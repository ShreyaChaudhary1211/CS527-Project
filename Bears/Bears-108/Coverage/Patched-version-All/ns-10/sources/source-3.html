


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DateTimeFormatterBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.joda.time.format</a>
</div>

<h1>Coverage Summary for Class: DateTimeFormatterBuilder (org.joda.time.format)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DateTimeFormatterBuilder</td>
<td class="coverageStat">
  <span class="percent">
    44.7%
  </span>
  <span class="absValue">
    (34/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.2%
  </span>
  <span class="absValue">
    (109/205)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$CharacterLiteral</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (16/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$Composite</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.7%
  </span>
  <span class="absValue">
    (46/66)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$FixedNumber</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.7%
  </span>
  <span class="absValue">
    (1/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$Fraction</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.8%
  </span>
  <span class="absValue">
    (7/90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$MatchingParser</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (43/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$NumberFormatter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.8%
  </span>
  <span class="absValue">
    (27/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$PaddedNumber</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.4%
  </span>
  <span class="absValue">
    (3/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$StringLiteral</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TextField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/77)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TimeZoneId</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TimeZoneName</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TimeZoneOffset</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14%
  </span>
  <span class="absValue">
    (20/143)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TwoDigitYear</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/98)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$UnpaddedNumber</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.4%
  </span>
  <span class="absValue">
    (2/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    40.1%
  </span>
  <span class="absValue">
    (67/167)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.5%
  </span>
  <span class="absValue">
    (280/888)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright 2001-2011 Stephen Colebourne
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package org.joda.time.format;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Writer;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.joda.time.Chronology;
&nbsp;import org.joda.time.DateTimeConstants;
&nbsp;import org.joda.time.DateTimeField;
&nbsp;import org.joda.time.DateTimeFieldType;
&nbsp;import org.joda.time.DateTimeUtils;
&nbsp;import org.joda.time.DateTimeZone;
&nbsp;import org.joda.time.MutableDateTime;
&nbsp;import org.joda.time.ReadablePartial;
&nbsp;import org.joda.time.MutableDateTime.Property;
&nbsp;import org.joda.time.field.MillisDurationField;
&nbsp;import org.joda.time.field.PreciseDateTimeField;
&nbsp;
&nbsp;/**
&nbsp; * Factory that creates complex instances of DateTimeFormatter via method calls.
&nbsp; * &lt;p&gt;
&nbsp; * Datetime formatting is performed by the {@link DateTimeFormatter} class.
&nbsp; * Three classes provide factory methods to create formatters, and this is one.
&nbsp; * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.
&nbsp; * &lt;p&gt;
&nbsp; * DateTimeFormatterBuilder is used for constructing formatters which are then
&nbsp; * used to print or parse. The formatters are built by appending specific fields
&nbsp; * or other formatters to an instance of this builder.
&nbsp; * &lt;p&gt;
&nbsp; * For example, a formatter that prints month and year, like &quot;January 1970&quot;,
&nbsp; * can be constructed as follows:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre&gt;
&nbsp; * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()
&nbsp; *     .appendMonthOfYearText()
&nbsp; *     .appendLiteral(&#39; &#39;)
&nbsp; *     .appendYear(4, 4)
&nbsp; *     .toFormatter();
&nbsp; * &lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the
&nbsp; * formatters that it builds are thread-safe and immutable.
&nbsp; *
&nbsp; * @author Brian S O&#39;Neill
&nbsp; * @author Stephen Colebourne
&nbsp; * @author Fredrik Borgh
&nbsp; * @since 1.0
&nbsp; * @see DateTimeFormat
&nbsp; * @see ISODateTimeFormat
&nbsp; */
&nbsp;public class DateTimeFormatterBuilder {
&nbsp;
&nbsp;    /** Array of printers and parsers (alternating). */
&nbsp;    private ArrayList&lt;Object&gt; iElementPairs;
&nbsp;    /** Cache of the last returned formatter. */
&nbsp;    private Object iFormatter;
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Creates a DateTimeFormatterBuilder.
&nbsp;     */
<b class="fc">&nbsp;    public DateTimeFormatterBuilder() {</b>
<b class="fc">&nbsp;        super();</b>
&nbsp;        iElementPairs = new ArrayList&lt;Object&gt;();
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Constructs a DateTimeFormatter using all the appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * This is the main method used by applications at the end of the build
&nbsp;     * process to create a usable formatter.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned formatter.
&nbsp;     * &lt;p&gt;
&nbsp;     * The returned formatter may not support both printing and parsing.
&nbsp;     * The methods {@link DateTimeFormatter#isPrinter()} and
&nbsp;     * {@link DateTimeFormatter#isParser()} will help you determine the state
&nbsp;     * of the formatter.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException if neither printing nor parsing is supported
&nbsp;     */
<b class="fc">&nbsp;    public DateTimeFormatter toFormatter() {</b>
<b class="fc">&nbsp;        Object f = getFormatter();</b>
<b class="fc">&nbsp;        DateTimePrinter printer = null;</b>
<b class="fc">&nbsp;        if (isPrinter(f)) {</b>
&nbsp;            printer = (DateTimePrinter) f;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        DateTimeParser parser = null;</b>
<b class="fc">&nbsp;        if (isParser(f)) {</b>
&nbsp;            parser = (DateTimeParser) f;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (printer != null || parser != null) {</b>
&nbsp;            return new DateTimeFormatter(printer, parser);
<b class="nc">&nbsp;        }</b>
&nbsp;        throw new UnsupportedOperationException(&quot;Both printing and parsing not supported&quot;);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal method to create a DateTimePrinter instance using all the
&nbsp;     * appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * Most applications will not use this method.
&nbsp;     * If you want a printer in an application, call {@link #toFormatter()}
&nbsp;     * and just use the printing API.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned printer.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException if printing is not supported
&nbsp;     */
<b class="nc">&nbsp;    public DateTimePrinter toPrinter() {</b>
<b class="nc">&nbsp;        Object f = getFormatter();</b>
<b class="nc">&nbsp;        if (isPrinter(f)) {</b>
<b class="nc">&nbsp;            return (DateTimePrinter) f;</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException(&quot;Printing is not supported&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal method to create a DateTimeParser instance using all the
&nbsp;     * appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * Most applications will not use this method.
&nbsp;     * If you want a parser in an application, call {@link #toFormatter()}
&nbsp;     * and just use the parsing API.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned parser.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException if parsing is not supported
&nbsp;     */
&nbsp;    public DateTimeParser toParser() {
<b class="fc">&nbsp;        Object f = getFormatter();</b>
<b class="fc">&nbsp;        if (isParser(f)) {</b>
<b class="fc">&nbsp;            return (DateTimeParser) f;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        throw new UnsupportedOperationException(&quot;Parsing is not supported&quot;);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Returns true if toFormatter can be called without throwing an
&nbsp;     * UnsupportedOperationException.
&nbsp;     * 
&nbsp;     * @return true if a formatter can be built
&nbsp;     */
&nbsp;    public boolean canBuildFormatter() {
&nbsp;        return isFormatter(getFormatter());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if toPrinter can be called without throwing an
&nbsp;     * UnsupportedOperationException.
&nbsp;     * 
&nbsp;     * @return true if a printer can be built
&nbsp;     */
&nbsp;    public boolean canBuildPrinter() {
&nbsp;        return isPrinter(getFormatter());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if toParser can be called without throwing an
&nbsp;     * UnsupportedOperationException.
&nbsp;     * 
&nbsp;     * @return true if a parser can be built
&nbsp;     */
&nbsp;    public boolean canBuildParser() {
&nbsp;        return isParser(getFormatter());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Clears out all the appended elements, allowing this builder to be
&nbsp;     * reused.
&nbsp;     */
&nbsp;    public void clear() {
&nbsp;        iFormatter = null;
<b class="nc">&nbsp;        iElementPairs.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Appends another formatter.
&nbsp;     * &lt;p&gt;
&nbsp;     * This extracts the underlying printer and parser and appends them
&nbsp;     * The printer and parser interfaces are the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @param formatter  the formatter to add
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if formatter is null or of an invalid type
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
&nbsp;        if (formatter == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No formatter supplied&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(formatter.getPrinter(), formatter.getParser());
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends just a printer. With no matching parser, a parser cannot be
&nbsp;     * built from this DateTimeFormatterBuilder.
&nbsp;     * &lt;p&gt;
&nbsp;     * The printer interface is part of the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @param printer  the printer to add, not null
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if printer is null or of an invalid type
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder append(DateTimePrinter printer) {
&nbsp;        checkPrinter(printer);
<b class="nc">&nbsp;        return append0(printer, null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends just a parser. With no matching printer, a printer cannot be
&nbsp;     * built from this builder.
&nbsp;     * &lt;p&gt;
&nbsp;     * The parser interface is part of the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @param parser  the parser to add, not null
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if parser is null or of an invalid type
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder append(DateTimeParser parser) {
&nbsp;        checkParser(parser);
<b class="fc">&nbsp;        return append0(null, parser);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends a printer/parser pair.
&nbsp;     * &lt;p&gt;
&nbsp;     * The printer and parser interfaces are the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @param printer  the printer to add, not null
&nbsp;     * @param parser  the parser to add, not null
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if printer or parser is null or of an invalid type
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {
&nbsp;        checkPrinter(printer);
<b class="nc">&nbsp;        checkParser(parser);</b>
<b class="nc">&nbsp;        return append0(printer, parser);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends a printer and a set of matching parsers. When parsing, the first
&nbsp;     * parser in the list is selected for parsing. If it fails, the next is
&nbsp;     * chosen, and so on. If none of these parsers succeeds, then the failed
&nbsp;     * position of the parser that made the greatest progress is returned.
&nbsp;     * &lt;p&gt;
&nbsp;     * Only the printer is optional. In addition, it is illegal for any but the
&nbsp;     * last of the parser array elements to be null. If the last element is
&nbsp;     * null, this represents the empty parser. The presence of an empty parser
&nbsp;     * indicates that the entire array of parse formats is optional.
&nbsp;     * &lt;p&gt;
&nbsp;     * The printer and parser interfaces are the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @param printer  the printer to add
&nbsp;     * @param parsers  the parsers to add
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if any printer or parser is of an invalid type
&nbsp;     * @throws IllegalArgumentException if any parser element but the last is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
&nbsp;        if (printer != null) {
<b class="fc">&nbsp;            checkPrinter(printer);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (parsers == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No parsers supplied&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        int length = parsers.length;
<b class="fc">&nbsp;        if (length == 1) {</b>
<b class="fc">&nbsp;            if (parsers[0] == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;No parser supplied&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            return append0(printer, parsers[0]);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        DateTimeParser[] copyOfParsers = new DateTimeParser[length];
<b class="fc">&nbsp;        int i;</b>
&nbsp;        for (i = 0; i &lt; length - 1; i++) {
<b class="fc">&nbsp;            if ((copyOfParsers[i] = parsers[i]) == null) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Incomplete parser array&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        copyOfParsers[i] = parsers[i];
<b class="fc">&nbsp;</b>
&nbsp;        return append0(printer, new MatchingParser(copyOfParsers));
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends just a parser element which is optional. With no matching
&nbsp;     * printer, a printer cannot be built from this DateTimeFormatterBuilder.
&nbsp;     * &lt;p&gt;
&nbsp;     * The parser interface is part of the low-level part of the formatting API.
&nbsp;     * Normally, instances are extracted from another formatter.
&nbsp;     * Note however that any formatter specific information, such as the locale,
&nbsp;     * time-zone, chronology, offset parsing or pivot/default year, will not be
&nbsp;     * extracted by this method.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if parser is null or of an invalid type
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
&nbsp;        checkParser(parser);
<b class="fc">&nbsp;        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};</b>
<b class="fc">&nbsp;        return append0(null, new MatchingParser(parsers));</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Checks if the parser is non null and a provider.
&nbsp;     * 
&nbsp;     * @param parser  the parser to check
&nbsp;     */
&nbsp;    private void checkParser(DateTimeParser parser) {
&nbsp;        if (parser == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No parser supplied&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the printer is non null and a provider.
&nbsp;     * 
&nbsp;     * @param printer  the printer to check
&nbsp;     */
&nbsp;    private void checkPrinter(DateTimePrinter printer) {
&nbsp;        if (printer == null) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No printer supplied&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private DateTimeFormatterBuilder append0(Object element) {
&nbsp;        iFormatter = null;
<b class="fc">&nbsp;        // Add the element as both a printer and parser.</b>
&nbsp;        iElementPairs.add(element);
<b class="fc">&nbsp;        iElementPairs.add(element);</b>
<b class="fc">&nbsp;        return this;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private DateTimeFormatterBuilder append0(
&nbsp;            DateTimePrinter printer, DateTimeParser parser) {
&nbsp;        iFormatter = null;
<b class="fc">&nbsp;        iElementPairs.add(printer);</b>
<b class="fc">&nbsp;        iElementPairs.add(parser);</b>
<b class="fc">&nbsp;        return this;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a specific character, and the parser to
&nbsp;     * expect it. The parser is case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendLiteral(char c) {
&nbsp;        return append0(new CharacterLiteral(c));
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit specific text, and the parser to expect
&nbsp;     * it. The parser is case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if text is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendLiteral(String text) {
&nbsp;        if (text == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Literal must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        switch (text.length()) {
<b class="fc">&nbsp;            case 0:</b>
&nbsp;                return this;
<b class="nc">&nbsp;            case 1:</b>
&nbsp;                return append0(new CharacterLiteral(text.charAt(0)));
<b class="nc">&nbsp;            default:</b>
&nbsp;                return append0(new StringLiteral(text));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as a decimal number, and the
&nbsp;     * parser to expect an unsigned decimal number.
&nbsp;     *
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @param minDigits  minimum number of digits to &lt;i&gt;print&lt;/i&gt;
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDecimal(
&nbsp;            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
&nbsp;        if (fieldType == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (maxDigits &lt; minDigits) {
<b class="fc">&nbsp;            maxDigits = minDigits;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (minDigits &lt; 0 || maxDigits &lt;= 0) {
<b class="fc">&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (minDigits &lt;= 1) {
<b class="fc">&nbsp;            return append0(new UnpaddedNumber(fieldType, maxDigits, false));</b>
<b class="fc">&nbsp;        } else {</b>
&nbsp;            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as a fixed-width decimal
&nbsp;     * number (smaller numbers will be left-padded with zeros), and the parser
&nbsp;     * to expect an unsigned decimal number with the same fixed width.
&nbsp;     * 
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @param numDigits  the exact number of digits to parse or print, except if
&nbsp;     * printed value requires more digits
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null or if &lt;code&gt;numDigits &lt;= 0&lt;/code&gt;
&nbsp;     * @since 1.5
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFixedDecimal(
&nbsp;            DateTimeFieldType fieldType, int numDigits) {
&nbsp;        if (fieldType == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (numDigits &lt;= 0) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Illegal number of digits: &quot; + numDigits);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(new FixedNumber(fieldType, numDigits, false));
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as a decimal number, and the
&nbsp;     * parser to expect a signed decimal number.
&nbsp;     *
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @param minDigits  minimum number of digits to &lt;i&gt;print&lt;/i&gt;
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendSignedDecimal(
&nbsp;            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
&nbsp;        if (fieldType == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (maxDigits &lt; minDigits) {
<b class="fc">&nbsp;            maxDigits = minDigits;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (minDigits &lt; 0 || maxDigits &lt;= 0) {
<b class="fc">&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (minDigits &lt;= 1) {
<b class="fc">&nbsp;            return append0(new UnpaddedNumber(fieldType, maxDigits, true));</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as a fixed-width decimal
&nbsp;     * number (smaller numbers will be left-padded with zeros), and the parser
&nbsp;     * to expect an signed decimal number with the same fixed width.
&nbsp;     * 
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @param numDigits  the exact number of digits to parse or print, except if
&nbsp;     * printed value requires more digits
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null or if &lt;code&gt;numDigits &lt;= 0&lt;/code&gt;
&nbsp;     * @since 1.5
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFixedSignedDecimal(
&nbsp;            DateTimeFieldType fieldType, int numDigits) {
&nbsp;        if (fieldType == null) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (numDigits &lt;= 0) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Illegal number of digits: &quot; + numDigits);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(new FixedNumber(fieldType, numDigits, true));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as text, and the
&nbsp;     * parser to expect text.
&nbsp;     *
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {
&nbsp;        if (fieldType == null) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(new TextField(fieldType, false));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a field value as short text, and the
&nbsp;     * parser to expect text.
&nbsp;     *
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {
&nbsp;        if (fieldType == null) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(new TextField(fieldType, true));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a remainder of time as a decimal fraction,
&nbsp;     * without decimal point. For example, if the field is specified as
&nbsp;     * minuteOfHour and the time is 12:30:45, the value printed is 75. A
&nbsp;     * decimal point is implied, so the fraction is 0.75, or three-quarters of
&nbsp;     * a minute.
&nbsp;     *
&nbsp;     * @param fieldType  type of field to append
&nbsp;     * @param minDigits  minimum number of digits to print.
&nbsp;     * @param maxDigits  maximum number of digits to print or parse.
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @throws IllegalArgumentException if field type is null
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFraction(
&nbsp;            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
&nbsp;        if (fieldType == null) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Field type must not be null&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (maxDigits &lt; minDigits) {
<b class="fc">&nbsp;            maxDigits = minDigits;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (minDigits &lt; 0 || maxDigits &lt;= 0) {
<b class="fc">&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return append0(new Fraction(fieldType, minDigits, maxDigits));
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the print/parse of a fractional second.
&nbsp;     * &lt;p&gt;
&nbsp;     * This reliably handles the case where fractional digits are being handled
&nbsp;     * beyond a visible decimal point. The digits parsed will always be treated
&nbsp;     * as the most significant (numerically largest) digits.
&nbsp;     * Thus &#39;23&#39; will be parsed as 230 milliseconds.
&nbsp;     * Contrast this behaviour to {@link #appendMillisOfSecond}.
&nbsp;     * This method does not print or parse the decimal point itself.
&nbsp;     * 
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to print or parse
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
&nbsp;        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the print/parse of a fractional minute.
&nbsp;     * &lt;p&gt;
&nbsp;     * This reliably handles the case where fractional digits are being handled
&nbsp;     * beyond a visible decimal point. The digits parsed will always be treated
&nbsp;     * as the most significant (numerically largest) digits.
&nbsp;     * Thus &#39;23&#39; will be parsed as 0.23 minutes (converted to milliseconds).
&nbsp;     * This method does not print or parse the decimal point itself.
&nbsp;     * 
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to print or parse
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {
&nbsp;        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the print/parse of a fractional hour.
&nbsp;     * &lt;p&gt;
&nbsp;     * This reliably handles the case where fractional digits are being handled
&nbsp;     * beyond a visible decimal point. The digits parsed will always be treated
&nbsp;     * as the most significant (numerically largest) digits.
&nbsp;     * Thus &#39;23&#39; will be parsed as 0.23 hours (converted to milliseconds).
&nbsp;     * This method does not print or parse the decimal point itself.
&nbsp;     * 
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to print or parse
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {
&nbsp;        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the print/parse of a fractional day.
&nbsp;     * &lt;p&gt;
&nbsp;     * This reliably handles the case where fractional digits are being handled
&nbsp;     * beyond a visible decimal point. The digits parsed will always be treated
&nbsp;     * as the most significant (numerically largest) digits.
&nbsp;     * Thus &#39;23&#39; will be parsed as 0.23 days (converted to milliseconds).
&nbsp;     * This method does not print or parse the decimal point itself.
&nbsp;     * 
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to print or parse
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {
&nbsp;        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric millisOfSecond field.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method will append a field that prints a three digit value.
&nbsp;     * During parsing the value that is parsed is assumed to be three digits.
&nbsp;     * If less than three digits are present then they will be counted as the
&nbsp;     * smallest parts of the millisecond. This is probably not what you want
&nbsp;     * if you are using the field as a fraction. Instead, a fractional
&nbsp;     * millisecond should be produced using {@link #appendFractionOfSecond}.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric millisOfDay field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric secondOfMinute field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric secondOfDay field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric minuteOfHour field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric minuteOfDay field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric hourOfDay field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric clockhourOfDay field.
&nbsp;     *
&nbsp;     * @param minDigits minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric hourOfHalfday field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric clockhourOfHalfday field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric dayOfWeek field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric dayOfMonth field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric dayOfYear field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric weekOfWeekyear field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric weekyear field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to &lt;i&gt;print&lt;/i&gt;
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
&nbsp;        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric monthOfYear field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric year field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to &lt;i&gt;print&lt;/i&gt;
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
&nbsp;        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric year field which always prints
&nbsp;     * and parses two digits. A pivot year is used during parsing to determine
&nbsp;     * the range of supported years as &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;.
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * pivot   supported range   00 is   20 is   40 is   60 is   80 is
&nbsp;     * ---------------------------------------------------------------
&nbsp;     * 1950      1900..1999      1900    1920    1940    1960    1980
&nbsp;     * 1975      1925..2024      2000    2020    1940    1960    1980
&nbsp;     * 2000      1950..2049      2000    2020    2040    1960    1980
&nbsp;     * 2025      1975..2074      2000    2020    2040    2060    1980
&nbsp;     * 2050      2000..2099      2000    2020    2040    2060    2080
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param pivot  pivot year to use when parsing
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {
&nbsp;        return appendTwoDigitYear(pivot, false);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric year field which always prints
&nbsp;     * two digits. A pivot year is used during parsing to determine the range
&nbsp;     * of supported years as &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;. If
&nbsp;     * parse is instructed to be lenient and the digit count is not two, it is
&nbsp;     * treated as an absolute year. With lenient parsing, specifying a positive
&nbsp;     * or negative sign before the year also makes it absolute.
&nbsp;     *
&nbsp;     * @param pivot  pivot year to use when parsing
&nbsp;     * @param lenientParse  when true, if digit count is not two, it is treated
&nbsp;     * as an absolute year
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @since 1.1
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {
&nbsp;        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric weekyear field which always prints
&nbsp;     * and parses two digits. A pivot year is used during parsing to determine
&nbsp;     * the range of supported years as &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;.
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * pivot   supported range   00 is   20 is   40 is   60 is   80 is
&nbsp;     * ---------------------------------------------------------------
&nbsp;     * 1950      1900..1999      1900    1920    1940    1960    1980
&nbsp;     * 1975      1925..2024      2000    2020    1940    1960    1980
&nbsp;     * 2000      1950..2049      2000    2020    2040    1960    1980
&nbsp;     * 2025      1975..2074      2000    2020    2040    2060    1980
&nbsp;     * 2050      2000..2099      2000    2020    2040    2060    2080
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param pivot  pivot weekyear to use when parsing
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {
&nbsp;        return appendTwoDigitWeekyear(pivot, false);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric weekyear field which always prints
&nbsp;     * two digits. A pivot year is used during parsing to determine the range
&nbsp;     * of supported years as &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;. If
&nbsp;     * parse is instructed to be lenient and the digit count is not two, it is
&nbsp;     * treated as an absolute weekyear. With lenient parsing, specifying a positive
&nbsp;     * or negative sign before the weekyear also makes it absolute.
&nbsp;     *
&nbsp;     * @param pivot  pivot weekyear to use when parsing
&nbsp;     * @param lenientParse  when true, if digit count is not two, it is treated
&nbsp;     * as an absolute weekyear
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @since 1.1
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {
&nbsp;        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric yearOfEra field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to &lt;i&gt;print&lt;/i&gt;
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric year of century field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {
&nbsp;        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a numeric century of era field.
&nbsp;     *
&nbsp;     * @param minDigits  minimum number of digits to print
&nbsp;     * @param maxDigits  maximum number of digits to &lt;i&gt;parse&lt;/i&gt;, or the estimated
&nbsp;     * maximum number of digits to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {
&nbsp;        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific AM/PM text, and the
&nbsp;     * parser to expect it. The parser is case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendHalfdayOfDayText() {
&nbsp;        return appendText(DateTimeFieldType.halfdayOfDay());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific dayOfWeek text. The
&nbsp;     * parser will accept a long or short dayOfWeek text, case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDayOfWeekText() {
&nbsp;        return appendText(DateTimeFieldType.dayOfWeek());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a short locale-specific dayOfWeek
&nbsp;     * text. The parser will accept a long or short dayOfWeek text,
&nbsp;     * case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendDayOfWeekShortText() {
&nbsp;        return appendShortText(DateTimeFieldType.dayOfWeek());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a short locale-specific monthOfYear
&nbsp;     * text. The parser will accept a long or short monthOfYear text,
&nbsp;     * case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMonthOfYearText() { 
&nbsp;        return appendText(DateTimeFieldType.monthOfYear());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific monthOfYear text. The
&nbsp;     * parser will accept a long or short monthOfYear text, case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendMonthOfYearShortText() {
&nbsp;        return appendShortText(DateTimeFieldType.monthOfYear());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific era text (BC/AD), and
&nbsp;     * the parser to expect it. The parser is case-insensitive.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendEraText() {
&nbsp;        return appendText(DateTimeFieldType.era());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific time zone name.
&nbsp;     * Using this method prevents parsing, because time zone names are not unique.
&nbsp;     * See {@link #appendTimeZoneName(Map)}.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneName() {
&nbsp;        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.
&nbsp;     * Time zone names are not unique, thus the API forces you to supply the lookup.
&nbsp;     * The names are searched in the order of the map, thus it is strongly recommended
&nbsp;     * to use a {@code LinkedHashMap} or similar.
&nbsp;     *
&nbsp;     * @param parseLookup  the table of names, not null
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneName(Map&lt;String, DateTimeZone&gt; parseLookup) {
&nbsp;        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);
<b class="nc">&nbsp;        return append0(pp, pp);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a short locale-specific time zone name.
&nbsp;     * Using this method prevents parsing, because time zone names are not unique.
&nbsp;     * See {@link #appendTimeZoneShortName(Map)}.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneShortName() {
&nbsp;        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit a short locale-specific time zone
&nbsp;     * name, providing a lookup for parsing.
&nbsp;     * Time zone names are not unique, thus the API forces you to supply the lookup.
&nbsp;     * The names are searched in the order of the map, thus it is strongly recommended
&nbsp;     * to use a {@code LinkedHashMap} or similar.
&nbsp;     *
&nbsp;     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneShortName(Map&lt;String, DateTimeZone&gt; parseLookup) {
&nbsp;        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);
<b class="nc">&nbsp;        return append0(pp, pp);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit the identifier of the time zone.
&nbsp;     * From version 2.0, this field can be parsed.
&nbsp;     *
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneId() {
&nbsp;        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit text and numbers to display time zone
&nbsp;     * offset from UTC. A parser will use the parsed time zone offset to adjust
&nbsp;     * the datetime.
&nbsp;     * &lt;p&gt;
&nbsp;     * If zero offset text is supplied, then it will be printed when the zone is zero.
&nbsp;     * During parsing, either the zero offset text, or the offset will be parsed.
&nbsp;     *
&nbsp;     * @param zeroOffsetText  the text to use if time zone offset is zero. If
&nbsp;     * null, offset is always shown.
&nbsp;     * @param showSeparators  if true, prints &#39;:&#39; separator before minute and
&nbsp;     * second field and prints &#39;.&#39; separator before fraction field.
&nbsp;     * @param minFields  minimum number of fields to print, stopping when no
&nbsp;     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
&nbsp;     * @param maxFields  maximum number of fields to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneOffset(
&nbsp;            String zeroOffsetText, boolean showSeparators,
&nbsp;            int minFields, int maxFields) {
&nbsp;        return append0(new TimeZoneOffset
<b class="fc">&nbsp;                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit text and numbers to display time zone
&nbsp;     * offset from UTC. A parser will use the parsed time zone offset to adjust
&nbsp;     * the datetime.
&nbsp;     * &lt;p&gt;
&nbsp;     * If zero offset print text is supplied, then it will be printed when the zone is zero.
&nbsp;     * If zero offset parse text is supplied, then either it or the offset will be parsed.
&nbsp;     *
&nbsp;     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If
&nbsp;     * null, offset is always shown.
&nbsp;     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time
&nbsp;     * zone offset is zero. If null, then always use the offset.
&nbsp;     * @param showSeparators  if true, prints &#39;:&#39; separator before minute and
&nbsp;     * second field and prints &#39;.&#39; separator before fraction field.
&nbsp;     * @param minFields  minimum number of fields to print, stopping when no
&nbsp;     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
&nbsp;     * @param maxFields  maximum number of fields to print
&nbsp;     * @return this DateTimeFormatterBuilder, for chaining
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendTimeZoneOffset(
&nbsp;            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,
&nbsp;            int minFields, int maxFields) {
&nbsp;        return append0(new TimeZoneOffset
<b class="nc">&nbsp;                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Calls upon {@link DateTimeFormat} to parse the pattern and append the
&nbsp;     * results into this builder.
&nbsp;     *
&nbsp;     * @param pattern  pattern specification
&nbsp;     * @throws IllegalArgumentException if the pattern is invalid
&nbsp;     * @see DateTimeFormat
&nbsp;     */
&nbsp;    public DateTimeFormatterBuilder appendPattern(String pattern) {
&nbsp;        DateTimeFormat.appendPatternTo(this, pattern);
<b class="nc">&nbsp;        return this;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    private Object getFormatter() {
&nbsp;        Object f = iFormatter;
<b class="fc">&nbsp;</b>
&nbsp;        if (f == null) {
<b class="fc">&nbsp;            if (iElementPairs.size() == 2) {</b>
<b class="fc">&nbsp;                Object printer = iElementPairs.get(0);</b>
<b class="fc">&nbsp;                Object parser = iElementPairs.get(1);</b>
<b class="fc">&nbsp;</b>
&nbsp;                if (printer != null) {
<b class="fc">&nbsp;                    if (printer == parser || parser == null) {</b>
<b class="fc">&nbsp;                        f = printer;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } else {
&nbsp;                    f = parser;
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            if (f == null) {
<b class="fc">&nbsp;                f = new Composite(iElementPairs);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            iFormatter = f;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        return f;
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean isPrinter(Object f) {
&nbsp;        if (f instanceof DateTimePrinter) {
<b class="fc">&nbsp;            if (f instanceof Composite) {</b>
<b class="fc">&nbsp;                return ((Composite)f).isPrinter();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            return true;
<b class="fc">&nbsp;        }</b>
&nbsp;        return false;
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean isParser(Object f) {
&nbsp;        if (f instanceof DateTimeParser) {
<b class="fc">&nbsp;            if (f instanceof Composite) {</b>
<b class="fc">&nbsp;                return ((Composite)f).isParser();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            return true;
<b class="fc">&nbsp;        }</b>
&nbsp;        return false;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean isFormatter(Object f) {
&nbsp;        return (isPrinter(f) || isParser(f));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    static void appendUnknownString(StringBuffer buf, int len) {
&nbsp;        for (int i = len; --i &gt;= 0;) {
<b class="nc">&nbsp;            buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    static void printUnknownString(Writer out, int len) throws IOException {
&nbsp;        for (int i = len; --i &gt;= 0;) {
&nbsp;            out.write(&#39;\ufffd&#39;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class CharacterLiteral
<b class="fc">&nbsp;            implements DateTimePrinter, DateTimeParser {</b>
<b class="fc">&nbsp;</b>
&nbsp;        private final char iValue;
&nbsp;
&nbsp;        CharacterLiteral(char value) {
<b class="fc">&nbsp;            super();</b>
&nbsp;            iValue = value;
&nbsp;        }
&nbsp;
&nbsp;        public int estimatePrintedLength() {
&nbsp;            return 1;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
<b class="nc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {</b>
&nbsp;            buf.append(iValue);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public void printTo(</b>
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
&nbsp;            out.write(iValue);
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
&nbsp;            buf.append(iValue);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
<b class="fc">&nbsp;            out.write(iValue);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public int estimateParsedLength() {</b>
<b class="fc">&nbsp;            return 1;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {</b>
&nbsp;            if (position &gt;= text.length()) {
&nbsp;                return ~position;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            char a = text.charAt(position);</b>
&nbsp;            char b = iValue;
&nbsp;
&nbsp;            if (a != b) {
&nbsp;                a = Character.toUpperCase(a);
&nbsp;                b = Character.toUpperCase(b);
&nbsp;                if (a != b) {
&nbsp;                    a = Character.toLowerCase(a);
&nbsp;                    b = Character.toLowerCase(b);
&nbsp;                    if (a != b) {
&nbsp;                        return ~position;
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            return position + 1;
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class StringLiteral
&nbsp;            implements DateTimePrinter, DateTimeParser {
<b class="nc">&nbsp;</b>
&nbsp;        private final String iValue;
&nbsp;
&nbsp;        StringLiteral(String value) {
<b class="nc">&nbsp;            super();</b>
&nbsp;            iValue = value;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public int estimatePrintedLength() {</b>
&nbsp;            return iValue.length();
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public void printTo(</b>
<b class="nc">&nbsp;                StringBuffer buf, long instant, Chronology chrono,</b>
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="fc">&nbsp;            buf.append(iValue);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
&nbsp;            out.write(iValue);
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
&nbsp;            buf.append(iValue);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {</b>
<b class="fc">&nbsp;            out.write(iValue);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public int estimateParsedLength() {
&nbsp;            return iValue.length();
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
&nbsp;            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {
&nbsp;                return position + iValue.length();
<b class="fc">&nbsp;            }</b>
&nbsp;            return ~position;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    //-----------------------------------------------------------------------</b>
<b class="fc">&nbsp;    static abstract class NumberFormatter</b>
<b class="fc">&nbsp;            implements DateTimePrinter, DateTimeParser {</b>
<b class="nc">&nbsp;        protected final DateTimeFieldType iFieldType;</b>
<b class="nc">&nbsp;        protected final int iMaxParsedDigits;</b>
&nbsp;        protected final boolean iSigned;
&nbsp;
<b class="nc">&nbsp;        NumberFormatter(DateTimeFieldType fieldType,</b>
&nbsp;                int maxParsedDigits, boolean signed) {
<b class="nc">&nbsp;            super();</b>
&nbsp;            iFieldType = fieldType;
<b class="nc">&nbsp;            iMaxParsedDigits = maxParsedDigits;</b>
&nbsp;            iSigned = signed;
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int estimateParsedLength() {</b>
&nbsp;            return iMaxParsedDigits;
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
<b class="fc">&nbsp;            int limit = Math.min(iMaxParsedDigits, text.length() - position);</b>
<b class="fc">&nbsp;</b>
&nbsp;            boolean negative = false;
<b class="fc">&nbsp;            int length = 0;</b>
<b class="nc">&nbsp;            while (length &lt; limit) {</b>
&nbsp;                char c = text.charAt(position + length);
&nbsp;                if (length == 0 &amp;&amp; (c == &#39;-&#39; || c == &#39;+&#39;) &amp;&amp; iSigned) {
&nbsp;                    negative = c == &#39;-&#39;;
<b class="fc">&nbsp;</b>
&nbsp;                    // Next character must be a digit.
&nbsp;                    if (length + 1 &gt;= limit || 
<b class="nc">&nbsp;                        (c = text.charAt(position + length + 1)) &lt; &#39;0&#39; || c &gt; &#39;9&#39;)</b>
<b class="nc">&nbsp;                    {</b>
&nbsp;                        break;
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    if (negative) {
&nbsp;                        length++;
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        // Skip the &#39;+&#39; for parseInt to succeed.</b>
<b class="nc">&nbsp;                        position++;</b>
&nbsp;                    }
&nbsp;                    // Expand the limit to disregard the sign character.
<b class="fc">&nbsp;                    limit = Math.min(limit + 1, text.length() - position);</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="fc">&nbsp;                    break;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                length++;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;            if (length == 0) {</b>
&nbsp;                return ~position;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            int value;</b>
<b class="fc">&nbsp;            if (length &gt;= 9) {</b>
&nbsp;                // Since value may exceed integer limits, use stock parser
&nbsp;                // which checks for this.
&nbsp;                value = Integer.parseInt(text.substring(position, position += length));
&nbsp;            } else {
&nbsp;                int i = position;
&nbsp;                if (negative) {
&nbsp;                    i++;
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    value = text.charAt(i++) - &#39;0&#39;;</b>
&nbsp;                } catch (StringIndexOutOfBoundsException e) {
&nbsp;                    return ~position;
&nbsp;                }
<b class="fc">&nbsp;                position += length;</b>
&nbsp;                while (i &lt; position) {
&nbsp;                    value = ((value &lt;&lt; 3) + (value &lt;&lt; 1)) + text.charAt(i++) - &#39;0&#39;;
&nbsp;                }
&nbsp;                if (negative) {
&nbsp;                    value = -value;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            bucket.saveField(iFieldType, value);</b>
<b class="nc">&nbsp;            return position;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
<b class="nc">&nbsp;    static class UnpaddedNumber extends NumberFormatter {</b>
&nbsp;
<b class="nc">&nbsp;        protected UnpaddedNumber(DateTimeFieldType fieldType,</b>
<b class="nc">&nbsp;                       int maxParsedDigits, boolean signed)</b>
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            super(fieldType, maxParsedDigits, signed);</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public int estimatePrintedLength() {
&nbsp;            return iMaxParsedDigits;
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
&nbsp;            try {
&nbsp;                DateTimeField field = iFieldType.getField(chrono);
&nbsp;                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));
&nbsp;            } catch (RuntimeException e) {
&nbsp;                buf.append(&#39;\ufffd&#39;);
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
<b class="fc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {</b>
&nbsp;            try {
&nbsp;                DateTimeField field = iFieldType.getField(chrono);
&nbsp;                FormatUtils.writeUnpaddedInteger(out, field.get(instant));
&nbsp;            } catch (RuntimeException e) {
&nbsp;                out.write(&#39;\ufffd&#39;);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {</b>
<b class="nc">&nbsp;            if (partial.isSupported(iFieldType)) {</b>
<b class="nc">&nbsp;                try {</b>
&nbsp;                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));
&nbsp;                } catch (RuntimeException e) {
&nbsp;                    buf.append(&#39;\ufffd&#39;);
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
<b class="nc">&nbsp;            if (partial.isSupported(iFieldType)) {</b>
&nbsp;                try {
&nbsp;                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
&nbsp;                } catch (RuntimeException e) {
&nbsp;                    out.write(&#39;\ufffd&#39;);
&nbsp;                }
&nbsp;            } else {
&nbsp;                out.write(&#39;\ufffd&#39;);
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class PaddedNumber extends NumberFormatter {
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected final int iMinPrintedDigits;</b>
<b class="nc">&nbsp;</b>
&nbsp;        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,
<b class="nc">&nbsp;                     boolean signed, int minPrintedDigits)</b>
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            super(fieldType, maxParsedDigits, signed);</b>
<b class="nc">&nbsp;            iMinPrintedDigits = minPrintedDigits;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public int estimatePrintedLength() {
&nbsp;            return iMaxParsedDigits;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public void printTo(</b>
<b class="nc">&nbsp;                StringBuffer buf, long instant, Chronology chrono,</b>
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="nc">&nbsp;            try {</b>
&nbsp;                DateTimeField field = iFieldType.getField(chrono);
&nbsp;                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
&nbsp;                appendUnknownString(buf, iMinPrintedDigits);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
&nbsp;            try {
&nbsp;                DateTimeField field = iFieldType.getField(chrono);
&nbsp;                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);
&nbsp;            } catch (RuntimeException e) {
&nbsp;                printUnknownString(out, iMinPrintedDigits);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
&nbsp;            if (partial.isSupported(iFieldType)) {
&nbsp;                try {
&nbsp;                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);
&nbsp;                } catch (RuntimeException e) {
&nbsp;                    appendUnknownString(buf, iMinPrintedDigits);
&nbsp;                }
&nbsp;            } else {
&nbsp;                appendUnknownString(buf, iMinPrintedDigits);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
&nbsp;            if (partial.isSupported(iFieldType)) {
&nbsp;                try {
&nbsp;                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
&nbsp;                } catch (RuntimeException e) {
&nbsp;                    printUnknownString(out, iMinPrintedDigits);
&nbsp;                }
&nbsp;            } else {
&nbsp;                printUnknownString(out, iMinPrintedDigits);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class FixedNumber extends PaddedNumber {
&nbsp;
&nbsp;        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {
&nbsp;            super(fieldType, numDigits, signed, numDigits);
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
&nbsp;            int newPos = super.parseInto(bucket, text, position);
&nbsp;            if (newPos &lt; 0) {
&nbsp;                return newPos;
&nbsp;            }
&nbsp;            int expectedPos = position + iMaxParsedDigits;
&nbsp;            if (newPos != expectedPos) {
&nbsp;                if (iSigned) {
&nbsp;                    char c = text.charAt(position);
&nbsp;                    if (c == &#39;-&#39; || c == &#39;+&#39;) {
&nbsp;                        expectedPos++;
&nbsp;                    }
&nbsp;                }
&nbsp;                if (newPos &gt; expectedPos) {
&nbsp;                    // The failure is at the position of the first extra digit.
&nbsp;                    return ~(expectedPos + 1);
&nbsp;                } else if (newPos &lt; expectedPos) {
&nbsp;                    // The failure is at the position where the next digit should be.
&nbsp;                    return ~newPos;
&nbsp;                }
&nbsp;            }
&nbsp;            return newPos;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class TwoDigitYear
&nbsp;            implements DateTimePrinter, DateTimeParser {
&nbsp;
&nbsp;        /** The field to print/parse. */
&nbsp;        private final DateTimeFieldType iType;
&nbsp;        /** The pivot year. */
&nbsp;        private final int iPivot;
&nbsp;        private final boolean iLenientParse;
&nbsp;
&nbsp;        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {
<b class="nc">&nbsp;            super();</b>
<b class="nc">&nbsp;            iType = type;</b>
<b class="nc">&nbsp;            iPivot = pivot;</b>
<b class="nc">&nbsp;            iLenientParse = lenientParse;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int estimateParsedLength() {
<b class="nc">&nbsp;            return iLenientParse ? 4 : 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
<b class="nc">&nbsp;            int limit = text.length() - position;</b>
&nbsp;
<b class="nc">&nbsp;            if (!iLenientParse) {</b>
<b class="nc">&nbsp;                limit = Math.min(2, limit);</b>
<b class="nc">&nbsp;                if (limit &lt; 2) {</b>
<b class="nc">&nbsp;                    return ~position;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                boolean hasSignChar = false;</b>
<b class="nc">&nbsp;                boolean negative = false;</b>
<b class="nc">&nbsp;                int length = 0;</b>
<b class="nc">&nbsp;                while (length &lt; limit) {</b>
<b class="nc">&nbsp;                    char c = text.charAt(position + length);</b>
<b class="nc">&nbsp;                    if (length == 0 &amp;&amp; (c == &#39;-&#39; || c == &#39;+&#39;)) {</b>
<b class="nc">&nbsp;                        hasSignChar = true;</b>
<b class="nc">&nbsp;                        negative = c == &#39;-&#39;;</b>
<b class="nc">&nbsp;                        if (negative) {</b>
<b class="nc">&nbsp;                            length++;</b>
&nbsp;                        } else {
&nbsp;                            // Skip the &#39;+&#39; for parseInt to succeed.
<b class="nc">&nbsp;                            position++;</b>
<b class="nc">&nbsp;                            limit--;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    length++;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                
<b class="nc">&nbsp;                if (length == 0) {</b>
<b class="nc">&nbsp;                    return ~position;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (hasSignChar || length != 2) {</b>
&nbsp;                    int value;
<b class="nc">&nbsp;                    if (length &gt;= 9) {</b>
&nbsp;                        // Since value may exceed integer limits, use stock
&nbsp;                        // parser which checks for this.
<b class="nc">&nbsp;                        value = Integer.parseInt(text.substring(position, position += length));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        int i = position;</b>
<b class="nc">&nbsp;                        if (negative) {</b>
<b class="nc">&nbsp;                            i++;</b>
&nbsp;                        }
&nbsp;                        try {
<b class="nc">&nbsp;                            value = text.charAt(i++) - &#39;0&#39;;</b>
<b class="nc">&nbsp;                        } catch (StringIndexOutOfBoundsException e) {</b>
<b class="nc">&nbsp;                            return ~position;</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        position += length;</b>
<b class="nc">&nbsp;                        while (i &lt; position) {</b>
<b class="nc">&nbsp;                            value = ((value &lt;&lt; 3) + (value &lt;&lt; 1)) + text.charAt(i++) - &#39;0&#39;;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (negative) {</b>
<b class="nc">&nbsp;                            value = -value;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    bucket.saveField(iType, value);</b>
<b class="nc">&nbsp;                    return position;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            int year;
<b class="nc">&nbsp;            char c = text.charAt(position);</b>
<b class="nc">&nbsp;            if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="nc">&nbsp;                return ~position;</b>
&nbsp;            }
<b class="nc">&nbsp;            year = c - &#39;0&#39;;</b>
<b class="nc">&nbsp;            c = text.charAt(position + 1);</b>
<b class="nc">&nbsp;            if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="nc">&nbsp;                return ~position;</b>
&nbsp;            }
<b class="nc">&nbsp;            year = ((year &lt;&lt; 3) + (year &lt;&lt; 1)) + c - &#39;0&#39;;</b>
&nbsp;
<b class="nc">&nbsp;            int pivot = iPivot;</b>
&nbsp;            // If the bucket pivot year is non-null, use that when parsing
<b class="nc">&nbsp;            if (bucket.getPivotYear() != null) {</b>
<b class="nc">&nbsp;                pivot = bucket.getPivotYear().intValue();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int low = pivot - 50;</b>
&nbsp;
&nbsp;            int t;
<b class="nc">&nbsp;            if (low &gt;= 0) {</b>
<b class="nc">&nbsp;                t = low % 100;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                t = 99 + ((low + 1) % 100);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            year += low + ((year &lt; t) ? 100 : 0) - t;</b>
&nbsp;
<b class="nc">&nbsp;            bucket.saveField(iType, year);</b>
<b class="nc">&nbsp;            return position + 2;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public int estimatePrintedLength() {
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="nc">&nbsp;            int year = getTwoDigitYear(instant, chrono);</b>
<b class="nc">&nbsp;            if (year &lt; 0) {</b>
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.appendPaddedInteger(buf, year, 2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
<b class="nc">&nbsp;            int year = getTwoDigitYear(instant, chrono);</b>
<b class="nc">&nbsp;            if (year &lt; 0) {</b>
<b class="nc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.writePaddedInteger(out, year, 2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private int getTwoDigitYear(long instant, Chronology chrono) {
&nbsp;            try {
<b class="nc">&nbsp;                int year = iType.getField(chrono).get(instant);</b>
<b class="nc">&nbsp;                if (year &lt; 0) {</b>
<b class="nc">&nbsp;                    year = -year;</b>
&nbsp;                }
<b class="nc">&nbsp;                return year % 100;</b>
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
<b class="nc">&nbsp;            int year = getTwoDigitYear(partial);</b>
<b class="nc">&nbsp;            if (year &lt; 0) {</b>
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.appendPaddedInteger(buf, year, 2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
<b class="nc">&nbsp;            int year = getTwoDigitYear(partial);</b>
<b class="nc">&nbsp;            if (year &lt; 0) {</b>
<b class="nc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.writePaddedInteger(out, year, 2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private int getTwoDigitYear(ReadablePartial partial) {
<b class="nc">&nbsp;            if (partial.isSupported(iType)) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    int year = partial.get(iType);</b>
<b class="nc">&nbsp;                    if (year &lt; 0) {</b>
<b class="nc">&nbsp;                        year = -year;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return year % 100;</b>
<b class="nc">&nbsp;                } catch (RuntimeException e) {}</b>
&nbsp;            } 
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class TextField
&nbsp;            implements DateTimePrinter, DateTimeParser {
&nbsp;
<b class="nc">&nbsp;        private static Map&lt;Locale, Map&lt;DateTimeFieldType, Object[]&gt;&gt; cParseCache =</b>
&nbsp;                    new HashMap&lt;Locale, Map&lt;DateTimeFieldType, Object[]&gt;&gt;();
&nbsp;        private final DateTimeFieldType iFieldType;
&nbsp;        private final boolean iShort;
&nbsp;
&nbsp;        TextField(DateTimeFieldType fieldType, boolean isShort) {
<b class="nc">&nbsp;            super();</b>
<b class="nc">&nbsp;            iFieldType = fieldType;</b>
<b class="nc">&nbsp;            iShort = isShort;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int estimatePrintedLength() {
<b class="nc">&nbsp;            return iShort ? 6 : 20;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
&nbsp;            try {
<b class="nc">&nbsp;                buf.append(print(instant, chrono, locale));</b>
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
&nbsp;            try {
<b class="nc">&nbsp;                out.write(print(instant, chrono, locale));</b>
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
<b class="fc">&nbsp;            try {</b>
<b class="pc">&nbsp;                buf.append(print(partial, locale));</b>
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
<b class="pc">&nbsp;                buf.append(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {</b>
&nbsp;            try {
<b class="nc">&nbsp;                out.write(print(partial, locale));</b>
<b class="nc">&nbsp;            } catch (RuntimeException e) {</b>
<b class="pc">&nbsp;                out.write(&#39;\ufffd&#39;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private String print(long instant, Chronology chrono, Locale locale) {
<b class="nc">&nbsp;            DateTimeField field = iFieldType.getField(chrono);</b>
<b class="nc">&nbsp;            if (iShort) {</b>
<b class="nc">&nbsp;                return field.getAsShortText(instant, locale);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return field.getAsText(instant, locale);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private String print(ReadablePartial partial, Locale locale) {</b>
<b class="nc">&nbsp;            if (partial.isSupported(iFieldType)) {</b>
<b class="nc">&nbsp;                DateTimeField field = iFieldType.getField(partial.getChronology());</b>
<b class="nc">&nbsp;                if (iShort) {</b>
<b class="nc">&nbsp;                    return field.getAsShortText(partial, locale);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return field.getAsText(partial, locale);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return &quot;\ufffd&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int estimateParsedLength() {</b>
<b class="nc">&nbsp;            return estimatePrintedLength();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc">&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {</b>
<b class="nc">&nbsp;            Locale locale = bucket.getLocale();</b>
&nbsp;            // handle languages which might have non ASCII A-Z or punctuation
&nbsp;            // bug 1788282
<b class="nc">&nbsp;            Set&lt;String&gt; validValues = null;</b>
<b class="nc">&nbsp;            int maxLength = 0;</b>
<b class="nc">&nbsp;            synchronized (cParseCache) {</b>
<b class="nc">&nbsp;                Map&lt;DateTimeFieldType, Object[]&gt; innerMap = cParseCache.get(locale);</b>
<b class="nc">&nbsp;                if (innerMap == null) {</b>
<b class="nc">&nbsp;                    innerMap = new HashMap&lt;DateTimeFieldType, Object[]&gt;();</b>
<b class="nc">&nbsp;                    cParseCache.put(locale, innerMap);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                Object[] array = innerMap.get(iFieldType);</b>
<b class="nc">&nbsp;                if (array == null) {</b>
<b class="nc">&nbsp;                    validValues = new HashSet&lt;String&gt;(32);</b>
<b class="nc">&nbsp;                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);</b>
<b class="nc">&nbsp;                    Property property = dt.property(iFieldType);</b>
<b class="nc">&nbsp;                    int min = property.getMinimumValueOverall();</b>
<b class="nc">&nbsp;                    int max = property.getMaximumValueOverall();</b>
<b class="nc">&nbsp;                    if (max - min &gt; 32) {  // protect against invalid fields</b>
<b class="nc">&nbsp;                        return ~position;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    maxLength = property.getMaximumTextLength(locale);</b>
<b class="nc">&nbsp;                    for (int i = min; i &lt;= max; i++) {</b>
<b class="nc">&nbsp;                        property.set(i);</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsShortText(locale));</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsText(locale));</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsText(locale).toLowerCase(locale));</b>
<b class="nc">&nbsp;                        validValues.add(property.getAsText(locale).toUpperCase(locale));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (&quot;en&quot;.equals(locale.getLanguage()) &amp;&amp; iFieldType == DateTimeFieldType.era()) {</b>
&nbsp;                        // hack to support for parsing &quot;BCE&quot; and &quot;CE&quot; if the language is English
<b class="nc">&nbsp;                        validValues.add(&quot;BCE&quot;);</b>
<b class="nc">&nbsp;                        validValues.add(&quot;bce&quot;);</b>
<b class="nc">&nbsp;                        validValues.add(&quot;CE&quot;);</b>
<b class="nc">&nbsp;                        validValues.add(&quot;ce&quot;);</b>
<b class="nc">&nbsp;                        maxLength = 3;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    array = new Object[] {validValues, Integer.valueOf(maxLength)};</b>
<b class="nc">&nbsp;                    innerMap.put(iFieldType, array);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    validValues = (Set&lt;String&gt;) array[0];</b>
<b class="nc">&nbsp;                    maxLength = ((Integer) array[1]).intValue();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // match the longest string first using our knowledge of the max length
<b class="nc">&nbsp;            int limit = Math.min(text.length(), position + maxLength);</b>
<b class="nc">&nbsp;            for (int i = limit; i &gt; position; i--) {</b>
<b class="nc">&nbsp;                String match = text.substring(position, i);</b>
<b class="nc">&nbsp;                if (validValues.contains(match)) {</b>
<b class="nc">&nbsp;                    bucket.saveField(iFieldType, match, locale);</b>
<b class="nc">&nbsp;                    return i;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return ~position;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc">&nbsp;    static class Fraction</b>
<b class="nc">&nbsp;            implements DateTimePrinter, DateTimeParser {</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private final DateTimeFieldType iFieldType;</b>
<b class="nc">&nbsp;        protected int iMinDigits;</b>
<b class="nc">&nbsp;        protected int iMaxDigits;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {</b>
<b class="nc">&nbsp;            super();</b>
&nbsp;            iFieldType = fieldType;
<b class="nc">&nbsp;            // Limit the precision requirements.</b>
<b class="nc">&nbsp;            if (maxDigits &gt; 18) {</b>
&nbsp;                maxDigits = 18;
&nbsp;            }
<b class="nc">&nbsp;            iMinDigits = minDigits;</b>
&nbsp;            iMaxDigits = maxDigits;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public int estimatePrintedLength() {
&nbsp;            return iMaxDigits;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="nc">&nbsp;            try {</b>
&nbsp;                printTo(buf, null, instant, chrono);
<b class="nc">&nbsp;            } catch (IOException e) {</b>
&nbsp;                // Not gonna happen.
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void printTo(</b>
<b class="nc">&nbsp;                Writer out, long instant, Chronology chrono,</b>
<b class="nc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {</b>
<b class="nc">&nbsp;            printTo(null, out, instant, chrono);</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {</b>
<b class="nc">&nbsp;            // removed check whether field is supported, as input field is typically</b>
<b class="nc">&nbsp;            // secondOfDay which is unsupported by TimeOfDay</b>
<b class="nc">&nbsp;            long millis = partial.getChronology().set(partial, 0L);</b>
&nbsp;            try {
<b class="nc">&nbsp;                printTo(buf, null, millis, partial.getChronology());</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                // Not gonna happen.</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {</b>
<b class="nc">&nbsp;            // removed check whether field is supported, as input field is typically</b>
&nbsp;            // secondOfDay which is unsupported by TimeOfDay
&nbsp;            long millis = partial.getChronology().set(partial, 0L);
<b class="nc">&nbsp;            printTo(null, out, millis, partial.getChronology());</b>
&nbsp;        }
&nbsp;
&nbsp;        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)
&nbsp;            throws IOException
<b class="nc">&nbsp;        {</b>
&nbsp;            DateTimeField field = iFieldType.getField(chrono);
<b class="nc">&nbsp;            int minDigits = iMinDigits;</b>
&nbsp;
&nbsp;            long fraction;
&nbsp;            try {
&nbsp;                fraction = field.remainder(instant);
&nbsp;            } catch (RuntimeException e) {
&nbsp;                if (buf != null) {
&nbsp;                    appendUnknownString(buf, minDigits);
&nbsp;                } else {
&nbsp;                    printUnknownString(out, minDigits);
&nbsp;                }
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            if (fraction == 0) {
&nbsp;                if (buf != null) {
&nbsp;                    while (--minDigits &gt;= 0) {
&nbsp;                        buf.append(&#39;0&#39;);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    while (--minDigits &gt;= 0) {</b>
<b class="fc">&nbsp;                        out.write(&#39;0&#39;);</b>
<b class="fc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                return;
<b class="fc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            String str;</b>
&nbsp;            long[] fractionData = getFractionData(fraction, field);
<b class="fc">&nbsp;            long scaled = fractionData[0];</b>
<b class="fc">&nbsp;            int maxDigits = (int) fractionData[1];</b>
&nbsp;            
&nbsp;            if ((scaled &amp; 0x7fffffff) == scaled) {
&nbsp;                str = Integer.toString((int) scaled);
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                str = Long.toString(scaled);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            int length = str.length();</b>
<b class="nc">&nbsp;            int digits = maxDigits;</b>
&nbsp;            while (length &lt; digits) {
<b class="fc">&nbsp;                if (buf != null) {</b>
&nbsp;                    buf.append(&#39;0&#39;);
&nbsp;                } else {
&nbsp;                    out.write(&#39;0&#39;);
&nbsp;                }
&nbsp;                minDigits--;
<b class="nc">&nbsp;                digits--;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (minDigits &lt; digits) {</b>
<b class="nc">&nbsp;                // Chop off as many trailing zero digits as necessary.</b>
&nbsp;                while (minDigits &lt; digits) {
&nbsp;                    if (length &lt;= 1 || str.charAt(length - 1) != &#39;0&#39;) {
<b class="nc">&nbsp;                        break;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    digits--;
<b class="nc">&nbsp;                    length--;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                if (length &lt; str.length()) {
&nbsp;                    if (buf != null) {
<b class="nc">&nbsp;                        for (int i=0; i&lt;length; i++) {</b>
<b class="nc">&nbsp;                            buf.append(str.charAt(i));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } else {
&nbsp;                        for (int i=0; i&lt;length; i++) {
<b class="nc">&nbsp;                            out.write(str.charAt(i));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            if (buf != null) {</b>
&nbsp;                buf.append(str);
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                out.write(str);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        private long[] getFractionData(long fraction, DateTimeField field) {</b>
&nbsp;            long rangeMillis = field.getDurationField().getUnitMillis();
&nbsp;            long scalar;
&nbsp;            int maxDigits = iMaxDigits;
<b class="nc">&nbsp;            while (true) {</b>
<b class="nc">&nbsp;                switch (maxDigits) {</b>
<b class="nc">&nbsp;                default: scalar = 1L; break;</b>
&nbsp;                case 1:  scalar = 10L; break;
<b class="nc">&nbsp;                case 2:  scalar = 100L; break;</b>
<b class="nc">&nbsp;                case 3:  scalar = 1000L; break;</b>
&nbsp;                case 4:  scalar = 10000L; break;
&nbsp;                case 5:  scalar = 100000L; break;
<b class="nc">&nbsp;                case 6:  scalar = 1000000L; break;</b>
<b class="nc">&nbsp;                case 7:  scalar = 10000000L; break;</b>
&nbsp;                case 8:  scalar = 100000000L; break;
&nbsp;                case 9:  scalar = 1000000000L; break;
&nbsp;                case 10: scalar = 10000000000L; break;
<b class="nc">&nbsp;                case 11: scalar = 100000000000L; break;</b>
<b class="nc">&nbsp;                case 12: scalar = 1000000000000L; break;</b>
&nbsp;                case 13: scalar = 10000000000000L; break;
<b class="nc">&nbsp;                case 14: scalar = 100000000000000L; break;</b>
&nbsp;                case 15: scalar = 1000000000000000L; break;
&nbsp;                case 16: scalar = 10000000000000000L; break;
&nbsp;                case 17: scalar = 100000000000000000L; break;
&nbsp;                case 18: scalar = 1000000000000000000L; break;
<b class="nc">&nbsp;                }</b>
&nbsp;                if (((rangeMillis * scalar) / scalar) == rangeMillis) {
&nbsp;                    break;
<b class="fc">&nbsp;                }</b>
&nbsp;                // Overflowed: scale down.
&nbsp;                maxDigits--;
&nbsp;            }
<b class="fc">&nbsp;            </b>
&nbsp;            return new long[] {fraction * scalar / rangeMillis, maxDigits};
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public int estimateParsedLength() {</b>
&nbsp;            return iMaxDigits;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {</b>
<b class="nc">&nbsp;            DateTimeField field = iFieldType.getField(bucket.getChronology());</b>
&nbsp;            
&nbsp;            int limit = Math.min(iMaxDigits, text.length() - position);
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            long value = 0;</b>
&nbsp;            long n = field.getDurationField().getUnitMillis() * 10;
<b class="fc">&nbsp;            int length = 0;</b>
<b class="fc">&nbsp;            while (length &lt; limit) {</b>
<b class="fc">&nbsp;                char c = text.charAt(position + length);</b>
&nbsp;                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
&nbsp;                    break;
&nbsp;                }
&nbsp;                length++;
&nbsp;                long nn = n / 10;
<b class="nc">&nbsp;                value += (c - &#39;0&#39;) * nn;</b>
<b class="nc">&nbsp;                n = nn;</b>
&nbsp;            }
&nbsp;
&nbsp;            value /= 10;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            if (length == 0) {</b>
<b class="nc">&nbsp;                return ~position;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            if (value &gt; Integer.MAX_VALUE) {
<b class="nc">&nbsp;                return ~position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            DateTimeField parseField = new PreciseDateTimeField(</b>
<b class="nc">&nbsp;                DateTimeFieldType.millisOfSecond(),</b>
&nbsp;                MillisDurationField.INSTANCE,
&nbsp;                field.getDurationField());
&nbsp;
&nbsp;            bucket.saveField(parseField, (int) value);
&nbsp;
&nbsp;            return position + length;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class TimeZoneOffset
&nbsp;            implements DateTimePrinter, DateTimeParser {
&nbsp;
<b class="nc">&nbsp;        private final String iZeroOffsetPrintText;</b>
&nbsp;        private final String iZeroOffsetParseText;
<b class="nc">&nbsp;        private final boolean iShowSeparators;</b>
&nbsp;        private final int iMinFields;
&nbsp;        private final int iMaxFields;
&nbsp;
&nbsp;        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,
<b class="nc">&nbsp;                                boolean showSeparators,</b>
<b class="nc">&nbsp;                                int minFields, int maxFields)</b>
<b class="nc">&nbsp;        {</b>
&nbsp;            super();
<b class="nc">&nbsp;            iZeroOffsetPrintText = zeroOffsetPrintText;</b>
<b class="nc">&nbsp;            iZeroOffsetParseText = zeroOffsetParseText;</b>
<b class="nc">&nbsp;            iShowSeparators = showSeparators;</b>
&nbsp;            if (minFields &lt;= 0 || maxFields &lt; minFields) {
&nbsp;                throw new IllegalArgumentException();
&nbsp;            }
&nbsp;            if (minFields &gt; 4) {
&nbsp;                minFields = 4;
<b class="nc">&nbsp;                maxFields = 4;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            iMinFields = minFields;
&nbsp;            iMaxFields = maxFields;
&nbsp;        }
<b class="nc">&nbsp;            </b>
<b class="nc">&nbsp;        public int estimatePrintedLength() {</b>
<b class="nc">&nbsp;            int est = 1 + iMinFields &lt;&lt; 1;</b>
<b class="nc">&nbsp;            if (iShowSeparators) {</b>
<b class="nc">&nbsp;                est += iMinFields - 1;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (iZeroOffsetPrintText != null &amp;&amp; iZeroOffsetPrintText.length() &gt; est) {</b>
&nbsp;                est = iZeroOffsetPrintText.length();
&nbsp;            }
&nbsp;            return est;
&nbsp;        }
&nbsp;        
&nbsp;        public void printTo(
<b class="nc">&nbsp;                StringBuffer buf, long instant, Chronology chrono,</b>
<b class="nc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {</b>
<b class="nc">&nbsp;            if (displayZone == null) {</b>
<b class="nc">&nbsp;                return;  // no zone</b>
&nbsp;            }
<b class="nc">&nbsp;            if (displayOffset == 0 &amp;&amp; iZeroOffsetPrintText != null) {</b>
&nbsp;                buf.append(iZeroOffsetPrintText);
&nbsp;                return;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (displayOffset &gt;= 0) {</b>
<b class="nc">&nbsp;                buf.append(&#39;+&#39;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                buf.append(&#39;-&#39;);</b>
<b class="nc">&nbsp;                displayOffset = -displayOffset;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
&nbsp;            FormatUtils.appendPaddedInteger(buf, hours, 2);
<b class="nc">&nbsp;            if (iMaxFields == 1) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
<b class="nc">&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields &lt;= 1) {</b>
<b class="nc">&nbsp;                return;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;</b>
<b class="nc">&nbsp;            if (iShowSeparators) {</b>
&nbsp;                buf.append(&#39;:&#39;);
&nbsp;            }
<b class="nc">&nbsp;            FormatUtils.appendPaddedInteger(buf, minutes, 2);</b>
<b class="nc">&nbsp;            if (iMaxFields == 2) {</b>
<b class="nc">&nbsp;                return;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
<b class="nc">&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields &lt;= 2) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;</b>
<b class="nc">&nbsp;            if (iShowSeparators) {</b>
&nbsp;                buf.append(&#39;:&#39;);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            FormatUtils.appendPaddedInteger(buf, seconds, 2);</b>
<b class="nc">&nbsp;            if (iMaxFields == 3) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
<b class="nc">&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields &lt;= 3) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (iShowSeparators) {</b>
<b class="nc">&nbsp;                buf.append(&#39;.&#39;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        </b>
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
<b class="nc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {</b>
<b class="nc">&nbsp;            if (displayZone == null) {</b>
<b class="nc">&nbsp;                return;  // no zone</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            if (displayOffset == 0 &amp;&amp; iZeroOffsetPrintText != null) {
<b class="nc">&nbsp;                out.write(iZeroOffsetPrintText);</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (displayOffset &gt;= 0) {</b>
<b class="nc">&nbsp;                out.write(&#39;+&#39;);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                out.write(&#39;-&#39;);</b>
<b class="nc">&nbsp;                displayOffset = -displayOffset;</b>
&nbsp;            }
&nbsp;
&nbsp;            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
&nbsp;            FormatUtils.writePaddedInteger(out, hours, 2);
<b class="nc">&nbsp;            if (iMaxFields == 1) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields == 1) {
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;
<b class="nc">&nbsp;            if (iShowSeparators) {</b>
<b class="nc">&nbsp;                out.write(&#39;:&#39;);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            FormatUtils.writePaddedInteger(out, minutes, 2);</b>
<b class="nc">&nbsp;            if (iMaxFields == 2) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;</b>
&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields == 2) {
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;
&nbsp;            if (iShowSeparators) {
&nbsp;                out.write(&#39;:&#39;);
&nbsp;            }
&nbsp;            FormatUtils.writePaddedInteger(out, seconds, 2);
&nbsp;            if (iMaxFields == 3) {
&nbsp;                return;
&nbsp;            }
&nbsp;            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
&nbsp;            if (displayOffset == 0 &amp;&amp; iMinFields == 3) {
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            if (iShowSeparators) {
&nbsp;                out.write(&#39;.&#39;);
&nbsp;            }
&nbsp;            FormatUtils.writePaddedInteger(out, displayOffset, 3);
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
&nbsp;            // no zone info
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
&nbsp;            // no zone info
&nbsp;        }
&nbsp;
&nbsp;        public int estimateParsedLength() {
&nbsp;            return estimatePrintedLength();
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
&nbsp;            int limit = text.length() - position;
&nbsp;
&nbsp;            zeroOffset:
&nbsp;            if (iZeroOffsetParseText != null) {
&nbsp;                if (iZeroOffsetParseText.length() == 0) {
&nbsp;                    // Peek ahead, looking for sign character.
&nbsp;                    if (limit &gt; 0) {
&nbsp;                        char c = text.charAt(position);
&nbsp;                        if (c == &#39;-&#39; || c == &#39;+&#39;) {
&nbsp;                            break zeroOffset;
&nbsp;                        }
&nbsp;                    }
&nbsp;                    bucket.setOffset(Integer.valueOf(0));
&nbsp;                    return position;
&nbsp;                }
&nbsp;                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {
&nbsp;                    bucket.setOffset(Integer.valueOf(0));
&nbsp;                    return position + iZeroOffsetParseText.length();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Format to expect is sign character followed by at least one digit.
&nbsp;
&nbsp;            if (limit &lt;= 1) {
&nbsp;                return ~position;
&nbsp;            }
&nbsp;
&nbsp;            boolean negative;
&nbsp;            char c = text.charAt(position);
&nbsp;            if (c == &#39;-&#39;) {
&nbsp;                negative = true;
&nbsp;            } else if (c == &#39;+&#39;) {
&nbsp;                negative = false;
&nbsp;            } else {
&nbsp;                return ~position;
&nbsp;            }
&nbsp;
&nbsp;            limit--;
&nbsp;            position++;
&nbsp;
&nbsp;            // Format following sign is one of:
&nbsp;            //
&nbsp;            // hh
&nbsp;            // hhmm
&nbsp;            // hhmmss
&nbsp;            // hhmmssSSS
&nbsp;            // hh:mm
&nbsp;            // hh:mm:ss
&nbsp;            // hh:mm:ss.SSS
&nbsp;
&nbsp;            // First parse hours.
&nbsp;
&nbsp;            if (digitCount(text, position, 2) &lt; 2) {
&nbsp;                // Need two digits for hour.
&nbsp;                return ~position;
&nbsp;            }
&nbsp;
&nbsp;            int offset;
&nbsp;
&nbsp;            int hours = FormatUtils.parseTwoDigits(text, position);
&nbsp;            if (hours &gt; 23) {
&nbsp;                return ~position;
&nbsp;            }
&nbsp;            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;
&nbsp;            limit -= 2;
&nbsp;            position += 2;
&nbsp;
&nbsp;            parse: {
&nbsp;                // Need to decide now if separators are expected or parsing
&nbsp;                // stops at hour field.
&nbsp;
&nbsp;                if (limit &lt;= 0) {
&nbsp;                    break parse;
&nbsp;                }
&nbsp;
&nbsp;                boolean expectSeparators;
&nbsp;                c = text.charAt(position);
&nbsp;                if (c == &#39;:&#39;) {
&nbsp;                    expectSeparators = true;
&nbsp;                    limit--;
&nbsp;                    position++;
&nbsp;                } else if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
&nbsp;                    expectSeparators = false;
&nbsp;                } else {
&nbsp;                    break parse;
&nbsp;                }
&nbsp;
&nbsp;                // Proceed to parse minutes.
&nbsp;
&nbsp;                int count = digitCount(text, position, 2);
&nbsp;                if (count == 0 &amp;&amp; !expectSeparators) {
&nbsp;                    break parse;
&nbsp;                } else if (count &lt; 2) {
&nbsp;                    // Need two digits for minute.
&nbsp;                    return ~position;
&nbsp;                }
&nbsp;
&nbsp;                int minutes = FormatUtils.parseTwoDigits(text, position);
&nbsp;                if (minutes &gt; 59) {
&nbsp;                    return ~position;
&nbsp;                }
&nbsp;                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;
&nbsp;                limit -= 2;
&nbsp;                position += 2;
&nbsp;
&nbsp;                // Proceed to parse seconds.
&nbsp;
&nbsp;                if (limit &lt;= 0) {
&nbsp;                    break parse;
&nbsp;                }
&nbsp;
&nbsp;                if (expectSeparators) {
&nbsp;                    if (text.charAt(position) != &#39;:&#39;) {
&nbsp;                        break parse;
&nbsp;                    }
&nbsp;                    limit--;
&nbsp;                    position++;
&nbsp;                }
&nbsp;
&nbsp;                count = digitCount(text, position, 2);
&nbsp;                if (count == 0 &amp;&amp; !expectSeparators) {
&nbsp;                    break parse;
&nbsp;                } else if (count &lt; 2) {
&nbsp;                    // Need two digits for second.
&nbsp;                    return ~position;
&nbsp;                }
&nbsp;
&nbsp;                int seconds = FormatUtils.parseTwoDigits(text, position);
&nbsp;                if (seconds &gt; 59) {
&nbsp;                    return ~position;
&nbsp;                }
&nbsp;                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;
&nbsp;                limit -= 2;
&nbsp;                position += 2;
&nbsp;
&nbsp;                // Proceed to parse fraction of second.
&nbsp;
&nbsp;                if (limit &lt;= 0) {
&nbsp;                    break parse;
&nbsp;                }
&nbsp;
&nbsp;                if (expectSeparators) {
&nbsp;                    if (text.charAt(position) != &#39;.&#39; &amp;&amp; text.charAt(position) != &#39;,&#39;) {
&nbsp;                        break parse;
&nbsp;                    }
&nbsp;                    limit--;
&nbsp;                    position++;
&nbsp;                }
<b class="fc">&nbsp;                </b>
&nbsp;                count = digitCount(text, position, 3);
<b class="fc">&nbsp;                if (count == 0 &amp;&amp; !expectSeparators) {</b>
<b class="fc">&nbsp;                    break parse;</b>
&nbsp;                } else if (count &lt; 1) {
<b class="fc">&nbsp;                    // Need at least one digit for fraction of second.</b>
&nbsp;                    return ~position;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                offset += (text.charAt(position++) - &#39;0&#39;) * 100;</b>
&nbsp;                if (count &gt; 1) {
<b class="fc">&nbsp;                    offset += (text.charAt(position++) - &#39;0&#39;) * 10;</b>
<b class="fc">&nbsp;                    if (count &gt; 2) {</b>
<b class="fc">&nbsp;                        offset += text.charAt(position++) - &#39;0&#39;;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));
<b class="fc">&nbsp;            return position;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        /**</b>
<b class="nc">&nbsp;         * Returns actual amount of digits to parse, but no more than original</b>
<b class="nc">&nbsp;         * &#39;amount&#39; parameter.</b>
&nbsp;         */
<b class="fc">&nbsp;        private int digitCount(String text, int position, int amount) {</b>
<b class="fc">&nbsp;            int limit = Math.min(text.length() - position, amount);</b>
<b class="fc">&nbsp;            amount = 0;</b>
<b class="fc">&nbsp;            for (; limit &gt; 0; limit--) {</b>
<b class="fc">&nbsp;                char c = text.charAt(position + amount);</b>
<b class="fc">&nbsp;                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                amount++;</b>
&nbsp;            }
&nbsp;            return amount;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class TimeZoneName
&nbsp;            implements DateTimePrinter, DateTimeParser {
&nbsp;
&nbsp;        static final int LONG_NAME = 0;
<b class="nc">&nbsp;        static final int SHORT_NAME = 1;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private final Map&lt;String, DateTimeZone&gt; iParseLookup;</b>
&nbsp;        private final int iType;
&nbsp;
<b class="nc">&nbsp;        TimeZoneName(int type, Map&lt;String, DateTimeZone&gt; parseLookup) {</b>
<b class="nc">&nbsp;            super();</b>
<b class="nc">&nbsp;            iType = type;</b>
<b class="nc">&nbsp;            iParseLookup = parseLookup;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int estimatePrintedLength() {</b>
<b class="nc">&nbsp;            return (iType == SHORT_NAME ? 4 : 20);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
<b class="nc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {</b>
<b class="nc">&nbsp;            buf.append(print(instant - displayOffset, displayZone, locale));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void printTo(
<b class="nc">&nbsp;                Writer out, long instant, Chronology chrono,</b>
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
<b class="nc">&nbsp;            out.write(print(instant - displayOffset, displayZone, locale));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private String print(long instant, DateTimeZone displayZone, Locale locale) {</b>
<b class="nc">&nbsp;            if (displayZone == null) {</b>
<b class="nc">&nbsp;                return &quot;&quot;;  // no zone</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (iType) {</b>
&nbsp;                case LONG_NAME:
<b class="nc">&nbsp;                    return displayZone.getName(instant, locale);</b>
<b class="fc">&nbsp;                case SHORT_NAME:</b>
<b class="nc">&nbsp;                    return displayZone.getShortName(instant, locale);</b>
&nbsp;            }
<b class="nc">&nbsp;            return &quot;&quot;;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {</b>
&nbsp;            // no zone info
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {</b>
<b class="fc">&nbsp;            // no zone info</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public int estimateParsedLength() {
<b class="nc">&nbsp;            return (iType == SHORT_NAME ? 4 : 20);</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
<b class="nc">&nbsp;            Map&lt;String, DateTimeZone&gt; parseLookup = iParseLookup;</b>
<b class="nc">&nbsp;            parseLookup = (parseLookup != null ? parseLookup : DateTimeUtils.getDefaultTimeZoneNames());</b>
<b class="pc">&nbsp;            String str = text.substring(position);</b>
<b class="nc">&nbsp;            String matched = null;</b>
<b class="nc">&nbsp;            for (String name : parseLookup.keySet()) {</b>
<b class="nc">&nbsp;                if (str.startsWith(name)) {</b>
<b class="nc">&nbsp;                    if (matched == null || name.length() &gt; matched.length()) {</b>
<b class="nc">&nbsp;                        matched = name;</b>
&nbsp;                    }
&nbsp;                }
<b class="pc">&nbsp;            }</b>
<b class="pc">&nbsp;            if (matched != null) {</b>
<b class="pc">&nbsp;                bucket.setZone(parseLookup.get(matched));</b>
<b class="pc">&nbsp;                return position + matched.length();</b>
<b class="fc">&nbsp;            }</b>
<b class="nc">&nbsp;            return ~position;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    //-----------------------------------------------------------------------</b>
<b class="pc">&nbsp;    static enum TimeZoneId</b>
<b class="fc">&nbsp;            implements DateTimePrinter, DateTimeParser {</b>
&nbsp;
<b class="pc">&nbsp;        INSTANCE;</b>
<b class="nc">&nbsp;        static final Set&lt;String&gt; ALL_IDS = DateTimeZone.getAvailableIDs();</b>
&nbsp;        static final int MAX_LENGTH;
&nbsp;        static {
<b class="nc">&nbsp;            int max = 0;</b>
<b class="nc">&nbsp;            for (String id : ALL_IDS) {</b>
<b class="pc">&nbsp;                max = Math.max(max, id.length());</b>
<b class="pc">&nbsp;            }</b>
<b class="pc">&nbsp;            MAX_LENGTH = max;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int estimatePrintedLength() {
<b class="nc">&nbsp;            return MAX_LENGTH;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="nc">&nbsp;            buf.append(displayZone != null ? displayZone.getID() : &quot;&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(
<b class="fc">&nbsp;                Writer out, long instant, Chronology chrono,</b>
<b class="fc">&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {</b>
<b class="pc">&nbsp;            out.write(displayZone != null ? displayZone.getID() : &quot;&quot;);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {</b>
<b class="fc">&nbsp;            // no zone info</b>
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
&nbsp;            // no zone info
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public int estimateParsedLength() {
<b class="nc">&nbsp;            return MAX_LENGTH;</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
<b class="nc">&nbsp;            String str = text.substring(position);</b>
<b class="nc">&nbsp;            String best = null;</b>
<b class="pc">&nbsp;            for (String id : ALL_IDS) {</b>
<b class="pc">&nbsp;                if (str.startsWith(id)) {</b>
<b class="nc">&nbsp;                    if (best == null || id.length() &gt; best.length()) {</b>
<b class="pc">&nbsp;                        best = id;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="pc">&nbsp;            }</b>
<b class="pc">&nbsp;            if (best != null) {</b>
<b class="nc">&nbsp;                bucket.setZone(DateTimeZone.forID(best));</b>
<b class="pc">&nbsp;                return position + best.length();</b>
&nbsp;            }
<b class="pc">&nbsp;            return ~position;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    //-----------------------------------------------------------------------</b>
<b class="fc">&nbsp;    static class Composite</b>
&nbsp;            implements DateTimePrinter, DateTimeParser {
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        private final DateTimePrinter[] iPrinters;</b>
&nbsp;        private final DateTimeParser[] iParsers;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        private final int iPrintedLengthEstimate;</b>
<b class="fc">&nbsp;        private final int iParsedLengthEstimate;</b>
<b class="fc">&nbsp;</b>
&nbsp;        Composite(List&lt;Object&gt; elementPairs) {
&nbsp;            super();
&nbsp;
&nbsp;            List&lt;Object&gt; printerList = new ArrayList&lt;Object&gt;();
<b class="fc">&nbsp;            List&lt;Object&gt; parserList = new ArrayList&lt;Object&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            decompose(elementPairs, printerList, parserList);</b>
<b class="fc">&nbsp;</b>
&nbsp;            if (printerList.contains(null) || printerList.isEmpty()) {
&nbsp;                iPrinters = null;
<b class="fc">&nbsp;                iPrintedLengthEstimate = 0;</b>
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                int size = printerList.size();</b>
<b class="fc">&nbsp;                iPrinters = new DateTimePrinter[size];</b>
&nbsp;                int printEst = 0;
&nbsp;                for (int i=0; i&lt;size; i++) {
&nbsp;                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);
<b class="fc">&nbsp;                    printEst += printer.estimatePrintedLength();</b>
&nbsp;                    iPrinters[i] = printer;
&nbsp;                }
<b class="fc">&nbsp;                iPrintedLengthEstimate = printEst;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            if (parserList.contains(null) || parserList.isEmpty()) {</b>
&nbsp;                iParsers = null;
<b class="fc">&nbsp;                iParsedLengthEstimate = 0;</b>
&nbsp;            } else {
&nbsp;                int size = parserList.size();
<b class="fc">&nbsp;                iParsers = new DateTimeParser[size];</b>
&nbsp;                int parseEst = 0;
&nbsp;                for (int i=0; i&lt;size; i++) {
&nbsp;                    DateTimeParser parser = (DateTimeParser) parserList.get(i);
&nbsp;                    parseEst += parser.estimateParsedLength();
<b class="nc">&nbsp;                    iParsers[i] = parser;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                iParsedLengthEstimate = parseEst;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int estimatePrintedLength() {</b>
&nbsp;            return iPrintedLengthEstimate;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public void printTo(
&nbsp;                StringBuffer buf, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) {
<b class="fc">&nbsp;            DateTimePrinter[] elements = iPrinters;</b>
<b class="fc">&nbsp;            if (elements == null) {</b>
<b class="nc">&nbsp;                throw new UnsupportedOperationException();</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            if (locale == null) {</b>
<b class="fc">&nbsp;                // Guard against default locale changing concurrently.</b>
<b class="fc">&nbsp;                locale = Locale.getDefault();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            int len = elements.length;</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; len; i++) {</b>
&nbsp;                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public void printTo(
&nbsp;                Writer out, long instant, Chronology chrono,
&nbsp;                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
&nbsp;            DateTimePrinter[] elements = iPrinters;
&nbsp;            if (elements == null) {
&nbsp;                throw new UnsupportedOperationException();
&nbsp;            }
&nbsp;
&nbsp;            if (locale == null) {
&nbsp;                // Guard against default locale changing concurrently.
&nbsp;                locale = Locale.getDefault();
&nbsp;            }
&nbsp;
&nbsp;            int len = elements.length;
&nbsp;            for (int i = 0; i &lt; len; i++) {
&nbsp;                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
&nbsp;            DateTimePrinter[] elements = iPrinters;
&nbsp;            if (elements == null) {
&nbsp;                throw new UnsupportedOperationException();
&nbsp;            }
&nbsp;
&nbsp;            if (locale == null) {
&nbsp;                // Guard against default locale changing concurrently.
&nbsp;                locale = Locale.getDefault();
&nbsp;            }
&nbsp;
&nbsp;            int len = elements.length;
&nbsp;            for (int i=0; i&lt;len; i++) {
&nbsp;                elements[i].printTo(buf, partial, locale);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
&nbsp;            DateTimePrinter[] elements = iPrinters;
&nbsp;            if (elements == null) {
&nbsp;                throw new UnsupportedOperationException();
&nbsp;            }
&nbsp;
&nbsp;            if (locale == null) {
&nbsp;                // Guard against default locale changing concurrently.
&nbsp;                locale = Locale.getDefault();
&nbsp;            }
&nbsp;
&nbsp;            int len = elements.length;
&nbsp;            for (int i=0; i&lt;len; i++) {
&nbsp;                elements[i].printTo(out, partial, locale);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int estimateParsedLength() {
&nbsp;            return iParsedLengthEstimate;
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
&nbsp;            DateTimeParser[] elements = iParsers;
&nbsp;            if (elements == null) {
&nbsp;                throw new UnsupportedOperationException();
&nbsp;            }
&nbsp;
&nbsp;            int len = elements.length;
&nbsp;            for (int i=0; i&lt;len &amp;&amp; position &gt;= 0; i++) {
&nbsp;                position = elements[i].parseInto(bucket, text, position);
&nbsp;            }
&nbsp;            return position;
&nbsp;        }
&nbsp;
&nbsp;        boolean isPrinter() {
&nbsp;            return iPrinters != null;
&nbsp;        }
&nbsp;
&nbsp;        boolean isParser() {
&nbsp;            return iParsers != null;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Processes the element pairs, putting results into the given printer
&nbsp;         * and parser lists.
&nbsp;         */
&nbsp;        private void decompose(List&lt;Object&gt; elementPairs, List&lt;Object&gt; printerList, List&lt;Object&gt; parserList) {
&nbsp;            int size = elementPairs.size();
&nbsp;            for (int i=0; i&lt;size; i+=2) {
&nbsp;                Object element = elementPairs.get(i);
&nbsp;                if (element instanceof Composite) {
&nbsp;                    addArrayToList(printerList, ((Composite)element).iPrinters);
&nbsp;                } else {
&nbsp;                    printerList.add(element);
&nbsp;                }
&nbsp;
&nbsp;                element = elementPairs.get(i + 1);
&nbsp;                if (element instanceof Composite) {
&nbsp;                    addArrayToList(parserList, ((Composite)element).iParsers);
&nbsp;                } else {
&nbsp;                    parserList.add(element);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void addArrayToList(List&lt;Object&gt; list, Object[] array) {
&nbsp;            if (array != null) {
&nbsp;                for (int i=0; i&lt;array.length; i++) {
&nbsp;                    list.add(array[i]);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    static class MatchingParser
&nbsp;            implements DateTimeParser {
&nbsp;
&nbsp;        private final DateTimeParser[] iParsers;
&nbsp;        private final int iParsedLengthEstimate;
&nbsp;
&nbsp;        MatchingParser(DateTimeParser[] parsers) {
&nbsp;            super();
&nbsp;            iParsers = parsers;
&nbsp;            int est = 0;
&nbsp;            for (int i=parsers.length; --i&gt;=0 ;) {
&nbsp;                DateTimeParser parser = parsers[i];
&nbsp;                if (parser != null) {
&nbsp;                    int len = parser.estimateParsedLength();
&nbsp;                    if (len &gt; est) {
&nbsp;                        est = len;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            iParsedLengthEstimate = est;
&nbsp;        }
&nbsp;
&nbsp;        public int estimateParsedLength() {
&nbsp;            return iParsedLengthEstimate;
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
&nbsp;            DateTimeParser[] parsers = iParsers;
&nbsp;            int length = parsers.length;
&nbsp;
&nbsp;            final Object originalState = bucket.saveState();
&nbsp;            boolean isOptional = false;
&nbsp;
&nbsp;            int bestValidPos = position;
&nbsp;            Object bestValidState = null;
&nbsp;
&nbsp;            int bestInvalidPos = position;
&nbsp;
&nbsp;            for (int i=0; i&lt;length; i++) {
&nbsp;                DateTimeParser parser = parsers[i];
&nbsp;                if (parser == null) {
&nbsp;                    // The empty parser wins only if nothing is better.
&nbsp;                    if (bestValidPos &lt;= position) {
&nbsp;                        return position;
&nbsp;                    }
&nbsp;                    isOptional = true;
&nbsp;                    break;
&nbsp;                }
&nbsp;                int parsePos = parser.parseInto(bucket, text, position);
&nbsp;                if (parsePos &gt;= position) {
&nbsp;                    if (parsePos &gt; bestValidPos) {
&nbsp;                        if (parsePos &gt;= text.length() ||
&nbsp;                            (i + 1) &gt;= length || parsers[i + 1] == null) {
&nbsp;
&nbsp;                            // Completely parsed text or no more parsers to
&nbsp;                            // check. Skip the rest.
&nbsp;                            return parsePos;
&nbsp;                        }
&nbsp;                        bestValidPos = parsePos;
&nbsp;                        bestValidState = bucket.saveState();
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    if (parsePos &lt; 0) {
&nbsp;                        parsePos = ~parsePos;
&nbsp;                        if (parsePos &gt; bestInvalidPos) {
&nbsp;                            bestInvalidPos = parsePos;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                bucket.restoreState(originalState);
&nbsp;            }
&nbsp;
&nbsp;            if (bestValidPos &gt; position || (bestValidPos == position &amp;&amp; isOptional)) {
&nbsp;                // Restore the state to the best valid parse.
&nbsp;                if (bestValidState != null) {
&nbsp;                    bucket.restoreState(bestValidState);
&nbsp;                }
&nbsp;                return bestValidPos;
&nbsp;            }
&nbsp;
&nbsp;            return ~bestInvalidPos;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-03 10:53</div>
</div>
</body>
</html>
