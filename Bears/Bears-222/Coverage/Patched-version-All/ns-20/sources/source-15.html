


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DirectedAcyclicGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jgrapht.graph</a>
</div>

<h1>Coverage Summary for Class: DirectedAcyclicGraph (org.jgrapht.graph)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DirectedAcyclicGraph</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (16/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.5%
  </span>
  <span class="absValue">
    (136/159)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$1</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$CycleFoundException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$Region</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$TopoComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$TopoIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.5%
  </span>
  <span class="absValue">
    (23/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$TopoOrderMap</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$TopoVertexBiMap</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$TopoVertexMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedArrayImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedArrayListImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedBitSetImpl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedHashSetImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedStrategy</td>
  </tr>
  <tr>
    <td class="name">DirectedAcyclicGraph$VisitedStrategyFactory</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    55.1%
  </span>
  <span class="absValue">
    (38/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.1%
  </span>
  <span class="absValue">
    (188/268)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (C) Copyright 2008-2018, by Peter Giles and Contributors.
&nbsp; *
&nbsp; * JGraphT : a free Java graph-theory library
&nbsp; *
&nbsp; * See the CONTRIBUTORS.md file distributed with this work for additional
&nbsp; * information regarding copyright ownership.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Public License 2.0 which is available at
&nbsp; * http://www.eclipse.org/legal/epl-2.0, or the
&nbsp; * GNU Lesser General Public License v2.1 or later
&nbsp; * which is available at
&nbsp; * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
&nbsp; *
&nbsp; * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
&nbsp; */
&nbsp;package org.jgrapht.graph;
&nbsp;
&nbsp;import org.jgrapht.*;
&nbsp;import org.jgrapht.graph.builder.*;
&nbsp;import org.jgrapht.traverse.*;
&nbsp;import org.jgrapht.util.*;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.util.*;
&nbsp;import java.util.function.*;
&nbsp;
&nbsp;/**
&nbsp; * A directed acyclic graph (DAG).
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Implements a DAG that can be modified (vertices &amp;amp; edges added and removed), is guaranteed to
&nbsp; * remain acyclic, and provides fast topological order iteration. An attempt to add an edge which
&nbsp; * would induce a cycle throws an {@link IllegalArgumentException}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This is done using a dynamic topological sort which is based on the algorithm described in &quot;David
&nbsp; * J. Pearce &amp;amp; Paul H. J. Kelly. A dynamic topological sort algorithm for directed acyclic
&nbsp; * graphs. Journal of Experimental Algorithmics, 11, 2007.&quot; (see
&nbsp; * &lt;a href=&quot;http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf&quot;&gt;paper&lt;/a&gt; or
&nbsp; * &lt;a href=&quot;http://doi.acm.org/10.1145/1187436.1210590&quot;&gt;ACM link&lt;/a&gt; for details). The
&nbsp; * implementation differs from the algorithm specified in the above paper in some ways, perhaps most
&nbsp; * notably in that the topological ordering is stored by default using two hash maps, which will
&nbsp; * have some effects on the runtime, but also allow for vertex addition and removal. This storage
&nbsp; * mechanism can be adjusted by subclasses.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The complexity of adding a new edge in the graph depends on the number of edges incident to the
&nbsp; * &quot;affected region&quot;, and should in general be faster than recomputing the whole topological
&nbsp; * ordering from scratch. For details about the complexity parameters and running times, see the
&nbsp; * previously mentioned paper.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This class makes no claims to thread safety, and concurrent usage from multiple threads will
&nbsp; * produce undefined results.
&nbsp; *
&nbsp; * @param &lt;V&gt; the graph vertex type
&nbsp; * @param &lt;E&gt; the graph edge type
&nbsp; *
&nbsp; * @author Peter Giles
&nbsp; */
<b class="fc">&nbsp;public class DirectedAcyclicGraph&lt;V, E&gt;</b>
&nbsp;    extends
&nbsp;    SimpleDirectedGraph&lt;V, E&gt;
&nbsp;    implements
&nbsp;    Iterable&lt;V&gt;
&nbsp;{
&nbsp;    private static final long serialVersionUID = 4522128427004938150L;
&nbsp;
&nbsp;    private static final String EDGE_WOULD_INDUCE_A_CYCLE = &quot;Edge would induce a cycle&quot;;
&nbsp;
&nbsp;    private final Comparator&lt;V&gt; topoComparator;
&nbsp;    private final TopoOrderMap&lt;V&gt; topoOrderMap;
<b class="fc">&nbsp;    private int maxTopoIndex = 0;</b>
<b class="fc">&nbsp;    private int minTopoIndex = 0;</b>
&nbsp;
&nbsp;    // this update count is used to keep internal topological iterators honest
<b class="fc">&nbsp;    private transient long topoModCount = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The visited strategy factory to use. Subclasses can change this.
&nbsp;     */
&nbsp;    private final VisitedStrategyFactory visitedStrategyFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a directed acyclic graph.
&nbsp;     *
&nbsp;     * @param edgeClass the edge class
&nbsp;     */
&nbsp;    public DirectedAcyclicGraph(Class&lt;? extends E&gt; edgeClass)
&nbsp;    {
<b class="fc">&nbsp;        this(null, SupplierUtil.createSupplier(edgeClass), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a directed acyclic graph.
&nbsp;     *
&nbsp;     * @param vertexSupplier the vertex supplier
&nbsp;     * @param edgeSupplier the edge supplier
&nbsp;     * @param weighted if true the graph will be weighted, otherwise not
&nbsp;     */
&nbsp;    public DirectedAcyclicGraph(
&nbsp;        Supplier&lt;V&gt; vertexSupplier, Supplier&lt;E&gt; edgeSupplier, boolean weighted)
&nbsp;    {
<b class="fc">&nbsp;        this(</b>
&nbsp;            vertexSupplier, edgeSupplier, new VisitedBitSetImpl(), new TopoVertexBiMap&lt;&gt;(),
&nbsp;            weighted);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a directed acyclic graph.
&nbsp;     * 
&nbsp;     * @param vertexSupplier the vertex supplier
&nbsp;     * @param edgeSupplier the edge supplier
&nbsp;     * @param visitedStrategyFactory the visited strategy factory. Subclasses can change this
&nbsp;     *        implementation to adjust the performance tradeoffs.
&nbsp;     * @param topoOrderMap the topological order map. For performance reasons, subclasses can change
&nbsp;     *        the way this class stores the topological order.
&nbsp;     * @param weighted if true the graph will be weighted, otherwise not
&nbsp;     */
&nbsp;    protected DirectedAcyclicGraph(
&nbsp;        Supplier&lt;V&gt; vertexSupplier, Supplier&lt;E&gt; edgeSupplier,
&nbsp;        VisitedStrategyFactory visitedStrategyFactory, TopoOrderMap&lt;V&gt; topoOrderMap,
&nbsp;        boolean weighted)
&nbsp;    {
<b class="fc">&nbsp;        super(vertexSupplier, edgeSupplier, weighted);</b>
<b class="fc">&nbsp;        this.visitedStrategyFactory =</b>
<b class="fc">&nbsp;            Objects.requireNonNull(visitedStrategyFactory, &quot;Visited factory cannot be null&quot;);</b>
<b class="fc">&nbsp;        this.topoOrderMap =</b>
<b class="fc">&nbsp;            Objects.requireNonNull(topoOrderMap, &quot;Topological order map cannot be null&quot;);</b>
<b class="fc">&nbsp;        this.topoComparator = new TopoComparator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a builder for this kind of graph.
&nbsp;     *
&nbsp;     * @param edgeClass class on which to base factory for edges
&nbsp;     * @param &lt;V&gt; the graph vertex type
&nbsp;     * @param &lt;E&gt; the graph edge type
&nbsp;     * @return a builder for this kind of graph
&nbsp;     */
&nbsp;    public static &lt;V, E&gt; GraphBuilder&lt;V, E, ? extends DirectedAcyclicGraph&lt;V, E&gt;&gt; createBuilder(
&nbsp;        Class&lt;? extends E&gt; edgeClass)
&nbsp;    {
<b class="nc">&nbsp;        return new GraphBuilder&lt;&gt;(new DirectedAcyclicGraph&lt;&gt;(edgeClass));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a builder for this kind of graph.
&nbsp;     * 
&nbsp;     * @param edgeSupplier edge supplier for the edges
&nbsp;     * @param &lt;V&gt; the graph vertex type
&nbsp;     * @param &lt;E&gt; the graph edge type
&nbsp;     * @return a builder for this kind of graph
&nbsp;     */
&nbsp;    public static &lt;V, E&gt; GraphBuilder&lt;V, E, ? extends DirectedAcyclicGraph&lt;V, E&gt;&gt; createBuilder(
&nbsp;        Supplier&lt;E&gt; edgeSupplier)
&nbsp;    {
<b class="nc">&nbsp;        return new GraphBuilder&lt;&gt;(new DirectedAcyclicGraph&lt;&gt;(null, edgeSupplier, false));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public GraphType getType()
&nbsp;    {
<b class="fc">&nbsp;        return new DefaultGraphType.Builder()</b>
<b class="fc">&nbsp;            .directed().weighted(super.getType().isWeighted()).allowMultipleEdges(false)</b>
<b class="fc">&nbsp;            .allowSelfLoops(false).allowCycles(false).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public V addVertex()
&nbsp;    {
<b class="fc">&nbsp;        V v = super.addVertex();</b>
&nbsp;
<b class="fc">&nbsp;        if (v != null) {</b>
&nbsp;            // add to the topological map
<b class="fc">&nbsp;            ++maxTopoIndex;</b>
<b class="fc">&nbsp;            topoOrderMap.putVertex(maxTopoIndex, v);</b>
<b class="fc">&nbsp;            ++topoModCount;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean addVertex(V v)
&nbsp;    {
<b class="fc">&nbsp;        boolean added = super.addVertex(v);</b>
&nbsp;
<b class="fc">&nbsp;        if (added) {</b>
&nbsp;            // add to the topological map
<b class="fc">&nbsp;            ++maxTopoIndex;</b>
<b class="fc">&nbsp;            topoOrderMap.putVertex(maxTopoIndex, v);</b>
<b class="fc">&nbsp;            ++topoModCount;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return added;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean removeVertex(V v)
&nbsp;    {
<b class="fc">&nbsp;        boolean removed = super.removeVertex(v);</b>
&nbsp;
<b class="fc">&nbsp;        if (removed) {</b>
&nbsp;            /*
&nbsp;             * Depending on the topoOrderMap implementation, this can leave holes in the topological
&nbsp;             * ordering, which can degrade performance for certain operations over time.
&nbsp;             */
<b class="fc">&nbsp;            Integer topoIndex = topoOrderMap.removeVertex(v);</b>
&nbsp;
&nbsp;            // if possible contract minTopoIndex
<b class="fc">&nbsp;            if (topoIndex == minTopoIndex) {</b>
<b class="nc">&nbsp;                while ((minTopoIndex &lt; 0) &amp;&amp; (topoOrderMap.getVertex(minTopoIndex) == null)) {</b>
<b class="nc">&nbsp;                    ++minTopoIndex;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // if possible contract maxTopoIndex
<b class="fc">&nbsp;            if (topoIndex == maxTopoIndex) {</b>
<b class="nc">&nbsp;                while ((maxTopoIndex &gt; 0) &amp;&amp; (topoOrderMap.getVertex(maxTopoIndex) == null)) {</b>
<b class="nc">&nbsp;                    --maxTopoIndex;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            ++topoModCount;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return removed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The complexity of adding a new edge in the graph depends on the number of edges incident to
&nbsp;     * the &quot;affected region&quot;, and should in general be faster than recomputing the whole topological
&nbsp;     * ordering from scratch.
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException if the edge would induce a cycle in the graph
&nbsp;     */
&nbsp;    @Override
&nbsp;    public E addEdge(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="fc">&nbsp;        assertVertexExist(sourceVertex);</b>
<b class="fc">&nbsp;        assertVertexExist(targetVertex);</b>
&nbsp;
&nbsp;        E result;
&nbsp;        try {
<b class="fc">&nbsp;            updateDag(sourceVertex, targetVertex);</b>
<b class="fc">&nbsp;            result = super.addEdge(sourceVertex, targetVertex);</b>
<b class="fc">&nbsp;        } catch (CycleFoundException e) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(EDGE_WOULD_INDUCE_A_CYCLE);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The complexity of adding a new edge in the graph depends on the number of edges incident to
&nbsp;     * the &quot;affected region&quot;, and should in general be faster than recomputing the whole topological
&nbsp;     * ordering from scratch.
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException if the edge would induce a cycle in the graph
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean addEdge(V sourceVertex, V targetVertex, E e)
&nbsp;    {
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException();</b>
<b class="nc">&nbsp;        } else if (containsEdge(e)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        assertVertexExist(sourceVertex);</b>
<b class="nc">&nbsp;        assertVertexExist(targetVertex);</b>
&nbsp;
&nbsp;        boolean result;
&nbsp;        try {
<b class="nc">&nbsp;            updateDag(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            result = super.addEdge(sourceVertex, targetVertex, e);</b>
<b class="nc">&nbsp;        } catch (CycleFoundException ex) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(EDGE_WOULD_INDUCE_A_CYCLE);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ancestors of a vertex.
&nbsp;     *
&nbsp;     * @param vertex the vertex to get the ancestors of
&nbsp;     * @return {@link Set} of ancestors of a vertex
&nbsp;     */
&nbsp;    public Set&lt;V&gt; getAncestors(V vertex)
&nbsp;    {
<b class="fc">&nbsp;        EdgeReversedGraph&lt;V, E&gt; reversedGraph = new EdgeReversedGraph&lt;&gt;(this);</b>
<b class="fc">&nbsp;        Iterator&lt;V&gt; iterator = new DepthFirstIterator&lt;&gt;(reversedGraph, vertex);</b>
<b class="fc">&nbsp;        Set&lt;V&gt; ancestors = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // Do not add start vertex to result.
<b class="fc">&nbsp;        if (iterator.hasNext()) {</b>
<b class="fc">&nbsp;            iterator.next();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        iterator.forEachRemaining(ancestors::add);</b>
&nbsp;
<b class="fc">&nbsp;        return ancestors;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the descendants of a vertex.
&nbsp;     *
&nbsp;     * @param vertex the vertex to get the descendants of
&nbsp;     * @return {@link Set} of descendants of a vertex
&nbsp;     */
&nbsp;    public Set&lt;V&gt; getDescendants(V vertex)
&nbsp;    {
<b class="fc">&nbsp;        Iterator&lt;V&gt; iterator = new DepthFirstIterator&lt;&gt;(this, vertex);</b>
<b class="fc">&nbsp;        Set&lt;V&gt; descendants = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // Do not add start vertex to result.
<b class="fc">&nbsp;        if (iterator.hasNext()) {</b>
<b class="fc">&nbsp;            iterator.next();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        iterator.forEachRemaining(descendants::add);</b>
&nbsp;
<b class="fc">&nbsp;        return descendants;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a topological order iterator.
&nbsp;     *
&nbsp;     * @return a topological order iterator
&nbsp;     */
&nbsp;    public Iterator&lt;V&gt; iterator()
&nbsp;    {
<b class="fc">&nbsp;        return new TopoIterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update as if a new edge is added.
&nbsp;     *
&nbsp;     * @param sourceVertex the source vertex
&nbsp;     * @param targetVertex the target vertex
&nbsp;     */
&nbsp;    private void updateDag(V sourceVertex, V targetVertex)
&nbsp;        throws CycleFoundException
&nbsp;    {
<b class="fc">&nbsp;        Integer lb = topoOrderMap.getTopologicalIndex(targetVertex);</b>
<b class="fc">&nbsp;        Integer ub = topoOrderMap.getTopologicalIndex(sourceVertex);</b>
&nbsp;
<b class="fc">&nbsp;        if (lb &lt; ub) {</b>
<b class="fc">&nbsp;            Set&lt;V&gt; df = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;            Set&lt;V&gt; db = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;            // discovery
<b class="fc">&nbsp;            Region affectedRegion = new Region(lb, ub);</b>
<b class="fc">&nbsp;            VisitedStrategy visited = visitedStrategyFactory.getVisitedStrategy(affectedRegion);</b>
&nbsp;
&nbsp;            // throws CycleFoundException if there is a cycle
<b class="fc">&nbsp;            dfsF(targetVertex, df, visited, affectedRegion);</b>
<b class="fc">&nbsp;            dfsB(sourceVertex, db, visited, affectedRegion);</b>
<b class="fc">&nbsp;            reorder(df, db, visited);</b>
&nbsp;
&nbsp;            /*
&nbsp;             * if we do a reorder, then the topology has been updated
&nbsp;             */
<b class="fc">&nbsp;            ++topoModCount;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Depth first search forward, building up the set (df) of forward-connected vertices in the
&nbsp;     * Affected Region
&nbsp;     *
&nbsp;     * @param initialVertex the vertex being visited
&nbsp;     * @param df the set we are populating with forward connected vertices in the Affected Region
&nbsp;     * @param visited a simple data structure that lets us know if we already visited a node with a
&nbsp;     *        given topo index
&nbsp;     *
&nbsp;     * @throws CycleFoundException if a cycle is discovered
&nbsp;     */
&nbsp;    private void dfsF(V initialVertex, Set&lt;V&gt; df, VisitedStrategy visited, Region affectedRegion)
&nbsp;        throws CycleFoundException
&nbsp;    {
<b class="fc">&nbsp;        Deque&lt;V&gt; vertices = new ArrayDeque&lt;&gt;();</b>
<b class="fc">&nbsp;        vertices.push(initialVertex);</b>
&nbsp;
<b class="fc">&nbsp;        while (!vertices.isEmpty()) {</b>
<b class="fc">&nbsp;            V vertex = vertices.pop();</b>
<b class="fc">&nbsp;            int topoIndex = topoOrderMap.getTopologicalIndex(vertex);</b>
&nbsp;
<b class="fc">&nbsp;            if (visited.getVisited(topoIndex)) {</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Assumption: vertex is in the AR and so it will be in visited
<b class="fc">&nbsp;            visited.setVisited(topoIndex);</b>
&nbsp;
<b class="fc">&nbsp;            df.add(vertex);</b>
&nbsp;
<b class="fc">&nbsp;            for (E outEdge : outgoingEdgesOf(vertex)) {</b>
<b class="fc">&nbsp;                V nextVertex = getEdgeTarget(outEdge);</b>
<b class="fc">&nbsp;                Integer nextVertexTopoIndex = topoOrderMap.getTopologicalIndex(nextVertex);</b>
&nbsp;
<b class="fc">&nbsp;                if (nextVertexTopoIndex == affectedRegion.finish) {</b>
&nbsp;                    // reset visited
&nbsp;                    try {
<b class="fc">&nbsp;                        for (V visitedVertex : df) {</b>
<b class="fc">&nbsp;                            visited.clearVisited(topoOrderMap.getTopologicalIndex(visitedVertex));</b>
<b class="fc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    } catch (UnsupportedOperationException e) {</b>
&nbsp;                        // okay, fine, some implementations (ones that automatically
&nbsp;                        // reset themselves out) don&#39;t work this way
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    throw new CycleFoundException();</b>
&nbsp;                }
&nbsp;
&nbsp;                /*
&nbsp;                 * Note, order of checks is important as we need to make sure the vertex is in the
&nbsp;                 * affected region before we check its visited status (otherwise we will be causing
&nbsp;                 * an ArrayIndexOutOfBoundsException).
&nbsp;                 */
<b class="fc">&nbsp;                if (affectedRegion.isIn(nextVertexTopoIndex)</b>
<b class="fc">&nbsp;                    &amp;&amp; !visited.getVisited(nextVertexTopoIndex))</b>
&nbsp;                {
<b class="fc">&nbsp;                    vertices.push(nextVertex); // recurse</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Depth first search backward, building up the set (db) of back-connected vertices in the
&nbsp;     * Affected Region
&nbsp;     *
&nbsp;     * @param initialVertex the vertex being visited
&nbsp;     * @param db the set we are populating with back-connected vertices in the AR
&nbsp;     * @param visited
&nbsp;     */
&nbsp;    private void dfsB(V initialVertex, Set&lt;V&gt; db, VisitedStrategy visited, Region affectedRegion)
&nbsp;    {
<b class="fc">&nbsp;        Deque&lt;V&gt; vertices = new ArrayDeque&lt;&gt;();</b>
<b class="fc">&nbsp;        vertices.push(initialVertex);</b>
&nbsp;
<b class="fc">&nbsp;        while (!vertices.isEmpty()) {</b>
<b class="fc">&nbsp;            V vertex = vertices.pop();</b>
&nbsp;            // Assumption: vertex is in the AR and so we will get a topoIndex from
&nbsp;            // the map
<b class="fc">&nbsp;            int topoIndex = topoOrderMap.getTopologicalIndex(vertex);</b>
&nbsp;
<b class="fc">&nbsp;            if (visited.getVisited(topoIndex)) {</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            visited.setVisited(topoIndex);</b>
&nbsp;
<b class="fc">&nbsp;            db.add(vertex);</b>
&nbsp;
<b class="fc">&nbsp;            for (E inEdge : incomingEdgesOf(vertex)) {</b>
<b class="fc">&nbsp;                V previousVertex = getEdgeSource(inEdge);</b>
<b class="fc">&nbsp;                Integer previousVertexTopoIndex = topoOrderMap.getTopologicalIndex(previousVertex);</b>
&nbsp;
&nbsp;                /*
&nbsp;                 * Note, order of checks is important as we need to make sure the vertex is in the
&nbsp;                 * affected region before we check its visited status (otherwise we will be causing
&nbsp;                 * an ArrayIndexOutOfBoundsException).
&nbsp;                 */
<b class="fc">&nbsp;                if (affectedRegion.isIn(previousVertexTopoIndex)</b>
<b class="fc">&nbsp;                    &amp;&amp; !visited.getVisited(previousVertexTopoIndex))</b>
&nbsp;                {
&nbsp;                    // if previousVertexTopoIndex != null, the vertex is in the
&nbsp;                    // Affected Region according to our topoIndexMap
<b class="fc">&nbsp;                    vertices.push(previousVertex);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void reorder(Set&lt;V&gt; df, Set&lt;V&gt; db, VisitedStrategy visited)
&nbsp;    {
<b class="fc">&nbsp;        List&lt;V&gt; topoDf = new ArrayList&lt;&gt;(df);</b>
<b class="fc">&nbsp;        List&lt;V&gt; topoDb = new ArrayList&lt;&gt;(db);</b>
&nbsp;
<b class="fc">&nbsp;        topoDf.sort(topoComparator);</b>
<b class="fc">&nbsp;        topoDb.sort(topoComparator);</b>
&nbsp;
&nbsp;        // merge these suckers together in topological order
<b class="fc">&nbsp;        SortedSet&lt;Integer&gt; availableTopoIndices = new TreeSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // we have to cast to the generic type, can&#39;t do &quot;new V[size]&quot; in java
&nbsp;        // 5;
<b class="fc">&nbsp;        V[] bigL = (V[]) new Object[df.size() + db.size()];</b>
<b class="fc">&nbsp;        int lIndex = 0; // this index is used for the sole purpose of pushing</b>
&nbsp;                        // into
&nbsp;
&nbsp;        // the correct index of bigL
&nbsp;        // assume (for now) that we are resetting visited
<b class="fc">&nbsp;        boolean clearVisited = true;</b>
&nbsp;
<b class="fc">&nbsp;        for (V vertex : topoDb) {</b>
<b class="fc">&nbsp;            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);</b>
&nbsp;
&nbsp;            // add the available indices to the set
<b class="fc">&nbsp;            availableTopoIndices.add(topoIndex);</b>
&nbsp;
<b class="fc">&nbsp;            bigL[lIndex++] = vertex;</b>
&nbsp;
<b class="fc">&nbsp;            if (clearVisited) { // reset visited status if supported</b>
&nbsp;                try {
<b class="fc">&nbsp;                    visited.clearVisited(topoIndex);</b>
<b class="nc">&nbsp;                } catch (UnsupportedOperationException e) {</b>
<b class="nc">&nbsp;                    clearVisited = false;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for (V vertex : topoDf) {</b>
<b class="fc">&nbsp;            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);</b>
&nbsp;
&nbsp;            // add the available indices to the set
<b class="fc">&nbsp;            availableTopoIndices.add(topoIndex);</b>
<b class="fc">&nbsp;            bigL[lIndex++] = vertex;</b>
&nbsp;
<b class="fc">&nbsp;            if (clearVisited) { // reset visited status if supported</b>
&nbsp;                try {
<b class="fc">&nbsp;                    visited.clearVisited(topoIndex);</b>
<b class="nc">&nbsp;                } catch (UnsupportedOperationException e) {</b>
<b class="nc">&nbsp;                    clearVisited = false;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        lIndex = 0; // reusing lIndex</b>
<b class="fc">&nbsp;        for (Integer topoIndex : availableTopoIndices) {</b>
&nbsp;            // assign the indexes to the elements of bigL in order
<b class="fc">&nbsp;            V vertex = bigL[lIndex++]; // note the post-increment</b>
<b class="fc">&nbsp;            topoOrderMap.putVertex(topoIndex, vertex);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An interface for storing the topological ordering.
&nbsp;     *
&nbsp;     * @param &lt;V&gt; the graph vertex type
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected interface TopoOrderMap&lt;V&gt;
&nbsp;        extends
&nbsp;        Serializable
&nbsp;    {
&nbsp;        /**
&nbsp;         * Add a vertex at the given topological index.
&nbsp;         *
&nbsp;         * @param index the topological index
&nbsp;         * @param vertex the vertex
&nbsp;         */
&nbsp;        void putVertex(Integer index, V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Get the vertex at the given topological index.
&nbsp;         *
&nbsp;         * @param index the topological index
&nbsp;         * @return vertex the vertex
&nbsp;         */
&nbsp;        V getVertex(Integer index);
&nbsp;
&nbsp;        /**
&nbsp;         * Get the topological index of the given vertex.
&nbsp;         *
&nbsp;         * @param vertex the vertex
&nbsp;         * @return the index that the vertex is at, or null if the vertex isn&#39;t in the topological
&nbsp;         *         ordering
&nbsp;         */
&nbsp;        Integer getTopologicalIndex(V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Remove the given vertex from the topological ordering.
&nbsp;         *
&nbsp;         * @param vertex the vertex
&nbsp;         * @return the index that the vertex was at, or null if the vertex wasn&#39;t in the topological
&nbsp;         *         ordering
&nbsp;         */
&nbsp;        Integer removeVertex(V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Remove all vertices from the topological ordering.
&nbsp;         */
&nbsp;        void removeAllVertices();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A strategy for marking vertices as visited.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Vertices are indexed by their topological index, to avoid using the vertex type in the
&nbsp;     * interface.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected interface VisitedStrategy
&nbsp;    {
&nbsp;        /**
&nbsp;         * Mark the given topological index as visited.
&nbsp;         *
&nbsp;         * @param index the topological index
&nbsp;         */
&nbsp;        void setVisited(int index);
&nbsp;
&nbsp;        /**
&nbsp;         * Get if the given topological index has been visited.
&nbsp;         *
&nbsp;         * @param index the topological index
&nbsp;         * @return true if the given topological index has been visited, false otherwise
&nbsp;         */
&nbsp;        boolean getVisited(int index);
&nbsp;
&nbsp;        /**
&nbsp;         * Clear the visited state of the given topological index.
&nbsp;         *
&nbsp;         * @param index the index
&nbsp;         * @throws UnsupportedOperationException if the implementation doesn&#39;t support (or doesn&#39;t
&nbsp;         *         need) clearance. For example, if the factory creates a new instance every time,
&nbsp;         *         it is a waste of cycles to reset the state after the search of the Affected
&nbsp;         *         Region is done, so an UnsupportedOperationException *should* be thrown.
&nbsp;         */
&nbsp;        void clearVisited(int index)
&nbsp;            throws UnsupportedOperationException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A visited strategy factory.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected interface VisitedStrategyFactory
&nbsp;        extends
&nbsp;        Serializable
&nbsp;    {
&nbsp;        /**
&nbsp;         * Create a new instance of {@link VisitedStrategy}.
&nbsp;         *
&nbsp;         * @param affectedRegion the affected region
&nbsp;         * @return a new instance of {@link VisitedStrategy} for the affected region
&nbsp;         */
&nbsp;        VisitedStrategy getVisitedStrategy(Region affectedRegion);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dual map implementation of the topological order map.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected static class TopoVertexBiMap&lt;V&gt;
&nbsp;        implements
&nbsp;        TopoOrderMap&lt;V&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        private final Map&lt;Integer, V&gt; topoToVertex = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        private final Map&lt;V, Integer&gt; vertexToTopo = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor
&nbsp;         */
&nbsp;        public TopoVertexBiMap()
<b class="fc">&nbsp;        {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void putVertex(Integer index, V vertex)
&nbsp;        {
<b class="fc">&nbsp;            topoToVertex.put(index, vertex);</b>
<b class="fc">&nbsp;            vertexToTopo.put(vertex, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V getVertex(Integer index)
&nbsp;        {
<b class="fc">&nbsp;            return topoToVertex.get(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer getTopologicalIndex(V vertex)
&nbsp;        {
<b class="fc">&nbsp;            return vertexToTopo.get(vertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer removeVertex(V vertex)
&nbsp;        {
<b class="fc">&nbsp;            Integer topoIndex = vertexToTopo.remove(vertex);</b>
<b class="fc">&nbsp;            if (topoIndex != null) {</b>
<b class="fc">&nbsp;                topoToVertex.remove(topoIndex);</b>
&nbsp;            }
<b class="fc">&nbsp;            return topoIndex;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void removeAllVertices()
&nbsp;        {
<b class="nc">&nbsp;            vertexToTopo.clear();</b>
<b class="nc">&nbsp;            topoToVertex.clear();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of the topological order map which for performance and flexibility uses an
&nbsp;     * ArrayList for topological index to vertex mapping, and a HashMap for vertex to topological
&nbsp;     * index mapping.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected class TopoVertexMap
&nbsp;        implements
&nbsp;        TopoOrderMap&lt;V&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        private final List&lt;V&gt; topoToVertex = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        private final Map&lt;V, Integer&gt; vertexToTopo = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor
&nbsp;         */
&nbsp;        public TopoVertexMap()
<b class="nc">&nbsp;        {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void putVertex(Integer index, V vertex)
&nbsp;        {
<b class="nc">&nbsp;            int translatedIndex = translateIndex(index);</b>
&nbsp;
&nbsp;            // grow topoToVertex as needed to accommodate elements
<b class="nc">&nbsp;            while ((translatedIndex + 1) &gt; topoToVertex.size()) {</b>
<b class="nc">&nbsp;                topoToVertex.add(null);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            topoToVertex.set(translatedIndex, vertex);</b>
<b class="nc">&nbsp;            vertexToTopo.put(vertex, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V getVertex(Integer index)
&nbsp;        {
<b class="nc">&nbsp;            return topoToVertex.get(translateIndex(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer getTopologicalIndex(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return vertexToTopo.get(vertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer removeVertex(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            Integer topoIndex = vertexToTopo.remove(vertex);</b>
<b class="nc">&nbsp;            if (topoIndex != null) {</b>
<b class="nc">&nbsp;                topoToVertex.set(translateIndex(topoIndex), null);</b>
&nbsp;            }
<b class="nc">&nbsp;            return topoIndex;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void removeAllVertices()
&nbsp;        {
<b class="nc">&nbsp;            vertexToTopo.clear();</b>
<b class="nc">&nbsp;            topoToVertex.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * We translate the topological index to an ArrayList index. We have to do this because
&nbsp;         * topological indices can be negative, and we want to do it because we can make better use
&nbsp;         * of space by only needing an ArrayList of size |AR|.
&nbsp;         *
&nbsp;         * @return the ArrayList index
&nbsp;         */
&nbsp;        private int translateIndex(int index)
&nbsp;        {
<b class="nc">&nbsp;            if (index &gt;= 0) {</b>
<b class="nc">&nbsp;                return 2 * index;</b>
&nbsp;            }
<b class="nc">&nbsp;            return -1 * ((index * 2) - 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An inclusive range of indices: [start, finish].
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
<b class="fc">&nbsp;    protected static class Region</b>
&nbsp;        implements
&nbsp;        Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        private final int start;
&nbsp;        private final int finish;
&nbsp;
&nbsp;        /**
&nbsp;         * Construct a new region.
&nbsp;         *
&nbsp;         * @param start the start of the region
&nbsp;         * @param finish the end of the region (inclusive)
&nbsp;         */
&nbsp;        public Region(int start, int finish)
<b class="fc">&nbsp;        {</b>
<b class="fc">&nbsp;            if (start &gt; finish) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;(start &gt; finish): invariant broken&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            this.start = start;</b>
<b class="fc">&nbsp;            this.finish = finish;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the size of the region.
&nbsp;         *
&nbsp;         * @return the size of the region
&nbsp;         */
&nbsp;        public int getSize()
&nbsp;        {
<b class="nc">&nbsp;            return (finish - start) + 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Check if index is in the region.
&nbsp;         *
&nbsp;         * @param index the index to check
&nbsp;         * @return true if the index is in the region, false otherwise
&nbsp;         */
&nbsp;        public boolean isIn(int index)
&nbsp;        {
<b class="fc">&nbsp;            return (index &gt;= start) &amp;&amp; (index &lt;= finish);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the start of the region.
&nbsp;         *
&nbsp;         * @return the start of the region
&nbsp;         */
&nbsp;        public int getStart()
&nbsp;        {
<b class="nc">&nbsp;            return start;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the end of the region (inclusive).
&nbsp;         *
&nbsp;         * @return the end of the region (inclusive)
&nbsp;         */
&nbsp;        public int getFinish()
&nbsp;        {
<b class="nc">&nbsp;            return finish;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A visited strategy which uses a {@link BitSet}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation is close to the performance of {@link VisitedArrayListImpl}, with 1/8 the
&nbsp;     * memory usage.
&nbsp;     *
&nbsp;     * @author John V. Sichi
&nbsp;     */
&nbsp;    protected static class VisitedBitSetImpl
&nbsp;        implements
&nbsp;        VisitedStrategy,
&nbsp;        VisitedStrategyFactory
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        private final BitSet visited = new BitSet();</b>
&nbsp;        private Region affectedRegion;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor
&nbsp;         */
&nbsp;        public VisitedBitSetImpl()
<b class="fc">&nbsp;        {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VisitedStrategy getVisitedStrategy(Region affectedRegion)
&nbsp;        {
<b class="fc">&nbsp;            this.affectedRegion = affectedRegion;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setVisited(int index)
&nbsp;        {
<b class="fc">&nbsp;            visited.set(translateIndex(index), true);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean getVisited(int index)
&nbsp;        {
<b class="fc">&nbsp;            return visited.get(translateIndex(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clearVisited(int index)
&nbsp;            throws UnsupportedOperationException
&nbsp;        {
<b class="fc">&nbsp;            visited.clear(translateIndex(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * We translate the topological index to an ArrayList index. We have to do this because
&nbsp;         * topological indices can be negative, and we want to do it because we can make better use
&nbsp;         * of space by only needing an ArrayList of size |AR|.
&nbsp;         *
&nbsp;         * @return the ArrayList index
&nbsp;         */
&nbsp;        private int translateIndex(int index)
&nbsp;        {
<b class="fc">&nbsp;            return index - affectedRegion.start;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A visited strategy using an {@link ArrayList}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation seems to offer the best performance in most cases. It grows the internal
&nbsp;     * ArrayList as needed to be as large as |AR|, so it will be more memory intensive than the
&nbsp;     * HashSet implementation, and unlike the Array implementation, it will hold on to that memory
&nbsp;     * (it expands, but never contracts).
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected static class VisitedArrayListImpl
&nbsp;        implements
&nbsp;        VisitedStrategy,
&nbsp;        VisitedStrategyFactory
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        private final List&lt;Boolean&gt; visited = new ArrayList&lt;&gt;();</b>
&nbsp;        private Region affectedRegion;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor
&nbsp;         */
&nbsp;        public VisitedArrayListImpl()
<b class="nc">&nbsp;        {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VisitedStrategy getVisitedStrategy(Region affectedRegion)
&nbsp;        {
&nbsp;            // Make sure visited is big enough
<b class="nc">&nbsp;            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;</b>
&nbsp;            /* plus one because the region range is inclusive of both indices */
&nbsp;
<b class="nc">&nbsp;            while (visited.size() &lt; minSize) {</b>
<b class="nc">&nbsp;                visited.add(Boolean.FALSE);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            this.affectedRegion = affectedRegion;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            visited.set(translateIndex(index), Boolean.TRUE);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean getVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            return visited.get(translateIndex(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clearVisited(int index)
&nbsp;            throws UnsupportedOperationException
&nbsp;        {
<b class="nc">&nbsp;            visited.set(translateIndex(index), Boolean.FALSE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * We translate the topological index to an ArrayList index. We have to do this because
&nbsp;         * topological indices can be negative, and we want to do it because we can make better use
&nbsp;         * of space by only needing an ArrayList of size |AR|.
&nbsp;         *
&nbsp;         * @return the ArrayList index
&nbsp;         */
&nbsp;        private int translateIndex(int index)
&nbsp;        {
<b class="nc">&nbsp;            return index - affectedRegion.start;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A visited strategy using a {@link HashSet}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation doesn&#39;t seem to perform as well, though I can imagine circumstances where
&nbsp;     * it should shine (lots and lots of vertices). It also should have the lowest memory footprint
&nbsp;     * as it only uses storage for indices that have been visited.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected static class VisitedHashSetImpl
&nbsp;        implements
&nbsp;        VisitedStrategy,
&nbsp;        VisitedStrategyFactory
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        private final Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor
&nbsp;         */
&nbsp;        public VisitedHashSetImpl()
<b class="nc">&nbsp;        {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VisitedStrategy getVisitedStrategy(Region affectedRegion)
&nbsp;        {
<b class="nc">&nbsp;            visited.clear();</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            visited.add(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean getVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            return visited.contains(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clearVisited(int index)
&nbsp;            throws UnsupportedOperationException
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A visited strategy using an array.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation, somewhat to my surprise, is slower than the ArrayList version, probably
&nbsp;     * due to its reallocation of the underlying array for every topology reorder that is required.
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    protected static class VisitedArrayImpl
&nbsp;        implements
&nbsp;        VisitedStrategy,
&nbsp;        VisitedStrategyFactory
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        private final boolean[] visited;
&nbsp;        private final Region region;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructs empty instance
&nbsp;         */
&nbsp;        public VisitedArrayImpl()
&nbsp;        {
<b class="nc">&nbsp;            this(null);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Construct an empty instance for a region.
&nbsp;         *
&nbsp;         * @param region the region
&nbsp;         */
&nbsp;        public VisitedArrayImpl(Region region)
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            if (region == null) { // make empty instance</b>
<b class="nc">&nbsp;                this.visited = null;</b>
<b class="nc">&nbsp;                this.region = null;</b>
&nbsp;            } else { // fill in the needed pieces
<b class="nc">&nbsp;                this.region = region;</b>
&nbsp;
&nbsp;                // initialized to all false by default
<b class="nc">&nbsp;                visited = new boolean[region.getSize()];</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VisitedStrategy getVisitedStrategy(Region affectedRegion)
&nbsp;        {
<b class="nc">&nbsp;            return new VisitedArrayImpl(affectedRegion);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            visited[index - region.start] = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean getVisited(int index)
&nbsp;        {
<b class="nc">&nbsp;            return visited[index - region.start];</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clearVisited(int index)
&nbsp;            throws UnsupportedOperationException
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exception used in dfsF when a cycle is found
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
<b class="fc">&nbsp;    private static class CycleFoundException</b>
&nbsp;        extends
&nbsp;        Exception
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 5583471522212552754L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Comparator for vertices based on their topological ordering
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
<b class="fc">&nbsp;    private class TopoComparator</b>
&nbsp;        implements
&nbsp;        Comparator&lt;V&gt;,
&nbsp;        Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 8144905376266340066L;
&nbsp;
&nbsp;        @Override
&nbsp;        public int compare(V o1, V o2)
&nbsp;        {
<b class="fc">&nbsp;            return topoOrderMap</b>
<b class="fc">&nbsp;                .getTopologicalIndex(o1).compareTo(topoOrderMap.getTopologicalIndex(o2));</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An iterator which follows topological order
&nbsp;     *
&nbsp;     * @author Peter Giles
&nbsp;     */
&nbsp;    private class TopoIterator
&nbsp;        implements
&nbsp;        Iterator&lt;V&gt;
&nbsp;    {
&nbsp;        private int currentTopoIndex;
<b class="fc">&nbsp;        private final long expectedTopoModCount = topoModCount;</b>
<b class="fc">&nbsp;        private Integer nextIndex = null;</b>
&nbsp;
&nbsp;        public TopoIterator()
<b class="fc">&nbsp;        {</b>
<b class="fc">&nbsp;            currentTopoIndex = minTopoIndex - 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasNext()
&nbsp;        {
<b class="fc">&nbsp;            if (expectedTopoModCount != topoModCount) {</b>
<b class="fc">&nbsp;                throw new ConcurrentModificationException();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            nextIndex = getNextIndex();</b>
<b class="fc">&nbsp;            return nextIndex != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V next()
&nbsp;        {
<b class="fc">&nbsp;            if (expectedTopoModCount != topoModCount) {</b>
<b class="fc">&nbsp;                throw new ConcurrentModificationException();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (nextIndex == null) {</b>
&nbsp;                // find nextIndex
<b class="fc">&nbsp;                nextIndex = getNextIndex();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (nextIndex == null) {</b>
<b class="fc">&nbsp;                throw new NoSuchElementException();</b>
&nbsp;            }
<b class="fc">&nbsp;            currentTopoIndex = nextIndex;</b>
<b class="fc">&nbsp;            nextIndex = null;</b>
<b class="fc">&nbsp;            return topoOrderMap.getVertex(currentTopoIndex);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void remove()
&nbsp;        {
<b class="fc">&nbsp;            if (expectedTopoModCount != topoModCount) {</b>
<b class="fc">&nbsp;                throw new ConcurrentModificationException();</b>
&nbsp;            }
&nbsp;
&nbsp;            V vertexToRemove;
<b class="nc">&nbsp;            if ((vertexToRemove = topoOrderMap.getVertex(currentTopoIndex)) != null) {</b>
<b class="nc">&nbsp;                topoOrderMap.removeVertex(vertexToRemove);</b>
&nbsp;            } else {
&nbsp;                // should only happen if next() hasn&#39;t been called
<b class="nc">&nbsp;                throw new IllegalStateException();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private Integer getNextIndex()
&nbsp;        {
<b class="fc">&nbsp;            for (int i = currentTopoIndex + 1; i &lt;= maxTopoIndex; i++) {</b>
<b class="fc">&nbsp;                if (topoOrderMap.getVertex(i) != null) {</b>
<b class="fc">&nbsp;                    return i;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 10:43</div>
</div>
</body>
</html>
