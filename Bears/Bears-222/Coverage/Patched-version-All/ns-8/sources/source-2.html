


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BergeGraphInspector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jgrapht.alg.cycle</a>
</div>

<h1>Coverage Summary for Class: BergeGraphInspector (org.jgrapht.alg.cycle)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BergeGraphInspector</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (37/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (588/672)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (C) Copyright 2016-2018, by Philipp S. Kaesgen and Contributors.
&nbsp; *
&nbsp; * JGraphT : a free Java graph-theory library
&nbsp; *
&nbsp; * See the CONTRIBUTORS.md file distributed with this work for additional
&nbsp; * information regarding copyright ownership.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Public License 2.0 which is available at
&nbsp; * http://www.eclipse.org/legal/epl-2.0, or the
&nbsp; * GNU Lesser General Public License v2.1 or later
&nbsp; * which is available at
&nbsp; * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
&nbsp; *
&nbsp; * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
&nbsp; */
&nbsp;package org.jgrapht.alg.cycle;
&nbsp;
&nbsp;import org.jgrapht.*;
&nbsp;import org.jgrapht.alg.connectivity.*;
&nbsp;import org.jgrapht.alg.shortestpath.*;
&nbsp;import org.jgrapht.generate.*;
&nbsp;import org.jgrapht.graph.*;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.*;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Tests whether a graph is &lt;a href=&quot;http://mathworld.wolfram.com/PerfectGraph.html&quot;&gt;perfect&lt;/a&gt;. A
&nbsp; * perfect graph, also known as a Berge graph, is a graph $G$ such that for every induced subgraph
&nbsp; * of $G$, the clique number $\chi(G)$ equals the chromatic number $\omega(G)$, i.e.,
&nbsp; * $\omega(G)=\chi(G)$. Another characterization of perfect graphs is given by the Strong Perfect
&nbsp; * Graph Theorem [M. Chudnovsky, N. Robertson, P. Seymour, R. Thomas. The strong perfect graph
&nbsp; * theorem Annals of Mathematics, vol 164(1): pp. 51â€“230, 2006]: A graph $G$ is perfect if neither
&nbsp; * $G$ nor its complement $\overline{G}$ have an odd hole. A hole in $G$ is an induced subgraph of
&nbsp; * $G$ that is a cycle of length at least four, and it is odd or even if it has odd (or even,
&nbsp; * respectively) length.
&nbsp; * &lt;p&gt;
&nbsp; * Some special &lt;a href=&quot;http://graphclasses.org/classes/gc_56.html&quot;&gt;classes&lt;/a&gt; of graphs are are
&nbsp; * known to be perfect, e.g. Bipartite graphs and Chordal graphs. Testing whether a graph is resp.
&nbsp; * Bipartite or Chordal can be done efficiently using {@link GraphTests#isBipartite} or
&nbsp; * {@link org.jgrapht.alg.cycle.ChordalityInspector}.
&nbsp; * &lt;p&gt;
&nbsp; * The implementation of this class is based on the paper: M. Chudnovsky, G. Cornuejols, X. Liu, P.
&nbsp; * Seymour, and K. Vuskovic. Recognizing Berge Graphs. Combinatorica 25(2): 143--186, 2003.
&nbsp; * &lt;p&gt;
&nbsp; * Special Thanks to Maria Chudnovsky for her kind help.
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * The runtime complexity of this implementation is $O(|V|^9|)$. This implementation is far more
&nbsp; * efficient than simplistically testing whether graph $G$ or its complement $\overline{G}$ have an
&nbsp; * odd cycle, because testing whether one graph can be found as an induced subgraph of another is
&nbsp; * &lt;a href=&quot;https://en.wikipedia.org/wiki/Induced_subgraph_isomorphism_problem&quot;&gt;known&lt;/a&gt; to be
&nbsp; * NP-hard.
&nbsp; * 
&nbsp; * @author Philipp S. Kaesgen (pkaesgen@freenet.de)
&nbsp; *
&nbsp; * @param &lt;V&gt; the graph vertex type
&nbsp; * @param &lt;E&gt; the graph edge type
&nbsp; */
<b class="fc">&nbsp;public class BergeGraphInspector&lt;V, E&gt;</b>
&nbsp;{
&nbsp;
<b class="fc">&nbsp;    private GraphPath&lt;V, E&gt; certificate = null;</b>
<b class="fc">&nbsp;    private boolean certify = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Lists the vertices which are covered by two paths
&nbsp;     * 
&nbsp;     * @param p1 A Path in g
&nbsp;     * @param p2 A Path in g
&nbsp;     * @return Set of vertices covered by both p1 and p2
&nbsp;     */
&nbsp;    private List&lt;V&gt; intersectGraphPaths(GraphPath&lt;V, E&gt; p1, GraphPath&lt;V, E&gt; p2)
&nbsp;    {
<b class="fc">&nbsp;        List&lt;V&gt; res = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;        res.addAll(p1.getVertexList());</b>
<b class="fc">&nbsp;        res.retainAll(p2.getVertexList());</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assembles a GraphPath of the Paths S and T. Required for the Pyramid Checker
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param S A Path in g
&nbsp;     * @param T A Path in g
&nbsp;     * @param m A vertex
&nbsp;     * @param b1 A base vertex
&nbsp;     * @param b2 A base vertex
&nbsp;     * @param b3 A base vertex
&nbsp;     * @param s1 A vertex
&nbsp;     * @param s2 A vertex
&nbsp;     * @param s3 A vertex
&nbsp;     * @return The conjunct path of S and T
&nbsp;     */
&nbsp;    private GraphPath&lt;V, E&gt; P(
&nbsp;            Graph&lt;V, E&gt; g, GraphPath&lt;V, E&gt; S, GraphPath&lt;V, E&gt; T, V m, V b1, V b2, V b3, V s1,
&nbsp;            V s2, V s3)
&nbsp;    {
<b class="fc">&nbsp;        if (s1 == b1) {</b>
<b class="fc">&nbsp;            if (b1 == m) {</b>
<b class="fc">&nbsp;                List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;                return new GraphWalk&lt;&gt;(g, s1, b1, edgeList, 0);</b>
&nbsp;            } else
<b class="fc">&nbsp;                return null;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            if (b1 == m)</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            if (g.containsEdge(m, b2) || g.containsEdge(m, b3) || g.containsEdge(m, s2)</b>
<b class="fc">&nbsp;                || g.containsEdge(m, s3) || S == null || T == null)</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            if (S.getVertexList().stream().anyMatch(</b>
<b class="fc">&nbsp;                t -&gt; g.containsEdge(t, b2) || g.containsEdge(t, b3) || g.containsEdge(t, s2)</b>
<b class="fc">&nbsp;                    || g.containsEdge(t, s3))</b>
<b class="fc">&nbsp;                || T.getVertexList().stream().anyMatch(</b>
<b class="fc">&nbsp;                    t -&gt; t != b1 &amp;&amp; (g.containsEdge(t, b2) || g.containsEdge(t, b3)</b>
<b class="fc">&nbsp;                        || g.containsEdge(t, s2) || g.containsEdge(t, s3))))</b>
<b class="nc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            List&lt;V&gt; intersection = intersectGraphPaths(S, T);</b>
<b class="fc">&nbsp;            if (intersection.size() != 1 || !intersection.contains(m))</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            if (S.getVertexList().stream().anyMatch(</b>
<b class="fc">&nbsp;                s -&gt; s != m</b>
<b class="fc">&nbsp;                    &amp;&amp; T.getVertexList().stream().anyMatch(t -&gt; t != m &amp;&amp; g.containsEdge(s, t))))</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;            edgeList.addAll(T.getEdgeList());</b>
<b class="fc">&nbsp;            edgeList.addAll(S.getEdgeList());</b>
<b class="fc">&nbsp;            double weight = edgeList.stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="fc">&nbsp;            return new GraphWalk&lt;&gt;(g, b1, s1, edgeList, weight);</b>
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void BFOddHoleCertificate(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        for (V start : g.vertexSet()) {</b>
<b class="fc">&nbsp;            if (g.degreeOf(start) &lt; 2)</b>
<b class="nc">&nbsp;                continue;</b>
<b class="fc">&nbsp;            Set&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;            set.addAll(g.vertexSet());</b>
<b class="fc">&nbsp;            for (V neighborOfStart : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (neighborOfStart == start || !g.containsEdge(start, neighborOfStart)</b>
<b class="fc">&nbsp;                    || g.degreeOf(neighborOfStart) != 2)</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                set.remove(neighborOfStart);</b>
<b class="fc">&nbsp;                Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, set);</b>
<b class="fc">&nbsp;                for (V neighborsNeighbor : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (neighborsNeighbor == start || neighborsNeighbor == neighborOfStart</b>
<b class="fc">&nbsp;                        || !g.containsEdge(neighborsNeighbor, neighborOfStart)</b>
<b class="fc">&nbsp;                        || g.containsEdge(neighborsNeighbor, start)</b>
<b class="fc">&nbsp;                        || g.degreeOf(neighborsNeighbor) &lt; 2)</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    GraphPath&lt;V, E&gt; path =</b>
<b class="fc">&nbsp;                        new DijkstraShortestPath&lt;&gt;(subg).getPath(start, neighborsNeighbor);</b>
<b class="fc">&nbsp;                    if (path == null || path.getLength() &lt; 3 || path.getLength() % 2 == 0)</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;                    edgeList.addAll(path.getEdgeList());</b>
<b class="fc">&nbsp;                    edgeList.add(g.getEdge(neighborsNeighbor, neighborOfStart));</b>
<b class="fc">&nbsp;                    edgeList.add(g.getEdge(neighborOfStart, start));</b>
<b class="fc">&nbsp;                    double weight = edgeList.stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="fc">&nbsp;                    certificate = new GraphWalk&lt;&gt;(g, start, start, edgeList, weight);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (certificate != null)</b>
<b class="fc">&nbsp;                    break;</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (certificate != null)</b>
<b class="fc">&nbsp;                break;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a graph contains a pyramid. Running time: O(|V(g)|^9)
&nbsp;     * 
&nbsp;     * @param g Graph
&nbsp;     * @return Either it finds a pyramid (and hence an odd hole) in g, or it determines that g
&nbsp;     *         contains no pyramid
&nbsp;     */
&nbsp;    boolean containsPyramid(Graph&lt;V, E&gt; g)
&nbsp;    {
&nbsp;        /*
&nbsp;         * A pyramid looks like this:
&nbsp;         * 
&nbsp;         * b2-(T2)-m2-(S2)-s2 / | \ b1---(T1)-m1-(S1)-s1--a \ | / b3-(T3)-m3-(S3)-s3
&nbsp;         * 
&nbsp;         * Note that b1, b2, and b3 are connected and all names in parentheses are paths
&nbsp;         * 
&nbsp;         */
<b class="fc">&nbsp;        Set&lt;Set&lt;V&gt;&gt; visitedTriangles = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (V b1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V b2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (b1 == b2 || !g.containsEdge(b1, b2))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                for (V b3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (b3 == b1 || b3 == b2 || !g.containsEdge(b2, b3) || !g.containsEdge(b1, b3))</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;
&nbsp;                    // Triangle detected for the pyramid base
<b class="fc">&nbsp;                    Set&lt;V&gt; triangles = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    triangles.add(b1);</b>
<b class="fc">&nbsp;                    triangles.add(b2);</b>
<b class="fc">&nbsp;                    triangles.add(b3);</b>
<b class="fc">&nbsp;                    if (visitedTriangles.contains(triangles)) {</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    visitedTriangles.add(triangles);</b>
&nbsp;
<b class="fc">&nbsp;                    for (V aCandidate : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (aCandidate == b1 || aCandidate == b2 || aCandidate == b3 ||</b>
&nbsp;                        // a is adjacent to at most one of b1,b2,b3
<b class="fc">&nbsp;                            g.containsEdge(aCandidate, b1) &amp;&amp; g.containsEdge(aCandidate, b2)</b>
<b class="fc">&nbsp;                            || g.containsEdge(aCandidate, b2) &amp;&amp; g.containsEdge(aCandidate, b3)</b>
<b class="fc">&nbsp;                            || g.containsEdge(aCandidate, b1) &amp;&amp; g.containsEdge(aCandidate, b3))</b>
&nbsp;                        {
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // aCandidate could now be the top of the pyramid
<b class="fc">&nbsp;                        for (V s1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                            if (s1 == aCandidate || !g.containsEdge(s1, aCandidate) || s1 == b2</b>
&nbsp;                                || s1 == b3
<b class="fc">&nbsp;                                || s1 != b1 &amp;&amp; (g.containsEdge(s1, b2) || g.containsEdge(s1, b3)))</b>
&nbsp;                            {
<b class="fc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            for (V s2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                                if (s2 == aCandidate || !g.containsEdge(s2, aCandidate)</b>
<b class="fc">&nbsp;                                    || g.containsEdge(s1, s2) || s1 == s2 || s2 == b1 || s2 == b3</b>
&nbsp;                                    || s2 != b2
<b class="fc">&nbsp;                                        &amp;&amp; (g.containsEdge(s2, b1) || g.containsEdge(s2, b3)))</b>
&nbsp;                                {
<b class="fc">&nbsp;                                    continue;</b>
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                                for (V s3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                                    if (s3 == aCandidate || !g.containsEdge(s3, aCandidate)</b>
<b class="fc">&nbsp;                                        || g.containsEdge(s3, s2) || s1 == s3 || s3 == s2</b>
<b class="fc">&nbsp;                                        || g.containsEdge(s1, s3) || s3 == b1 || s3 == b2</b>
&nbsp;                                        || s3 != b3
<b class="fc">&nbsp;                                            &amp;&amp; (g.containsEdge(s3, b1) || g.containsEdge(s3, b2)))</b>
&nbsp;                                    {
<b class="fc">&nbsp;                                        continue;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    // s1, s2, s3 could now be the closest vertices to the top
&nbsp;                                    // vertex of the pyramid
<b class="fc">&nbsp;                                    Set&lt;V&gt; M = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                    M.addAll(g.vertexSet());</b>
<b class="fc">&nbsp;                                    M.remove(b1);</b>
<b class="fc">&nbsp;                                    M.remove(b2);</b>
<b class="fc">&nbsp;                                    M.remove(b3);</b>
<b class="fc">&nbsp;                                    M.remove(s1);</b>
<b class="fc">&nbsp;                                    M.remove(s2);</b>
<b class="fc">&nbsp;                                    M.remove(s3);</b>
&nbsp;
<b class="fc">&nbsp;                                    Map&lt;V, GraphPath&lt;V, E&gt;&gt; S1 = new HashMap&lt;&gt;(),</b>
<b class="fc">&nbsp;                                        S2 = new HashMap&lt;&gt;(),</b>
<b class="fc">&nbsp;                                        S3 = new HashMap&lt;&gt;(),</b>
<b class="fc">&nbsp;                                        T1 = new HashMap&lt;&gt;(),</b>
<b class="fc">&nbsp;                                        T2 = new HashMap&lt;&gt;(),</b>
<b class="fc">&nbsp;                                        T3 = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;                                    // find paths which could be the edges of the pyramid
<b class="fc">&nbsp;                                    for (V m1 : M) {</b>
<b class="fc">&nbsp;                                        Set&lt;V&gt; validInterior = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                        validInterior.addAll(M);</b>
<b class="fc">&nbsp;                                        validInterior.removeIf(</b>
<b class="fc">&nbsp;                                            i -&gt; g.containsEdge(i, b2) || g.containsEdge(i, s2)</b>
<b class="fc">&nbsp;                                                || g.containsEdge(i, b3) || g.containsEdge(i, s3));</b>
&nbsp;
<b class="fc">&nbsp;                                        validInterior.add(m1);</b>
<b class="fc">&nbsp;                                        validInterior.add(s1);</b>
<b class="fc">&nbsp;                                        Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, validInterior);</b>
<b class="fc">&nbsp;                                        S1.put(</b>
&nbsp;                                            m1,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(m1, s1));</b>
<b class="fc">&nbsp;                                        validInterior.remove(s1);</b>
<b class="fc">&nbsp;                                        validInterior.add(b1);</b>
<b class="fc">&nbsp;                                        subg = new AsSubgraph&lt;&gt;(g, validInterior);</b>
<b class="fc">&nbsp;                                        T1.put(</b>
&nbsp;                                            m1,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(b1, m1));</b>
&nbsp;
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    for (V m2 : M) {</b>
<b class="fc">&nbsp;                                        Set&lt;V&gt; validInterior = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                        validInterior.addAll(M);</b>
<b class="fc">&nbsp;                                        validInterior.removeIf(</b>
<b class="fc">&nbsp;                                            i -&gt; g.containsEdge(i, b1) || g.containsEdge(i, s1)</b>
<b class="fc">&nbsp;                                                || g.containsEdge(i, b3) || g.containsEdge(i, s3));</b>
<b class="fc">&nbsp;                                        validInterior.add(m2);</b>
<b class="fc">&nbsp;                                        validInterior.add(s2);</b>
<b class="fc">&nbsp;                                        Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, validInterior);</b>
<b class="fc">&nbsp;                                        S2.put(</b>
&nbsp;                                            m2,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(m2, s2));</b>
<b class="fc">&nbsp;                                        validInterior.remove(s2);</b>
<b class="fc">&nbsp;                                        validInterior.add(b2);</b>
<b class="fc">&nbsp;                                        subg = new AsSubgraph&lt;&gt;(g, validInterior);</b>
<b class="fc">&nbsp;                                        T2.put(</b>
&nbsp;                                            m2,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(b2, m2));</b>
&nbsp;
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    for (V m3 : M) {</b>
<b class="fc">&nbsp;                                        Set&lt;V&gt; validInterior = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                        validInterior.addAll(M);</b>
<b class="fc">&nbsp;                                        validInterior.removeIf(</b>
<b class="fc">&nbsp;                                            i -&gt; g.containsEdge(i, b1) || g.containsEdge(i, s1)</b>
<b class="fc">&nbsp;                                                || g.containsEdge(i, b2) || g.containsEdge(i, s2));</b>
<b class="fc">&nbsp;                                        validInterior.add(m3);</b>
<b class="fc">&nbsp;                                        validInterior.add(s3);</b>
&nbsp;
<b class="fc">&nbsp;                                        Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, validInterior);</b>
<b class="fc">&nbsp;                                        S3.put(</b>
&nbsp;                                            m3,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(m3, s3));</b>
<b class="fc">&nbsp;                                        validInterior.remove(s3);</b>
<b class="fc">&nbsp;                                        validInterior.add(b3);</b>
<b class="fc">&nbsp;                                        subg = new AsSubgraph&lt;&gt;(g, validInterior, null);</b>
<b class="fc">&nbsp;                                        T3.put(</b>
&nbsp;                                            m3,
<b class="fc">&nbsp;                                                new DijkstraShortestPath&lt;&gt;(subg).getPath(b3, m3));</b>
<b class="fc">&nbsp;                                    }</b>
&nbsp;
&nbsp;                                    // Check if all edges of a pyramid are valid
<b class="fc">&nbsp;                                    Set&lt;V&gt; M1 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                    M1.addAll(M);</b>
<b class="fc">&nbsp;                                    M1.add(b1);</b>
<b class="fc">&nbsp;                                    for (V m1 : M1) {</b>
&nbsp;                                        GraphPath&lt;V,
<b class="fc">&nbsp;                                            E&gt; P1 = P(</b>
<b class="fc">&nbsp;                                                g, S1.get(m1), T1.get(m1), m1, b1, b2, b3, s1,</b>
&nbsp;                                                s2, s3);
<b class="fc">&nbsp;                                        if (P1 == null)</b>
<b class="fc">&nbsp;                                            continue;</b>
<b class="fc">&nbsp;                                        Set&lt;V&gt; M2 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                        M2.addAll(M);</b>
<b class="fc">&nbsp;                                        M2.add(b2);</b>
<b class="fc">&nbsp;                                        for (V m2 : M) {</b>
&nbsp;                                            GraphPath&lt;V,
<b class="fc">&nbsp;                                                E&gt; P2 = P(</b>
<b class="fc">&nbsp;                                                    g, S2.get(m2), T2.get(m2), m2, b2, b1, b3,</b>
&nbsp;                                                    s2, s1, s3);
<b class="fc">&nbsp;                                            if (P2 == null)</b>
<b class="fc">&nbsp;                                                continue;</b>
<b class="fc">&nbsp;                                            Set&lt;V&gt; M3 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                            M3.addAll(M);</b>
<b class="fc">&nbsp;                                            M3.add(b3);</b>
<b class="fc">&nbsp;                                            for (V m3 : M3) {</b>
&nbsp;                                                GraphPath&lt;V,
<b class="fc">&nbsp;                                                    E&gt; P3 = P(</b>
<b class="fc">&nbsp;                                                        g, S3.get(m3), T3.get(m3), m3, b3, b1,</b>
&nbsp;                                                        b2, s3, s1, s2);
<b class="fc">&nbsp;                                                if (P3 == null)</b>
<b class="fc">&nbsp;                                                    continue;</b>
<b class="fc">&nbsp;                                                if (certify) {</b>
<b class="fc">&nbsp;                                                    if ((P1.getLength() + P2.getLength())</b>
&nbsp;                                                        % 2 == 0)
&nbsp;                                                    {
<b class="fc">&nbsp;                                                        Set&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                                        set.addAll(P1.getVertexList());</b>
<b class="fc">&nbsp;                                                        set.addAll(P2.getVertexList());</b>
<b class="fc">&nbsp;                                                        set.add(aCandidate);</b>
<b class="fc">&nbsp;                                                        BFOddHoleCertificate(</b>
&nbsp;                                                            new AsSubgraph&lt;&gt;(g, set));
<b class="fc">&nbsp;                                                    } else if ((P1.getLength() + P3.getLength())</b>
&nbsp;                                                        % 2 == 0)
&nbsp;                                                    {
<b class="nc">&nbsp;                                                        Set&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                                                        set.addAll(P1.getVertexList());</b>
<b class="nc">&nbsp;                                                        set.addAll(P3.getVertexList());</b>
<b class="nc">&nbsp;                                                        set.add(aCandidate);</b>
<b class="nc">&nbsp;                                                        BFOddHoleCertificate(</b>
&nbsp;                                                            new AsSubgraph&lt;&gt;(g, set));
<b class="nc">&nbsp;                                                    } else {</b>
<b class="fc">&nbsp;                                                        Set&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                                        set.addAll(P3.getVertexList());</b>
<b class="fc">&nbsp;                                                        set.addAll(P2.getVertexList());</b>
<b class="fc">&nbsp;                                                        set.add(aCandidate);</b>
<b class="fc">&nbsp;                                                        BFOddHoleCertificate(</b>
&nbsp;                                                            new AsSubgraph&lt;&gt;(g, set));
&nbsp;                                                    }
&nbsp;                                                }
<b class="fc">&nbsp;                                                return true;</b>
&nbsp;
&nbsp;                                            }
&nbsp;
<b class="fc">&nbsp;                                        }</b>
&nbsp;
<b class="fc">&nbsp;                                    }</b>
&nbsp;
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;
<b class="fc">&nbsp;                        }</b>
&nbsp;
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds all Components of a set F contained in V(g)
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param F A vertex subset of g
&nbsp;     * @return Components of F in g
&nbsp;     */
&nbsp;    private List&lt;Set&lt;V&gt;&gt; findAllComponents(Graph&lt;V, E&gt; g, Set&lt;V&gt; F)
&nbsp;    {
<b class="fc">&nbsp;        return new ConnectivityInspector&lt;&gt;(new AsSubgraph&lt;&gt;(g, F)).connectedSets();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a graph contains a Jewel. Running time: O(|V(g)|^6)
&nbsp;     * 
&nbsp;     * @param g Graph
&nbsp;     * @return Decides whether there is a jewel in g
&nbsp;     */
&nbsp;    boolean containsJewel(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        for (V v2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V v3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (v2 == v3 || !g.containsEdge(v2, v3))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                for (V v5 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (v2 == v5 || v3 == v5)</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;
<b class="fc">&nbsp;                    Set&lt;V&gt; F = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    for (V f : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (f == v2 || f == v3 || f == v5 || g.containsEdge(f, v2)</b>
<b class="fc">&nbsp;                            || g.containsEdge(f, v3) || g.containsEdge(f, v5))</b>
<b class="fc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        F.add(f);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    List&lt;Set&lt;V&gt;&gt; componentsOfF = findAllComponents(g, F);</b>
&nbsp;
<b class="fc">&nbsp;                    Set&lt;V&gt; X1 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    for (V x1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (x1 == v2 || x1 == v3 || x1 == v5 || !g.containsEdge(x1, v2)</b>
<b class="fc">&nbsp;                            || !g.containsEdge(x1, v5) || g.containsEdge(x1, v3))</b>
<b class="fc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        X1.add(x1);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Set&lt;V&gt; X2 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    for (V x2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (x2 == v2 || x2 == v3 || x2 == v5 || g.containsEdge(x2, v2)</b>
<b class="fc">&nbsp;                            || !g.containsEdge(x2, v5) || !g.containsEdge(x2, v3))</b>
<b class="fc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        X2.add(x2);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    for (V v1 : X1) {</b>
<b class="fc">&nbsp;                        if (g.containsEdge(v1, v3))</b>
<b class="nc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        for (V v4 : X2) {</b>
<b class="fc">&nbsp;                            if (v1 == v4 || g.containsEdge(v1, v4) || g.containsEdge(v2, v4))</b>
<b class="nc">&nbsp;                                continue;</b>
<b class="fc">&nbsp;                            for (Set&lt;V&gt; FPrime : componentsOfF) {</b>
<b class="fc">&nbsp;                                if (hasANeighbour(g, FPrime, v1) &amp;&amp; hasANeighbour(g, FPrime, v4)) {</b>
<b class="fc">&nbsp;                                    if (certify) {</b>
<b class="fc">&nbsp;                                        Set&lt;V&gt; validSet = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                        validSet.addAll(FPrime);</b>
<b class="fc">&nbsp;                                        validSet.add(v1);</b>
<b class="fc">&nbsp;                                        validSet.add(v4);</b>
<b class="fc">&nbsp;                                        GraphPath&lt;V, E&gt; p = new DijkstraShortestPath&lt;&gt;(</b>
<b class="fc">&nbsp;                                                new AsSubgraph&lt;&gt;(g, validSet)).getPath(v1, v4);</b>
<b class="fc">&nbsp;                                        List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;                                        edgeList.addAll(p.getEdgeList());</b>
<b class="fc">&nbsp;                                        if (p.getLength() % 2 == 1) {</b>
<b class="fc">&nbsp;                                            edgeList.add(g.getEdge(v4, v5));</b>
<b class="fc">&nbsp;                                            edgeList.add(g.getEdge(v5, v1));</b>
&nbsp;
&nbsp;                                        } else {
<b class="fc">&nbsp;                                            edgeList.add(g.getEdge(v4, v3));</b>
<b class="fc">&nbsp;                                            edgeList.add(g.getEdge(v3, v2));</b>
<b class="fc">&nbsp;                                            edgeList.add(g.getEdge(v2, v1));</b>
&nbsp;
&nbsp;                                        }
&nbsp;
<b class="fc">&nbsp;                                        double weight = edgeList</b>
<b class="fc">&nbsp;                                            .stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="fc">&nbsp;                                        certificate =</b>
&nbsp;                                                new GraphWalk&lt;&gt;(g, v1, v1, edgeList, weight);
&nbsp;                                    }
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a graph contains a clean shortest odd hole. Running time: O(|V(g)|^4)
&nbsp;     * 
&nbsp;     * @param g Graph containing no pyramid or jewel
&nbsp;     * @return Decides whether g contains a clean shortest odd hole
&nbsp;     */
&nbsp;    boolean containsCleanShortestOddHole(Graph&lt;V, E&gt; g)
&nbsp;    {
&nbsp;        /*
&nbsp;         * Find 3 Paths which are an uneven odd hole when conjunct
&nbsp;         */
<b class="fc">&nbsp;        for (V u : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V v : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (u == v || g.containsEdge(u, v))</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                GraphPath&lt;V, E&gt; puv = new DijkstraShortestPath&lt;&gt;(g).getPath(u, v);</b>
<b class="fc">&nbsp;                if (puv == null)</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                for (V w : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (w == u || w == v || g.containsEdge(w, u) || g.containsEdge(w, v))</b>
<b class="fc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    GraphPath&lt;V, E&gt; pvw = new DijkstraShortestPath&lt;&gt;(g).getPath(v, w);</b>
<b class="fc">&nbsp;                    if (pvw == null)</b>
<b class="fc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    GraphPath&lt;V, E&gt; pwu = new DijkstraShortestPath&lt;&gt;(g).getPath(w, u);</b>
<b class="fc">&nbsp;                    if (pwu == null)</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    Set&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    set.addAll(puv.getVertexList());</b>
<b class="fc">&nbsp;                    set.addAll(pvw.getVertexList());</b>
<b class="fc">&nbsp;                    set.addAll(pwu.getVertexList());</b>
<b class="fc">&nbsp;                    Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, set);</b>
&nbsp;                    // Look for holes with more than 6 edges and uneven length
<b class="fc">&nbsp;                    if (set.size() &lt; 7 || subg.vertexSet().size() != set.size()</b>
<b class="fc">&nbsp;                        || subg.edgeSet().size() != subg.vertexSet().size()</b>
<b class="fc">&nbsp;                        || subg.vertexSet().size() % 2 == 0</b>
<b class="fc">&nbsp;                        || subg.vertexSet().stream().anyMatch(t -&gt; subg.degreeOf(t) != 2))</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;
<b class="fc">&nbsp;                    if (certify) {</b>
<b class="nc">&nbsp;                        List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;                        edgeList.addAll(puv.getEdgeList());</b>
<b class="nc">&nbsp;                        edgeList.addAll(pvw.getEdgeList());</b>
<b class="nc">&nbsp;                        edgeList.addAll(pwu.getEdgeList());</b>
&nbsp;
<b class="nc">&nbsp;                        double weight =</b>
<b class="nc">&nbsp;                            edgeList.stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="nc">&nbsp;                        certificate = new GraphWalk&lt;&gt;(g, u, u, edgeList, weight);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return true;</b>
&nbsp;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a path in g from start to end avoiding the vertices in X
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param start start vertex
&nbsp;     * @param end end vertex
&nbsp;     * @param X set of vertices which should not be in the graph
&nbsp;     * @return A Path in G\X
&nbsp;     */
&nbsp;    private GraphPath&lt;V, E&gt; getPathAvoidingX(Graph&lt;V, E&gt; g, V start, V end, Set&lt;V&gt; X)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;V&gt; vertexSet = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        vertexSet.addAll(g.vertexSet());</b>
<b class="fc">&nbsp;        vertexSet.removeAll(X);</b>
<b class="fc">&nbsp;        vertexSet.add(start);</b>
<b class="fc">&nbsp;        vertexSet.add(end);</b>
<b class="fc">&nbsp;        Graph&lt;V, E&gt; subg = new AsSubgraph&lt;&gt;(g, vertexSet, null);</b>
<b class="fc">&nbsp;        return new DijkstraShortestPath&lt;&gt;(subg).getPath(start, end);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether the vertex set of a graph without a vertex set X contains a shortest odd hole.
&nbsp;     * Running time: O(|V(g)|^4)
&nbsp;     * 
&nbsp;     * @param g Graph containing neither pyramid nor jewel
&nbsp;     * @param X Subset of V(g) and a possible Cleaner for an odd hole
&nbsp;     * @return Determines whether g has an odd hole such that X is a near-cleaner for it
&nbsp;     */
&nbsp;    private boolean containsShortestOddHole(Graph&lt;V, E&gt; g, Set&lt;V&gt; X)
&nbsp;    {
<b class="fc">&nbsp;        for (V y1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            if (X.contains(y1))</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;
<b class="fc">&nbsp;            for (V x1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (x1 == y1)</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                GraphPath&lt;V, E&gt; rx1y1 = getPathAvoidingX(g, x1, y1, X);</b>
<b class="fc">&nbsp;                for (V x3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (x3 == x1 || x3 == y1 || !g.containsEdge(x1, x3))</b>
<b class="fc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    for (V x2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (x2 == x3 || x2 == x1 || x2 == y1 || g.containsEdge(x2, x1)</b>
<b class="fc">&nbsp;                            || !g.containsEdge(x3, x2))</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;
<b class="fc">&nbsp;                        GraphPath&lt;V, E&gt; rx2y1 = getPathAvoidingX(g, x2, y1, X);</b>
&nbsp;
&nbsp;                        double n;
<b class="fc">&nbsp;                        if (rx1y1 == null || rx2y1 == null)</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;
<b class="fc">&nbsp;                        V y2 = null;</b>
<b class="fc">&nbsp;                        for (V y2Candidate : rx2y1.getVertexList()) {</b>
<b class="fc">&nbsp;                            if (g.containsEdge(y1, y2Candidate) &amp;&amp; y2Candidate != x1</b>
&nbsp;                                &amp;&amp; y2Candidate != x2 &amp;&amp; y2Candidate != x3 &amp;&amp; y2Candidate != y1)
&nbsp;                            {
<b class="fc">&nbsp;                                y2 = y2Candidate;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        if (y2 == null)</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;
<b class="fc">&nbsp;                        GraphPath&lt;V, E&gt; rx3y1 = getPathAvoidingX(g, x3, y1, X);</b>
<b class="fc">&nbsp;                        GraphPath&lt;V, E&gt; rx3y2 = getPathAvoidingX(g, x3, y2, X);</b>
<b class="fc">&nbsp;                        GraphPath&lt;V, E&gt; rx1y2 = getPathAvoidingX(g, x1, y2, X);</b>
<b class="fc">&nbsp;                        if (rx3y1 != null &amp;&amp; rx3y2 != null &amp;&amp; rx1y2 != null</b>
<b class="fc">&nbsp;                            &amp;&amp; rx2y1.getLength() == (n = rx1y1.getLength() + 1)</b>
<b class="fc">&nbsp;                            &amp;&amp; n == rx1y2.getLength() &amp;&amp; rx3y1.getLength() &gt;= n</b>
<b class="fc">&nbsp;                            &amp;&amp; rx3y2.getLength() &gt;= n)</b>
&nbsp;                        {
<b class="nc">&nbsp;                            if (certify) {</b>
<b class="nc">&nbsp;                                List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;                                edgeList.addAll(rx1y1.getEdgeList());</b>
<b class="nc">&nbsp;                                for (int i = rx2y1.getLength() - 1; i &gt;= 0; i--)</b>
<b class="nc">&nbsp;                                    edgeList.add(rx2y1.getEdgeList().get(i));</b>
<b class="nc">&nbsp;                                edgeList.add(g.getEdge(x2, x3));</b>
<b class="nc">&nbsp;                                edgeList.add(g.getEdge(x3, x1));</b>
&nbsp;
<b class="nc">&nbsp;                                double weight =</b>
<b class="nc">&nbsp;                                    edgeList.stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="nc">&nbsp;                                certificate = new GraphWalk&lt;&gt;(g, x1, x1, edgeList, weight);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a clean shortest odd hole is in g or whether X is a cleaner for an amenable
&nbsp;     * shortest odd hole
&nbsp;     * 
&nbsp;     * @param g A graph, containing no pyramid or jewel
&nbsp;     * @param X A subset X of V(g) and a possible Cleaner for an odd hole
&nbsp;     * @return Returns whether g has an odd hole or there is no shortest odd hole in C such that X
&nbsp;     *         is a near-cleaner for C.
&nbsp;     */
&nbsp;    private boolean routine1(Graph&lt;V, E&gt; g, Set&lt;V&gt; X)
&nbsp;    {
<b class="fc">&nbsp;        return containsCleanShortestOddHole(g) || containsShortestOddHole(g, X);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a graph has a configuration of type T1. A configuration of type T1 in g is a
&nbsp;     * hole of length 5
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @return whether g contains a configuration of Type T1 (5-cycle)
&nbsp;     */
&nbsp;    private boolean hasConfigurationType1(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        for (V v1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            Set&lt;V&gt; temp = new ConnectivityInspector&lt;&gt;(g).connectedSetOf(v1);</b>
<b class="fc">&nbsp;            for (V v2 : temp) {</b>
<b class="fc">&nbsp;                if (v1 == v2 || !g.containsEdge(v1, v2))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                for (V v3 : temp) {</b>
<b class="fc">&nbsp;                    if (v3 == v1 || v3 == v2 || !g.containsEdge(v2, v3) || g.containsEdge(v1, v3))</b>
<b class="fc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    for (V v4 : temp) {</b>
<b class="fc">&nbsp;                        if (v4 == v1 || v4 == v2 || v4 == v3 || g.containsEdge(v1, v4)</b>
<b class="fc">&nbsp;                            || g.containsEdge(v2, v4) || !g.containsEdge(v3, v4))</b>
<b class="fc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        for (V v5 : temp) {</b>
<b class="fc">&nbsp;                            if (v5 == v1 || v5 == v2 || v5 == v3 || v5 == v4</b>
<b class="fc">&nbsp;                                || g.containsEdge(v2, v5) || g.containsEdge(v3, v5)</b>
<b class="fc">&nbsp;                                || !g.containsEdge(v1, v5) || !g.containsEdge(v4, v5))</b>
<b class="fc">&nbsp;                                continue;</b>
<b class="fc">&nbsp;                            if (certify) {</b>
<b class="fc">&nbsp;                                List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;                                edgeList.add(g.getEdge(v1, v2));</b>
<b class="fc">&nbsp;                                edgeList.add(g.getEdge(v2, v3));</b>
<b class="fc">&nbsp;                                edgeList.add(g.getEdge(v3, v4));</b>
<b class="fc">&nbsp;                                edgeList.add(g.getEdge(v4, v5));</b>
<b class="fc">&nbsp;                                edgeList.add(g.getEdge(v5, v1));</b>
&nbsp;
<b class="fc">&nbsp;                                double weight =</b>
<b class="fc">&nbsp;                                    edgeList.stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="fc">&nbsp;                                certificate = new GraphWalk&lt;&gt;(g, v1, v1, edgeList, weight);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A vertex y is X-complete if y contained in V(g)\X is adjacent to every vertex in X.
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param y Vertex whose X-completeness is to assess
&nbsp;     * @param X Set of vertices
&nbsp;     * @return whether y is X-complete
&nbsp;     */
&nbsp;    boolean isYXComplete(Graph&lt;V, E&gt; g, V y, Set&lt;V&gt; X)
&nbsp;    {
<b class="fc">&nbsp;        return X.stream().allMatch(t -&gt; g.containsEdge(t, y));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all anticomponents of a graph and a vertex set.
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param Y A set of vertices
&nbsp;     * @return List of anticomponents of Y in g
&nbsp;     */
&nbsp;    private List&lt;Set&lt;V&gt;&gt; findAllAnticomponentsOfY(Graph&lt;V, E&gt; g, Set&lt;V&gt; Y)
&nbsp;    {
&nbsp;        Graph&lt;V, E&gt; target;
<b class="fc">&nbsp;        if (g.getType().isSimple())</b>
<b class="fc">&nbsp;            target = new SimpleGraph&lt;&gt;(</b>
<b class="fc">&nbsp;                g.getVertexSupplier(), g.getEdgeSupplier(), g.getType().isWeighted());</b>
&nbsp;        else
<b class="nc">&nbsp;            target = new Multigraph&lt;&gt;(</b>
<b class="nc">&nbsp;                g.getVertexSupplier(), g.getEdgeSupplier(), g.getType().isWeighted());</b>
<b class="fc">&nbsp;        new ComplementGraphGenerator&lt;&gt;(g).generateGraph(target);</b>
&nbsp;
<b class="fc">&nbsp;        return findAllComponents(target, Y);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Checks whether a graph is of configuration type T2. A configuration of type T2 in g is a
&nbsp;     * sequence v1,v2,v3,v4,P,X such that:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;v1-v2-v3-v4 is a path of g&lt;/li&gt;
&nbsp;     * &lt;li&gt;X is an anticomponent of the set of all {v1,v2,v4}-complete vertices&lt;/li&gt;
&nbsp;     * &lt;li&gt;P is a path in G\(X+{v2,v3}) between v1,v4, and no vertex in P*, i.e. P&#39;s interior, is
&nbsp;     * X-complete or adjacent to v2 or adjacent to v3&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * An example is the complement graph of a cycle-7-graph
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @return whether g contains a configuration of Type T2
&nbsp;     */
&nbsp;    boolean hasConfigurationType2(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        for (V v1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V v2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (v1 == v2 || !g.containsEdge(v1, v2))</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                for (V v3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (v3 == v2 || v1 == v3 || g.containsEdge(v1, v3) || !g.containsEdge(v2, v3))</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;
<b class="fc">&nbsp;                    for (V v4 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (v4 == v1 || v4 == v2 || v4 == v3 || g.containsEdge(v4, v2)</b>
<b class="fc">&nbsp;                            || g.containsEdge(v4, v1) || !g.containsEdge(v3, v4))</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;
<b class="fc">&nbsp;                        Set&lt;V&gt; temp = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                        temp.add(v1);</b>
<b class="fc">&nbsp;                        temp.add(v2);</b>
<b class="fc">&nbsp;                        temp.add(v4);</b>
<b class="fc">&nbsp;                        Set&lt;V&gt; Y = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                        for (V y : g.vertexSet()) {</b>
<b class="fc">&nbsp;                            if (isYXComplete(g, y, temp)) {</b>
<b class="fc">&nbsp;                                Y.add(y);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        List&lt;Set&lt;V&gt;&gt; anticomponentsOfY = findAllAnticomponentsOfY(g, Y);</b>
<b class="fc">&nbsp;                        for (Set&lt;V&gt; X : anticomponentsOfY) {</b>
<b class="fc">&nbsp;                            Set&lt;V&gt; v2v3 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                            v2v3.addAll(g.vertexSet());</b>
<b class="fc">&nbsp;                            v2v3.remove(v2);</b>
<b class="fc">&nbsp;                            v2v3.remove(v3);</b>
<b class="fc">&nbsp;                            v2v3.removeAll(X);</b>
<b class="fc">&nbsp;                            if (!v2v3.contains(v1) || !v2v3.contains(v4))</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;
<b class="fc">&nbsp;                            GraphPath&lt;V, E&gt; Path =</b>
&nbsp;                                    new DijkstraShortestPath&lt;&gt;(new AsSubgraph&lt;&gt;(g, v2v3))
<b class="fc">&nbsp;                                    .getPath(v1, v4);</b>
<b class="fc">&nbsp;                            if (Path == null)</b>
<b class="fc">&nbsp;                                continue;</b>
<b class="fc">&nbsp;                            List&lt;V&gt; P = Path.getVertexList();</b>
<b class="fc">&nbsp;                            if (!P.contains(v1) || !P.contains(v4))</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;
<b class="fc">&nbsp;                            boolean cont = true;</b>
<b class="fc">&nbsp;                            for (V p : P) {</b>
<b class="fc">&nbsp;                                if (p != v1 &amp;&amp; p != v4 &amp;&amp; (g.containsEdge(p, v2)</b>
<b class="fc">&nbsp;                                    || g.containsEdge(p, v3) || isYXComplete(g, p, X)))</b>
&nbsp;                                {
<b class="fc">&nbsp;                                    cont = false;</b>
<b class="fc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            if (cont) {</b>
<b class="fc">&nbsp;                                if (certify) {</b>
<b class="nc">&nbsp;                                    List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;                                    if (Path.getLength() % 2 == 0) {</b>
<b class="nc">&nbsp;                                        edgeList.add(g.getEdge(v1, v2));</b>
<b class="nc">&nbsp;                                        edgeList.add(g.getEdge(v2, v3));</b>
<b class="nc">&nbsp;                                        edgeList.add(g.getEdge(v3, v4));</b>
<b class="nc">&nbsp;                                        edgeList.addAll(Path.getEdgeList());</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        edgeList.addAll(Path.getEdgeList());</b>
<b class="nc">&nbsp;                                        V x = X.iterator().next();</b>
<b class="nc">&nbsp;                                        edgeList.add(g.getEdge(v4, x));</b>
<b class="nc">&nbsp;                                        edgeList.add(g.getEdge(x, v1));</b>
&nbsp;                                    }
&nbsp;
<b class="nc">&nbsp;                                    double weight = edgeList</b>
<b class="nc">&nbsp;                                        .stream().mapToDouble(g::getEdgeWeight).sum();</b>
<b class="nc">&nbsp;                                    certificate = new GraphWalk&lt;&gt;(g, v1, v1, edgeList, weight);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return true;</b>
&nbsp;
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reports whether v has at least one neighbour in set
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param set A set of vertices
&nbsp;     * @param v A vertex
&nbsp;     * @return whether v has at least one neighbour in set
&nbsp;     */
&nbsp;    private boolean hasANeighbour(Graph&lt;V, E&gt; g, Set&lt;V&gt; set, V v)
&nbsp;    {
<b class="fc">&nbsp;        return set.stream().anyMatch(s -&gt; g.containsEdge(s, v));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For each anticomponent X, find the maximal connected subset F&#39; containing v5 with the
&nbsp;     * properties that v1,v2 have no neighbours in F&#39; and no vertex of F&#39;\v5 is X-complete
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param X A set of vertices
&nbsp;     * @param v1 A vertex
&nbsp;     * @param v2 A vertex
&nbsp;     * @param v5 A Vertex
&nbsp;     * @return The maximal connected vertex subset containing v5, no neighbours of v1 and v2, and no
&nbsp;     *         X-complete vertex except v5
&nbsp;     */
&nbsp;    private Set&lt;V&gt; findMaximalConnectedSubset(Graph&lt;V, E&gt; g, Set&lt;V&gt; X, V v1, V v2, V v5)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;V&gt; FPrime = new ConnectivityInspector&lt;&gt;(g).connectedSetOf(v5);</b>
<b class="fc">&nbsp;        FPrime.removeIf(</b>
<b class="fc">&nbsp;            t -&gt; t != v5 &amp;&amp; isYXComplete(g, t, X) || v1 == t || v2 == t || g.containsEdge(v1, t)</b>
<b class="fc">&nbsp;                || g.containsEdge(v2, t));</b>
<b class="fc">&nbsp;        return FPrime;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reports whether a vertex has at least one nonneighbour in X
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param v A Vertex
&nbsp;     * @param X A set of vertices
&nbsp;     * @return whether v has a nonneighbour in X
&nbsp;     */
&nbsp;    private boolean hasANonneighbourInX(Graph&lt;V, E&gt; g, V v, Set&lt;V&gt; X)
&nbsp;    {
<b class="fc">&nbsp;        return X.stream().anyMatch(x -&gt; !g.containsEdge(v, x));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Checks whether a graph is of configuration type T3. A configuration of type T3 in g is a
&nbsp;     * sequence v1,...,v6,P,X such that
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;v1,...,v6 are distinct vertices of g&lt;/li&gt;
&nbsp;     * &lt;li&gt;v1v2,v3v4,v2v3,v3v5,v4v6 are edges, and v1v3,v2v4,v1v5,v2v5,v1v6,v2v6,v4v5 are
&nbsp;     * non-edges&lt;/li&gt;
&nbsp;     * &lt;li&gt;X is an anticomponent of the set of all {v1,v2,v5}-complete vertices, and v3,v4 are not
&nbsp;     * X-complete&lt;/li&gt;
&nbsp;     * &lt;li&gt;P is a path of g\(X+{v1,v2,v3,v4}) between v5,v6, and no vertex in P* is X-complete or
&nbsp;     * adjacent to v1 or adjacent to v2&lt;/li&gt;
&nbsp;     * &lt;li&gt;if v5v6 is an edge then v6 is not X-complete&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @return whether g contains a configuration of Type T3
&nbsp;     */
&nbsp;    boolean hasConfigurationType3(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        for (V v1 : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V v2 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (v1 == v2 || !g.containsEdge(v1, v2))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                for (V v5 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (v1 == v5 || v2 == v5 || g.containsEdge(v1, v5) || g.containsEdge(v2, v5))</b>
<b class="fc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    Set&lt;V&gt; triple = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    triple.add(v1);</b>
<b class="fc">&nbsp;                    triple.add(v2);</b>
<b class="fc">&nbsp;                    triple.add(v5);</b>
<b class="fc">&nbsp;                    Set&lt;V&gt; Y = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    for (V y : g.vertexSet()) {</b>
<b class="fc">&nbsp;                        if (isYXComplete(g, y, triple)) {</b>
<b class="fc">&nbsp;                            Y.add(y);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    List&lt;Set&lt;V&gt;&gt; anticomponents = findAllAnticomponentsOfY(g, Y);</b>
<b class="fc">&nbsp;                    for (Set&lt;V&gt; X : anticomponents) {</b>
<b class="fc">&nbsp;                        Set&lt;V&gt; FPrime = findMaximalConnectedSubset(g, X, v1, v2, v5);</b>
<b class="fc">&nbsp;                        Set&lt;V&gt; F = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                        F.addAll(FPrime);</b>
<b class="fc">&nbsp;                        for (V x : X) {</b>
<b class="fc">&nbsp;                            if (!g.containsEdge(x, v1) &amp;&amp; !g.containsEdge(x, v2)</b>
<b class="nc">&nbsp;                                &amp;&amp; !g.containsEdge(x, v5) &amp;&amp; hasANeighbour(g, FPrime, x))</b>
<b class="nc">&nbsp;                                F.add(x);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
<b class="fc">&nbsp;                        for (V v4 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                            if (v4 == v1 || v4 == v2 || v4 == v5 || g.containsEdge(v2, v4)</b>
<b class="fc">&nbsp;                                || g.containsEdge(v5, v4) || !g.containsEdge(v1, v4)</b>
<b class="fc">&nbsp;                                || !hasANeighbour(g, F, v4) || !hasANonneighbourInX(g, v4, X)</b>
<b class="fc">&nbsp;                                || isYXComplete(g, v4, X))</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;
<b class="fc">&nbsp;                            for (V v3 : g.vertexSet()) {</b>
<b class="fc">&nbsp;                                if (v3 == v1 || v3 == v2 || v3 == v4 || v3 == v5</b>
<b class="fc">&nbsp;                                    || !g.containsEdge(v2, v3) || !g.containsEdge(v3, v4)</b>
<b class="fc">&nbsp;                                    || !g.containsEdge(v5, v3) || g.containsEdge(v1, v3)</b>
<b class="fc">&nbsp;                                    || !hasANonneighbourInX(g, v3, X) || isYXComplete(g, v3, X))</b>
<b class="nc">&nbsp;                                    continue;</b>
<b class="fc">&nbsp;                                for (V v6 : F) {</b>
<b class="fc">&nbsp;                                    if (v6 == v1 || v6 == v2 || v6 == v3 || v6 == v4 || v6 == v5</b>
<b class="fc">&nbsp;                                        || !g.containsEdge(v4, v6) || g.containsEdge(v1, v6)</b>
<b class="fc">&nbsp;                                        || g.containsEdge(v2, v6)</b>
<b class="fc">&nbsp;                                        || g.containsEdge(v5, v6) &amp;&amp; !isYXComplete(g, v6, X))</b>
<b class="nc">&nbsp;                                        continue;</b>
<b class="fc">&nbsp;                                    Set&lt;V&gt; verticesForPv5v6 = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.addAll(FPrime);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.add(v5);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.add(v6);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.remove(v1);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.remove(v2);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.remove(v3);</b>
<b class="fc">&nbsp;                                    verticesForPv5v6.remove(v4);</b>
&nbsp;
<b class="fc">&nbsp;                                    if (new ConnectivityInspector&lt;&gt;(</b>
&nbsp;                                            new AsSubgraph&lt;&gt;(g, verticesForPv5v6))
<b class="fc">&nbsp;                                            .pathExists(v6, v5))</b>
&nbsp;                                    {
<b class="fc">&nbsp;                                        if (certify) {</b>
<b class="nc">&nbsp;                                            List&lt;E&gt; edgeList = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;                                            edgeList.add(g.getEdge(v1, v4));</b>
<b class="nc">&nbsp;                                            edgeList.add(g.getEdge(v4, v6));</b>
<b class="nc">&nbsp;                                            GraphPath&lt;V, E&gt; P =</b>
<b class="nc">&nbsp;                                                    new DijkstraShortestPath&lt;&gt;(g).getPath(v6, v5);</b>
<b class="nc">&nbsp;                                            edgeList.addAll(P.getEdgeList());</b>
<b class="nc">&nbsp;                                            if (P.getLength() % 2 == 1) {</b>
<b class="nc">&nbsp;                                                V x = X.iterator().next();</b>
<b class="nc">&nbsp;                                                edgeList.add(g.getEdge(v5, x));</b>
<b class="nc">&nbsp;                                                edgeList.add(g.getEdge(x, v1));</b>
<b class="nc">&nbsp;                                            } else {</b>
<b class="nc">&nbsp;                                                edgeList.add(g.getEdge(v5, v3));</b>
<b class="nc">&nbsp;                                                edgeList.add(g.getEdge(v3, v4));</b>
<b class="nc">&nbsp;                                                edgeList.add(g.getEdge(v4, v1));</b>
&nbsp;                                            }
&nbsp;
<b class="nc">&nbsp;                                            double weight = edgeList</b>
<b class="nc">&nbsp;                                                .stream().mapToDouble(g::getEdgeWeight)</b>
<b class="nc">&nbsp;                                                .sum();</b>
<b class="nc">&nbsp;                                            certificate =</b>
&nbsp;                                                    new GraphWalk&lt;&gt;(g, v1, v1, edgeList, weight);
&nbsp;                                        }
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
<b class="nc">&nbsp;                                }</b>
&nbsp;
<b class="nc">&nbsp;                            }</b>
&nbsp;
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, the graph is not Berge. Checks whether g contains a Pyramid, Jewel, configuration
&nbsp;     * type 1, 2 or 3.
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @return whether g contains a pyramid, a jewel, a T1, a T2, or a T3
&nbsp;     */
&nbsp;    private boolean routine2(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        return containsPyramid(g) || containsJewel(g) || hasConfigurationType1(g)</b>
<b class="fc">&nbsp;            || hasConfigurationType2(g) || hasConfigurationType3(g);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * N(a,b) is the set of all {a,b}-complete vertices
&nbsp;     * 
&nbsp;     * @param g A Graph
&nbsp;     * @param a A Vertex
&nbsp;     * @param b A Vertex
&nbsp;     * @return The set of all {a,b}-complete vertices
&nbsp;     */
&nbsp;    private Set&lt;V&gt; N(Graph&lt;V, E&gt; g, V a, V b)
&nbsp;    {
<b class="fc">&nbsp;        return g</b>
<b class="fc">&nbsp;            .vertexSet().stream().filter(t -&gt; g.containsEdge(t, a) &amp;&amp; g.containsEdge(t, b))</b>
<b class="fc">&nbsp;            .collect(Collectors.toSet());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * r(a,b,c) is the cardinality of the largest anticomponent of N(a,b) that contains a
&nbsp;     * nonneighbour of c (or 0, if c is N(a,b)-complete)
&nbsp;     * 
&nbsp;     * @param g a Graph
&nbsp;     * @param Nab The set of all {a,b}-complete vertices
&nbsp;     * @param c A vertex
&nbsp;     * @return The cardinality of the largest anticomponent of N(a,b) that contains a nonneighbour
&nbsp;     *         of c (or 0, if c is N(a,b)-complete)
&nbsp;     */
&nbsp;    private int r(Graph&lt;V, E&gt; g, Set&lt;V&gt; Nab, V c)
&nbsp;    {
<b class="fc">&nbsp;        if (isYXComplete(g, c, Nab))</b>
<b class="fc">&nbsp;            return 0;</b>
<b class="fc">&nbsp;        List&lt;Set&lt;V&gt;&gt; anticomponents = findAllAnticomponentsOfY(g, Nab);</b>
<b class="fc">&nbsp;        return anticomponents.stream().mapToInt(Set::size).max().getAsInt();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Y(a,b,c) is the union of all anticomponents of N(a,b) that have cardinality strictly greater
&nbsp;     * than r(a,b,c)
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param Nab The set of all {a,b}-complete vertices
&nbsp;     * @param c A vertex
&nbsp;     * @return A Set of vertices with cardinality greater r(a,b,c)
&nbsp;     */
&nbsp;    private Set&lt;V&gt; Y(Graph&lt;V, E&gt; g, Set&lt;V&gt; Nab, V c)
&nbsp;    {
<b class="fc">&nbsp;        int cutoff = r(g, Nab, c);</b>
<b class="fc">&nbsp;        List&lt;Set&lt;V&gt;&gt; anticomponents = findAllAnticomponentsOfY(g, Nab);</b>
<b class="fc">&nbsp;        Set&lt;V&gt; res = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (Set&lt;V&gt; anticomponent : anticomponents) {</b>
<b class="fc">&nbsp;            if (anticomponent.size() &gt; cutoff) {</b>
<b class="fc">&nbsp;                res.addAll(anticomponent);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * W(a,b,c) is the anticomponent of N(a,b)+{c} that contains c
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param Nab The set of all {a,b}-complete vertices
&nbsp;     * @param c A vertex
&nbsp;     * @return The anticomponent of N(a,b)+{c} containing c
&nbsp;     */
&nbsp;    private Set&lt;V&gt; W(Graph&lt;V, E&gt; g, Set&lt;V&gt; Nab, V c)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;V&gt; temp = new HashSet&lt;V&gt;();</b>
<b class="fc">&nbsp;        temp.addAll(Nab);</b>
<b class="fc">&nbsp;        temp.add(c);</b>
<b class="fc">&nbsp;        List&lt;Set&lt;V&gt;&gt; anticomponents = findAllAnticomponentsOfY(g, temp);</b>
<b class="fc">&nbsp;        for (Set&lt;V&gt; anticomponent : anticomponents)</b>
<b class="fc">&nbsp;            if (anticomponent.contains(c))</b>
<b class="fc">&nbsp;                return anticomponent;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Z(a,b,c) is the set of all (Y(a,b,c)+W(a,b,c))-complete vertices
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param Nab The set of all {a,b}-complete vertices
&nbsp;     * @param c A vertex
&nbsp;     * @return A set of vertices
&nbsp;     */
&nbsp;    private Set&lt;V&gt; Z(Graph&lt;V, E&gt; g, Set&lt;V&gt; Nab, V c)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;V&gt; temp = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        temp.addAll(Y(g, Nab, c));</b>
<b class="fc">&nbsp;        temp.addAll(W(g, Nab, c));</b>
<b class="fc">&nbsp;        Set&lt;V&gt; res = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (V it : g.vertexSet()) {</b>
<b class="fc">&nbsp;            if (isYXComplete(g, it, temp))</b>
<b class="fc">&nbsp;                res.add(it);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * X(a,b,c)=Y(a,b,c)+Z(a,b,c)
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param Nab The set of all {a,b}-complete vertices
&nbsp;     * @param c A vertex
&nbsp;     * @return The union of Y(a,b,c) and Z(a,b,c)
&nbsp;     */
&nbsp;    private Set&lt;V&gt; X(Graph&lt;V, E&gt; g, Set&lt;V&gt; Nab, V c)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;V&gt; res = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        res.addAll(Y(g, Nab, c));</b>
<b class="fc">&nbsp;        res.addAll(Z(g, Nab, c));</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A triple (a,b,c) of vertices is relevant if a,b are distinct and nonadjacent, and c is not
&nbsp;     * contained in N(a,b) (possibly c is contained in {a,b}).
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param a A vertex
&nbsp;     * @param b A vertex
&nbsp;     * @param c A vertex
&nbsp;     * @return Assessement whether a,b,c is a relevant triple
&nbsp;     */
&nbsp;    private boolean isTripleRelevant(Graph&lt;V, E&gt; g, V a, V b, V c)
&nbsp;    {
<b class="fc">&nbsp;        return a != b &amp;&amp; !g.containsEdge(a, b) &amp;&amp; !N(g, a, b).contains(c);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set of vertex sets that may be near-cleaners for an amenable hole in g.
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @return possible near-cleaners
&nbsp;     */
&nbsp;    Set&lt;Set&lt;V&gt;&gt; routine3(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;Set&lt;V&gt;&gt; NuvList = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (V u : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V v : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (u == v || !g.containsEdge(u, v))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                NuvList.add(N(g, u, v));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;Set&lt;V&gt;&gt; tripleList = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (V a : g.vertexSet()) {</b>
<b class="fc">&nbsp;            for (V b : g.vertexSet()) {</b>
<b class="fc">&nbsp;                if (a == b || g.containsEdge(a, b))</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                Set&lt;V&gt; Nab = N(g, a, b);</b>
<b class="fc">&nbsp;                for (V c : g.vertexSet()) {</b>
<b class="fc">&nbsp;                    if (isTripleRelevant(g, a, b, c)) {</b>
<b class="fc">&nbsp;                        tripleList.add(X(g, Nab, c));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        Set&lt;Set&lt;V&gt;&gt; res = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (Set&lt;V&gt; Nuv : NuvList) {</b>
<b class="fc">&nbsp;            for (Set&lt;V&gt; triple : tripleList) {</b>
<b class="fc">&nbsp;                Set&lt;V&gt; temp = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                temp.addAll(Nuv);</b>
<b class="fc">&nbsp;                temp.addAll(triple);</b>
<b class="fc">&nbsp;                res.add(temp);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the Berge Recognition Algorithm.
&nbsp;     * &lt;p&gt;
&nbsp;     * First this algorithm is used to test whether $G$ or its complement contain a jewel, a pyramid
&nbsp;     * or a configuration of type 1, 2 or 3. If so, it is output that $G$ is not Berge. If not, then
&nbsp;     * every shortest odd hole in $G$ is amenable. This asserted, the near-cleaner subsets of $V(G)$
&nbsp;     * are determined. For each of them in turn it is checked, if this subset is a near-cleaner and,
&nbsp;     * thus, if there is an odd hole. If an odd hole is found, this checker will output that $G$ is
&nbsp;     * not Berge. If no odd hole is found, all near-cleaners for the complement graph are determined
&nbsp;     * and it will be proceeded as before. If again no odd hole is detected, $G$ is Berge.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * A certificate can be obtained through the {@link BergeGraphInspector#getCertificate} method,
&nbsp;     * if &lt;code&gt;computeCertificate&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * Running this method takes $O(|V|^9)$, and computing the certificate takes $O(|V|^5)$.
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @param computeCertificate toggles certificate computation
&nbsp;     * @return whether g is Berge and, thus, perfect
&nbsp;     */
&nbsp;    public boolean isBerge(Graph&lt;V, E&gt; g, boolean computeCertificate)
&nbsp;    {
<b class="fc">&nbsp;        GraphTests.requireDirectedOrUndirected(g);</b>
&nbsp;        Graph&lt;V, E&gt; complementGraph;
<b class="fc">&nbsp;        if (g.getType().isSimple())</b>
<b class="fc">&nbsp;            complementGraph = new SimpleGraph&lt;&gt;(</b>
<b class="fc">&nbsp;                    g.getVertexSupplier(), g.getEdgeSupplier(), g.getType().isWeighted());</b>
&nbsp;        else
<b class="nc">&nbsp;            complementGraph = new Multigraph&lt;&gt;(</b>
<b class="nc">&nbsp;                    g.getVertexSupplier(), g.getEdgeSupplier(), g.getType().isWeighted());</b>
<b class="fc">&nbsp;        new ComplementGraphGenerator&lt;&gt;(g).generateGraph(complementGraph);</b>
&nbsp;
<b class="fc">&nbsp;        certify = computeCertificate;</b>
<b class="fc">&nbsp;        if (routine2(g) || routine2(complementGraph)) {</b>
<b class="fc">&nbsp;            certify = false;</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (Set&lt;V&gt; it : routine3(g)) {</b>
<b class="fc">&nbsp;            if (routine1(g, it)) {</b>
<b class="nc">&nbsp;                certify = false;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for (Set&lt;V&gt; it : routine3(complementGraph)) {</b>
<b class="fc">&nbsp;            if (routine1(complementGraph, it)) {</b>
<b class="nc">&nbsp;                certify = false;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        certify = false;</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the Berge Recognition Algorithm.
&nbsp;     * &lt;p&gt;
&nbsp;     * First this algorithm is used to test whether $G$ or its complement contain a jewel, a pyramid
&nbsp;     * or a configuration of type 1, 2 or 3. If so, it is output that $G$ is not Berge. If not, then
&nbsp;     * every shortest odd hole in $G$ is amenable. This asserted, the near-cleaner subsets of $V(G)$
&nbsp;     * are determined. For each of them in turn it is checked, if this subset is a near-cleaner and,
&nbsp;     * thus, if there is an odd hole. If an odd hole is found, this checker will output that $G$ is
&nbsp;     * not Berge. If no odd hole is found, all near-cleaners for the complement graph are determined
&nbsp;     * and it will be proceeded as before. If again no odd hole is detected, $G$ is Berge.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * This method by default does not compute a certificate. For obtaining a certificate, call
&nbsp;     * {@link BergeGraphInspector#isBerge} with &lt;code&gt;computeCertificate=true&lt;/code&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * Running this method takes $O(|V|^9)$.
&nbsp;     * 
&nbsp;     * @param g A graph
&nbsp;     * @return whether g is Berge and, thus, perfect
&nbsp;     */
&nbsp;    public boolean isBerge(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="nc">&nbsp;        return this.isBerge(g, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the certificate in the form of a hole or anti-hole in the inspected graph, when the
&nbsp;     * {@link BergeGraphInspector#isBerge} method is previously called with
&nbsp;     * &lt;code&gt;computeCertificate=true&lt;/code&gt;. Returns null if the inspected graph is perfect.
&nbsp;     *
&nbsp;     * @return a &lt;a href=&quot;http://graphclasses.org/smallgraphs.html#holes&quot;&gt;hole&lt;/a&gt; or
&nbsp;     *         &lt;a href=&quot;http://graphclasses.org/smallgraphs.html#antiholes&quot;&gt;anti-hole&lt;/a&gt; in the
&nbsp;     *         inspected graph, null if the graph is perfect
&nbsp;     */
&nbsp;    public GraphPath&lt;V, E&gt; getCertificate()
&nbsp;    {
<b class="fc">&nbsp;        return certificate;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 10:43</div>
</div>
</body>
</html>
