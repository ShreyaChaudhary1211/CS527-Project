


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AsSynchronizedGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jgrapht.graph.concurrent</a>
</div>

<h1>Coverage Summary for Class: AsSynchronizedGraph (org.jgrapht.graph.concurrent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AsSynchronizedGraph</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/161)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AsSynchronizedGraph$1</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$CacheAccess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$CacheStrategy</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$CopyOnDemandSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$NoCache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AsSynchronizedGraph$NoCopy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/327)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (C) Copyright 2018-2018, by CHEN Kui and Contributors.
&nbsp; *
&nbsp; * JGraphT : a free Java graph-theory library
&nbsp; *
&nbsp; * See the CONTRIBUTORS.md file distributed with this work for additional
&nbsp; * information regarding copyright ownership.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Public License 2.0 which is available at
&nbsp; * http://www.eclipse.org/legal/epl-2.0, or the
&nbsp; * GNU Lesser General Public License v2.1 or later
&nbsp; * which is available at
&nbsp; * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
&nbsp; *
&nbsp; * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
&nbsp; */
&nbsp;package org.jgrapht.graph.concurrent;
&nbsp;
&nbsp;import org.jgrapht.*;
&nbsp;import org.jgrapht.graph.*;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.*;
&nbsp;import java.util.concurrent.locks.*;
&nbsp;import java.util.function.*;
&nbsp;import java.util.stream.*;
&nbsp;
&nbsp;/**
&nbsp; * Create a synchronized (thread-safe) Graph backed by the specified Graph. This Graph is designed
&nbsp; * to support concurrent reads which are mutually exclusive with writes. In order to guarantee
&nbsp; * serial access, it is critical that &lt;strong&gt;all&lt;/strong&gt; access to the backing Graph is
&nbsp; * accomplished through the created Graph.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Users need to manually synchronize on edge supplier (see {@link Graph#getEdgeSupplier()}) if creating an edge needs to access
&nbsp; * shared resources. Failure to follow this advice may result in non-deterministic behavior.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * For all methods returning a Set, the Graph guarantees that all operations on the returned Set do
&nbsp; * not affect the backing Graph. For &lt;code&gt;edgeSet&lt;/code&gt; and &lt;code&gt;vertexSet&lt;/code&gt; methods, the
&nbsp; * returned Set is backed by the underlying graph, but when a traversal over the set is started via
&nbsp; * a method such as iterator(), a snapshot of the underlying Set is copied for iteration purposes.
&nbsp; * For &lt;code&gt;edgesOf&lt;/code&gt;, &lt;code&gt;incomingEdgesOf&lt;/code&gt; and &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods,
&nbsp; * the returned Set is a unmodifiable copy of the result produced by the underlying Graph. Users can
&nbsp; * control whether those copies should be cached; caching may significantly increase memory
&nbsp; * requirements. If users decide to cache those copies and the backing graph&#39;s changes don&#39;t affect
&nbsp; * them, those copies will be returned the next time the method is called. If the backing graph&#39;s
&nbsp; * changes affect them, they will be removed from cache and re-created the next time the method is
&nbsp; * called. If users decide to not cache those copies, the graph will create ephemeral copies every
&nbsp; * time the method is called. For other methods returning a Set, the Set is just the backing Graph&#39;s
&nbsp; * return.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * As an alternative, a &lt;em&gt;copyless mode&lt;/em&gt; is supported. When enabled, no collection copies are
&nbsp; * made at all (and hence the cache setting is ignored). This requires the caller to explicitly
&nbsp; * synchronize iteration via the {@link #getLock} method. This approach requires quite a bit of care
&nbsp; * on the part of the calling application, so it is disabled by default.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Even though this graph implementation is thread-safe, callers should still be aware of potential
&nbsp; * hazards from removal methods. If calling code obtains a reference to a vertex or edge from the
&nbsp; * graph, and then calls another graph method to access information about that object, an
&nbsp; * {@link IllegalArgumentException} may be thrown if another thread has concurrently removed that
&nbsp; * object. Therefore, calling the remove methods concurrently with a typical algorithm is likely to
&nbsp; * cause the algorithm to fail with an {@link IllegalArgumentException}. So really the main
&nbsp; * concurrent read/write use case is add-only. &lt;br&gt;
&nbsp; * eg: If threadA tries to get all edges touching a certain vertex after threadB removes the vertex,
&nbsp; * the algorithm will be interrupted by {@link IllegalArgumentException}.
&nbsp; * &lt;/p&gt;
&nbsp; * 
&nbsp; * &lt;pre&gt;
&nbsp; * Thread threadA = new Thread(() -&amp;gt; {
&nbsp; *     Set vertices = graph.vertexSet();
&nbsp; *     for (Object v : vertices) {
&nbsp; *         // {@link IllegalArgumentException} may be thrown since other threads may have removed
&nbsp; *         // the vertex.
&nbsp; *         Set edges = graph.edgesOf(v);
&nbsp; *         doOtherThings();
&nbsp; *     }
&nbsp; * });
&nbsp; * Thread threadB = new Thread(() -&amp;gt; {
&nbsp; *     Set vertices = graph.vertexSet();
&nbsp; *     for (Object v : vertices) {
&nbsp; *         if (someConditions) {
&nbsp; *             graph.removeVertex(v);
&nbsp; *         }
&nbsp; *     }
&nbsp; * });
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * One way to avoid the hazard noted above is for the calling application to explicitly synchronize
&nbsp; * all iterations using the {@link #getLock} method.
&nbsp; *
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The created Graph&#39;s hashCode is equal to the backing set&#39;s hashCode. And the created Graph is
&nbsp; * equal to another Graph if they are the same Graph or the backing Graph is equal to the other
&nbsp; * Graph.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @param &lt;V&gt; the graph vertex type
&nbsp; * @param &lt;E&gt; the graph edge type
&nbsp; *
&nbsp; * @author CHEN Kui
&nbsp; */
<b class="nc">&nbsp;public class AsSynchronizedGraph&lt;V, E&gt;</b>
&nbsp;    extends
&nbsp;    GraphDelegator&lt;V, E&gt;
&nbsp;    implements
&nbsp;    Graph&lt;V, E&gt;,
&nbsp;    Serializable
&nbsp;{
&nbsp;    private static final long serialVersionUID = 5144561442831050752L;
&nbsp;
&nbsp;    private final ReentrantReadWriteLock readWriteLock;
&nbsp;
&nbsp;    // A set encapsulating backing vertexSet.
&nbsp;    private transient CopyOnDemandSet&lt;V&gt; allVerticesSet;
&nbsp;
&nbsp;    // A set encapsulating backing edgeSet.
&nbsp;    private transient CopyOnDemandSet&lt;E&gt; allEdgesSet;
&nbsp;
&nbsp;    private CacheStrategy&lt;V, E&gt; cacheStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for AsSynchronizedGraph with default settings (cache disabled, non-fair mode, and
&nbsp;     * copyless mode disabled).
&nbsp;     *
&nbsp;     * @param g the backing graph (the delegate)
&nbsp;     */
&nbsp;    public AsSynchronizedGraph(Graph&lt;V, E&gt; g)
&nbsp;    {
<b class="nc">&nbsp;        this(g, false, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for AsSynchronizedGraph with specified properties.
&nbsp;     *
&nbsp;     * @param g the backing graph (the delegate)
&nbsp;     * @param cacheEnable a flag describing whether a cache will be used
&nbsp;     * @param fair a flag describing whether fair mode will be used
&nbsp;     * @param copyless a flag describing whether copyless mode will be used
&nbsp;     */
&nbsp;    private AsSynchronizedGraph(Graph&lt;V, E&gt; g, boolean cacheEnable, boolean fair, boolean copyless)
&nbsp;    {
<b class="nc">&nbsp;        super(g);</b>
<b class="nc">&nbsp;        readWriteLock = new ReentrantReadWriteLock(fair);</b>
<b class="nc">&nbsp;        if (copyless) {</b>
<b class="nc">&nbsp;            cacheStrategy = new NoCopy();</b>
<b class="nc">&nbsp;        } else if (cacheEnable) {</b>
<b class="nc">&nbsp;            cacheStrategy = new CacheAccess();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            cacheStrategy = new NoCache();</b>
&nbsp;        }
<b class="nc">&nbsp;        allEdgesSet = new CopyOnDemandSet&lt;&gt;(super.edgeSet(), readWriteLock, copyless);</b>
<b class="nc">&nbsp;        allVerticesSet = new CopyOnDemandSet&lt;&gt;(super.vertexSet(), readWriteLock, copyless);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; getAllEdges(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.getAllEdges(sourceVertex, targetVertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public E getEdge(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.getEdge(sourceVertex, targetVertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public E addEdge(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            E e = cacheStrategy.addEdge(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            if (e != null)</b>
<b class="nc">&nbsp;                edgeSetModified();</b>
<b class="nc">&nbsp;            return e;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean addEdge(V sourceVertex, V targetVertex, E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (cacheStrategy.addEdge(sourceVertex, targetVertex, e)) {</b>
<b class="nc">&nbsp;                edgeSetModified();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean addVertex(V v)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (super.addVertex(v)) {</b>
<b class="nc">&nbsp;                vertexSetModified();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean containsEdge(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.containsEdge(sourceVertex, targetVertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean containsEdge(E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.containsEdge(e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean containsVertex(V v)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.containsVertex(v);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int degreeOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.degreeOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; edgeSet()
&nbsp;    {
<b class="nc">&nbsp;        return allEdgesSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; edgesOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return cacheStrategy.edgesOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int inDegreeOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.inDegreeOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; incomingEdgesOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return cacheStrategy.incomingEdgesOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int outDegreeOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.outDegreeOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; outgoingEdgesOf(V vertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return cacheStrategy.outgoingEdgesOf(vertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean removeAllEdges(Collection&lt;? extends E&gt; edges)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.removeAllEdges(edges);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;E&gt; removeAllEdges(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.removeAllEdges(sourceVertex, targetVertex);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean removeAllVertices(Collection&lt;? extends V&gt; vertices)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.removeAllVertices(vertices);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean removeEdge(E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (cacheStrategy.removeEdge(e)) {</b>
<b class="nc">&nbsp;                edgeSetModified();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public E removeEdge(V sourceVertex, V targetVertex)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            E e = cacheStrategy.removeEdge(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            if (e != null)</b>
<b class="nc">&nbsp;                edgeSetModified();</b>
<b class="nc">&nbsp;            return e;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean removeVertex(V v)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (cacheStrategy.removeVertex(v)) {</b>
<b class="nc">&nbsp;                edgeSetModified();</b>
<b class="nc">&nbsp;                vertexSetModified();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString()
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.toString();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;V&gt; vertexSet()
&nbsp;    {
<b class="nc">&nbsp;        return allVerticesSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public V getEdgeSource(E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.getEdgeSource(e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public V getEdgeTarget(E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.getEdgeTarget(e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getEdgeWeight(E e)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return super.getEdgeWeight(e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setEdgeWeight(E e, double weight)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            super.setEdgeWeight(e, weight);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return whether the graph uses cache for &lt;code&gt;edgesOf&lt;/code&gt;, &lt;code&gt;incomingEdgesOf&lt;/code&gt;
&nbsp;     * and &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;     * 
&nbsp;     * @return &lt;tt&gt;true&lt;/tt&gt; if cache is in use, &lt;tt&gt;false&lt;/tt&gt; if cache is not in use.
&nbsp;     */
&nbsp;    public boolean isCacheEnabled()
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return cacheStrategy.isCacheEnabled();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return whether copyless mode is used for collection-returning methods.
&nbsp;     * 
&nbsp;     * @return &lt;tt&gt;true&lt;/tt&gt; if the graph uses copyless mode, &lt;tt&gt;false&lt;/tt&gt; otherwise
&nbsp;     */
&nbsp;    public boolean isCopyless()
&nbsp;    {
<b class="nc">&nbsp;        return allVerticesSet.isCopyless();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the cache strategy for &lt;code&gt;edgesOf&lt;/code&gt;, &lt;code&gt;incomingEdgesOf&lt;/code&gt; and
&nbsp;     * &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;     *
&nbsp;     * @param cacheEnabled a flag whether to use cache for those methods, if &lt;tt&gt;true&lt;/tt&gt;, cache
&nbsp;     *        will be used for those methods, otherwise cache will not be used.
&nbsp;     * @return the AsSynchronizedGraph
&nbsp;     */
&nbsp;    public AsSynchronizedGraph&lt;V, E&gt; setCache(boolean cacheEnabled)
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (cacheEnabled == isCacheEnabled())</b>
<b class="nc">&nbsp;                return this;</b>
<b class="nc">&nbsp;            if (cacheEnabled)</b>
<b class="nc">&nbsp;                cacheStrategy = new CacheAccess();</b>
&nbsp;            else
<b class="nc">&nbsp;                cacheStrategy = new NoCache();</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode()
&nbsp;    {
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return getDelegate().hashCode();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object o)
&nbsp;    {
<b class="nc">&nbsp;        if (this == o)</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        readWriteLock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return getDelegate().equals(o);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a unmodifiable copy of the set.
&nbsp;     *
&nbsp;     * @param set the set to be copied.
&nbsp;     *
&nbsp;     * @return a unmodifiable copy of the set
&nbsp;     */
&nbsp;    private &lt;C&gt; Set&lt;C&gt; copySet(Set&lt;C&gt; set)
&nbsp;    {
<b class="nc">&nbsp;        return Collections.unmodifiableSet(new LinkedHashSet&lt;&gt;(set));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inform allVerticesSet that the backing data has been modified.
&nbsp;     */
&nbsp;    private void vertexSetModified()
&nbsp;    {
<b class="nc">&nbsp;        allVerticesSet.modified();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inform allEdgesSet that the backing data has been modified.
&nbsp;     */
&nbsp;    private void edgeSetModified()
&nbsp;    {
<b class="nc">&nbsp;        allEdgesSet.modified();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return whether fair mode is used for synchronizing access to this graph.
&nbsp;     * 
&nbsp;     * @return &lt;tt&gt;true&lt;/tt&gt; if the graph uses fair mode, &lt;tt&gt;false&lt;/tt&gt; if non-fair mode
&nbsp;     */
&nbsp;    public boolean isFair()
&nbsp;    {
<b class="nc">&nbsp;        return readWriteLock.isFair();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the read/write lock used to synchronize all access to this graph. This can be used by
&nbsp;     * calling applications to explicitly synchronize compound sequences of graph accessses. The
&nbsp;     * lock is reentrant, so the locks acquired internally by AsSynchronizedGraph will not interfere
&nbsp;     * with the caller&#39;s acquired lock. However, write methods &lt;strong&gt;MUST NOT&lt;/strong&gt; be called
&nbsp;     * while holding a read lock, otherwise a deadlock will occur.
&nbsp;     *
&nbsp;     * @return the reentrant read/write lock used to synchronize all access to this graph
&nbsp;     */
&nbsp;    public ReentrantReadWriteLock getLock()
&nbsp;    {
<b class="nc">&nbsp;        return readWriteLock;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a synchronized (thread-safe) and unmodifiable Set backed by the specified Set. In
&nbsp;     * order to guarantee serial access, it is critical that &lt;strong&gt;all&lt;/strong&gt; access to the
&nbsp;     * backing Set is accomplished through the created Set.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When a traversal over the set is started via a method such as iterator(), a snapshot of the
&nbsp;     * underlying set is copied for iteration purposes (unless copyless mode is enabled).
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The created Set&#39;s hashCode is equal to the backing Set&#39;s hashCode. And the created Set is
&nbsp;     * equal to another set if they are the same Set or the backing Set is equal to the other Set.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The created set will be serializable if the backing set is serializable.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param &lt;E&gt; the class of the objects in the set
&nbsp;     *
&nbsp;     * @author CHEN Kui
&nbsp;     */
<b class="nc">&nbsp;    private static class CopyOnDemandSet&lt;E&gt;</b>
&nbsp;        implements
&nbsp;        Set&lt;E&gt;,
&nbsp;        Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 5553953818148294283L;
&nbsp;
&nbsp;        // Backing set.
&nbsp;        private Set&lt;E&gt; set;
&nbsp;
&nbsp;        // When this flag is set, the backing set is used directly rather than
&nbsp;        // a copy.
&nbsp;        private final boolean copyless;
&nbsp;
&nbsp;        // Backing set&#39;s unmodifiable copy. If null, needs to be recomputed on next access.
&nbsp;        volatile private transient Set&lt;E&gt; copy;
&nbsp;
&nbsp;        final ReadWriteLock readWriteLock;
&nbsp;
&nbsp;        private static final String UNMODIFIABLE = &quot;this set is unmodifiable&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor for CopyOnDemandSet.
&nbsp;         * 
&nbsp;         * @param s the backing set.
&nbsp;         * @param readWriteLock the ReadWriteLock on which to locked
&nbsp;         * @param copyless whether copyless mode should be used
&nbsp;         */
&nbsp;        private CopyOnDemandSet(Set&lt;E&gt; s, ReadWriteLock readWriteLock, boolean copyless)
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            set = Objects.requireNonNull(s, &quot;s must not be null&quot;);</b>
<b class="nc">&nbsp;            copy = null;</b>
<b class="nc">&nbsp;            this.readWriteLock = readWriteLock;</b>
<b class="nc">&nbsp;            this.copyless = copyless;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return whether copyless mode is used for iteration.
&nbsp;         * 
&nbsp;         * @return &lt;tt&gt;true&lt;/tt&gt; if the set uses copyless mode, &lt;tt&gt;false&lt;/tt&gt; otherwise
&nbsp;         */
&nbsp;        public boolean isCopyless()
&nbsp;        {
<b class="nc">&nbsp;            return copyless;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public int size()
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.size();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean isEmpty()
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.isEmpty();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean contains(Object o)
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.contains(o);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an iterator over the elements in the backing set&#39;s unmodifiable copy. The
&nbsp;         * elements are returned in the same order of the backing set.
&nbsp;         *
&nbsp;         * @return an iterator over the elements in the backing set&#39;s unmodifiable copy.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Iterator&lt;E&gt; iterator()
&nbsp;        {
<b class="nc">&nbsp;            return getCopy().iterator();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Object[] toArray()
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.toArray();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public &lt;T&gt; T[] toArray(T[] a)
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.toArray(a);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean add(E e)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean remove(Object o)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean containsAll(Collection&lt;?&gt; c)
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.containsAll(c);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean addAll(Collection&lt;? extends E&gt; c)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean retainAll(Collection&lt;?&gt; c)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeAll(Collection&lt;?&gt; c)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void clear()
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        // Override default methods in Collection
&nbsp;        @Override
&nbsp;        public void forEach(Consumer&lt;? super E&gt; action)
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                set.forEach(action);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeIf(Predicate&lt;? super E&gt; filter)
&nbsp;        {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(UNMODIFIABLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a &lt;Code&gt;Spliterator&lt;/code&gt; over the elements in the set&#39;s unmodifiable copy.
&nbsp;         *
&nbsp;         * @return a &lt;code&gt;Spliterator&lt;/code&gt; over the elements in the backing set&#39;s unmodifiable
&nbsp;         *         copy.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Spliterator&lt;E&gt; spliterator()
&nbsp;        {
<b class="nc">&nbsp;            return getCopy().spliterator();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return a sequential &lt;code&gt;Stream&lt;/code&gt; with the backing set&#39;s unmodifiable copy as its
&nbsp;         * source.
&nbsp;         * 
&nbsp;         * @return a sequential &lt;code&gt;Stream&lt;/code&gt; with the backing set&#39;s unmodifiable copy as its
&nbsp;         *         source.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Stream&lt;E&gt; stream()
&nbsp;        {
<b class="nc">&nbsp;            return getCopy().stream();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return a possibly parallel &lt;code&gt;Stream&lt;/code&gt; with the backing set&#39;s unmodifiable copy
&nbsp;         * as its source.
&nbsp;         * 
&nbsp;         * @return a possibly parallel &lt;code&gt;Stream&lt;/code&gt; with the backing set&#39;s unmodifiable copy
&nbsp;         *         as its source.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Stream&lt;E&gt; parallelStream()
&nbsp;        {
<b class="nc">&nbsp;            return getCopy().parallelStream();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Compares the specified object with this set for equality.
&nbsp;         * 
&nbsp;         * @param o object to be compared for equality with this set.
&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if o and this set are the same object or o is equal to the
&nbsp;         *         backing object, false otherwise.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean equals(Object o)
&nbsp;        {
<b class="nc">&nbsp;            if (this == o)</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.equals(o);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return the backing set&#39;s hashcode.
&nbsp;         * 
&nbsp;         * @return the backing set&#39;s hashcode.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public int hashCode()
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.hashCode();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return the backing set&#39;s toString result.
&nbsp;         * 
&nbsp;         * @return the backing set&#39;s toString result.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public String toString()
&nbsp;        {
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return set.toString();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the backing set&#39;s unmodifiable copy, or a direct reference to the backing set if in
&nbsp;         * copyless mode.
&nbsp;         *
&nbsp;         * @return the backing set or its unmodifiable copy
&nbsp;         */
&nbsp;        private Set&lt;E&gt; getCopy()
&nbsp;        {
<b class="nc">&nbsp;            if (copyless) {</b>
<b class="nc">&nbsp;                return set;</b>
&nbsp;            }
<b class="nc">&nbsp;            readWriteLock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                Set&lt;E&gt; tempCopy = copy;</b>
<b class="nc">&nbsp;                if (tempCopy == null) {</b>
<b class="nc">&nbsp;                    synchronized (this) {</b>
<b class="nc">&nbsp;                        tempCopy = copy;</b>
<b class="nc">&nbsp;                        if (tempCopy == null) {</b>
<b class="nc">&nbsp;                            copy = tempCopy = new LinkedHashSet&lt;&gt;(set);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                return tempCopy;</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                readWriteLock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If the backing set is modified, call this method to let this set knows the backing set&#39;s
&nbsp;         * copy need to update.
&nbsp;         */
&nbsp;        private void modified()
&nbsp;        {
<b class="nc">&nbsp;            copy = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An interface for cache strategy of AsSynchronizedGraph&#39;s &lt;code&gt;edgesOf&lt;/code&gt;,
&nbsp;     * &lt;code&gt;incomingEdgesOf&lt;/code&gt; and &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;     */
&nbsp;    private interface CacheStrategy&lt;V, E&gt;
&nbsp;    {
&nbsp;        /**
&nbsp;         * Add an edge into AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        E addEdge(V sourceVertex, V targetVertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Add an edge into AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        boolean addEdge(V sourceVertex, V targetVertex, E e);
&nbsp;
&nbsp;        /**
&nbsp;         * Get all edges touching the specified vertex in AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        Set&lt;E&gt; edgesOf(V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Get a set of all edges in AsSynchronizedGraph&#39;s backing graph incoming into the specified
&nbsp;         * vertex.
&nbsp;         */
&nbsp;        Set&lt;E&gt; incomingEdgesOf(V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Get a set of all edges in AsSynchronizedGraph&#39;s backing graph outgoing from the specified
&nbsp;         * vertex.
&nbsp;         */
&nbsp;        Set&lt;E&gt; outgoingEdgesOf(V vertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Remove the specified edge from AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        boolean removeEdge(E e);
&nbsp;
&nbsp;        /**
&nbsp;         * Remove an edge from AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        E removeEdge(V sourceVertex, V targetVertex);
&nbsp;
&nbsp;        /**
&nbsp;         * Remove the specified vertex from AsSynchronizedGraph&#39;s backing graph.
&nbsp;         */
&nbsp;        boolean removeVertex(V v);
&nbsp;
&nbsp;        /**
&nbsp;         * Return whether the graph uses cache for &lt;code&gt;edgesOf&lt;/code&gt;,
&nbsp;         * &lt;code&gt;incomingEdgesOf&lt;/code&gt; and &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;         * 
&nbsp;         * @return &lt;tt&gt;true&lt;/tt&gt; if cache is in use, &lt;tt&gt;false&lt;/tt&gt; if cache is not in use.
&nbsp;         */
&nbsp;        boolean isCacheEnabled();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Don&#39;t use cache for AsSynchronizedGraph&#39;s &lt;code&gt;edgesOf&lt;/code&gt;, &lt;code&gt;incomingEdgesOf&lt;/code&gt;
&nbsp;     * and &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;     */
<b class="nc">&nbsp;    private class NoCache</b>
&nbsp;        implements
&nbsp;        CacheStrategy&lt;V, E&gt;,
&nbsp;        Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 19246150051213471L;
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public E addEdge(V sourceVertex, V targetVertex)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.addEdge(sourceVertex, targetVertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean addEdge(V sourceVertex, V targetVertex, E e)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.addEdge(sourceVertex, targetVertex, e);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; edgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return copySet(AsSynchronizedGraph.super.edgesOf(vertex));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; incomingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return copySet(AsSynchronizedGraph.super.incomingEdgesOf(vertex));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; outgoingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return copySet(AsSynchronizedGraph.super.outgoingEdgesOf(vertex));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeEdge(E e)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.removeEdge(e);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public E removeEdge(V sourceVertex, V targetVertex)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.removeEdge(sourceVertex, targetVertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeVertex(V v)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.removeVertex(v);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean isCacheEnabled()
&nbsp;        {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Disable cache as per &lt;code&gt;NoCache&lt;/code&gt;, and also don&#39;t produce copies; instead, just
&nbsp;     * directly return the results from the underlying graph. This requires the caller to explicitly
&nbsp;     * synchronize iterations over these collections.
&nbsp;     */
<b class="nc">&nbsp;    private class NoCopy</b>
&nbsp;        extends
&nbsp;        NoCache
&nbsp;    {
&nbsp;        private static final long serialVersionUID = -5046944235164395939L;
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; edgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.edgesOf(vertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; incomingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.incomingEdgesOf(vertex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; outgoingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            return AsSynchronizedGraph.super.outgoingEdgesOf(vertex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use cache for AsSynchronizedGraph&#39;s &lt;code&gt;edgesOf&lt;/code&gt;, &lt;code&gt;incomingEdgesOf&lt;/code&gt; and
&nbsp;     * &lt;code&gt;outgoingEdgesOf&lt;/code&gt; methods.
&nbsp;     */
<b class="nc">&nbsp;    private class CacheAccess</b>
&nbsp;        implements
&nbsp;        CacheStrategy&lt;V, E&gt;,
&nbsp;        Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = -18262921841829294L;
&nbsp;
&nbsp;        // A map caching for incomingEdges operation.
<b class="nc">&nbsp;        private final transient Map&lt;V, Set&lt;E&gt;&gt; incomingEdgesMap = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // A map caching for outgoingEdges operation.
<b class="nc">&nbsp;        private final transient Map&lt;V, Set&lt;E&gt;&gt; outgoingEdgesMap = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // A map caching for edgesOf operation.
<b class="nc">&nbsp;        private final transient Map&lt;V, Set&lt;E&gt;&gt; edgesOfMap = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public E addEdge(V sourceVertex, V targetVertex)
&nbsp;        {
<b class="nc">&nbsp;            E e = AsSynchronizedGraph.super.addEdge(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            if (e != null)</b>
<b class="nc">&nbsp;                edgeModified(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            return e;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean addEdge(V sourceVertex, V targetVertex, E e)
&nbsp;        {
<b class="nc">&nbsp;            if (AsSynchronizedGraph.super.addEdge(sourceVertex, targetVertex, e)) {</b>
<b class="nc">&nbsp;                edgeModified(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; edgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            Set&lt;E&gt; s = edgesOfMap.get(vertex);</b>
<b class="nc">&nbsp;            if (s != null)</b>
<b class="nc">&nbsp;                return s;</b>
<b class="nc">&nbsp;            s = copySet(AsSynchronizedGraph.super.edgesOf(vertex));</b>
<b class="nc">&nbsp;            edgesOfMap.put(vertex, s);</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; incomingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            Set&lt;E&gt; s = incomingEdgesMap.get(vertex);</b>
<b class="nc">&nbsp;            if (s != null)</b>
<b class="nc">&nbsp;                return s;</b>
<b class="nc">&nbsp;            s = copySet(AsSynchronizedGraph.super.incomingEdgesOf(vertex));</b>
<b class="nc">&nbsp;            incomingEdgesMap.put(vertex, s);</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Set&lt;E&gt; outgoingEdgesOf(V vertex)
&nbsp;        {
<b class="nc">&nbsp;            Set&lt;E&gt; s = outgoingEdgesMap.get(vertex);</b>
<b class="nc">&nbsp;            if (s != null)</b>
<b class="nc">&nbsp;                return s;</b>
<b class="nc">&nbsp;            s = copySet(AsSynchronizedGraph.super.outgoingEdgesOf(vertex));</b>
<b class="nc">&nbsp;            outgoingEdgesMap.put(vertex, s);</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeEdge(E e)
&nbsp;        {
<b class="nc">&nbsp;            V sourceVertex = getEdgeSource(e);</b>
<b class="nc">&nbsp;            V targetVertex = getEdgeTarget(e);</b>
<b class="nc">&nbsp;            if (AsSynchronizedGraph.super.removeEdge(e)) {</b>
<b class="nc">&nbsp;                edgeModified(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public E removeEdge(V sourceVertex, V targetVertex)
&nbsp;        {
<b class="nc">&nbsp;            E e = AsSynchronizedGraph.super.removeEdge(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            if (e != null)</b>
<b class="nc">&nbsp;                edgeModified(sourceVertex, targetVertex);</b>
<b class="nc">&nbsp;            return e;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean removeVertex(V v)
&nbsp;        {
<b class="nc">&nbsp;            if (AsSynchronizedGraph.super.removeVertex(v)) {</b>
<b class="nc">&nbsp;                edgesOfMap.clear();</b>
<b class="nc">&nbsp;                incomingEdgesMap.clear();</b>
<b class="nc">&nbsp;                outgoingEdgesMap.clear();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Clear the copies which the edge to be added or removed can affect.
&nbsp;         *
&nbsp;         * @param sourceVertex source vertex of the modified edge.
&nbsp;         * @param targetVertex target vertex of the modified edge.
&nbsp;         */
&nbsp;        private void edgeModified(V sourceVertex, V targetVertex)
&nbsp;        {
<b class="nc">&nbsp;            outgoingEdgesMap.remove(sourceVertex);</b>
<b class="nc">&nbsp;            incomingEdgesMap.remove(targetVertex);</b>
<b class="nc">&nbsp;            edgesOfMap.remove(sourceVertex);</b>
<b class="nc">&nbsp;            edgesOfMap.remove(targetVertex);</b>
<b class="nc">&nbsp;            if (!AsSynchronizedGraph.super.getType().isDirected()) {</b>
<b class="nc">&nbsp;                outgoingEdgesMap.remove(targetVertex);</b>
<b class="nc">&nbsp;                incomingEdgesMap.remove(sourceVertex);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean isCacheEnabled()
&nbsp;        {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A builder for {@link AsSynchronizedGraph}.
&nbsp;     *
&nbsp;     * @param &lt;V&gt; the graph vertex type
&nbsp;     * @param &lt;E&gt; the graph edge type
&nbsp;     *
&nbsp;     * @author CHEN Kui
&nbsp;     */
&nbsp;    public static class Builder&lt;V, E&gt;
&nbsp;    {
&nbsp;        private boolean cacheEnable;
&nbsp;        private boolean fair;
&nbsp;        private boolean copyless;
&nbsp;
&nbsp;        /**
&nbsp;         * Construct a new Builder with non-fair mode, cache disabled, and copyless mode disabled.
&nbsp;         */
&nbsp;        public Builder()
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            cacheEnable = false;</b>
<b class="nc">&nbsp;            fair = false;</b>
<b class="nc">&nbsp;            copyless = false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Construct a new Builder matching the settings of an existing graph.
&nbsp;         *
&nbsp;         * @param graph the graph on which to base the builder
&nbsp;         */
&nbsp;        public Builder(AsSynchronizedGraph&lt;V, E&gt; graph)
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            this.cacheEnable = graph.isCacheEnabled();</b>
<b class="nc">&nbsp;            this.fair = graph.isFair();</b>
<b class="nc">&nbsp;            this.copyless = graph.isCopyless();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph without caching.
&nbsp;         *
&nbsp;         * @return the Builder
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; cacheDisable()
&nbsp;        {
<b class="nc">&nbsp;            cacheEnable = false;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph with caching.
&nbsp;         *
&nbsp;         * @return the Builder
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; cacheEnable()
&nbsp;        {
<b class="nc">&nbsp;            cacheEnable = true;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return whether a cache will be used for the synchronized graph being built.
&nbsp;         *
&nbsp;         * @return &lt;tt&gt;true&lt;/tt&gt; if cache will be used, &lt;tt&gt;false&lt;/tt&gt; if cache will not be used
&nbsp;         */
&nbsp;        public boolean isCacheEnable()
&nbsp;        {
<b class="nc">&nbsp;            return cacheEnable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph which does not return collection copies.
&nbsp;         *
&nbsp;         * @return the Builder
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; setCopyless()
&nbsp;        {
<b class="nc">&nbsp;            copyless = true;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph which returns collection copies.
&nbsp;         *
&nbsp;         * @return the Builder
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; clearCopyless()
&nbsp;        {
<b class="nc">&nbsp;            copyless = false;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return whether copyless mode will be used for the synchronized graph being built.
&nbsp;         *
&nbsp;         * @return &lt;tt&gt;true&lt;/tt&gt; if constructed as copyless, &lt;tt&gt;false&lt;/tt&gt; otherwise
&nbsp;         */
&nbsp;        public boolean isCopyless()
&nbsp;        {
<b class="nc">&nbsp;            return copyless;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph with fair mode.
&nbsp;         *
&nbsp;         * @return the SynchronizedGraphParams
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; setFair()
&nbsp;        {
<b class="nc">&nbsp;            fair = true;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Request a synchronized graph with non-fair mode.
&nbsp;         *
&nbsp;         * @return the SynchronizedGraphParams
&nbsp;         */
&nbsp;        public Builder&lt;V, E&gt; setNonfair()
&nbsp;        {
<b class="nc">&nbsp;            fair = false;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Return whether fair mode will be used for the synchronized graph being built.
&nbsp;         *
&nbsp;         * @return &lt;tt&gt;true&lt;/tt&gt; if constructed as fair mode, &lt;tt&gt;false&lt;/tt&gt; if non-fair
&nbsp;         */
&nbsp;        public boolean isFair()
&nbsp;        {
<b class="nc">&nbsp;            return fair;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Build the AsSynchronizedGraph.
&nbsp;         *
&nbsp;         * @param graph the backing graph (the delegate)
&nbsp;         * @return the AsSynchronizedGraph
&nbsp;         */
&nbsp;        public AsSynchronizedGraph&lt;V, E&gt; build(Graph&lt;V, E&gt; graph)
&nbsp;        {
<b class="nc">&nbsp;            return new AsSynchronizedGraph&lt;&gt;(graph, cacheEnable, fair, copyless);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 10:39</div>
</div>
</body>
</html>
