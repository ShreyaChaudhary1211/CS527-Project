


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CliqueMinimalSeparatorDecomposition</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jgrapht.alg.clique</a>
</div>

<h1>Coverage Summary for Class: CliqueMinimalSeparatorDecomposition (org.jgrapht.alg.clique)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CliqueMinimalSeparatorDecomposition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/150)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (C) Copyright 2015-2018, by Florian Buenzli and Contributors.
&nbsp; *
&nbsp; * JGraphT : a free Java graph-theory library
&nbsp; *
&nbsp; * See the CONTRIBUTORS.md file distributed with this work for additional
&nbsp; * information regarding copyright ownership.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Public License 2.0 which is available at
&nbsp; * http://www.eclipse.org/legal/epl-2.0, or the
&nbsp; * GNU Lesser General Public License v2.1 or later
&nbsp; * which is available at
&nbsp; * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
&nbsp; *
&nbsp; * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
&nbsp; */
&nbsp;package org.jgrapht.alg.clique;
&nbsp;
&nbsp;import org.jgrapht.*;
&nbsp;import org.jgrapht.alg.connectivity.*;
&nbsp;import org.jgrapht.graph.builder.*;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.Map.*;
&nbsp;
&nbsp;/**
&nbsp; * Clique Minimal Separator Decomposition using MCS-M+ and Atoms algorithm as described in Berry et
&nbsp; * al. An Introduction to Clique Minimal Separator Decomposition (2010), DOI:10.3390/a3020197,
&nbsp; * &lt;a href=&quot;http://www.mdpi.com/1999-4893/3/2/197&quot;&gt; http://www.mdpi.com/1999-4893/3/2/197&lt;/a&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The Clique Minimal Separator (CMS) Decomposition is a procedure that splits a graph into a set of
&nbsp; * subgraphs separated by minimal clique separators, adding the separating clique to each component
&nbsp; * produced by the separation. At the end we have a set of atoms. The CMS decomposition is unique
&nbsp; * and yields the set of the atoms independent of the order of the decomposition.
&nbsp; *
&nbsp; * @param &lt;V&gt; the graph vertex type
&nbsp; * @param &lt;E&gt; the graph edge type
&nbsp; *
&nbsp; * @author Florian Buenzli (fbuenzli@student.ethz.ch)
&nbsp; * @author Thomas Tschager (thomas.tschager@inf.ethz.ch)
&nbsp; * @author Tomas Hruz (tomas.hruz@inf.ethz.ch)
&nbsp; * @author Philipp Hoppen
&nbsp; */
<b class="nc">&nbsp;public class CliqueMinimalSeparatorDecomposition&lt;V, E&gt;</b>
&nbsp;{
&nbsp;    /**
&nbsp;     * Source graph to operate on
&nbsp;     */
&nbsp;    private Graph&lt;V, E&gt; graph;
&nbsp;
&nbsp;    /**
&nbsp;     * Minimal triangulation of graph
&nbsp;     */
&nbsp;    private Graph&lt;V, E&gt; chordalGraph;
&nbsp;
&nbsp;    /**
&nbsp;     * Fill edges
&nbsp;     */
&nbsp;    private Set&lt;E&gt; fillEdges;
&nbsp;
&nbsp;    /**
&nbsp;     * Minimal elimination ordering on the vertices of graph
&nbsp;     */
&nbsp;    private LinkedList&lt;V&gt; meo;
&nbsp;
&nbsp;    /**
&nbsp;     * List of all vertices that generate a minimal separator of &lt;code&gt;
&nbsp;     * chordGraph&lt;/code&gt;
&nbsp;     */
&nbsp;    private List&lt;V&gt; generators;
&nbsp;
&nbsp;    /**
&nbsp;     * Set of clique minimal separators
&nbsp;     */
&nbsp;    private Set&lt;Set&lt;V&gt;&gt; separators;
&nbsp;
&nbsp;    /**
&nbsp;     * The atoms generated by the decomposition
&nbsp;     */
&nbsp;    private Set&lt;Set&lt;V&gt;&gt; atoms;
&nbsp;
&nbsp;    /**
&nbsp;     * Map for each separator how many components it produces.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Set&lt;V&gt;, Integer&gt; fullComponentCount = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Setup a clique minimal separator decomposition on undirected graph &lt;code&gt;
&nbsp;     * g&lt;/code&gt;. Loops and multiple (parallel) edges are removed, i.e. the graph is transformed to a
&nbsp;     * simple graph.
&nbsp;     *
&nbsp;     * @param g The graph to decompose.
&nbsp;     */
&nbsp;    public CliqueMinimalSeparatorDecomposition(Graph&lt;V, E&gt; g)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        this.graph = GraphTests.requireUndirected(g);</b>
<b class="nc">&nbsp;        this.fillEdges = new HashSet&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute the minimal triangulation of the graph. Implementation of Algorithm MCS-M+ as
&nbsp;     * described in Berry et al. (2010), DOI:10.3390/a3020197
&nbsp;     * &lt;a href=&quot;http://www.mdpi.com/1999-4893/3/2/197&quot;&gt; http://www.mdpi.com/1999-4893/3/2/197&lt;/a&gt;
&nbsp;     */
&nbsp;    private void computeMinimalTriangulation()
&nbsp;    {
&nbsp;        // initialize chordGraph with same vertices as graph
<b class="nc">&nbsp;        chordalGraph = GraphTypeBuilder</b>
<b class="nc">&nbsp;            .&lt;V, E&gt; undirected().edgeSupplier(graph.getEdgeSupplier())</b>
<b class="nc">&nbsp;            .vertexSupplier(graph.getVertexSupplier()).allowingMultipleEdges(false)</b>
<b class="nc">&nbsp;            .allowingSelfLoops(false).buildGraph();</b>
&nbsp;
<b class="nc">&nbsp;        for (V v : graph.vertexSet()) {</b>
<b class="nc">&nbsp;            chordalGraph.addVertex(v);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // initialize g&#39; as subgraph of graph (same vertices and edges)
<b class="nc">&nbsp;        final Graph&lt;V, E&gt; gprime = copyAsSimpleGraph(graph);</b>
<b class="nc">&nbsp;        int s = -1;</b>
<b class="nc">&nbsp;        generators = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        meo = new LinkedList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        final Map&lt;V, Integer&gt; vertexLabels = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (V v : gprime.vertexSet()) {</b>
<b class="nc">&nbsp;            vertexLabels.put(v, 0);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (int i = 1, n = graph.vertexSet().size(); i &lt;= n; i++) {</b>
<b class="nc">&nbsp;            V v = getMaxLabelVertex(vertexLabels);</b>
<b class="nc">&nbsp;            LinkedList&lt;V&gt; Y = new LinkedList&lt;&gt;(Graphs.neighborListOf(gprime, v));</b>
&nbsp;
<b class="nc">&nbsp;            if (vertexLabels.get(v) &lt;= s) {</b>
<b class="nc">&nbsp;                generators.add(v);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            s = vertexLabels.get(v);</b>
&nbsp;
&nbsp;            // Mark x reached and all other vertices of gprime unreached
<b class="nc">&nbsp;            HashSet&lt;V&gt; reached = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            reached.add(v);</b>
&nbsp;
&nbsp;            // mark neighborhood of x reached and add to reach(label(y))
<b class="nc">&nbsp;            HashMap&lt;Integer, HashSet&lt;V&gt;&gt; reach = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;            // mark y reached and add y to reach
<b class="nc">&nbsp;            for (V y : Y) {</b>
<b class="nc">&nbsp;                reached.add(y);</b>
<b class="nc">&nbsp;                addToReach(vertexLabels.get(y), y, reach);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            for (int j = 0; j &lt; graph.vertexSet().size(); j++) {</b>
<b class="nc">&nbsp;                if (!reach.containsKey(j)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                while (reach.get(j).size() &gt; 0) {</b>
&nbsp;                    // remove a vertex y from reach(j)
<b class="nc">&nbsp;                    V y = reach.get(j).iterator().next();</b>
<b class="nc">&nbsp;                    reach.get(j).remove(y);</b>
&nbsp;
<b class="nc">&nbsp;                    for (V z : Graphs.neighborListOf(gprime, y)) {</b>
<b class="nc">&nbsp;                        if (!reached.contains(z)) {</b>
<b class="nc">&nbsp;                            reached.add(z);</b>
<b class="nc">&nbsp;                            if (vertexLabels.get(z) &gt; j) {</b>
<b class="nc">&nbsp;                                Y.add(z);</b>
<b class="nc">&nbsp;                                E fillEdge = graph.getEdgeSupplier().get();</b>
<b class="nc">&nbsp;                                fillEdges.add(fillEdge);</b>
<b class="nc">&nbsp;                                addToReach(vertexLabels.get(z), z, reach);</b>
<b class="nc">&nbsp;                            } else {</b>
<b class="nc">&nbsp;                                addToReach(j, z, reach);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (V y : Y) {</b>
<b class="nc">&nbsp;                chordalGraph.addEdge(v, y);</b>
<b class="nc">&nbsp;                vertexLabels.put(y, vertexLabels.get(y) + 1);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            meo.addLast(v);</b>
<b class="nc">&nbsp;            gprime.removeVertex(v);</b>
<b class="nc">&nbsp;            vertexLabels.remove(v);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the vertex with the maximal label.
&nbsp;     *
&nbsp;     * @param vertexLabels Map that gives a label for each vertex.
&nbsp;     *
&nbsp;     * @return Vertex with the maximal label.
&nbsp;     */
&nbsp;    private V getMaxLabelVertex(Map&lt;V, Integer&gt; vertexLabels)
&nbsp;    {
<b class="nc">&nbsp;        Iterator&lt;Entry&lt;V, Integer&gt;&gt; iterator = vertexLabels.entrySet().iterator();</b>
<b class="nc">&nbsp;        Entry&lt;V, Integer&gt; max = iterator.next();</b>
<b class="nc">&nbsp;        while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;            Entry&lt;V, Integer&gt; e = iterator.next();</b>
<b class="nc">&nbsp;            if (e.getValue() &gt; max.getValue()) {</b>
<b class="nc">&nbsp;                max = e;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return max.getKey();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a vertex to reach.
&nbsp;     *
&nbsp;     * @param k vertex&#39; label
&nbsp;     * @param v the vertex
&nbsp;     * @param r the reach structure.
&nbsp;     */
&nbsp;    private void addToReach(Integer k, V v, HashMap&lt;Integer, HashSet&lt;V&gt;&gt; r)
&nbsp;    {
<b class="nc">&nbsp;        if (r.containsKey(k)) {</b>
<b class="nc">&nbsp;            r.get(k).add(v);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            HashSet&lt;V&gt; set = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            set.add(v);</b>
<b class="nc">&nbsp;            r.put(k, set);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute the unique decomposition of the input graph $G$ (atoms of $G$). Implementation of
&nbsp;     * algorithm Atoms as described in Berry et al. (2010), DOI:10.3390/a3020197,
&nbsp;     * &lt;a href=&quot;http://www.mdpi.com/1999-4893/3/2/197&quot;&gt; http://www.mdpi.com/1999-4893/3/2/197&lt;/a&gt;
&nbsp;     */
&nbsp;    private void computeAtoms()
&nbsp;    {
<b class="nc">&nbsp;        if (chordalGraph == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        separators = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // initialize g&#39; as subgraph of graph (same vertices and edges)
<b class="nc">&nbsp;        Graph&lt;V, E&gt; gprime = copyAsSimpleGraph(graph);</b>
&nbsp;
&nbsp;        // initialize h&#39; as subgraph of chordalGraph (same vertices and edges)
<b class="nc">&nbsp;        Graph&lt;V, E&gt; hprime = copyAsSimpleGraph(chordalGraph);</b>
&nbsp;
<b class="nc">&nbsp;        atoms = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Iterator&lt;V&gt; iterator = meo.descendingIterator();</b>
<b class="nc">&nbsp;        while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;            V v = iterator.next();</b>
<b class="nc">&nbsp;            if (generators.contains(v)) {</b>
<b class="nc">&nbsp;                Set&lt;V&gt; separator = new HashSet&lt;&gt;(Graphs.neighborListOf(hprime, v));</b>
&nbsp;
<b class="nc">&nbsp;                if (isClique(graph, separator)) {</b>
<b class="nc">&nbsp;                    if (separator.size() &gt; 0) {</b>
<b class="nc">&nbsp;                        if (separators.contains(separator)) {</b>
<b class="nc">&nbsp;                            fullComponentCount</b>
<b class="nc">&nbsp;                                .put(separator, fullComponentCount.get(separator) + 1);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            fullComponentCount.put(separator, 2);</b>
<b class="nc">&nbsp;                            separators.add(separator);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    Graph&lt;V, E&gt; tmpGraph = copyAsSimpleGraph(gprime);</b>
&nbsp;
<b class="nc">&nbsp;                    tmpGraph.removeAllVertices(separator);</b>
<b class="nc">&nbsp;                    ConnectivityInspector&lt;V, E&gt; con = new ConnectivityInspector&lt;&gt;(tmpGraph);</b>
<b class="nc">&nbsp;                    if (con.isConnected()) {</b>
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;separator did not separate the graph&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (Set&lt;V&gt; component : con.connectedSets()) {</b>
<b class="nc">&nbsp;                        if (component.contains(v)) {</b>
<b class="nc">&nbsp;                            gprime.removeAllVertices(component);</b>
<b class="nc">&nbsp;                            component.addAll(separator);</b>
<b class="nc">&nbsp;                            atoms.add(new HashSet&lt;&gt;(component));</b>
<b class="nc">&nbsp;                            assert (component.size() &gt; 0);</b>
&nbsp;                            break;
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            hprime.removeVertex(v);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (gprime.vertexSet().size() &gt; 0) {</b>
<b class="nc">&nbsp;            atoms.add(new HashSet&lt;&gt;(gprime.vertexSet()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check whether the subgraph of &lt;code&gt;graph&lt;/code&gt; induced by the given &lt;code&gt;vertices&lt;/code&gt;
&nbsp;     * is complete, i.e. a clique.
&nbsp;     *
&nbsp;     * @param graph the graph.
&nbsp;     * @param vertices the vertices to induce the subgraph from.
&nbsp;     *
&nbsp;     * @return true if the induced subgraph is a clique.
&nbsp;     */
&nbsp;    private static &lt;V, E&gt; boolean isClique(Graph&lt;V, E&gt; graph, Set&lt;V&gt; vertices)
&nbsp;    {
<b class="nc">&nbsp;        for (V v1 : vertices) {</b>
<b class="nc">&nbsp;            for (V v2 : vertices) {</b>
<b class="nc">&nbsp;                if (!v1.equals(v2) &amp;&amp; (graph.getEdge(v1, v2) == null)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a copy of a graph for internal use.
&nbsp;     *
&nbsp;     * @param graph the graph to copy.
&nbsp;     *
&nbsp;     * @return A copy of the graph projected to a SimpleGraph.
&nbsp;     */
&nbsp;    private static &lt;V, E&gt; Graph&lt;V, E&gt; copyAsSimpleGraph(Graph&lt;V, E&gt; graph)
&nbsp;    {
&nbsp;        Graph&lt;V,
&nbsp;            E&gt; copy = GraphTypeBuilder
<b class="nc">&nbsp;                .&lt;V, E&gt; undirected().edgeSupplier(graph.getEdgeSupplier())</b>
<b class="nc">&nbsp;                .vertexSupplier(graph.getVertexSupplier()).allowingMultipleEdges(false)</b>
<b class="nc">&nbsp;                .allowingSelfLoops(false).buildGraph();</b>
&nbsp;
<b class="nc">&nbsp;        if (graph.getType().isSimple()) {</b>
<b class="nc">&nbsp;            Graphs.addGraph(copy, graph);</b>
&nbsp;        } else {
&nbsp;            // project graph to SimpleGraph
<b class="nc">&nbsp;            Graphs.addAllVertices(copy, graph.vertexSet());</b>
<b class="nc">&nbsp;            for (E e : graph.edgeSet()) {</b>
<b class="nc">&nbsp;                V v1 = graph.getEdgeSource(e);</b>
<b class="nc">&nbsp;                V v2 = graph.getEdgeTarget(e);</b>
<b class="nc">&nbsp;                if (!v1.equals(v2) &amp;&amp; !copy.containsEdge(e)) {</b>
<b class="nc">&nbsp;                    copy.addEdge(v1, v2);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return copy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the graph is chordal.
&nbsp;     *
&nbsp;     * @return true if the graph is chordal, false otherwise.
&nbsp;     */
&nbsp;    public boolean isChordal()
&nbsp;    {
<b class="nc">&nbsp;        if (chordalGraph == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return (chordalGraph.edgeSet().size() == graph.edgeSet().size());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the fill edges generated by the triangulation.
&nbsp;     *
&nbsp;     * @return Set of fill edges.
&nbsp;     */
&nbsp;    public Set&lt;E&gt; getFillEdges()
&nbsp;    {
<b class="nc">&nbsp;        if (fillEdges == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return fillEdges;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the minimal triangulation of the graph.
&nbsp;     *
&nbsp;     * @return Triangulated graph.
&nbsp;     */
&nbsp;    public Graph&lt;V, E&gt; getMinimalTriangulation()
&nbsp;    {
<b class="nc">&nbsp;        if (chordalGraph == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return chordalGraph;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the generators of the separators of the triangulated graph, i.e. all vertices that
&nbsp;     * generate a minimal separator of triangulated graph.
&nbsp;     *
&nbsp;     * @return List of generators.
&nbsp;     */
&nbsp;    public List&lt;V&gt; getGenerators()
&nbsp;    {
<b class="nc">&nbsp;        if (generators == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return generators;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the minimal elimination ordering produced by the triangulation.
&nbsp;     *
&nbsp;     * @return The minimal elimination ordering.
&nbsp;     */
&nbsp;    public LinkedList&lt;V&gt; getMeo()
&nbsp;    {
<b class="nc">&nbsp;        if (meo == null) {</b>
<b class="nc">&nbsp;            computeMinimalTriangulation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return meo;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get a map to know for each separator how many components it produces.
&nbsp;     *
&nbsp;     * @return A map from separators to integers (component count).
&nbsp;     */
&nbsp;    public Map&lt;Set&lt;V&gt;, Integer&gt; getFullComponentCount()
&nbsp;    {
<b class="nc">&nbsp;        if (fullComponentCount == null) {</b>
<b class="nc">&nbsp;            computeAtoms();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return fullComponentCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the atoms generated by the decomposition.
&nbsp;     *
&nbsp;     * @return Set of atoms, where each atom is described as the set of its vertices.
&nbsp;     */
&nbsp;    public Set&lt;Set&lt;V&gt;&gt; getAtoms()
&nbsp;    {
<b class="nc">&nbsp;        if (atoms == null) {</b>
<b class="nc">&nbsp;            computeAtoms();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return atoms;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the clique minimal separators.
&nbsp;     *
&nbsp;     * @return Set of separators, where each separator is described as the set of its vertices.
&nbsp;     */
&nbsp;    public Set&lt;Set&lt;V&gt;&gt; getSeparators()
&nbsp;    {
<b class="nc">&nbsp;        if (separators == null) {</b>
<b class="nc">&nbsp;            computeAtoms();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return separators;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the original graph.
&nbsp;     *
&nbsp;     * @return Original graph.
&nbsp;     */
&nbsp;    public Graph&lt;V, E&gt; getGraph()
&nbsp;    {
<b class="nc">&nbsp;        return graph;</b>
&nbsp;    }
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 10:44</div>
</div>
</body>
</html>
