


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > PeriodFormatterBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.joda.time.format</a>
</div>

<h1>Coverage Summary for Class: PeriodFormatterBuilder (org.joda.time.format)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PeriodFormatterBuilder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/169)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$Composite</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$CompositeAffix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$FieldFormatter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/248)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$Literal</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$PeriodFieldAffix</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$PluralAffix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$Separator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/95)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeriodFormatterBuilder$SimpleAffix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/99)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/645)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright 2001-2009 Stephen Colebourne
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package org.joda.time.format;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Writer;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.TreeSet;
&nbsp;
&nbsp;import org.joda.time.DateTimeConstants;
&nbsp;import org.joda.time.DurationFieldType;
&nbsp;import org.joda.time.PeriodType;
&nbsp;import org.joda.time.ReadWritablePeriod;
&nbsp;import org.joda.time.ReadablePeriod;
&nbsp;
&nbsp;/**
&nbsp; * Factory that creates complex instances of PeriodFormatter via method calls.
&nbsp; * &lt;p&gt;
&nbsp; * Period formatting is performed by the {@link PeriodFormatter} class.
&nbsp; * Three classes provide factory methods to create formatters, and this is one.
&nbsp; * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.
&nbsp; * &lt;p&gt;
&nbsp; * PeriodFormatterBuilder is used for constructing formatters which are then
&nbsp; * used to print or parse. The formatters are built by appending specific fields
&nbsp; * or other formatters to an instance of this builder.
&nbsp; * &lt;p&gt;
&nbsp; * For example, a formatter that prints years and months, like &quot;15 years and 8 months&quot;,
&nbsp; * can be constructed as follows:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre&gt;
&nbsp; * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()
&nbsp; *     .printZeroAlways()
&nbsp; *     .appendYears()
&nbsp; *     .appendSuffix(&quot; year&quot;, &quot; years&quot;)
&nbsp; *     .appendSeparator(&quot; and &quot;)
&nbsp; *     .printZeroRarelyLast()
&nbsp; *     .appendMonths()
&nbsp; *     .appendSuffix(&quot; month&quot;, &quot; months&quot;)
&nbsp; *     .toFormatter();
&nbsp; * &lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * PeriodFormatterBuilder itself is mutable and not thread-safe, but the
&nbsp; * formatters that it builds are thread-safe and immutable.
&nbsp; *
&nbsp; * @author Brian S O&#39;Neill
&nbsp; * @since 1.0
&nbsp; * @see PeriodFormat
&nbsp; */
&nbsp;public class PeriodFormatterBuilder {
&nbsp;    private static final int PRINT_ZERO_RARELY_FIRST = 1;
&nbsp;    private static final int PRINT_ZERO_RARELY_LAST = 2;
&nbsp;    private static final int PRINT_ZERO_IF_SUPPORTED = 3;
&nbsp;    private static final int PRINT_ZERO_ALWAYS = 4;
&nbsp;    private static final int PRINT_ZERO_NEVER = 5;
&nbsp;    
&nbsp;    private static final int YEARS = 0;
&nbsp;    private static final int MONTHS = 1;
&nbsp;    private static final int WEEKS = 2;
&nbsp;    private static final int DAYS = 3;
&nbsp;    private static final int HOURS = 4;
&nbsp;    private static final int MINUTES = 5;
&nbsp;    private static final int SECONDS = 6;
&nbsp;    private static final int MILLIS = 7;
&nbsp;    private static final int SECONDS_MILLIS = 8;
&nbsp;    private static final int SECONDS_OPTIONAL_MILLIS = 9;
&nbsp;    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;
&nbsp;
&nbsp;    private int iMinPrintedDigits;
&nbsp;    private int iPrintZeroSetting;
&nbsp;    private int iMaxParsedDigits;
&nbsp;    private boolean iRejectSignedValues;
&nbsp;
&nbsp;    private PeriodFieldAffix iPrefix;
&nbsp;
&nbsp;    // List of Printers and Parsers used to build a final formatter.
&nbsp;    private List&lt;Object&gt; iElementPairs;
&nbsp;    /** Set to true if the formatter is not a printer. */
&nbsp;    private boolean iNotPrinter;
&nbsp;    /** Set to true if the formatter is not a parser. */
&nbsp;    private boolean iNotParser;
&nbsp;
&nbsp;    // Last PeriodFormatter appended of each field type.
&nbsp;    private FieldFormatter[] iFieldFormatters;
&nbsp;
<b class="nc">&nbsp;    public PeriodFormatterBuilder() {</b>
<b class="nc">&nbsp;        clear();</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Constructs a PeriodFormatter using all the appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * This is the main method used by applications at the end of the build
&nbsp;     * process to create a usable formatter.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned formatter.
&nbsp;     * &lt;p&gt;
&nbsp;     * The returned formatter may not support both printing and parsing.
&nbsp;     * The methods {@link PeriodFormatter#isPrinter()} and
&nbsp;     * {@link PeriodFormatter#isParser()} will help you determine the state
&nbsp;     * of the formatter.
&nbsp;     * 
&nbsp;     * @return the newly created formatter
&nbsp;     * @throws IllegalStateException if the builder can produce neither a printer nor a parser
&nbsp;     */
&nbsp;    public PeriodFormatter toFormatter() {
<b class="nc">&nbsp;        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);</b>
<b class="nc">&nbsp;        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();</b>
<b class="nc">&nbsp;        return formatter;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal method to create a PeriodPrinter instance using all the
&nbsp;     * appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * Most applications will not use this method.
&nbsp;     * If you want a printer in an application, call {@link #toFormatter()}
&nbsp;     * and just use the printing API.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned printer.
&nbsp;     * 
&nbsp;     * @return the newly created printer, null if builder cannot create a printer
&nbsp;     */
&nbsp;    public PeriodPrinter toPrinter() {
<b class="nc">&nbsp;        if (iNotPrinter) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return toFormatter().getPrinter();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal method to create a PeriodParser instance using all the
&nbsp;     * appended elements.
&nbsp;     * &lt;p&gt;
&nbsp;     * Most applications will not use this method.
&nbsp;     * If you want a printer in an application, call {@link #toFormatter()}
&nbsp;     * and just use the printing API.
&nbsp;     * &lt;p&gt;
&nbsp;     * Subsequent changes to this builder do not affect the returned parser.
&nbsp;     * 
&nbsp;     * @return the newly created parser, null if builder cannot create a parser
&nbsp;     */
&nbsp;    public PeriodParser toParser() {
<b class="nc">&nbsp;        if (iNotParser) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return toFormatter().getParser();</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Clears out all the appended elements, allowing this builder to be reused.
&nbsp;     */
&nbsp;    public void clear() {
<b class="nc">&nbsp;        iMinPrintedDigits = 1;</b>
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;</b>
<b class="nc">&nbsp;        iMaxParsedDigits = 10;</b>
<b class="nc">&nbsp;        iRejectSignedValues = false;</b>
<b class="nc">&nbsp;        iPrefix = null;</b>
<b class="nc">&nbsp;        if (iElementPairs == null) {</b>
<b class="nc">&nbsp;            iElementPairs = new ArrayList&lt;Object&gt;();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            iElementPairs.clear();</b>
&nbsp;        }
<b class="nc">&nbsp;        iNotPrinter = false;</b>
<b class="nc">&nbsp;        iNotParser = false;</b>
<b class="nc">&nbsp;        iFieldFormatters = new FieldFormatter[10];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Appends another formatter.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder append(PeriodFormatter formatter) {
<b class="nc">&nbsp;        if (formatter == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No formatter supplied&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        clearPrefix();</b>
<b class="nc">&nbsp;        append0(formatter.getPrinter(), formatter.getParser());</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Appends a printer parser pair.
&nbsp;     * &lt;p&gt;
&nbsp;     * Either the printer or the parser may be null, in which case the builder will
&nbsp;     * be unable to produce a parser or printer repectively.
&nbsp;     *
&nbsp;     * @param printer  appends a printer to the builder, null if printing is not supported
&nbsp;     * @param parser  appends a parser to the builder, null if parsing is not supported
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalArgumentException if both the printer and parser are null
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {
<b class="nc">&nbsp;        if (printer == null &amp;&amp; parser == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No printer or parser supplied&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        clearPrefix();</b>
<b class="nc">&nbsp;        append0(printer, parser);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the printer to emit specific text, and the parser to expect it.
&nbsp;     * The parser is case-insensitive.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalArgumentException if text is null
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendLiteral(String text) {
<b class="nc">&nbsp;        if (text == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Literal must not be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        clearPrefix();</b>
<b class="nc">&nbsp;        Literal literal = new Literal(text);</b>
<b class="nc">&nbsp;        append0(literal, literal);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the minimum digits printed for the next and following appended
&nbsp;     * fields. By default, the minimum digits printed is one. If the field value
&nbsp;     * is zero, it is not printed unless a printZero rule is applied.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {
<b class="nc">&nbsp;        iMinPrintedDigits = minDigits;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the maximum digits parsed for the next and following appended
&nbsp;     * fields. By default, the maximum digits parsed is ten.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {
<b class="nc">&nbsp;        iMaxParsedDigits = maxDigits;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reject signed values when parsing the next and following appended fields.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder rejectSignedValues(boolean v) {
<b class="nc">&nbsp;        iRejectSignedValues = v;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Never print zero values for the next and following appended fields,
&nbsp;     * unless no fields would be printed. If no fields are printed, the printer
&nbsp;     * forces the last &quot;printZeroRarely&quot; field to print a zero.
&nbsp;     * &lt;p&gt;
&nbsp;     * This field setting is the default.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder printZeroRarelyLast() {
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Never print zero values for the next and following appended fields,
&nbsp;     * unless no fields would be printed. If no fields are printed, the printer
&nbsp;     * forces the first &quot;printZeroRarely&quot; field to print a zero.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder printZeroRarelyFirst() {
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Print zero values for the next and following appened fields only if the
&nbsp;     * period supports it.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder printZeroIfSupported() {
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Always print zero values for the next and following appended fields,
&nbsp;     * even if the period doesn&#39;t support it. The parser requires values for
&nbsp;     * fields that always print zero.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder printZeroAlways() {
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_ALWAYS;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Never print zero values for the next and following appended fields,
&nbsp;     * unless no fields would be printed. If no fields are printed, the printer
&nbsp;     * forces the last &quot;printZeroRarely&quot; field to print a zero.
&nbsp;     * &lt;p&gt;
&nbsp;     * This field setting is the default.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder printZeroNever() {
<b class="nc">&nbsp;        iPrintZeroSetting = PRINT_ZERO_NEVER;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Append a field prefix which applies only to the next appended field. If
&nbsp;     * the field is not printed, neither is the prefix.
&nbsp;     *
&nbsp;     * @param text text to print before field only if field is printed
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @see #appendSuffix
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendPrefix(String text) {
<b class="nc">&nbsp;        if (text == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return appendPrefix(new SimpleAffix(text));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a field prefix which applies only to the next appended field. If
&nbsp;     * the field is not printed, neither is the prefix.
&nbsp;     * &lt;p&gt;
&nbsp;     * During parsing, the singular and plural versions are accepted whether
&nbsp;     * or not the actual value matches plurality.
&nbsp;     *
&nbsp;     * @param singularText text to print if field value is one
&nbsp;     * @param pluralText text to print if field value is not one
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @see #appendSuffix
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendPrefix(String singularText,
&nbsp;                                                 String pluralText) {
<b class="nc">&nbsp;        if (singularText == null || pluralText == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return appendPrefix(new PluralAffix(singularText, pluralText));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a field prefix which applies only to the next appended field. If
&nbsp;     * the field is not printed, neither is the prefix.
&nbsp;     *
&nbsp;     * @param prefix custom prefix
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @see #appendSuffix
&nbsp;     */
&nbsp;    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {
<b class="nc">&nbsp;        if (prefix == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (iPrefix != null) {</b>
<b class="nc">&nbsp;            prefix = new CompositeAffix(iPrefix, prefix);</b>
&nbsp;        }
<b class="nc">&nbsp;        iPrefix = prefix;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer years field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendYears() {
<b class="nc">&nbsp;        appendField(YEARS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer months field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendMonths() {
<b class="nc">&nbsp;        appendField(MONTHS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer weeks field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendWeeks() {
<b class="nc">&nbsp;        appendField(WEEKS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer days field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendDays() {
<b class="nc">&nbsp;        appendField(DAYS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer hours field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendHours() {
<b class="nc">&nbsp;        appendField(HOURS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer minutes field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendMinutes() {
<b class="nc">&nbsp;        appendField(MINUTES);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer seconds field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeconds() {
<b class="nc">&nbsp;        appendField(SECONDS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit a combined seconds and millis field, if supported.
&nbsp;     * The millis will overflow into the seconds if necessary.
&nbsp;     * The millis are always output.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSecondsWithMillis() {
<b class="nc">&nbsp;        appendField(SECONDS_MILLIS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit a combined seconds and millis field, if supported.
&nbsp;     * The millis will overflow into the seconds if necessary.
&nbsp;     * The millis are only output if non-zero.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {
<b class="nc">&nbsp;        appendField(SECONDS_OPTIONAL_MILLIS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer millis field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of printed and parsed digits can be controlled using
&nbsp;     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendMillis() {
<b class="nc">&nbsp;        appendField(MILLIS);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruct the printer to emit an integer millis field, if supported.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.
&nbsp;     *
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendMillis3Digit() {
<b class="nc">&nbsp;        appendField(7, 3);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void appendField(int type) {
<b class="nc">&nbsp;        appendField(type, iMinPrintedDigits);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void appendField(int type, int minPrinted) {
<b class="nc">&nbsp;        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,</b>
&nbsp;            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);
<b class="nc">&nbsp;        append0(field, field);</b>
<b class="nc">&nbsp;        iFieldFormatters[type] = field;</b>
<b class="nc">&nbsp;        iPrefix = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Append a field suffix which applies only to the last appended field. If
&nbsp;     * the field is not printed, neither is the suffix.
&nbsp;     *
&nbsp;     * @param text text to print after field only if field is printed
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if no field exists to append to
&nbsp;     * @see #appendPrefix
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSuffix(String text) {
<b class="nc">&nbsp;        if (text == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return appendSuffix(new SimpleAffix(text));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a field suffix which applies only to the last appended field. If
&nbsp;     * the field is not printed, neither is the suffix.
&nbsp;     * &lt;p&gt;
&nbsp;     * During parsing, the singular and plural versions are accepted whether or
&nbsp;     * not the actual value matches plurality.
&nbsp;     *
&nbsp;     * @param singularText text to print if field value is one
&nbsp;     * @param pluralText text to print if field value is not one
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if no field exists to append to
&nbsp;     * @see #appendPrefix
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSuffix(String singularText,
&nbsp;                                               String pluralText) {
<b class="nc">&nbsp;        if (singularText == null || pluralText == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return appendSuffix(new PluralAffix(singularText, pluralText));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a field suffix which applies only to the last appended field. If
&nbsp;     * the field is not printed, neither is the suffix.
&nbsp;     *
&nbsp;     * @param suffix custom suffix
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if no field exists to append to
&nbsp;     * @see #appendPrefix
&nbsp;     */
&nbsp;    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {
&nbsp;        final Object originalPrinter;
&nbsp;        final Object originalParser;
<b class="nc">&nbsp;        if (iElementPairs.size() &gt; 0) {</b>
<b class="nc">&nbsp;            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);</b>
<b class="nc">&nbsp;            originalParser = iElementPairs.get(iElementPairs.size() - 1);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            originalPrinter = null;</b>
<b class="nc">&nbsp;            originalParser = null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (originalPrinter == null || originalParser == null ||</b>
&nbsp;                originalPrinter != originalParser ||
&nbsp;                !(originalPrinter instanceof FieldFormatter)) {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;No field to apply suffix to&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        clearPrefix();</b>
<b class="nc">&nbsp;        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);</b>
<b class="nc">&nbsp;        iElementPairs.set(iElementPairs.size() - 2, newField);</b>
<b class="nc">&nbsp;        iElementPairs.set(iElementPairs.size() - 1, newField);</b>
<b class="nc">&nbsp;        iFieldFormatters[newField.getFieldType()] = newField;</b>
&nbsp;        
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Append a separator, which is output if fields are printed both before
&nbsp;     * and after the separator.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;).appendHours()&lt;/code&gt;
&nbsp;     * will only output the comma if both the days and hours fields are output.
&nbsp;     * &lt;p&gt;
&nbsp;     * The text will be parsed case-insensitively.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: appending a separator discontinues any further work on the latest
&nbsp;     * appended field.
&nbsp;     *
&nbsp;     * @param text  the text to use as a separator
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if this separator follows a previous one
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeparator(String text) {
<b class="nc">&nbsp;        return appendSeparator(text, text, null, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a separator, which is output only if fields are printed after the separator.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example,
&nbsp;     * &lt;code&gt;builder.appendDays().appendSeparatorIfFieldsAfter(&quot;,&quot;).appendHours()&lt;/code&gt;
&nbsp;     * will only output the comma if the hours fields is output.
&nbsp;     * &lt;p&gt;
&nbsp;     * The text will be parsed case-insensitively.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: appending a separator discontinues any further work on the latest
&nbsp;     * appended field.
&nbsp;     *
&nbsp;     * @param text  the text to use as a separator
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if this separator follows a previous one
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
<b class="nc">&nbsp;        return appendSeparator(text, text, null, false, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a separator, which is output only if fields are printed before the separator.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example,
&nbsp;     * &lt;code&gt;builder.appendDays().appendSeparatorIfFieldsBefore(&quot;,&quot;).appendHours()&lt;/code&gt;
&nbsp;     * will only output the comma if the days fields is output.
&nbsp;     * &lt;p&gt;
&nbsp;     * The text will be parsed case-insensitively.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: appending a separator discontinues any further work on the latest
&nbsp;     * appended field.
&nbsp;     *
&nbsp;     * @param text  the text to use as a separator
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if this separator follows a previous one
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
<b class="nc">&nbsp;        return appendSeparator(text, text, null, true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a separator, which is output if fields are printed both before
&nbsp;     * and after the separator.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method changes the separator depending on whether it is the last separator
&nbsp;     * to be output.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendHours().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendMinutes()&lt;/code&gt;
&nbsp;     * will output &#39;1,2&amp;3&#39; if all three fields are output, &#39;1&amp;2&#39; if two fields are output
&nbsp;     * and &#39;1&#39; if just one field is output.
&nbsp;     * &lt;p&gt;
&nbsp;     * The text will be parsed case-insensitively.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: appending a separator discontinues any further work on the latest
&nbsp;     * appended field.
&nbsp;     *
&nbsp;     * @param text  the text to use as a separator
&nbsp;     * @param finalText  the text used used if this is the final separator to be printed
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if this separator follows a previous one
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {
<b class="nc">&nbsp;        return appendSeparator(text, finalText, null, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Append a separator, which is output if fields are printed both before
&nbsp;     * and after the separator.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method changes the separator depending on whether it is the last separator
&nbsp;     * to be output.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendHours().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendMinutes()&lt;/code&gt;
&nbsp;     * will output &#39;1,2&amp;3&#39; if all three fields are output, &#39;1&amp;2&#39; if two fields are output
&nbsp;     * and &#39;1&#39; if just one field is output.
&nbsp;     * &lt;p&gt;
&nbsp;     * The text will be parsed case-insensitively.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: appending a separator discontinues any further work on the latest
&nbsp;     * appended field.
&nbsp;     *
&nbsp;     * @param text  the text to use as a separator
&nbsp;     * @param finalText  the text used used if this is the final separator to be printed
&nbsp;     * @param variants  set of text values which are also acceptable when parsed
&nbsp;     * @return this PeriodFormatterBuilder
&nbsp;     * @throws IllegalStateException if this separator follows a previous one
&nbsp;     */
&nbsp;    public PeriodFormatterBuilder appendSeparator(String text, String finalText,
&nbsp;                                                  String[] variants) {
<b class="nc">&nbsp;        return appendSeparator(text, finalText, variants, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    private PeriodFormatterBuilder appendSeparator(String text, String finalText,
&nbsp;                                                   String[] variants,
&nbsp;                                                   boolean useBefore, boolean useAfter) {
<b class="nc">&nbsp;        if (text == null || finalText == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        clearPrefix();</b>
&nbsp;        
&nbsp;        // optimise zero formatter case
<b class="nc">&nbsp;        List&lt;Object&gt; pairs = iElementPairs;</b>
<b class="nc">&nbsp;        if (pairs.size() == 0) {</b>
<b class="nc">&nbsp;            if (useAfter &amp;&amp; useBefore == false) {</b>
<b class="nc">&nbsp;                Separator separator = new Separator(</b>
&nbsp;                        text, finalText, variants,
&nbsp;                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);
<b class="nc">&nbsp;                append0(separator, separator);</b>
&nbsp;            }
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // find the last separator added
&nbsp;        int i;
<b class="nc">&nbsp;        Separator lastSeparator = null;</b>
<b class="nc">&nbsp;        for (i=pairs.size(); --i&gt;=0; ) {</b>
<b class="nc">&nbsp;            if (pairs.get(i) instanceof Separator) {</b>
<b class="nc">&nbsp;                lastSeparator = (Separator) pairs.get(i);</b>
<b class="nc">&nbsp;                pairs = pairs.subList(i + 1, pairs.size());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            i--;  // element pairs</b>
&nbsp;        }
&nbsp;        
&nbsp;        // merge formatters
<b class="nc">&nbsp;        if (lastSeparator != null &amp;&amp; pairs.size() == 0) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot have two adjacent separators&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Object[] comp = createComposite(pairs);</b>
<b class="nc">&nbsp;            pairs.clear();</b>
<b class="nc">&nbsp;            Separator separator = new Separator(</b>
&nbsp;                    text, finalText, variants,
&nbsp;                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],
&nbsp;                    useBefore, useAfter);
<b class="nc">&nbsp;            pairs.add(separator);</b>
<b class="nc">&nbsp;            pairs.add(separator);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    private void clearPrefix() throws IllegalStateException {
<b class="nc">&nbsp;        if (iPrefix != null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Prefix not followed by field&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        iPrefix = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {
<b class="nc">&nbsp;        iElementPairs.add(printer);</b>
<b class="nc">&nbsp;        iElementPairs.add(parser);</b>
<b class="nc">&nbsp;        iNotPrinter |= (printer == null);</b>
<b class="nc">&nbsp;        iNotParser |= (parser == null);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    private static PeriodFormatter toFormatter(List&lt;Object&gt; elementPairs, boolean notPrinter, boolean notParser) {
<b class="nc">&nbsp;        if (notPrinter &amp;&amp; notParser) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Builder has created neither a printer nor a parser&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int size = elementPairs.size();</b>
<b class="nc">&nbsp;        if (size &gt;= 2 &amp;&amp; elementPairs.get(0) instanceof Separator) {</b>
<b class="nc">&nbsp;            Separator sep = (Separator) elementPairs.get(0);</b>
<b class="nc">&nbsp;            if (sep.iAfterParser == null &amp;&amp; sep.iAfterPrinter == null) {</b>
<b class="nc">&nbsp;                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);</b>
<b class="nc">&nbsp;                sep = sep.finish(f.getPrinter(), f.getParser());</b>
<b class="nc">&nbsp;                return new PeriodFormatter(sep, sep);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Object[] comp = createComposite(elementPairs);</b>
<b class="nc">&nbsp;        if (notPrinter) {</b>
<b class="nc">&nbsp;            return new PeriodFormatter(null, (PeriodParser) comp[1]);</b>
<b class="nc">&nbsp;        } else if (notParser) {</b>
<b class="nc">&nbsp;            return new PeriodFormatter((PeriodPrinter) comp[0], null);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Object[] createComposite(List&lt;Object&gt; elementPairs) {
<b class="nc">&nbsp;        switch (elementPairs.size()) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                return new Object[] {Literal.EMPTY, Literal.EMPTY};</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                return new Object[] {elementPairs.get(0), elementPairs.get(1)};</b>
&nbsp;            default:
<b class="nc">&nbsp;                Composite comp = new Composite(elementPairs);</b>
<b class="nc">&nbsp;                return new Object[] {comp, comp};</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Defines a formatted field&#39;s prefix or suffix text.
&nbsp;     * This can be used for fields such as &#39;n hours&#39; or &#39;nH&#39; or &#39;Hour:n&#39;.
&nbsp;     */
&nbsp;    static interface PeriodFieldAffix {
&nbsp;        int calculatePrintedLength(int value);
&nbsp;        
&nbsp;        void printTo(StringBuffer buf, int value);
&nbsp;        
&nbsp;        void printTo(Writer out, int value) throws IOException;
&nbsp;        
&nbsp;        /**
&nbsp;         * @return new position after parsing affix, or ~position of failure
&nbsp;         */
&nbsp;        int parse(String periodStr, int position);
&nbsp;
&nbsp;        /**
&nbsp;         * @return position where affix starts, or original ~position if not found
&nbsp;         */
&nbsp;        int scan(String periodStr, int position);
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Implements an affix where the text does not vary by the amount.
&nbsp;     */
&nbsp;    static class SimpleAffix implements PeriodFieldAffix {
&nbsp;        private final String iText;
&nbsp;
<b class="nc">&nbsp;        SimpleAffix(String text) {</b>
<b class="nc">&nbsp;            iText = text;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(int value) {
<b class="nc">&nbsp;            return iText.length();</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, int value) {
<b class="nc">&nbsp;            buf.append(iText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, int value) throws IOException {
<b class="nc">&nbsp;            out.write(iText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parse(String periodStr, int position) {
<b class="nc">&nbsp;            String text = iText;</b>
<b class="nc">&nbsp;            int textLength = text.length();</b>
<b class="nc">&nbsp;            if (periodStr.regionMatches(true, position, text, 0, textLength)) {</b>
<b class="nc">&nbsp;                return position + textLength;</b>
&nbsp;            }
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int scan(String periodStr, final int position) {
<b class="nc">&nbsp;            String text = iText;</b>
<b class="nc">&nbsp;            int textLength = text.length();</b>
<b class="nc">&nbsp;            int sourceLength = periodStr.length();</b>
&nbsp;            search:
<b class="nc">&nbsp;            for (int pos = position; pos &lt; sourceLength; pos++) {</b>
<b class="nc">&nbsp;                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {</b>
<b class="nc">&nbsp;                    return pos;</b>
&nbsp;                }
&nbsp;                // Only allow number characters to be skipped in search of suffix.
<b class="nc">&nbsp;                switch (periodStr.charAt(pos)) {</b>
&nbsp;                case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
&nbsp;                case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
&nbsp;                case &#39;.&#39;: case &#39;,&#39;: case &#39;+&#39;: case &#39;-&#39;:
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    break search;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Implements an affix where the text varies by the amount of the field.
&nbsp;     * Only singular (1) and plural (not 1) are supported.
&nbsp;     */
&nbsp;    static class PluralAffix implements PeriodFieldAffix {
&nbsp;        private final String iSingularText;
&nbsp;        private final String iPluralText;
&nbsp;
<b class="nc">&nbsp;        PluralAffix(String singularText, String pluralText) {</b>
<b class="nc">&nbsp;            iSingularText = singularText;</b>
<b class="nc">&nbsp;            iPluralText = pluralText;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(int value) {
<b class="nc">&nbsp;            return (value == 1 ? iSingularText : iPluralText).length();</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, int value) {
<b class="nc">&nbsp;            buf.append(value == 1 ? iSingularText : iPluralText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, int value) throws IOException {
<b class="nc">&nbsp;            out.write(value == 1 ? iSingularText : iPluralText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parse(String periodStr, int position) {
<b class="nc">&nbsp;            String text1 = iPluralText;</b>
<b class="nc">&nbsp;            String text2 = iSingularText; </b>
&nbsp;
<b class="nc">&nbsp;            if (text1.length() &lt; text2.length()) {</b>
&nbsp;                // Swap in order to match longer one first.
<b class="nc">&nbsp;                String temp = text1;</b>
<b class="nc">&nbsp;                text1 = text2;</b>
<b class="nc">&nbsp;                text2 = temp;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (periodStr.regionMatches</b>
<b class="nc">&nbsp;                (true, position, text1, 0, text1.length())) {</b>
<b class="nc">&nbsp;                return position + text1.length();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (periodStr.regionMatches</b>
<b class="nc">&nbsp;                (true, position, text2, 0, text2.length())) {</b>
<b class="nc">&nbsp;                return position + text2.length();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int scan(String periodStr, final int position) {
<b class="nc">&nbsp;            String text1 = iPluralText;</b>
<b class="nc">&nbsp;            String text2 = iSingularText; </b>
&nbsp;
<b class="nc">&nbsp;            if (text1.length() &lt; text2.length()) {</b>
&nbsp;                // Swap in order to match longer one first.
<b class="nc">&nbsp;                String temp = text1;</b>
<b class="nc">&nbsp;                text1 = text2;</b>
<b class="nc">&nbsp;                text2 = temp;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int textLength1 = text1.length();</b>
<b class="nc">&nbsp;            int textLength2 = text2.length();</b>
&nbsp;
<b class="nc">&nbsp;            int sourceLength = periodStr.length();</b>
<b class="nc">&nbsp;            for (int pos = position; pos &lt; sourceLength; pos++) {</b>
<b class="nc">&nbsp;                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {</b>
<b class="nc">&nbsp;                    return pos;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {</b>
<b class="nc">&nbsp;                    return pos;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Builds a composite affix by merging two other affix implementations.
&nbsp;     */
&nbsp;    static class CompositeAffix implements PeriodFieldAffix {
&nbsp;        private final PeriodFieldAffix iLeft;
&nbsp;        private final PeriodFieldAffix iRight;
&nbsp;
<b class="nc">&nbsp;        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {</b>
<b class="nc">&nbsp;            iLeft = left;</b>
<b class="nc">&nbsp;            iRight = right;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(int value) {
<b class="nc">&nbsp;            return iLeft.calculatePrintedLength(value)</b>
<b class="nc">&nbsp;                + iRight.calculatePrintedLength(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, int value) {
<b class="nc">&nbsp;            iLeft.printTo(buf, value);</b>
<b class="nc">&nbsp;            iRight.printTo(buf, value);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, int value) throws IOException {
<b class="nc">&nbsp;            iLeft.printTo(out, value);</b>
<b class="nc">&nbsp;            iRight.printTo(out, value);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parse(String periodStr, int position) {
<b class="nc">&nbsp;            position = iLeft.parse(periodStr, position);</b>
<b class="nc">&nbsp;            if (position &gt;= 0) {</b>
<b class="nc">&nbsp;                position = iRight.parse(periodStr, position);</b>
&nbsp;            }
<b class="nc">&nbsp;            return position;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int scan(String periodStr, final int position) {
<b class="nc">&nbsp;            int pos = iLeft.scan(periodStr, position);</b>
<b class="nc">&nbsp;            if (pos &gt;= 0) {</b>
<b class="nc">&nbsp;                return iRight.scan(periodStr, pos);</b>
&nbsp;            }
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Formats the numeric value of a field, potentially with prefix/suffix.
&nbsp;     */
&nbsp;    static class FieldFormatter
&nbsp;            implements PeriodPrinter, PeriodParser {
&nbsp;        private final int iMinPrintedDigits;
&nbsp;        private final int iPrintZeroSetting;
&nbsp;        private final int iMaxParsedDigits;
&nbsp;        private final boolean iRejectSignedValues;
&nbsp;        
&nbsp;        /** The index of the field type, 0=year, etc. */
&nbsp;        private final int iFieldType;
&nbsp;        /**
&nbsp;         * The array of the latest formatter added for each type.
&nbsp;         * This is shared between all the field formatters in a formatter.
&nbsp;         */
&nbsp;        private final FieldFormatter[] iFieldFormatters;
&nbsp;        
&nbsp;        private final PeriodFieldAffix iPrefix;
&nbsp;        private final PeriodFieldAffix iSuffix;
&nbsp;
&nbsp;        FieldFormatter(int minPrintedDigits, int printZeroSetting,
&nbsp;                       int maxParsedDigits, boolean rejectSignedValues,
&nbsp;                       int fieldType, FieldFormatter[] fieldFormatters,
<b class="nc">&nbsp;                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {</b>
<b class="nc">&nbsp;            iMinPrintedDigits = minPrintedDigits;</b>
<b class="nc">&nbsp;            iPrintZeroSetting = printZeroSetting;</b>
<b class="nc">&nbsp;            iMaxParsedDigits = maxParsedDigits;</b>
<b class="nc">&nbsp;            iRejectSignedValues = rejectSignedValues;</b>
<b class="nc">&nbsp;            iFieldType = fieldType;</b>
<b class="nc">&nbsp;            iFieldFormatters = fieldFormatters;</b>
<b class="nc">&nbsp;            iPrefix = prefix;</b>
<b class="nc">&nbsp;            iSuffix = suffix;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {</b>
<b class="nc">&nbsp;            iMinPrintedDigits = field.iMinPrintedDigits;</b>
<b class="nc">&nbsp;            iPrintZeroSetting = field.iPrintZeroSetting;</b>
<b class="nc">&nbsp;            iMaxParsedDigits = field.iMaxParsedDigits;</b>
<b class="nc">&nbsp;            iRejectSignedValues = field.iRejectSignedValues;</b>
<b class="nc">&nbsp;            iFieldType = field.iFieldType;</b>
<b class="nc">&nbsp;            iFieldFormatters = field.iFieldFormatters;</b>
<b class="nc">&nbsp;            iPrefix = field.iPrefix;</b>
<b class="nc">&nbsp;            if (field.iSuffix != null) {</b>
<b class="nc">&nbsp;                suffix = new CompositeAffix(field.iSuffix, suffix);</b>
&nbsp;            }
<b class="nc">&nbsp;            iSuffix = suffix;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<b class="nc">&nbsp;            if (stopAt &lt;= 0) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {</b>
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            long valueLong = getFieldValue(period);</b>
<b class="nc">&nbsp;            if (valueLong == Long.MAX_VALUE) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);</b>
<b class="nc">&nbsp;            if (iFieldType &gt;= SECONDS_MILLIS) {</b>
&nbsp;                // valueLong contains the seconds and millis fields
&nbsp;                // the minimum output is 0.000, which is 4 or 5 digits with a negative
<b class="nc">&nbsp;                sum = (valueLong &lt; 0 ? Math.max(sum, 5) : Math.max(sum, 4));</b>
&nbsp;                // plus one for the decimal point
<b class="nc">&nbsp;                sum++;</b>
<b class="nc">&nbsp;                if (iFieldType == SECONDS_OPTIONAL_MILLIS &amp;&amp;</b>
<b class="nc">&nbsp;                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {</b>
<b class="nc">&nbsp;                    sum -= 4; // remove three digits and decimal point</b>
&nbsp;                }
&nbsp;                // reset valueLong to refer to the seconds part for the prefic/suffix calculation
<b class="nc">&nbsp;                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;</b>
&nbsp;            }
<b class="nc">&nbsp;            int value = (int) valueLong;</b>
&nbsp;
<b class="nc">&nbsp;            if (iPrefix != null) {</b>
<b class="nc">&nbsp;                sum += iPrefix.calculatePrintedLength(value);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iSuffix != null) {</b>
<b class="nc">&nbsp;                sum += iSuffix.calculatePrintedLength(value);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return sum;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            long valueLong = getFieldValue(period);</b>
<b class="nc">&nbsp;            if (valueLong == Long.MAX_VALUE) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            int value = (int) valueLong;</b>
<b class="nc">&nbsp;            if (iFieldType &gt;= SECONDS_MILLIS) {</b>
<b class="nc">&nbsp;                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (iPrefix != null) {</b>
<b class="nc">&nbsp;                iPrefix.printTo(buf, value);</b>
&nbsp;            }
<b class="nc">&nbsp;            int bufLen = buf.length();</b>
<b class="nc">&nbsp;            int minDigits = iMinPrintedDigits;</b>
<b class="nc">&nbsp;            if (minDigits &lt;= 1) {</b>
<b class="nc">&nbsp;                FormatUtils.appendUnpaddedInteger(buf, value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.appendPaddedInteger(buf, value, minDigits);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iFieldType &gt;= SECONDS_MILLIS) {</b>
<b class="nc">&nbsp;                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);</b>
<b class="nc">&nbsp;                if (iFieldType == SECONDS_MILLIS || dp &gt; 0) {</b>
<b class="nc">&nbsp;                    if (valueLong &lt; 0 &amp;&amp; valueLong &gt; -DateTimeConstants.MILLIS_PER_SECOND) {</b>
<b class="nc">&nbsp;                        buf.insert(bufLen, &#39;-&#39;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    buf.append(&#39;.&#39;);</b>
<b class="nc">&nbsp;                    FormatUtils.appendPaddedInteger(buf, dp, 3);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (iSuffix != null) {</b>
<b class="nc">&nbsp;                iSuffix.printTo(buf, value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<b class="nc">&nbsp;            long valueLong = getFieldValue(period);</b>
<b class="nc">&nbsp;            if (valueLong == Long.MAX_VALUE) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            int value = (int) valueLong;</b>
<b class="nc">&nbsp;            if (iFieldType &gt;= SECONDS_MILLIS) {</b>
<b class="nc">&nbsp;                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (iPrefix != null) {</b>
<b class="nc">&nbsp;                iPrefix.printTo(out, value);</b>
&nbsp;            }
<b class="nc">&nbsp;            int minDigits = iMinPrintedDigits;</b>
<b class="nc">&nbsp;            if (minDigits &lt;= 1) {</b>
<b class="nc">&nbsp;                FormatUtils.writeUnpaddedInteger(out, value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                FormatUtils.writePaddedInteger(out, value, minDigits);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iFieldType &gt;= SECONDS_MILLIS) {</b>
<b class="nc">&nbsp;                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);</b>
<b class="nc">&nbsp;                if (iFieldType == SECONDS_MILLIS || dp &gt; 0) {</b>
<b class="nc">&nbsp;                    out.write(&#39;.&#39;);</b>
<b class="nc">&nbsp;                    FormatUtils.writePaddedInteger(out, dp, 3);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (iSuffix != null) {</b>
<b class="nc">&nbsp;                iSuffix.printTo(out, value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(
&nbsp;                ReadWritablePeriod period, String text, 
&nbsp;                int position, Locale locale) {
&nbsp;
<b class="nc">&nbsp;            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);</b>
&nbsp;
&nbsp;            // Shortcut test.
<b class="nc">&nbsp;            if (position &gt;= text.length()) {</b>
<b class="nc">&nbsp;                return mustParse ? ~position : position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (iPrefix != null) {</b>
<b class="nc">&nbsp;                position = iPrefix.parse(text, position);</b>
<b class="nc">&nbsp;                if (position &gt;= 0) {</b>
&nbsp;                    // If prefix is found, then the parse must finish.
<b class="nc">&nbsp;                    mustParse = true;</b>
&nbsp;                } else {
&nbsp;                    // Prefix not found, so bail.
<b class="nc">&nbsp;                    if (!mustParse) {</b>
&nbsp;                        // It&#39;s okay because parsing of this field is not
&nbsp;                        // required. Don&#39;t return an error. Fields down the
&nbsp;                        // chain can continue on, trying to parse.
<b class="nc">&nbsp;                        return ~position;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return position;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int suffixPos = -1;</b>
<b class="nc">&nbsp;            if (iSuffix != null &amp;&amp; !mustParse) {</b>
&nbsp;                // Pre-scan the suffix, to help determine if this field must be
&nbsp;                // parsed.
<b class="nc">&nbsp;                suffixPos = iSuffix.scan(text, position);</b>
<b class="nc">&nbsp;                if (suffixPos &gt;= 0) {</b>
&nbsp;                    // If suffix is found, then parse must finish.
<b class="nc">&nbsp;                    mustParse = true;</b>
&nbsp;                } else {
&nbsp;                    // Suffix not found, so bail.
<b class="nc">&nbsp;                    if (!mustParse) {</b>
&nbsp;                        // It&#39;s okay because parsing of this field is not
&nbsp;                        // required. Don&#39;t return an error. Fields down the
&nbsp;                        // chain can continue on, trying to parse.
<b class="nc">&nbsp;                        return ~suffixPos;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return suffixPos;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!mustParse &amp;&amp; !isSupported(period.getPeriodType(), iFieldType)) {</b>
&nbsp;                // If parsing is not required and the field is not supported,
&nbsp;                // exit gracefully so that another parser can continue on.
<b class="nc">&nbsp;                return position;</b>
&nbsp;            }
&nbsp;
&nbsp;            int limit;
<b class="nc">&nbsp;            if (suffixPos &gt; 0) {</b>
<b class="nc">&nbsp;                limit = Math.min(iMaxParsedDigits, suffixPos - position);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                limit = Math.min(iMaxParsedDigits, text.length() - position);</b>
&nbsp;            }
&nbsp;
&nbsp;            // validate input number
<b class="nc">&nbsp;            int length = 0;</b>
<b class="nc">&nbsp;            int fractPos = -1;</b>
<b class="nc">&nbsp;            boolean hasDigits = false;</b>
<b class="nc">&nbsp;            while (length &lt; limit) {</b>
<b class="nc">&nbsp;                char c = text.charAt(position + length);</b>
&nbsp;                // leading sign
<b class="nc">&nbsp;                if (length == 0 &amp;&amp; (c == &#39;-&#39; || c == &#39;+&#39;) &amp;&amp; !iRejectSignedValues) {</b>
<b class="nc">&nbsp;                    boolean negative = c == &#39;-&#39;;</b>
&nbsp;
&nbsp;                    // Next character must be a digit.
<b class="nc">&nbsp;                    if (length + 1 &gt;= limit || </b>
<b class="nc">&nbsp;                        (c = text.charAt(position + length + 1)) &lt; &#39;0&#39; || c &gt; &#39;9&#39;)</b>
&nbsp;                    {
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (negative) {</b>
<b class="nc">&nbsp;                        length++;</b>
&nbsp;                    } else {
&nbsp;                        // Skip the &#39;+&#39; for parseInt to succeed.
<b class="nc">&nbsp;                        position++;</b>
&nbsp;                    }
&nbsp;                    // Expand the limit to disregard the sign character.
<b class="nc">&nbsp;                    limit = Math.min(limit + 1, text.length() - position);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // main number
<b class="nc">&nbsp;                if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;                    hasDigits = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if ((c == &#39;.&#39; || c == &#39;,&#39;)</b>
&nbsp;                         &amp;&amp; (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {
<b class="nc">&nbsp;                        if (fractPos &gt;= 0) {</b>
&nbsp;                            // can&#39;t have two decimals
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        fractPos = position + length + 1;</b>
&nbsp;                        // Expand the limit to disregard the decimal point.
<b class="nc">&nbsp;                        limit = Math.min(limit + 1, text.length() - position);</b>
&nbsp;                    } else {
&nbsp;                        break;
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                length++;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (!hasDigits) {</b>
<b class="nc">&nbsp;                return ~position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (suffixPos &gt;= 0 &amp;&amp; position + length != suffixPos) {</b>
&nbsp;                // If there are additional non-digit characters before the
&nbsp;                // suffix is reached, then assume that the suffix found belongs
&nbsp;                // to a field not yet reached. Return original position so that
&nbsp;                // another parser can continue on.
<b class="nc">&nbsp;                return position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (iFieldType != SECONDS_MILLIS &amp;&amp; iFieldType != SECONDS_OPTIONAL_MILLIS) {</b>
&nbsp;                // Handle common case.
<b class="nc">&nbsp;                setFieldValue(period, iFieldType, parseInt(text, position, length));</b>
<b class="nc">&nbsp;            } else if (fractPos &lt; 0) {</b>
<b class="nc">&nbsp;                setFieldValue(period, SECONDS, parseInt(text, position, length));</b>
<b class="nc">&nbsp;                setFieldValue(period, MILLIS, 0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                int wholeValue = parseInt(text, position, fractPos - position - 1);</b>
<b class="nc">&nbsp;                setFieldValue(period, SECONDS, wholeValue);</b>
&nbsp;
<b class="nc">&nbsp;                int fractLen = position + length - fractPos;</b>
&nbsp;                int fractValue;
<b class="nc">&nbsp;                if (fractLen &lt;= 0) {</b>
<b class="nc">&nbsp;                    fractValue = 0;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (fractLen &gt;= 3) {</b>
<b class="nc">&nbsp;                        fractValue = parseInt(text, fractPos, 3);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        fractValue = parseInt(text, fractPos, fractLen);</b>
<b class="nc">&nbsp;                        if (fractLen == 1) {</b>
<b class="nc">&nbsp;                            fractValue *= 100;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            fractValue *= 10;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (wholeValue &lt; 0) {</b>
<b class="nc">&nbsp;                        fractValue = -fractValue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                setFieldValue(period, MILLIS, fractValue);</b>
&nbsp;            }
&nbsp;                
<b class="nc">&nbsp;            position += length;</b>
&nbsp;
<b class="nc">&nbsp;            if (position &gt;= 0 &amp;&amp; iSuffix != null) {</b>
<b class="nc">&nbsp;                position = iSuffix.parse(text, position);</b>
&nbsp;            }
&nbsp;                
<b class="nc">&nbsp;            return position;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param text text to parse
&nbsp;         * @param position position in text
&nbsp;         * @param length exact count of characters to parse
&nbsp;         * @return parsed int value
&nbsp;         */
&nbsp;        private int parseInt(String text, int position, int length) {
<b class="nc">&nbsp;            if (length &gt;= 10) {</b>
&nbsp;                // Since value may exceed max, use stock parser which checks for this.
<b class="nc">&nbsp;                return Integer.parseInt(text.substring(position, position + length));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (length &lt;= 0) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            int value = text.charAt(position++);</b>
<b class="nc">&nbsp;            length--;</b>
&nbsp;            boolean negative;
<b class="nc">&nbsp;            if (value == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                if (--length &lt; 0) {</b>
<b class="nc">&nbsp;                    return 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                negative = true;</b>
<b class="nc">&nbsp;                value = text.charAt(position++);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                negative = false;</b>
&nbsp;            }
<b class="nc">&nbsp;            value -= &#39;0&#39;;</b>
<b class="nc">&nbsp;            while (length-- &gt; 0) {</b>
<b class="nc">&nbsp;                value = ((value &lt;&lt; 3) + (value &lt;&lt; 1)) + text.charAt(position++) - &#39;0&#39;;</b>
&nbsp;            }
<b class="nc">&nbsp;            return negative ? -value : value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @return Long.MAX_VALUE if nothing to print, otherwise value
&nbsp;         */
&nbsp;        long getFieldValue(ReadablePeriod period) {
&nbsp;            PeriodType type;
<b class="nc">&nbsp;            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {</b>
<b class="nc">&nbsp;                type = null; // Don&#39;t need to check if supported.</b>
&nbsp;            } else {
<b class="nc">&nbsp;                type = period.getPeriodType();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (type != null &amp;&amp; isSupported(type, iFieldType) == false) {</b>
<b class="nc">&nbsp;                return Long.MAX_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            long value;
&nbsp;
<b class="nc">&nbsp;            switch (iFieldType) {</b>
&nbsp;            default:
<b class="nc">&nbsp;                return Long.MAX_VALUE;</b>
&nbsp;            case YEARS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.years());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MONTHS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.months());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WEEKS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.weeks());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case DAYS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.days());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case HOURS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.hours());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MINUTES:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.minutes());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SECONDS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.seconds());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MILLIS:
<b class="nc">&nbsp;                value = period.get(DurationFieldType.millis());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SECONDS_MILLIS: // drop through
&nbsp;            case SECONDS_OPTIONAL_MILLIS:
<b class="nc">&nbsp;                int seconds = period.get(DurationFieldType.seconds());</b>
<b class="nc">&nbsp;                int millis = period.get(DurationFieldType.millis());</b>
<b class="nc">&nbsp;                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;</b>
&nbsp;                break;
&nbsp;            }
&nbsp;
&nbsp;            // determine if period is zero and this is the last field
<b class="nc">&nbsp;            if (value == 0) {</b>
<b class="nc">&nbsp;                switch (iPrintZeroSetting) {</b>
&nbsp;                case PRINT_ZERO_NEVER:
<b class="nc">&nbsp;                    return Long.MAX_VALUE;</b>
&nbsp;                case PRINT_ZERO_RARELY_LAST:
<b class="nc">&nbsp;                    if (isZero(period) &amp;&amp; iFieldFormatters[iFieldType] == this) {</b>
<b class="nc">&nbsp;                        for (int i = iFieldType + 1; i &lt;= MAX_FIELD; i++) {</b>
<b class="nc">&nbsp;                            if (isSupported(type, i) &amp;&amp; iFieldFormatters[i] != null) {</b>
<b class="nc">&nbsp;                                return Long.MAX_VALUE;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        return Long.MAX_VALUE;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case PRINT_ZERO_RARELY_FIRST:
<b class="nc">&nbsp;                    if (isZero(period) &amp;&amp; iFieldFormatters[iFieldType] == this) {</b>
<b class="nc">&nbsp;                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK</b>
<b class="nc">&nbsp;                        i--;                              // see bug 1660490</b>
<b class="nc">&nbsp;                        for (; i &gt;= 0 &amp;&amp; i &lt;= MAX_FIELD; i--) {</b>
<b class="nc">&nbsp;                            if (isSupported(type, i) &amp;&amp; iFieldFormatters[i] != null) {</b>
<b class="nc">&nbsp;                                return Long.MAX_VALUE;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        return Long.MAX_VALUE;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean isZero(ReadablePeriod period) {
<b class="nc">&nbsp;            for (int i = 0, isize = period.size(); i &lt; isize; i++) {</b>
<b class="nc">&nbsp;                if (period.getValue(i) != 0) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean isSupported(PeriodType type, int field) {
<b class="nc">&nbsp;            switch (field) {</b>
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case YEARS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.years());</b>
&nbsp;            case MONTHS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.months());</b>
&nbsp;            case WEEKS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.weeks());</b>
&nbsp;            case DAYS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.days());</b>
&nbsp;            case HOURS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.hours());</b>
&nbsp;            case MINUTES:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.minutes());</b>
&nbsp;            case SECONDS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.seconds());</b>
&nbsp;            case MILLIS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.millis());</b>
&nbsp;            case SECONDS_MILLIS: // drop through
&nbsp;            case SECONDS_OPTIONAL_MILLIS:
<b class="nc">&nbsp;                return type.isSupported(DurationFieldType.seconds()) ||</b>
<b class="nc">&nbsp;                       type.isSupported(DurationFieldType.millis());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        void setFieldValue(ReadWritablePeriod period, int field, int value) {
<b class="nc">&nbsp;            switch (field) {</b>
&nbsp;            default:
<b class="nc">&nbsp;                break;</b>
&nbsp;            case YEARS:
<b class="nc">&nbsp;                period.setYears(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MONTHS:
<b class="nc">&nbsp;                period.setMonths(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WEEKS:
<b class="nc">&nbsp;                period.setWeeks(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case DAYS:
<b class="nc">&nbsp;                period.setDays(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case HOURS:
<b class="nc">&nbsp;                period.setHours(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MINUTES:
<b class="nc">&nbsp;                period.setMinutes(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SECONDS:
<b class="nc">&nbsp;                period.setSeconds(value);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MILLIS:
<b class="nc">&nbsp;                period.setMillis(value);</b>
&nbsp;                break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int getFieldType() {
<b class="nc">&nbsp;            return iFieldType;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Handles a simple literal piece of text.
&nbsp;     */
&nbsp;    static class Literal
&nbsp;            implements PeriodPrinter, PeriodParser {
<b class="nc">&nbsp;        static final Literal EMPTY = new Literal(&quot;&quot;);</b>
&nbsp;        private final String iText;
&nbsp;
<b class="nc">&nbsp;        Literal(String text) {</b>
<b class="nc">&nbsp;            iText = text;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            return iText.length();</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            buf.append(iText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<b class="nc">&nbsp;            out.write(iText);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(
&nbsp;                ReadWritablePeriod period, String periodStr,
&nbsp;                int position, Locale locale) {
<b class="nc">&nbsp;            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {</b>
<b class="nc">&nbsp;                return position + iText.length();</b>
&nbsp;            }
<b class="nc">&nbsp;            return ~position;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Handles a separator, that splits the fields into multiple parts.
&nbsp;     * For example, the &#39;T&#39; in the ISO8601 standard.
&nbsp;     */
<b class="nc">&nbsp;    static class Separator</b>
&nbsp;            implements PeriodPrinter, PeriodParser {
&nbsp;        private final String iText;
&nbsp;        private final String iFinalText;
&nbsp;        private final String[] iParsedForms;
&nbsp;
&nbsp;        private final boolean iUseBefore;
&nbsp;        private final boolean iUseAfter;
&nbsp;
&nbsp;        private final PeriodPrinter iBeforePrinter;
&nbsp;        private volatile PeriodPrinter iAfterPrinter;
&nbsp;        private final PeriodParser iBeforeParser;
&nbsp;        private volatile PeriodParser iAfterParser;
&nbsp;
&nbsp;        Separator(String text, String finalText, String[] variants,
&nbsp;                PeriodPrinter beforePrinter, PeriodParser beforeParser,
<b class="nc">&nbsp;                boolean useBefore, boolean useAfter) {</b>
<b class="nc">&nbsp;            iText = text;</b>
<b class="nc">&nbsp;            iFinalText = finalText;</b>
&nbsp;
<b class="nc">&nbsp;            if ((finalText == null || text.equals(finalText)) &amp;&amp;</b>
&nbsp;                (variants == null || variants.length == 0)) {
&nbsp;
<b class="nc">&nbsp;                iParsedForms = new String[] {text};</b>
&nbsp;            } else {
&nbsp;                // Filter and reverse sort the parsed forms.
<b class="nc">&nbsp;                TreeSet&lt;String&gt; parsedSet = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</b>
<b class="nc">&nbsp;                parsedSet.add(text);</b>
<b class="nc">&nbsp;                parsedSet.add(finalText);</b>
<b class="nc">&nbsp;                if (variants != null) {</b>
<b class="nc">&nbsp;                    for (int i=variants.length; --i&gt;=0; ) {</b>
<b class="nc">&nbsp;                        parsedSet.add(variants[i]);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                ArrayList&lt;String&gt; parsedList = new ArrayList&lt;String&gt;(parsedSet);</b>
<b class="nc">&nbsp;                Collections.reverse(parsedList);</b>
<b class="nc">&nbsp;                iParsedForms = parsedList.toArray(new String[parsedList.size()]);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            iBeforePrinter = beforePrinter;</b>
<b class="nc">&nbsp;            iBeforeParser = beforeParser;</b>
<b class="nc">&nbsp;            iUseBefore = useBefore;</b>
<b class="nc">&nbsp;            iUseAfter = useAfter;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<b class="nc">&nbsp;            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);</b>
<b class="nc">&nbsp;            if (sum &lt; stopAt) {</b>
<b class="nc">&nbsp;                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);</b>
&nbsp;            }
<b class="nc">&nbsp;            return sum;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            PeriodPrinter before = iBeforePrinter;</b>
<b class="nc">&nbsp;            PeriodPrinter after = iAfterPrinter;</b>
&nbsp;            
<b class="nc">&nbsp;            int sum = before.calculatePrintedLength(period, locale)</b>
<b class="nc">&nbsp;                    + after.calculatePrintedLength(period, locale);</b>
&nbsp;            
<b class="nc">&nbsp;            if (iUseBefore) {</b>
<b class="nc">&nbsp;                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                    if (iUseAfter) {</b>
<b class="nc">&nbsp;                        int afterCount = after.countFieldsToPrint(period, 2, locale);</b>
<b class="nc">&nbsp;                        if (afterCount &gt; 0) {</b>
<b class="nc">&nbsp;                            sum += (afterCount &gt; 1 ? iText : iFinalText).length();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        sum += iText.length();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                sum += iText.length();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return sum;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            PeriodPrinter before = iBeforePrinter;</b>
<b class="nc">&nbsp;            PeriodPrinter after = iAfterPrinter;</b>
&nbsp;            
<b class="nc">&nbsp;            before.printTo(buf, period, locale);</b>
<b class="nc">&nbsp;            if (iUseBefore) {</b>
<b class="nc">&nbsp;                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                    if (iUseAfter) {</b>
<b class="nc">&nbsp;                        int afterCount = after.countFieldsToPrint(period, 2, locale);</b>
<b class="nc">&nbsp;                        if (afterCount &gt; 0) {</b>
<b class="nc">&nbsp;                            buf.append(afterCount &gt; 1 ? iText : iFinalText);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        buf.append(iText);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                buf.append(iText);</b>
&nbsp;            }
<b class="nc">&nbsp;            after.printTo(buf, period, locale);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<b class="nc">&nbsp;            PeriodPrinter before = iBeforePrinter;</b>
<b class="nc">&nbsp;            PeriodPrinter after = iAfterPrinter;</b>
&nbsp;            
<b class="nc">&nbsp;            before.printTo(out, period, locale);</b>
<b class="nc">&nbsp;            if (iUseBefore) {</b>
<b class="nc">&nbsp;                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                    if (iUseAfter) {</b>
<b class="nc">&nbsp;                        int afterCount = after.countFieldsToPrint(period, 2, locale);</b>
<b class="nc">&nbsp;                        if (afterCount &gt; 0) {</b>
<b class="nc">&nbsp;                            out.write(afterCount &gt; 1 ? iText : iFinalText);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        out.write(iText);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</b>
<b class="nc">&nbsp;                out.write(iText);</b>
&nbsp;            }
<b class="nc">&nbsp;            after.printTo(out, period, locale);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(
&nbsp;                ReadWritablePeriod period, String periodStr,
&nbsp;                int position, Locale locale) {
<b class="nc">&nbsp;            int oldPos = position;</b>
<b class="nc">&nbsp;            position = iBeforeParser.parseInto(period, periodStr, position, locale);</b>
&nbsp;
<b class="nc">&nbsp;            if (position &lt; 0) {</b>
<b class="nc">&nbsp;                return position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            boolean found = false;</b>
<b class="nc">&nbsp;            int parsedFormLength = -1;</b>
<b class="nc">&nbsp;            if (position &gt; oldPos) {</b>
&nbsp;                // Consume this separator.
<b class="nc">&nbsp;                String[] parsedForms = iParsedForms;</b>
<b class="nc">&nbsp;                int length = parsedForms.length;</b>
<b class="nc">&nbsp;                for (int i=0; i &lt; length; i++) {</b>
<b class="nc">&nbsp;                    String parsedForm = parsedForms[i];</b>
<b class="nc">&nbsp;                    if ((parsedForm == null || parsedForm.length() == 0) ||</b>
&nbsp;                        periodStr.regionMatches
<b class="nc">&nbsp;                        (true, position, parsedForm, 0, parsedForm.length())) {</b>
&nbsp;                        
<b class="nc">&nbsp;                        parsedFormLength = (parsedForm == null ? 0 : parsedForm.length());</b>
<b class="nc">&nbsp;                        position += parsedFormLength;</b>
<b class="nc">&nbsp;                        found = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            oldPos = position;</b>
<b class="nc">&nbsp;            position = iAfterParser.parseInto(period, periodStr, position, locale);</b>
&nbsp;
<b class="nc">&nbsp;            if (position &lt; 0) {</b>
<b class="nc">&nbsp;                return position;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (found &amp;&amp; position == oldPos &amp;&amp; parsedFormLength &gt; 0) {</b>
&nbsp;                // Separator should not have been supplied.
<b class="nc">&nbsp;                return ~oldPos;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (position &gt; oldPos &amp;&amp; !found &amp;&amp; !iUseBefore) {</b>
&nbsp;                // Separator was required.
<b class="nc">&nbsp;                return ~oldPos;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return position;</b>
&nbsp;        }
&nbsp;
&nbsp;        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {
<b class="nc">&nbsp;            iAfterPrinter = afterPrinter;</b>
<b class="nc">&nbsp;            iAfterParser = afterParser;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * Composite implementation that merges other fields to create a full pattern.
&nbsp;     */
&nbsp;    static class Composite
&nbsp;            implements PeriodPrinter, PeriodParser {
&nbsp;        
&nbsp;        private final PeriodPrinter[] iPrinters;
&nbsp;        private final PeriodParser[] iParsers;
&nbsp;
<b class="nc">&nbsp;        Composite(List&lt;Object&gt; elementPairs) {</b>
<b class="nc">&nbsp;            List&lt;Object&gt; printerList = new ArrayList&lt;Object&gt;();</b>
<b class="nc">&nbsp;            List&lt;Object&gt; parserList = new ArrayList&lt;Object&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            decompose(elementPairs, printerList, parserList);</b>
&nbsp;
<b class="nc">&nbsp;            if (printerList.size() &lt;= 0) {</b>
<b class="nc">&nbsp;                iPrinters = null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                iPrinters = printerList.toArray(</b>
<b class="nc">&nbsp;                        new PeriodPrinter[printerList.size()]);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (parserList.size() &lt;= 0) {</b>
<b class="nc">&nbsp;                iParsers = null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                iParsers = parserList.toArray(</b>
<b class="nc">&nbsp;                        new PeriodParser[parserList.size()]);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<b class="nc">&nbsp;            int sum = 0;</b>
<b class="nc">&nbsp;            PeriodPrinter[] printers = iPrinters;</b>
<b class="nc">&nbsp;            for (int i=printers.length; sum &lt; stopAt &amp;&amp; --i&gt;=0; ) {</b>
<b class="nc">&nbsp;                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);</b>
&nbsp;            }
<b class="nc">&nbsp;            return sum;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            int sum = 0;</b>
<b class="nc">&nbsp;            PeriodPrinter[] printers = iPrinters;</b>
<b class="nc">&nbsp;            for (int i=printers.length; --i&gt;=0; ) {</b>
<b class="nc">&nbsp;                sum += printers[i].calculatePrintedLength(period, locale);</b>
&nbsp;            }
<b class="nc">&nbsp;            return sum;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<b class="nc">&nbsp;            PeriodPrinter[] printers = iPrinters;</b>
<b class="nc">&nbsp;            int len = printers.length;</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;len; i++) {</b>
<b class="nc">&nbsp;                printers[i].printTo(buf, period, locale);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<b class="nc">&nbsp;            PeriodPrinter[] printers = iPrinters;</b>
<b class="nc">&nbsp;            int len = printers.length;</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;len; i++) {</b>
<b class="nc">&nbsp;                printers[i].printTo(out, period, locale);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int parseInto(
&nbsp;                ReadWritablePeriod period, String periodStr,
&nbsp;                int position, Locale locale) {
<b class="nc">&nbsp;            PeriodParser[] parsers = iParsers;</b>
<b class="nc">&nbsp;            if (parsers == null) {</b>
<b class="nc">&nbsp;                throw new UnsupportedOperationException();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int len = parsers.length;</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;len &amp;&amp; position &gt;= 0; i++) {</b>
<b class="nc">&nbsp;                position = parsers[i].parseInto(period, periodStr, position, locale);</b>
&nbsp;            }
<b class="nc">&nbsp;            return position;</b>
&nbsp;        }
&nbsp;
&nbsp;        private void decompose(List&lt;Object&gt; elementPairs, List&lt;Object&gt; printerList, List&lt;Object&gt; parserList) {
<b class="nc">&nbsp;            int size = elementPairs.size();</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;size; i+=2) {</b>
<b class="nc">&nbsp;                Object element = elementPairs.get(i);</b>
<b class="nc">&nbsp;                if (element instanceof PeriodPrinter) {</b>
<b class="nc">&nbsp;                    if (element instanceof Composite) {</b>
<b class="nc">&nbsp;                        addArrayToList(printerList, ((Composite) element).iPrinters);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        printerList.add(element);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                element = elementPairs.get(i + 1);</b>
<b class="nc">&nbsp;                if (element instanceof PeriodParser) {</b>
<b class="nc">&nbsp;                    if (element instanceof Composite) {</b>
<b class="nc">&nbsp;                        addArrayToList(parserList, ((Composite) element).iParsers);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        parserList.add(element);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void addArrayToList(List&lt;Object&gt; list, Object[] array) {
<b class="nc">&nbsp;            if (array != null) {</b>
<b class="nc">&nbsp;                for (int i=0; i&lt;array.length; i++) {</b>
<b class="nc">&nbsp;                    list.add(array[i]);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-03 10:38</div>
</div>
</body>
</html>
