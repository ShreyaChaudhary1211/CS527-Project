


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DateTimeZoneBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.joda.time.tz</a>
</div>

<h1>Coverage Summary for Class: DateTimeZoneBuilder (org.joda.time.tz)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DateTimeZoneBuilder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/136)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$DSTZone</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/85)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$OfYear</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/118)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$PrecalculatedZone</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/217)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Recurrence</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Rule</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$RuleSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Transition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/705)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright 2001-2013 Stephen Colebourne
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package org.joda.time.tz;
&nbsp;
&nbsp;import java.io.DataInput;
&nbsp;import java.io.DataInputStream;
&nbsp;import java.io.DataOutput;
&nbsp;import java.io.DataOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.text.DateFormatSymbols;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.joda.time.Chronology;
&nbsp;import org.joda.time.DateTime;
&nbsp;import org.joda.time.DateTimeUtils;
&nbsp;import org.joda.time.DateTimeZone;
&nbsp;import org.joda.time.Period;
&nbsp;import org.joda.time.PeriodType;
&nbsp;import org.joda.time.chrono.ISOChronology;
&nbsp;
&nbsp;/**
&nbsp; * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since
&nbsp; * creating a new DateTimeZone this way is a relatively expensive operation,
&nbsp; * built zones can be written to a file. Reading back the encoded data is a
&nbsp; * quick operation.
&nbsp; * &lt;p&gt;
&nbsp; * DateTimeZoneBuilder itself is mutable and not thread-safe, but the
&nbsp; * DateTimeZone objects that it builds are thread-safe and immutable.
&nbsp; * &lt;p&gt;
&nbsp; * It is intended that {@link ZoneInfoCompiler} be used to read time zone data
&nbsp; * files, indirectly calling DateTimeZoneBuilder. The following complex
&nbsp; * example defines the America/Los_Angeles time zone, with all historical
&nbsp; * transitions:
&nbsp; * 
&nbsp; * &lt;pre&gt;
&nbsp; * DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()
&nbsp; *     .addCutover(-2147483648, &#39;w&#39;, 1, 1, 0, false, 0)
&nbsp; *     .setStandardOffset(-28378000)
&nbsp; *     .setFixedSavings(&quot;LMT&quot;, 0)
&nbsp; *     .addCutover(1883, &#39;w&#39;, 11, 18, 0, false, 43200000)
&nbsp; *     .setStandardOffset(-28800000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1918, 1919, &#39;w&#39;,  3, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1918, 1919, &#39;w&#39;, 10, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PWT&quot;, 3600000, 1942, 1942, &#39;w&#39;,  2,  9, 0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PPT&quot;, 3600000, 1945, 1945, &#39;u&#39;,  8, 14, 0, false, 82800000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1945, 1945, &#39;w&#39;,  9, 30, 0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1948, 1948, &#39;w&#39;,  3, 14, 0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1949, 1949, &#39;w&#39;,  1,  1, 0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1950, 1966, &#39;w&#39;,  4, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1950, 1961, &#39;w&#39;,  9, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1962, 1966, &#39;w&#39;, 10, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1967, 2147483647, &#39;w&#39;, 10, -1, 7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1967, 1973, &#39;w&#39;, 4, -1,  7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1974, 1974, &#39;w&#39;, 1,  6,  0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1975, 1975, &#39;w&#39;, 2, 23,  0, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1976, 1986, &#39;w&#39;, 4, -1,  7, false, 7200000)
&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1987, 2147483647, &#39;w&#39;, 4, 1, 7, true, 7200000)
&nbsp; *     .toDateTimeZone(&quot;America/Los_Angeles&quot;, true);
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * @author Brian S O&#39;Neill
&nbsp; * @see ZoneInfoCompiler
&nbsp; * @see ZoneInfoProvider
&nbsp; * @since 1.0
&nbsp; */
&nbsp;public class DateTimeZoneBuilder {
&nbsp;    /**
&nbsp;     * Decodes a built DateTimeZone from the given stream, as encoded by
&nbsp;     * writeTo.
&nbsp;     *
&nbsp;     * @param in input stream to read encoded DateTimeZone from.
&nbsp;     * @param id time zone id to assign
&nbsp;     */
&nbsp;    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {
<b class="nc">&nbsp;        if (in instanceof DataInput) {</b>
<b class="nc">&nbsp;            return readFrom((DataInput)in, id);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return readFrom((DataInput)new DataInputStream(in), id);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Decodes a built DateTimeZone from the given stream, as encoded by
&nbsp;     * writeTo.
&nbsp;     *
&nbsp;     * @param in input stream to read encoded DateTimeZone from.
&nbsp;     * @param id time zone id to assign
&nbsp;     */
&nbsp;    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {
<b class="nc">&nbsp;        switch (in.readUnsignedByte()) {</b>
&nbsp;        case &#39;F&#39;:
<b class="nc">&nbsp;            DateTimeZone fixed = new FixedDateTimeZone</b>
<b class="nc">&nbsp;                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));</b>
<b class="nc">&nbsp;            if (fixed.equals(DateTimeZone.UTC)) {</b>
<b class="nc">&nbsp;                fixed = DateTimeZone.UTC;</b>
&nbsp;            }
<b class="nc">&nbsp;            return fixed;</b>
&nbsp;        case &#39;C&#39;:
<b class="nc">&nbsp;            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));</b>
&nbsp;        case &#39;P&#39;:
<b class="nc">&nbsp;            return PrecalculatedZone.readFrom(in, id);</b>
&nbsp;        default:
<b class="nc">&nbsp;            throw new IOException(&quot;Invalid encoding&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Millisecond encoding formats:
&nbsp;     *
&nbsp;     * upper two bits  units       field length  approximate range
&nbsp;     * ---------------------------------------------------------------
&nbsp;     * 00              30 minutes  1 byte        +/- 16 hours
&nbsp;     * 01              minutes     4 bytes       +/- 1020 years
&nbsp;     * 10              seconds     5 bytes       +/- 4355 years
&nbsp;     * 11              millis      9 bytes       +/- 292,000,000 years
&nbsp;     *
&nbsp;     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.
&nbsp;     */
&nbsp;    static void writeMillis(DataOutput out, long millis) throws IOException {
<b class="nc">&nbsp;        if (millis % (30 * 60000L) == 0) {</b>
&nbsp;            // Try to write in 30 minute units.
<b class="nc">&nbsp;            long units = millis / (30 * 60000L);</b>
<b class="nc">&nbsp;            if (((units &lt;&lt; (64 - 6)) &gt;&gt; (64 - 6)) == units) {</b>
&nbsp;                // Form 00 (6 bits effective precision)
<b class="nc">&nbsp;                out.writeByte((int)(units &amp; 0x3f));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (millis % 60000L == 0) {</b>
&nbsp;            // Try to write minutes.
<b class="nc">&nbsp;            long minutes = millis / 60000L;</b>
<b class="nc">&nbsp;            if (((minutes &lt;&lt; (64 - 30)) &gt;&gt; (64 - 30)) == minutes) {</b>
&nbsp;                // Form 01 (30 bits effective precision)
<b class="nc">&nbsp;                out.writeInt(0x40000000 | (int)(minutes &amp; 0x3fffffff));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (millis % 1000L == 0) {</b>
&nbsp;            // Try to write seconds.
<b class="nc">&nbsp;            long seconds = millis / 1000L;</b>
<b class="nc">&nbsp;            if (((seconds &lt;&lt; (64 - 38)) &gt;&gt; (64 - 38)) == seconds) {</b>
&nbsp;                // Form 10 (38 bits effective precision)
<b class="nc">&nbsp;                out.writeByte(0x80 | (int)((seconds &gt;&gt; 32) &amp; 0x3f));</b>
<b class="nc">&nbsp;                out.writeInt((int)(seconds &amp; 0xffffffff));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Write milliseconds either because the additional precision is
&nbsp;        // required or the minutes didn&#39;t fit in the field.
&nbsp;        
&nbsp;        // Form 11 (64-bits effective precision, but write as if 70 bits)
<b class="nc">&nbsp;        out.writeByte(millis &lt; 0 ? 0xff : 0xc0);</b>
<b class="nc">&nbsp;        out.writeLong(millis);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads encoding generated by writeMillis.
&nbsp;     */
&nbsp;    static long readMillis(DataInput in) throws IOException {
<b class="nc">&nbsp;        int v = in.readUnsignedByte();</b>
<b class="nc">&nbsp;        switch (v &gt;&gt; 6) {</b>
&nbsp;        case 0: default:
&nbsp;            // Form 00 (6 bits effective precision)
<b class="nc">&nbsp;            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 6);</b>
<b class="nc">&nbsp;            return v * (30 * 60000L);</b>
&nbsp;
&nbsp;        case 1:
&nbsp;            // Form 01 (30 bits effective precision)
<b class="nc">&nbsp;            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 30);</b>
<b class="nc">&nbsp;            v |= (in.readUnsignedByte()) &lt;&lt; 16;</b>
<b class="nc">&nbsp;            v |= (in.readUnsignedByte()) &lt;&lt; 8;</b>
<b class="nc">&nbsp;            v |= (in.readUnsignedByte());</b>
<b class="nc">&nbsp;            return v * 60000L;</b>
&nbsp;
&nbsp;        case 2:
&nbsp;            // Form 10 (38 bits effective precision)
<b class="nc">&nbsp;            long w = (((long)v) &lt;&lt; (64 - 6)) &gt;&gt; (64 - 38);</b>
<b class="nc">&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 24;</b>
<b class="nc">&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 16;</b>
<b class="nc">&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 8;</b>
<b class="nc">&nbsp;            w |= (in.readUnsignedByte());</b>
<b class="nc">&nbsp;            return w * 1000L;</b>
&nbsp;
&nbsp;        case 3:
&nbsp;            // Form 11 (64-bits effective precision)
<b class="nc">&nbsp;            return in.readLong();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static DateTimeZone buildFixedZone(String id, String nameKey,
&nbsp;                                               int wallOffset, int standardOffset) {
<b class="nc">&nbsp;        if (&quot;UTC&quot;.equals(id) &amp;&amp; id.equals(nameKey) &amp;&amp;</b>
&nbsp;            wallOffset == 0 &amp;&amp; standardOffset == 0) {
<b class="nc">&nbsp;            return DateTimeZone.UTC;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);</b>
&nbsp;    }
&nbsp;
&nbsp;    // List of RuleSets.
&nbsp;    private final ArrayList&lt;RuleSet&gt; iRuleSets;
&nbsp;
<b class="nc">&nbsp;    public DateTimeZoneBuilder() {</b>
<b class="nc">&nbsp;        iRuleSets = new ArrayList&lt;RuleSet&gt;(10);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a cutover for added rules. The standard offset at the cutover
&nbsp;     * defaults to 0. Call setStandardOffset afterwards to change it.
&nbsp;     *
&nbsp;     * @param year  the year of cutover
&nbsp;     * @param mode &#39;u&#39; - cutover is measured against UTC, &#39;w&#39; - against wall
&nbsp;     *  offset, &#39;s&#39; - against standard offset
&nbsp;     * @param monthOfYear  the month from 1 (January) to 12 (December)
&nbsp;     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
&nbsp;     *  For example, if -1, set to last day of month
&nbsp;     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
&nbsp;     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
&nbsp;     *  dayOfWeek when true, retreat when false.
&nbsp;     * @param millisOfDay  additional precision for specifying time of day of cutover
&nbsp;     */
&nbsp;    public DateTimeZoneBuilder addCutover(int year,
&nbsp;                                          char mode,
&nbsp;                                          int monthOfYear,
&nbsp;                                          int dayOfMonth,
&nbsp;                                          int dayOfWeek,
&nbsp;                                          boolean advanceDayOfWeek,
&nbsp;                                          int millisOfDay)
&nbsp;    {
<b class="nc">&nbsp;        if (iRuleSets.size() &gt; 0) {</b>
<b class="nc">&nbsp;            OfYear ofYear = new OfYear</b>
&nbsp;                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<b class="nc">&nbsp;            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);</b>
<b class="nc">&nbsp;            lastRuleSet.setUpperLimit(year, ofYear);</b>
&nbsp;        }
<b class="nc">&nbsp;        iRuleSets.add(new RuleSet());</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the standard offset to use for newly added rules until the next
&nbsp;     * cutover is added.
&nbsp;     * @param standardOffset  the standard offset in millis
&nbsp;     */
&nbsp;    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {
<b class="nc">&nbsp;        getLastRuleSet().setStandardOffset(standardOffset);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set a fixed savings rule at the cutover.
&nbsp;     */
&nbsp;    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {
<b class="nc">&nbsp;        getLastRuleSet().setFixedSavings(nameKey, saveMillis);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a recurring daylight saving time rule.
&nbsp;     *
&nbsp;     * @param nameKey  the name key of new rule
&nbsp;     * @param saveMillis  the milliseconds to add to standard offset
&nbsp;     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates
&nbsp;     * beginning of time
&nbsp;     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE
&nbsp;     *  indicates end of time
&nbsp;     * @param mode  &#39;u&#39; - transitions are calculated against UTC, &#39;w&#39; -
&nbsp;     *  transitions are calculated against wall offset, &#39;s&#39; - transitions are
&nbsp;     *  calculated against standard offset
&nbsp;     * @param monthOfYear  the month from 1 (January) to 12 (December)
&nbsp;     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
&nbsp;     *  For example, if -1, set to last day of month
&nbsp;     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
&nbsp;     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
&nbsp;     *  dayOfWeek when true, retreat when false.
&nbsp;     * @param millisOfDay  additional precision for specifying time of day of transitions
&nbsp;     */
&nbsp;    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,
&nbsp;                                                   int fromYear, int toYear,
&nbsp;                                                   char mode,
&nbsp;                                                   int monthOfYear,
&nbsp;                                                   int dayOfMonth,
&nbsp;                                                   int dayOfWeek,
&nbsp;                                                   boolean advanceDayOfWeek,
&nbsp;                                                   int millisOfDay)
&nbsp;    {
<b class="nc">&nbsp;        if (fromYear &lt;= toYear) {</b>
<b class="nc">&nbsp;            OfYear ofYear = new OfYear</b>
&nbsp;                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<b class="nc">&nbsp;            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);</b>
<b class="nc">&nbsp;            Rule rule = new Rule(recurrence, fromYear, toYear);</b>
<b class="nc">&nbsp;            getLastRuleSet().addRule(rule);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    private RuleSet getLastRuleSet() {
<b class="nc">&nbsp;        if (iRuleSets.size() == 0) {</b>
<b class="nc">&nbsp;            addCutover(Integer.MIN_VALUE, &#39;w&#39;, 1, 1, 0, false, 0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return iRuleSets.get(iRuleSets.size() - 1);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Processes all the rules and builds a DateTimeZone.
&nbsp;     *
&nbsp;     * @param id  time zone id to assign
&nbsp;     * @param outputID  true if the zone id should be output
&nbsp;     */
&nbsp;    public DateTimeZone toDateTimeZone(String id, boolean outputID) {
<b class="nc">&nbsp;        if (id == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Discover where all the transitions occur and store the results in
&nbsp;        // these lists.
<b class="nc">&nbsp;        ArrayList&lt;Transition&gt; transitions = new ArrayList&lt;Transition&gt;();</b>
&nbsp;
&nbsp;        // Tail zone picks up remaining transitions in the form of an endless
&nbsp;        // DST cycle.
<b class="nc">&nbsp;        DSTZone tailZone = null;</b>
&nbsp;
<b class="nc">&nbsp;        long millis = Long.MIN_VALUE;</b>
<b class="nc">&nbsp;        int saveMillis = 0;</b>
&nbsp;            
<b class="nc">&nbsp;        int ruleSetCount = iRuleSets.size();</b>
<b class="nc">&nbsp;        for (int i=0; i&lt;ruleSetCount; i++) {</b>
<b class="nc">&nbsp;            RuleSet rs = iRuleSets.get(i);</b>
<b class="nc">&nbsp;            Transition next = rs.firstTransition(millis);</b>
<b class="nc">&nbsp;            if (next == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            addTransition(transitions, next);</b>
<b class="nc">&nbsp;            millis = next.getMillis();</b>
<b class="nc">&nbsp;            saveMillis = next.getSaveMillis();</b>
&nbsp;
&nbsp;            // Copy it since we&#39;re going to destroy it.
<b class="nc">&nbsp;            rs = new RuleSet(rs);</b>
&nbsp;
<b class="nc">&nbsp;            while ((next = rs.nextTransition(millis, saveMillis)) != null) {</b>
<b class="nc">&nbsp;                if (addTransition(transitions, next)) {</b>
<b class="nc">&nbsp;                    if (tailZone != null) {</b>
&nbsp;                        // Got the extra transition before DSTZone.
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                millis = next.getMillis();</b>
<b class="nc">&nbsp;                saveMillis = next.getSaveMillis();</b>
<b class="nc">&nbsp;                if (tailZone == null &amp;&amp; i == ruleSetCount - 1) {</b>
<b class="nc">&nbsp;                    tailZone = rs.buildTailZone(id);</b>
&nbsp;                    // If tailZone is not null, don&#39;t break out of main loop until
&nbsp;                    // at least one more transition is calculated. This ensures a
&nbsp;                    // correct &#39;seam&#39; to the DSTZone.
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            millis = rs.getUpperLimit(saveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if a simpler zone implementation can be returned.
<b class="nc">&nbsp;        if (transitions.size() == 0) {</b>
<b class="nc">&nbsp;            if (tailZone != null) {</b>
&nbsp;                // This shouldn&#39;t happen, but handle just in case.
<b class="nc">&nbsp;                return tailZone;</b>
&nbsp;            }
<b class="nc">&nbsp;            return buildFixedZone(id, &quot;UTC&quot;, 0, 0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (transitions.size() == 1 &amp;&amp; tailZone == null) {</b>
<b class="nc">&nbsp;            Transition tr = transitions.get(0);</b>
<b class="nc">&nbsp;            return buildFixedZone(id, tr.getNameKey(),</b>
<b class="nc">&nbsp;                                  tr.getWallOffset(), tr.getStandardOffset());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);</b>
<b class="nc">&nbsp;        if (zone.isCachable()) {</b>
<b class="nc">&nbsp;            return CachedDateTimeZone.forZone(zone);</b>
&nbsp;        }
<b class="nc">&nbsp;        return zone;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean addTransition(ArrayList&lt;Transition&gt; transitions, Transition tr) {
<b class="nc">&nbsp;        int size = transitions.size();</b>
<b class="nc">&nbsp;        if (size == 0) {</b>
<b class="nc">&nbsp;            transitions.add(tr);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Transition last = transitions.get(size - 1);</b>
<b class="nc">&nbsp;        if (!tr.isTransitionFrom(last)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If local time of new transition is same as last local time, just
&nbsp;        // replace last transition with new one.
<b class="nc">&nbsp;        int offsetForLast = 0;</b>
<b class="nc">&nbsp;        if (size &gt;= 2) {</b>
<b class="nc">&nbsp;            offsetForLast = transitions.get(size - 2).getWallOffset();</b>
&nbsp;        }
<b class="nc">&nbsp;        int offsetForNew = last.getWallOffset();</b>
&nbsp;
<b class="nc">&nbsp;        long lastLocal = last.getMillis() + offsetForLast;</b>
<b class="nc">&nbsp;        long newLocal = tr.getMillis() + offsetForNew;</b>
&nbsp;
<b class="nc">&nbsp;        if (newLocal != lastLocal) {</b>
<b class="nc">&nbsp;            transitions.add(tr);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        transitions.remove(size - 1);</b>
<b class="nc">&nbsp;        return addTransition(transitions, tr);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a built DateTimeZone to the given stream. Call readFrom to
&nbsp;     * decode the data into a DateTimeZone object.
&nbsp;     *
&nbsp;     * @param out  the output stream to receive the encoded DateTimeZone
&nbsp;     * @since 1.5 (parameter added)
&nbsp;     */
&nbsp;    public void writeTo(String zoneID, OutputStream out) throws IOException {
<b class="nc">&nbsp;        if (out instanceof DataOutput) {</b>
<b class="nc">&nbsp;            writeTo(zoneID, (DataOutput)out);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            writeTo(zoneID, (DataOutput)new DataOutputStream(out));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a built DateTimeZone to the given stream. Call readFrom to
&nbsp;     * decode the data into a DateTimeZone object.
&nbsp;     *
&nbsp;     * @param out  the output stream to receive the encoded DateTimeZone
&nbsp;     * @since 1.5 (parameter added)
&nbsp;     */
&nbsp;    public void writeTo(String zoneID, DataOutput out) throws IOException {
&nbsp;        // pass false so zone id is not written out
<b class="nc">&nbsp;        DateTimeZone zone = toDateTimeZone(zoneID, false);</b>
&nbsp;
<b class="nc">&nbsp;        if (zone instanceof FixedDateTimeZone) {</b>
<b class="nc">&nbsp;            out.writeByte(&#39;F&#39;); // &#39;F&#39; for fixed</b>
<b class="nc">&nbsp;            out.writeUTF(zone.getNameKey(0));</b>
<b class="nc">&nbsp;            writeMillis(out, zone.getOffset(0));</b>
<b class="nc">&nbsp;            writeMillis(out, zone.getStandardOffset(0));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (zone instanceof CachedDateTimeZone) {</b>
<b class="nc">&nbsp;                out.writeByte(&#39;C&#39;); // &#39;C&#39; for cached, precalculated</b>
<b class="nc">&nbsp;                zone = ((CachedDateTimeZone)zone).getUncachedZone();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                out.writeByte(&#39;P&#39;); // &#39;P&#39; for precalculated, uncached</b>
&nbsp;            }
<b class="nc">&nbsp;            ((PrecalculatedZone)zone).writeTo(out);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Supports setting fields of year and moving between transitions.
&nbsp;     */
&nbsp;    private static final class OfYear {
&nbsp;        static OfYear readFrom(DataInput in) throws IOException {
<b class="nc">&nbsp;            return new OfYear((char)in.readUnsignedByte(),</b>
<b class="nc">&nbsp;                              (int)in.readUnsignedByte(),</b>
<b class="nc">&nbsp;                              (int)in.readByte(),</b>
<b class="nc">&nbsp;                              (int)in.readUnsignedByte(),</b>
<b class="nc">&nbsp;                              in.readBoolean(),</b>
<b class="nc">&nbsp;                              (int)readMillis(in));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is &#39;u&#39;, &#39;w&#39;, or &#39;s&#39;.
&nbsp;        final char iMode;
&nbsp;
&nbsp;        final int iMonthOfYear;
&nbsp;        final int iDayOfMonth;
&nbsp;        final int iDayOfWeek;
&nbsp;        final boolean iAdvance;
&nbsp;        final int iMillisOfDay;
&nbsp;
&nbsp;        OfYear(char mode,
&nbsp;               int monthOfYear,
&nbsp;               int dayOfMonth,
&nbsp;               int dayOfWeek, boolean advanceDayOfWeek,
&nbsp;               int millisOfDay)
<b class="nc">&nbsp;        {</b>
<b class="nc">&nbsp;            if (mode != &#39;u&#39; &amp;&amp; mode != &#39;w&#39; &amp;&amp; mode != &#39;s&#39;) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Unknown mode: &quot; + mode);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            iMode = mode;</b>
<b class="nc">&nbsp;            iMonthOfYear = monthOfYear;</b>
<b class="nc">&nbsp;            iDayOfMonth = dayOfMonth;</b>
<b class="nc">&nbsp;            iDayOfWeek = dayOfWeek;</b>
<b class="nc">&nbsp;            iAdvance = advanceDayOfWeek;</b>
<b class="nc">&nbsp;            iMillisOfDay = millisOfDay;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param standardOffset standard offset just before instant
&nbsp;         */
&nbsp;        public long setInstant(int year, int standardOffset, int saveMillis) {
&nbsp;            int offset;
<b class="nc">&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="nc">&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                offset = 0;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="nc">&nbsp;            long millis = chrono.year().set(0, year);</b>
<b class="nc">&nbsp;            millis = chrono.monthOfYear().set(millis, iMonthOfYear);</b>
<b class="nc">&nbsp;            millis = chrono.millisOfDay().set(millis, iMillisOfDay);</b>
<b class="nc">&nbsp;            millis = setDayOfMonth(chrono, millis);</b>
&nbsp;
<b class="nc">&nbsp;            if (iDayOfWeek != 0) {</b>
<b class="nc">&nbsp;                millis = setDayOfWeek(chrono, millis);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Convert from local time to UTC.
<b class="nc">&nbsp;            return millis - offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param standardOffset standard offset just before next recurrence
&nbsp;         */
&nbsp;        public long next(long instant, int standardOffset, int saveMillis) {
&nbsp;            int offset;
<b class="nc">&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="nc">&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                offset = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Convert from UTC to local time.
<b class="nc">&nbsp;            instant += offset;</b>
&nbsp;
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="nc">&nbsp;            long next = chrono.monthOfYear().set(instant, iMonthOfYear);</b>
&nbsp;            // Be lenient with millisOfDay.
<b class="nc">&nbsp;            next = chrono.millisOfDay().set(next, 0);</b>
<b class="nc">&nbsp;            next = chrono.millisOfDay().add(next, iMillisOfDay);</b>
<b class="nc">&nbsp;            next = setDayOfMonthNext(chrono, next);</b>
&nbsp;
<b class="nc">&nbsp;            if (iDayOfWeek == 0) {</b>
<b class="nc">&nbsp;                if (next &lt;= instant) {</b>
<b class="nc">&nbsp;                    next = chrono.year().add(next, 1);</b>
<b class="nc">&nbsp;                    next = setDayOfMonthNext(chrono, next);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                next = setDayOfWeek(chrono, next);</b>
<b class="nc">&nbsp;                if (next &lt;= instant) {</b>
<b class="nc">&nbsp;                    next = chrono.year().add(next, 1);</b>
<b class="nc">&nbsp;                    next = chrono.monthOfYear().set(next, iMonthOfYear);</b>
<b class="nc">&nbsp;                    next = setDayOfMonthNext(chrono, next);</b>
<b class="nc">&nbsp;                    next = setDayOfWeek(chrono, next);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Convert from local time to UTC.
<b class="nc">&nbsp;            return next - offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param standardOffset standard offset just before previous recurrence
&nbsp;         */
&nbsp;        public long previous(long instant, int standardOffset, int saveMillis) {
&nbsp;            int offset;
<b class="nc">&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="nc">&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="nc">&nbsp;                offset = standardOffset;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                offset = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Convert from UTC to local time.
<b class="nc">&nbsp;            instant += offset;</b>
&nbsp;
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="nc">&nbsp;            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);</b>
&nbsp;            // Be lenient with millisOfDay.
<b class="nc">&nbsp;            prev = chrono.millisOfDay().set(prev, 0);</b>
<b class="nc">&nbsp;            prev = chrono.millisOfDay().add(prev, iMillisOfDay);</b>
<b class="nc">&nbsp;            prev = setDayOfMonthPrevious(chrono, prev);</b>
&nbsp;
<b class="nc">&nbsp;            if (iDayOfWeek == 0) {</b>
<b class="nc">&nbsp;                if (prev &gt;= instant) {</b>
<b class="nc">&nbsp;                    prev = chrono.year().add(prev, -1);</b>
<b class="nc">&nbsp;                    prev = setDayOfMonthPrevious(chrono, prev);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                prev = setDayOfWeek(chrono, prev);</b>
<b class="nc">&nbsp;                if (prev &gt;= instant) {</b>
<b class="nc">&nbsp;                    prev = chrono.year().add(prev, -1);</b>
<b class="nc">&nbsp;                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);</b>
<b class="nc">&nbsp;                    prev = setDayOfMonthPrevious(chrono, prev);</b>
<b class="nc">&nbsp;                    prev = setDayOfWeek(chrono, prev);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Convert from local time to UTC.
<b class="nc">&nbsp;            return prev - offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object obj) {
<b class="nc">&nbsp;            if (this == obj) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (obj instanceof OfYear) {</b>
<b class="nc">&nbsp;                OfYear other = (OfYear)obj;</b>
<b class="nc">&nbsp;                return</b>
&nbsp;                    iMode == other.iMode &amp;&amp;
&nbsp;                    iMonthOfYear == other.iMonthOfYear &amp;&amp;
&nbsp;                    iDayOfMonth == other.iDayOfMonth &amp;&amp;
&nbsp;                    iDayOfWeek == other.iDayOfWeek &amp;&amp;
&nbsp;                    iAdvance == other.iAdvance &amp;&amp;
&nbsp;                    iMillisOfDay == other.iMillisOfDay;
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /*
&nbsp;        public String toString() {
&nbsp;            return
&nbsp;                &quot;[OfYear]\n&quot; + 
&nbsp;                &quot;Mode: &quot; + iMode + &#39;\n&#39; +
&nbsp;                &quot;MonthOfYear: &quot; + iMonthOfYear + &#39;\n&#39; +
&nbsp;                &quot;DayOfMonth: &quot; + iDayOfMonth + &#39;\n&#39; +
&nbsp;                &quot;DayOfWeek: &quot; + iDayOfWeek + &#39;\n&#39; +
&nbsp;                &quot;AdvanceDayOfWeek: &quot; + iAdvance + &#39;\n&#39; +
&nbsp;                &quot;MillisOfDay: &quot; + iMillisOfDay + &#39;\n&#39;;
&nbsp;        }
&nbsp;        */
&nbsp;
&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="nc">&nbsp;            out.writeByte(iMode);</b>
<b class="nc">&nbsp;            out.writeByte(iMonthOfYear);</b>
<b class="nc">&nbsp;            out.writeByte(iDayOfMonth);</b>
<b class="nc">&nbsp;            out.writeByte(iDayOfWeek);</b>
<b class="nc">&nbsp;            out.writeBoolean(iAdvance);</b>
<b class="nc">&nbsp;            writeMillis(out, iMillisOfDay);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If month-day is 02-29 and year isn&#39;t leap, advances to next leap year.
&nbsp;         */
&nbsp;        private long setDayOfMonthNext(Chronology chrono, long next) {
&nbsp;            try {
<b class="nc">&nbsp;                next = setDayOfMonth(chrono, next);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</b>
<b class="nc">&nbsp;                    while (chrono.year().isLeap(next) == false) {</b>
<b class="nc">&nbsp;                        next = chrono.year().add(next, 1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    next = setDayOfMonth(chrono, next);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw e;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return next;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If month-day is 02-29 and year isn&#39;t leap, retreats to previous leap year.
&nbsp;         */
&nbsp;        private long setDayOfMonthPrevious(Chronology chrono, long prev) {
&nbsp;            try {
<b class="nc">&nbsp;                prev = setDayOfMonth(chrono, prev);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</b>
<b class="nc">&nbsp;                    while (chrono.year().isLeap(prev) == false) {</b>
<b class="nc">&nbsp;                        prev = chrono.year().add(prev, -1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    prev = setDayOfMonth(chrono, prev);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw e;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return prev;</b>
&nbsp;        }
&nbsp;
&nbsp;        private long setDayOfMonth(Chronology chrono, long instant) {
<b class="nc">&nbsp;            if (iDayOfMonth &gt;= 0) {</b>
<b class="nc">&nbsp;                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                instant = chrono.dayOfMonth().set(instant, 1);</b>
<b class="nc">&nbsp;                instant = chrono.monthOfYear().add(instant, 1);</b>
<b class="nc">&nbsp;                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);</b>
&nbsp;            }
<b class="nc">&nbsp;            return instant;</b>
&nbsp;        }
&nbsp;
&nbsp;        private long setDayOfWeek(Chronology chrono, long instant) {
<b class="nc">&nbsp;            int dayOfWeek = chrono.dayOfWeek().get(instant);</b>
<b class="nc">&nbsp;            int daysToAdd = iDayOfWeek - dayOfWeek;</b>
<b class="nc">&nbsp;            if (daysToAdd != 0) {</b>
<b class="nc">&nbsp;                if (iAdvance) {</b>
<b class="nc">&nbsp;                    if (daysToAdd &lt; 0) {</b>
<b class="nc">&nbsp;                        daysToAdd += 7;</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    if (daysToAdd &gt; 0) {</b>
<b class="nc">&nbsp;                        daysToAdd -= 7;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                instant = chrono.dayOfWeek().add(instant, daysToAdd);</b>
&nbsp;            }
<b class="nc">&nbsp;            return instant;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extends OfYear with a nameKey and savings.
&nbsp;     */
&nbsp;    private static final class Recurrence {
&nbsp;        static Recurrence readFrom(DataInput in) throws IOException {
<b class="nc">&nbsp;            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));</b>
&nbsp;        }
&nbsp;
&nbsp;        final OfYear iOfYear;
&nbsp;        final String iNameKey;
&nbsp;        final int iSaveMillis;
&nbsp;
<b class="nc">&nbsp;        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {</b>
<b class="nc">&nbsp;            iOfYear = ofYear;</b>
<b class="nc">&nbsp;            iNameKey = nameKey;</b>
<b class="nc">&nbsp;            iSaveMillis = saveMillis;</b>
&nbsp;        }
&nbsp;
&nbsp;        public OfYear getOfYear() {
<b class="nc">&nbsp;            return iOfYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param standardOffset standard offset just before next recurrence
&nbsp;         */
&nbsp;        public long next(long instant, int standardOffset, int saveMillis) {
<b class="nc">&nbsp;            return iOfYear.next(instant, standardOffset, saveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param standardOffset standard offset just before previous recurrence
&nbsp;         */
&nbsp;        public long previous(long instant, int standardOffset, int saveMillis) {
<b class="nc">&nbsp;            return iOfYear.previous(instant, standardOffset, saveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getNameKey() {
<b class="nc">&nbsp;            return iNameKey;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getSaveMillis() {
<b class="nc">&nbsp;            return iSaveMillis;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object obj) {
<b class="nc">&nbsp;            if (this == obj) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (obj instanceof Recurrence) {</b>
<b class="nc">&nbsp;                Recurrence other = (Recurrence)obj;</b>
<b class="nc">&nbsp;                return</b>
&nbsp;                    iSaveMillis == other.iSaveMillis &amp;&amp;
<b class="nc">&nbsp;                    iNameKey.equals(other.iNameKey) &amp;&amp;</b>
<b class="nc">&nbsp;                    iOfYear.equals(other.iOfYear);</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="nc">&nbsp;            iOfYear.writeTo(out);</b>
<b class="nc">&nbsp;            out.writeUTF(iNameKey);</b>
<b class="nc">&nbsp;            writeMillis(out, iSaveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        Recurrence rename(String nameKey) {
<b class="nc">&nbsp;            return new Recurrence(iOfYear, nameKey, iSaveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        Recurrence renameAppend(String appendNameKey) {
<b class="nc">&nbsp;            return rename((iNameKey + appendNameKey).intern());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extends Recurrence with inclusive year limits.
&nbsp;     */
&nbsp;    private static final class Rule {
&nbsp;        final Recurrence iRecurrence;
&nbsp;        final int iFromYear; // inclusive
&nbsp;        final int iToYear;   // inclusive
&nbsp;
<b class="nc">&nbsp;        Rule(Recurrence recurrence, int fromYear, int toYear) {</b>
<b class="nc">&nbsp;            iRecurrence = recurrence;</b>
<b class="nc">&nbsp;            iFromYear = fromYear;</b>
<b class="nc">&nbsp;            iToYear = toYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        public int getFromYear() {
<b class="nc">&nbsp;            return iFromYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getToYear() {
<b class="nc">&nbsp;            return iToYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        public OfYear getOfYear() {
<b class="nc">&nbsp;            return iRecurrence.getOfYear();</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getNameKey() {
<b class="nc">&nbsp;            return iRecurrence.getNameKey();</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getSaveMillis() {
<b class="nc">&nbsp;            return iRecurrence.getSaveMillis();</b>
&nbsp;        }
&nbsp;
&nbsp;        public long next(final long instant, int standardOffset, int saveMillis) {
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
&nbsp;
<b class="nc">&nbsp;            final int wallOffset = standardOffset + saveMillis;</b>
<b class="nc">&nbsp;            long testInstant = instant;</b>
&nbsp;
&nbsp;            int year;
<b class="nc">&nbsp;            if (instant == Long.MIN_VALUE) {</b>
<b class="nc">&nbsp;                year = Integer.MIN_VALUE;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                year = chrono.year().get(instant + wallOffset);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (year &lt; iFromYear) {</b>
&nbsp;                // First advance instant to start of from year.
<b class="nc">&nbsp;                testInstant = chrono.year().set(0, iFromYear) - wallOffset;</b>
&nbsp;                // Back off one millisecond to account for next recurrence
&nbsp;                // being exactly at the beginning of the year.
<b class="nc">&nbsp;                testInstant -= 1;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);</b>
&nbsp;
<b class="nc">&nbsp;            if (next &gt; instant) {</b>
<b class="nc">&nbsp;                year = chrono.year().get(next + wallOffset);</b>
<b class="nc">&nbsp;                if (year &gt; iToYear) {</b>
&nbsp;                    // Out of range, return original value.
<b class="nc">&nbsp;                    next = instant;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return next;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class Transition {
&nbsp;        private final long iMillis;
&nbsp;        private final String iNameKey;
&nbsp;        private final int iWallOffset;
&nbsp;        private final int iStandardOffset;
&nbsp;
<b class="nc">&nbsp;        Transition(long millis, Transition tr) {</b>
<b class="nc">&nbsp;            iMillis = millis;</b>
<b class="nc">&nbsp;            iNameKey = tr.iNameKey;</b>
<b class="nc">&nbsp;            iWallOffset = tr.iWallOffset;</b>
<b class="nc">&nbsp;            iStandardOffset = tr.iStandardOffset;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Transition(long millis, Rule rule, int standardOffset) {</b>
<b class="nc">&nbsp;            iMillis = millis;</b>
<b class="nc">&nbsp;            iNameKey = rule.getNameKey();</b>
<b class="nc">&nbsp;            iWallOffset = standardOffset + rule.getSaveMillis();</b>
<b class="nc">&nbsp;            iStandardOffset = standardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        Transition(long millis, String nameKey,
<b class="nc">&nbsp;                   int wallOffset, int standardOffset) {</b>
<b class="nc">&nbsp;            iMillis = millis;</b>
<b class="nc">&nbsp;            iNameKey = nameKey;</b>
<b class="nc">&nbsp;            iWallOffset = wallOffset;</b>
<b class="nc">&nbsp;            iStandardOffset = standardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public long getMillis() {
<b class="nc">&nbsp;            return iMillis;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getNameKey() {
<b class="nc">&nbsp;            return iNameKey;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getWallOffset() {
<b class="nc">&nbsp;            return iWallOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getStandardOffset() {
<b class="nc">&nbsp;            return iStandardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getSaveMillis() {
<b class="nc">&nbsp;            return iWallOffset - iStandardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * There must be a change in the millis, wall offsets or name keys.
&nbsp;         */
&nbsp;        public boolean isTransitionFrom(Transition other) {
<b class="nc">&nbsp;            if (other == null) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return iMillis &gt; other.iMillis &amp;&amp;</b>
&nbsp;                (iWallOffset != other.iWallOffset ||
&nbsp;                 //iStandardOffset != other.iStandardOffset ||
<b class="nc">&nbsp;                 !(iNameKey.equals(other.iNameKey)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class RuleSet {
&nbsp;        private static final int YEAR_LIMIT;
&nbsp;
&nbsp;        static {
&nbsp;            // Don&#39;t pre-calculate more than 100 years into the future. Almost
&nbsp;            // all zones will stop pre-calculating far sooner anyhow. Either a
&nbsp;            // simple DST cycle is detected or the last rule is a fixed
&nbsp;            // offset. If a zone has a fixed offset set more than 100 years
&nbsp;            // into the future, then it won&#39;t be observed.
<b class="nc">&nbsp;            long now = DateTimeUtils.currentTimeMillis();</b>
<b class="nc">&nbsp;            YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;</b>
&nbsp;        }
&nbsp;
&nbsp;        private int iStandardOffset;
&nbsp;        private ArrayList&lt;Rule&gt; iRules;
&nbsp;
&nbsp;        // Optional.
&nbsp;        private String iInitialNameKey;
&nbsp;        private int iInitialSaveMillis;
&nbsp;
&nbsp;        // Upper limit is exclusive.
&nbsp;        private int iUpperYear;
&nbsp;        private OfYear iUpperOfYear;
&nbsp;
<b class="nc">&nbsp;        RuleSet() {</b>
<b class="nc">&nbsp;            iRules = new ArrayList&lt;Rule&gt;(10);</b>
<b class="nc">&nbsp;            iUpperYear = Integer.MAX_VALUE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Copy constructor.
&nbsp;         */
<b class="nc">&nbsp;        RuleSet(RuleSet rs) {</b>
<b class="nc">&nbsp;            iStandardOffset = rs.iStandardOffset;</b>
<b class="nc">&nbsp;            iRules = new ArrayList&lt;Rule&gt;(rs.iRules);</b>
<b class="nc">&nbsp;            iInitialNameKey = rs.iInitialNameKey;</b>
<b class="nc">&nbsp;            iInitialSaveMillis = rs.iInitialSaveMillis;</b>
<b class="nc">&nbsp;            iUpperYear = rs.iUpperYear;</b>
<b class="nc">&nbsp;            iUpperOfYear = rs.iUpperOfYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        public int getStandardOffset() {
<b class="nc">&nbsp;            return iStandardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setStandardOffset(int standardOffset) {
<b class="nc">&nbsp;            iStandardOffset = standardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setFixedSavings(String nameKey, int saveMillis) {
<b class="nc">&nbsp;            iInitialNameKey = nameKey;</b>
<b class="nc">&nbsp;            iInitialSaveMillis = saveMillis;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void addRule(Rule rule) {
<b class="nc">&nbsp;            if (!iRules.contains(rule)) {</b>
<b class="nc">&nbsp;                iRules.add(rule);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void setUpperLimit(int year, OfYear ofYear) {
<b class="nc">&nbsp;            iUpperYear = year;</b>
<b class="nc">&nbsp;            iUpperOfYear = ofYear;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a transition at firstMillis with the first name key and
&nbsp;         * offsets for this rule set. This method may return null.
&nbsp;         *
&nbsp;         * @param firstMillis millis of first transition
&nbsp;         */
&nbsp;        public Transition firstTransition(final long firstMillis) {
<b class="nc">&nbsp;            if (iInitialNameKey != null) {</b>
&nbsp;                // Initial zone info explicitly set, so don&#39;t search the rules.
<b class="nc">&nbsp;                return new Transition(firstMillis, iInitialNameKey,</b>
&nbsp;                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);
&nbsp;            }
&nbsp;
&nbsp;            // Make a copy before we destroy the rules.
<b class="nc">&nbsp;            ArrayList&lt;Rule&gt; copy = new ArrayList&lt;Rule&gt;(iRules);</b>
&nbsp;
&nbsp;            // Iterate through all the transitions until firstMillis is
&nbsp;            // reached. Use the name key and savings for whatever rule reaches
&nbsp;            // the limit.
&nbsp;
<b class="nc">&nbsp;            long millis = Long.MIN_VALUE;</b>
<b class="nc">&nbsp;            int saveMillis = 0;</b>
<b class="nc">&nbsp;            Transition first = null;</b>
&nbsp;
&nbsp;            Transition next;
<b class="nc">&nbsp;            while ((next = nextTransition(millis, saveMillis)) != null) {</b>
<b class="nc">&nbsp;                millis = next.getMillis();</b>
&nbsp;
<b class="nc">&nbsp;                if (millis == firstMillis) {</b>
<b class="nc">&nbsp;                    first = new Transition(firstMillis, next);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (millis &gt; firstMillis) {</b>
<b class="nc">&nbsp;                    if (first == null) {</b>
&nbsp;                        // Find first rule without savings. This way a more
&nbsp;                        // accurate nameKey is found even though no rule
&nbsp;                        // extends to the RuleSet&#39;s lower limit.
<b class="nc">&nbsp;                        for (Rule rule : copy) {</b>
<b class="nc">&nbsp;                            if (rule.getSaveMillis() == 0) {</b>
<b class="nc">&nbsp;                                first = new Transition(firstMillis, rule, iStandardOffset);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (first == null) {</b>
&nbsp;                        // Found no rule without savings. Create a transition
&nbsp;                        // with no savings anyhow, and use the best available
&nbsp;                        // name key.
<b class="nc">&nbsp;                        first = new Transition(firstMillis, next.getNameKey(),</b>
&nbsp;                                               iStandardOffset, iStandardOffset);
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
&nbsp;                
&nbsp;                // Set first to the best transition found so far, but next
&nbsp;                // iteration may find something closer to lower limit.
<b class="nc">&nbsp;                first = new Transition(firstMillis, next);</b>
&nbsp;
<b class="nc">&nbsp;                saveMillis = next.getSaveMillis();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            iRules = copy;</b>
<b class="nc">&nbsp;            return first;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns null if RuleSet is exhausted or upper limit reached. Calling
&nbsp;         * this method will throw away rules as they each become
&nbsp;         * exhausted. Copy the RuleSet before using it to compute transitions.
&nbsp;         *
&nbsp;         * Returned transition may be a duplicate from previous
&nbsp;         * transition. Caller must call isTransitionFrom to filter out
&nbsp;         * duplicates.
&nbsp;         *
&nbsp;         * @param saveMillis savings before next transition
&nbsp;         */
&nbsp;        public Transition nextTransition(final long instant, final int saveMillis) {
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
&nbsp;
&nbsp;            // Find next matching rule.
<b class="nc">&nbsp;            Rule nextRule = null;</b>
<b class="nc">&nbsp;            long nextMillis = Long.MAX_VALUE;</b>
&nbsp;            
<b class="nc">&nbsp;            Iterator&lt;Rule&gt; it = iRules.iterator();</b>
<b class="nc">&nbsp;            while (it.hasNext()) {</b>
<b class="nc">&nbsp;                Rule rule = it.next();</b>
<b class="nc">&nbsp;                long next = rule.next(instant, iStandardOffset, saveMillis);</b>
<b class="nc">&nbsp;                if (next &lt;= instant) {</b>
<b class="nc">&nbsp;                    it.remove();</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Even if next is same as previous next, choose the rule
&nbsp;                // in order for more recently added rules to override.
<b class="nc">&nbsp;                if (next &lt;= nextMillis) {</b>
&nbsp;                    // Found a better match.
<b class="nc">&nbsp;                    nextRule = rule;</b>
<b class="nc">&nbsp;                    nextMillis = next;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            
<b class="nc">&nbsp;            if (nextRule == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Stop precalculating if year reaches some arbitrary limit.
<b class="nc">&nbsp;            if (chrono.year().get(nextMillis) &gt;= YEAR_LIMIT) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Check if upper limit reached or passed.
<b class="nc">&nbsp;            if (iUpperYear &lt; Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                long upperMillis =</b>
<b class="nc">&nbsp;                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</b>
<b class="nc">&nbsp;                if (nextMillis &gt;= upperMillis) {</b>
&nbsp;                    // At or after upper limit.
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return new Transition(nextMillis, nextRule, iStandardOffset);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param saveMillis savings before upper limit
&nbsp;         */
&nbsp;        public long getUpperLimit(int saveMillis) {
<b class="nc">&nbsp;            if (iUpperYear == Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                return Long.MAX_VALUE;</b>
&nbsp;            }
<b class="nc">&nbsp;            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns null if none can be built.
&nbsp;         */
&nbsp;        public DSTZone buildTailZone(String id) {
<b class="nc">&nbsp;            if (iRules.size() == 2) {</b>
<b class="nc">&nbsp;                Rule startRule = iRules.get(0);</b>
<b class="nc">&nbsp;                Rule endRule = iRules.get(1);</b>
<b class="nc">&nbsp;                if (startRule.getToYear() == Integer.MAX_VALUE &amp;&amp;</b>
<b class="nc">&nbsp;                    endRule.getToYear() == Integer.MAX_VALUE) {</b>
&nbsp;
&nbsp;                    // With exactly two infinitely recurring rules left, a
&nbsp;                    // simple DSTZone can be formed.
&nbsp;
&nbsp;                    // The order of rules can come in any order, and it doesn&#39;t
&nbsp;                    // really matter which rule was chosen the &#39;start&#39; and
&nbsp;                    // which is chosen the &#39;end&#39;. DSTZone works properly either
&nbsp;                    // way.
<b class="nc">&nbsp;                    return new DSTZone(id, iStandardOffset,</b>
&nbsp;                                       startRule.iRecurrence, endRule.iRecurrence);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class DSTZone extends DateTimeZone {
&nbsp;        private static final long serialVersionUID = 6941492635554961361L;
&nbsp;
&nbsp;        static DSTZone readFrom(DataInput in, String id) throws IOException {
<b class="nc">&nbsp;            return new DSTZone(id, (int)readMillis(in), </b>
<b class="nc">&nbsp;                               Recurrence.readFrom(in), Recurrence.readFrom(in));</b>
&nbsp;        }
&nbsp;
&nbsp;        final int iStandardOffset;
&nbsp;        final Recurrence iStartRecurrence;
&nbsp;        final Recurrence iEndRecurrence;
&nbsp;
&nbsp;        DSTZone(String id, int standardOffset,
&nbsp;                Recurrence startRecurrence, Recurrence endRecurrence) {
<b class="nc">&nbsp;            super(id);</b>
<b class="nc">&nbsp;            iStandardOffset = standardOffset;</b>
<b class="nc">&nbsp;            iStartRecurrence = startRecurrence;</b>
<b class="nc">&nbsp;            iEndRecurrence = endRecurrence;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getNameKey(long instant) {
<b class="nc">&nbsp;            return findMatchingRecurrence(instant).getNameKey();</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getOffset(long instant) {
<b class="nc">&nbsp;            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getStandardOffset(long instant) {
<b class="nc">&nbsp;            return iStandardOffset;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isFixed() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public long nextTransition(long instant) {
<b class="nc">&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="nc">&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="nc">&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
&nbsp;
&nbsp;            long start, end;
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                start = startRecurrence.next</b>
<b class="nc">&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;                if (instant &gt; 0 &amp;&amp; start &lt; 0) {</b>
&nbsp;                    // Overflowed.
<b class="nc">&nbsp;                    start = instant;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                end = endRecurrence.next</b>
<b class="nc">&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;                if (instant &gt; 0 &amp;&amp; end &lt; 0) {</b>
&nbsp;                    // Overflowed.
<b class="nc">&nbsp;                    end = instant;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return (start &gt; end) ? end : start;</b>
&nbsp;        }
&nbsp;
&nbsp;        public long previousTransition(long instant) {
&nbsp;            // Increment in order to handle the case where instant is exactly at
&nbsp;            // a transition.
<b class="nc">&nbsp;            instant++;</b>
&nbsp;
<b class="nc">&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="nc">&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="nc">&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
&nbsp;
&nbsp;            long start, end;
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                start = startRecurrence.previous</b>
<b class="nc">&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;                if (instant &lt; 0 &amp;&amp; start &gt; 0) {</b>
&nbsp;                    // Overflowed.
<b class="nc">&nbsp;                    start = instant;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                end = endRecurrence.previous</b>
<b class="nc">&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;                if (instant &lt; 0 &amp;&amp; end &gt; 0) {</b>
&nbsp;                    // Overflowed.
<b class="nc">&nbsp;                    end = instant;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return ((start &gt; end) ? start : end) - 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object obj) {
<b class="nc">&nbsp;            if (this == obj) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (obj instanceof DSTZone) {</b>
<b class="nc">&nbsp;                DSTZone other = (DSTZone)obj;</b>
<b class="nc">&nbsp;                return</b>
<b class="nc">&nbsp;                    getID().equals(other.getID()) &amp;&amp;</b>
&nbsp;                    iStandardOffset == other.iStandardOffset &amp;&amp;
<b class="nc">&nbsp;                    iStartRecurrence.equals(other.iStartRecurrence) &amp;&amp;</b>
<b class="nc">&nbsp;                    iEndRecurrence.equals(other.iEndRecurrence);</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="nc">&nbsp;            writeMillis(out, iStandardOffset);</b>
<b class="nc">&nbsp;            iStartRecurrence.writeTo(out);</b>
<b class="nc">&nbsp;            iEndRecurrence.writeTo(out);</b>
&nbsp;        }
&nbsp;
&nbsp;        private Recurrence findMatchingRecurrence(long instant) {
<b class="nc">&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="nc">&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="nc">&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
&nbsp;
&nbsp;            long start, end;
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                start = startRecurrence.next</b>
<b class="nc">&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                start = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                end = endRecurrence.next</b>
<b class="nc">&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            } catch (ArithmeticException e) {</b>
&nbsp;                // Overflowed.
<b class="nc">&nbsp;                end = instant;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return (start &gt; end) ? startRecurrence : endRecurrence;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class PrecalculatedZone extends DateTimeZone {
&nbsp;        private static final long serialVersionUID = 7811976468055766265L;
&nbsp;
&nbsp;        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {
&nbsp;            // Read string pool.
<b class="nc">&nbsp;            int poolSize = in.readUnsignedShort();</b>
<b class="nc">&nbsp;            String[] pool = new String[poolSize];</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;poolSize; i++) {</b>
<b class="nc">&nbsp;                pool[i] = in.readUTF();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int size = in.readInt();</b>
<b class="nc">&nbsp;            long[] transitions = new long[size];</b>
<b class="nc">&nbsp;            int[] wallOffsets = new int[size];</b>
<b class="nc">&nbsp;            int[] standardOffsets = new int[size];</b>
<b class="nc">&nbsp;            String[] nameKeys = new String[size];</b>
&nbsp;            
<b class="nc">&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="nc">&nbsp;                transitions[i] = readMillis(in);</b>
<b class="nc">&nbsp;                wallOffsets[i] = (int)readMillis(in);</b>
<b class="nc">&nbsp;                standardOffsets[i] = (int)readMillis(in);</b>
&nbsp;                try {
&nbsp;                    int index;
<b class="nc">&nbsp;                    if (poolSize &lt; 256) {</b>
<b class="nc">&nbsp;                        index = in.readUnsignedByte();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        index = in.readUnsignedShort();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    nameKeys[i] = pool[index];</b>
<b class="nc">&nbsp;                } catch (ArrayIndexOutOfBoundsException e) {</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Invalid encoding&quot;);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            DSTZone tailZone = null;</b>
<b class="nc">&nbsp;            if (in.readBoolean()) {</b>
<b class="nc">&nbsp;                tailZone = DSTZone.readFrom(in, id);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return new PrecalculatedZone</b>
&nbsp;                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Factory to create instance from builder.
&nbsp;         * 
&nbsp;         * @param id  the zone id
&nbsp;         * @param outputID  true if the zone id should be output
&nbsp;         * @param transitions  the list of Transition objects
&nbsp;         * @param tailZone  optional zone for getting info beyond precalculated tables
&nbsp;         */
&nbsp;        static PrecalculatedZone create(String id, boolean outputID, ArrayList&lt;Transition&gt; transitions,
&nbsp;                                        DSTZone tailZone) {
<b class="nc">&nbsp;            int size = transitions.size();</b>
<b class="nc">&nbsp;            if (size == 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            long[] trans = new long[size];</b>
<b class="nc">&nbsp;            int[] wallOffsets = new int[size];</b>
<b class="nc">&nbsp;            int[] standardOffsets = new int[size];</b>
<b class="nc">&nbsp;            String[] nameKeys = new String[size];</b>
&nbsp;
<b class="nc">&nbsp;            Transition last = null;</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="nc">&nbsp;                Transition tr = transitions.get(i);</b>
&nbsp;
<b class="nc">&nbsp;                if (!tr.isTransitionFrom(last)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(id);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                trans[i] = tr.getMillis();</b>
<b class="nc">&nbsp;                wallOffsets[i] = tr.getWallOffset();</b>
<b class="nc">&nbsp;                standardOffsets[i] = tr.getStandardOffset();</b>
<b class="nc">&nbsp;                nameKeys[i] = tr.getNameKey();</b>
&nbsp;
<b class="nc">&nbsp;                last = tr;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Some timezones (Australia) have the same name key for
&nbsp;            // summer and winter which messes everything up. Fix it here.
<b class="nc">&nbsp;            String[] zoneNameData = new String[5];</b>
<b class="nc">&nbsp;            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; zoneStrings.length; j++) {</b>
<b class="nc">&nbsp;                String[] set = zoneStrings[j];</b>
<b class="nc">&nbsp;                if (set != null &amp;&amp; set.length == 5 &amp;&amp; id.equals(set[0])) {</b>
<b class="nc">&nbsp;                    zoneNameData = set;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = 0; i &lt; nameKeys.length - 1; i++) {</b>
<b class="nc">&nbsp;                String curNameKey = nameKeys[i];</b>
<b class="nc">&nbsp;                String nextNameKey = nameKeys[i + 1];</b>
<b class="nc">&nbsp;                long curOffset = wallOffsets[i];</b>
<b class="nc">&nbsp;                long nextOffset = wallOffsets[i + 1];</b>
<b class="nc">&nbsp;                long curStdOffset = standardOffsets[i];</b>
<b class="nc">&nbsp;                long nextStdOffset = standardOffsets[i + 1];</b>
<b class="nc">&nbsp;                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);</b>
<b class="nc">&nbsp;                if (curOffset != nextOffset &amp;&amp;</b>
&nbsp;                        curStdOffset == nextStdOffset &amp;&amp;
<b class="nc">&nbsp;                        curNameKey.equals(nextNameKey) &amp;&amp;</b>
<b class="nc">&nbsp;                        p.getYears() == 0 &amp;&amp; p.getMonths() &gt; 4 &amp;&amp; p.getMonths() &lt; 8 &amp;&amp;</b>
<b class="nc">&nbsp;                        curNameKey.equals(zoneNameData[2]) &amp;&amp;</b>
<b class="nc">&nbsp;                        curNameKey.equals(zoneNameData[4])) {</b>
&nbsp;                    
<b class="nc">&nbsp;                    if (ZoneInfoCompiler.verbose()) {</b>
<b class="nc">&nbsp;                        System.out.println(&quot;Fixing duplicate name key - &quot; + nextNameKey);</b>
<b class="nc">&nbsp;                        System.out.println(&quot;     - &quot; + new DateTime(trans[i], chrono) +</b>
&nbsp;                                           &quot; - &quot; + new DateTime(trans[i + 1], chrono));
&nbsp;                    }
<b class="nc">&nbsp;                    if (curOffset &gt; nextOffset) {</b>
<b class="nc">&nbsp;                        nameKeys[i] = (curNameKey + &quot;-Summer&quot;).intern();</b>
<b class="nc">&nbsp;                    } else if (curOffset &lt; nextOffset) {</b>
<b class="nc">&nbsp;                        nameKeys[i + 1] = (nextNameKey + &quot;-Summer&quot;).intern();</b>
<b class="nc">&nbsp;                        i++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (tailZone != null) {</b>
<b class="nc">&nbsp;                if (tailZone.iStartRecurrence.getNameKey()</b>
<b class="nc">&nbsp;                    .equals(tailZone.iEndRecurrence.getNameKey())) {</b>
<b class="nc">&nbsp;                    if (ZoneInfoCompiler.verbose()) {</b>
<b class="nc">&nbsp;                        System.out.println(&quot;Fixing duplicate recurrent name key - &quot; +</b>
<b class="nc">&nbsp;                                           tailZone.iStartRecurrence.getNameKey());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (tailZone.iStartRecurrence.getSaveMillis() &gt; 0) {</b>
<b class="nc">&nbsp;                        tailZone = new DSTZone(</b>
<b class="nc">&nbsp;                            tailZone.getID(),</b>
&nbsp;                            tailZone.iStandardOffset,
<b class="nc">&nbsp;                            tailZone.iStartRecurrence.renameAppend(&quot;-Summer&quot;),</b>
&nbsp;                            tailZone.iEndRecurrence);
&nbsp;                    } else {
<b class="nc">&nbsp;                        tailZone = new DSTZone(</b>
<b class="nc">&nbsp;                            tailZone.getID(),</b>
&nbsp;                            tailZone.iStandardOffset,
&nbsp;                            tailZone.iStartRecurrence,
<b class="nc">&nbsp;                            tailZone.iEndRecurrence.renameAppend(&quot;-Summer&quot;));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return new PrecalculatedZone</b>
&nbsp;                ((outputID ? id : &quot;&quot;), trans, wallOffsets, standardOffsets, nameKeys, tailZone);
&nbsp;        }
&nbsp;
&nbsp;        // All array fields have the same length.
&nbsp;
&nbsp;        private final long[] iTransitions;
&nbsp;
&nbsp;        private final int[] iWallOffsets;
&nbsp;        private final int[] iStandardOffsets;
&nbsp;        private final String[] iNameKeys;
&nbsp;
&nbsp;        private final DSTZone iTailZone;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor used ONLY for valid input, loaded via static methods.
&nbsp;         */
&nbsp;        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,
&nbsp;                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)
&nbsp;        {
<b class="nc">&nbsp;            super(id);</b>
<b class="nc">&nbsp;            iTransitions = transitions;</b>
<b class="nc">&nbsp;            iWallOffsets = wallOffsets;</b>
<b class="nc">&nbsp;            iStandardOffsets = standardOffsets;</b>
<b class="nc">&nbsp;            iNameKeys = nameKeys;</b>
<b class="nc">&nbsp;            iTailZone = tailZone;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getNameKey(long instant) {
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="nc">&nbsp;            if (i &gt;= 0) {</b>
<b class="nc">&nbsp;                return iNameKeys[i];</b>
&nbsp;            }
<b class="nc">&nbsp;            i = ~i;</b>
<b class="nc">&nbsp;            if (i &lt; transitions.length) {</b>
<b class="nc">&nbsp;                if (i &gt; 0) {</b>
<b class="nc">&nbsp;                    return iNameKeys[i - 1];</b>
&nbsp;                }
<b class="nc">&nbsp;                return &quot;UTC&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iTailZone == null) {</b>
<b class="nc">&nbsp;                return iNameKeys[i - 1];</b>
&nbsp;            }
<b class="nc">&nbsp;            return iTailZone.getNameKey(instant);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getOffset(long instant) {
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="nc">&nbsp;            if (i &gt;= 0) {</b>
<b class="nc">&nbsp;                return iWallOffsets[i];</b>
&nbsp;            }
<b class="nc">&nbsp;            i = ~i;</b>
<b class="nc">&nbsp;            if (i &lt; transitions.length) {</b>
<b class="nc">&nbsp;                if (i &gt; 0) {</b>
<b class="nc">&nbsp;                    return iWallOffsets[i - 1];</b>
&nbsp;                }
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iTailZone == null) {</b>
<b class="nc">&nbsp;                return iWallOffsets[i - 1];</b>
&nbsp;            }
<b class="nc">&nbsp;            return iTailZone.getOffset(instant);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getStandardOffset(long instant) {
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="nc">&nbsp;            if (i &gt;= 0) {</b>
<b class="nc">&nbsp;                return iStandardOffsets[i];</b>
&nbsp;            }
<b class="nc">&nbsp;            i = ~i;</b>
<b class="nc">&nbsp;            if (i &lt; transitions.length) {</b>
<b class="nc">&nbsp;                if (i &gt; 0) {</b>
<b class="nc">&nbsp;                    return iStandardOffsets[i - 1];</b>
&nbsp;                }
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iTailZone == null) {</b>
<b class="nc">&nbsp;                return iStandardOffsets[i - 1];</b>
&nbsp;            }
<b class="nc">&nbsp;            return iTailZone.getStandardOffset(instant);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isFixed() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public long nextTransition(long instant) {
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="nc">&nbsp;            i = (i &gt;= 0) ? (i + 1) : ~i;</b>
<b class="nc">&nbsp;            if (i &lt; transitions.length) {</b>
<b class="nc">&nbsp;                return transitions[i];</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iTailZone == null) {</b>
<b class="nc">&nbsp;                return instant;</b>
&nbsp;            }
<b class="nc">&nbsp;            long end = transitions[transitions.length - 1];</b>
<b class="nc">&nbsp;            if (instant &lt; end) {</b>
<b class="nc">&nbsp;                instant = end;</b>
&nbsp;            }
<b class="nc">&nbsp;            return iTailZone.nextTransition(instant);</b>
&nbsp;        }
&nbsp;
&nbsp;        public long previousTransition(long instant) {
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="nc">&nbsp;            if (i &gt;= 0) {</b>
<b class="nc">&nbsp;                if (instant &gt; Long.MIN_VALUE) {</b>
<b class="nc">&nbsp;                    return instant - 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                return instant;</b>
&nbsp;            }
<b class="nc">&nbsp;            i = ~i;</b>
<b class="nc">&nbsp;            if (i &lt; transitions.length) {</b>
<b class="nc">&nbsp;                if (i &gt; 0) {</b>
<b class="nc">&nbsp;                    long prev = transitions[i - 1];</b>
<b class="nc">&nbsp;                    if (prev &gt; Long.MIN_VALUE) {</b>
<b class="nc">&nbsp;                        return prev - 1;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return instant;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (iTailZone != null) {</b>
<b class="nc">&nbsp;                long prev = iTailZone.previousTransition(instant);</b>
<b class="nc">&nbsp;                if (prev &lt; instant) {</b>
<b class="nc">&nbsp;                    return prev;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            long prev = transitions[i - 1];</b>
<b class="nc">&nbsp;            if (prev &gt; Long.MIN_VALUE) {</b>
<b class="nc">&nbsp;                return prev - 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            return instant;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object obj) {
<b class="nc">&nbsp;            if (this == obj) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (obj instanceof PrecalculatedZone) {</b>
<b class="nc">&nbsp;                PrecalculatedZone other = (PrecalculatedZone)obj;</b>
<b class="nc">&nbsp;                return</b>
<b class="nc">&nbsp;                    getID().equals(other.getID()) &amp;&amp;</b>
<b class="nc">&nbsp;                    Arrays.equals(iTransitions, other.iTransitions) &amp;&amp;</b>
<b class="nc">&nbsp;                    Arrays.equals(iNameKeys, other.iNameKeys) &amp;&amp;</b>
<b class="nc">&nbsp;                    Arrays.equals(iWallOffsets, other.iWallOffsets) &amp;&amp;</b>
<b class="nc">&nbsp;                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &amp;&amp;</b>
&nbsp;                    ((iTailZone == null)
&nbsp;                     ? (null == other.iTailZone)
<b class="nc">&nbsp;                     : (iTailZone.equals(other.iTailZone)));</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="nc">&nbsp;            int size = iTransitions.length;</b>
&nbsp;
&nbsp;            // Create unique string pool.
<b class="nc">&nbsp;            Set&lt;String&gt; poolSet = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="nc">&nbsp;                poolSet.add(iNameKeys[i]);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int poolSize = poolSet.size();</b>
<b class="nc">&nbsp;            if (poolSize &gt; 65535) {</b>
<b class="nc">&nbsp;                throw new UnsupportedOperationException(&quot;String pool is too large&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            String[] pool = new String[poolSize];</b>
<b class="nc">&nbsp;            Iterator&lt;String&gt; it = poolSet.iterator();</b>
<b class="nc">&nbsp;            for (int i=0; it.hasNext(); i++) {</b>
<b class="nc">&nbsp;                pool[i] = it.next();</b>
&nbsp;            }
&nbsp;
&nbsp;            // Write out the pool.
<b class="nc">&nbsp;            out.writeShort(poolSize);</b>
<b class="nc">&nbsp;            for (int i=0; i&lt;poolSize; i++) {</b>
<b class="nc">&nbsp;                out.writeUTF(pool[i]);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            out.writeInt(size);</b>
&nbsp;
<b class="nc">&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="nc">&nbsp;                writeMillis(out, iTransitions[i]);</b>
<b class="nc">&nbsp;                writeMillis(out, iWallOffsets[i]);</b>
<b class="nc">&nbsp;                writeMillis(out, iStandardOffsets[i]);</b>
&nbsp;                
&nbsp;                // Find pool index and write it out.
<b class="nc">&nbsp;                String nameKey = iNameKeys[i];</b>
<b class="nc">&nbsp;                for (int j=0; j&lt;poolSize; j++) {</b>
<b class="nc">&nbsp;                    if (pool[j].equals(nameKey)) {</b>
<b class="nc">&nbsp;                        if (poolSize &lt; 256) {</b>
<b class="nc">&nbsp;                            out.writeByte(j);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            out.writeShort(j);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            out.writeBoolean(iTailZone != null);</b>
<b class="nc">&nbsp;            if (iTailZone != null) {</b>
<b class="nc">&nbsp;                iTailZone.writeTo(out);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isCachable() {
<b class="nc">&nbsp;            if (iTailZone != null) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            long[] transitions = iTransitions;</b>
<b class="nc">&nbsp;            if (transitions.length &lt;= 1) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add up all the distances between transitions that are less than
&nbsp;            // about two years.
<b class="nc">&nbsp;            double distances = 0;</b>
<b class="nc">&nbsp;            int count = 0;</b>
&nbsp;
<b class="nc">&nbsp;            for (int i=1; i&lt;transitions.length; i++) {</b>
<b class="nc">&nbsp;                long diff = transitions[i] - transitions[i - 1];</b>
<b class="nc">&nbsp;                if (diff &lt; ((366L + 365) * 24 * 60 * 60 * 1000)) {</b>
<b class="nc">&nbsp;                    distances += (double)diff;</b>
<b class="nc">&nbsp;                    count++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (count &gt; 0) {</b>
<b class="nc">&nbsp;                double avg = distances / count;</b>
<b class="nc">&nbsp;                avg /= 24 * 60 * 60 * 1000;</b>
<b class="nc">&nbsp;                if (avg &gt;= 25) {</b>
&nbsp;                    // Only bother caching if average distance between
&nbsp;                    // transitions is at least 25 days. Why 25?
&nbsp;                    // CachedDateTimeZone is more efficient if the distance
&nbsp;                    // between transitions is large. With an average of 25, it
&nbsp;                    // will on average perform about 2 tests per cache
&nbsp;                    // hit. (49.7 / 25) is approximately 2.
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 10:47</div>
</div>
</body>
</html>
