


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JSONWriterJSONB</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.alibaba.fastjson2</a>
</div>

<h1>Coverage Summary for Class: JSONWriterJSONB (com.alibaba.fastjson2)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JSONWriterJSONB</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/94)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1047)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.alibaba.fastjson2;
&nbsp;
&nbsp;import com.alibaba.fastjson2.internal.trove.map.hash.TLongIntHashMap;
&nbsp;import com.alibaba.fastjson2.util.Fnv;
&nbsp;import com.alibaba.fastjson2.util.IOUtils;
&nbsp;import com.alibaba.fastjson2.util.JDKUtils;
&nbsp;import com.alibaba.fastjson2.util.UnsafeUtils;
&nbsp;import com.alibaba.fastjson2.writer.ObjectWriter;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.time.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static com.alibaba.fastjson2.JSONB.Constants.*;
&nbsp;import static com.alibaba.fastjson2.JSONFactory.*;
&nbsp;import static com.alibaba.fastjson2.JSONWriter.Feature.WriteNameAsSymbol;
&nbsp;import static com.alibaba.fastjson2.util.DateUtils.OFFSET_8_ZONE_ID_NAME;
&nbsp;import static com.alibaba.fastjson2.util.DateUtils.SHANGHAI_ZONE_ID_NAME;
&nbsp;import static com.alibaba.fastjson2.util.JDKUtils.*;
&nbsp;import static com.alibaba.fastjson2.util.TypeUtils.*;
&nbsp;
&nbsp;final class JSONWriterJSONB
&nbsp;        extends JSONWriter {
&nbsp;    // optimize for write ZonedDateTime
<b class="nc">&nbsp;    static final byte[] SHANGHAI_ZONE_ID_NAME_BYTES = JSONB.toBytes(SHANGHAI_ZONE_ID_NAME);</b>
<b class="nc">&nbsp;    static final byte[] OFFSET_8_ZONE_ID_NAME_BYTES = JSONB.toBytes(OFFSET_8_ZONE_ID_NAME);</b>
&nbsp;
&nbsp;    private final CacheItem cacheItem;
&nbsp;    private byte[] bytes;
&nbsp;    private TLongIntHashMap symbols;
&nbsp;    private int symbolIndex;
&nbsp;
&nbsp;    private long rootTypeNameHash;
&nbsp;
&nbsp;    JSONWriterJSONB(Context ctx, SymbolTable symbolTable) {
<b class="nc">&nbsp;        super(ctx, symbolTable, true, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;        cacheItem = CACHE_ITEMS[System.identityHashCode(Thread.currentThread()) &amp; (CACHE_ITEMS.length - 1)];</b>
<b class="nc">&nbsp;        byte[] bytes = BYTES_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;        if (bytes == null) {</b>
<b class="nc">&nbsp;            bytes = new byte[8192];</b>
&nbsp;        }
<b class="nc">&nbsp;        this.bytes = bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        if (bytes.length &lt; CACHE_THRESHOLD) {</b>
<b class="nc">&nbsp;            BYTES_UPDATER.lazySet(cacheItem, bytes);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeAny(Object value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean fieldBased = (context.features &amp; Feature.FieldBased.mask) != 0;</b>
&nbsp;
<b class="nc">&nbsp;        Class&lt;?&gt; valueClass = value.getClass();</b>
<b class="nc">&nbsp;        ObjectWriter objectWriter = context.provider.getObjectWriter(valueClass, valueClass, fieldBased);</b>
&nbsp;
<b class="nc">&nbsp;        if (isBeanToArray()) {</b>
<b class="nc">&nbsp;            objectWriter.writeArrayMappingJSONB(this, value, null, null, 0);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            objectWriter.writeJSONB(this, value, null, null, 0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void startObject() {
<b class="nc">&nbsp;        if (level &gt;= context.maxLevel) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;level too large : &quot; + level);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        level++;</b>
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off] = BC_OBJECT;</b>
<b class="nc">&nbsp;        this.off = off + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void endObject() {
<b class="nc">&nbsp;        level--;</b>
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off] = BC_OBJECT_END;</b>
<b class="nc">&nbsp;        this.off = off + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void startArray() {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void startArray(Object array, int size) {
<b class="nc">&nbsp;        if (isWriteTypeInfo(array)) {</b>
<b class="nc">&nbsp;            writeTypeName(array.getClass().getName());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        level++;</b>
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        boolean tinyInt = size &lt;= ARRAY_FIX_LEN;</b>
<b class="nc">&nbsp;        bytes[off] = tinyInt ? (byte) (BC_ARRAY_FIX_MIN + size) : BC_ARRAY;</b>
<b class="nc">&nbsp;        this.off = off + 1;</b>
<b class="nc">&nbsp;        if (!tinyInt) {</b>
<b class="nc">&nbsp;            writeInt32(size);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void startArray(int size) {
<b class="nc">&nbsp;        level++;</b>
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        boolean tinyInt = size &lt;= ARRAY_FIX_LEN;</b>
<b class="nc">&nbsp;        bytes[off] = tinyInt ? (byte) (BC_ARRAY_FIX_MIN + size) : BC_ARRAY;</b>
<b class="nc">&nbsp;        this.off = off + 1;</b>
<b class="nc">&nbsp;        if (!tinyInt) {</b>
<b class="nc">&nbsp;            writeInt32(size);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeRaw(byte b) {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off++] = b;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeChar(char ch) {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off++] = BC_CHAR;</b>
<b class="nc">&nbsp;        writeInt32(ch);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeName(String name) {
<b class="nc">&nbsp;        writeString(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeNull() {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off++] = BC_NULL;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeStringNull() {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off++] = BC_NULL;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void endArray() {
<b class="nc">&nbsp;        level--;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeComma() {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void write0(char ch) {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeString(char[] chars, int off, int len, boolean quote) {
<b class="nc">&nbsp;        if (chars == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean ascii = true;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;            if (chars[i + off] &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                ascii = false;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ascii) {</b>
<b class="nc">&nbsp;            if (len &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (len + BC_STR_ASCII_FIX_MIN);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                bytes[this.off++] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;                writeInt32(len);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int i = 0; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) chars[off + i];</b>
&nbsp;            }
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeString(new String(chars, off, len));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void writeStringLatin1(final byte[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeStringNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int strlen = value.length;</b>
<b class="nc">&nbsp;        int minCapacity = value.length</b>
&nbsp;                + off
&nbsp;                + 5 /*max str len*/
&nbsp;                + 1;
&nbsp;
<b class="nc">&nbsp;        if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        if (strlen &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;            bytes[off++] = (byte) (strlen + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;        } else if (strlen &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            putStringSizeSmall(bytes, off, strlen);</b>
<b class="nc">&nbsp;            off += 3;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            off += putStringSizeLarge(bytes, off, strlen);</b>
&nbsp;        }
<b class="nc">&nbsp;        System.arraycopy(value, 0, bytes, off, value.length);</b>
<b class="nc">&nbsp;        this.off = off + strlen;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void putStringSizeSmall(byte[] bytes, int off, int val) {
<b class="nc">&nbsp;        bytes[off] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (BC_INT32_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (val);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int putStringSizeLarge(byte[] bytes, int off, int strlen) {
<b class="nc">&nbsp;        if (strlen &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;            putInt3(bytes, off + 1, strlen);</b>
<b class="nc">&nbsp;            return 4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bytes[off] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;        bytes[off + 1] = BC_INT32;</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (strlen &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) (strlen &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) (strlen &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) strlen;</b>
<b class="nc">&nbsp;        return 6;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeString(final char[] chars) {
<b class="nc">&nbsp;        if (chars == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        boolean ascii = true;</b>
<b class="nc">&nbsp;        int strlen = chars.length;</b>
<b class="nc">&nbsp;        if (chars.length &lt; STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;            int minCapacity = off + 1 + strlen;</b>
<b class="nc">&nbsp;            if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;                ensureCapacity(minCapacity);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            bytes[off++] = (byte) (strlen + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;            for (char ch : chars) {</b>
<b class="nc">&nbsp;                if (ch &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                    ascii = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                bytes[off++] = (byte) ch;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (ascii) {</b>
<b class="nc">&nbsp;                this.off = off;</b>
&nbsp;                return;
&nbsp;            } else {
<b class="nc">&nbsp;                off = this.off;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        {
<b class="nc">&nbsp;            int i = 0;</b>
<b class="nc">&nbsp;            int upperBound = chars.length &amp; ~3;</b>
<b class="nc">&nbsp;            for (; i &lt; upperBound; i += 4) {</b>
<b class="nc">&nbsp;                char c0 = chars[i];</b>
<b class="nc">&nbsp;                char c1 = chars[i + 1];</b>
<b class="nc">&nbsp;                char c2 = chars[i + 2];</b>
<b class="nc">&nbsp;                char c3 = chars[i + 3];</b>
<b class="nc">&nbsp;                if (c0 &gt; 0x00FF || c1 &gt; 0x00FF || c2 &gt; 0x00FF || c3 &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                    ascii = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (ascii) {</b>
<b class="nc">&nbsp;                for (; i &lt; chars.length; ++i) {</b>
<b class="nc">&nbsp;                    if (chars[i] &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                        ascii = false;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int minCapacity = (ascii ? strlen : strlen * 3)</b>
&nbsp;                + off
&nbsp;                + 5 /*max str len*/
&nbsp;                + 1;
&nbsp;
<b class="nc">&nbsp;        if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ascii) {</b>
<b class="nc">&nbsp;            if (strlen &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) (strlen + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;            } else if (strlen &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                putStringSizeSmall(bytes, off, strlen);</b>
<b class="nc">&nbsp;                off += 3;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                off += putStringSizeLarge(bytes, off, strlen);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (char aChar : chars) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) aChar;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            int maxSize = chars.length * 3;</b>
<b class="nc">&nbsp;            int lenByteCnt = sizeOfInt(maxSize);</b>
<b class="nc">&nbsp;            ensureCapacity(off + maxSize + lenByteCnt + 1);</b>
<b class="nc">&nbsp;            int result = IOUtils.encodeUTF8(chars, 0, chars.length, bytes, off + lenByteCnt + 1);</b>
&nbsp;
<b class="nc">&nbsp;            int utf8len = result - off - lenByteCnt - 1;</b>
<b class="nc">&nbsp;            int utf8lenByteCnt = sizeOfInt(utf8len);</b>
<b class="nc">&nbsp;            if (lenByteCnt != utf8lenByteCnt) {</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, off + lenByteCnt + 1, bytes, off + utf8lenByteCnt + 1, utf8len);</b>
&nbsp;            }
<b class="nc">&nbsp;            final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;            bytes[off++] = BC_STR_UTF8;</b>
<b class="nc">&nbsp;            if (utf8len &gt;= BC_INT32_NUM_MIN &amp;&amp; utf8len &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) utf8len;</b>
<b class="nc">&nbsp;            } else if (utf8len &gt;= INT32_BYTE_MIN &amp;&amp; utf8len &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                bytes[off] = (byte) (BC_INT32_BYTE_ZERO + (utf8len &gt;&gt; 8));</b>
<b class="nc">&nbsp;                bytes[off + 1] = (byte) (utf8len);</b>
<b class="nc">&nbsp;                off += 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                off += writeInt32(bytes, off, utf8len);</b>
&nbsp;            }
<b class="nc">&nbsp;            off += utf8len;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off = off;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeString(final char[] chars, final int off, final int len) {
<b class="nc">&nbsp;        if (chars == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean ascii = true;</b>
&nbsp;
<b class="nc">&nbsp;        if (len &lt; STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;            final int mark = this.off;</b>
&nbsp;
<b class="nc">&nbsp;            int minCapacity = this.off + 1 + len;</b>
<b class="nc">&nbsp;            if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;                ensureCapacity(minCapacity);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            bytes[this.off++] = (byte) (len + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;            for (int i = off; i &lt; len; i++) {</b>
<b class="nc">&nbsp;                char ch = chars[i];</b>
<b class="nc">&nbsp;                if (ch &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                    ascii = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                bytes[this.off++] = (byte) ch;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (ascii) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            this.off = mark;</b>
&nbsp;        }
&nbsp;
&nbsp;        {
<b class="nc">&nbsp;            int i = off;</b>
<b class="nc">&nbsp;            int upperBound = chars.length &amp; ~3;</b>
<b class="nc">&nbsp;            for (; i &lt; upperBound; i += 4) {</b>
<b class="nc">&nbsp;                char c0 = chars[i];</b>
<b class="nc">&nbsp;                char c1 = chars[i + 1];</b>
<b class="nc">&nbsp;                char c2 = chars[i + 2];</b>
<b class="nc">&nbsp;                char c3 = chars[i + 3];</b>
<b class="nc">&nbsp;                if (c0 &gt; 0x00FF || c1 &gt; 0x00FF || c2 &gt; 0x00FF || c3 &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                    ascii = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (ascii) {</b>
<b class="nc">&nbsp;                for (; i &lt; chars.length; ++i) {</b>
<b class="nc">&nbsp;                    if (chars[i] &gt; 0x00FF) {</b>
<b class="nc">&nbsp;                        ascii = false;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int minCapacity = (ascii ? len : len * 3)</b>
&nbsp;                + this.off
&nbsp;                + 5 /*max str len*/
&nbsp;                + 1;
&nbsp;
<b class="nc">&nbsp;        if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ascii) {</b>
<b class="nc">&nbsp;            if (len &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (len + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;            } else if (len &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (BC_INT32_BYTE_ZERO + (len &gt;&gt; 8));</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (len);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                bytes[this.off++] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;                writeInt32(len);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (char aChar : chars) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) aChar;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            int maxSize = chars.length * 3;</b>
<b class="nc">&nbsp;            int lenByteCnt = sizeOfInt(maxSize);</b>
<b class="nc">&nbsp;            ensureCapacity(this.off + maxSize + lenByteCnt + 1);</b>
<b class="nc">&nbsp;            int result = IOUtils.encodeUTF8(chars, 0, chars.length, bytes, this.off + lenByteCnt + 1);</b>
&nbsp;
<b class="nc">&nbsp;            int utf8len = result - this.off - lenByteCnt - 1;</b>
<b class="nc">&nbsp;            int utf8lenByteCnt = sizeOfInt(utf8len);</b>
<b class="nc">&nbsp;            if (lenByteCnt != utf8lenByteCnt) {</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, this.off + lenByteCnt + 1, bytes, this.off + utf8lenByteCnt + 1, utf8len);</b>
&nbsp;            }
<b class="nc">&nbsp;            bytes[this.off++] = BC_STR_UTF8;</b>
<b class="nc">&nbsp;            if (utf8len &gt;= BC_INT32_NUM_MIN &amp;&amp; utf8len &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) utf8len;</b>
<b class="nc">&nbsp;            } else if (utf8len &gt;= INT32_BYTE_MIN &amp;&amp; utf8len &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (BC_INT32_BYTE_ZERO + (utf8len &gt;&gt; 8));</b>
<b class="nc">&nbsp;                bytes[this.off++] = (byte) (utf8len);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                writeInt32(utf8len);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.off += utf8len;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void writeString(String[] strings) {
<b class="nc">&nbsp;        if (strings == null) {</b>
<b class="nc">&nbsp;            writeArrayNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        startArray(strings.length);</b>
<b class="nc">&nbsp;        for (String item : strings) {</b>
<b class="nc">&nbsp;            if (item == null) {</b>
<b class="nc">&nbsp;                if (isEnabled(Feature.NullAsDefaultValue.mask | Feature.WriteNullStringAsEmpty.mask)) {</b>
<b class="nc">&nbsp;                    writeString(&quot;&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    writeNull();</b>
&nbsp;                }
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            writeString(item);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeSymbol(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (symbolTable != null) {</b>
<b class="nc">&nbsp;            int ordinal = symbolTable.getOrdinal(str);</b>
<b class="nc">&nbsp;            if (ordinal &gt;= 0) {</b>
<b class="nc">&nbsp;                writeRaw(BC_SYMBOL);</b>
<b class="nc">&nbsp;                writeInt32(-ordinal);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeString(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeTypeName(String typeName) {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.bytes[off++] = BC_TYPED_ANY;</b>
&nbsp;
<b class="nc">&nbsp;        long hash = Fnv.hashCode64(typeName);</b>
&nbsp;
<b class="nc">&nbsp;        int symbol = -1;</b>
<b class="nc">&nbsp;        if (symbolTable != null) {</b>
<b class="nc">&nbsp;            symbol = symbolTable.getOrdinalByHashCode(hash);</b>
<b class="nc">&nbsp;            if (symbol == -1 &amp;&amp; symbols != null) {</b>
<b class="nc">&nbsp;                symbol = symbols.get(hash);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (symbols != null) {</b>
<b class="nc">&nbsp;            symbol = symbols.get(hash);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (symbol == -1) {</b>
<b class="nc">&nbsp;            if (symbols == null) {</b>
<b class="nc">&nbsp;                symbols = new TLongIntHashMap();</b>
&nbsp;            }
<b class="nc">&nbsp;            symbols.put(hash, symbol = symbolIndex++);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (off == bytes.length) {</b>
<b class="nc">&nbsp;                ensureCapacity(off + 1);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            writeInt32(symbol);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeString(typeName);</b>
<b class="nc">&nbsp;        writeInt32(symbol);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean writeTypeName(byte[] typeName, long hash) {
<b class="nc">&nbsp;        if (symbolTable != null) {</b>
<b class="nc">&nbsp;            int symbol = symbolTable.getOrdinalByHashCode(hash);</b>
<b class="nc">&nbsp;            if (symbol != -1) {</b>
<b class="nc">&nbsp;                return writeTypeNameSymbol(symbol);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean symbolExists = false;</b>
&nbsp;        int symbol;
<b class="nc">&nbsp;        if (rootTypeNameHash == hash) {</b>
<b class="nc">&nbsp;            symbolExists = true;</b>
<b class="nc">&nbsp;            symbol = 0;</b>
<b class="nc">&nbsp;        } else if (symbols != null) {</b>
<b class="nc">&nbsp;            symbol = symbols.putIfAbsent(hash, symbolIndex);</b>
<b class="nc">&nbsp;            if (symbol != symbolIndex) {</b>
<b class="nc">&nbsp;                symbolExists = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                symbolIndex++;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            symbol = symbolIndex++;</b>
<b class="nc">&nbsp;            if (symbol == 0) {</b>
<b class="nc">&nbsp;                rootTypeNameHash = hash;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (symbol != 0 || (context.features &amp; WriteNameAsSymbol.mask) != 0) {</b>
<b class="nc">&nbsp;                symbols = new TLongIntHashMap(hash, symbol);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (symbolExists) {</b>
<b class="nc">&nbsp;            writeTypeNameSymbol(-symbol);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 2 + typeName.length;</b>
<b class="nc">&nbsp;        if (minCapacity &gt; bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off++] = BC_TYPED_ANY;</b>
<b class="nc">&nbsp;        System.arraycopy(typeName, 0, bytes, off, typeName.length);</b>
<b class="nc">&nbsp;        off += typeName.length;</b>
<b class="nc">&nbsp;        if (symbol &gt;= BC_INT32_NUM_MIN &amp;&amp; symbol &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) symbol;</b>
<b class="nc">&nbsp;            this.off = off + 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.off = off;</b>
<b class="nc">&nbsp;            writeInt32(symbol);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean writeTypeNameSymbol(int symbol) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (off + 2 &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 2);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        this.bytes[off] = BC_TYPED_ANY;</b>
<b class="nc">&nbsp;        this.off = off + 1;</b>
<b class="nc">&nbsp;        writeInt32(-symbol);</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    static int sizeOfInt(int i) {
<b class="nc">&nbsp;        if (i &gt;= BC_INT32_NUM_MIN &amp;&amp; i &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (i &gt;= INT32_BYTE_MIN &amp;&amp; i &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (i &gt;= INT32_SHORT_MIN &amp;&amp; i &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            return 3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 5;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void writeString(List&lt;String&gt; list) {
<b class="nc">&nbsp;        if (list == null) {</b>
<b class="nc">&nbsp;            writeArrayNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int size = list.size();</b>
<b class="nc">&nbsp;        startArray(size);</b>
&nbsp;
<b class="nc">&nbsp;        if (STRING_VALUE != null &amp;&amp; STRING_CODER != null) {</b>
<b class="nc">&nbsp;            int mark = off;</b>
<b class="nc">&nbsp;            final int LATIN = 0;</b>
<b class="nc">&nbsp;            boolean latinAll = true;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; size; i++) {</b>
<b class="nc">&nbsp;                String str = list.get(i);</b>
<b class="nc">&nbsp;                if (str == null) {</b>
<b class="nc">&nbsp;                    writeNull();</b>
&nbsp;                }
<b class="nc">&nbsp;                int coder = STRING_CODER.applyAsInt(str);</b>
<b class="nc">&nbsp;                if (coder != LATIN) {</b>
<b class="nc">&nbsp;                    latinAll = false;</b>
<b class="nc">&nbsp;                    off = mark;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                int strlen = str.length();</b>
<b class="nc">&nbsp;                if (strlen &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                    bytes[off++] = (byte) (strlen + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;                } else if (strlen &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    bytes[off] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;                    bytes[off + 1] = (byte) (BC_INT32_BYTE_ZERO + (strlen &gt;&gt; 8));</b>
<b class="nc">&nbsp;                    bytes[off + 2] = (byte) (strlen);</b>
<b class="nc">&nbsp;                    off += 3;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    bytes[off++] = BC_STR_ASCII;</b>
<b class="nc">&nbsp;                    writeInt32(strlen);</b>
&nbsp;                }
<b class="nc">&nbsp;                byte[] value = STRING_VALUE.apply(str);</b>
<b class="nc">&nbsp;                System.arraycopy(value, 0, bytes, off, value.length);</b>
<b class="nc">&nbsp;                off += strlen;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (latinAll) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; size; i++) {</b>
<b class="nc">&nbsp;            String str = list.get(i);</b>
<b class="nc">&nbsp;            writeString(str);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeString(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (STRING_VALUE != null) {</b>
<b class="nc">&nbsp;            int coder = STRING_CODER.applyAsInt(str);</b>
<b class="nc">&nbsp;            byte[] value = STRING_VALUE.apply(str);</b>
&nbsp;
<b class="nc">&nbsp;            if (coder == 0) {</b>
<b class="nc">&nbsp;                int off = this.off;</b>
<b class="nc">&nbsp;                int strlen = value.length;</b>
<b class="nc">&nbsp;                int minCapacity = value.length + off + 6;</b>
&nbsp;
<b class="nc">&nbsp;                if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;                    ensureCapacity(minCapacity);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;                if (strlen &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                    bytes[off++] = (byte) (strlen + BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;                } else if (strlen &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    putStringSizeSmall(bytes, off, strlen);</b>
<b class="nc">&nbsp;                    off += 3;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    off += putStringSizeLarge(bytes, off, strlen);</b>
&nbsp;                }
<b class="nc">&nbsp;                System.arraycopy(value, 0, bytes, off, value.length);</b>
<b class="nc">&nbsp;                this.off = off + strlen;</b>
&nbsp;                return;
&nbsp;            } else {
<b class="nc">&nbsp;                if (tryWriteStringUTF16(value)) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeString(</b>
<b class="nc">&nbsp;                JDKUtils.getCharArray(str)</b>
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    public void writeStringUTF16(byte[] value) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        final int strlen = value.length;</b>
<b class="nc">&nbsp;        int minCapacity = off + strlen + 6;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off++] = JDKUtils.BIG_ENDIAN ? BC_STR_UTF16BE : BC_STR_UTF16LE;</b>
<b class="nc">&nbsp;        off += writeInt32(bytes, off, strlen);</b>
<b class="nc">&nbsp;        System.arraycopy(value, 0, bytes, off, strlen);</b>
<b class="nc">&nbsp;        this.off = off + strlen;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean tryWriteStringUTF16(byte[] value) {
<b class="nc">&nbsp;        int check_cnt = 128;</b>
<b class="nc">&nbsp;        if (check_cnt &gt; value.length) {</b>
<b class="nc">&nbsp;            check_cnt = value.length;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((check_cnt &amp; 1) == 1) {</b>
<b class="nc">&nbsp;            check_cnt -= 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int asciiCount = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i + 2 &lt;= check_cnt; i += 2) {</b>
<b class="nc">&nbsp;            byte b0 = value[i];</b>
<b class="nc">&nbsp;            byte b1 = value[i + 1];</b>
<b class="nc">&nbsp;            if (b0 == 0 || b1 == 0) {</b>
<b class="nc">&nbsp;                asciiCount++;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean utf16 = value.length != 0 &amp;&amp; (asciiCount == 0 || (check_cnt &gt;&gt; 1) / asciiCount &gt;= 3); // utf16字符占比&gt;=1/3</b>
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 6 + value.length * 2 + 1;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= this.bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        if (!utf16) {</b>
<b class="nc">&nbsp;            int maxSize = value.length + (value.length &gt;&gt; 2);</b>
<b class="nc">&nbsp;            int lenByteCnt = sizeOfInt(maxSize);</b>
<b class="nc">&nbsp;            int result = IOUtils.encodeUTF8(value, 0, value.length, bytes, off + lenByteCnt + 1);</b>
<b class="nc">&nbsp;            int utf8len = result - off - lenByteCnt - 1;</b>
<b class="nc">&nbsp;            if (utf8len &gt; value.length) {</b>
<b class="nc">&nbsp;                utf16 = true;</b>
<b class="nc">&nbsp;            } else if (result != -1) {</b>
<b class="nc">&nbsp;                this.off = off + writeUTF8(bytes, off, value, utf8len, asciiCount, lenByteCnt);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (utf16) {</b>
<b class="nc">&nbsp;            this.off = off + writeUTF16(bytes, off, value);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int writeUTF8(
&nbsp;            byte[] bytes,
&nbsp;            int off,
&nbsp;            byte[] value,
&nbsp;            int utf8len,
&nbsp;            int asciiCount,
&nbsp;            int lenByteCnt
&nbsp;    ) {
&nbsp;        final byte strtype;
<b class="nc">&nbsp;        if (utf8len * 2 == value.length) {</b>
<b class="nc">&nbsp;            if (asciiCount &lt;= STR_ASCII_FIX_LEN) {</b>
<b class="nc">&nbsp;                bytes[off] = (byte) (BC_STR_ASCII_FIX_MIN + utf8len);</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, off + 1 + lenByteCnt, bytes, off + 1, utf8len);</b>
<b class="nc">&nbsp;                return utf8len + 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            strtype = BC_STR_ASCII;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            strtype = BC_STR_UTF8;</b>
&nbsp;        }
<b class="nc">&nbsp;        int utf8lenByteCnt = sizeOfInt(utf8len);</b>
<b class="nc">&nbsp;        if (lenByteCnt != utf8lenByteCnt) {</b>
<b class="nc">&nbsp;            System.arraycopy(bytes, off + lenByteCnt + 1, bytes, off + utf8lenByteCnt + 1, utf8len);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off] = strtype;</b>
<b class="nc">&nbsp;        return writeInt32(bytes, off + 1, utf8len) + utf8len + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int writeUTF16(byte[] bytes, int off, byte[] value) {
<b class="nc">&nbsp;        bytes[off] = JDKUtils.BIG_ENDIAN ? BC_STR_UTF16BE : BC_STR_UTF16LE;</b>
<b class="nc">&nbsp;        int size = writeInt32(bytes, off + 1, value.length);</b>
<b class="nc">&nbsp;        System.arraycopy(value, 0, bytes, off + size + 1, value.length);</b>
<b class="nc">&nbsp;        return value.length + size + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    void ensureCapacity(int minCapacity) {
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            int oldCapacity = bytes.length;</b>
<b class="nc">&nbsp;            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</b>
<b class="nc">&nbsp;            if (newCapacity - minCapacity &lt; 0) {</b>
<b class="nc">&nbsp;                newCapacity = minCapacity;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (newCapacity &gt; maxArraySize) {</b>
<b class="nc">&nbsp;                throw new OutOfMemoryError();</b>
&nbsp;            }
&nbsp;
&nbsp;            // minCapacity is usually close to size, so this is a win:
<b class="nc">&nbsp;            bytes = Arrays.copyOf(bytes, newCapacity);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeMillis(long millis) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 9;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        if (millis % 1000 == 0) {</b>
<b class="nc">&nbsp;            long seconds = (millis / 1000);</b>
<b class="nc">&nbsp;            if (seconds &gt;= Integer.MIN_VALUE &amp;&amp; seconds &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                int secondsInt = (int) seconds;</b>
&nbsp;
<b class="nc">&nbsp;                bytes[off] = BC_TIMESTAMP_SECONDS;</b>
<b class="nc">&nbsp;                bytes[off + 1] = (byte) (secondsInt &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;                bytes[off + 2] = (byte) (secondsInt &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;                bytes[off + 3] = (byte) (secondsInt &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;                bytes[off + 4] = (byte) secondsInt;</b>
<b class="nc">&nbsp;                this.off = off + 5;</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (seconds % 60 == 0) {</b>
<b class="nc">&nbsp;                long minutes = seconds / 60;</b>
<b class="nc">&nbsp;                if (minutes &gt;= Integer.MIN_VALUE &amp;&amp; minutes &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                    int minutesInt = (int) minutes;</b>
<b class="nc">&nbsp;                    bytes[off] = BC_TIMESTAMP_MINUTES;</b>
<b class="nc">&nbsp;                    bytes[off + 1] = (byte) (minutesInt &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;                    bytes[off + 2] = (byte) (minutesInt &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;                    bytes[off + 3] = (byte) (minutesInt &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;                    bytes[off + 4] = (byte) minutesInt;</b>
<b class="nc">&nbsp;                    this.off = off + 5;</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bytes[off] = BC_TIMESTAMP_MILLIS;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (millis &gt;&gt;&gt; 56);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (millis &gt;&gt;&gt; 48);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) (millis &gt;&gt;&gt; 40);</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) (millis &gt;&gt;&gt; 32);</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) (millis &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) (millis &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) (millis &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 8] = (byte) millis;</b>
<b class="nc">&nbsp;        this.off = off + 9;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt64(long val) {
<b class="nc">&nbsp;        int minCapacity = off + 9;</b>
<b class="nc">&nbsp;        if (minCapacity &gt; bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int off = this.off;</b>
&nbsp;        int size;
<b class="nc">&nbsp;        if (val &gt;= INT64_NUM_LOW_VALUE &amp;&amp; val &lt;= INT64_NUM_HIGH_VALUE) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) (BC_INT64_NUM_MIN + (val - INT64_NUM_LOW_VALUE));</b>
<b class="nc">&nbsp;            size = 1;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT64_BYTE_MIN &amp;&amp; val &lt;= INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) (BC_INT64_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;            bytes[off + 1] = (byte) (val);</b>
<b class="nc">&nbsp;            size = 2;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT64_SHORT_MIN &amp;&amp; val &lt;= INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            putLong3(bytes, off, (int) val);</b>
<b class="nc">&nbsp;            size = 3;</b>
<b class="nc">&nbsp;        } else if (val &gt;= Integer.MIN_VALUE &amp;&amp; val &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;            bytes[off] = BC_INT64_INT;</b>
<b class="nc">&nbsp;            putInt(bytes, off + 1, (int) val);</b>
<b class="nc">&nbsp;            size = 5;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off] = BC_INT64;</b>
<b class="nc">&nbsp;            putLong(bytes, off + 1, val);</b>
<b class="nc">&nbsp;            size = 9;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off = off + size;</b>
&nbsp;    }
&nbsp;
&nbsp;    static void putLong3(byte[] bytes, int off, int val) {
<b class="nc">&nbsp;        bytes[off] = (byte) (BC_INT64_SHORT_ZERO + (val &gt;&gt; 16));</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (val &gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (val);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt64(long[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeArrayNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int size = value.length;</b>
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + value.length * 9 + 5;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        if (size &lt;= ARRAY_FIX_LEN) {</b>
<b class="nc">&nbsp;            bytes[off++] = (byte) (BC_ARRAY_FIX_MIN + size);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off] = BC_ARRAY;</b>
<b class="nc">&nbsp;            off += writeInt32(bytes, off + 1, size) + 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (long val : value) {</b>
<b class="nc">&nbsp;            if (val &gt;= BC_INT32_NUM_MIN &amp;&amp; val &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) val;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (val &gt;= INT64_BYTE_MIN &amp;&amp; val &lt;= INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                bytes[off] = (byte) (BC_INT64_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;                bytes[off + 1] = (byte) (val);</b>
<b class="nc">&nbsp;                off += 2;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (val &gt;= INT64_SHORT_MIN &amp;&amp; val &lt;= INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                putLong3(bytes, off, (int) val);</b>
<b class="nc">&nbsp;                off += 3;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (val &gt;= Integer.MIN_VALUE &amp;&amp; val &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                bytes[off] = BC_INT64_INT;</b>
<b class="nc">&nbsp;                putInt(bytes, off + 1, (int) val);</b>
<b class="nc">&nbsp;                off += 5;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            bytes[off] = BC_INT64;</b>
<b class="nc">&nbsp;            putLong(bytes, off + 1, val);</b>
<b class="nc">&nbsp;            off += 9;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off = off;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void putInt(byte[] bytes, int off, int val) {
<b class="nc">&nbsp;        bytes[off] = (byte) (val &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (val &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (val &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) val;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void putLong(byte[] bytes, int off, long val) {
<b class="nc">&nbsp;        bytes[off] = (byte) (val &gt;&gt;&gt; 56);</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (val &gt;&gt;&gt; 48);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (val &gt;&gt;&gt; 40);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) (val &gt;&gt;&gt; 32);</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) (val &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) (val &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) (val &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) val;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeFloat(float value) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 5;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int i = (int) value;</b>
<b class="nc">&nbsp;        if (i == value &amp;&amp; value &gt;= INT32_SHORT_MIN &amp;&amp; value &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = BC_FLOAT_INT;</b>
<b class="nc">&nbsp;            off += writeInt32(bytes, off + 1, i) + 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off] = BC_FLOAT;</b>
<b class="nc">&nbsp;            i = Float.floatToIntBits(value);</b>
<b class="nc">&nbsp;            putInt(bytes, off + 1, i);</b>
<b class="nc">&nbsp;            off += 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off = off;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeFloat(float[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        startArray(value.length);</b>
<b class="nc">&nbsp;        for (float v : value) {</b>
<b class="nc">&nbsp;            writeFloat(v);</b>
&nbsp;        }
<b class="nc">&nbsp;        endArray();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDouble(double value) {
<b class="nc">&nbsp;        if (value == 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;            bytes[off++] = BC_DOUBLE_NUM_0;</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (value == 1) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;            bytes[off] = BC_DOUBLE_NUM_1;</b>
<b class="nc">&nbsp;            this.off = off + 1;</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (value &gt;= Integer.MIN_VALUE &amp;&amp; value &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;            long longValue = (long) value;</b>
<b class="nc">&nbsp;            if (longValue == value) {</b>
<b class="nc">&nbsp;                ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;                bytes[off] = BC_DOUBLE_LONG;</b>
<b class="nc">&nbsp;                this.off = off + 1;</b>
<b class="nc">&nbsp;                writeInt64(longValue);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ensureCapacity(off + 9);</b>
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_DOUBLE;</b>
<b class="nc">&nbsp;        long i = Double.doubleToLongBits(value);</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (i &gt;&gt;&gt; 56);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (i &gt;&gt;&gt; 48);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) (i &gt;&gt;&gt; 40);</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) (i &gt;&gt;&gt; 32);</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) (i &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) (i &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) (i &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 8] = (byte) i;</b>
<b class="nc">&nbsp;        this.off = off + 9;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDouble(double[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        startArray(value.length);</b>
<b class="nc">&nbsp;        for (double v : value) {</b>
<b class="nc">&nbsp;            writeDouble(v);</b>
&nbsp;        }
<b class="nc">&nbsp;        endArray();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt16(short[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        startArray(value.length);</b>
<b class="nc">&nbsp;        for (short item : value) {</b>
<b class="nc">&nbsp;            writeInt32(item);</b>
&nbsp;        }
<b class="nc">&nbsp;        endArray();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt32(int[] values) {
<b class="nc">&nbsp;        if (values == null) {</b>
<b class="nc">&nbsp;            writeArrayNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // inline startArray(value.length);
<b class="nc">&nbsp;        int size = values.length;</b>
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (size &lt;= ARRAY_FIX_LEN) {</b>
<b class="nc">&nbsp;            bytes[off++] = (byte) (BC_ARRAY_FIX_MIN + size);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off++] = BC_ARRAY;</b>
<b class="nc">&nbsp;            writeInt32(size);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + values.length * 5;</b>
<b class="nc">&nbsp;        if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        for (int val : values) {</b>
<b class="nc">&nbsp;            if (val &gt;= BC_INT32_NUM_MIN &amp;&amp; val &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) val;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (val &gt;= INT32_BYTE_MIN &amp;&amp; val &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) (BC_INT32_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;                bytes[off++] = (byte) (val);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (val &gt;= INT32_SHORT_MIN &amp;&amp; val &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                putInt3(bytes, off, val);</b>
<b class="nc">&nbsp;                off += 3;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            bytes[off] = BC_INT32;</b>
<b class="nc">&nbsp;            putInt(bytes, off + 1, val);</b>
<b class="nc">&nbsp;            off += 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off = off;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt8(byte val) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 2;</b>
<b class="nc">&nbsp;        if (minCapacity - bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_INT8;</b>
<b class="nc">&nbsp;        bytes[off + 1] = val;</b>
<b class="nc">&nbsp;        this.off = off + 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt16(short val) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + 3;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_INT16;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (val &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) val;</b>
<b class="nc">&nbsp;        this.off = off + 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeEnum(Enum e) {
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((context.features &amp; Feature.WriteEnumUsingToString.mask) != 0) {</b>
<b class="nc">&nbsp;            writeString(e.toString());</b>
<b class="nc">&nbsp;        } else if ((context.features &amp; Feature.WriteEnumsUsingName.mask) != 0) {</b>
<b class="nc">&nbsp;            writeString(e.name());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int val = e.ordinal();</b>
<b class="nc">&nbsp;            if (val &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                if (off == bytes.length) {</b>
<b class="nc">&nbsp;                    ensureCapacity(off + 1);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                bytes[off++] = (byte) val;</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            writeInt32(val);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInt32(int val) {
<b class="nc">&nbsp;        int minCapacity = off + 5;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
&nbsp;        int size;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        if (val &gt;= BC_INT32_NUM_MIN &amp;&amp; val &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) val;</b>
<b class="nc">&nbsp;            size = 1;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT32_BYTE_MIN &amp;&amp; val &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) (BC_INT32_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;            bytes[off + 1] = (byte) (val);</b>
<b class="nc">&nbsp;            size = 2;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT32_SHORT_MIN &amp;&amp; val &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            putInt3(bytes, off, val);</b>
<b class="nc">&nbsp;            size = 3;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off] = BC_INT32;</b>
<b class="nc">&nbsp;            putInt(bytes, off + 1, val);</b>
<b class="nc">&nbsp;            size = 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.off += size;</b>
&nbsp;    }
&nbsp;
&nbsp;    static void putInt3(byte[] bytes, int off, int val) {
<b class="nc">&nbsp;        bytes[off] = (byte) (BC_INT32_SHORT_ZERO + (val &gt;&gt; 16));</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (val &gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int writeInt32(byte[] bytes, int off, int val) {
<b class="nc">&nbsp;        if (val &gt;= BC_INT32_NUM_MIN &amp;&amp; val &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) val;</b>
<b class="nc">&nbsp;            return 1;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT32_BYTE_MIN &amp;&amp; val &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) (BC_INT32_BYTE_ZERO + (val &gt;&gt; 8));</b>
<b class="nc">&nbsp;            bytes[off + 1] = (byte) (val);</b>
<b class="nc">&nbsp;            return 2;</b>
<b class="nc">&nbsp;        } else if (val &gt;= INT32_SHORT_MIN &amp;&amp; val &lt;= INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            putInt3(bytes, off, val);</b>
<b class="nc">&nbsp;            return 3;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off] = BC_INT32;</b>
<b class="nc">&nbsp;            putInt(bytes, off + 1, val);</b>
<b class="nc">&nbsp;            return 5;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeArrayNull() {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((this.context.features &amp; (Feature.NullAsDefaultValue.mask | Feature.WriteNullListAsEmpty.mask)) != 0) {</b>
<b class="nc">&nbsp;            bytes[off++] = BC_ARRAY_FIX_MIN;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bytes[off++] = BC_NULL;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeRaw(String str) {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeRaw(byte[] bytes) {
<b class="nc">&nbsp;        int minCapacity = this.off + bytes.length;</b>
<b class="nc">&nbsp;        if (minCapacity - this.bytes.length &gt; 0) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
<b class="nc">&nbsp;        System.arraycopy(bytes, 0, this.bytes, off, bytes.length);</b>
<b class="nc">&nbsp;        off += bytes.length;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void writeSymbol(int symbol) {
<b class="nc">&nbsp;        int minCapacity = off + 3;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off++] = BC_SYMBOL;</b>
&nbsp;
<b class="nc">&nbsp;        if (symbol &gt;= BC_INT32_NUM_MIN &amp;&amp; symbol &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            bytes[off++] = (byte) symbol;</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (symbol &gt;= INT32_BYTE_MIN &amp;&amp; symbol &lt;= INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) (BC_INT32_BYTE_ZERO + (symbol &gt;&gt; 8));</b>
<b class="nc">&nbsp;            bytes[off + 1] = (byte) (symbol);</b>
<b class="nc">&nbsp;            off += 2;</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeInt32(symbol);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeNameRaw(byte[] name, long nameHash) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        int minCapacity = off + name.length + 2;</b>
<b class="nc">&nbsp;        if (minCapacity &gt;= this.bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(minCapacity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
&nbsp;        int symbol;
<b class="nc">&nbsp;        if (symbolTable == null</b>
<b class="nc">&nbsp;                || (symbol = symbolTable.getOrdinalByHashCode(nameHash)) == -1</b>
&nbsp;        ) {
<b class="nc">&nbsp;            if ((context.features &amp; WriteNameAsSymbol.mask) == 0) {</b>
<b class="nc">&nbsp;                System.arraycopy(name, 0, bytes, off, name.length);</b>
<b class="nc">&nbsp;                this.off = off + name.length;</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            boolean symbolExists = false;</b>
<b class="nc">&nbsp;            if (symbols != null) {</b>
<b class="nc">&nbsp;                if ((symbol = symbols.putIfAbsent(nameHash, symbolIndex)) != symbolIndex) {</b>
<b class="nc">&nbsp;                    symbolExists = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    symbolIndex++;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                (symbols = new TLongIntHashMap())</b>
<b class="nc">&nbsp;                        .put(nameHash, symbol = symbolIndex++);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!symbolExists) {</b>
<b class="nc">&nbsp;                bytes[off++] = BC_SYMBOL;</b>
<b class="nc">&nbsp;                System.arraycopy(name, 0, bytes, off, name.length);</b>
<b class="nc">&nbsp;                this.off = off + name.length;</b>
&nbsp;
<b class="nc">&nbsp;                if (symbol &gt;= BC_INT32_NUM_MIN &amp;&amp; symbol &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    bytes[this.off++] = (byte) symbol;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    writeInt32(symbol);</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            symbol = -symbol;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bytes[off++] = BC_SYMBOL;</b>
<b class="nc">&nbsp;        int intValue = -symbol;</b>
<b class="nc">&nbsp;        if (intValue &gt;= BC_INT32_NUM_MIN &amp;&amp; intValue &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            bytes[off] = (byte) intValue;</b>
<b class="nc">&nbsp;            this.off = off + 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.off = off;</b>
<b class="nc">&nbsp;            writeInt32(intValue);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeLocalDate(LocalDate date) {
<b class="nc">&nbsp;        if (date == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 5);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_DATE;</b>
<b class="nc">&nbsp;        int year = date.getYear();</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) date.getMonthValue();</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) date.getDayOfMonth();</b>
<b class="nc">&nbsp;        this.off = off + 5;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeLocalTime(LocalTime time) {
<b class="nc">&nbsp;        if (time == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 4);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_TIME;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) time.getHour();</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) time.getMinute();</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) time.getSecond();</b>
<b class="nc">&nbsp;        this.off = off + 4;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = time.getNano();</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeLocalDateTime(LocalDateTime dateTime) {
<b class="nc">&nbsp;        if (dateTime == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 8);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_DATETIME;</b>
<b class="nc">&nbsp;        int year = dateTime.getYear();</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) dateTime.getMonthValue();</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dateTime.getDayOfMonth();</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) dateTime.getHour();</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) dateTime.getMinute();</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) dateTime.getSecond();</b>
<b class="nc">&nbsp;        this.off = off + 8;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = dateTime.getNano();</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeZonedDateTime(ZonedDateTime dateTime) {
<b class="nc">&nbsp;        if (dateTime == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 8);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_TIMESTAMP_WITH_TIMEZONE;</b>
<b class="nc">&nbsp;        int year = dateTime.getYear();</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) dateTime.getMonthValue();</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dateTime.getDayOfMonth();</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) dateTime.getHour();</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) dateTime.getMinute();</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) dateTime.getSecond();</b>
<b class="nc">&nbsp;        this.off = off + 8;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = dateTime.getNano();</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;
<b class="nc">&nbsp;        ZoneId zoneId = dateTime.getZone();</b>
<b class="nc">&nbsp;        String zoneIdStr = zoneId.getId();</b>
<b class="nc">&nbsp;        if (zoneIdStr.equals(SHANGHAI_ZONE_ID_NAME)) {</b>
<b class="nc">&nbsp;            writeRaw(SHANGHAI_ZONE_ID_NAME_BYTES);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            writeString(zoneIdStr);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeOffsetDateTime(OffsetDateTime dateTime) {
<b class="nc">&nbsp;        if (dateTime == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 8);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_TIMESTAMP_WITH_TIMEZONE;</b>
<b class="nc">&nbsp;        int year = dateTime.getYear();</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) dateTime.getMonthValue();</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dateTime.getDayOfMonth();</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) dateTime.getHour();</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) dateTime.getMinute();</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) dateTime.getSecond();</b>
<b class="nc">&nbsp;        this.off = off + 8;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = dateTime.getNano();</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;
<b class="nc">&nbsp;        ZoneId zoneId = dateTime.getOffset();</b>
<b class="nc">&nbsp;        String zoneIdStr = zoneId.getId();</b>
<b class="nc">&nbsp;        if (zoneIdStr.equals(OFFSET_8_ZONE_ID_NAME)) {</b>
<b class="nc">&nbsp;            writeRaw(OFFSET_8_ZONE_ID_NAME_BYTES);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            writeString(zoneIdStr);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeInstant(Instant instant) {
<b class="nc">&nbsp;        if (instant == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;        bytes[off++] = BC_TIMESTAMP;</b>
<b class="nc">&nbsp;        long second = instant.getEpochSecond();</b>
<b class="nc">&nbsp;        int nano = instant.getNano();</b>
<b class="nc">&nbsp;        writeInt64(second);</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeUUID(UUID value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long msb = value.getMostSignificantBits();</b>
<b class="nc">&nbsp;        long lsb = value.getLeastSignificantBits();</b>
&nbsp;
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 18);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_BINARY;</b>
<b class="nc">&nbsp;        bytes[off + 1] = BC_INT32_NUM_16;</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) (msb &gt;&gt;&gt; 56);</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) (msb &gt;&gt;&gt; 48);</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) (msb &gt;&gt;&gt; 40);</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) (msb &gt;&gt;&gt; 32);</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) (msb &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) (msb &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 8] = (byte) (msb &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 9] = (byte) msb;</b>
<b class="nc">&nbsp;        bytes[off + 10] = (byte) (lsb &gt;&gt;&gt; 56);</b>
<b class="nc">&nbsp;        bytes[off + 11] = (byte) (lsb &gt;&gt;&gt; 48);</b>
<b class="nc">&nbsp;        bytes[off + 12] = (byte) (lsb &gt;&gt;&gt; 40);</b>
<b class="nc">&nbsp;        bytes[off + 13] = (byte) (lsb &gt;&gt;&gt; 32);</b>
<b class="nc">&nbsp;        bytes[off + 14] = (byte) (lsb &gt;&gt;&gt; 24);</b>
<b class="nc">&nbsp;        bytes[off + 15] = (byte) (lsb &gt;&gt;&gt; 16);</b>
<b class="nc">&nbsp;        bytes[off + 16] = (byte) (lsb &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 17] = (byte) lsb;</b>
<b class="nc">&nbsp;        this.off = off + 18;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeBigInt(BigInteger value, long features) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isInt64(value)) {</b>
<b class="nc">&nbsp;            if (off == bytes.length) {</b>
<b class="nc">&nbsp;                ensureCapacity(off + 1);</b>
&nbsp;            }
<b class="nc">&nbsp;            bytes[off++] = BC_BIGINT_LONG;</b>
<b class="nc">&nbsp;            long int64Value = value.longValue();</b>
<b class="nc">&nbsp;            writeInt64(int64Value);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        byte[] valueBytes = value.toByteArray();</b>
<b class="nc">&nbsp;        ensureCapacity(off + 5 + valueBytes.length);</b>
&nbsp;
<b class="nc">&nbsp;        bytes[off++] = BC_BIGINT;</b>
<b class="nc">&nbsp;        writeInt32(valueBytes.length);</b>
<b class="nc">&nbsp;        System.arraycopy(valueBytes, 0, bytes, off, valueBytes.length);</b>
<b class="nc">&nbsp;        off += valueBytes.length;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeBinary(byte[] bytes) {
<b class="nc">&nbsp;        if (bytes == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ensureCapacity(off + 6 + bytes.length);</b>
<b class="nc">&nbsp;        this.bytes[off++] = BC_BINARY;</b>
<b class="nc">&nbsp;        writeInt32(bytes.length);</b>
&nbsp;
<b class="nc">&nbsp;        System.arraycopy(bytes, 0, this.bytes, off, bytes.length);</b>
<b class="nc">&nbsp;        off += bytes.length;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDecimal(BigDecimal value, long features, DecimalFormat format) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int precision = value.precision();</b>
<b class="nc">&nbsp;        int scale = value.scale();</b>
&nbsp;
<b class="nc">&nbsp;        if (precision &lt; 19 &amp;&amp; FIELD_DECIMAL_INT_COMPACT_OFFSET != -1) {</b>
<b class="nc">&nbsp;            long intCompact = UnsafeUtils.getLong(value, FIELD_DECIMAL_INT_COMPACT_OFFSET);</b>
<b class="nc">&nbsp;            if (scale == 0) {</b>
<b class="nc">&nbsp;                ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;                this.bytes[off++] = BC_DECIMAL_LONG;</b>
<b class="nc">&nbsp;                writeInt64(intCompact);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;            this.bytes[off++] = BC_DECIMAL;</b>
<b class="nc">&nbsp;            writeInt32(scale);</b>
<b class="nc">&nbsp;            if (intCompact &gt;= Integer.MIN_VALUE &amp;&amp; intCompact &lt;= Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                writeInt32((int) intCompact);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                writeInt64(intCompact);</b>
&nbsp;            }
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        BigInteger unscaledValue = value.unscaledValue();</b>
<b class="nc">&nbsp;        if (scale == 0</b>
<b class="nc">&nbsp;                &amp;&amp; isInt64(unscaledValue)) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;            this.bytes[off++] = BC_DECIMAL_LONG;</b>
<b class="nc">&nbsp;            long longValue = unscaledValue.longValue();</b>
<b class="nc">&nbsp;            writeInt64(longValue);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ensureCapacity(off + 1);</b>
<b class="nc">&nbsp;        this.bytes[off++] = BC_DECIMAL;</b>
<b class="nc">&nbsp;        writeInt32(scale);</b>
&nbsp;
<b class="nc">&nbsp;        if (isInt32(unscaledValue)) {</b>
<b class="nc">&nbsp;            int intValue = unscaledValue.intValue();</b>
<b class="nc">&nbsp;            writeInt32(intValue);</b>
<b class="nc">&nbsp;        } else if (isInt64(unscaledValue)) {</b>
<b class="nc">&nbsp;            long longValue = unscaledValue.longValue();</b>
<b class="nc">&nbsp;            writeInt64(longValue);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            writeBigInt(unscaledValue, 0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeBool(boolean value) {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.bytes[off++] = value ? BC_TRUE : BC_FALSE;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeBool(boolean[] value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        startArray(value.length);</b>
<b class="nc">&nbsp;        for (boolean b : value) {</b>
<b class="nc">&nbsp;            writeBool(b);</b>
&nbsp;        }
<b class="nc">&nbsp;        endArray();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeReference(String path) {
<b class="nc">&nbsp;        if (off == bytes.length) {</b>
<b class="nc">&nbsp;            ensureCapacity(off + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        bytes[off++] = BC_REFERENCE;</b>
&nbsp;
<b class="nc">&nbsp;        if (path == this.lastReference) {</b>
<b class="nc">&nbsp;            writeString(&quot;#-1&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            writeString(path);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        this.lastReference = path;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDateTime14(
&nbsp;            int year,
&nbsp;            int month,
&nbsp;            int dayOfMonth,
&nbsp;            int hour,
&nbsp;            int minute,
&nbsp;            int second
&nbsp;    ) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 8);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_DATETIME;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) month;</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dayOfMonth;</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) hour;</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) minute;</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) second;</b>
<b class="nc">&nbsp;        this.off = off + 8;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = 0;</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDateTime19(
&nbsp;            int year,
&nbsp;            int month,
&nbsp;            int dayOfMonth,
&nbsp;            int hour,
&nbsp;            int minute,
&nbsp;            int second
&nbsp;    ) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 8);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_DATETIME;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) month;</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dayOfMonth;</b>
<b class="nc">&nbsp;        bytes[off + 5] = (byte) hour;</b>
<b class="nc">&nbsp;        bytes[off + 6] = (byte) minute;</b>
<b class="nc">&nbsp;        bytes[off + 7] = (byte) second;</b>
<b class="nc">&nbsp;        this.off = off + 8;</b>
&nbsp;
<b class="nc">&nbsp;        int nano = 0;</b>
<b class="nc">&nbsp;        writeInt32(nano);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDateTimeISO8601(
&nbsp;            int year,
&nbsp;            int month,
&nbsp;            int dayOfMonth,
&nbsp;            int hour,
&nbsp;            int minute,
&nbsp;            int second,
&nbsp;            int millis,
&nbsp;            int offsetSeconds,
&nbsp;            boolean timeZone
&nbsp;    ) {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDateYYYMMDD8(int year, int month, int dayOfMonth) {
<b class="nc">&nbsp;        int off = this.off;</b>
<b class="nc">&nbsp;        ensureCapacity(off + 5);</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        bytes[off] = BC_LOCAL_DATE;</b>
<b class="nc">&nbsp;        bytes[off + 1] = (byte) (year &gt;&gt;&gt; 8);</b>
<b class="nc">&nbsp;        bytes[off + 2] = (byte) year;</b>
<b class="nc">&nbsp;        bytes[off + 3] = (byte) month;</b>
<b class="nc">&nbsp;        bytes[off + 4] = (byte) dayOfMonth;</b>
<b class="nc">&nbsp;        this.off = off + 5;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeDateYYYMMDD10(int year, int month, int dayOfMonth) {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeTimeHHMMSS8(int hour, int minute, int second) {
<b class="nc">&nbsp;        throw new JSONException(&quot;unsupported operation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeBase64(byte[] bytes) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeHex(byte[] bytes) {
<b class="nc">&nbsp;        writeBinary(bytes);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeRaw(char ch) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeNameRaw(byte[] bytes) {
<b class="nc">&nbsp;        writeRaw(bytes);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeNameRaw(char[] chars) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeNameRaw(char[] bytes, int offset, int len) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeColon() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void write(List array) {
<b class="nc">&nbsp;        if (array == null) {</b>
<b class="nc">&nbsp;            writeArrayNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int size = array.size();</b>
<b class="nc">&nbsp;        startArray(size);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; size; i++) {</b>
<b class="nc">&nbsp;            Object item = array.get(i);</b>
<b class="nc">&nbsp;            writeAny(item);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void write(Map map) {
<b class="nc">&nbsp;        if (map == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        startObject();</b>
<b class="nc">&nbsp;        for (Map.Entry entry : (Iterable&lt;Map.Entry&gt;) map.entrySet()) {</b>
<b class="nc">&nbsp;            writeAny(entry.getKey());</b>
<b class="nc">&nbsp;            writeAny(entry.getValue());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        endObject();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void write(JSONObject object) {
<b class="nc">&nbsp;        if (object == null) {</b>
<b class="nc">&nbsp;            writeNull();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        startObject();</b>
<b class="nc">&nbsp;        for (Map.Entry entry : object.entrySet()) {</b>
<b class="nc">&nbsp;            writeAny(entry.getKey());</b>
<b class="nc">&nbsp;            writeAny(entry.getValue());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        endObject();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte[] getBytes() {
<b class="nc">&nbsp;        return Arrays.copyOf(bytes, off);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int size() {
<b class="nc">&nbsp;        return off;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte[] getBytes(Charset charset) {
<b class="nc">&nbsp;        throw new JSONException(&quot;not support operator&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int flushTo(OutputStream to) throws IOException {
<b class="nc">&nbsp;        int len = off;</b>
<b class="nc">&nbsp;        to.write(bytes, 0, off);</b>
<b class="nc">&nbsp;        off = 0;</b>
<b class="nc">&nbsp;        return len;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int flushTo(OutputStream out, Charset charset) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        if (bytes.length == 0) {</b>
<b class="nc">&nbsp;            return &quot;&lt;empty&gt;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        byte[] jsonbBytes = getBytes();</b>
<b class="nc">&nbsp;        JSONReader reader = JSONReader.ofJSONB(jsonbBytes);</b>
<b class="nc">&nbsp;        JSONWriter writer = JSONWriter.of();</b>
&nbsp;        try {
<b class="nc">&nbsp;            Object object = reader.readAny();</b>
<b class="nc">&nbsp;            writer.writeAny(object);</b>
<b class="nc">&nbsp;            return writer.toString();</b>
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            return JSONB.typeName(bytes[0]) + &quot;, bytes length &quot; + off;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 22:05</div>
</div>
</body>
</html>
