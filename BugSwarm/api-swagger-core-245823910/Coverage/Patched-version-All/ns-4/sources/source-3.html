


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ModelResolver</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.swagger.jackson</a>
</div>

<h1>Coverage Summary for Class: ModelResolver (io.swagger.jackson)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ModelResolver</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/330)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ModelResolver$1</td>
  </tr>
  <tr>
    <td class="name">ModelResolver$GeneratorWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ModelResolver$GeneratorWrapper$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ModelResolver$GeneratorWrapper$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ModelResolver$GeneratorWrapper$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ModelResolver$GeneratorWrapper$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/377)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package io.swagger.jackson;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonIdentityInfo;
&nbsp;import com.fasterxml.jackson.annotation.JsonIdentityReference;
&nbsp;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
&nbsp;import com.fasterxml.jackson.annotation.JsonProperty;
&nbsp;import com.fasterxml.jackson.annotation.JsonUnwrapped;
&nbsp;import com.fasterxml.jackson.annotation.ObjectIdGenerator;
&nbsp;import com.fasterxml.jackson.annotation.ObjectIdGenerators;
&nbsp;import com.fasterxml.jackson.databind.BeanDescription;
&nbsp;import com.fasterxml.jackson.databind.JavaType;
&nbsp;import com.fasterxml.jackson.databind.ObjectMapper;
&nbsp;import com.fasterxml.jackson.databind.PropertyMetadata;
&nbsp;import com.fasterxml.jackson.databind.SerializationFeature;
&nbsp;import com.fasterxml.jackson.databind.introspect.Annotated;
&nbsp;import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
&nbsp;import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
&nbsp;import com.fasterxml.jackson.databind.jsontype.NamedType;
&nbsp;import com.fasterxml.jackson.databind.type.TypeFactory;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import io.swagger.converter.ModelConverter;
&nbsp;import io.swagger.converter.ModelConverterContext;
&nbsp;import io.swagger.oas.models.media.ArraySchema;
&nbsp;import io.swagger.oas.models.media.IntegerSchema;
&nbsp;import io.swagger.oas.models.media.MapSchema;
&nbsp;import io.swagger.oas.models.media.NumberSchema;
&nbsp;import io.swagger.oas.models.media.Schema;
&nbsp;import io.swagger.oas.models.media.StringSchema;
&nbsp;import io.swagger.oas.models.media.UUIDSchema;
&nbsp;import io.swagger.util.PrimitiveType;
&nbsp;import io.swagger.util.ReflectionUtils;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import javax.validation.constraints.DecimalMax;
&nbsp;import javax.validation.constraints.DecimalMin;
&nbsp;import javax.validation.constraints.Max;
&nbsp;import javax.validation.constraints.Min;
&nbsp;import javax.validation.constraints.Pattern;
&nbsp;import javax.validation.constraints.Size;
&nbsp;import javax.xml.bind.annotation.XmlAccessType;
&nbsp;import javax.xml.bind.annotation.XmlAccessorType;
&nbsp;import javax.xml.bind.annotation.XmlElement;
&nbsp;import javax.xml.bind.annotation.XmlRootElement;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;public class ModelResolver extends AbstractModelConverter implements ModelConverter {
<b class="nc">&nbsp;    Logger LOGGER = LoggerFactory.getLogger(ModelResolver.class);</b>
&nbsp;
&nbsp;    public ModelResolver(ObjectMapper mapper) {
<b class="nc">&nbsp;        super(mapper);</b>
&nbsp;    }
&nbsp;
&nbsp;    public ObjectMapper objectMapper() {
<b class="nc">&nbsp;        return _mapper;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String constructRef(String simpleRef) {
<b class="nc">&nbsp;        return &quot;#/components/schemas/&quot; + simpleRef;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String extractSimpleName(String ref) {
<b class="nc">&nbsp;        int idx = ref.lastIndexOf(&quot;/&quot;);</b>
<b class="nc">&nbsp;        if(idx &gt; 0) {</b>
<b class="nc">&nbsp;            return ref.substring(idx);</b>
&nbsp;        }
<b class="nc">&nbsp;        return ref;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean shouldIgnoreClass(Type type) {
<b class="nc">&nbsp;        if (type instanceof Class) {</b>
<b class="nc">&nbsp;            Class&lt;?&gt; cls = (Class&lt;?&gt;) type;</b>
<b class="nc">&nbsp;            if (cls.getName().equals(&quot;javax.ws.rs.Response&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            if (type instanceof com.fasterxml.jackson.core.type.ResolvedType) {</b>
<b class="nc">&nbsp;                com.fasterxml.jackson.core.type.ResolvedType rt = (com.fasterxml.jackson.core.type.ResolvedType) type;</b>
<b class="nc">&nbsp;                LOGGER.debug(&quot;Can&#39;t check class {}, {}&quot;, type, rt.getRawClass().getName());</b>
<b class="nc">&nbsp;                if (rt.getRawClass().equals(Class.class)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Schema resolve(Type type,
&nbsp;                          ModelConverterContext context,
&nbsp;                          Annotation[] annotations,
&nbsp;                          Iterator&lt;ModelConverter&gt; next) {
<b class="nc">&nbsp;        if (this.shouldIgnoreClass(type)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return resolveProperty(_mapper.constructType(type), context, annotations, next);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Schema resolveProperty(JavaType propType,
&nbsp;            ModelConverterContext context,
&nbsp;            Annotation[] annotations,
&nbsp;            Iterator&lt;ModelConverter&gt; next) {
<b class="nc">&nbsp;        LOGGER.debug(&quot;resolveProperty {}&quot;, propType);</b>
&nbsp;
<b class="nc">&nbsp;        Schema property = null;</b>
<b class="nc">&nbsp;        if (propType.isContainerType()) {</b>
<b class="nc">&nbsp;            JavaType keyType = propType.getKeyType();</b>
<b class="nc">&nbsp;            JavaType valueType = propType.getContentType();</b>
<b class="nc">&nbsp;            if (keyType != null &amp;&amp; valueType != null) {</b>
<b class="nc">&nbsp;                property = new MapSchema().additionalProperties(context.resolve(valueType, new Annotation[]{}));</b>
<b class="nc">&nbsp;            } else if (valueType != null) {</b>
<b class="nc">&nbsp;                Schema items = context.resolve(valueType, new Annotation[]{});</b>
&nbsp;                // If property is XmlElement annotated, then use the name provided by annotation | https://github.com/swagger-api/swagger-core/issues/2047
<b class="nc">&nbsp;                if(annotations != null &amp;&amp; annotations.length &gt; 0) {</b>
<b class="nc">&nbsp;                    for (Annotation annotation : annotations) {</b>
<b class="nc">&nbsp;                        if(annotation instanceof XmlElement) {</b>
<b class="nc">&nbsp;                            XmlElement xmlElement =   (XmlElement)annotation;</b>
<b class="nc">&nbsp;                            if(xmlElement != null &amp;&amp; xmlElement.name() != null &amp;&amp; !&quot;&quot;.equals(xmlElement.name()) &amp;&amp; !&quot;##default&quot;.equals(xmlElement.name())) {</b>
&nbsp;//                                Xml xml = items.getXml() != null ? items.getXml() : new Xml();
&nbsp;//                                xml.setName(xmlElement.name());
&nbsp;//                                items.setXml(xml);
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                Schema arrayProperty =</b>
<b class="nc">&nbsp;                        new ArraySchema().items(items);</b>
<b class="nc">&nbsp;                if (_isSetType(propType.getRawClass())) {</b>
<b class="nc">&nbsp;                    arrayProperty.setUniqueItems(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                property = arrayProperty;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            property = PrimitiveType.createProperty(propType);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (property == null) {</b>
<b class="nc">&nbsp;            if (propType.isEnumType()) {</b>
<b class="nc">&nbsp;                property = new StringSchema();</b>
<b class="nc">&nbsp;                _addEnumProps(propType.getRawClass(), property);</b>
<b class="nc">&nbsp;            } else if (_isOptionalType(propType)) {</b>
<b class="nc">&nbsp;                property = context.resolve(propType.containedType(0), null);</b>
&nbsp;            } else {
&nbsp;                // complex type
<b class="nc">&nbsp;                Schema innerModel = context.resolve(propType);</b>
&nbsp;                // TODO
&nbsp;//                if (innerModel instanceof ComposedModel) {
&nbsp;//                    innerModel = ((ComposedModel) innerModel).getChild();
&nbsp;//                }
<b class="nc">&nbsp;                if (innerModel instanceof Schema) {</b>
<b class="nc">&nbsp;                    Schema mi = (Schema) innerModel;</b>
&nbsp;
<b class="nc">&nbsp;                    if(&quot;object&quot;.equals(mi.getType())) {</b>
&nbsp;                        // create a reference for the property
<b class="nc">&nbsp;                        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(propType);</b>
<b class="nc">&nbsp;                        String name = _typeName(propType, beanDesc);</b>
<b class="nc">&nbsp;                        property = new Schema().$ref(constructRef(name));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    else if(mi.get$ref() != null) {</b>
<b class="nc">&nbsp;                        property = new Schema().$ref(StringUtils.isNotEmpty(mi.get$ref()) ? mi.get$ref() : mi.getTitle());</b>
&nbsp;                    }
&nbsp;                    else {
<b class="nc">&nbsp;                        property = innerModel;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return property;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean _isOptionalType(JavaType propType) {
<b class="nc">&nbsp;        return Arrays.asList(&quot;com.google.common.base.Optional&quot;, &quot;java.util.Optional&quot;)</b>
<b class="nc">&nbsp;                .contains(propType.getRawClass().getCanonicalName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Schema resolve(Type type, ModelConverterContext context, Iterator&lt;ModelConverter&gt; next) {
<b class="nc">&nbsp;        if (this.shouldIgnoreClass(type)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return resolve(_mapper.constructType(type), context, next);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void _addEnumProps(Class&lt;?&gt; propClass, Schema property) {
<b class="nc">&nbsp;        final boolean useIndex = _mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);</b>
<b class="nc">&nbsp;        final boolean useToString = _mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);</b>
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        Class&lt;Enum&lt;?&gt;&gt; enumClass = (Class&lt;Enum&lt;?&gt;&gt;) propClass;</b>
<b class="nc">&nbsp;        for (Enum&lt;?&gt; en : enumClass.getEnumConstants()) {</b>
&nbsp;            String n;
<b class="nc">&nbsp;            if (useIndex) {</b>
<b class="nc">&nbsp;                n = String.valueOf(en.ordinal());</b>
<b class="nc">&nbsp;            } else if (useToString) {</b>
<b class="nc">&nbsp;                n = en.toString();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                n = _intr.findEnumValue(en);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (property instanceof StringSchema) {</b>
<b class="nc">&nbsp;                StringSchema sp = (StringSchema) property;</b>
<b class="nc">&nbsp;                sp.addEnumItem(n);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Schema resolve(JavaType type, ModelConverterContext context, Iterator&lt;ModelConverter&gt; next) {
<b class="nc">&nbsp;        if (type.isEnumType()) {</b>
&nbsp;            // We don&#39;t build models for primitive types
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        else if(PrimitiveType.fromType(type) != null) {</b>
<b class="nc">&nbsp;            return PrimitiveType.fromType(type).createProperty();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);</b>
&nbsp;        // Couple of possibilities for defining
<b class="nc">&nbsp;        String name = _typeName(type, beanDesc);</b>
&nbsp;
<b class="nc">&nbsp;        if (&quot;Object&quot;.equals(name)) {</b>
<b class="nc">&nbsp;            return new Schema();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * --Preventing parent/child hierarchy creation loops - Comment 1--
&nbsp;         * Creating a parent model will result in the creation of child models. Creating a child model will result in
&nbsp;         * the creation of a parent model, as per the second If statement following this comment.
&nbsp;         *
&nbsp;         * By checking whether a model has already been resolved (as implemented below), loops of parents creating
&nbsp;         * children and children creating parents can be short-circuited. This works because currently the
&nbsp;         * ModelConverterContextImpl will return null for a class that already been processed, but has not yet been
&nbsp;         * defined. This logic works in conjunction with the early immediate definition of model in the context
&nbsp;         * implemented later in this method (See &quot;Preventing parent/child hierarchy creation loops - Comment 2&quot;) to
&nbsp;         * prevent such
&nbsp;         */
<b class="nc">&nbsp;        Schema resolvedModel = context.resolve(type.getRawClass());</b>
<b class="nc">&nbsp;        if (resolvedModel != null) {</b>
&nbsp;            // TODO
&nbsp;            /*
&nbsp;            if (!(resolvedModel instanceof ModelImpl || resolvedModel instanceof ComposedModel)
&nbsp;                    || (resolvedModel instanceof ModelImpl &amp;&amp; ((ModelImpl) resolvedModel).getName().equals(name))) {
&nbsp;                return resolvedModel;
&nbsp;            } else if (resolvedModel instanceof ComposedModel) {
&nbsp;                Model childModel = ((ComposedModel) resolvedModel).getChild();
&nbsp;                if (childModel != null &amp;&amp; (!(childModel instanceof ModelImpl)
&nbsp;                        || ((ModelImpl) childModel).getName().equals(name))) {
&nbsp;                    return resolvedModel;
&nbsp;                }
&nbsp;            }
&nbsp;            */
<b class="nc">&nbsp;            return resolvedModel;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Schema model = new Schema()</b>
<b class="nc">&nbsp;                .type(&quot;object&quot;)</b>
<b class="nc">&nbsp;                .description(_description(beanDesc.getClassInfo()));</b>
&nbsp;
<b class="nc">&nbsp;        if (!type.isContainerType()) {</b>
&nbsp;            // define the model here to support self/cyclic referencing of models
<b class="nc">&nbsp;            context.defineModel(name, model, type, null);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type.isContainerType()) {</b>
&nbsp;            // We treat collections as primitive types, just need to add models for values (if any)
<b class="nc">&nbsp;            context.resolve(type.getContentType());</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // if XmlRootElement annotation, construct an Xml object and attach it to the model
<b class="nc">&nbsp;        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);</b>
<b class="nc">&nbsp;        if (rootAnnotation != null &amp;&amp; !&quot;&quot;.equals(rootAnnotation.name()) &amp;&amp; !&quot;##default&quot;.equals(rootAnnotation.name())) {</b>
<b class="nc">&nbsp;            LOGGER.debug(&quot;{}&quot;, rootAnnotation);</b>
&nbsp;            /*
&nbsp;            Xml xml = new Xml().name(rootAnnotation.name());
&nbsp;            if (rootAnnotation.namespace() != null &amp;&amp; !&quot;&quot;.equals(rootAnnotation.namespace()) &amp;&amp; !&quot;##default&quot;.equals(rootAnnotation.namespace())) {
&nbsp;                xml.namespace(rootAnnotation.namespace());
&nbsp;            }
&nbsp;            model.xml(xml);
&nbsp;            */
&nbsp;        }
<b class="nc">&nbsp;        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);</b>
&nbsp;
&nbsp;        // see if @JsonIgnoreProperties exist
<b class="nc">&nbsp;        Set&lt;String&gt; propertiesToIgnore = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);</b>
<b class="nc">&nbsp;        if (ignoreProperties != null) {</b>
<b class="nc">&nbsp;            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));</b>
&nbsp;        }
&nbsp;/*
&nbsp;        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
&nbsp;        String disc = (apiModel == null) ? &quot;&quot; : apiModel.discriminator();
&nbsp;
&nbsp;        if (apiModel != null &amp;&amp; StringUtils.isNotEmpty(apiModel.reference())) {
&nbsp;            model.setReference(apiModel.reference());
&nbsp;        }
&nbsp;
&nbsp;        if (disc.isEmpty()) {
&nbsp;            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
&nbsp;            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
&nbsp;            if (typeInfo != null) {
&nbsp;                disc = typeInfo.property();
&nbsp;            }
&nbsp;        }
&nbsp;        if (!disc.isEmpty()) {
&nbsp;            model.setDiscriminator(disc);
&nbsp;        }
&nbsp;*/
<b class="nc">&nbsp;        List&lt;Schema&gt; props = new ArrayList&lt;Schema&gt;();</b>
<b class="nc">&nbsp;        Map&lt;String, Schema&gt; modelProps = new LinkedHashMap&lt;String, Schema&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {</b>
<b class="nc">&nbsp;            Schema property = null;</b>
<b class="nc">&nbsp;            String propName = propDef.getName();</b>
<b class="nc">&nbsp;            Annotation[] annotations = null;</b>
&nbsp;
&nbsp;            // hack to avoid clobbering properties with get/is names
&nbsp;            // it&#39;s ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
<b class="nc">&nbsp;            if (propDef.getPrimaryMember() != null) {</b>
<b class="nc">&nbsp;                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();</b>
<b class="nc">&nbsp;                if (member != null) {</b>
<b class="nc">&nbsp;                    String altName = member.getName();</b>
<b class="nc">&nbsp;                    if (altName != null) {</b>
<b class="nc">&nbsp;                        final int length = altName.length();</b>
<b class="nc">&nbsp;                        for (String prefix : Arrays.asList(&quot;get&quot;, &quot;is&quot;)) {</b>
<b class="nc">&nbsp;                            final int offset = prefix.length();</b>
<b class="nc">&nbsp;                            if (altName.startsWith(prefix) &amp;&amp; length &gt; offset</b>
<b class="nc">&nbsp;                                    &amp;&amp; !Character.isUpperCase(altName.charAt(offset))) {</b>
<b class="nc">&nbsp;                                propName = altName;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            PropertyMetadata md = propDef.getMetadata();</b>
&nbsp;
<b class="nc">&nbsp;            boolean hasSetter = false, hasGetter = false;</b>
&nbsp;            try{
<b class="nc">&nbsp;                if (propDef.getSetter() == null) {</b>
<b class="nc">&nbsp;                    hasSetter = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    hasSetter = true;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IllegalArgumentException e){</b>
&nbsp;                //com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder would throw IllegalArgumentException
&nbsp;                // if there are overloaded setters. If we only want to know whether a set method exists, suppress the exception
&nbsp;                // is reasonable.
&nbsp;                // More logs might be added here
<b class="nc">&nbsp;                hasSetter = true;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (propDef.getGetter() != null) {</b>
<b class="nc">&nbsp;                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);</b>
<b class="nc">&nbsp;                if (pd != null) {</b>
<b class="nc">&nbsp;                    hasGetter = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            Boolean isReadOnly = null;</b>
<b class="nc">&nbsp;            if (!hasSetter &amp; hasGetter) {</b>
<b class="nc">&nbsp;                isReadOnly = Boolean.TRUE;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                isReadOnly = Boolean.FALSE;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final AnnotatedMember member = propDef.getPrimaryMember();</b>
<b class="nc">&nbsp;            Boolean allowEmptyValue = null;</b>
<b class="nc">&nbsp;            String minimum = null, maximum = null;</b>
<b class="nc">&nbsp;            boolean exclusiveMinimum = false, exclusiveMaximum = false;</b>
&nbsp;
<b class="nc">&nbsp;            if (member != null &amp;&amp; !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {</b>
<b class="nc">&nbsp;                List&lt;Annotation&gt; annotationList = new ArrayList&lt;Annotation&gt;();</b>
<b class="nc">&nbsp;                for (Annotation a : member.annotations()) {</b>
<b class="nc">&nbsp;                    annotationList.add(a);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                annotations = annotationList.toArray(new Annotation[annotationList.size()]);</b>
&nbsp;
<b class="nc">&nbsp;                io.swagger.oas.annotations.media.Schema mp = null;</b>
&nbsp;
<b class="nc">&nbsp;                io.swagger.oas.annotations.media.ArraySchema as = null;</b>
<b class="nc">&nbsp;                as = member.getAnnotation(io.swagger.oas.annotations.media.ArraySchema.class);</b>
<b class="nc">&nbsp;                if (as != null) {</b>
<b class="nc">&nbsp;                    mp = as.schema();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    mp = member.getAnnotation(io.swagger.oas.annotations.media.Schema.class);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(mp != null) {</b>
<b class="nc">&nbsp;                    if (mp.readOnly()) {</b>
<b class="nc">&nbsp;                        isReadOnly = mp.readOnly();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (mp.nullable()) {</b>
<b class="nc">&nbsp;                        allowEmptyValue = mp.nullable();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        allowEmptyValue = null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (StringUtils.isNotBlank(mp.minimum()) &amp;&amp; !String.valueOf(Integer.MAX_VALUE).equals(mp.minimum())) {</b>
<b class="nc">&nbsp;                        minimum = mp.minimum();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (StringUtils.isNotBlank(mp.maximum()) &amp;&amp; !String.valueOf(Integer.MIN_VALUE).equals(mp.maximum())) {</b>
<b class="nc">&nbsp;                        maximum = mp.maximum();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if(mp.exclusiveMinimum()) {</b>
<b class="nc">&nbsp;                        exclusiveMinimum = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if(mp.exclusiveMaximum()) {</b>
<b class="nc">&nbsp;                        exclusiveMaximum = true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                JavaType propType = member.getType(beanDesc.bindingsForBeanType());</b>
&nbsp;
&nbsp;                // allow override of name from annotation
<b class="nc">&nbsp;                if (mp != null &amp;&amp; !mp.name().isEmpty()) {</b>
<b class="nc">&nbsp;                    propName = mp.name();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (mp != null &amp;&amp; !Void.class.equals(mp.implementation())) {</b>
<b class="nc">&nbsp;                    Class&lt;?&gt; cls = mp.implementation();</b>
&nbsp;
<b class="nc">&nbsp;                    LOGGER.debug(&quot;overriding datatype from {} to {}&quot;, propType, cls.getName());</b>
&nbsp;
<b class="nc">&nbsp;                    if (as != null) {</b>
<b class="nc">&nbsp;                        ArraySchema propertySchema = new ArraySchema();</b>
<b class="nc">&nbsp;                        Schema innerSchema = null;</b>
&nbsp;
<b class="nc">&nbsp;                        Schema primitiveProperty = PrimitiveType.createProperty(cls);</b>
<b class="nc">&nbsp;                        if (primitiveProperty != null) {</b>
<b class="nc">&nbsp;                            innerSchema = primitiveProperty;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            innerSchema = context.resolve(cls, annotations);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        propertySchema.setItems(innerSchema);</b>
<b class="nc">&nbsp;                        property = propertySchema;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    else {
<b class="nc">&nbsp;                        property = context.resolve(cls, annotations);</b>
&nbsp;                    }
&nbsp;                    /*else if (or.toLowerCase().startsWith(&quot;map[&quot;)) {
&nbsp;                        // TODO
&nbsp;//                        int pos = or.indexOf(&quot;,&quot;);
&nbsp;//                        if (pos &gt; 0) {
&nbsp;//                            String innerType = or.substring(pos + 1, or.length() - 1);
&nbsp;//                            MapProperty p = new MapProperty();
&nbsp;//                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
&nbsp;//                            if (primitiveProperty != null) {
&nbsp;//                                p.setAdditionalProperties(primitiveProperty);
&nbsp;//                            } else {
&nbsp;//                                innerJavaType = getInnerType(innerType);
&nbsp;//                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
&nbsp;//                            }
&nbsp;//                            property = p;
&nbsp;//                        }
&nbsp;                    } else {
&nbsp;                        Schema primitiveProperty = PrimitiveType.createProperty(or);
&nbsp;                        if (primitiveProperty != null) {
&nbsp;                            property = primitiveProperty;
&nbsp;                        } else {
&nbsp;                            innerJavaType = getInnerType(or);
&nbsp;                            property = context.resolve(innerJavaType, annotations);
&nbsp;                        }
&nbsp;                    }
&nbsp;                    if (innerJavaType != null) {
&nbsp;                        context.resolve(innerJavaType);
&nbsp;                    }*/
&nbsp;                }
&nbsp;
&nbsp;                // no property from override, construct from propType
<b class="nc">&nbsp;                if (property == null) {</b>
<b class="nc">&nbsp;                    if (mp != null &amp;&amp; StringUtils.isNotEmpty(mp.ref())) {</b>
<b class="nc">&nbsp;                        property = new Schema().$ref(mp.ref());</b>
<b class="nc">&nbsp;                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {</b>
&nbsp;                        // TODO
&nbsp;//                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
&nbsp;//                                member.getAnnotation(JsonIdentityInfo.class),
&nbsp;//                                member.getAnnotation(JsonIdentityReference.class));
&nbsp;                    }
<b class="nc">&nbsp;                    if (property == null) {</b>
<b class="nc">&nbsp;                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);</b>
<b class="nc">&nbsp;                        if (uw != null &amp;&amp; uw.enabled()) {</b>
<b class="nc">&nbsp;                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            property = context.resolve(propType, annotations);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (property != null) {</b>
<b class="nc">&nbsp;                    if (property.get$ref() == null) {</b>
<b class="nc">&nbsp;                        Boolean required = md.getRequired();</b>
<b class="nc">&nbsp;                        if (required != null &amp;&amp; !Boolean.FALSE.equals(required)) {</b>
<b class="nc">&nbsp;                            model.addRequiredItem(propName);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        String description = _intr.findPropertyDescription(member);</b>
<b class="nc">&nbsp;                        if (description != null &amp;&amp; !&quot;&quot;.equals(description)) {</b>
<b class="nc">&nbsp;                            property.setDescription(description);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        Integer index = _intr.findPropertyIndex(member);</b>
<b class="nc">&nbsp;                        if (index != null) {</b>
&nbsp;//                        property.setPosition(index);
&nbsp;                        }
<b class="nc">&nbsp;                        String _defaultValue = _findDefaultValue(member);</b>
<b class="nc">&nbsp;                        property.setDefault(_defaultValue);</b>
<b class="nc">&nbsp;                        if(minimum != null) {</b>
<b class="nc">&nbsp;                            property.minimum(new BigDecimal(minimum));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if(maximum != null) {</b>
<b class="nc">&nbsp;                            property.maximum(new BigDecimal(maximum));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if(exclusiveMaximum) {</b>
<b class="nc">&nbsp;                            property.exclusiveMaximum(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if(exclusiveMinimum) {</b>
<b class="nc">&nbsp;                            property.exclusiveMinimum(true);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        property.setExample(_findExampleValue(member));</b>
<b class="nc">&nbsp;                        property.setReadOnly(_findReadOnly(member));</b>
<b class="nc">&nbsp;                        if (allowEmptyValue != null) {</b>
<b class="nc">&nbsp;                            property.setNullable(allowEmptyValue);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (property.getReadOnly() == null) {</b>
<b class="nc">&nbsp;                            if (isReadOnly) {</b>
<b class="nc">&nbsp;                                property.setReadOnly(isReadOnly);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        if (mp != null) {</b>
<b class="nc">&nbsp;                            if(mp._enum().length &gt; 0) {</b>
<b class="nc">&nbsp;                                for(String _enum : mp._enum()) {</b>
<b class="nc">&nbsp;                                    if(StringUtils.isNotBlank(_enum)) {</b>
<b class="nc">&nbsp;                                        property.addEnumItemObject(_enum);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        JAXBAnnotationsHelper.apply(member, property);</b>
<b class="nc">&nbsp;                        applyBeanValidatorAnnotations(property, annotations);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(property != null) {</b>
<b class="nc">&nbsp;                    props.add(property);</b>
<b class="nc">&nbsp;                    modelProps.put(propName, property);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;//        Collections.sort(props, getPropertyComparator());
&nbsp;
<b class="nc">&nbsp;        if(modelProps.size() &gt; 0) {</b>
<b class="nc">&nbsp;            model.setProperties(modelProps);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * --Preventing parent/child hierarchy creation loops - Comment 2--
&nbsp;         * Creating a parent model will result in the creation of child models, as per the first If statement following
&nbsp;         * this comment. Creating a child model will result in the creation of a parent model, as per the second If
&nbsp;         * statement following this comment.
&nbsp;         *
&nbsp;         * The current model must be defined in the context immediately. This done to help prevent repeated
&nbsp;         * loops where  parents create children and children create parents when a hierarchy is present. This logic
&nbsp;         * works in conjunction with the &quot;early checking&quot; performed earlier in this method
&nbsp;         * (See &quot;Preventing parent/child hierarchy creation loops - Comment 1&quot;), to prevent repeated creation loops.
&nbsp;         *
&nbsp;         *
&nbsp;         * As an aside, defining the current model in the context immediately also ensures that child models are
&nbsp;         * available for modification by resolveSubtypes, when their parents are created.
&nbsp;         */
<b class="nc">&nbsp;        Class&lt;?&gt; currentType = type.getRawClass();</b>
<b class="nc">&nbsp;        context.defineModel(name, model, currentType, null);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * This must be done after model.setProperties so that the model&#39;s set
&nbsp;         * of properties is available to filter from any subtypes
&nbsp;         **/
<b class="nc">&nbsp;        if (!resolveSubtypes(model, beanDesc, context)) {</b>
&nbsp;//            model.setDiscriminator(null);
&nbsp;        }
&nbsp;/*
&nbsp;        if (apiModel != null) {
&nbsp;             * Check if the @ApiModel annotation has a parent property containing a value that should not be ignored
&nbsp;            Class&lt;?&gt; parentClass = apiModel.parent();
&nbsp;            if (parentClass != null &amp;&amp; !parentClass.equals(Void.class) &amp;&amp; !this.shouldIgnoreClass(parentClass)) {
&nbsp;                JavaType parentType = _mapper.constructType(parentClass);
&nbsp;                final BeanDescription parentBeanDesc = _mapper.getSerializationConfig().introspect(parentType);
&nbsp;
&nbsp;//                 * Retrieve all the sub-types of the parent class and ensure that the current type is one of those types
&nbsp;                boolean currentTypeIsParentSubType = false;
&nbsp;                List&lt;NamedType&gt; subTypes = _intr.findSubtypes(parentBeanDesc.getClassInfo());
&nbsp;                if (subTypes != null) {
&nbsp;                    for (NamedType subType : subTypes) {
&nbsp;                        if (subType.getType().equals(currentType)) {
&nbsp;                            currentTypeIsParentSubType = true;
&nbsp;                            break;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;//                 Retrieve the subTypes from the parent class @ApiModel annotation and ensure that the current type
&nbsp;//                 is one of those types.
&nbsp;                boolean currentTypeIsParentApiModelSubType = false;
&nbsp;                final ApiModel parentApiModel = parentBeanDesc.getClassAnnotations().get(ApiModel.class);
&nbsp;                if (parentApiModel != null) {
&nbsp;                    Class&lt;?&gt;[] apiModelSubTypes = parentApiModel.subTypes();
&nbsp;                    if (apiModelSubTypes != null) {
&nbsp;                        for (Class&lt;?&gt; subType : apiModelSubTypes) {
&nbsp;                            if (subType.equals(currentType)) {
&nbsp;                                currentTypeIsParentApiModelSubType = true;
&nbsp;                                break;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;
&nbsp;//                 If the current type is a sub-type of the parent class and is listed in the subTypes property of the
&nbsp;//                 parent class @ApiModel annotation, then do the following:
&nbsp;//                 1. Resolve the model for the parent class. This will result in the parent model being created, and the
&nbsp;//                 current child model being updated to be a ComposedModel referencing the parent.
&nbsp;//                 2. Resolve and return the current child type again. This will return the new ComposedModel from the
&nbsp;//                 context, which was created in step 1 above. Admittedly, there is a small chance that this may result
&nbsp;//                 in a stack overflow, if the context does not correctly cache the model for the current type. However,
&nbsp;//                 as context caching is assumed elsewhere to avoid cyclical model creation, this was deemed to be
&nbsp;//                 sufficient.
&nbsp;
&nbsp;                if (currentTypeIsParentSubType &amp;&amp; currentTypeIsParentApiModelSubType) {
&nbsp;                    context.resolve(parentClass);
&nbsp;                    return context.resolve(currentType);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        */
<b class="nc">&nbsp;        return model;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean ignore(final Annotated member, final XmlAccessorType xmlAccessorTypeAnnotation, final String propName, final Set&lt;String&gt; propertiesToIgnore) {
<b class="nc">&nbsp;        if (propertiesToIgnore.contains(propName)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (xmlAccessorTypeAnnotation == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (xmlAccessorTypeAnnotation.value().equals(XmlAccessType.NONE)) {</b>
<b class="nc">&nbsp;            if (!member.hasAnnotation(XmlElement.class)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleUnwrapped(List&lt;Schema&gt; props, Schema innerModel, String prefix, String suffix) {
<b class="nc">&nbsp;        if (StringUtils.isBlank(suffix) &amp;&amp; StringUtils.isBlank(prefix)) {</b>
<b class="nc">&nbsp;            props.addAll(innerModel.getProperties().values());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (prefix == null) {</b>
<b class="nc">&nbsp;                prefix = &quot;&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (suffix == null) {</b>
<b class="nc">&nbsp;                suffix = &quot;&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Schema prop : (Collection&lt;Schema&gt;)innerModel.getProperties().values()) {</b>
&nbsp;                // TODO
&nbsp;//                props.add(prop.rename(prefix + prop.getName() + suffix));
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private enum GeneratorWrapper {</b>
<b class="nc">&nbsp;        PROPERTY(ObjectIdGenerators.PropertyGenerator.class) {</b>
&nbsp;            @Override
&nbsp;            protected Schema processAsProperty(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
&nbsp;                /*
&nbsp;                 * When generator = ObjectIdGenerators.PropertyGenerator.class and
&nbsp;                 * @JsonIdentityReference(alwaysAsId = false) then property is serialized
&nbsp;                 * in the same way it is done without @JsonIdentityInfo annotation.
&nbsp;                 */
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Schema processAsId(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                final BeanDescription beanDesc = mapper.getSerializationConfig().introspect(type);</b>
<b class="nc">&nbsp;                for (BeanPropertyDefinition def : beanDesc.findProperties()) {</b>
<b class="nc">&nbsp;                    final String name = def.getName();</b>
<b class="nc">&nbsp;                    if (name != null &amp;&amp; name.equals(propertyName)) {</b>
<b class="nc">&nbsp;                        final AnnotatedMember propMember = def.getPrimaryMember();</b>
<b class="nc">&nbsp;                        final JavaType propType = propMember.getType(beanDesc.bindingsForBeanType());</b>
<b class="nc">&nbsp;                        if (PrimitiveType.fromType(propType) != null) {</b>
<b class="nc">&nbsp;                            return PrimitiveType.createProperty(propType);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return context.resolve(propType,</b>
<b class="nc">&nbsp;                                    Iterables.toArray(propMember.annotations(), Annotation.class));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        INT(ObjectIdGenerators.IntSequenceGenerator.class) {</b>
&nbsp;            @Override
&nbsp;            protected Schema processAsProperty(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                Schema id = new IntegerSchema();</b>
<b class="nc">&nbsp;                return process(id, propertyName, type, context);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Schema processAsId(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                return new IntegerSchema();</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        UUID(ObjectIdGenerators.UUIDGenerator.class) {</b>
&nbsp;            @Override
&nbsp;            protected Schema processAsProperty(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                Schema id = new UUIDSchema();</b>
<b class="nc">&nbsp;                return process(id, propertyName, type, context);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Schema processAsId(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                return new UUIDSchema();</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        NONE(ObjectIdGenerators.None.class) {</b>
&nbsp;            // When generator = ObjectIdGenerators.None.class property should be processed as normal property.
&nbsp;            @Override
&nbsp;            protected Schema processAsProperty(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Schema processAsId(String propertyName, JavaType type,
&nbsp;                    ModelConverterContext context, ObjectMapper mapper) {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        private final Class&lt;? extends ObjectIdGenerator&gt; generator;
&nbsp;
<b class="nc">&nbsp;        GeneratorWrapper(Class&lt;? extends ObjectIdGenerator&gt; generator) {</b>
<b class="nc">&nbsp;            this.generator = generator;</b>
&nbsp;        }
&nbsp;
&nbsp;        protected abstract Schema processAsProperty(String propertyName, JavaType type,
&nbsp;                ModelConverterContext context, ObjectMapper mapper);
&nbsp;
&nbsp;        protected abstract Schema processAsId(String propertyName, JavaType type,
&nbsp;                ModelConverterContext context, ObjectMapper mapper);
&nbsp;
&nbsp;        public static Schema processJsonIdentity(JavaType type, ModelConverterContext context,
&nbsp;                ObjectMapper mapper, JsonIdentityInfo identityInfo,
&nbsp;                JsonIdentityReference identityReference) {
<b class="nc">&nbsp;            final GeneratorWrapper wrapper = identityInfo != null ? getWrapper(identityInfo.generator()) : null;</b>
<b class="nc">&nbsp;            if (wrapper == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (identityReference != null &amp;&amp; identityReference.alwaysAsId()) {</b>
<b class="nc">&nbsp;                return wrapper.processAsId(identityInfo.property(), type, context, mapper);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return wrapper.processAsProperty(identityInfo.property(), type, context, mapper);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static GeneratorWrapper getWrapper(Class&lt;?&gt; generator) {
<b class="nc">&nbsp;            for (GeneratorWrapper value : GeneratorWrapper.values()) {</b>
<b class="nc">&nbsp;                if (value.generator.isAssignableFrom(generator)) {</b>
<b class="nc">&nbsp;                    return value;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static Schema process(Schema id, String propertyName, JavaType type,
&nbsp;                ModelConverterContext context) {
&nbsp;//            id.setTitle(propertyName);
<b class="nc">&nbsp;            Schema model = context.resolve(type);</b>
&nbsp;            // TODO
&nbsp;//            if (model instanceof ComposedModel) {
&nbsp;//                model = ((ComposedModel) model).getChild();
&nbsp;//            }
&nbsp;//            if (model instanceof ModelImpl) {
<b class="nc">&nbsp;                Schema mi = (Schema) model;</b>
<b class="nc">&nbsp;                mi.getProperties().put(propertyName, id);</b>
<b class="nc">&nbsp;                return new Schema().$ref(StringUtils.isNotEmpty(mi.get$ref())</b>
<b class="nc">&nbsp;                        ? mi.get$ref() : mi.getTitle());</b>
&nbsp;//            }
&nbsp;//            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void applyBeanValidatorAnnotations(Schema property, Annotation[] annotations) {
<b class="nc">&nbsp;        Map&lt;String, Annotation&gt; annos = new HashMap&lt;String, Annotation&gt;();</b>
<b class="nc">&nbsp;        if (annotations != null) {</b>
<b class="nc">&nbsp;            for (Annotation anno : annotations) {</b>
<b class="nc">&nbsp;                annos.put(anno.annotationType().getName(), anno);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.NotNull&quot;)) {</b>
&nbsp;//            property.setRequired(true);
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.Min&quot;)) {</b>
<b class="nc">&nbsp;            if (&quot;integer&quot;.equals(property.getType()) || &quot;number&quot;. equals(property.getType())) {</b>
<b class="nc">&nbsp;                Min min = (Min) annos.get(&quot;javax.validation.constraints.Min&quot;);</b>
&nbsp;//                AbstractNumericProperty ap = (AbstractNumericProperty) property;
<b class="nc">&nbsp;                property.setMinimum(new BigDecimal(min.value()));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.Max&quot;)) {</b>
<b class="nc">&nbsp;            if (&quot;integer&quot;.equals(property.getType()) || &quot;number&quot;. equals(property.getType())) {</b>
<b class="nc">&nbsp;                Max max = (Max) annos.get(&quot;javax.validation.constraints.Max&quot;);</b>
<b class="nc">&nbsp;                property.setMaximum(new BigDecimal(max.value()));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.Size&quot;)) {</b>
<b class="nc">&nbsp;            Size size = (Size) annos.get(&quot;javax.validation.constraints.Size&quot;);</b>
<b class="nc">&nbsp;            if (&quot;integer&quot;.equals(property.getType()) || &quot;number&quot;. equals(property.getType())) {</b>
<b class="nc">&nbsp;                property.setMinimum(new BigDecimal(size.min()));</b>
<b class="nc">&nbsp;                property.setMaximum(new BigDecimal(size.max()));</b>
<b class="nc">&nbsp;            } else if (property instanceof StringSchema) {</b>
<b class="nc">&nbsp;                StringSchema sp = (StringSchema) property;</b>
<b class="nc">&nbsp;                sp.minLength(new Integer(size.min()));</b>
<b class="nc">&nbsp;                sp.maxLength(new Integer(size.max()));</b>
&nbsp;            } /*else if (property instanceof ArrayProperty) {
&nbsp;                ArrayProperty sp = (ArrayProperty) property;
&nbsp;                sp.setMinItems(size.min());
&nbsp;                sp.setMaxItems(size.max());
&nbsp;            }*/
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.DecimalMin&quot;)) {</b>
<b class="nc">&nbsp;            DecimalMin min = (DecimalMin) annos.get(&quot;javax.validation.constraints.DecimalMin&quot;);</b>
<b class="nc">&nbsp;            if (property instanceof NumberSchema) {</b>
<b class="nc">&nbsp;                NumberSchema ap = (NumberSchema) property;</b>
<b class="nc">&nbsp;                ap.setMinimum(new BigDecimal(min.value()));</b>
<b class="nc">&nbsp;                ap.setExclusiveMinimum(!min.inclusive());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.DecimalMax&quot;)) {</b>
<b class="nc">&nbsp;            DecimalMax max = (DecimalMax) annos.get(&quot;javax.validation.constraints.DecimalMax&quot;);</b>
<b class="nc">&nbsp;            if (property instanceof NumberSchema) {</b>
<b class="nc">&nbsp;                NumberSchema ap = (NumberSchema) property;</b>
<b class="nc">&nbsp;                ap.setMaximum(new BigDecimal(max.value()));</b>
<b class="nc">&nbsp;                ap.setExclusiveMaximum(!max.inclusive());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (annos.containsKey(&quot;javax.validation.constraints.Pattern&quot;)) {</b>
<b class="nc">&nbsp;            Pattern pattern = (Pattern) annos.get(&quot;javax.validation.constraints.Pattern&quot;);</b>
<b class="nc">&nbsp;            if (property instanceof StringSchema) {</b>
<b class="nc">&nbsp;                property.setPattern(pattern.regexp());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected JavaType getInnerType(String innerType) {
&nbsp;        try {
<b class="nc">&nbsp;            Class&lt;?&gt; innerClass = ReflectionUtils.loadClassByName(innerType);</b>
<b class="nc">&nbsp;            if (innerClass != null) {</b>
<b class="nc">&nbsp;                TypeFactory tf = _mapper.getTypeFactory();</b>
<b class="nc">&nbsp;                return tf.constructType(innerClass);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (ClassNotFoundException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean resolveSubtypes(Schema model, BeanDescription bean, ModelConverterContext context) {
<b class="nc">&nbsp;        final List&lt;NamedType&gt; types = _intr.findSubtypes(bean.getClassInfo());</b>
&nbsp;
<b class="nc">&nbsp;        if (types == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * As the introspector will find @JsonSubTypes for a child class that are present on its super classes, the
&nbsp;         * code segment below will also run the introspector on the parent class, and then remove any sub-types that are
&nbsp;         * found for the parent from the sub-types found for the child. The same logic all applies to implemented
&nbsp;         * interfaces, and is accounted for below.
&nbsp;         */
<b class="nc">&nbsp;        removeSuperClassAndInterfaceSubTypes(types, bean);</b>
&nbsp;
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        final Class&lt;?&gt; beanClass = bean.getClassInfo().getAnnotated();</b>
<b class="nc">&nbsp;        for (NamedType subtype : types) {</b>
<b class="nc">&nbsp;            final Class&lt;?&gt; subtypeType = subtype.getType();</b>
<b class="nc">&nbsp;            if (!beanClass.isAssignableFrom(subtypeType)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final Schema subtypeModel = context.resolve(subtypeType);</b>
&nbsp;
&nbsp;            // TODO
&nbsp;            /*
&nbsp;            if (subtypeModel instanceof ModelImpl) {
&nbsp;                final ModelImpl impl = (ModelImpl) subtypeModel;
&nbsp;
&nbsp;                // check if model name was inherited
&nbsp;                if (impl.getName().equals(model.getName())) {
&nbsp;                    impl.setName(_typeNameResolver.nameForType(_mapper.constructType(subtypeType),
&nbsp;                            TypeNameResolver.Options.SKIP_API_MODEL));
&nbsp;                }
&nbsp;
&nbsp;                // remove shared properties defined in the parent
&nbsp;                final Map&lt;String, Property&gt; baseProps = model.getProperties();
&nbsp;                final Map&lt;String, Property&gt; subtypeProps = impl.getProperties();
&nbsp;                if (baseProps != null &amp;&amp; subtypeProps != null) {
&nbsp;                    for (Map.Entry&lt;String, Property&gt; entry : baseProps.entrySet()) {
&nbsp;                        if (entry.getValue().equals(subtypeProps.get(entry.getKey()))) {
&nbsp;                            subtypeProps.remove(entry.getKey());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                impl.setDiscriminator(null);
&nbsp;                ComposedModel child = new ComposedModel().parent(new RefModel(model.getName())).child(impl);
&nbsp;                context.defineModel(impl.getName(), child, subtypeType, null);
&nbsp;                ++count;
&nbsp;            }
&nbsp;            */
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count != 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void removeSuperClassAndInterfaceSubTypes(List&lt;NamedType&gt; types, BeanDescription bean) {
<b class="nc">&nbsp;        Class&lt;?&gt; beanClass = bean.getType().getRawClass();</b>
<b class="nc">&nbsp;        Class&lt;?&gt; superClass = beanClass.getSuperclass();</b>
<b class="nc">&nbsp;        if (superClass != null &amp;&amp; !superClass.equals(Object.class)) {</b>
<b class="nc">&nbsp;            removeSuperSubTypes(types, superClass);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!types.isEmpty()) {</b>
<b class="nc">&nbsp;            Class&lt;?&gt;[] superInterfaces = beanClass.getInterfaces();</b>
<b class="nc">&nbsp;            for (Class&lt;?&gt; superInterface : superInterfaces) {</b>
<b class="nc">&nbsp;                removeSuperSubTypes(types, superInterface);</b>
<b class="nc">&nbsp;                if (types.isEmpty()) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void removeSuperSubTypes(List&lt;NamedType&gt; resultTypes, Class&lt;?&gt; superClass) {
<b class="nc">&nbsp;        JavaType superType = _mapper.constructType(superClass);</b>
<b class="nc">&nbsp;        BeanDescription superBean = _mapper.getSerializationConfig().introspect(superType);</b>
<b class="nc">&nbsp;        final List&lt;NamedType&gt; superTypes = _intr.findSubtypes(superBean.getClassInfo());</b>
<b class="nc">&nbsp;        if (superTypes != null) {</b>
<b class="nc">&nbsp;            resultTypes.removeAll(superTypes);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 22:26</div>
</div>
</body>
</html>
