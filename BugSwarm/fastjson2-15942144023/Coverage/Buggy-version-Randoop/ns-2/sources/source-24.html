


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JSONReaderJSONB</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.alibaba.fastjson2</a>
</div>

<h1>Coverage Summary for Class: JSONReaderJSONB (com.alibaba.fastjson2)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JSONReaderJSONB</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/136)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2966)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.alibaba.fastjson2;
&nbsp;
&nbsp;import com.alibaba.fastjson2.reader.*;
&nbsp;import com.alibaba.fastjson2.util.*;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.time.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static com.alibaba.fastjson2.JSONB.Constants.*;
&nbsp;import static com.alibaba.fastjson2.JSONB.typeName;
&nbsp;import static com.alibaba.fastjson2.JSONFactory.*;
&nbsp;import static com.alibaba.fastjson2.util.DateUtils.*;
&nbsp;import static com.alibaba.fastjson2.util.JDKUtils.*;
&nbsp;import static com.alibaba.fastjson2.util.TypeUtils.toBigDecimal;
&nbsp;
&nbsp;final class JSONReaderJSONB
&nbsp;        extends JSONReader {
<b class="nc">&nbsp;    static final long BASE = UNSAFE.arrayBaseOffset(byte[].class);</b>
&nbsp;
<b class="nc">&nbsp;    static final byte[] SHANGHAI_ZONE_ID_NAME_BYTES = JSONB.toBytes(SHANGHAI_ZONE_ID_NAME);</b>
&nbsp;    static Charset GB18030;
&nbsp;
&nbsp;    protected final byte[] bytes;
&nbsp;    protected final int length;
&nbsp;    protected final int end;
&nbsp;
&nbsp;    protected byte type;
&nbsp;    protected int strlen;
&nbsp;    protected byte strtype;
&nbsp;    protected int strBegin;
&nbsp;
&nbsp;    protected byte[] valueBytes;
&nbsp;    protected final CacheItem cacheItem;
&nbsp;
&nbsp;    protected final SymbolTable symbolTable;
&nbsp;
&nbsp;    protected long symbol0Hash;
&nbsp;    protected int symbol0Begin;
&nbsp;    protected int symbol0Length;
&nbsp;    protected byte symbol0StrType;
&nbsp;
&nbsp;    protected long[] symbols;
&nbsp;
&nbsp;    JSONReaderJSONB(Context ctx, InputStream is) {
<b class="nc">&nbsp;        super(ctx, true, false);</b>
&nbsp;
<b class="nc">&nbsp;        int cacheIndex = System.identityHashCode(Thread.currentThread()) &amp; (CACHE_ITEMS.length - 1);</b>
<b class="nc">&nbsp;        cacheItem = CACHE_ITEMS[cacheIndex];</b>
<b class="nc">&nbsp;        byte[] bytes = BYTES_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;        int bufferSize = ctx.bufferSize;</b>
<b class="nc">&nbsp;        if (bytes == null) {</b>
<b class="nc">&nbsp;            bytes = new byte[bufferSize];</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int off = 0;</b>
&nbsp;        try {
&nbsp;            for (; ; ) {
<b class="nc">&nbsp;                int n = is.read(bytes, off, bytes.length - off);</b>
<b class="nc">&nbsp;                if (n == -1) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                off += n;</b>
&nbsp;
<b class="nc">&nbsp;                if (off == bytes.length) {</b>
<b class="nc">&nbsp;                    bytes = Arrays.copyOf(bytes, bytes.length + bufferSize);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (IOException ioe) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;read error&quot;, ioe);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        this.bytes = bytes;</b>
<b class="nc">&nbsp;        this.offset = 0;</b>
<b class="nc">&nbsp;        this.length = off;</b>
<b class="nc">&nbsp;        this.end = length;</b>
<b class="nc">&nbsp;        this.symbolTable = ctx.symbolTable;</b>
&nbsp;    }
&nbsp;
&nbsp;    JSONReaderJSONB(Context ctx, byte[] bytes, int off, int length) {
<b class="nc">&nbsp;        super(ctx, true, false);</b>
<b class="nc">&nbsp;        this.bytes = bytes;</b>
<b class="nc">&nbsp;        this.offset = off;</b>
<b class="nc">&nbsp;        this.length = length;</b>
<b class="nc">&nbsp;        this.end = off + length;</b>
<b class="nc">&nbsp;        this.symbolTable = ctx.symbolTable;</b>
<b class="nc">&nbsp;        this.cacheItem = CACHE_ITEMS[System.identityHashCode(Thread.currentThread()) &amp; (CACHE_ITEMS.length - 1)];</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getString() {
<b class="nc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            return symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
&nbsp;        Charset charset;
<b class="nc">&nbsp;        if (strtype == BC_STR_ASCII) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.ISO_8859_1;</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;                char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                    chars[i] = (char) (bytes[strBegin + i] &amp; 0xff);</b>
&nbsp;                }
<b class="nc">&nbsp;                return STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;            } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, strBegin, chars, 0, strlen);</b>
<b class="nc">&nbsp;                return STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
&nbsp;            }
<b class="nc">&nbsp;            charset = StandardCharsets.ISO_8859_1;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_SYMBOL) {</b>
<b class="nc">&nbsp;            int symbol = strlen;</b>
<b class="nc">&nbsp;            int index = symbol * 2;</b>
&nbsp;//            return symbols[index];
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + JSONB.typeName(strtype));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + JSONB.typeName(strtype));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new String(bytes, strBegin, strlen, charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int readLength() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int len = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;            return len;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_INT32) {</b>
<b class="nc">&nbsp;            int len = getInt(bytes, offset);</b>
<b class="nc">&nbsp;            offset += 4;</b>
<b class="nc">&nbsp;            if (len &gt; 1024 * 1024 * 256) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;input length overflow&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return len;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;not support length type : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    static int getInt3(byte[] bytes, int offset, int type) {
<b class="nc">&nbsp;        return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                + ((bytes[offset] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                + (bytes[offset + 1] &amp; 0xFF);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isArray() {
<b class="nc">&nbsp;        if (offset &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        byte type = bytes[offset];</b>
<b class="nc">&nbsp;        return type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isObject() {
<b class="nc">&nbsp;        return offset &lt; end &amp;&amp; bytes[offset] == BC_OBJECT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isNumber() {
<b class="nc">&nbsp;        byte type = bytes[offset];</b>
<b class="nc">&nbsp;        return type &gt;= BC_DOUBLE_NUM_0 &amp;&amp; type &lt;= BC_INT32;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isString() {
<b class="nc">&nbsp;        return offset &lt; bytes.length</b>
&nbsp;                &amp;&amp; (type = bytes[offset]) &gt;= BC_STR_ASCII_FIX_MIN;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatch(char ch) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfArrayStart() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfComma() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfArrayEnd() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfObjectStart() {
<b class="nc">&nbsp;        if (bytes[offset] != BC_OBJECT) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfObjectEnd() {
<b class="nc">&nbsp;        if (bytes[offset] != BC_OBJECT_END) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfNullOrEmptyString() {
<b class="nc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 1;</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T read(Type type) {
<b class="nc">&nbsp;        boolean fieldBased = (context.features &amp; Feature.FieldBased.mask) != 0;</b>
<b class="nc">&nbsp;        ObjectReader objectReader = context.provider.getObjectReader(type, fieldBased);</b>
<b class="nc">&nbsp;        return (T) objectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T read(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        boolean fieldBased = (context.features &amp; Feature.FieldBased.mask) != 0;</b>
<b class="nc">&nbsp;        ObjectReader objectReader = context.provider.getObjectReader(type, fieldBased);</b>
<b class="nc">&nbsp;        return (T) objectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Map&lt;String, Object&gt; readObject() {
<b class="nc">&nbsp;        type = bytes[offset++];</b>
<b class="nc">&nbsp;        if (type == BC_NULL) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_OBJECT) {</b>
&nbsp;            Map map;
<b class="nc">&nbsp;            if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                if (JVM_VERSION == 8 &amp;&amp; bytes[offset] != BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                    map = new HashMap(10);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    map = new HashMap();</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (JVM_VERSION == 8 &amp;&amp; bytes[offset] != BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                    map = new JSONObject(10);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    map = new JSONObject();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (int i = 0; ; ++i) {</b>
<b class="nc">&nbsp;                type = bytes[offset];</b>
<b class="nc">&nbsp;                if (type == BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
&nbsp;                Object name;
<b class="nc">&nbsp;                if (isString()) {</b>
<b class="nc">&nbsp;                    name = readFieldName();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    name = readAny();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (offset &lt; bytes.length &amp;&amp; bytes[offset] == BC_REFERENCE) {</b>
<b class="nc">&nbsp;                    String reference = readReference();</b>
<b class="nc">&nbsp;                    if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                        map.put(name, map);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        addResolveTask(map, name, JSONPath.of(reference));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                byte valueType = bytes[offset];</b>
&nbsp;                Object value;
<b class="nc">&nbsp;                if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                    value = readString();</b>
<b class="nc">&nbsp;                } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    value = (int) valueType;</b>
<b class="nc">&nbsp;                } else if (valueType == BC_TRUE) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    value = Boolean.TRUE;</b>
<b class="nc">&nbsp;                } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    value = Boolean.FALSE;</b>
<b class="nc">&nbsp;                } else if (valueType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                    value = readObject();</b>
<b class="nc">&nbsp;                } else if (valueType == BC_INT64) {</b>
<b class="nc">&nbsp;                    long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset + 1);</b>
<b class="nc">&nbsp;                    offset += 9;</b>
<b class="nc">&nbsp;                    value = BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value);</b>
<b class="nc">&nbsp;                } else if (valueType &gt;= BC_ARRAY_FIX_MIN &amp;&amp; valueType &lt;= BC_ARRAY) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                    int len;
<b class="nc">&nbsp;                    if (valueType == BC_ARRAY) {</b>
<b class="nc">&nbsp;                        byte itemType = bytes[offset];</b>
<b class="nc">&nbsp;                        if (itemType &gt;= BC_INT32_NUM_MIN &amp;&amp; itemType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                            offset++;</b>
<b class="nc">&nbsp;                            len = itemType;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            len = readLength();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        len = valueType - BC_ARRAY_FIX_MIN;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (len == 0) {</b>
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            value = new ArrayList&lt;&gt;();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                                value = context.arraySupplier.get();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                value = new JSONArray();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        List list;
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            list = new ArrayList(len);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            list = new JSONArray(len);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        for (int j = 0; j &lt; len; ++j) {</b>
<b class="nc">&nbsp;                            if (isReference()) {</b>
<b class="nc">&nbsp;                                String reference = readReference();</b>
<b class="nc">&nbsp;                                if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                    list.add(list);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    list.add(null);</b>
<b class="nc">&nbsp;                                    addResolveTask(list, j, JSONPath.of(reference));</b>
&nbsp;                                }
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            byte itemType = bytes[offset];</b>
&nbsp;                            Object item;
<b class="nc">&nbsp;                            if (itemType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; itemType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                                item = readString();</b>
<b class="nc">&nbsp;                            } else if (itemType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                                item = readObject();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                item = readAny();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            list.add(item);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        value = list;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (valueType &gt;= BC_INT32_BYTE_MIN &amp;&amp; valueType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    value = ((valueType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset + 1] &amp; 0xFF);
<b class="nc">&nbsp;                    offset += 2;</b>
<b class="nc">&nbsp;                } else if (valueType &gt;= BC_INT32_SHORT_MIN &amp;&amp; valueType &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int32Value = getInt3(bytes, offset + 1, valueType);</b>
<b class="nc">&nbsp;                    offset += 3;</b>
<b class="nc">&nbsp;                    value = int32Value;</b>
<b class="nc">&nbsp;                } else if (valueType == BC_INT32) {</b>
<b class="nc">&nbsp;                    int int32Value = getInt(bytes, offset + 1);</b>
<b class="nc">&nbsp;                    offset += 5;</b>
<b class="nc">&nbsp;                    value = int32Value;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    value = readAny();</b>
&nbsp;                }
<b class="nc">&nbsp;                map.put(name, value);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return map;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            ObjectReader objectReader = checkAutoType(Map.class, 0, 0);</b>
<b class="nc">&nbsp;            return (Map) objectReader.readObject(this, null, null, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;object not support input &quot; + error(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void read(final Map map, long features) {
<b class="nc">&nbsp;        if (bytes[offset] != BC_OBJECT) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;object not support input &quot; + error(type));</b>
&nbsp;        }
<b class="nc">&nbsp;        offset++;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; ; ++i) {</b>
<b class="nc">&nbsp;            byte type = bytes[offset];</b>
<b class="nc">&nbsp;            if (type == BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            Object name;
<b class="nc">&nbsp;            if (type &gt;= BC_STR_ASCII_FIX_MIN) {</b>
<b class="nc">&nbsp;                name = readFieldName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                name = readAny();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (isReference()) {</b>
<b class="nc">&nbsp;                String reference = readReference();</b>
<b class="nc">&nbsp;                if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                    map.put(name, map);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    addResolveTask(map, name, JSONPath.of(reference));</b>
<b class="nc">&nbsp;                    map.put(name, null);</b>
&nbsp;                }
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            byte valueType = bytes[offset];</b>
&nbsp;            Object value;
<b class="nc">&nbsp;            if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                value = readString();</b>
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = (int) valueType;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_TRUE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.TRUE;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.FALSE;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                value = readObject();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                value = readAny();</b>
&nbsp;            }
<b class="nc">&nbsp;            map.put(name, value);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object readAny() {
<b class="nc">&nbsp;        if (offset &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;readAny overflow : &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_TRUE:
<b class="nc">&nbsp;                return true;</b>
&nbsp;            case BC_FALSE:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                return (short) ((bytes[offset++] &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF));
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return (long) int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                int len = readInt32Value();</b>
<b class="nc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                return (double) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
&nbsp;
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    if (valueBytes == null) {</b>
<b class="nc">&nbsp;                        valueBytes = BYTES_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;                        if (valueBytes == null) {</b>
<b class="nc">&nbsp;                            valueBytes = new byte[8192];</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;                    if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                        valueBytes = new byte[minCapacity];</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;                    if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                        byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                        System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                        String str = STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        return str;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
&nbsp;
&nbsp;                String str;
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, strlen == 0 ? LATIN1 : UTF16);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16BE: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
&nbsp;
&nbsp;                String str;
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, strlen == 0 ? LATIN1 : UTF16);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    str = new String(bytes, offset, strlen, StandardCharsets.UTF_16BE);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_GB18030: {
<b class="nc">&nbsp;                if (GB18030 == null) {</b>
<b class="nc">&nbsp;                    GB18030 = Charset.forName(&quot;GB18030&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                int strlen = readLength();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, GB18030);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal;</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG: {
<b class="nc">&nbsp;                return BigDecimal.valueOf(</b>
<b class="nc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_BINARY: {
<b class="nc">&nbsp;                int len = readLength();</b>
<b class="nc">&nbsp;                byte[] binary = Arrays.copyOfRange(this.bytes, offset, offset + len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return binary;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return new Date(minutes * 60L * 1000L);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long seconds = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return new Date(seconds * 1000);</b>
&nbsp;            }
&nbsp;            case BC_LOCAL_DATE: {
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                byte month = bytes[offset++];</b>
<b class="nc">&nbsp;                byte dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                return LocalDate.of(year, month, dayOfMonth);</b>
&nbsp;            }
&nbsp;            case BC_LOCAL_TIME: {
<b class="nc">&nbsp;                byte hour = bytes[offset++];</b>
<b class="nc">&nbsp;                byte minute = bytes[offset++];</b>
<b class="nc">&nbsp;                byte second = bytes[offset++];</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                return LocalTime.of(hour, minute, second, nano);</b>
&nbsp;            }
&nbsp;            case BC_LOCAL_DATETIME: {
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                byte month = bytes[offset++];</b>
<b class="nc">&nbsp;                byte dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                byte hour = bytes[offset++];</b>
<b class="nc">&nbsp;                byte minute = bytes[offset++];</b>
<b class="nc">&nbsp;                byte second = bytes[offset++];</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                return LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_WITH_TIMEZONE: {
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                byte month = bytes[offset++];</b>
<b class="nc">&nbsp;                byte dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                byte hour = bytes[offset++];</b>
<b class="nc">&nbsp;                byte minute = bytes[offset++];</b>
<b class="nc">&nbsp;                byte second = bytes[offset++];</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
&nbsp;                // SHANGHAI_ZONE_ID_NAME_BYTES
&nbsp;                ZoneId zoneId;
&nbsp;                {
&nbsp;                    boolean shanghai;
<b class="nc">&nbsp;                    byte[] shanghaiZoneIdNameBytes = SHANGHAI_ZONE_ID_NAME_BYTES;</b>
<b class="nc">&nbsp;                    if (offset + shanghaiZoneIdNameBytes.length &lt; bytes.length) {</b>
<b class="nc">&nbsp;                        shanghai = true;</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; shanghaiZoneIdNameBytes.length; ++i) {</b>
<b class="nc">&nbsp;                            if (bytes[offset + i] != shanghaiZoneIdNameBytes[i]) {</b>
<b class="nc">&nbsp;                                shanghai = false;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        shanghai = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (shanghai) {</b>
<b class="nc">&nbsp;                        offset += shanghaiZoneIdNameBytes.length;</b>
<b class="nc">&nbsp;                        zoneId = SHANGHAI_ZONE_ID;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        String zoneIdStr = readString();</b>
<b class="nc">&nbsp;                        zoneId = DateUtils.getZoneId(zoneIdStr, SHANGHAI_ZONE_ID);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                LocalDateTime ldt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
<b class="nc">&nbsp;                return ZonedDateTime.of(ldt, zoneId);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP: {
<b class="nc">&nbsp;                long epochSeconds = readInt64Value();</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                return Instant.ofEpochSecond(epochSeconds, nano);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return new Date(BIG_ENDIAN ? millis : Long.reverseBytes(millis));</b>
&nbsp;            }
&nbsp;            case BC_BIGINT_LONG: {
<b class="nc">&nbsp;                return BigInteger.valueOf(</b>
<b class="nc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                long typeHash = readTypeHashCode();</b>
&nbsp;
<b class="nc">&nbsp;                if (context.autoTypeBeforeHandler != null) {</b>
<b class="nc">&nbsp;                    Class&lt;?&gt; filterClass = context.autoTypeBeforeHandler.apply(typeHash, null, context.features);</b>
&nbsp;
<b class="nc">&nbsp;                    if (filterClass == null) {</b>
<b class="nc">&nbsp;                        String typeName = getString();</b>
<b class="nc">&nbsp;                        filterClass = context.autoTypeBeforeHandler.apply(typeName, null, context.features);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (filterClass != null) {</b>
<b class="nc">&nbsp;                        ObjectReader autoTypeObjectReader = context.getObjectReader(filterClass);</b>
<b class="nc">&nbsp;                        return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                boolean supportAutoType = (context.features &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="nc">&nbsp;                if (!supportAutoType) {</b>
<b class="nc">&nbsp;                    if (isObject()) {</b>
<b class="nc">&nbsp;                        return readObject();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (isArray()) {</b>
<b class="nc">&nbsp;                        return readArray();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    throw new JSONException(&quot;auoType not support , offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                ObjectReader autoTypeObjectReader = context.getObjectReaderAutoType(typeHash);</b>
<b class="nc">&nbsp;                if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                    String typeName = getString();</b>
<b class="nc">&nbsp;                    autoTypeObjectReader = context.getObjectReaderAutoType(typeName, null);</b>
&nbsp;
<b class="nc">&nbsp;                    if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                        throw new JSONException(&quot;auoType not support : &quot; + typeName + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0D;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return 1D;</b>
&nbsp;            case BC_CHAR:
<b class="nc">&nbsp;                int intValue = readInt32Value();</b>
<b class="nc">&nbsp;                return (char) intValue;</b>
&nbsp;            case BC_OBJECT: {
<b class="nc">&nbsp;                Map map = null;</b>
<b class="nc">&nbsp;                boolean supportAutoType = (context.features &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="nc">&nbsp;                for (int i = 0; ; ++i) {</b>
<b class="nc">&nbsp;                    byte type = bytes[offset];</b>
<b class="nc">&nbsp;                    if (type == BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    Object name;
<b class="nc">&nbsp;                    if (supportAutoType &amp;&amp; i == 0 &amp;&amp; type &gt;= BC_STR_ASCII_FIX_MIN) {</b>
<b class="nc">&nbsp;                        long hash = readFieldNameHashCode();</b>
<b class="nc">&nbsp;                        if (hash == ObjectReader.HASH_TYPE) {</b>
<b class="nc">&nbsp;                            long typeHash = readValueHashCode();</b>
<b class="nc">&nbsp;                            ObjectReader autoTypeObjectReader = context.getObjectReaderAutoType(typeHash);</b>
<b class="nc">&nbsp;                            if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                                String typeName = getString();</b>
<b class="nc">&nbsp;                                autoTypeObjectReader = context.getObjectReaderAutoType(typeName, null);</b>
&nbsp;
<b class="nc">&nbsp;                                if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                                    throw new JSONException(&quot;auotype not support : &quot; + typeName + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            typeRedirect = true;</b>
<b class="nc">&nbsp;                            return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        name = getFieldName();</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        if (type &gt;= BC_STR_ASCII_FIX_MIN) {</b>
<b class="nc">&nbsp;                            name = readFieldName();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            name = readAny();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (map == null) {</b>
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            map = new HashMap();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            map = new JSONObject();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (isReference()) {</b>
<b class="nc">&nbsp;                        String reference = readReference();</b>
<b class="nc">&nbsp;                        if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                            map.put(name, map);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            addResolveTask(map, name, JSONPath.of(reference));</b>
<b class="nc">&nbsp;                            map.put(name, null);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    byte valueType = bytes[offset];</b>
&nbsp;                    Object value;
<b class="nc">&nbsp;                    if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                        value = readString();</b>
<b class="nc">&nbsp;                    } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        value = (int) valueType;</b>
<b class="nc">&nbsp;                    } else if (valueType == BC_TRUE) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        value = Boolean.TRUE;</b>
<b class="nc">&nbsp;                    } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        value = Boolean.FALSE;</b>
<b class="nc">&nbsp;                    } else if (valueType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                        value = readObject();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        value = readAny();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    map.put(name, value);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (map == null) {</b>
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        map = new HashMap();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        map = new JSONObject();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return map;</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return (int) type;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;                    offset += 2;</b>
<b class="nc">&nbsp;                    return int3;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return (long) ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    return (long) (((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF));
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY) {</b>
<b class="nc">&nbsp;                    int len = type == BC_ARRAY</b>
<b class="nc">&nbsp;                            ? readLength()</b>
&nbsp;                            : type - BC_ARRAY_FIX_MIN;
&nbsp;
<b class="nc">&nbsp;                    if (len == 0) {</b>
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            return new ArrayList&lt;&gt;();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                                return context.arraySupplier.get();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return new JSONArray();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    List list;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        list = new ArrayList(len);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        list = new JSONArray(len);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    for (int i = 0; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;                        if (isReference()) {</b>
<b class="nc">&nbsp;                            String reference = readReference();</b>
<b class="nc">&nbsp;                            if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                list.add(list);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                list.add(null);</b>
<b class="nc">&nbsp;                                addResolveTask(list, i, JSONPath.of(reference));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        Object item = readAny();</b>
<b class="nc">&nbsp;                        list.add(item);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return list;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII) {</b>
<b class="nc">&nbsp;                    strlen = type == BC_STR_ASCII</b>
<b class="nc">&nbsp;                            ? readLength()</b>
&nbsp;                            : type - BC_STR_ASCII_FIX_MIN;
&nbsp;
<b class="nc">&nbsp;                    if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;                        return symbolTable.getName(-strlen);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;                        char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                            chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                        String str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                            str = str.trim();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return str;</b>
<b class="nc">&nbsp;                    } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                        byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                        System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        String str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
&nbsp;
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                            str = str.trim();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return str;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                        str = str.trim();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return str;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type == BC_SYMBOL) {</b>
<b class="nc">&nbsp;                    strlen = readLength();</b>
&nbsp;
<b class="nc">&nbsp;                    if (strlen &gt;= 0) {</b>
<b class="nc">&nbsp;                        throw new JSONException(&quot;not support symbol : &quot; + strlen);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return symbolTable.getName(-strlen);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                throw new JSONException(&quot;not support type : &quot; + error(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte getType() {
<b class="nc">&nbsp;        return bytes[offset];</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List readArray() {
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        JSONArray array = new JSONArray(entryCnt);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            byte valueType = bytes[offset];</b>
&nbsp;            Object value;
<b class="nc">&nbsp;            if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                value = readString();</b>
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = (int) valueType;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_TRUE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.TRUE;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.FALSE;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                value = readObject();</b>
<b class="nc">&nbsp;            } else if (valueType == BC_INT64) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                value = BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value);</b>
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_ARRAY_FIX_MIN &amp;&amp; valueType &lt;= BC_ARRAY) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                int len = valueType == BC_ARRAY</b>
<b class="nc">&nbsp;                        ? readLength()</b>
&nbsp;                        : valueType - BC_ARRAY_FIX_MIN;
&nbsp;
<b class="nc">&nbsp;                if (len == 0) {</b>
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        value = new ArrayList&lt;&gt;();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                            value = context.arraySupplier.get();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            value = new JSONArray();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    List list;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        list = new ArrayList(len);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        list = new JSONArray(len);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    for (int j = 0; j &lt; len; ++j) {</b>
<b class="nc">&nbsp;                        if (isReference()) {</b>
<b class="nc">&nbsp;                            String reference = readReference();</b>
<b class="nc">&nbsp;                            if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                list.add(list);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                list.add(null);</b>
<b class="nc">&nbsp;                                addResolveTask(list, j, JSONPath.of(reference));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        byte itemType = bytes[offset];</b>
&nbsp;                        Object item;
<b class="nc">&nbsp;                        if (itemType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; itemType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                            item = readString();</b>
<b class="nc">&nbsp;                        } else if (itemType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                            item = readObject();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            item = readAny();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        list.add(item);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    value = list;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_INT32_BYTE_MIN &amp;&amp; valueType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                value = ((valueType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset + 1] &amp; 0xFF);
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_INT32_SHORT_MIN &amp;&amp; valueType &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                int int3 = getInt3(bytes, offset + 1, valueType);</b>
<b class="nc">&nbsp;                offset += 3;</b>
<b class="nc">&nbsp;                value = int3;</b>
<b class="nc">&nbsp;            } else if (valueType == BC_INT32) {</b>
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 5;</b>
<b class="nc">&nbsp;                value = BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value);</b>
<b class="nc">&nbsp;            } else if (valueType == BC_REFERENCE) {</b>
<b class="nc">&nbsp;                String reference = readReference();</b>
<b class="nc">&nbsp;                if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                    value = array;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    addResolveTask(array, i, JSONPath.of(reference));</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                value = readAny();</b>
&nbsp;            }
<b class="nc">&nbsp;            array.add(value);</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List readArray(Type itemType) {
<b class="nc">&nbsp;        if (nextIfNull()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (bytes[offset] == BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            Object obj = readAny();</b>
<b class="nc">&nbsp;            if (obj instanceof List) {</b>
<b class="nc">&nbsp;                return (List) obj;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (obj instanceof Collection) {</b>
<b class="nc">&nbsp;                return new JSONArray((Collection) obj);</b>
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;not support class &quot; + obj.getClass());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        JSONArray array = new JSONArray(entryCnt);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            array.add(read(itemType));</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List readList(Type[] types) {
<b class="nc">&nbsp;        if (nextIfNull()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        JSONArray array = new JSONArray(entryCnt);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            Type itemType = types[i];</b>
<b class="nc">&nbsp;            array.add(read(itemType));</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte[] readHex() {
<b class="nc">&nbsp;        String str = readString();</b>
<b class="nc">&nbsp;        byte[] bytes = new byte[str.length() / 2];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; bytes.length; ++i) {</b>
<b class="nc">&nbsp;            char c0 = str.charAt(i * 2);</b>
<b class="nc">&nbsp;            char c1 = str.charAt(i * 2 + 1);</b>
&nbsp;
<b class="nc">&nbsp;            int b0 = c0 - (c0 &lt;= 57 ? 48 : 55);</b>
<b class="nc">&nbsp;            int b1 = c1 - (c1 &lt;= 57 ? 48 : 55);</b>
<b class="nc">&nbsp;            bytes[i] = (byte) ((b0 &lt;&lt; 4) | b1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isReference() {
<b class="nc">&nbsp;        return offset &lt; bytes.length &amp;&amp; bytes[offset] == BC_REFERENCE;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readReference() {
<b class="nc">&nbsp;        if (bytes[offset] != BC_REFERENCE) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        if (isString()) {</b>
<b class="nc">&nbsp;            return readString();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;reference not support input &quot; + error(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    Object readAnyObject() {
<b class="nc">&nbsp;        if (bytes[offset] != BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            return readAny();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Context context = this.context;</b>
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        final long typeHash = readTypeHashCode();</b>
&nbsp;
<b class="nc">&nbsp;        ObjectReader autoTypeObjectReader = null;</b>
<b class="nc">&nbsp;        AutoTypeBeforeHandler autoTypeBeforeHandler = context.autoTypeBeforeHandler;</b>
<b class="nc">&nbsp;        if (autoTypeBeforeHandler != null) {</b>
<b class="nc">&nbsp;            Class&lt;?&gt; objectClass = autoTypeBeforeHandler.apply(typeHash, Object.class, 0L);</b>
<b class="nc">&nbsp;            if (objectClass == null) {</b>
<b class="nc">&nbsp;                objectClass = autoTypeBeforeHandler.apply(getString(), Object.class, 0L);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (objectClass != null) {</b>
<b class="nc">&nbsp;                autoTypeObjectReader = context.getObjectReader(objectClass);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final long features = context.features;</b>
&nbsp;
<b class="nc">&nbsp;        if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;            if ((features &amp; Feature.SupportAutoType.mask) == 0) {</b>
<b class="nc">&nbsp;                if ((features &amp; Feature.ErrorOnNotSupportAutoType.mask) == 0) {</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                autoTypeError();</b>
&nbsp;            }
<b class="nc">&nbsp;            autoTypeObjectReader = context.provider.getObjectReader(typeHash);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (autoTypeObjectReader != null) {</b>
<b class="nc">&nbsp;            Class objectClass = autoTypeObjectReader.getObjectClass();</b>
<b class="nc">&nbsp;            if (objectClass != null) {</b>
<b class="nc">&nbsp;                ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="nc">&nbsp;                if (classLoader != null) {</b>
<b class="nc">&nbsp;                    ClassLoader tcl = Thread.currentThread().getContextClassLoader();</b>
<b class="nc">&nbsp;                    if (classLoader != tcl) {</b>
<b class="nc">&nbsp;                        autoTypeObjectReader = getObjectReaderContext(autoTypeObjectReader, objectClass, tcl);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;            autoTypeObjectReader = context.provider.getObjectReader(getString(), Object.class, features);</b>
<b class="nc">&nbsp;            if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                if ((features &amp; Feature.ErrorOnNotSupportAutoType.mask) == 0) {</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                autoTypeError();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        this.type = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;        return autoTypeObjectReader.readJSONBObject(this, Object.class, null, context.features);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ObjectReader checkAutoType(Class expectClass, long expectClassHash, long features) {
<b class="nc">&nbsp;        ObjectReader autoTypeObjectReader = null;</b>
<b class="nc">&nbsp;        if (bytes[offset] == BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            offset++;</b>
&nbsp;
<b class="nc">&nbsp;            Context context = this.context;</b>
<b class="nc">&nbsp;            final long typeHash = readTypeHashCode();</b>
<b class="nc">&nbsp;            if (expectClassHash == typeHash) {</b>
<b class="nc">&nbsp;                ObjectReader objectReader = context.getObjectReader(expectClass);</b>
<b class="nc">&nbsp;                Class objectClass = objectReader.getObjectClass();</b>
<b class="nc">&nbsp;                if (objectClass != null &amp;&amp; objectClass == expectClass) {</b>
<b class="nc">&nbsp;                    context.provider.registerIfAbsent(typeHash, objectReader);</b>
<b class="nc">&nbsp;                    return objectReader;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            AutoTypeBeforeHandler autoTypeBeforeHandler = context.autoTypeBeforeHandler;</b>
<b class="nc">&nbsp;            if (autoTypeBeforeHandler != null) {</b>
<b class="nc">&nbsp;                ObjectReader objectReader = checkAutoTypeWithHandler(expectClass, features, autoTypeBeforeHandler, typeHash);</b>
<b class="nc">&nbsp;                if (objectReader != null) {</b>
<b class="nc">&nbsp;                    return objectReader;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final long features2 = context.features | features;</b>
<b class="nc">&nbsp;            boolean isSupportAutoType = (features2 &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="nc">&nbsp;            if (!isSupportAutoType) {</b>
<b class="nc">&nbsp;                if ((features2 &amp; Feature.ErrorOnNotSupportAutoType.mask) == 0) {</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                autoTypeError();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            autoTypeObjectReader = context.provider.getObjectReader(typeHash);</b>
&nbsp;
<b class="nc">&nbsp;            if (autoTypeObjectReader != null) {</b>
<b class="nc">&nbsp;                Class objectClass = autoTypeObjectReader.getObjectClass();</b>
<b class="nc">&nbsp;                if (objectClass != null) {</b>
<b class="nc">&nbsp;                    ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="nc">&nbsp;                    if (classLoader != null) {</b>
<b class="nc">&nbsp;                        ClassLoader tcl = Thread.currentThread().getContextClassLoader();</b>
<b class="nc">&nbsp;                        if (classLoader != tcl) {</b>
<b class="nc">&nbsp;                            autoTypeObjectReader = getObjectReaderContext(autoTypeObjectReader, objectClass, tcl);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                autoTypeObjectReader = context.provider.getObjectReader(getString(), expectClass, features2);</b>
<b class="nc">&nbsp;                if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                    if ((features2 &amp; Feature.ErrorOnNotSupportAutoType.mask) == 0) {</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    autoTypeError();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            this.type = bytes[offset];</b>
&nbsp;        }
<b class="nc">&nbsp;        return autoTypeObjectReader;</b>
&nbsp;    }
&nbsp;
&nbsp;    ObjectReader checkAutoTypeWithHandler(
&nbsp;            Class expectClass,
&nbsp;            long features,
&nbsp;            AutoTypeBeforeHandler autoTypeBeforeHandler,
&nbsp;            long typeHash
&nbsp;    ) {
<b class="nc">&nbsp;        Class&lt;?&gt; objectClass = autoTypeBeforeHandler.apply(typeHash, expectClass, features);</b>
<b class="nc">&nbsp;        if (objectClass == null) {</b>
<b class="nc">&nbsp;            objectClass = autoTypeBeforeHandler.apply(getString(), expectClass, features);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (objectClass != null) {</b>
<b class="nc">&nbsp;            ObjectReader objectReader = context.getObjectReader(objectClass);</b>
<b class="nc">&nbsp;            if (objectReader != null) {</b>
<b class="nc">&nbsp;                return objectReader;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    void autoTypeError() {
<b class="nc">&nbsp;        throw new JSONException(&quot;auotype not support : &quot; + getString());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ObjectReader getObjectReaderContext(
&nbsp;            ObjectReader autoTypeObjectReader,
&nbsp;            Class objectClass,
&nbsp;            ClassLoader contextClassLoader
&nbsp;    ) {
<b class="nc">&nbsp;        String typeName = getString();</b>
<b class="nc">&nbsp;        Class contextClass = TypeUtils.getMapping(typeName);</b>
<b class="nc">&nbsp;        if (contextClass == null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (contextClassLoader == null) {</b>
<b class="nc">&nbsp;                    contextClassLoader = JSON.class.getClassLoader();</b>
&nbsp;                }
<b class="nc">&nbsp;                contextClass = contextClassLoader.loadClass(typeName);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (contextClass != null &amp;&amp; !objectClass.equals(contextClass)) {</b>
<b class="nc">&nbsp;            autoTypeObjectReader = getObjectReader(contextClass);</b>
&nbsp;        }
<b class="nc">&nbsp;        return autoTypeObjectReader;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int startArray() {
<b class="nc">&nbsp;        final byte type = this.type = bytes[offset++];</b>
&nbsp;
<b class="nc">&nbsp;        if (type == BC_NULL) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY_FIX_MAX) {</b>
<b class="nc">&nbsp;            ch = (char) -type;</b>
<b class="nc">&nbsp;            return type - BC_ARRAY_FIX_MIN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_BINARY) {</b>
<b class="nc">&nbsp;            return readInt32Value();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type != BC_ARRAY) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;array not support input &quot; + error(type));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readInt32Value();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String error(byte type) {
<b class="nc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;        buf.append(typeName(type));</b>
<b class="nc">&nbsp;        if (isString()) {</b>
<b class="nc">&nbsp;            int mark = offset;</b>
<b class="nc">&nbsp;            offset--;</b>
&nbsp;
<b class="nc">&nbsp;            String str = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                str = readString();</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (str != null) {</b>
<b class="nc">&nbsp;                buf.append(&#39; &#39;);</b>
<b class="nc">&nbsp;                buf.append(str);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            offset = mark;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        buf.append(&quot;, offset &quot;);</b>
<b class="nc">&nbsp;        buf.append(offset);</b>
<b class="nc">&nbsp;        buf.append(&#39;/&#39;);</b>
<b class="nc">&nbsp;        buf.append(bytes.length);</b>
&nbsp;
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void next() {
<b class="nc">&nbsp;        offset++;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readFieldNameHashCode() {
<b class="nc">&nbsp;        strtype = bytes[offset++];</b>
<b class="nc">&nbsp;        boolean typeSymbol = strtype == BC_SYMBOL;</b>
&nbsp;
<b class="nc">&nbsp;        if (typeSymbol) {</b>
<b class="nc">&nbsp;            strtype = bytes[offset];</b>
<b class="nc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
&nbsp;                int symbol;
<b class="nc">&nbsp;                if (strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    symbol = strtype;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    symbol = readInt32Value();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (symbol &lt; 0) {</b>
<b class="nc">&nbsp;                    return symbolTable.getHashCode(-symbol);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (symbol == 0) {</b>
<b class="nc">&nbsp;                    strtype = symbol0StrType;</b>
<b class="nc">&nbsp;                    strlen = symbol0Length;</b>
<b class="nc">&nbsp;                    strBegin = symbol0Begin;</b>
<b class="nc">&nbsp;                    if (symbol0Hash == 0) {</b>
<b class="nc">&nbsp;                        symbol0Hash = getNameHashCode();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return symbol0Hash;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int index = symbol * 2;</b>
<b class="nc">&nbsp;                long strInfo = symbols[index + 1];</b>
<b class="nc">&nbsp;                this.strtype = (byte) strInfo;</b>
<b class="nc">&nbsp;                strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="nc">&nbsp;                strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="nc">&nbsp;                long nameHashCode = symbols[index];</b>
<b class="nc">&nbsp;                if (nameHashCode == 0) {</b>
<b class="nc">&nbsp;                    nameHashCode = getNameHashCode();</b>
<b class="nc">&nbsp;                    symbols[index] = nameHashCode;</b>
&nbsp;                }
<b class="nc">&nbsp;                return nameHashCode;</b>
&nbsp;            }
<b class="nc">&nbsp;            offset++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        strBegin = offset;</b>
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_ASCII || strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw readFieldNameHashCodeEror();</b>
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            long nameValue = 0;</b>
<b class="nc">&nbsp;            if (strlen &lt;= 8 &amp;&amp; offset + strlen &lt;= bytes.length) {</b>
<b class="nc">&nbsp;                switch (strlen) {</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        nameValue = bytes[offset];</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        nameValue = UNSAFE.getShort(bytes, BASE + offset) &amp; 0xFFFFL;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        nameValue = (bytes[offset + 2] &lt;&lt; 16)</b>
<b class="nc">&nbsp;                                + (UNSAFE.getShort(bytes, BASE + offset) &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        nameValue = UNSAFE.getInt(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 4]) &lt;&lt; 32)</b>
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        nameValue = ((long) UNSAFE.getShort(bytes, BASE + offset + 4) &lt;&lt; 32)</b>
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 6]) &lt;&lt; 48)</b>
&nbsp;                                + (((long) bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + (((long) bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        nameValue = UNSAFE.getLong(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (nameValue != 0) {</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                hashCode = nameValue;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset++];</b>
<b class="nc">&nbsp;                    hashCode ^= c;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (typeSymbol) {</b>
&nbsp;            int symbol;
<b class="nc">&nbsp;            if ((type = bytes[offset]) &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                symbol = type;</b>
<b class="nc">&nbsp;                offset++;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                symbol = readInt32Value();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (symbol == 0) {</b>
<b class="nc">&nbsp;                symbol0Begin = strBegin;</b>
<b class="nc">&nbsp;                symbol0Length = strlen;</b>
<b class="nc">&nbsp;                symbol0StrType = strtype;</b>
<b class="nc">&nbsp;                symbol0Hash = hashCode;</b>
<b class="nc">&nbsp;                return hashCode;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
&nbsp;
<b class="nc">&nbsp;            int symbolIndex = symbol &lt;&lt; 1;</b>
<b class="nc">&nbsp;            int minCapacity = symbolIndex + 2;</b>
<b class="nc">&nbsp;            if (symbols == null) {</b>
<b class="nc">&nbsp;                symbols = new long[Math.max(minCapacity, 32)];</b>
<b class="nc">&nbsp;            } else if (symbols.length &lt; minCapacity) {</b>
<b class="nc">&nbsp;                symbols = Arrays.copyOf(symbols, minCapacity + 16);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            symbols[symbolIndex] = hashCode;</b>
<b class="nc">&nbsp;            symbols[symbolIndex + 1] = strInfo;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected JSONException readFieldNameHashCodeEror() {
<b class="nc">&nbsp;        StringBuilder message = new StringBuilder()</b>
<b class="nc">&nbsp;                .append(&quot;fieldName not support input type &quot;)</b>
<b class="nc">&nbsp;                .append(typeName(strtype));</b>
<b class="nc">&nbsp;        if (strtype == BC_REFERENCE) {</b>
<b class="nc">&nbsp;            message.append(&quot; &quot;)</b>
<b class="nc">&nbsp;                    .append(readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        message.append(&quot;, offset &quot;)</b>
<b class="nc">&nbsp;                .append(offset);</b>
<b class="nc">&nbsp;        JSONException error = new JSONException(message.toString());</b>
<b class="nc">&nbsp;        return error;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isInt() {
<b class="nc">&nbsp;        int type = bytes[offset];</b>
<b class="nc">&nbsp;        return (type &gt;= BC_BIGINT_LONG &amp;&amp; type &lt;= BC_INT32)</b>
&nbsp;                || type == BC_TIMESTAMP_SECONDS
&nbsp;                || type == BC_TIMESTAMP_MINUTES
&nbsp;                || type == BC_TIMESTAMP_MILLIS;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isNull() {
<b class="nc">&nbsp;        return bytes[offset] == BC_NULL;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Date readNullOrNewDate() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfNull() {
<b class="nc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void readNull() {
<b class="nc">&nbsp;        type = bytes[offset++];</b>
<b class="nc">&nbsp;        if (type != BC_NULL) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;null not match, &quot; + type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean readIfNull() {
<b class="nc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readTypeHashCode() {
<b class="nc">&nbsp;        strtype = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        boolean typeSymbol = strtype == BC_SYMBOL;</b>
<b class="nc">&nbsp;        if (typeSymbol) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strtype = bytes[offset];</b>
<b class="nc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
&nbsp;                int symbol;
<b class="nc">&nbsp;                if (strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    symbol = strtype;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    symbol = readInt32Value();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (symbol &lt; 0) {</b>
<b class="nc">&nbsp;                    return symbolTable.getHashCode(-symbol);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (symbol == 0) {</b>
<b class="nc">&nbsp;                    strtype = symbol0StrType;</b>
<b class="nc">&nbsp;                    strlen = symbol0Length;</b>
<b class="nc">&nbsp;                    strBegin = symbol0Begin;</b>
<b class="nc">&nbsp;                    if (symbol0Hash == 0) {</b>
<b class="nc">&nbsp;                        symbol0Hash = getNameHashCode();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return symbol0Hash;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int index = symbol * 2;</b>
<b class="nc">&nbsp;                long strInfo = symbols[index + 1];</b>
<b class="nc">&nbsp;                this.strtype = (byte) strInfo;</b>
<b class="nc">&nbsp;                strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="nc">&nbsp;                strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="nc">&nbsp;                long nameHashCode = symbols[index];</b>
<b class="nc">&nbsp;                if (nameHashCode == 0) {</b>
<b class="nc">&nbsp;                    nameHashCode = getNameHashCode();</b>
<b class="nc">&nbsp;                    symbols[index] = nameHashCode;</b>
&nbsp;                }
<b class="nc">&nbsp;                return nameHashCode;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
&nbsp;            int typeIndex;
<b class="nc">&nbsp;            if (strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                typeIndex = strtype;</b>
<b class="nc">&nbsp;            } else if (strtype &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                typeIndex = ((strtype - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
&nbsp;            } else {
<b class="nc">&nbsp;                typeIndex = readInt32Value();</b>
&nbsp;            }
&nbsp;
&nbsp;            long refTypeHash;
<b class="nc">&nbsp;            if (typeIndex == 0) {</b>
<b class="nc">&nbsp;                strtype = symbol0StrType;</b>
<b class="nc">&nbsp;                strlen = symbol0Length;</b>
<b class="nc">&nbsp;                strBegin = symbol0Begin;</b>
<b class="nc">&nbsp;                if (symbol0Hash == 0) {</b>
<b class="nc">&nbsp;                    symbol0Hash = Fnv.hashCode64(getString());</b>
&nbsp;                }
<b class="nc">&nbsp;                refTypeHash = symbol0Hash;</b>
<b class="nc">&nbsp;            } else if (typeIndex &lt; 0) {</b>
<b class="nc">&nbsp;                strlen = strtype;</b>
<b class="nc">&nbsp;                refTypeHash = symbolTable.getHashCode(-typeIndex);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                refTypeHash = symbols[typeIndex * 2];</b>
<b class="nc">&nbsp;                if (refTypeHash == 0) {</b>
<b class="nc">&nbsp;                    long strInfo = symbols[typeIndex * 2 + 1];</b>
<b class="nc">&nbsp;                    strtype = (byte) strInfo;</b>
<b class="nc">&nbsp;                    strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="nc">&nbsp;                    strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="nc">&nbsp;                    refTypeHash = Fnv.hashCode64(getString());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (refTypeHash == -1) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;type ref not found : &quot; + typeIndex);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return refTypeHash;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        strBegin = offset;</b>
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="nc">&nbsp;            byte strType = bytes[offset];</b>
<b class="nc">&nbsp;            if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                strlen = strType;</b>
<b class="nc">&nbsp;            } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
&nbsp;            } else {
<b class="nc">&nbsp;                strlen = readLength();</b>
&nbsp;            }
<b class="nc">&nbsp;            strBegin = offset;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;string value not support input &quot; + typeName(type)</b>
&nbsp;                    + &quot; offset &quot; + offset + &quot;/&quot; + bytes.length);
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            int end = offset + strlen;</b>
<b class="nc">&nbsp;            while (offset &lt; end) {</b>
<b class="nc">&nbsp;                int c = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;                if (c &gt;= 0) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    c &amp;= 0xFF;</b>
<b class="nc">&nbsp;                    switch (c &gt;&gt; 4) {</b>
&nbsp;                        case 12:
&nbsp;                        case 13: {
&nbsp;                            /* 110x xxxx   10xx xxxx*/
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            if ((c2 &amp; 0xC0) != 0x80) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x1F) &lt;&lt; 6)</b>
&nbsp;                                    | (c2 &amp; 0x3F));
<b class="nc">&nbsp;                            offset += 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        case 14: {
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            int c3 = bytes[offset + 2];</b>
<b class="nc">&nbsp;                            if (((c2 &amp; 0xC0) != 0x80) || ((c3 &amp; 0xC0) != 0x80)) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x0F) &lt;&lt; 12) |</b>
&nbsp;                                    ((c2 &amp; 0x3F) &lt;&lt; 6) |
&nbsp;                                    ((c3 &amp; 0x3F)));
<b class="nc">&nbsp;                            offset += 3;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        default:
&nbsp;                            /* 10xx xxxx,  1111 xxxx */
<b class="nc">&nbsp;                            throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                hashCode ^= c;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16 || strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            long nameValue = 0;</b>
<b class="nc">&nbsp;            if (strlen &lt;= 8) {</b>
<b class="nc">&nbsp;                for (int i = 0, start = offset; i &lt; strlen; offset++, i++) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset];</b>
<b class="nc">&nbsp;                    if (c &lt; 0 || (c == 0 &amp;&amp; bytes[start] == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        offset = start;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    switch (i) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (nameValue != 0) {</b>
<b class="nc">&nbsp;                hashCode = nameValue;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset++];</b>
<b class="nc">&nbsp;                    hashCode ^= c;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int symbol;
<b class="nc">&nbsp;        if ((type = bytes[offset]) &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            symbol = type;</b>
<b class="nc">&nbsp;            offset++;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            symbol = readInt32Value();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (symbol == 0) {</b>
<b class="nc">&nbsp;            symbol0Begin = strBegin;</b>
<b class="nc">&nbsp;            symbol0Length = strlen;</b>
<b class="nc">&nbsp;            symbol0StrType = strtype;</b>
<b class="nc">&nbsp;            symbol0Hash = hashCode;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int minCapacity = symbol * 2 + 2;</b>
&nbsp;
<b class="nc">&nbsp;            if (symbols == null) {</b>
<b class="nc">&nbsp;                symbols = new long[Math.max(minCapacity, 32)];</b>
<b class="nc">&nbsp;            } else if (symbols.length &lt; minCapacity) {</b>
<b class="nc">&nbsp;                symbols = Arrays.copyOf(symbols, minCapacity + 16);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
<b class="nc">&nbsp;            symbols[symbol * 2 + 1] = strInfo;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readValueHashCode() {
<b class="nc">&nbsp;        strtype = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;        offset++;</b>
<b class="nc">&nbsp;        strBegin = offset;</b>
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_SYMBOL) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;string value not support input &quot; + typeName(type)</b>
&nbsp;                    + &quot; offset &quot; + offset + &quot;/&quot; + bytes.length);
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            int end = offset + strlen;</b>
<b class="nc">&nbsp;            while (offset &lt; end) {</b>
<b class="nc">&nbsp;                int c = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;                if (c &gt;= 0) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    c &amp;= 0xFF;</b>
<b class="nc">&nbsp;                    switch (c &gt;&gt; 4) {</b>
&nbsp;                        case 12:
&nbsp;                        case 13: {
&nbsp;                            /* 110x xxxx   10xx xxxx*/
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            if ((c2 &amp; 0xC0) != 0x80) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x1F) &lt;&lt; 6)</b>
&nbsp;                                    | (c2 &amp; 0x3F));
<b class="nc">&nbsp;                            offset += 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        case 14: {
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            int c3 = bytes[offset + 2];</b>
<b class="nc">&nbsp;                            if (((c2 &amp; 0xC0) != 0x80) || ((c3 &amp; 0xC0) != 0x80)) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x0F) &lt;&lt; 12) |</b>
&nbsp;                                    ((c2 &amp; 0x3F) &lt;&lt; 6) |
&nbsp;                                    ((c3 &amp; 0x3F)));
<b class="nc">&nbsp;                            offset += 3;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        default:
&nbsp;                            /* 10xx xxxx,  1111 xxxx */
<b class="nc">&nbsp;                            throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                hashCode ^= c;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            if (bytes[offset] == (byte) 0xFE</b>
&nbsp;                    &amp;&amp; bytes[offset + 1] == (byte) 0xFF
&nbsp;            ) {
<b class="nc">&nbsp;                if (strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                    long nameValue = 0;</b>
<b class="nc">&nbsp;                    for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                        byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                        byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                        char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                        if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                            nameValue = 0;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        byte c = (byte) ch;</b>
<b class="nc">&nbsp;                        switch ((i - 2) &gt;&gt; 1) {</b>
&nbsp;                            case 0:
<b class="nc">&nbsp;                                nameValue = c;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 1:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 2:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 3:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 4:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 5:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 6:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 7:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            default:
&nbsp;                                break;
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (nameValue != 0) {</b>
<b class="nc">&nbsp;                        return nameValue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                    hashCode ^= ch;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (bytes[offset] == (byte) 0xFF</b>
&nbsp;                    &amp;&amp; bytes[offset + 1] == (byte) 0xFE
&nbsp;            ) {
<b class="nc">&nbsp;                for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                    hashCode ^= ch;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                    hashCode ^= ch;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            if (strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                    if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    byte c = (byte) ch;</b>
<b class="nc">&nbsp;                    switch (i &gt;&gt; 1) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            if (strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                    if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    byte c = (byte) ch;</b>
<b class="nc">&nbsp;                    switch (i &gt;&gt; 1) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if (strlen &lt;= 8) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0, start = offset; i &lt; strlen; offset++, i++) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset];</b>
<b class="nc">&nbsp;                    if (c &lt; 0 || (c == 0 &amp;&amp; bytes[start] == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        offset = start;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    switch (i) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                byte c = bytes[offset++];</b>
<b class="nc">&nbsp;                hashCode ^= c;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected long getNameHashCode() {
<b class="nc">&nbsp;        int offset = strBegin;</b>
<b class="nc">&nbsp;        long nameValue = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strlen; offset++) {</b>
<b class="nc">&nbsp;            byte c = bytes[offset];</b>
<b class="nc">&nbsp;            if (c &lt; 0 || i &gt;= 8 || (i == 0 &amp;&amp; bytes[strBegin] == 0)) {</b>
<b class="nc">&nbsp;                offset = strBegin;</b>
<b class="nc">&nbsp;                nameValue = 0;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            switch (i) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    nameValue = c;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 7:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (nameValue != 0) {</b>
<b class="nc">&nbsp;            return nameValue;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;            byte c = bytes[offset++];</b>
<b class="nc">&nbsp;            hashCode ^= c;</b>
<b class="nc">&nbsp;            hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;        }
<b class="nc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getNameHashCodeLCase() {
<b class="nc">&nbsp;        int offset = strBegin;</b>
<b class="nc">&nbsp;        long nameValue = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strlen; offset++) {</b>
<b class="nc">&nbsp;            byte c = bytes[offset];</b>
<b class="nc">&nbsp;            if (c &lt; 0 || i &gt;= 8 || (i == 0 &amp;&amp; bytes[strBegin] == 0)) {</b>
<b class="nc">&nbsp;                offset = strBegin;</b>
<b class="nc">&nbsp;                nameValue = 0;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (c == &#39;_&#39; || c == &#39;-&#39; || c == &#39; &#39;) {</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                if (c1 != c) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {</b>
<b class="nc">&nbsp;                c += 32;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            switch (i) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    nameValue = c;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 7:
<b class="nc">&nbsp;                    nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (nameValue != 0) {</b>
<b class="nc">&nbsp;            return nameValue;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;            byte c = bytes[offset++];</b>
<b class="nc">&nbsp;            if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {</b>
<b class="nc">&nbsp;                c = (byte) (c + 32);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (c == &#39;_&#39; || c == &#39;-&#39; || c == &#39; &#39;) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            hashCode ^= c;</b>
<b class="nc">&nbsp;            hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;        }
<b class="nc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void skipValue() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
&nbsp;            case BC_ARRAY_FIX_0:
&nbsp;            case BC_STR_ASCII_FIX_0:
&nbsp;            case BC_FALSE:
&nbsp;            case BC_TRUE:
&nbsp;                return;
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                offset++;</b>
&nbsp;                return;
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                offset += 2;</b>
&nbsp;                return;
&nbsp;            case BC_INT32:
&nbsp;            case BC_TIMESTAMP_SECONDS:
&nbsp;            case BC_TIMESTAMP_MINUTES:
&nbsp;            case BC_FLOAT:
<b class="nc">&nbsp;                offset += 4;</b>
&nbsp;                return;
&nbsp;            case BC_FLOAT_INT:
<b class="nc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS:
&nbsp;            case BC_DOUBLE:
<b class="nc">&nbsp;                offset += 8;</b>
&nbsp;                return;
&nbsp;            case BC_DOUBLE_LONG:
&nbsp;            case BC_DECIMAL_LONG:
<b class="nc">&nbsp;                readInt64Value();</b>
&nbsp;                return;
&nbsp;            case BC_DECIMAL:
&nbsp;                // TODO skip big decimal
<b class="nc">&nbsp;                readInt32Value();</b>
<b class="nc">&nbsp;                readBigInteger();</b>
&nbsp;                return;
&nbsp;            case BC_LOCAL_TIME:
<b class="nc">&nbsp;                offset += 3;</b>
<b class="nc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_LOCAL_DATETIME:
<b class="nc">&nbsp;                offset += 7;</b>
<b class="nc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_TIMESTAMP_WITH_TIMEZONE:
<b class="nc">&nbsp;                offset += 7;</b>
<b class="nc">&nbsp;                readInt32Value(); // nano</b>
<b class="nc">&nbsp;                readString(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_BINARY:
<b class="nc">&nbsp;                int byteslen = readInt32Value();</b>
<b class="nc">&nbsp;                offset += byteslen;</b>
&nbsp;                return;
&nbsp;            case BC_STR_ASCII:
&nbsp;            case BC_STR_UTF8:
&nbsp;            case BC_STR_UTF16:
&nbsp;            case BC_STR_UTF16LE:
&nbsp;            case BC_STR_UTF16BE:
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;                return;
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                readTypeHashCode();</b>
<b class="nc">&nbsp;                skipValue();</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            case BC_OBJECT: {
<b class="nc">&nbsp;                for (int i = 0; ; ++i) {</b>
<b class="nc">&nbsp;                    if (bytes[offset] == BC_OBJECT_END) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    skipName();</b>
<b class="nc">&nbsp;                    skipValue();</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
&nbsp;            case BC_REFERENCE: {
<b class="nc">&nbsp;                if (isString()) {</b>
<b class="nc">&nbsp;                    skipName();</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                throw new JSONException(&quot;skip not support type &quot; + typeName(type));</b>
&nbsp;            }
&nbsp;            default:
&nbsp;                // [-16, 47]
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
&nbsp;                // [-40, -17]
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    offset += (type - BC_STR_ASCII_FIX_MIN);</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY) {</b>
&nbsp;                    int itemCnt;
<b class="nc">&nbsp;                    if (type == BC_ARRAY) {</b>
<b class="nc">&nbsp;                        itemCnt = readInt32Value();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        itemCnt = type - BC_ARRAY_FIX_MIN;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int i = 0; i &lt; itemCnt; ++i) {</b>
<b class="nc">&nbsp;                        skipValue();</b>
&nbsp;                    }
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                throw new JSONException(&quot;skip not support type &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean skipName() {
<b class="nc">&nbsp;        strtype = bytes[offset++];</b>
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            offset += (strtype - BC_STR_ASCII_FIX_MIN);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            offset += strlen;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype == BC_SYMBOL) {</b>
<b class="nc">&nbsp;            int type = bytes[offset];</b>
<b class="nc">&nbsp;            if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32) {</b>
<b class="nc">&nbsp;                readInt32Value();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String str = readString();</b>
<b class="nc">&nbsp;            readInt32Value();</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;name not support input : &quot; + typeName(strtype));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readFieldName() {
<b class="nc">&nbsp;        strtype = bytes[offset];</b>
<b class="nc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        offset++;</b>
&nbsp;
<b class="nc">&nbsp;        boolean typeSymbol = strtype == BC_SYMBOL;</b>
<b class="nc">&nbsp;        if (typeSymbol) {</b>
<b class="nc">&nbsp;            strtype = bytes[offset];</b>
<b class="nc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
<b class="nc">&nbsp;                int symbol = readInt32Value();</b>
<b class="nc">&nbsp;                if (symbol &lt; 0) {</b>
<b class="nc">&nbsp;                    return symbolTable.getName(-symbol);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (symbol == 0) {</b>
<b class="nc">&nbsp;                    strtype = symbol0StrType;</b>
<b class="nc">&nbsp;                    strlen = symbol0Length;</b>
<b class="nc">&nbsp;                    strBegin = symbol0Begin;</b>
<b class="nc">&nbsp;                    return getFieldName();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int index = symbol * 2 + 1;</b>
<b class="nc">&nbsp;                long strInfo = symbols[index];</b>
<b class="nc">&nbsp;                strtype = (byte) strInfo;</b>
<b class="nc">&nbsp;                strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="nc">&nbsp;                strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="nc">&nbsp;                return getString();</b>
&nbsp;            }
<b class="nc">&nbsp;            offset++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        strBegin = offset;</b>
<b class="nc">&nbsp;        Charset charset = null;</b>
<b class="nc">&nbsp;        String str = null;</b>
<b class="nc">&nbsp;        if (strtype == BC_STR_ASCII_FIX_MIN + 1) {</b>
<b class="nc">&nbsp;            str = TypeUtils.toString((char) (bytes[offset] &amp; 0xff));</b>
<b class="nc">&nbsp;            strlen = 1;</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_ASCII_FIX_MIN + 2) {</b>
<b class="nc">&nbsp;            str = TypeUtils.toString(</b>
&nbsp;                    (char) (bytes[offset] &amp; 0xff),
&nbsp;                    (char) (bytes[offset + 1] &amp; 0xff)
&nbsp;            );
<b class="nc">&nbsp;            strlen = 2;</b>
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII) {</b>
<b class="nc">&nbsp;            long nameValue0 = -1, nameValue1 = -1;</b>
&nbsp;
<b class="nc">&nbsp;            if (strtype == BC_STR_ASCII) {</b>
<b class="nc">&nbsp;                strlen = readLength();</b>
<b class="nc">&nbsp;                strBegin = offset;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;
<b class="nc">&nbsp;                if (offset + strlen &gt; bytes.length) {</b>
<b class="nc">&nbsp;                    throw new JSONException(&quot;illegal jsonb data&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                switch (strlen) {</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 2] &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        nameValue0 = UNSAFE.getInt(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 4]) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 5]) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 6]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        nameValue0 = UNSAFE.getLong(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 9:
<b class="nc">&nbsp;                        nameValue0 = bytes[offset];</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 1);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 10:
<b class="nc">&nbsp;                        nameValue0 = UNSAFE.getShort(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 2);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset] &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 2] &amp; 0xFFL);
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 3);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        nameValue0 = UNSAFE.getInt(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 4);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 13:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 4]) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 5);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 14:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 5]) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 6);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 15:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 6]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
<b class="nc">&nbsp;                                + (UNSAFE.getInt(bytes, BASE + offset) &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 7);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 16:
<b class="nc">&nbsp;                        nameValue0 = UNSAFE.getLong(bytes, BASE + offset);</b>
<b class="nc">&nbsp;                        nameValue1 = UNSAFE.getLong(bytes, BASE + offset + 8);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (bytes[offset + strlen - 1] &gt; 0 &amp;&amp; nameValue0 != -1) {</b>
<b class="nc">&nbsp;                if (nameValue1 != -1) {</b>
<b class="nc">&nbsp;                    int indexMask = ((int) nameValue1) &amp; (NAME_CACHE2.length - 1);</b>
<b class="nc">&nbsp;                    JSONFactory.NameCacheEntry2 entry = NAME_CACHE2[indexMask];</b>
<b class="nc">&nbsp;                    if (entry == null) {</b>
&nbsp;                        String name;
<b class="nc">&nbsp;                        if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;                            char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                                chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            name = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            name = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        NAME_CACHE2[indexMask] = new JSONFactory.NameCacheEntry2(name, nameValue0, nameValue1);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        str = name;</b>
<b class="nc">&nbsp;                    } else if (entry.value0 == nameValue0 &amp;&amp; entry.value1 == nameValue1) {</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        str = entry.name;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    int indexMask = ((int) nameValue0) &amp; (NAME_CACHE.length - 1);</b>
<b class="nc">&nbsp;                    JSONFactory.NameCacheEntry entry = NAME_CACHE[indexMask];</b>
<b class="nc">&nbsp;                    if (entry == null) {</b>
&nbsp;                        String name;
<b class="nc">&nbsp;                        if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;                            char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                                chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            name = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            name = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        NAME_CACHE[indexMask] = new JSONFactory.NameCacheEntry(name, nameValue0);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        str = name;</b>
<b class="nc">&nbsp;                    } else if (entry.value == nameValue0) {</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        str = entry.name;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (str == null) {</b>
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK8 != null &amp;&amp; strlen &gt;= 0) {</b>
<b class="nc">&nbsp;                    char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                        chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;                } else if (STRING_CREATOR_JDK11 != null &amp;&amp; strlen &gt;= 0) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;                }
<b class="nc">&nbsp;                charset = StandardCharsets.ISO_8859_1;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = BYTES_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;                    if (valueBytes == null) {</b>
<b class="nc">&nbsp;                        valueBytes = new byte[8192];</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;                if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                    valueBytes = new byte[minCapacity];</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;                if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                    byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                    System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_GB18030) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
&nbsp;
<b class="nc">&nbsp;            if (GB18030 == null) {</b>
<b class="nc">&nbsp;                GB18030 = Charset.forName(&quot;GB18030&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            charset = GB18030;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            str = symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            str = new String(bytes, offset, strlen, charset);</b>
<b class="nc">&nbsp;            offset += strlen;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (typeSymbol) {</b>
<b class="nc">&nbsp;            int symbol = readInt32Value();</b>
&nbsp;
<b class="nc">&nbsp;            if (symbol == 0) {</b>
<b class="nc">&nbsp;                symbol0Begin = strBegin;</b>
<b class="nc">&nbsp;                symbol0Length = strlen;</b>
<b class="nc">&nbsp;                symbol0StrType = strtype;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                int minCapacity = symbol * 2 + 2;</b>
<b class="nc">&nbsp;                if (symbols == null) {</b>
<b class="nc">&nbsp;                    symbols = new long[Math.max(minCapacity, 32)];</b>
<b class="nc">&nbsp;                } else if (symbols.length &lt; minCapacity) {</b>
<b class="nc">&nbsp;                    symbols = Arrays.copyOf(symbols, symbols.length + 16);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
<b class="nc">&nbsp;                symbols[symbol * 2 + 1] = strInfo;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getFieldName() {
<b class="nc">&nbsp;        return getString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readString() {
<b class="nc">&nbsp;        final byte strtype = bytes[offset++];</b>
<b class="nc">&nbsp;        this.strtype = strtype;</b>
<b class="nc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        strBegin = offset;</b>
<b class="nc">&nbsp;        String str = null;</b>
<b class="nc">&nbsp;        boolean ascii = false;</b>
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII) {</b>
<b class="nc">&nbsp;            ascii = true;</b>
&nbsp;            final int strlen;
<b class="nc">&nbsp;            if (strtype == BC_STR_ASCII) {</b>
<b class="nc">&nbsp;                byte strType = bytes[offset];</b>
<b class="nc">&nbsp;                if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    strlen = strType;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    strlen = readLength();</b>
&nbsp;                }
<b class="nc">&nbsp;                strBegin = offset;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;            }
<b class="nc">&nbsp;            this.strlen = strlen;</b>
&nbsp;
<b class="nc">&nbsp;            if (strlen &gt;= 0) {</b>
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;                    char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                        chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;                } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (str != null) {</b>
<b class="nc">&nbsp;                if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                    str = str.trim();</b>
&nbsp;                }
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readStringNonAscii(null, ascii);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String readStringNonAscii(String str, boolean ascii) {
&nbsp;        Charset charset;
<b class="nc">&nbsp;        if (ascii) {</b>
<b class="nc">&nbsp;            charset = StandardCharsets.ISO_8859_1;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            str = readStringUTF8();</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            strBegin = offset;</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            str = readUTF16LE();</b>
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            str = readUTF16BE();</b>
<b class="nc">&nbsp;            if (str != null) {</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
<b class="nc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_GB18030) {</b>
<b class="nc">&nbsp;            readGB18030();</b>
<b class="nc">&nbsp;            charset = GB18030;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return readStringTypeNotMatch();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (str != null) {</b>
<b class="nc">&nbsp;            if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                str = str.trim();</b>
&nbsp;            }
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readString(charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String readString(Charset charset) {
&nbsp;        String str;
<b class="nc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            return symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        char[] chars = null;</b>
<b class="nc">&nbsp;        if (JVM_VERSION == 8 &amp;&amp; strtype == BC_STR_UTF8 &amp;&amp; strlen &lt; 8192) {</b>
<b class="nc">&nbsp;            final int cacheIndex = System.identityHashCode(Thread.currentThread()) &amp; (CACHE_ITEMS.length - 1);</b>
<b class="nc">&nbsp;            final CacheItem cacheItem = CACHE_ITEMS[cacheIndex];</b>
<b class="nc">&nbsp;            chars = CHARS_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;            if (chars == null) {</b>
<b class="nc">&nbsp;                chars = new char[8192];</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (chars != null) {</b>
<b class="nc">&nbsp;            int len = IOUtils.decodeUTF8(bytes, offset, strlen, chars);</b>
<b class="nc">&nbsp;            str = new String(chars, 0, len);</b>
<b class="nc">&nbsp;            if (chars.length &lt; CACHE_THRESHOLD) {</b>
<b class="nc">&nbsp;                CHARS_UPDATER.lazySet(cacheItem, chars);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            str = new String(bytes, offset, strlen, charset);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;            str = str.trim();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void readGB18030() {
<b class="nc">&nbsp;        strlen = readLength();</b>
<b class="nc">&nbsp;        strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;        if (GB18030 == null) {</b>
<b class="nc">&nbsp;            GB18030 = Charset.forName(&quot;GB18030&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String readUTF16BE() {
<b class="nc">&nbsp;        strlen = readLength();</b>
<b class="nc">&nbsp;        strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;        if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;            byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;            System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;            String str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;            offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;            if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                str = str.trim();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String readUTF16LE() {
<b class="nc">&nbsp;        byte strType = bytes[offset];</b>
<b class="nc">&nbsp;        if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = strType;</b>
<b class="nc">&nbsp;        } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        } else {
<b class="nc">&nbsp;            strlen = readLength();</b>
&nbsp;        }
<b class="nc">&nbsp;        strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;        if (strlen == 0) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;            byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;            System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;            String str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;            offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;            if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                str = str.trim();</b>
&nbsp;            }
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String readStringUTF8() {
<b class="nc">&nbsp;        byte strType = bytes[offset];</b>
<b class="nc">&nbsp;        if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = strType;</b>
<b class="nc">&nbsp;        } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        } else {
<b class="nc">&nbsp;            strlen = readLength();</b>
&nbsp;        }
<b class="nc">&nbsp;        strBegin = offset;</b>
&nbsp;
<b class="nc">&nbsp;        if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;            if (valueBytes == null) {</b>
<b class="nc">&nbsp;                valueBytes = BYTES_UPDATER.getAndSet(cacheItem, null);</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = new byte[8192];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;            if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                valueBytes = new byte[minCapacity];</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;            if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                String str = STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                    str = str.trim();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String readStringTypeNotMatch() {
<b class="nc">&nbsp;        if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            return Byte.toString(strtype);</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_INT32_BYTE_MIN &amp;&amp; strtype &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            int intValue = ((strtype - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;            return Integer.toString(intValue);</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_INT32_SHORT_MIN &amp;&amp; strtype &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int int3 = getInt3(bytes, offset, strtype);</b>
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;            return Integer.toString(int3);</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_INT64_NUM_MIN &amp;&amp; strtype &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;            int intValue = INT64_NUM_LOW_VALUE + (strtype - BC_INT64_NUM_MIN);</b>
<b class="nc">&nbsp;            return Integer.toString(intValue);</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_INT64_BYTE_MIN &amp;&amp; strtype &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            int intValue = ((strtype - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;            return Integer.toString(intValue);</b>
<b class="nc">&nbsp;        } else if (strtype &gt;= BC_INT64_SHORT_MIN &amp;&amp; strtype &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int intValue = ((strtype - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;            return Integer.toString(intValue);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (strtype) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return &quot;0.0&quot;;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return &quot;1.0&quot;;</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Long.toString(BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value));</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT:
<b class="nc">&nbsp;                return Float.toString(</b>
<b class="nc">&nbsp;                        readInt32Value());</b>
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                float floatValue = Float.intBitsToFloat(BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value));</b>
<b class="nc">&nbsp;                return Float.toString(floatValue);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                double doubleValue = Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
<b class="nc">&nbsp;                return Double.toString(doubleValue);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                int seconds = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                long millis = (BIG_ENDIAN ? seconds : Integer.reverseBytes(seconds)) * 1000L;</b>
<b class="nc">&nbsp;                Date date = new Date(millis);</b>
<b class="nc">&nbsp;                return DateUtils.toString(date);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                int minutes = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                long millis = (BIG_ENDIAN ? minutes : Integer.reverseBytes(minutes)) * 60000L;</b>
<b class="nc">&nbsp;                Date date = new Date(millis);</b>
<b class="nc">&nbsp;                return DateUtils.toString(date);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                Date date = new Date(BIG_ENDIAN ? millis : Long.reverseBytes(millis));</b>
<b class="nc">&nbsp;                return DateUtils.toString(date);</b>
&nbsp;            }
&nbsp;            case BC_INT64:
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return Long.toString(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                int len = readInt32Value();</b>
<b class="nc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return new BigInteger(bytes).toString();</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.toString();</b>
&nbsp;            }
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                offset--;</b>
<b class="nc">&nbsp;                Object typedAny = readAny();</b>
<b class="nc">&nbsp;                return typedAny == null ? null : JSON.toJSONString(typedAny, JSONWriter.Feature.WriteThrowableClassName);</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG:
&nbsp;            case BC_BIGINT_LONG: {
<b class="nc">&nbsp;                return Long.toString(</b>
<b class="nc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                double doubleValue = readInt64Value();</b>
<b class="nc">&nbsp;                return Double.toString(doubleValue);</b>
&nbsp;            }
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;readString not support type &quot; + typeName(strtype) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String[] readStringArray() {
<b class="nc">&nbsp;        if (nextIfMatch(BC_TYPED_ANY)) {</b>
<b class="nc">&nbsp;            long typeHash = readTypeHashCode();</b>
<b class="nc">&nbsp;            if (typeHash != ObjectReaderImplStringArray.HASH_TYPE) {</b>
<b class="nc">&nbsp;                throw new JSONException(info(&quot;not support type &quot; + getString()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        if (entryCnt == -1) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        String[] array = new String[entryCnt];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            array[i] = readString();</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public char readCharValue() {
<b class="nc">&nbsp;        byte type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type == BC_CHAR) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return (char) readInt32Value();</b>
<b class="nc">&nbsp;        } else if (type == BC_STR_ASCII_FIX_0) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return &#39;\0&#39;;</b>
<b class="nc">&nbsp;        } else if (type &gt; BC_STR_ASCII_FIX_0 &amp;&amp; type &lt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return (char) (bytes[offset++] &amp; 0xff);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String str = readString();</b>
<b class="nc">&nbsp;        if (str == null || str.isEmpty()) {</b>
<b class="nc">&nbsp;            return &#39;\0&#39;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.charAt(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int[] readInt32ValueArray() {
<b class="nc">&nbsp;        if (nextIfMatch(JSONB.Constants.BC_TYPED_ANY)) {</b>
<b class="nc">&nbsp;            long typeHash = readTypeHashCode();</b>
<b class="nc">&nbsp;            if (typeHash != ObjectReaderImplInt64ValueArray.HASH_TYPE</b>
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt64Array.HASH_TYPE
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt32Array.HASH_TYPE
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt32ValueArray.HASH_TYPE
&nbsp;            ) {
<b class="nc">&nbsp;                throw new JSONException(info(&quot;not support &quot; + getString()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        if (entryCnt == -1) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int[] array = new int[entryCnt];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            array[i] = readInt32Value();</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long[] readInt64ValueArray() {
<b class="nc">&nbsp;        if (nextIfMatch(JSONB.Constants.BC_TYPED_ANY)) {</b>
<b class="nc">&nbsp;            long typeHash = readTypeHashCode();</b>
<b class="nc">&nbsp;            if (typeHash != ObjectReaderImplInt64ValueArray.HASH_TYPE</b>
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt64Array.HASH_TYPE
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt32Array.HASH_TYPE
&nbsp;                    &amp;&amp; typeHash != ObjectReaderImplInt32ValueArray.HASH_TYPE
&nbsp;            ) {
<b class="nc">&nbsp;                throw new JSONException(info(&quot;not support &quot; + getString()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int entryCnt = startArray();</b>
<b class="nc">&nbsp;        if (entryCnt == -1) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long[] array = new long[entryCnt];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="nc">&nbsp;            array[i] = readInt64Value();</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readInt64Value() {
<b class="nc">&nbsp;        wasNull = false;</b>
&nbsp;
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
&nbsp;
&nbsp;        long int64Value;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;            int64Value = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            int64Value = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 1;</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int64Value = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset + 1] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;        } else if (type == BC_INT64_INT) {</b>
<b class="nc">&nbsp;            int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;            int64Value = BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value);</b>
<b class="nc">&nbsp;            offset += 4;</b>
<b class="nc">&nbsp;        } else if (type == BC_INT64) {</b>
<b class="nc">&nbsp;            int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;            if (!BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                int64Value = Long.reverseBytes(int64Value);</b>
&nbsp;            }
<b class="nc">&nbsp;            offset += 8;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.offset = offset;</b>
<b class="nc">&nbsp;            return readInt64Value0(bytes, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.offset = offset;</b>
<b class="nc">&nbsp;        return int64Value;</b>
&nbsp;    }
&nbsp;
&nbsp;    private long readInt64Value0(byte[] bytes, byte type) {
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;            return int3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                if ((context.features &amp; Feature.ErrorOnNullForPrimitives.mask) != 0) {</b>
<b class="nc">&nbsp;                    throw new JSONException(info(&quot;long value not support input null&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                wasNull = true;</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                float floatValue = Float.intBitsToFloat(BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value));</b>
<b class="nc">&nbsp;                return (long) floatValue;</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                offset--;</b>
<b class="nc">&nbsp;                return (long) readDoubleValue();</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT:
<b class="nc">&nbsp;                return (long) ((float) readInt32Value());</b>
&nbsp;            case BC_DOUBLE_LONG:
<b class="nc">&nbsp;                return (long) ((double) readInt64Value());</b>
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return minutes * 60 * 1000;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long seconds = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return seconds * 1000;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MILLIS:
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value);</b>
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.longValue();</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                        return new BigInteger(str).longValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return toBigDecimal(str).longValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;readInt64Value not support &quot; + typeName(type) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int readInt32Value() {
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        final byte type = bytes[offset++];</b>
&nbsp;
&nbsp;        int int32Value;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            int32Value = type;</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            int32Value = ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 1;</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int32Value = ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset + 1] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;        } else if (type == BC_INT32) {</b>
<b class="nc">&nbsp;            int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;            if (!BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                int32Value = Integer.reverseBytes(int32Value);</b>
&nbsp;            }
<b class="nc">&nbsp;            offset += 4;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.offset = offset;</b>
<b class="nc">&nbsp;            return readInt32Value0(bytes, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.offset = offset;</b>
<b class="nc">&nbsp;        return int32Value;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int readInt32Value0(byte[] bytes, byte type) {
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;            return INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                if ((context.features &amp; Feature.ErrorOnNullForPrimitives.mask) != 0) {</b>
<b class="nc">&nbsp;                    throw new JSONException(info(&quot;int value not support input null&quot;));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                wasNull = true;</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                return (int) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return (int) (BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT:
<b class="nc">&nbsp;                return (int) (float) readInt32Value();</b>
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="nc">&nbsp;                return (int) floatValue;</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                offset--;</b>
<b class="nc">&nbsp;                return (int) readDoubleValue();</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES:
&nbsp;            case BC_TIMESTAMP_SECONDS:
&nbsp;            case BC_INT64_INT:
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return int32Value;</b>
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return toBigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;readInt32Value not support &quot; + typeName(type) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isBinary() {
<b class="nc">&nbsp;        return bytes[offset] == BC_BINARY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte[] readBinary() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        if (type != BC_BINARY) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;not support input : &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int len = readLength();</b>
<b class="nc">&nbsp;        byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;        System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;        offset += len;</b>
<b class="nc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Integer readInt32() {
<b class="nc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        wasNull = false;</b>
<b class="nc">&nbsp;        int value = readInt32Value();</b>
<b class="nc">&nbsp;        if (wasNull) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Long readInt64() {
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
&nbsp;
<b class="nc">&nbsp;        if (type == BC_NULL) {</b>
<b class="nc">&nbsp;            this.offset = offset;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        long int64Value;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;            int64Value = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            int64Value = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 1;</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int64Value = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset + 1] &amp; 0xFF);
<b class="nc">&nbsp;            offset += 2;</b>
<b class="nc">&nbsp;        } else if (type == BC_INT64_INT) {</b>
<b class="nc">&nbsp;            int int32Val = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;            int64Value = BIG_ENDIAN ? int32Val : Integer.reverseBytes(int32Val);</b>
<b class="nc">&nbsp;            offset += 4;</b>
<b class="nc">&nbsp;        } else if (type == BC_INT64) {</b>
<b class="nc">&nbsp;            int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;            if (!BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                int64Value = Long.reverseBytes(int64Value);</b>
&nbsp;            }
<b class="nc">&nbsp;            offset += 8;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.offset = offset;</b>
<b class="nc">&nbsp;            return readInt64Value0(bytes, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.offset = offset;</b>
<b class="nc">&nbsp;        return int64Value;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String readFixedAsciiString(int strlen) {
&nbsp;        String str;
<b class="nc">&nbsp;        if (strlen == 1) {</b>
<b class="nc">&nbsp;            str = TypeUtils.toString((char) (bytes[offset] &amp; 0xff));</b>
<b class="nc">&nbsp;        } else if (strlen == 2) {</b>
<b class="nc">&nbsp;            str = TypeUtils.toString(</b>
&nbsp;                    (char) (bytes[offset] &amp; 0xff),
&nbsp;                    (char) (bytes[offset + 1] &amp; 0xff)
&nbsp;            );
<b class="nc">&nbsp;        } else if (STRING_CREATOR_JDK8 != null) {</b>
<b class="nc">&nbsp;            char[] chars = new char[strlen];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="nc">&nbsp;                chars[i] = (char) (bytes[offset + i] &amp; 0xff);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Float readFloat() {
<b class="nc">&nbsp;        byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        byte type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type == BC_FLOAT) {</b>
<b class="nc">&nbsp;            int int32Value = ((bytes[offset + 4] &amp; 0xFF)) +</b>
&nbsp;                    ((bytes[offset + 3] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                    ((bytes[offset + 1]) &lt;&lt; 24);
<b class="nc">&nbsp;            this.offset = offset + 5;</b>
<b class="nc">&nbsp;            return Float.intBitsToFloat(int32Value);</b>
<b class="nc">&nbsp;        } else if (type == BC_NULL) {</b>
<b class="nc">&nbsp;            this.offset = offset + 1;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readFloat0();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public float readFloatValue() {
<b class="nc">&nbsp;        byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        if (bytes[offset] == BC_FLOAT) {</b>
<b class="nc">&nbsp;            int int32Val = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset + 1);</b>
<b class="nc">&nbsp;            this.offset = offset + 5;</b>
<b class="nc">&nbsp;            return Float.intBitsToFloat(BIG_ENDIAN ? int32Val : Integer.reverseBytes(int32Val));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readFloat0();</b>
&nbsp;    }
&nbsp;
&nbsp;    private float readFloat0() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                if ((context.features &amp; Feature.ErrorOnNullForPrimitives.mask) != 0) {</b>
<b class="nc">&nbsp;                    throw new JSONException(info(&quot;long value not support input null&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                wasNull = true;</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return (float) (BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return (float) Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                return (float) (double) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            case BC_FALSE:
&nbsp;//            case FLOAT_NUM_0:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;//            case FLOAT_NUM_1:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;                    this.offset = offset + 2;</b>
<b class="nc">&nbsp;                    return int3;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return (float) (INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return toBigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;TODO : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double readDoubleValue() {
<b class="nc">&nbsp;        byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        int offset = this.offset;</b>
<b class="nc">&nbsp;        if (bytes[offset] == BC_DOUBLE) {</b>
<b class="nc">&nbsp;            long int64Value = ((bytes[offset + 8] &amp; 0xFFL)) +</b>
&nbsp;                    ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                    ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                    ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                    ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                    ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                    ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                    ((long) (bytes[offset + 1]) &lt;&lt; 56);
<b class="nc">&nbsp;            this.offset = offset + 9;</b>
<b class="nc">&nbsp;            return Double.longBitsToDouble(int64Value);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readDoubleValue0();</b>
&nbsp;    }
&nbsp;
&nbsp;    private double readDoubleValue0() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                if ((context.features &amp; Feature.ErrorOnNullForPrimitives.mask) != 0) {</b>
<b class="nc">&nbsp;                    throw new JSONException(info(&quot;long value not support input null&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                wasNull = true;</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return (double) (BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT:
<b class="nc">&nbsp;                int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Float.intBitsToFloat(BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value));</b>
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG:
<b class="nc">&nbsp;                return readInt64Value();</b>
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            case BC_FALSE:
&nbsp;//            case FLOAT_NUM_0:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;//            case FLOAT_NUM_1:
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;                    this.offset = offset + 2;</b>
<b class="nc">&nbsp;                    return int3;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return toBigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;TODO : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void readNumber0() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Number readNumber() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;            return (int) type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;            int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;            this.offset = offset + 2;</b>
<b class="nc">&nbsp;            return int3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;            return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;            return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="nc">&nbsp;                return 0D;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="nc">&nbsp;                return 1D;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16: {
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return (short) int16Value;</b>
&nbsp;            }
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return (long) int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                int len = readInt32Value();</b>
<b class="nc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT_LONG: {
<b class="nc">&nbsp;                return BigInteger.valueOf(</b>
<b class="nc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE:
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            case BC_DOUBLE_LONG:
<b class="nc">&nbsp;                return (double) readInt64Value();</b>
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    return new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG: {
<b class="nc">&nbsp;                return BigDecimal.valueOf(</b>
<b class="nc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return toBigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return toBigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                String typeName = readString();</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;not support input type : &quot; + typeName);</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    return toBigDecimal(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BigDecimal readBigDecimal() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
&nbsp;        BigDecimal decimal;
<b class="nc">&nbsp;        if (type == BC_DECIMAL) {</b>
<b class="nc">&nbsp;            int scale = readInt32Value();</b>
<b class="nc">&nbsp;            if (bytes[offset] == BC_BIGINT_LONG) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                long unscaledLongValue = readInt64Value();</b>
<b class="nc">&nbsp;                decimal = BigDecimal.valueOf(unscaledLongValue, scale);</b>
<b class="nc">&nbsp;            } else if (bytes[offset] == BC_INT32) {</b>
<b class="nc">&nbsp;                decimal = BigDecimal.valueOf(getInt(bytes, offset + 1), scale);</b>
<b class="nc">&nbsp;                offset += 5;</b>
<b class="nc">&nbsp;            } else if (bytes[offset] == BC_INT64) {</b>
<b class="nc">&nbsp;                long unscaledValue = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset + 1);</b>
<b class="nc">&nbsp;                decimal = BigDecimal.valueOf(</b>
&nbsp;                        BIG_ENDIAN
&nbsp;                                ? unscaledValue
<b class="nc">&nbsp;                                : Long.reverseBytes(unscaledValue), scale</b>
&nbsp;                );
<b class="nc">&nbsp;                offset += 9;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
<b class="nc">&nbsp;                decimal = scale == 0</b>
&nbsp;                        ? new BigDecimal(unscaledValue)
&nbsp;                        : new BigDecimal(unscaledValue, scale);
&nbsp;            }
<b class="nc">&nbsp;        } else if (type == BC_DECIMAL_LONG) {</b>
<b class="nc">&nbsp;            decimal = BigDecimal.valueOf(</b>
<b class="nc">&nbsp;                    readInt64Value()</b>
&nbsp;            );
&nbsp;        } else {
<b class="nc">&nbsp;            decimal = readDecimal0(type);</b>
&nbsp;        }
<b class="nc">&nbsp;        return decimal;</b>
&nbsp;    }
&nbsp;
&nbsp;    private BigDecimal readDecimal0(byte type) {
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_DOUBLE_NUM_0:
&nbsp;            case BC_FALSE:
<b class="nc">&nbsp;                return BigDecimal.ZERO;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="nc">&nbsp;                return BigDecimal.ONE;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return BigDecimal.valueOf(bytes[offset++]);</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf(int16Value);</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                float floatValue = (float) readInt32Value();</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf((long) floatValue);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf((long) floatValue);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                double doubleValue = Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf(</b>
&nbsp;                        (long) doubleValue);
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                BigInteger bigInt = readBigInteger();</b>
<b class="nc">&nbsp;                return new BigDecimal(bigInt);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                double doubleValue = readInt64Value();</b>
<b class="nc">&nbsp;                return BigDecimal.valueOf((long) doubleValue);</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return toBigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return toBigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return toBigDecimal(str);</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return BigDecimal.valueOf(type);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;                    this.offset = offset + 2;</b>
<b class="nc">&nbsp;                    return BigDecimal.valueOf(int3);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="nc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    return toBigDecimal(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BigInteger readBigInteger() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
&nbsp;        BigInteger bigInt;
<b class="nc">&nbsp;        if (type == BC_BIGINT_LONG) {</b>
<b class="nc">&nbsp;            bigInt = BigInteger.valueOf(</b>
<b class="nc">&nbsp;                    readInt64Value()</b>
&nbsp;            );
<b class="nc">&nbsp;        } else if (type == BC_BIGINT) {</b>
<b class="nc">&nbsp;            int len = readInt32Value();</b>
<b class="nc">&nbsp;            byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;            System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;            offset += len;</b>
<b class="nc">&nbsp;            bigInt = new BigInteger(bytes);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            bigInt = readBigInteger0(type);</b>
&nbsp;        }
<b class="nc">&nbsp;        return bigInt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private BigInteger readBigInteger0(byte type) {
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_DOUBLE_NUM_0:
&nbsp;            case BC_FALSE:
<b class="nc">&nbsp;                return BigInteger.ZERO;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="nc">&nbsp;                return BigInteger.ONE;</b>
&nbsp;            case BC_INT8:
<b class="nc">&nbsp;                return BigInteger.valueOf(bytes[offset++]);</b>
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="nc">&nbsp;                offset += 2;</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(int16Value);</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="nc">&nbsp;                float floatValue = (float) readInt32Value();</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) floatValue);
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="nc">&nbsp;                int int32Value = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) floatValue);
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                double doubleValue = Double.longBitsToDouble(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) doubleValue);
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="nc">&nbsp;                long int64Value = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return BigInteger.valueOf(BIG_ENDIAN ? int64Value : Long.reverseBytes(int64Value));</b>
&nbsp;            }
&nbsp;            case BC_BINARY: {
<b class="nc">&nbsp;                int len = readInt32Value();</b>
<b class="nc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="nc">&nbsp;                int scale = readInt32Value();</b>
<b class="nc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="nc">&nbsp;                if (scale == 0) {</b>
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="nc">&nbsp;                return decimal.toBigInteger();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="nc">&nbsp;                double doubleValue = readInt64Value();</b>
<b class="nc">&nbsp;                return BigInteger.valueOf((long) doubleValue);</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readInt32Value();</b>
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return toBigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                    return BigInteger.valueOf(type);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int int3 = getInt3(bytes, offset, type);</b>
<b class="nc">&nbsp;                    this.offset = offset + 2;</b>
<b class="nc">&nbsp;                    return BigInteger.valueOf(int3);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="nc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="nc">&nbsp;                    int intValue = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="nc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
<b class="nc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate() {
<b class="nc">&nbsp;        int type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type == BC_LOCAL_DATE) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;            int month = bytes[offset++];</b>
<b class="nc">&nbsp;            int dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;            return LocalDate.of(year, month, dayOfMonth);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readLocalDate0(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    private LocalDate readLocalDate0(int type) {
<b class="nc">&nbsp;        if (type == BC_LOCAL_DATETIME) {</b>
<b class="nc">&nbsp;            return readLocalDateTime().toLocalDate();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_TIMESTAMP_WITH_TIMEZONE) {</b>
<b class="nc">&nbsp;            return readZonedDateTime().toLocalDate();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            int len = getStringLength();</b>
<b class="nc">&nbsp;            switch (len) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalDate8();</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    return readLocalDate9();</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    return readLocalDate10();</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalDate11();</b>
&nbsp;                default:
<b class="nc">&nbsp;                    if (bytes[offset + len] == &#39;Z&#39;) {</b>
<b class="nc">&nbsp;                        ZonedDateTime zdt = readZonedDateTime();</b>
<b class="nc">&nbsp;                        return zdt.toLocalDate();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + len + &quot;, &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_STR_UTF8 || type == BC_STR_ASCII) {</b>
<b class="nc">&nbsp;            strtype = (byte) type;</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            switch (strlen) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalDate8();</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    return readLocalDate9();</b>
&nbsp;                case 10: {
<b class="nc">&nbsp;                    return readLocalDate10();</b>
&nbsp;                }
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalDate11();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type : &quot; + typeName((byte) type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDateTime readLocalDateTime() {
<b class="nc">&nbsp;        int type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type == BC_LOCAL_DATETIME) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;            int month = bytes[offset++];</b>
<b class="nc">&nbsp;            int dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;            int hour = bytes[offset++];</b>
<b class="nc">&nbsp;            int minute = bytes[offset++];</b>
<b class="nc">&nbsp;            int second = bytes[offset++];</b>
&nbsp;
<b class="nc">&nbsp;            int nano = readInt32Value();</b>
&nbsp;
<b class="nc">&nbsp;            return LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readLocalDateTime0(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    private LocalDateTime readLocalDateTime0(int type) {
<b class="nc">&nbsp;        if (type == BC_TIMESTAMP_WITH_TIMEZONE) {</b>
<b class="nc">&nbsp;            return readZonedDateTime().toLocalDateTime();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            int len = getStringLength();</b>
&nbsp;            LocalDate localDate;
<b class="nc">&nbsp;            switch (len) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    localDate = readLocalDate8();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    localDate = readLocalDate9();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    localDate = readLocalDate10();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    localDate = readLocalDate11();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 16:
<b class="nc">&nbsp;                    return readLocalDateTime16();</b>
&nbsp;                case 17:
<b class="nc">&nbsp;                    return readLocalDateTime17();</b>
&nbsp;                case 18:
<b class="nc">&nbsp;                    return readLocalDateTime18();</b>
&nbsp;                case 19:
<b class="nc">&nbsp;                    return readLocalDateTime19();</b>
&nbsp;                case 20:
<b class="nc">&nbsp;                    return readLocalDateTime20();</b>
&nbsp;                case 21:
&nbsp;                case 22:
&nbsp;                case 23:
&nbsp;                case 24:
&nbsp;                case 25:
&nbsp;                case 26:
&nbsp;                case 27:
&nbsp;                case 28:
&nbsp;                case 29:
<b class="nc">&nbsp;                    LocalDateTime ldt = readLocalDateTimeX(len);</b>
<b class="nc">&nbsp;                    if (ldt != null) {</b>
<b class="nc">&nbsp;                        return ldt;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ZonedDateTime zdt = readZonedDateTimeX(len);</b>
<b class="nc">&nbsp;                    if (zdt != null) {</b>
<b class="nc">&nbsp;                        return zdt.toLocalDateTime();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + len + &quot;, &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type : &quot; + typeName((byte) type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime12() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 12</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime12(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 13;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime14() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 14</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime14(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 15;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime16() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 16</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime16(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 17;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime17() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 17</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime17(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 18;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime10() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 10</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime10(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 11;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime11() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 11</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime11(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 12;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected ZonedDateTime readZonedDateTimeX(int len) {
<b class="nc">&nbsp;        type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type &lt; BC_STR_ASCII_FIX_MIN || type &gt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        ZonedDateTime ldt;
<b class="nc">&nbsp;        if (len &lt; 19</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseZonedDateTime(bytes, offset + 1, len, context.zoneId)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;illegal LocalDateTime string : &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += (len + 1);</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void skipLineComment() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalTime readLocalTime() {
<b class="nc">&nbsp;        int type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type == BC_LOCAL_TIME) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            int hour = bytes[offset++];</b>
<b class="nc">&nbsp;            int minute = bytes[offset++];</b>
<b class="nc">&nbsp;            int second = bytes[offset++];</b>
<b class="nc">&nbsp;            int nano = readInt32Value();</b>
<b class="nc">&nbsp;            return LocalTime.of(hour, minute, second, nano);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            int len = getStringLength();</b>
<b class="nc">&nbsp;            switch (len) {</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return readLocalTime5();</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalTime8();</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    return readLocalTime10();</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalTime11();</b>
&nbsp;                case 12:
<b class="nc">&nbsp;                    return readLocalTime12();</b>
&nbsp;                case 18:
<b class="nc">&nbsp;                    return readLocalTime18();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;not support len : &quot; + len);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Instant readInstant() {
<b class="nc">&nbsp;        int type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_TIMESTAMP: {
<b class="nc">&nbsp;                return Instant.ofEpochSecond(</b>
<b class="nc">&nbsp;                        readInt64Value(),</b>
<b class="nc">&nbsp;                        readInt32Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Instant.ofEpochSecond(minutes * 60, 0);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long seconds = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return Instant.ofEpochSecond(seconds, 0);</b>
&nbsp;            }
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                return Instant.ofEpochMilli(BIG_ENDIAN ? millis : Long.reverseBytes(millis));</b>
&nbsp;            }
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    public OffsetTime readOffsetTime() {
<b class="nc">&nbsp;        ZonedDateTime zdt = readZonedDateTime();</b>
<b class="nc">&nbsp;        return zdt == null ? null : zdt.toOffsetDateTime().toOffsetTime();</b>
&nbsp;    }
&nbsp;
&nbsp;    public OffsetDateTime readOffsetDateTime() {
<b class="nc">&nbsp;        ZonedDateTime zdt = readZonedDateTime();</b>
<b class="nc">&nbsp;        return zdt == null ? zdt.toOffsetDateTime() : zdt.toOffsetDateTime();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ZonedDateTime readZonedDateTime() {
<b class="nc">&nbsp;        int type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_TIMESTAMP: {
<b class="nc">&nbsp;                long second = readInt64Value();</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(second, nano);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(minutes * 60);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long seconds = getInt(bytes, offset);</b>
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(seconds);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_LOCAL_DATE: {
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                byte month = bytes[offset++];</b>
<b class="nc">&nbsp;                byte dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                LocalDate localDate = LocalDate.of(year, month, dayOfMonth);</b>
<b class="nc">&nbsp;                return ZonedDateTime.of(localDate, LocalTime.MIN, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_LOCAL_DATETIME: {
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                byte month = bytes[offset++];</b>
<b class="nc">&nbsp;                byte dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                byte hour = bytes[offset++];</b>
<b class="nc">&nbsp;                byte minute = bytes[offset++];</b>
<b class="nc">&nbsp;                byte second = bytes[offset++];</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                LocalDateTime ldt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
<b class="nc">&nbsp;                return ZonedDateTime.of(ldt, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochMilli(BIG_ENDIAN ? millis : Long.reverseBytes(millis));</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, DEFAULT_ZONE_ID);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_WITH_TIMEZONE:
<b class="nc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="nc">&nbsp;                int month = bytes[offset++];</b>
<b class="nc">&nbsp;                int dayOfMonth = bytes[offset++];</b>
<b class="nc">&nbsp;                int hour = bytes[offset++];</b>
<b class="nc">&nbsp;                int minute = bytes[offset++];</b>
<b class="nc">&nbsp;                int second = bytes[offset++];</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                LocalDateTime ldt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
&nbsp;
&nbsp;                ZoneId zoneId;
<b class="nc">&nbsp;                long zoneIdHash = readValueHashCode();</b>
<b class="nc">&nbsp;                final long SHANGHAI_ZONE_ID_HASH = -4800907791268808639L; // Fnv.hashCode64(&quot;Asia/Shanghai&quot;);</b>
<b class="nc">&nbsp;                if (zoneIdHash == SHANGHAI_ZONE_ID_HASH) {</b>
<b class="nc">&nbsp;                    zoneId = SHANGHAI_ZONE_ID;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    String zoneIdStr = getString();</b>
<b class="nc">&nbsp;                    ZoneId contextZoneId = context.getZoneId();</b>
<b class="nc">&nbsp;                    if (contextZoneId.getId().equals(zoneIdStr)) {</b>
<b class="nc">&nbsp;                        zoneId = contextZoneId;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        zoneId = DateUtils.getZoneId(zoneIdStr, SHANGHAI_ZONE_ID);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return ZonedDateTime.ofLocal(ldt, zoneId, null);</b>
&nbsp;            default:
<b class="nc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_0 &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;                    offset--;</b>
<b class="nc">&nbsp;                    return readZonedDateTimeX(type - BC_STR_ASCII_FIX_MIN);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;type not support : &quot; + JSONB.typeName((byte) type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public UUID readUUID() {
<b class="nc">&nbsp;        byte type = bytes[offset++];</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_BINARY:
<b class="nc">&nbsp;                int len = readLength();</b>
<b class="nc">&nbsp;                if (len != 16) {</b>
<b class="nc">&nbsp;                    throw new JSONException(&quot;uuid not support &quot; + len);</b>
&nbsp;                }
<b class="nc">&nbsp;                long msb = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;                long lsb = UNSAFE.getLong(bytes, ARRAY_BYTE_BASE_OFFSET + offset + 8);</b>
<b class="nc">&nbsp;                offset += 16;</b>
<b class="nc">&nbsp;                return new UUID(</b>
<b class="nc">&nbsp;                        BIG_ENDIAN ? msb : Long.reverseBytes(msb),</b>
<b class="nc">&nbsp;                        BIG_ENDIAN ? lsb : Long.reverseBytes(lsb)</b>
&nbsp;                );
&nbsp;            case BC_STR_ASCII_FIX_32: {
<b class="nc">&nbsp;                long hi = 0;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; 16; i++) {</b>
<b class="nc">&nbsp;                    hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                }
<b class="nc">&nbsp;                long lo = 0;</b>
<b class="nc">&nbsp;                for (int i = 16; i &lt; 32; i++) {</b>
<b class="nc">&nbsp;                    lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                offset += 32;</b>
<b class="nc">&nbsp;                return new UUID(hi, lo);</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII_FIX_36: {
<b class="nc">&nbsp;                byte ch1 = bytes[offset + 8];</b>
<b class="nc">&nbsp;                byte ch2 = bytes[offset + 13];</b>
<b class="nc">&nbsp;                byte ch3 = bytes[offset + 18];</b>
<b class="nc">&nbsp;                byte ch4 = bytes[offset + 23];</b>
<b class="nc">&nbsp;                if (ch1 == &#39;-&#39; &amp;&amp; ch2 == &#39;-&#39; &amp;&amp; ch3 == &#39;-&#39; &amp;&amp; ch4 == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                    long hi = 0;</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; 8; i++) {</b>
<b class="nc">&nbsp;                        hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int i = 9; i &lt; 13; i++) {</b>
<b class="nc">&nbsp;                        hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int i = 14; i &lt; 18; i++) {</b>
<b class="nc">&nbsp;                        hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    long lo = 0;</b>
<b class="nc">&nbsp;                    for (int i = 19; i &lt; 23; i++) {</b>
<b class="nc">&nbsp;                        lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int i = 24; i &lt; 36; i++) {</b>
<b class="nc">&nbsp;                        lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    offset += 36;</b>
<b class="nc">&nbsp;                    return new UUID(hi, lo);</b>
&nbsp;                }
<b class="nc">&nbsp;                throw new JSONException(&quot;Invalid UUID string:  &quot; + new String(bytes, offset, 36, StandardCharsets.ISO_8859_1));</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII:
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
<b class="nc">&nbsp;                if (strlen == 32) {</b>
<b class="nc">&nbsp;                    long hi = 0;</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; 16; i++) {</b>
<b class="nc">&nbsp;                        hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
<b class="nc">&nbsp;                    long lo = 0;</b>
<b class="nc">&nbsp;                    for (int i = 16; i &lt; 32; i++) {</b>
<b class="nc">&nbsp;                        lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    offset += 32;</b>
<b class="nc">&nbsp;                    return new UUID(hi, lo);</b>
<b class="nc">&nbsp;                } else if (strlen == 36) {</b>
<b class="nc">&nbsp;                    byte ch1 = bytes[offset + 8];</b>
<b class="nc">&nbsp;                    byte ch2 = bytes[offset + 13];</b>
<b class="nc">&nbsp;                    byte ch3 = bytes[offset + 18];</b>
<b class="nc">&nbsp;                    byte ch4 = bytes[offset + 23];</b>
<b class="nc">&nbsp;                    if (ch1 == &#39;-&#39; &amp;&amp; ch2 == &#39;-&#39; &amp;&amp; ch3 == &#39;-&#39; &amp;&amp; ch4 == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                        long hi = 0;</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; 8; i++) {</b>
<b class="nc">&nbsp;                            hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                        }
<b class="nc">&nbsp;                        for (int i = 9; i &lt; 13; i++) {</b>
<b class="nc">&nbsp;                            hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                        }
<b class="nc">&nbsp;                        for (int i = 14; i &lt; 18; i++) {</b>
<b class="nc">&nbsp;                            hi = (hi &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        long lo = 0;</b>
<b class="nc">&nbsp;                        for (int i = 19; i &lt; 23; i++) {</b>
<b class="nc">&nbsp;                            lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                        }
<b class="nc">&nbsp;                        for (int i = 24; i &lt; 36; i++) {</b>
<b class="nc">&nbsp;                            lo = (lo &lt;&lt; 4) + UUID_VALUES[bytes[offset + i] - &#39;0&#39;];</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        offset += 36;</b>
<b class="nc">&nbsp;                        return new UUID(hi, lo);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;Invalid UUID string:  &quot; + str);</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                throw new JSONException(&quot;type not support : &quot; + JSONB.typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Boolean readBool() {
<b class="nc">&nbsp;        byte type = this.bytes[offset++];</b>
<b class="nc">&nbsp;        if (type == BC_NULL) {</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        } else if (type == BC_TRUE) {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } else if (type == BC_FALSE) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readBoolValue0(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean readBoolValue() {
<b class="nc">&nbsp;        wasNull = false;</b>
<b class="nc">&nbsp;        byte type = this.bytes[offset++];</b>
<b class="nc">&nbsp;        if (type == BC_TRUE) {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } else if (type == BC_FALSE) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return readBoolValue0(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean readBoolValue0(byte type) {
<b class="nc">&nbsp;        final byte[] bytes = this.bytes;</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_INT32_NUM_1:
<b class="nc">&nbsp;                return true;</b>
&nbsp;            case BC_INT32_NUM_0:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                if ((context.features &amp; Feature.ErrorOnNullForPrimitives.mask) != 0) {</b>
<b class="nc">&nbsp;                    throw new JSONException(info(&quot;long value not support input null&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                wasNull = true;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case BC_STR_ASCII_FIX_1:
<b class="nc">&nbsp;                if (bytes[offset] == &#39;1&#39; || bytes[offset] == &#39;Y&#39;) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bytes[offset] == &#39;0&#39; || bytes[offset] == &#39;N&#39;) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            case BC_STR_ASCII_FIX_4:
<b class="nc">&nbsp;                if (bytes[offset] == &#39;t&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;r&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;u&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;e&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bytes[offset] == &#39;T&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;R&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;U&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;E&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            case BC_STR_ASCII_FIX_5:
<b class="nc">&nbsp;                if (bytes[offset] == &#39;f&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;a&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;l&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;s&#39;
&nbsp;                        &amp;&amp; bytes[offset + 4] == &#39;e&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 5;</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bytes[offset] == &#39;F&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;A&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;L&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;S&#39;
&nbsp;                        &amp;&amp; bytes[offset + 4] == &#39;E&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 5;</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            case BC_STR_UTF8:
&nbsp;            case BC_STR_ASCII: {
<b class="nc">&nbsp;                strlen = readLength();</b>
<b class="nc">&nbsp;                if (strlen == 1) {</b>
<b class="nc">&nbsp;                    if (bytes[offset] == &#39;Y&#39;) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (bytes[offset] == &#39;N&#39;) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (strlen == 4</b>
&nbsp;                        &amp;&amp; bytes[offset] == &#39;t&#39;
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;r&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;u&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;e&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (strlen == 5) {</b>
<b class="nc">&nbsp;                    if (bytes[offset] == &#39;f&#39;</b>
&nbsp;                            &amp;&amp; bytes[offset + 1] == &#39;a&#39;
&nbsp;                            &amp;&amp; bytes[offset + 2] == &#39;l&#39;
&nbsp;                            &amp;&amp; bytes[offset + 3] == &#39;s&#39;
&nbsp;                            &amp;&amp; bytes[offset + 4] == &#39;e&#39;) {
<b class="nc">&nbsp;                        offset += 5;</b>
<b class="nc">&nbsp;                        return false;</b>
<b class="nc">&nbsp;                    } else if (bytes[offset] == &#39;F&#39;</b>
&nbsp;                            &amp;&amp; bytes[offset + 1] == &#39;A&#39;
&nbsp;                            &amp;&amp; bytes[offset + 2] == &#39;L&#39;
&nbsp;                            &amp;&amp; bytes[offset + 3] == &#39;S&#39;
&nbsp;                            &amp;&amp; bytes[offset + 4] == &#39;E&#39;) {
<b class="nc">&nbsp;                        offset += 5;</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;not support input &quot; + str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16:
&nbsp;            case BC_STR_UTF16BE:
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                strlen = readLength();</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
&nbsp;
<b class="nc">&nbsp;                Charset charset = type == BC_STR_UTF16BE</b>
&nbsp;                        ? StandardCharsets.UTF_16BE
&nbsp;                        : type == BC_STR_UTF16LE ? StandardCharsets.UTF_16LE : StandardCharsets.UTF_16;
&nbsp;
<b class="nc">&nbsp;                String str = new String(chars, charset);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                switch (str) {</b>
&nbsp;                    case &quot;0&quot;:
&nbsp;                    case &quot;N&quot;:
&nbsp;                    case &quot;false&quot;:
&nbsp;                    case &quot;FALSE&quot;:
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    case &quot;1&quot;:
&nbsp;                    case &quot;Y&quot;:
&nbsp;                    case &quot;true&quot;:
&nbsp;                    case &quot;TRUE&quot;:
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new JSONException(&quot;not support input &quot; + str);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                throw new JSONException(&quot;not support type : &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatch(byte type) {
<b class="nc">&nbsp;        if (bytes[offset] == type) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean nextIfMatchTypedAny() {
<b class="nc">&nbsp;        if (bytes[offset] == BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected int getStringLength() {
<b class="nc">&nbsp;        type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            return type - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate8() {
&nbsp;        LocalDate ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 8</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDate8(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 9;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate9() {
&nbsp;        LocalDate ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 9</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDate9(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 10;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDate readLocalDate10() {
&nbsp;        LocalDate ldt;
<b class="nc">&nbsp;        if ((strtype == BC_STR_ASCII || strtype == BC_STR_UTF8) &amp;&amp; strlen == 10) {</b>
<b class="nc">&nbsp;            ldt = DateUtils.parseLocalDate10(bytes, offset);</b>
<b class="nc">&nbsp;        } else if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 10</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDate10(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 11;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDate readLocalDate11() {
&nbsp;        LocalDate ldt;
<b class="nc">&nbsp;        if ((strtype == BC_STR_ASCII || strtype == BC_STR_UTF8) &amp;&amp; strlen == 11) {</b>
<b class="nc">&nbsp;            ldt = DateUtils.parseLocalDate11(bytes, offset);</b>
<b class="nc">&nbsp;        } else if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 11</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDate11(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 12;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime5() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 5</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime5(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 6;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime8() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 8</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime8(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 9;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime9() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 8</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime8(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 10;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime12() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 12</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime12(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 13;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime18() {
&nbsp;        LocalTime time;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 18</b>
<b class="nc">&nbsp;                || (time = DateUtils.parseLocalTime18(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 19;</b>
<b class="nc">&nbsp;        return time;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime18() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 18</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime18(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 19;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime20() {
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 20</b>
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTime20(bytes, offset + 1)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        offset += 21;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readMillis19() {
<b class="nc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN + 19) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long millis = DateUtils.parseMillis19(bytes, offset + 1, context.zoneId);</b>
<b class="nc">&nbsp;        offset += 20;</b>
<b class="nc">&nbsp;        return millis;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime19() {
<b class="nc">&nbsp;        type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 19) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LocalDateTime ldt = DateUtils.parseLocalDateTime19(bytes, offset + 1);</b>
<b class="nc">&nbsp;        if (ldt == null) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 20;</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTimeX(int len) {
<b class="nc">&nbsp;        type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type &lt; BC_STR_ASCII_FIX_MIN || type &gt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        LocalDateTime ldt;
<b class="nc">&nbsp;        if (len &lt; 21</b>
&nbsp;                || len &gt; 29
<b class="nc">&nbsp;                || (ldt = DateUtils.parseLocalDateTimeX(bytes, offset + 1, len)) == null</b>
&nbsp;        ) {
<b class="nc">&nbsp;            throw new JSONException(&quot;illegal LocalDateTime string : &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += (len + 1);</b>
<b class="nc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readPattern() {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readFieldNameHashCodeUnquote() {
<b class="nc">&nbsp;        return readFieldNameHashCode();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfSet() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfInfinity() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2, char c3) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2, char c3, char c4) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2, char c3, char c4, char c5) {
<b class="nc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SavePoint mark() {
<b class="nc">&nbsp;        return new SavePoint(this.offset, this.type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void reset(SavePoint savePoint) {
<b class="nc">&nbsp;        this.offset = savePoint.offset;</b>
<b class="nc">&nbsp;        this.type = (byte) savePoint.current;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="nc">&nbsp;        byte[] valueBytes = this.valueBytes;</b>
<b class="nc">&nbsp;        if (valueBytes != null &amp;&amp; valueBytes.length &lt; CACHE_THRESHOLD) {</b>
<b class="nc">&nbsp;            BYTES_UPDATER.lazySet(cacheItem, valueBytes);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEnd() {
<b class="nc">&nbsp;        return offset &gt;= end;</b>
&nbsp;    }
&nbsp;
&nbsp;    static int getInt(byte[] bytes, int offset) {
<b class="nc">&nbsp;        int int32Value = UNSAFE.getInt(bytes, ARRAY_BYTE_BASE_OFFSET + offset);</b>
<b class="nc">&nbsp;        return BIG_ENDIAN ? int32Value : Integer.reverseBytes(int32Value);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:22</div>
</div>
</body>
</html>
