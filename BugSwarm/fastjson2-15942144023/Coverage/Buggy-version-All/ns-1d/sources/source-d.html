


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JodaSupport</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.alibaba.fastjson2.util</a>
</div>

<h1>Coverage Summary for Class: JodaSupport (com.alibaba.fastjson2.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JodaSupport</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JodaSupport$ChronologyReader</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.5%
  </span>
  <span class="absValue">
    (25/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$DateTime2ZDT</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (32/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$DateTimeFromZDT</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.3%
  </span>
  <span class="absValue">
    (21/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$GregorianChronologyWriter</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.7%
  </span>
  <span class="absValue">
    (17/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$InstantReader</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.8%
  </span>
  <span class="absValue">
    (26/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$ISOChronologyWriter</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.9%
  </span>
  <span class="absValue">
    (13/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$LocalDateReader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.1%
  </span>
  <span class="absValue">
    (35/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$LocalDateTimeReader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.6%
  </span>
  <span class="absValue">
    (44/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$LocalDateTimeWriter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.2%
  </span>
  <span class="absValue">
    (71/97)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JodaSupport$LocalDateWriter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.6%
  </span>
  <span class="absValue">
    (45/58)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    84.4%
  </span>
  <span class="absValue">
    (38/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.3%
  </span>
  <span class="absValue">
    (345/452)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.alibaba.fastjson2.util;
&nbsp;
&nbsp;import com.alibaba.fastjson2.JSONB;
&nbsp;import com.alibaba.fastjson2.JSONException;
&nbsp;import com.alibaba.fastjson2.JSONReader;
&nbsp;import com.alibaba.fastjson2.JSONWriter;
&nbsp;import com.alibaba.fastjson2.codec.DateTimeCodec;
&nbsp;import com.alibaba.fastjson2.reader.ObjectReader;
&nbsp;import com.alibaba.fastjson2.support.LambdaMiscCodec;
&nbsp;import com.alibaba.fastjson2.writer.ObjectWriter;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.time.*;
&nbsp;import java.time.format.DateTimeFormatter;
&nbsp;import java.util.Map;
&nbsp;import java.util.function.*;
&nbsp;
&nbsp;import static com.alibaba.fastjson2.JSONB.Constants.BC_LOCAL_DATE;
&nbsp;import static com.alibaba.fastjson2.JSONB.Constants.BC_LOCAL_DATETIME;
&nbsp;
<b class="nc">&nbsp;public class JodaSupport {</b>
<b class="fc">&nbsp;    static final long HASH_YEAR = Fnv.hashCode64(&quot;year&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_MONTH = Fnv.hashCode64(&quot;month&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_DAY = Fnv.hashCode64(&quot;day&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_HOUR = Fnv.hashCode64(&quot;hour&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_MINUTE = Fnv.hashCode64(&quot;minute&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_SECOND = Fnv.hashCode64(&quot;second&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_MILLIS = Fnv.hashCode64(&quot;millis&quot;);</b>
<b class="fc">&nbsp;    static final long HASH_CHRONOLOGY = Fnv.hashCode64(&quot;chronology&quot;);</b>
&nbsp;
&nbsp;    public static ObjectWriter createLocalDateTimeWriter(Class objectClass, String format) {
<b class="fc">&nbsp;        return new LocalDateTimeWriter(objectClass, format);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectWriter createLocalDateWriter(Class objectClass, String format) {
<b class="fc">&nbsp;        return new LocalDateWriter(objectClass, format);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectReader createChronologyReader(Class objectClass) {
<b class="fc">&nbsp;        return new ChronologyReader(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectReader createLocalDateReader(Class objectClass) {
<b class="fc">&nbsp;        return new LocalDateReader(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectReader createLocalDateTimeReader(Class objectClass) {
<b class="fc">&nbsp;        return new LocalDateTimeReader(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectReader createInstantReader(Class objectClass) {
<b class="fc">&nbsp;        return new InstantReader(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectWriter createGregorianChronologyWriter(Class objectClass) {
<b class="fc">&nbsp;        return new GregorianChronologyWriter(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectWriter createISOChronologyWriter(Class objectClass) {
<b class="fc">&nbsp;        return new ISOChronologyWriter(objectClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    static class InstantReader
&nbsp;            implements ObjectReader {
&nbsp;        final Class objectClass;
&nbsp;        final LongFunction constructor;
&nbsp;
<b class="fc">&nbsp;        InstantReader(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                this.constructor = LambdaMiscCodec.createLongFunction(</b>
<b class="fc">&nbsp;                        objectClass.getConstructor(long.class)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (NoSuchMethodException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;create joda instant reader error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Class getObjectClass() {
<b class="nc">&nbsp;            return objectClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object createInstance(Map map, long features) {
<b class="fc">&nbsp;            Number millis = (Long) map.get(&quot;millis&quot;);</b>
<b class="fc">&nbsp;            if (millis != null) {</b>
<b class="fc">&nbsp;                return createInstanceFromMillis(millis.longValue());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            Number epochSecond = (Number) map.get(&quot;epochSecond&quot;);</b>
<b class="fc">&nbsp;            if (epochSecond != null) {</b>
<b class="fc">&nbsp;                long epochMillis = epochSecond.longValue() * 1000L;</b>
<b class="fc">&nbsp;                return createInstanceFromMillis(epochMillis);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(&quot;create joda instant error&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Object createInstanceFromMillis(long millis) {
<b class="fc">&nbsp;            return constructor.apply(millis);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            if (jsonReader.nextIfNull()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (jsonReader.isInt()) {</b>
<b class="fc">&nbsp;                long millis = jsonReader.readInt64Value();</b>
<b class="fc">&nbsp;                return createInstanceFromMillis(millis);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (jsonReader.isString()) {</b>
<b class="fc">&nbsp;                Instant jdkInstant = jsonReader.readInstant();</b>
<b class="fc">&nbsp;                if (jdkInstant == null) {</b>
<b class="fc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                long millis = jdkInstant.toEpochMilli();</b>
<b class="fc">&nbsp;                return createInstanceFromMillis(millis);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (jsonReader.isObject()) {</b>
<b class="fc">&nbsp;                Map object = jsonReader.readObject();</b>
<b class="fc">&nbsp;                return createInstance(object, features);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="nc">&nbsp;            return readObject(jsonReader, fieldType, fieldName, features);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ChronologyReader
&nbsp;            implements ObjectReader {
<b class="fc">&nbsp;        static final long HASH_ZONE_ID = Fnv.hashCode64(&quot;zoneId&quot;);</b>
&nbsp;
&nbsp;        final Class objectClass;
&nbsp;        final Class gregorianChronology;
&nbsp;        final Class dateTimeZone;
&nbsp;        final Function forID;
&nbsp;        final Function getInstance;
&nbsp;        final Object utc;
&nbsp;
<b class="fc">&nbsp;        ChronologyReader(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
<b class="fc">&nbsp;            ClassLoader classLoader = objectClass.getClassLoader();</b>
&nbsp;            try {
<b class="fc">&nbsp;                gregorianChronology = classLoader.loadClass(&quot;org.joda.time.chrono.GregorianChronology&quot;);</b>
<b class="fc">&nbsp;                dateTimeZone = classLoader.loadClass(&quot;org.joda.time.DateTimeZone&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                utc = gregorianChronology.getMethod(&quot;getInstanceUTC&quot;).invoke(null);</b>
<b class="fc">&nbsp;                forID = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        dateTimeZone.getMethod(&quot;forID&quot;, String.class)</b>
&nbsp;                );
<b class="fc">&nbsp;                getInstance = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        gregorianChronology.getMethod(&quot;getInstance&quot;, dateTimeZone)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;create ChronologyReader error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Class getObjectClass() {
<b class="nc">&nbsp;            return objectClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            Integer minimumDaysInFirstWeek = null;</b>
<b class="fc">&nbsp;            String zoneId = null;</b>
<b class="fc">&nbsp;            jsonReader.nextIfObjectStart();</b>
<b class="fc">&nbsp;            while (!jsonReader.nextIfObjectEnd()) {</b>
<b class="fc">&nbsp;                final long HASH_MINIMUM_DAYS_IN_FIRST_WEEK = 8244232525129275563L; // Fnv.hashCode64(&quot;minimumDaysInFirstWeek&quot;);</b>
<b class="fc">&nbsp;                long fieldNameHashCode = jsonReader.readFieldNameHashCode();</b>
<b class="fc">&nbsp;                if (fieldNameHashCode == HASH_MINIMUM_DAYS_IN_FIRST_WEEK) {</b>
<b class="nc">&nbsp;                    minimumDaysInFirstWeek = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                } else if (fieldNameHashCode == HASH_ZONE_ID) {</b>
<b class="fc">&nbsp;                    zoneId = jsonReader.readString();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;not support fieldName &quot; + jsonReader.getFieldName()));</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            if (minimumDaysInFirstWeek == null) {</b>
<b class="fc">&nbsp;                if (&quot;UTC&quot;.equals(zoneId)) {</b>
<b class="fc">&nbsp;                    return utc;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Object datetimeZone = forID.apply(zoneId);</b>
<b class="nc">&nbsp;                return getInstance.apply(datetimeZone);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support&quot;));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class GregorianChronologyWriter
&nbsp;            implements ObjectWriter {
&nbsp;        final Class objectClass;
&nbsp;        final ToIntFunction getMinimumDaysInFirstWeek;
&nbsp;        final Function getZone;
&nbsp;        final Function getID;
&nbsp;
<b class="fc">&nbsp;        GregorianChronologyWriter(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                this.getMinimumDaysInFirstWeek = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getMinimumDaysInFirstWeek&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                Method method = objectClass.getMethod(&quot;getZone&quot;);</b>
<b class="fc">&nbsp;                this.getZone = LambdaMiscCodec.createFunction(method);</b>
<b class="fc">&nbsp;                this.getID = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        method.getReturnType().getMethod(&quot;getID&quot;)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (NoSuchMethodException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;getMethod error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void writeJSONB(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="fc">&nbsp;            Object zone = getZone.apply(object);</b>
<b class="fc">&nbsp;            String zoneId = (String) getID.apply(zone);</b>
&nbsp;
<b class="fc">&nbsp;            int minDaysInFirstWeek = getMinimumDaysInFirstWeek.applyAsInt(object);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.startObject();</b>
<b class="fc">&nbsp;            if (minDaysInFirstWeek != 4) {</b>
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;minimumDaysInFirstWeek&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(minDaysInFirstWeek);</b>
&nbsp;            }
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;zoneId&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeString(zoneId);</b>
<b class="fc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="nc">&nbsp;            Object zone = getZone.apply(object);</b>
<b class="nc">&nbsp;            String zoneId = (String) getID.apply(zone);</b>
&nbsp;
<b class="nc">&nbsp;            int minDaysInFirstWeek = getMinimumDaysInFirstWeek.applyAsInt(object);</b>
<b class="nc">&nbsp;            jsonWriter.startObject();</b>
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;minimumDaysInFirstWeek&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeInt32(minDaysInFirstWeek);</b>
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;zoneId&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeString(zoneId);</b>
<b class="nc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ISOChronologyWriter
&nbsp;            implements ObjectWriter {
&nbsp;        final Class objectClass;
&nbsp;        final Function getZone;
&nbsp;        final Function getID;
&nbsp;
<b class="fc">&nbsp;        ISOChronologyWriter(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                Method method = objectClass.getMethod(&quot;getZone&quot;);</b>
<b class="fc">&nbsp;                this.getZone = LambdaMiscCodec.createFunction(method);</b>
<b class="fc">&nbsp;                this.getID = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        method.getReturnType().getMethod(&quot;getID&quot;)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (NoSuchMethodException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;getMethod error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void writeJSONB(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="nc">&nbsp;            Object zone = getZone.apply(object);</b>
<b class="nc">&nbsp;            String zoneId = (String) getID.apply(zone);</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.startObject();</b>
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;zoneId&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeString(zoneId);</b>
<b class="nc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="fc">&nbsp;            Object zone = getZone.apply(object);</b>
<b class="fc">&nbsp;            String zoneId = (String) getID.apply(zone);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.startObject();</b>
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;zoneId&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeString(zoneId);</b>
<b class="fc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LocalDateReader
&nbsp;            implements ObjectReader {
&nbsp;        final Class objectClass;
&nbsp;        final Constructor constructor3;
&nbsp;        final Constructor constructor4;
&nbsp;
&nbsp;        final Class classISOChronology;
&nbsp;        final Class classChronology;
&nbsp;        final Object utc;
&nbsp;
<b class="fc">&nbsp;        LocalDateReader(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="fc">&nbsp;                classChronology = classLoader.loadClass(&quot;org.joda.time.Chronology&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                constructor3 = objectClass.getConstructor(int.class, int.class, int.class);</b>
<b class="fc">&nbsp;                constructor4 = objectClass.getConstructor(int.class, int.class, int.class, classChronology);</b>
&nbsp;
<b class="fc">&nbsp;                classISOChronology = classLoader.loadClass(&quot;org.joda.time.chrono.ISOChronology&quot;);</b>
<b class="fc">&nbsp;                utc = classISOChronology.getMethod(&quot;getInstance&quot;).invoke(null);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException</b>
&nbsp;                    | NoSuchMethodException
&nbsp;                    | IllegalAccessException
&nbsp;                    | IllegalArgumentException
&nbsp;                    | InvocationTargetException e) {
<b class="nc">&nbsp;                throw new JSONException(&quot;create LocalDateWriter error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Class getObjectClass() {
<b class="fc">&nbsp;            return objectClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            if (jsonReader.nextIfNull()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            LocalDate localDate = jsonReader.readLocalDate();</b>
<b class="fc">&nbsp;            if (localDate == null) {</b>
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="fc">&nbsp;                return constructor4.newInstance(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth(), null);</b>
<b class="nc">&nbsp;            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            byte type = jsonReader.getType();</b>
&nbsp;
<b class="fc">&nbsp;            if (type == BC_LOCAL_DATE) {</b>
<b class="fc">&nbsp;                LocalDate localDate = jsonReader.readLocalDate();</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return constructor3.newInstance(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth());</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (jsonReader.isObject()) {</b>
<b class="fc">&nbsp;                Integer year = null, month = null, day = null;</b>
<b class="fc">&nbsp;                Object chronology = null;</b>
<b class="fc">&nbsp;                jsonReader.nextIfObjectStart();</b>
<b class="fc">&nbsp;                while (!jsonReader.nextIfObjectEnd()) {</b>
<b class="fc">&nbsp;                    long fieldNameHashCode = jsonReader.readFieldNameHashCode();</b>
<b class="fc">&nbsp;                    if (fieldNameHashCode == HASH_YEAR) {</b>
<b class="fc">&nbsp;                        year = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_MONTH) {</b>
<b class="fc">&nbsp;                        month = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_DAY) {</b>
<b class="fc">&nbsp;                        day = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_CHRONOLOGY) {</b>
<b class="fc">&nbsp;                        chronology = jsonReader.read(classChronology);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new JSONException(jsonReader.info(&quot;not support fieldName &quot; + jsonReader.getFieldName()));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                try {
<b class="fc">&nbsp;                    return constructor4.newInstance(year, month, day, chronology);</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support &quot; + JSONB.typeName(type)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LocalDateWriter
&nbsp;            extends DateTimeCodec
&nbsp;            implements ObjectWriter {
&nbsp;        final Class objectClass;
&nbsp;        final ToIntFunction getYear;
&nbsp;        final ToIntFunction getMonthOfYear;
&nbsp;        final ToIntFunction getDayOfMonth;
&nbsp;        final Function getChronology;
&nbsp;
&nbsp;        final Class isoChronology;
&nbsp;        final Object utc;
&nbsp;
&nbsp;        LocalDateWriter(Class objectClass, String format) {
<b class="fc">&nbsp;            super(format);</b>
&nbsp;
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="fc">&nbsp;                isoChronology = classLoader.loadClass(&quot;org.joda.time.chrono.ISOChronology&quot;);</b>
<b class="fc">&nbsp;                Object instance = isoChronology.getMethod(&quot;getInstance&quot;).invoke(null);</b>
<b class="fc">&nbsp;                utc = isoChronology.getMethod(&quot;withUTC&quot;).invoke(instance);</b>
&nbsp;
<b class="fc">&nbsp;                getYear = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getYear&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getMonthOfYear = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getMonthOfYear&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getDayOfMonth = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getDayOfMonth&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getChronology = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getChronology&quot;)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (ClassNotFoundException</b>
&nbsp;                    | NoSuchMethodException
&nbsp;                    | IllegalAccessException
&nbsp;                    | IllegalArgumentException
&nbsp;                    | InvocationTargetException e) {
<b class="nc">&nbsp;                throw new JSONException(&quot;create LocalDateWriter error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void writeJSONB(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="fc">&nbsp;            int year = getYear.applyAsInt(object);</b>
<b class="fc">&nbsp;            int monthOfYear = getMonthOfYear.applyAsInt(object);</b>
<b class="fc">&nbsp;            int dayOfMonth = getDayOfMonth.applyAsInt(object);</b>
<b class="fc">&nbsp;            Object chronology = getChronology.apply(object);</b>
&nbsp;
<b class="fc">&nbsp;            if (jsonWriter.isWriteTypeInfo(object, fieldType, features)) {</b>
<b class="fc">&nbsp;                jsonWriter.writeTypeName(TypeUtils.getTypeName(object.getClass()));</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (chronology == utc || chronology == null) {</b>
<b class="fc">&nbsp;                jsonWriter.writeLocalDate(LocalDate.of(year, monthOfYear, dayOfMonth));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            jsonWriter.startObject();</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;year&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeInt32(year);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;month&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeInt32(monthOfYear);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;day&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeInt32(dayOfMonth);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.writeName(&quot;chronology&quot;);</b>
<b class="fc">&nbsp;            jsonWriter.writeAny(chronology);</b>
&nbsp;
<b class="fc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
<b class="fc">&nbsp;            int year = getYear.applyAsInt(object);</b>
<b class="fc">&nbsp;            int monthOfYear = getMonthOfYear.applyAsInt(object);</b>
<b class="fc">&nbsp;            int dayOfMonth = getDayOfMonth.applyAsInt(object);</b>
<b class="fc">&nbsp;            Object chronology = getChronology.apply(object);</b>
&nbsp;
<b class="fc">&nbsp;            if (chronology == utc || chronology == null) {</b>
<b class="fc">&nbsp;                LocalDate localDate = LocalDate.of(year, monthOfYear, dayOfMonth);</b>
&nbsp;
<b class="fc">&nbsp;                DateTimeFormatter formatter = this.getDateFormatter();</b>
<b class="fc">&nbsp;                if (formatter == null) {</b>
<b class="fc">&nbsp;                    formatter = jsonWriter.context.getDateFormatter();</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (formatter == null) {</b>
<b class="nc">&nbsp;                    jsonWriter.writeLocalDate(localDate);</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                String str = formatter.format(localDate);</b>
<b class="fc">&nbsp;                jsonWriter.writeString(str);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            jsonWriter.startObject();</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;year&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeInt32(year);</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;month&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeInt32(monthOfYear);</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;day&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeInt32(dayOfMonth);</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.writeName(&quot;chronology&quot;);</b>
<b class="nc">&nbsp;            jsonWriter.writeAny(chronology);</b>
&nbsp;
<b class="nc">&nbsp;            jsonWriter.endObject();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LocalDateTimeReader
&nbsp;            implements ObjectReader {
&nbsp;        final Class objectClass;
&nbsp;        final Constructor constructor7;
&nbsp;        final Constructor constructor8;
&nbsp;
&nbsp;        final Class classISOChronology;
&nbsp;        final Class classChronology;
&nbsp;        final Object utc;
&nbsp;
<b class="fc">&nbsp;        LocalDateTimeReader(Class objectClass) {</b>
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="fc">&nbsp;                classChronology = classLoader.loadClass(&quot;org.joda.time.Chronology&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                constructor7 = objectClass.getConstructor(int.class, int.class, int.class, int.class, int.class, int.class, int.class);</b>
<b class="fc">&nbsp;                constructor8 = objectClass.getConstructor(int.class, int.class, int.class, int.class, int.class, int.class, int.class, classChronology);</b>
&nbsp;
<b class="fc">&nbsp;                classISOChronology = classLoader.loadClass(&quot;org.joda.time.chrono.ISOChronology&quot;);</b>
<b class="fc">&nbsp;                utc = classISOChronology.getMethod(&quot;getInstance&quot;).invoke(null);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException</b>
&nbsp;                    | NoSuchMethodException
&nbsp;                    | IllegalAccessException
&nbsp;                    | IllegalArgumentException
&nbsp;                    | InvocationTargetException e) {
<b class="nc">&nbsp;                throw new JSONException(&quot;create LocalDateWriter error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Class getObjectClass() {
<b class="fc">&nbsp;            return objectClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            if (jsonReader.isString() || jsonReader.isInt()) {</b>
<b class="fc">&nbsp;                LocalDateTime ldt = jsonReader.readLocalDateTime();</b>
<b class="fc">&nbsp;                if (ldt == null) {</b>
<b class="fc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;
&nbsp;                try {
<b class="fc">&nbsp;                    return constructor7.newInstance(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(), ldt.getHour(), ldt.getMinute(), ldt.getSecond(), ldt.getNano() / 1000_000);</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {
<b class="fc">&nbsp;            byte type = jsonReader.getType();</b>
&nbsp;
<b class="fc">&nbsp;            if (type == BC_LOCAL_DATE) {</b>
<b class="nc">&nbsp;                LocalDate localDate = jsonReader.readLocalDate();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return constructor7.newInstance(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth(), 0, 0, 0, 0);</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (type == BC_LOCAL_DATETIME) {</b>
<b class="fc">&nbsp;                LocalDateTime ldt = jsonReader.readLocalDateTime();</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return constructor7.newInstance(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(), ldt.getHour(), ldt.getMinute(), ldt.getSecond(), ldt.getNano() / 1000_000);</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (jsonReader.isObject()) {</b>
<b class="fc">&nbsp;                Integer year = null, month = null, day = null, hour = null, minute = null, second = null, millis = null;</b>
<b class="fc">&nbsp;                Object chronology = null;</b>
<b class="fc">&nbsp;                jsonReader.nextIfObjectStart();</b>
<b class="fc">&nbsp;                while (!jsonReader.nextIfObjectEnd()) {</b>
<b class="fc">&nbsp;                    long fieldNameHashCode = jsonReader.readFieldNameHashCode();</b>
<b class="fc">&nbsp;                    if (fieldNameHashCode == HASH_YEAR) {</b>
<b class="fc">&nbsp;                        year = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_MONTH) {</b>
<b class="fc">&nbsp;                        month = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_DAY) {</b>
<b class="fc">&nbsp;                        day = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_HOUR) {</b>
<b class="fc">&nbsp;                        hour = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_MINUTE) {</b>
<b class="fc">&nbsp;                        minute = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_SECOND) {</b>
<b class="fc">&nbsp;                        second = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_MILLIS) {</b>
<b class="fc">&nbsp;                        millis = jsonReader.readInt32Value();</b>
<b class="fc">&nbsp;                    } else if (fieldNameHashCode == HASH_CHRONOLOGY) {</b>
<b class="fc">&nbsp;                        chronology = jsonReader.read(classChronology);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new JSONException(jsonReader.info(&quot;not support fieldName &quot; + jsonReader.getFieldName()));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                try {
<b class="fc">&nbsp;                    return constructor8.newInstance(year, month, day, hour, minute, second, millis, chronology);</b>
<b class="nc">&nbsp;                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                    throw new JSONException(jsonReader.info(&quot;read org.joda.time.LocalDate error&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(jsonReader.info(&quot;not support &quot; + JSONB.typeName(type)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LocalDateTimeWriter
&nbsp;            extends DateTimeCodec
&nbsp;            implements ObjectWriter {
&nbsp;        final Class objectClass;
&nbsp;
&nbsp;        final Method getYear;
&nbsp;        final Method getMonthOfYear;
&nbsp;        final Method getDayOfMonth;
&nbsp;
&nbsp;        final ToIntFunction getHourOfDay;
&nbsp;        final ToIntFunction getMinuteOfHour;
&nbsp;        final ToIntFunction getSecondOfMinute;
&nbsp;        final ToIntFunction getMillisOfSecond;
&nbsp;
&nbsp;        final Function getChronology;
&nbsp;
&nbsp;        final Class isoChronology;
&nbsp;        final Object utc;
&nbsp;
&nbsp;        LocalDateTimeWriter(Class objectClass, String format) {
<b class="fc">&nbsp;            super(format);</b>
&nbsp;
<b class="fc">&nbsp;            this.objectClass = objectClass;</b>
&nbsp;            try {
<b class="fc">&nbsp;                ClassLoader classLoader = objectClass.getClassLoader();</b>
<b class="fc">&nbsp;                isoChronology = classLoader.loadClass(&quot;org.joda.time.chrono.ISOChronology&quot;);</b>
<b class="fc">&nbsp;                Object instance = isoChronology.getMethod(&quot;getInstance&quot;).invoke(null);</b>
<b class="fc">&nbsp;                utc = isoChronology.getMethod(&quot;withUTC&quot;).invoke(instance);</b>
&nbsp;
<b class="fc">&nbsp;                getYear = objectClass.getMethod(&quot;getYear&quot;);</b>
<b class="fc">&nbsp;                getMonthOfYear = objectClass.getMethod(&quot;getMonthOfYear&quot;);</b>
<b class="fc">&nbsp;                getDayOfMonth = objectClass.getMethod(&quot;getDayOfMonth&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                getHourOfDay = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getHourOfDay&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getMinuteOfHour = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getMinuteOfHour&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getSecondOfMinute = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getSecondOfMinute&quot;)</b>
&nbsp;                );
<b class="fc">&nbsp;                getMillisOfSecond = LambdaMiscCodec.createToIntFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getMillisOfSecond&quot;)</b>
&nbsp;                );
&nbsp;
<b class="fc">&nbsp;                getChronology = LambdaMiscCodec.createFunction(</b>
<b class="fc">&nbsp;                        objectClass.getMethod(&quot;getChronology&quot;)</b>
&nbsp;                );
<b class="nc">&nbsp;            } catch (ClassNotFoundException</b>
&nbsp;                    | NoSuchMethodException
&nbsp;                    | IllegalAccessException
&nbsp;                    | IllegalArgumentException
&nbsp;                    | InvocationTargetException e) {
<b class="nc">&nbsp;                throw new JSONException(&quot;create LocalDateWriter error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void writeJSONB(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
&nbsp;            try {
<b class="fc">&nbsp;                int year = (Integer) getYear.invoke(object);</b>
<b class="fc">&nbsp;                int monthOfYear = (Integer) getMonthOfYear.invoke(object);</b>
<b class="fc">&nbsp;                int dayOfMonth = (Integer) getDayOfMonth.invoke(object);</b>
&nbsp;
<b class="fc">&nbsp;                int hour = getHourOfDay.applyAsInt(object);</b>
<b class="fc">&nbsp;                int minute = getMinuteOfHour.applyAsInt(object);</b>
<b class="fc">&nbsp;                int second = getSecondOfMinute.applyAsInt(object);</b>
<b class="fc">&nbsp;                int millis = getMillisOfSecond.applyAsInt(object);</b>
&nbsp;
<b class="fc">&nbsp;                Object chronology = getChronology.apply(object);</b>
&nbsp;
<b class="fc">&nbsp;                if (jsonWriter.isWriteTypeInfo(object, fieldType, features)) {</b>
<b class="fc">&nbsp;                    jsonWriter.writeTypeName(TypeUtils.getTypeName(object.getClass()));</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (chronology == utc || chronology == null) {</b>
<b class="fc">&nbsp;                    jsonWriter.writeLocalDateTime(</b>
<b class="fc">&nbsp;                            LocalDateTime.of(year, monthOfYear, dayOfMonth, hour, minute, second, millis * 1000000));</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                jsonWriter.startObject();</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;year&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(year);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;month&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(monthOfYear);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;day&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(dayOfMonth);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;hour&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(hour);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;minute&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(minute);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;second&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(second);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;millis&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeInt32(millis);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.writeName(&quot;chronology&quot;);</b>
<b class="fc">&nbsp;                jsonWriter.writeAny(chronology);</b>
&nbsp;
<b class="fc">&nbsp;                jsonWriter.endObject();</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;write LocalDateWriter error&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(JSONWriter jsonWriter, Object object, Object fieldName, Type fieldType, long features) {
&nbsp;            try {
<b class="fc">&nbsp;                int year = (Integer) getYear.invoke(object);</b>
<b class="fc">&nbsp;                int monthOfYear = (Integer) getMonthOfYear.invoke(object);</b>
<b class="fc">&nbsp;                int dayOfMonth = (Integer) getDayOfMonth.invoke(object);</b>
&nbsp;
<b class="fc">&nbsp;                int hour = getHourOfDay.applyAsInt(object);</b>
<b class="fc">&nbsp;                int minute = getMinuteOfHour.applyAsInt(object);</b>
<b class="fc">&nbsp;                int second = getSecondOfMinute.applyAsInt(object);</b>
<b class="fc">&nbsp;                int millis = getMillisOfSecond.applyAsInt(object);</b>
&nbsp;
<b class="fc">&nbsp;                Object chronology = getChronology.apply(object);</b>
&nbsp;
<b class="fc">&nbsp;                if (jsonWriter.isWriteTypeInfo(object, fieldType, features)) {</b>
<b class="nc">&nbsp;                    jsonWriter.writeTypeName(TypeUtils.getTypeName(object.getClass()));</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (chronology == utc || chronology == null) {</b>
<b class="fc">&nbsp;                    int nanoOfSecond = millis * 1000_000;</b>
<b class="fc">&nbsp;                    LocalDateTime ldt = LocalDateTime.of(year, monthOfYear, dayOfMonth, hour, minute, second, nanoOfSecond);</b>
&nbsp;
<b class="fc">&nbsp;                    DateTimeFormatter formatter = this.getDateFormatter();</b>
<b class="fc">&nbsp;                    if (formatter == null) {</b>
<b class="fc">&nbsp;                        formatter = jsonWriter.context.getDateFormatter();</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (formatter == null) {</b>
<b class="fc">&nbsp;                        jsonWriter.writeLocalDateTime(ldt);</b>
&nbsp;                        return;
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    String str = formatter.format(ldt);</b>
<b class="fc">&nbsp;                    jsonWriter.writeString(str);</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                jsonWriter.startObject();</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;year&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(year);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;month&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(monthOfYear);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;day&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(dayOfMonth);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;hour&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(hour);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;minute&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(minute);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;second&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(second);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;millis&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeInt32(millis);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.writeName(&quot;chronology&quot;);</b>
<b class="nc">&nbsp;                jsonWriter.writeAny(chronology);</b>
&nbsp;
<b class="nc">&nbsp;                jsonWriter.endObject();</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;write LocalDateWriter error&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final class DateTimeFromZDT</b>
&nbsp;            implements Function {
&nbsp;        static Constructor CONS;
&nbsp;        static Method FOR_ID;
&nbsp;
&nbsp;        @Override
&nbsp;        public Object apply(Object o) {
<b class="fc">&nbsp;            ZonedDateTime zdt = (ZonedDateTime) o;</b>
&nbsp;            try {
<b class="fc">&nbsp;                if (FOR_ID == null) {</b>
<b class="fc">&nbsp;                    Class&lt;?&gt; zoneClass = Class.forName(&quot;org.joda.time.DateTimeZone&quot;);</b>
<b class="fc">&nbsp;                    FOR_ID = zoneClass.getMethod(&quot;forID&quot;, String.class);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (CONS == null) {</b>
<b class="fc">&nbsp;                    CONS = Class.forName(&quot;org.joda.time.DateTime&quot;)</b>
<b class="fc">&nbsp;                            .getConstructor(</b>
&nbsp;                                    int.class, int.class, int.class, int.class, int.class, int.class, int.class,
<b class="fc">&nbsp;                                    FOR_ID.getDeclaringClass()</b>
&nbsp;                            );
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                String zondId = zdt.getZone().getId();</b>
<b class="fc">&nbsp;                if (&quot;Z&quot;.equals(zondId)) {</b>
<b class="fc">&nbsp;                    zondId = &quot;UTC&quot;;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return CONS.newInstance(</b>
<b class="fc">&nbsp;                        zdt.getYear(),</b>
<b class="fc">&nbsp;                        zdt.getMonthValue(),</b>
<b class="fc">&nbsp;                        zdt.getDayOfMonth(),</b>
<b class="fc">&nbsp;                        zdt.getHour(),</b>
<b class="fc">&nbsp;                        zdt.getMinute(),</b>
<b class="fc">&nbsp;                        zdt.getSecond(),</b>
<b class="fc">&nbsp;                        zdt.getNano() / 1_000_000,</b>
<b class="fc">&nbsp;                        FOR_ID.invoke(null, zondId)</b>
&nbsp;                        );
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;build DateTime error&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final class DateTime2ZDT</b>
&nbsp;            implements Function {
&nbsp;        static Class CLASS;
&nbsp;        static ToIntFunction YEAR;
&nbsp;        static ToIntFunction MONTH;
&nbsp;        static ToIntFunction DAY_OF_MONTH;
&nbsp;        static ToIntFunction HOUR;
&nbsp;        static ToIntFunction MINUTE;
&nbsp;        static ToIntFunction SECOND;
&nbsp;        static ToIntFunction MILLIS;
&nbsp;        static Function GET_ZONE;
&nbsp;        static Function GET_ID;
&nbsp;
&nbsp;        @Override
&nbsp;        public Object apply(Object o) {
&nbsp;            try {
<b class="fc">&nbsp;                if (CLASS == null) {</b>
<b class="fc">&nbsp;                    CLASS = Class.forName(&quot;org.joda.time.DateTime&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (YEAR == null) {</b>
<b class="fc">&nbsp;                    YEAR = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getYear&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (MONTH == null) {</b>
<b class="fc">&nbsp;                    MONTH = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getMonthOfYear&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (DAY_OF_MONTH == null) {</b>
<b class="fc">&nbsp;                    DAY_OF_MONTH = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getDayOfMonth&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (HOUR == null) {</b>
<b class="fc">&nbsp;                    HOUR = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getHourOfDay&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (MINUTE == null) {</b>
<b class="fc">&nbsp;                    MINUTE = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getMinuteOfHour&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (SECOND == null) {</b>
<b class="fc">&nbsp;                    SECOND = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getSecondOfMinute&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (MILLIS == null) {</b>
<b class="fc">&nbsp;                    MILLIS = LambdaMiscCodec.createToIntFunction(CLASS.getMethod(&quot;getMillisOfSecond&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (GET_ZONE == null) {</b>
<b class="fc">&nbsp;                    GET_ZONE = LambdaMiscCodec.createFunction(CLASS.getMethod(&quot;getZone&quot;));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (GET_ID == null) {</b>
<b class="fc">&nbsp;                    GET_ID = LambdaMiscCodec.createFunction(Class.forName(&quot;org.joda.time.DateTimeZone&quot;).getMethod(&quot;getID&quot;));</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                Object zone = GET_ZONE.apply(o);</b>
<b class="fc">&nbsp;                String zonIdStr = (String) GET_ID.apply(zone);</b>
<b class="fc">&nbsp;                ZoneId zoneId = ZoneId.of(zonIdStr);</b>
<b class="fc">&nbsp;                return ZonedDateTime.of(</b>
<b class="fc">&nbsp;                        YEAR.applyAsInt(o),</b>
<b class="fc">&nbsp;                        MONTH.applyAsInt(o),</b>
<b class="fc">&nbsp;                        DAY_OF_MONTH.applyAsInt(o),</b>
<b class="fc">&nbsp;                        HOUR.applyAsInt(o),</b>
<b class="fc">&nbsp;                        MINUTE.applyAsInt(o),</b>
<b class="fc">&nbsp;                        SECOND.applyAsInt(o),</b>
<b class="fc">&nbsp;                        MILLIS.applyAsInt(o) * 1_000_000,</b>
&nbsp;                        zoneId
&nbsp;                );
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;convert joda org.joda.time.DateTime to java.time.ZonedDateTime error&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:27</div>
</div>
</body>
</html>
