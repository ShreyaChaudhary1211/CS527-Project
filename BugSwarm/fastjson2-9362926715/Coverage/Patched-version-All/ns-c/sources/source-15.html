


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JSONReaderJSONB</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.alibaba.fastjson2</a>
</div>

<h1>Coverage Summary for Class: JSONReaderJSONB (com.alibaba.fastjson2)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JSONReaderJSONB</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.9%
  </span>
  <span class="absValue">
    (87/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.1%
  </span>
  <span class="absValue">
    (2036/2903)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.alibaba.fastjson2;
&nbsp;
&nbsp;import com.alibaba.fastjson2.reader.ObjectReader;
&nbsp;import com.alibaba.fastjson2.reader.ObjectReaderProvider;
&nbsp;import com.alibaba.fastjson2.util.*;
&nbsp;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.time.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static com.alibaba.fastjson2.JSONB.Constants.*;
&nbsp;import static com.alibaba.fastjson2.JSONB.typeName;
&nbsp;import static com.alibaba.fastjson2.JSONFactory.*;
&nbsp;import static com.alibaba.fastjson2.util.DateUtils.localDateTime;
&nbsp;import static com.alibaba.fastjson2.util.IOUtils.SHANGHAI_ZONE_ID;
&nbsp;import static com.alibaba.fastjson2.util.JDKUtils.*;
&nbsp;import static com.alibaba.fastjson2.util.UUIDUtils.parse4Nibbles;
&nbsp;
&nbsp;class JSONReaderJSONB
&nbsp;        extends JSONReader {
&nbsp;    static Charset GB18030;
&nbsp;
&nbsp;    protected final byte[] bytes;
&nbsp;    protected final int length;
&nbsp;    protected final int end;
&nbsp;
&nbsp;    protected byte type;
&nbsp;    protected int strlen;
&nbsp;    protected byte strtype;
&nbsp;    protected int strBegin;
&nbsp;
&nbsp;    protected byte[] valueBytes;
<b class="fc">&nbsp;    protected final int cachedIndex = System.identityHashCode(Thread.currentThread()) &amp; (CACHE_SIZE - 1);</b>
&nbsp;
&nbsp;    protected final SymbolTable symbolTable;
<b class="fc">&nbsp;    protected long[] symbols = new long[32];</b>
&nbsp;
&nbsp;    JSONReaderJSONB(Context ctx, byte[] bytes, int off, int length) {
<b class="fc">&nbsp;        super(ctx);</b>
<b class="fc">&nbsp;        this.bytes = bytes;</b>
<b class="fc">&nbsp;        this.offset = off;</b>
<b class="fc">&nbsp;        this.length = length;</b>
<b class="fc">&nbsp;        this.end = off + length;</b>
<b class="fc">&nbsp;        this.symbolTable = ctx.symbolTable;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isJSONB() {
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getString() {
<b class="fc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            return symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
&nbsp;        Charset charset;
<b class="fc">&nbsp;        if (strtype == BC_STR_ASCII) {</b>
<b class="fc">&nbsp;            charset = StandardCharsets.US_ASCII;</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;                char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                    chars[i] = (char) bytes[strBegin + i];</b>
&nbsp;                }
<b class="fc">&nbsp;                return STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="nc">&nbsp;            } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, strBegin, chars, 0, strlen);</b>
<b class="nc">&nbsp;                return STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
&nbsp;            }
<b class="nc">&nbsp;            charset = StandardCharsets.US_ASCII;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
<b class="nc">&nbsp;        } else if (strtype == BC_SYMBOL) {</b>
<b class="nc">&nbsp;            int symbol = strlen;</b>
<b class="nc">&nbsp;            if (symbol &lt; 0) {</b>
<b class="nc">&nbsp;                return symbolTable.getName(-symbol);</b>
&nbsp;            }
<b class="nc">&nbsp;            int index = symbol * 2;</b>
&nbsp;//            return symbols[index];
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + JSONB.typeName(strtype));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + JSONB.typeName(strtype));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return new String(bytes, strBegin, strlen, charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int readLength() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type == BC_INT32) {</b>
<b class="fc">&nbsp;            int len = (bytes[offset++] &lt;&lt; 24)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 16)
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            if (len &gt; 1024 * 1024 * 256) {</b>
<b class="fc">&nbsp;                throw new JSONException(&quot;input length overflow&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return len;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;not support length type : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean isArray() {
<b class="fc">&nbsp;        if (offset &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte type = bytes[offset];</b>
<b class="fc">&nbsp;        return type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean isObject() {
<b class="fc">&nbsp;        return offset &lt; end &amp;&amp; bytes[offset] == BC_OBJECT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isNumber() {
<b class="fc">&nbsp;        byte type = bytes[offset];</b>
<b class="fc">&nbsp;        return type &gt;= BC_DOUBLE_LONG &amp;&amp; type &lt;= BC_INT32;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isString() {
<b class="fc">&nbsp;        return offset &lt; bytes.length</b>
&nbsp;                &amp;&amp; (type = bytes[offset]) &gt;= BC_STR_ASCII_FIX_MIN;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatch(char ch) {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfObjectStart() {
<b class="fc">&nbsp;        if (bytes[offset] != BC_OBJECT) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        offset++;</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean nextIfObjectEnd() {
<b class="fc">&nbsp;        if (bytes[offset] != BC_OBJECT_END) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        offset++;</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean nextIfEmptyString() {
<b class="fc">&nbsp;        if (bytes[offset] != BC_STR_ASCII_FIX_MIN) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        offset += 1;</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T read(Type type) {
<b class="fc">&nbsp;        boolean fieldBased = (context.features &amp; Feature.FieldBased.mask) != 0;</b>
<b class="fc">&nbsp;        ObjectReader objectReader = context.provider.getObjectReader(type, fieldBased);</b>
<b class="fc">&nbsp;        return (T) objectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T read(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        boolean fieldBased = (context.features &amp; Feature.FieldBased.mask) != 0;</b>
<b class="fc">&nbsp;        ObjectReader objectReader = context.provider.getObjectReader(type, fieldBased);</b>
<b class="fc">&nbsp;        return (T) objectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Map&lt;String, Object&gt; readObject() {
<b class="fc">&nbsp;        type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type == BC_NULL) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_OBJECT) {</b>
&nbsp;            Map map;
<b class="fc">&nbsp;            if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="fc">&nbsp;                if (JVM_VERSION == 8 &amp;&amp; bytes[offset] != BC_OBJECT_END) {</b>
<b class="fc">&nbsp;                    map = new HashMap(10);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    map = new HashMap();</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                if (JVM_VERSION == 8 &amp;&amp; bytes[offset] != BC_OBJECT_END) {</b>
<b class="fc">&nbsp;                    map = new JSONObject(10);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    map = new JSONObject();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            for (int i = 0; ; ++i) {</b>
<b class="fc">&nbsp;                type = bytes[offset];</b>
<b class="fc">&nbsp;                if (type == BC_OBJECT_END) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                String name = readFieldName();</b>
&nbsp;
<b class="fc">&nbsp;                if (offset &lt; bytes.length &amp;&amp; bytes[offset] == BC_REFERENCE) {</b>
<b class="fc">&nbsp;                    String reference = readReference();</b>
<b class="fc">&nbsp;                    if (&quot;..&quot;.equals(reference)) {</b>
<b class="fc">&nbsp;                        map.put(name, map);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        addResolveTask(map, name, JSONPath.of(reference));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                byte valueType = bytes[offset];</b>
&nbsp;                Object value;
<b class="fc">&nbsp;                if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="fc">&nbsp;                    value = readString();</b>
<b class="fc">&nbsp;                } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    value = (int) valueType;</b>
<b class="fc">&nbsp;                } else if (valueType == BC_TRUE) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    value = Boolean.TRUE;</b>
<b class="fc">&nbsp;                } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    value = Boolean.FALSE;</b>
<b class="fc">&nbsp;                } else if (valueType == BC_OBJECT) {</b>
<b class="fc">&nbsp;                    value = readObject();</b>
<b class="fc">&nbsp;                } else if (valueType == BC_INT64) {</b>
<b class="nc">&nbsp;                    offset++;</b>
<b class="nc">&nbsp;                    long int64Value =</b>
&nbsp;                            ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                    ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                    ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                    ((long) (bytes[offset]) &lt;&lt; 56);
<b class="nc">&nbsp;                    offset += 8;</b>
<b class="nc">&nbsp;                    value = int64Value;</b>
<b class="nc">&nbsp;                } else if (valueType &gt;= BC_ARRAY_FIX_MIN &amp;&amp; valueType &lt;= BC_ARRAY) {</b>
<b class="fc">&nbsp;                    offset++;</b>
&nbsp;                    int len;
<b class="fc">&nbsp;                    if (valueType == BC_ARRAY) {</b>
<b class="fc">&nbsp;                        byte itemType = bytes[offset];</b>
<b class="fc">&nbsp;                        if (itemType &gt;= BC_INT32_NUM_MIN &amp;&amp; itemType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                            offset++;</b>
<b class="nc">&nbsp;                            len = itemType;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            len = readLength();</b>
&nbsp;                        }
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        len = valueType - BC_ARRAY_FIX_MIN;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (len == 0) {</b>
<b class="fc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            value = new ArrayList&lt;&gt;();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                                value = context.arraySupplier.get();</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                value = new JSONArray();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        List list;
<b class="fc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                            list = new ArrayList(len);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            list = new JSONArray(len);</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        for (int j = 0; j &lt; len; ++j) {</b>
<b class="fc">&nbsp;                            if (isReference()) {</b>
<b class="fc">&nbsp;                                String reference = readReference();</b>
<b class="fc">&nbsp;                                if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                    list.add(list);</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    list.add(null);</b>
<b class="fc">&nbsp;                                    addResolveTask(list, j, JSONPath.of(reference));</b>
&nbsp;                                }
<b class="fc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            byte itemType = bytes[offset];</b>
&nbsp;                            Object item;
<b class="fc">&nbsp;                            if (itemType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; itemType &lt;= BC_STR_GB18030) {</b>
<b class="fc">&nbsp;                                item = readString();</b>
<b class="fc">&nbsp;                            } else if (itemType == BC_OBJECT) {</b>
<b class="fc">&nbsp;                                item = readObject();</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                item = readAny();</b>
&nbsp;                            }
<b class="fc">&nbsp;                            list.add(item);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        value = list;</b>
&nbsp;                    }
<b class="fc">&nbsp;                } else if (valueType &gt;= BC_INT32_BYTE_MIN &amp;&amp; valueType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    value = ((valueType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                } else if (valueType &gt;= BC_INT32_SHORT_MIN &amp;&amp; valueType &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    int int32Value = ((valueType - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    value = new Integer(int32Value);</b>
<b class="fc">&nbsp;                } else if (valueType == BC_INT32) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    int int32Value =</b>
&nbsp;                            ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                    offset += 4;</b>
<b class="fc">&nbsp;                    value = new Integer(int32Value);</b>
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    value = readAny();</b>
&nbsp;                }
<b class="fc">&nbsp;                map.put(name, value);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return map;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_TYPED_ANY) {</b>
<b class="nc">&nbsp;            ObjectReader objectReader = checkAutoType(Map.class, 0, 0);</b>
<b class="nc">&nbsp;            return (Map) objectReader.readObject(this, null, null, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;object not support input &quot; + error(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object readAny() {
<b class="fc">&nbsp;        if (offset &gt;= bytes.length) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;readAny overflow : &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                return null;</b>
&nbsp;            case BC_TRUE:
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case BC_FALSE:
<b class="fc">&nbsp;                return false;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                return (short) ((bytes[offset++] &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF));
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return new Integer(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return new Long(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return Long.valueOf(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="fc">&nbsp;                int len = readInt32Value();</b>
<b class="fc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="fc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="fc">&nbsp;                offset += len;</b>
<b class="fc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return Double.longBitsToDouble(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                return (double) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readLength();</b>
&nbsp;
<b class="fc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    if (valueBytes == null) {</b>
<b class="nc">&nbsp;                        valueBytes = JSONFactory.allocateByteArray(cachedIndex);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;                    if (valueBytes == null) {</b>
<b class="nc">&nbsp;                        valueBytes = new byte[minCapacity];</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                            valueBytes = new byte[minCapacity];</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;                    if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                        byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                        System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                        String str = STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        return str;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16: {
<b class="fc">&nbsp;                int strlen = readLength();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
&nbsp;
&nbsp;                String str;
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16BE: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
&nbsp;
&nbsp;                String str;
<b class="nc">&nbsp;                if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    str = new String(bytes, offset, strlen, StandardCharsets.UTF_16BE);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_STR_GB18030: {
<b class="fc">&nbsp;                if (GB18030 == null) {</b>
<b class="fc">&nbsp;                    GB18030 = Charset.forName(&quot;GB18030&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                int strlen = readLength();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, GB18030);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal;</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG: {
<b class="fc">&nbsp;                return BigDecimal.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_BINARY: {
<b class="fc">&nbsp;                int len = readLength();</b>
<b class="fc">&nbsp;                byte[] binary = Arrays.copyOfRange(this.bytes, offset, offset + len);</b>
<b class="fc">&nbsp;                offset += len;</b>
<b class="fc">&nbsp;                return binary;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return new Date(minutes * 60L * 1000L);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="fc">&nbsp;                long seconds =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return new Date(seconds * 1000);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="fc">&nbsp;                long millis =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return new Date(millis);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT_LONG: {
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_TYPED_ANY: {
<b class="fc">&nbsp;                long typeHash = readTypeHashCode();</b>
&nbsp;
<b class="fc">&nbsp;                if (context.autoTypeBeforeHandler != null) {</b>
<b class="fc">&nbsp;                    Class&lt;?&gt; filterClass = context.autoTypeBeforeHandler.apply(typeHash, null, context.features);</b>
&nbsp;
<b class="fc">&nbsp;                    if (filterClass == null) {</b>
<b class="fc">&nbsp;                        String typeName = getString();</b>
<b class="fc">&nbsp;                        filterClass = context.autoTypeBeforeHandler.apply(typeName, null, context.features);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (filterClass != null) {</b>
<b class="fc">&nbsp;                        ObjectReader autoTypeObjectReader = context.getObjectReader(filterClass);</b>
<b class="fc">&nbsp;                        return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                boolean supportAutoType = (context.features &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="fc">&nbsp;                if (!supportAutoType) {</b>
<b class="fc">&nbsp;                    if (isObject()) {</b>
<b class="fc">&nbsp;                        return readObject();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    throw new JSONException(&quot;auoType not support , offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                ObjectReader autoTypeObjectReader = context.getObjectReaderAutoType(typeHash);</b>
<b class="fc">&nbsp;                if (autoTypeObjectReader == null) {</b>
<b class="fc">&nbsp;                    String typeName = getString();</b>
<b class="fc">&nbsp;                    autoTypeObjectReader = context.getObjectReaderAutoType(typeName, null);</b>
&nbsp;
<b class="fc">&nbsp;                    if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                        throw new JSONException(&quot;auoType not support : &quot; + typeName + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0D;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                return 1D;</b>
&nbsp;            case BC_CHAR:
<b class="fc">&nbsp;                int intValue = readInt32Value();</b>
<b class="fc">&nbsp;                return (char) intValue;</b>
&nbsp;            case BC_OBJECT: {
<b class="fc">&nbsp;                Map map = null;</b>
<b class="fc">&nbsp;                boolean supportAutoType = (context.features &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="fc">&nbsp;                for (int i = 0; ; ++i) {</b>
<b class="fc">&nbsp;                    byte type = bytes[offset];</b>
<b class="fc">&nbsp;                    if (type == BC_OBJECT_END) {</b>
<b class="fc">&nbsp;                        offset++;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    Object name;
<b class="fc">&nbsp;                    if (supportAutoType &amp;&amp; i == 0 &amp;&amp; type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_GB18030) {</b>
<b class="fc">&nbsp;                        long hash = readFieldNameHashCode();</b>
&nbsp;
<b class="fc">&nbsp;                        if (hash == ObjectReader.HASH_TYPE &amp;&amp; supportAutoType) {</b>
<b class="fc">&nbsp;                            long typeHash = readValueHashCode();</b>
<b class="fc">&nbsp;                            ObjectReader autoTypeObjectReader = context.getObjectReaderAutoType(typeHash);</b>
<b class="fc">&nbsp;                            if (autoTypeObjectReader == null) {</b>
<b class="fc">&nbsp;                                String typeName = getString();</b>
<b class="fc">&nbsp;                                autoTypeObjectReader = context.getObjectReaderAutoType(typeName, null);</b>
&nbsp;
<b class="fc">&nbsp;                                if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                                    throw new JSONException(&quot;auotype not support : &quot; + typeName + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            typeRedirect = true;</b>
<b class="fc">&nbsp;                            return autoTypeObjectReader.readJSONBObject(this, null, null, 0);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        name = getFieldName();</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_SYMBOL) {</b>
<b class="fc">&nbsp;                            name = readFieldName();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            name = readAny();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (map == null) {</b>
<b class="fc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="fc">&nbsp;                            map = new HashMap();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            map = new JSONObject();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (isReference()) {</b>
<b class="nc">&nbsp;                        String reference = readReference();</b>
<b class="nc">&nbsp;                        if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                            map.put(name, map);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            addResolveTask(map, name, JSONPath.of(reference));</b>
<b class="nc">&nbsp;                            map.put(name, null);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    byte valueType = bytes[offset];</b>
&nbsp;                    Object value;
<b class="fc">&nbsp;                    if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="fc">&nbsp;                        value = readString();</b>
<b class="fc">&nbsp;                    } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                        offset++;</b>
<b class="fc">&nbsp;                        value = (int) valueType;</b>
<b class="fc">&nbsp;                    } else if (valueType == BC_TRUE) {</b>
<b class="fc">&nbsp;                        offset++;</b>
<b class="fc">&nbsp;                        value = Boolean.TRUE;</b>
<b class="fc">&nbsp;                    } else if (valueType == BC_FALSE) {</b>
<b class="fc">&nbsp;                        offset++;</b>
<b class="fc">&nbsp;                        value = Boolean.FALSE;</b>
<b class="fc">&nbsp;                    } else if (valueType == BC_OBJECT) {</b>
<b class="fc">&nbsp;                        value = readObject();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        value = readAny();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    map.put(name, value);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (map == null) {</b>
<b class="fc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="fc">&nbsp;                        map = new HashMap();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        map = new JSONObject();</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return map;</b>
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return (int) type;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return (long) ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return (long) (((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF));
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY) {</b>
<b class="fc">&nbsp;                    int len = type == BC_ARRAY</b>
<b class="fc">&nbsp;                            ? readLength()</b>
&nbsp;                            : type - BC_ARRAY_FIX_MIN;
&nbsp;
<b class="fc">&nbsp;                    if (len == 0) {</b>
<b class="fc">&nbsp;                        if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="fc">&nbsp;                            return new ArrayList&lt;&gt;();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                                return context.arraySupplier.get();</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return new JSONArray();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    List list;
<b class="fc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="fc">&nbsp;                        list = new ArrayList(len);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        list = new JSONArray(len);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    for (int i = 0; i &lt; len; ++i) {</b>
<b class="fc">&nbsp;                        if (isReference()) {</b>
<b class="fc">&nbsp;                            String reference = readReference();</b>
<b class="fc">&nbsp;                            if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                list.add(list);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                list.add(null);</b>
<b class="fc">&nbsp;                                addResolveTask(list, i, JSONPath.of(reference));</b>
&nbsp;                            }
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        Object item = readAny();</b>
<b class="fc">&nbsp;                        list.add(item);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return list;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII) {</b>
<b class="fc">&nbsp;                    strlen = type == BC_STR_ASCII</b>
<b class="fc">&nbsp;                            ? readLength()</b>
&nbsp;                            : type - BC_STR_ASCII_FIX_MIN;
&nbsp;
<b class="fc">&nbsp;                    if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;                        return symbolTable.getName(-strlen);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;                        char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                        for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                            chars[i] = (char) bytes[offset + i];</b>
&nbsp;                        }
<b class="fc">&nbsp;                        offset += strlen;</b>
&nbsp;
<b class="fc">&nbsp;                        String str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;                        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                            str = str.trim();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return str;</b>
<b class="nc">&nbsp;                    } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                        byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                        System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                        offset += strlen;</b>
<b class="nc">&nbsp;                        String str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
&nbsp;
<b class="nc">&nbsp;                        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                            str = str.trim();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return str;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                        str = str.trim();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return str;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                throw new JSONException(&quot;not support type : &quot; + error(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte getType() {
<b class="fc">&nbsp;        return bytes[offset];</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List readArray() {
<b class="fc">&nbsp;        int entryCnt = startArray();</b>
<b class="fc">&nbsp;        JSONArray array = new JSONArray(entryCnt);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="fc">&nbsp;            byte valueType = bytes[offset];</b>
&nbsp;            Object value;
<b class="fc">&nbsp;            if (valueType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; valueType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                value = readString();</b>
<b class="fc">&nbsp;            } else if (valueType &gt;= BC_INT32_NUM_MIN &amp;&amp; valueType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = (int) valueType;</b>
<b class="fc">&nbsp;            } else if (valueType == BC_TRUE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.TRUE;</b>
<b class="fc">&nbsp;            } else if (valueType == BC_FALSE) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = Boolean.FALSE;</b>
<b class="fc">&nbsp;            } else if (valueType == BC_OBJECT) {</b>
<b class="fc">&nbsp;                value = readObject();</b>
<b class="fc">&nbsp;            } else if (valueType == BC_INT64) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="nc">&nbsp;                offset += 8;</b>
<b class="nc">&nbsp;                value = int64Value;</b>
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_ARRAY_FIX_MIN &amp;&amp; valueType &lt;= BC_ARRAY) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                int len = valueType == BC_ARRAY</b>
<b class="nc">&nbsp;                        ? readLength()</b>
&nbsp;                        : valueType - BC_ARRAY_FIX_MIN;
&nbsp;
<b class="nc">&nbsp;                if (len == 0) {</b>
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        value = new ArrayList&lt;&gt;();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (context.arraySupplier != null) {</b>
<b class="nc">&nbsp;                            value = context.arraySupplier.get();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            value = new JSONArray();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    List list;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.UseNativeObject.mask) != 0) {</b>
<b class="nc">&nbsp;                        list = new ArrayList(len);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        list = new JSONArray(len);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    for (int j = 0; j &lt; len; ++j) {</b>
<b class="nc">&nbsp;                        if (isReference()) {</b>
<b class="nc">&nbsp;                            String reference = readReference();</b>
<b class="nc">&nbsp;                            if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                                list.add(list);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                list.add(null);</b>
<b class="nc">&nbsp;                                addResolveTask(list, j, JSONPath.of(reference));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        byte itemType = bytes[offset];</b>
&nbsp;                        Object item;
<b class="nc">&nbsp;                        if (itemType &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; itemType &lt;= BC_STR_GB18030) {</b>
<b class="nc">&nbsp;                            item = readString();</b>
<b class="nc">&nbsp;                        } else if (itemType == BC_OBJECT) {</b>
<b class="nc">&nbsp;                            item = readObject();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            item = readAny();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        list.add(item);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    value = list;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (valueType &gt;= BC_INT32_BYTE_MIN &amp;&amp; valueType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                value = ((valueType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            } else if (valueType &gt;= BC_INT32_SHORT_MIN &amp;&amp; valueType &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                int int32Value = ((valueType - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                        + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
<b class="nc">&nbsp;                value = new Integer(int32Value);</b>
<b class="nc">&nbsp;            } else if (valueType == BC_INT32) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                value = new Integer(int32Value);</b>
<b class="nc">&nbsp;            } else if (valueType == BC_REFERENCE) {</b>
<b class="fc">&nbsp;                String reference = readReference();</b>
<b class="fc">&nbsp;                if (&quot;..&quot;.equals(reference)) {</b>
<b class="nc">&nbsp;                    value = array;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    addResolveTask(array, i, JSONPath.of(reference));</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                value = readAny();</b>
&nbsp;            }
<b class="fc">&nbsp;            array.add(value);</b>
&nbsp;        }
<b class="fc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List readArray(Type itemType) {
<b class="fc">&nbsp;        if (nextIfNull()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int entryCnt = startArray();</b>
<b class="fc">&nbsp;        JSONArray array = new JSONArray(entryCnt);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; entryCnt; i++) {</b>
<b class="fc">&nbsp;            array.add(read(itemType));</b>
&nbsp;        }
<b class="fc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isReference() {
<b class="fc">&nbsp;        return offset &lt; bytes.length &amp;&amp; bytes[offset] == BC_REFERENCE;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readReference() {
<b class="fc">&nbsp;        if (bytes[offset] != BC_REFERENCE) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        offset++;</b>
<b class="fc">&nbsp;        if (isString()) {</b>
<b class="fc">&nbsp;            return readString();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;reference not support input &quot; + error(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ObjectReader checkAutoType(Class expectClass, long expectClassHash, long features) {
<b class="fc">&nbsp;        ObjectReader autoTypeObjectReader = null;</b>
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type == BC_TYPED_ANY) {</b>
<b class="fc">&nbsp;            offset++;</b>
&nbsp;
<b class="fc">&nbsp;            long typeHash = readTypeHashCode();</b>
&nbsp;
<b class="fc">&nbsp;            if (expectClassHash == typeHash) {</b>
<b class="fc">&nbsp;                ObjectReader objectReader = context.getObjectReader(expectClass);</b>
<b class="fc">&nbsp;                Class objectClass = objectReader.getObjectClass();</b>
<b class="fc">&nbsp;                if (objectClass != null &amp;&amp; objectClass == expectClass) {</b>
<b class="fc">&nbsp;                    context.getProvider().registerIfAbsent(typeHash, objectReader);</b>
<b class="fc">&nbsp;                    return objectReader;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (context.autoTypeBeforeHandler != null) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt; objectClass = context.autoTypeBeforeHandler.apply(typeHash, expectClass, features);</b>
<b class="fc">&nbsp;                if (objectClass == null) {</b>
<b class="fc">&nbsp;                    String typeName = getString();</b>
<b class="fc">&nbsp;                    objectClass = context.autoTypeBeforeHandler.apply(typeName, expectClass, features);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (objectClass != null) {</b>
<b class="fc">&nbsp;                    ObjectReader objectReader = context.getObjectReader(objectClass);</b>
<b class="fc">&nbsp;                    if (objectReader != null) {</b>
<b class="fc">&nbsp;                        return objectReader;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            boolean isSupportAutoType = ((context.features | features) &amp; Feature.SupportAutoType.mask) != 0;</b>
<b class="fc">&nbsp;            if (!isSupportAutoType) {</b>
<b class="fc">&nbsp;                String typeName = getString();</b>
<b class="fc">&nbsp;                throw new JSONException(&quot;autoType not support input &quot; + typeName);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            ObjectReaderProvider provider = context.provider;</b>
<b class="fc">&nbsp;            autoTypeObjectReader = provider.getObjectReader(typeHash);</b>
&nbsp;
<b class="fc">&nbsp;            if (autoTypeObjectReader != null) {</b>
<b class="fc">&nbsp;                Class objectClass = autoTypeObjectReader.getObjectClass();</b>
<b class="fc">&nbsp;                if (objectClass != null) {</b>
<b class="fc">&nbsp;                    ClassLoader objectClassLoader = objectClass.getClassLoader();</b>
<b class="fc">&nbsp;                    if (objectClassLoader != null) {</b>
<b class="fc">&nbsp;                        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</b>
<b class="fc">&nbsp;                        if (objectClassLoader != contextClassLoader) {</b>
<b class="fc">&nbsp;                            String typeName = getString();</b>
<b class="fc">&nbsp;                            Class contextClass = TypeUtils.getMapping(typeName);</b>
<b class="fc">&nbsp;                            if (contextClass == null) {</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    if (contextClassLoader == null) {</b>
<b class="fc">&nbsp;                                        contextClassLoader = JSON.class.getClassLoader();</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    contextClass = contextClassLoader.loadClass(typeName);</b>
<b class="nc">&nbsp;                                } catch (ClassNotFoundException ignored) {</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (contextClass != null &amp;&amp; !objectClass.equals(contextClass)) {</b>
<b class="fc">&nbsp;                                autoTypeObjectReader = getObjectReader(contextClass);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (autoTypeObjectReader == null) {</b>
<b class="fc">&nbsp;                String typeName = getString();</b>
<b class="fc">&nbsp;                autoTypeObjectReader = provider.getObjectReader(typeName, expectClass, context.features | features);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (autoTypeObjectReader == null) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;auotype not support : &quot; + getString());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            type = bytes[offset];</b>
&nbsp;        }
<b class="fc">&nbsp;        return autoTypeObjectReader;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int startArray() {
<b class="fc">&nbsp;        type = bytes[offset++];</b>
&nbsp;
<b class="fc">&nbsp;        if (type == BC_NULL) {</b>
<b class="fc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY_FIX_MAX) {</b>
<b class="fc">&nbsp;            ch = (char) -type;</b>
<b class="fc">&nbsp;            return type - BC_ARRAY_FIX_MIN;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type == BC_BINARY) {</b>
<b class="nc">&nbsp;            return readInt32Value();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type != BC_ARRAY) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;array not support input &quot; + error(type));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return readInt32Value();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String error(byte type) {
<b class="fc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
&nbsp;
<b class="fc">&nbsp;        buf.append(typeName(type));</b>
<b class="fc">&nbsp;        if (isString()) {</b>
<b class="nc">&nbsp;            int mark = offset;</b>
<b class="nc">&nbsp;            offset--;</b>
&nbsp;
<b class="nc">&nbsp;            String str = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                str = readString();</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (str != null) {</b>
<b class="nc">&nbsp;                buf.append(&#39; &#39;);</b>
<b class="nc">&nbsp;                buf.append(str);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            offset = mark;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        buf.append(&quot;, offset &quot;);</b>
<b class="fc">&nbsp;        buf.append(offset);</b>
<b class="fc">&nbsp;        buf.append(&#39;/&#39;);</b>
<b class="fc">&nbsp;        buf.append(bytes.length);</b>
&nbsp;
<b class="fc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final void next() {
<b class="fc">&nbsp;        offset++;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readFieldNameHashCode() {
<b class="fc">&nbsp;        strtype = bytes[offset++];</b>
<b class="fc">&nbsp;        boolean typeSymbol = strtype == BC_SYMBOL;</b>
<b class="fc">&nbsp;        if (typeSymbol) {</b>
<b class="fc">&nbsp;            strtype = bytes[offset];</b>
<b class="fc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
&nbsp;                int symbol;
<b class="fc">&nbsp;                if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    symbol = strtype;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    symbol = readInt32Value();</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (symbol &lt; 0) {</b>
<b class="fc">&nbsp;                    return symbolTable.getHashCode(-symbol);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                int index = symbol * 2;</b>
<b class="fc">&nbsp;                long strInfo = symbols[index + 1];</b>
<b class="fc">&nbsp;                this.strtype = (byte) strInfo;</b>
<b class="fc">&nbsp;                strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="fc">&nbsp;                strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="fc">&nbsp;                return symbols[index];</b>
&nbsp;            }
<b class="fc">&nbsp;            offset++;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        strBegin = offset;</b>
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_ASCII || strtype == BC_STR_UTF8) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            StringBuffer message = new StringBuffer()</b>
<b class="nc">&nbsp;                    .append(&quot;fieldName not support input type &quot;)</b>
<b class="nc">&nbsp;                    .append(typeName(strtype));</b>
<b class="nc">&nbsp;            if (strtype == BC_REFERENCE) {</b>
<b class="nc">&nbsp;                message.append(&quot; &quot;)</b>
<b class="nc">&nbsp;                        .append(readString());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            message.append(&quot;, offset &quot;)</b>
<b class="nc">&nbsp;                    .append(offset);</b>
<b class="nc">&nbsp;            throw new JSONException(message.toString());</b>
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            long nameValue = 0;</b>
<b class="fc">&nbsp;            if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 8) {</b>
<b class="nc">&nbsp;                switch (strlen) {</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        nameValue = bytes[offset];</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        nameValue = (bytes[offset + 1] &lt;&lt; 8)</b>
&nbsp;                                + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        nameValue = (bytes[offset + 2] &lt;&lt; 16)</b>
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        nameValue = (bytes[offset + 3] &lt;&lt; 24)</b>
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFF);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 4]) &lt;&lt; 32)</b>
&nbsp;                                + (((long) bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + (((long) bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + (((long) bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 5]) &lt;&lt; 40)</b>
&nbsp;                                + (((long) bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + (((long) bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + (((long) bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + (((long) bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 6]) &lt;&lt; 48)</b>
&nbsp;                                + (((long) bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + (((long) bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + (((long) bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + (((long) bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + (((long) bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        nameValue = (((long) bytes[offset + 7]) &lt;&lt; 56)</b>
&nbsp;                                + (((long) bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + (((long) bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + (((long) bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + (((long) bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + (((long) bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + (((long) bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (nameValue != 0) {</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                hashCode = nameValue;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                    byte c = bytes[offset++];</b>
<b class="fc">&nbsp;                    hashCode ^= c;</b>
<b class="fc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (typeSymbol) {</b>
&nbsp;            int symbol;
<b class="fc">&nbsp;            if ((type = bytes[offset]) &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                symbol = type;</b>
<b class="fc">&nbsp;                offset++;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                symbol = readInt32Value();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
&nbsp;
<b class="fc">&nbsp;            int minCapacity = symbol * 2 + 2;</b>
<b class="fc">&nbsp;            if (symbols.length &lt; minCapacity) {</b>
<b class="nc">&nbsp;                symbols = Arrays.copyOf(symbols, minCapacity + 16);</b>
&nbsp;            }
<b class="fc">&nbsp;            symbols[symbol * 2] = hashCode;</b>
<b class="fc">&nbsp;            symbols[symbol * 2 + 1] = strInfo;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isInt() {
<b class="fc">&nbsp;        int type = bytes[offset];</b>
<b class="fc">&nbsp;        return (type &gt;= BC_BIGINT_LONG &amp;&amp; type &lt;= BC_INT32)</b>
&nbsp;                || type == BC_TIMESTAMP_SECONDS
&nbsp;                || type == BC_TIMESTAMP_MINUTES
&nbsp;                || type == BC_TIMESTAMP_MILLIS;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isNull() {
<b class="fc">&nbsp;        return bytes[offset] == BC_NULL;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Date readNullOrNewDate() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfNull() {
<b class="fc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void readNull() {
<b class="fc">&nbsp;        type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type != BC_NULL) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;null not match, &quot; + type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean readIfNull() {
<b class="fc">&nbsp;        if (bytes[offset] == BC_NULL) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readTypeHashCode() {
<b class="fc">&nbsp;        strtype = bytes[offset];</b>
&nbsp;
<b class="fc">&nbsp;        if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
&nbsp;            int typeIndex;
<b class="fc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                offset++;</b>
<b class="fc">&nbsp;                typeIndex = strtype;</b>
<b class="nc">&nbsp;            } else if (strtype &gt;= BC_INT32_BYTE_MIN &amp;&amp; strtype &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="nc">&nbsp;                offset++;</b>
<b class="nc">&nbsp;                return ((strtype - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
&nbsp;            } else {
<b class="nc">&nbsp;                typeIndex = readInt32Value();</b>
&nbsp;            }
&nbsp;
&nbsp;            long refTypeHash;
<b class="fc">&nbsp;            if (typeIndex &lt; 0) {</b>
<b class="nc">&nbsp;                strlen = strtype;</b>
<b class="nc">&nbsp;                refTypeHash = symbolTable.getHashCode(-typeIndex);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                refTypeHash = symbols[typeIndex * 2];</b>
<b class="fc">&nbsp;                if (refTypeHash == 0) {</b>
<b class="fc">&nbsp;                    long strInfo = symbols[typeIndex * 2 + 1];</b>
<b class="fc">&nbsp;                    strtype = (byte) strInfo;</b>
<b class="fc">&nbsp;                    strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="fc">&nbsp;                    strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="fc">&nbsp;                    refTypeHash = Fnv.hashCode64(getString());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (refTypeHash == -1) {</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;type ref not found : &quot; + typeIndex);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return refTypeHash;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset++;</b>
<b class="fc">&nbsp;        strBegin = offset;</b>
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;string value not support input &quot; + typeName(type)</b>
&nbsp;                    + &quot; offset &quot; + offset + &quot;/&quot; + bytes.length);
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="nc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            int end = offset + strlen;</b>
<b class="nc">&nbsp;            for (; offset &lt; end; ) {</b>
<b class="nc">&nbsp;                int c = bytes[offset];</b>
&nbsp;
<b class="nc">&nbsp;                if (c &gt;= 0) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    c &amp;= 0xFF;</b>
<b class="nc">&nbsp;                    switch (c &gt;&gt; 4) {</b>
&nbsp;                        case 12:
&nbsp;                        case 13: {
&nbsp;                            /* 110x xxxx   10xx xxxx*/
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            if ((c2 &amp; 0xC0) != 0x80) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x1F) &lt;&lt; 6)</b>
&nbsp;                                    | (c2 &amp; 0x3F));
<b class="nc">&nbsp;                            offset += 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        case 14: {
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            int c3 = bytes[offset + 2];</b>
<b class="nc">&nbsp;                            if (((c2 &amp; 0xC0) != 0x80) || ((c3 &amp; 0xC0) != 0x80)) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x0F) &lt;&lt; 12) |</b>
&nbsp;                                    ((c2 &amp; 0x3F) &lt;&lt; 6) |
&nbsp;                                    ((c3 &amp; 0x3F) &lt;&lt; 0));
<b class="nc">&nbsp;                            offset += 3;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        default:
&nbsp;                            /* 10xx xxxx,  1111 xxxx */
<b class="nc">&nbsp;                            throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                hashCode ^= c;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (strtype == BC_STR_UTF16 || strtype == BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="nc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                hashCode ^= ch;</b>
<b class="nc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            long nameValue = 0;</b>
<b class="fc">&nbsp;            if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 8) {</b>
<b class="nc">&nbsp;                for (int i = 0, start = offset; i &lt; strlen; offset++, i++) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset];</b>
<b class="nc">&nbsp;                    if (c &lt; 0 || (c == 0 &amp;&amp; bytes[start] == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        offset = start;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    switch (i) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (nameValue != 0) {</b>
<b class="nc">&nbsp;                hashCode = nameValue;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                    byte c = bytes[offset++];</b>
<b class="fc">&nbsp;                    hashCode ^= c;</b>
<b class="fc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int symbol;
<b class="fc">&nbsp;        if ((type = bytes[offset]) &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            symbol = type;</b>
<b class="fc">&nbsp;            offset++;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            symbol = readInt32Value();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int minCapacity = symbol * 2 + 2;</b>
<b class="fc">&nbsp;        if (symbols.length &lt; minCapacity) {</b>
<b class="fc">&nbsp;            symbols = Arrays.copyOf(symbols, symbols.length + 16);</b>
&nbsp;        }
<b class="fc">&nbsp;        long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
<b class="fc">&nbsp;        symbols[symbol * 2 + 1] = strInfo;</b>
&nbsp;
<b class="fc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readValueHashCode() {
<b class="fc">&nbsp;        strtype = bytes[offset];</b>
&nbsp;
<b class="fc">&nbsp;        offset++;</b>
<b class="fc">&nbsp;        strBegin = offset;</b>
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;string value not support input &quot; + typeName(type)</b>
&nbsp;                    + &quot; offset &quot; + offset + &quot;/&quot; + bytes.length);
&nbsp;        }
&nbsp;
&nbsp;        long hashCode;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="fc">&nbsp;            hashCode = symbolTable.getHashCode(-strlen);</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="fc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;            int end = offset + strlen;</b>
<b class="fc">&nbsp;            for (; offset &lt; end; ) {</b>
<b class="fc">&nbsp;                int c = bytes[offset];</b>
&nbsp;
<b class="fc">&nbsp;                if (c &gt;= 0) {</b>
<b class="fc">&nbsp;                    offset++;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    c &amp;= 0xFF;</b>
<b class="fc">&nbsp;                    switch (c &gt;&gt; 4) {</b>
&nbsp;                        case 12:
&nbsp;                        case 13: {
&nbsp;                            /* 110x xxxx   10xx xxxx*/
<b class="nc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                            if ((c2 &amp; 0xC0) != 0x80) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            c = (char) (((c &amp; 0x1F) &lt;&lt; 6)</b>
&nbsp;                                    | (c2 &amp; 0x3F));
<b class="nc">&nbsp;                            offset += 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        case 14: {
<b class="fc">&nbsp;                            int c2 = bytes[offset + 1];</b>
<b class="fc">&nbsp;                            int c3 = bytes[offset + 2];</b>
<b class="fc">&nbsp;                            if (((c2 &amp; 0xC0) != 0x80) || ((c3 &amp; 0xC0) != 0x80)) {</b>
<b class="nc">&nbsp;                                throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            c = (char) (((c &amp; 0x0F) &lt;&lt; 12) |</b>
&nbsp;                                    ((c2 &amp; 0x3F) &lt;&lt; 6) |
&nbsp;                                    ((c3 &amp; 0x3F) &lt;&lt; 0));
<b class="fc">&nbsp;                            offset += 3;</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        default:
&nbsp;                            /* 10xx xxxx,  1111 xxxx */
<b class="nc">&nbsp;                            throw new JSONException(&quot;malformed input around byte &quot; + offset);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                hashCode ^= c;</b>
<b class="fc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="fc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;            if (bytes[offset] == (byte) 0xFE</b>
&nbsp;                    &amp;&amp; bytes[offset + 1] == (byte) 0xFF
&nbsp;            ) {
<b class="fc">&nbsp;                if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                    long nameValue = 0;</b>
<b class="nc">&nbsp;                    for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                        byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                        byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                        char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                        if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                            nameValue = 0;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        byte c = (byte) ch;</b>
<b class="nc">&nbsp;                        switch ((i - 2) &gt;&gt; 1) {</b>
&nbsp;                            case 0:
<b class="nc">&nbsp;                                nameValue = c;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 1:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 2:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 3:
<b class="nc">&nbsp;                                nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 4:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 5:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 6:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 7:
<b class="nc">&nbsp;                                nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            default:
&nbsp;                                break;
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (nameValue != 0) {</b>
<b class="nc">&nbsp;                        return nameValue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="fc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="fc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="fc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="fc">&nbsp;                    hashCode ^= ch;</b>
<b class="fc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (bytes[offset] == (byte) 0xFF</b>
&nbsp;                    &amp;&amp; bytes[offset + 1] == (byte) 0xFE
&nbsp;            ) {
<b class="nc">&nbsp;                for (int i = 2; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                    hashCode ^= ch;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="nc">&nbsp;                    hashCode ^= ch;</b>
<b class="nc">&nbsp;                    hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="fc">&nbsp;            if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                    if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    byte c = (byte) ch;</b>
<b class="nc">&nbsp;                    switch (i &gt;&gt; 1) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="fc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="fc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="fc">&nbsp;                char ch = (char) ((c1 &amp; 0xff) | ((c0 &amp; 0xff) &lt;&lt; 8));</b>
<b class="fc">&nbsp;                hashCode ^= ch;</b>
<b class="fc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="fc">&nbsp;            if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 16) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="nc">&nbsp;                    byte c0 = bytes[offset + i];</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + i + 1];</b>
<b class="nc">&nbsp;                    char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
&nbsp;
<b class="nc">&nbsp;                    if (ch &gt; 0x7F || (i == 0 &amp;&amp; ch == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    byte c = (byte) ch;</b>
<b class="nc">&nbsp;                    switch (i &gt;&gt; 1) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; strlen; i += 2) {</b>
<b class="fc">&nbsp;                byte c0 = bytes[offset + i];</b>
<b class="fc">&nbsp;                byte c1 = bytes[offset + i + 1];</b>
<b class="fc">&nbsp;                char ch = (char) ((c0 &amp; 0xff) | ((c1 &amp; 0xff) &lt;&lt; 8));</b>
<b class="fc">&nbsp;                hashCode ^= ch;</b>
<b class="fc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            if (MIXED_HASH_ALGORITHM &amp;&amp; strlen &lt;= 8) {</b>
<b class="nc">&nbsp;                long nameValue = 0;</b>
<b class="nc">&nbsp;                for (int i = 0, start = offset; i &lt; strlen; offset++, i++) {</b>
<b class="nc">&nbsp;                    byte c = bytes[offset];</b>
<b class="nc">&nbsp;                    if (c &lt; 0 || (c == 0 &amp;&amp; bytes[start] == 0)) {</b>
<b class="nc">&nbsp;                        nameValue = 0;</b>
<b class="nc">&nbsp;                        offset = start;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    switch (i) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            nameValue = c;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (nameValue != 0) {</b>
<b class="nc">&nbsp;                    return nameValue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                byte c = bytes[offset++];</b>
<b class="fc">&nbsp;                hashCode ^= c;</b>
<b class="fc">&nbsp;                hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getNameHashCodeLCase() {
<b class="fc">&nbsp;        int offset = strBegin;</b>
&nbsp;
<b class="fc">&nbsp;        if (MIXED_HASH_ALGORITHM) {</b>
<b class="nc">&nbsp;            long nameValue = 0;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; strlen; offset++) {</b>
<b class="nc">&nbsp;                byte c = bytes[offset];</b>
<b class="nc">&nbsp;                if (c &lt; 0 || i &gt;= 8 || (i == 0 &amp;&amp; bytes[strBegin] == 0)) {</b>
<b class="nc">&nbsp;                    offset = strBegin;</b>
<b class="nc">&nbsp;                    nameValue = 0;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (c == &#39;_&#39; || c == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                    byte c1 = bytes[offset + 1];</b>
<b class="nc">&nbsp;                    if (c1 != c) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {</b>
<b class="nc">&nbsp;                    c += 32;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                switch (i) {</b>
&nbsp;                    case 0:
<b class="nc">&nbsp;                        nameValue = c;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        nameValue = ((c) &lt;&lt; 8) + (nameValue &amp; 0xFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        nameValue = ((c) &lt;&lt; 16) + (nameValue &amp; 0xFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        nameValue = ((c) &lt;&lt; 24) + (nameValue &amp; 0xFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        nameValue = (((long) c) &lt;&lt; 32) + (nameValue &amp; 0xFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        nameValue = (((long) c) &lt;&lt; 40L) + (nameValue &amp; 0xFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        nameValue = (((long) c) &lt;&lt; 48L) + (nameValue &amp; 0xFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        nameValue = (((long) c) &lt;&lt; 56L) + (nameValue &amp; 0xFFFFFFFFFFFFFFL);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (nameValue != 0) {</b>
<b class="nc">&nbsp;                return nameValue;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        long hashCode = Fnv.MAGIC_HASH_CODE;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;            byte c = bytes[offset++];</b>
<b class="fc">&nbsp;            if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {</b>
<b class="fc">&nbsp;                c = (byte) (c + 32);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (c == &#39;_&#39; || c == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            hashCode ^= c;</b>
<b class="fc">&nbsp;            hashCode *= Fnv.MAGIC_PRIME;</b>
&nbsp;        }
<b class="fc">&nbsp;        return hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void skipValue() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
&nbsp;            case BC_ARRAY_FIX_0:
&nbsp;            case BC_STR_ASCII_FIX_0:
&nbsp;            case BC_FALSE:
&nbsp;            case BC_TRUE:
&nbsp;                return;
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                offset++;</b>
&nbsp;                return;
&nbsp;            case BC_INT16:
<b class="nc">&nbsp;                offset += 2;</b>
&nbsp;                return;
&nbsp;            case BC_INT32:
&nbsp;            case BC_TIMESTAMP_SECONDS:
&nbsp;            case BC_TIMESTAMP_MINUTES:
&nbsp;            case BC_FLOAT:
<b class="fc">&nbsp;                offset += 4;</b>
&nbsp;                return;
&nbsp;            case BC_FLOAT_INT:
<b class="fc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS:
&nbsp;            case BC_DOUBLE:
<b class="fc">&nbsp;                offset += 8;</b>
&nbsp;                return;
&nbsp;            case BC_DOUBLE_LONG:
<b class="fc">&nbsp;                readInt64Value();</b>
&nbsp;                return;
&nbsp;            case BC_DECIMAL:
&nbsp;                // TODO skip big decimal
<b class="fc">&nbsp;                readInt32Value();</b>
<b class="fc">&nbsp;                readBigInteger();</b>
&nbsp;                return;
&nbsp;            case BC_DECIMAL_LONG:
<b class="nc">&nbsp;                readInt64Value();</b>
&nbsp;                return;
&nbsp;            case BC_LOCAL_TIME:
<b class="nc">&nbsp;                offset += 3;</b>
<b class="nc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_LOCAL_DATETIME:
<b class="fc">&nbsp;                offset += 7;</b>
<b class="fc">&nbsp;                readInt32Value(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_TIMESTAMP_WITH_TIMEZONE:
<b class="fc">&nbsp;                offset += 7;</b>
<b class="fc">&nbsp;                readInt32Value(); // nano</b>
<b class="fc">&nbsp;                readString(); // skip</b>
&nbsp;                return;
&nbsp;            case BC_BINARY:
<b class="fc">&nbsp;                int byteslen = readInt32Value();</b>
<b class="fc">&nbsp;                offset += byteslen;</b>
&nbsp;                return;
&nbsp;            case BC_STR_ASCII:
&nbsp;            case BC_STR_UTF8:
&nbsp;            case BC_STR_UTF16:
&nbsp;            case BC_STR_UTF16LE:
&nbsp;            case BC_STR_UTF16BE:
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                offset += strlen;</b>
&nbsp;                return;
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                readTypeHashCode();</b>
<b class="nc">&nbsp;                skipValue();</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            case BC_OBJECT: {
<b class="fc">&nbsp;                for (int i = 0; ; ++i) {</b>
<b class="fc">&nbsp;                    if (bytes[offset] == BC_OBJECT_END) {</b>
<b class="fc">&nbsp;                        offset++;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    skipName();</b>
<b class="fc">&nbsp;                    skipValue();</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
&nbsp;            case BC_REFERENCE: {
<b class="nc">&nbsp;                if (isString()) {</b>
<b class="nc">&nbsp;                    skipName();</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                throw new JSONException(&quot;skip not support type &quot; + typeName(type));</b>
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    offset += (type - BC_STR_ASCII_FIX_MIN);</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_ARRAY_FIX_MIN &amp;&amp; type &lt;= BC_ARRAY) {</b>
&nbsp;                    int itemCnt;
<b class="fc">&nbsp;                    if (type == BC_ARRAY) {</b>
<b class="fc">&nbsp;                        itemCnt = readInt32Value();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        itemCnt = type - BC_ARRAY_FIX_MIN;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (int i = 0; i &lt; itemCnt; ++i) {</b>
<b class="fc">&nbsp;                        skipValue();</b>
&nbsp;                    }
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                throw new JSONException(&quot;skip not support type &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean skipName() {
<b class="fc">&nbsp;        strtype = bytes[offset++];</b>
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            offset += (strtype - BC_STR_ASCII_FIX_MIN);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype == BC_STR_ASCII</b>
&nbsp;                || strtype == BC_STR_UTF8
&nbsp;                || strtype == BC_STR_UTF16
&nbsp;                || strtype == BC_STR_UTF16LE
&nbsp;                || strtype == BC_STR_UTF16BE
&nbsp;        ) {
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            offset += strlen;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_UTF16BE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strtype == BC_SYMBOL) {</b>
<b class="nc">&nbsp;            int type = bytes[offset];</b>
<b class="nc">&nbsp;            if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32) {</b>
<b class="nc">&nbsp;                readInt32Value();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String str = readString();</b>
<b class="nc">&nbsp;            readInt32Value();</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new JSONException(&quot;name not support input : &quot; + typeName(strtype));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readFieldName() {
<b class="fc">&nbsp;        strtype = bytes[offset];</b>
<b class="fc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        offset++;</b>
&nbsp;
<b class="fc">&nbsp;        boolean typeSymbol = strtype == BC_SYMBOL;</b>
<b class="fc">&nbsp;        if (typeSymbol) {</b>
<b class="fc">&nbsp;            strtype = bytes[offset];</b>
<b class="fc">&nbsp;            if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32) {</b>
<b class="fc">&nbsp;                int symbol = readInt32Value();</b>
<b class="fc">&nbsp;                if (symbol &lt; 0) {</b>
<b class="fc">&nbsp;                    return symbolTable.getName(-symbol);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int index = symbol * 2 + 1;</b>
<b class="nc">&nbsp;                long strInfo = symbols[index];</b>
<b class="nc">&nbsp;                strtype = (byte) strInfo;</b>
<b class="nc">&nbsp;                strlen = ((int) strInfo) &gt;&gt; 8;</b>
<b class="nc">&nbsp;                strBegin = (int) (strInfo &gt;&gt; 32);</b>
<b class="nc">&nbsp;                return getString();</b>
&nbsp;            }
<b class="nc">&nbsp;            offset++;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        strBegin = offset;</b>
<b class="fc">&nbsp;        Charset charset = null;</b>
<b class="fc">&nbsp;        String str = null;</b>
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII) {</b>
<b class="fc">&nbsp;            long nameValue0 = -1, nameValue1 = -1;</b>
&nbsp;
<b class="fc">&nbsp;            if (strtype == BC_STR_ASCII) {</b>
<b class="fc">&nbsp;                strlen = readLength();</b>
<b class="fc">&nbsp;                strBegin = offset;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;
<b class="fc">&nbsp;                switch (strlen) {</b>
&nbsp;                    case 1:
<b class="fc">&nbsp;                        nameValue0 = bytes[offset];</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 1] &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 3:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 2] &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 3] &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 4]) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 5]) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 0] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 7:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 6]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 8:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 7]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 9:
<b class="fc">&nbsp;                        nameValue0 = bytes[offset + 0];</b>
<b class="fc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 8]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 7]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 1] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 10:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 1] &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 9]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 2] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 2] &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 10]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 3] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 12:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (bytes[offset + 3] &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 11]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 10] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 4] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 13:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 4]) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 12]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 11] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 10] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 5] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 14:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 5]) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 13]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 12] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 11] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 10] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 7] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 6] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 15:
<b class="fc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 6]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="fc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 14]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 13] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 12] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 11] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 10] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 8] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 7] &amp; 0xFFL);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 16:
<b class="nc">&nbsp;                        nameValue0</b>
&nbsp;                                = (((long) bytes[offset + 7]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 6]) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset] &amp; 0xFFL);
<b class="nc">&nbsp;                        nameValue1</b>
&nbsp;                                = (((long) bytes[offset + 15]) &lt;&lt; 56)
&nbsp;                                + ((bytes[offset + 14] &amp; 0xFFL) &lt;&lt; 48)
&nbsp;                                + ((bytes[offset + 13] &amp; 0xFFL) &lt;&lt; 40)
&nbsp;                                + ((bytes[offset + 12] &amp; 0xFFL) &lt;&lt; 32)
&nbsp;                                + ((bytes[offset + 11] &amp; 0xFFL) &lt;&lt; 24)
&nbsp;                                + ((bytes[offset + 10] &amp; 0xFFL) &lt;&lt; 16)
&nbsp;                                + ((bytes[offset + 9] &amp; 0xFFL) &lt;&lt; 8)
&nbsp;                                + (bytes[offset + 8] &amp; 0xFFL);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (nameValue0 != -1) {</b>
<b class="fc">&nbsp;                if (nameValue1 != -1) {</b>
<b class="fc">&nbsp;                    int indexMask = ((int) nameValue1) &amp; (NAME_CACHE2.length - 1);</b>
<b class="fc">&nbsp;                    JSONFactory.NameCacheEntry2 entry = NAME_CACHE2[indexMask];</b>
<b class="fc">&nbsp;                    if (entry == null) {</b>
&nbsp;                        String name;
<b class="fc">&nbsp;                        if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;                            char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                                chars[i] = (char) bytes[offset + i];</b>
&nbsp;                            }
<b class="fc">&nbsp;                            name = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            name = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        NAME_CACHE2[indexMask] = new JSONFactory.NameCacheEntry2(name, nameValue0, nameValue1);</b>
<b class="fc">&nbsp;                        offset += strlen;</b>
<b class="fc">&nbsp;                        return name;</b>
<b class="fc">&nbsp;                    } else if (entry.value0 == nameValue0 &amp;&amp; entry.value1 == nameValue1) {</b>
<b class="fc">&nbsp;                        offset += strlen;</b>
<b class="fc">&nbsp;                        return entry.name;</b>
&nbsp;                    }
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    int indexMask = ((int) nameValue0) &amp; (NAME_CACHE.length - 1);</b>
<b class="fc">&nbsp;                    JSONFactory.NameCacheEntry entry = NAME_CACHE[indexMask];</b>
<b class="fc">&nbsp;                    if (entry == null) {</b>
&nbsp;                        String name;
<b class="fc">&nbsp;                        if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;                            char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                                chars[i] = (char) bytes[offset + i];</b>
&nbsp;                            }
<b class="fc">&nbsp;                            name = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            name = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        NAME_CACHE[indexMask] = new JSONFactory.NameCacheEntry(name, nameValue0);</b>
<b class="fc">&nbsp;                        offset += strlen;</b>
<b class="fc">&nbsp;                        return name;</b>
<b class="fc">&nbsp;                    } else if (entry.value == nameValue0) {</b>
<b class="fc">&nbsp;                        offset += strlen;</b>
<b class="fc">&nbsp;                        return entry.name;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK8 != null &amp;&amp; strlen &gt;= 0) {</b>
<b class="fc">&nbsp;                char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                    chars[i] = (char) bytes[offset + i];</b>
&nbsp;                }
<b class="fc">&nbsp;                offset += strlen;</b>
&nbsp;
<b class="fc">&nbsp;                str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;            } else if (STRING_CREATOR_JDK11 != null &amp;&amp; strlen &gt;= 0) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;            }
<b class="fc">&nbsp;            charset = StandardCharsets.US_ASCII;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = JSONFactory.allocateByteArray(cachedIndex);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = new byte[minCapacity];</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                        valueBytes = new byte[minCapacity];</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;                if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                    byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                    System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                    str = (String) STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="fc">&nbsp;            str = symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (str == null) {</b>
<b class="fc">&nbsp;            str = new String(bytes, offset, strlen, charset);</b>
<b class="fc">&nbsp;            offset += strlen;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (typeSymbol) {</b>
<b class="nc">&nbsp;            int symbol = readInt32Value();</b>
&nbsp;
<b class="nc">&nbsp;            int minCapacity = symbol * 2 + 2;</b>
<b class="nc">&nbsp;            if (symbols.length &lt; minCapacity) {</b>
<b class="nc">&nbsp;                symbols = Arrays.copyOf(symbols, symbols.length + 16);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            long strInfo = ((long) strBegin &lt;&lt; 32) + ((long) strlen &lt;&lt; 8) + strtype;</b>
<b class="nc">&nbsp;            symbols[symbol * 2 + 1] = strInfo;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getFieldName() {
<b class="fc">&nbsp;        return getString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readString() {
<b class="fc">&nbsp;        strtype = bytes[offset++];</b>
<b class="fc">&nbsp;        if (strtype == BC_NULL) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        strBegin = offset;</b>
&nbsp;        Charset charset;
&nbsp;        String str;
<b class="fc">&nbsp;        if (strtype &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; strtype &lt;= BC_STR_ASCII) {</b>
<b class="fc">&nbsp;            if (strtype == BC_STR_ASCII) {</b>
<b class="fc">&nbsp;                byte strType = bytes[offset];</b>
<b class="fc">&nbsp;                if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    strlen = strType;</b>
<b class="fc">&nbsp;                } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                } else {
<b class="fc">&nbsp;                    strlen = readLength();</b>
&nbsp;                }
<b class="fc">&nbsp;                strBegin = offset;</b>
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                strlen = strtype - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (strlen &gt;= 0) {</b>
<b class="fc">&nbsp;                if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;                    char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;                    for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                        chars[i] = (char) bytes[offset + i];</b>
&nbsp;                    }
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;                    if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="fc">&nbsp;                        str = str.trim();</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    return str;</b>
<b class="nc">&nbsp;                } else if (STRING_CREATOR_JDK11 != null) {</b>
<b class="nc">&nbsp;                    byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                    System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(chars, LATIN1);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                        str = str.trim();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return str;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.US_ASCII;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF8) {</b>
<b class="fc">&nbsp;            byte strType = bytes[offset];</b>
<b class="fc">&nbsp;            if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                offset++;</b>
<b class="fc">&nbsp;                strlen = strType;</b>
<b class="fc">&nbsp;            } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                offset++;</b>
<b class="fc">&nbsp;                strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
&nbsp;            } else {
<b class="fc">&nbsp;                strlen = readLength();</b>
&nbsp;            }
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = JSONFactory.allocateByteArray(cachedIndex);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int minCapacity = strlen &lt;&lt; 1;</b>
<b class="nc">&nbsp;                if (valueBytes == null) {</b>
<b class="nc">&nbsp;                    valueBytes = new byte[minCapacity];</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (minCapacity &gt; valueBytes.length) {</b>
<b class="nc">&nbsp;                        valueBytes = new byte[minCapacity];</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int utf16_len = IOUtils.decodeUTF8(bytes, offset, strlen, valueBytes);</b>
<b class="nc">&nbsp;                if (utf16_len != -1) {</b>
<b class="nc">&nbsp;                    byte[] value = new byte[utf16_len];</b>
<b class="nc">&nbsp;                    System.arraycopy(valueBytes, 0, value, 0, utf16_len);</b>
<b class="nc">&nbsp;                    str = STRING_CREATOR_JDK11.apply(value, UTF16);</b>
<b class="nc">&nbsp;                    offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                    if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                        str = str.trim();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return str;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_8;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16LE) {</b>
<b class="fc">&nbsp;            byte strType = bytes[offset];</b>
<b class="fc">&nbsp;            if (strType &gt;= BC_INT32_NUM_MIN &amp;&amp; strType &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                offset++;</b>
<b class="fc">&nbsp;                strlen = strType;</b>
<b class="fc">&nbsp;            } else if (strType &gt;= BC_INT32_BYTE_MIN &amp;&amp; strType &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                offset++;</b>
<b class="fc">&nbsp;                strlen = ((strType - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                        + (bytes[offset++] &amp; 0xFF);
&nbsp;            } else {
<b class="nc">&nbsp;                strlen = readLength();</b>
&nbsp;            }
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (strlen == 0) {</b>
<b class="fc">&nbsp;                return &quot;&quot;;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; !JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                    str = str.trim();</b>
&nbsp;                }
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16LE;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_UTF16BE) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (STRING_CREATOR_JDK11 != null &amp;&amp; JDKUtils.BIG_ENDIAN) {</b>
<b class="nc">&nbsp;                byte[] chars = new byte[strlen];</b>
<b class="nc">&nbsp;                System.arraycopy(bytes, offset, chars, 0, strlen);</b>
<b class="nc">&nbsp;                str = STRING_CREATOR_JDK11.apply(chars, UTF16);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
&nbsp;
<b class="nc">&nbsp;                if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;                    str = str.trim();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return str;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            charset = StandardCharsets.UTF_16BE;</b>
<b class="fc">&nbsp;        } else if (strtype == BC_STR_GB18030) {</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            strBegin = offset;</b>
&nbsp;
<b class="fc">&nbsp;            if (GB18030 == null) {</b>
<b class="nc">&nbsp;                GB18030 = Charset.forName(&quot;GB18030&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            charset = GB18030;</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT32_NUM_MIN &amp;&amp; strtype &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            return Byte.toString(strtype);</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT32_BYTE_MIN &amp;&amp; strtype &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;            int intValue = ((strtype - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            return Integer.toString(intValue);</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT32_SHORT_MIN &amp;&amp; strtype &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;            int intValue = ((strtype - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            return Integer.toString(intValue);</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT64_NUM_MIN &amp;&amp; strtype &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;            int intValue = INT64_NUM_LOW_VALUE + (strtype - BC_INT64_NUM_MIN);</b>
<b class="fc">&nbsp;            return Integer.toString(intValue);</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT64_BYTE_MIN &amp;&amp; strtype &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;            int intValue = ((strtype - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            return Integer.toString(intValue);</b>
<b class="fc">&nbsp;        } else if (strtype &gt;= BC_INT64_SHORT_MIN &amp;&amp; strtype &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;            int intValue = ((strtype - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;            return Integer.toString(intValue);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            switch (strtype) {</b>
&nbsp;                case BC_NULL:
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                    return &quot;0.0&quot;;</b>
&nbsp;                case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                    return &quot;1.0&quot;;</b>
&nbsp;                case BC_INT64_INT:
&nbsp;                case BC_INT32: {
<b class="fc">&nbsp;                    long int32Value =</b>
&nbsp;                            ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                    offset += 4;</b>
<b class="fc">&nbsp;                    return Long.toString(int32Value);</b>
&nbsp;                }
&nbsp;                case BC_FLOAT_INT:
<b class="fc">&nbsp;                    return Float.toString(</b>
<b class="fc">&nbsp;                            readInt32Value());</b>
&nbsp;                case BC_FLOAT: {
<b class="fc">&nbsp;                    int int32Value =</b>
&nbsp;                            ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                    offset += 4;</b>
<b class="fc">&nbsp;                    float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="fc">&nbsp;                    return Float.toString(floatValue);</b>
&nbsp;                }
&nbsp;                case BC_DOUBLE: {
<b class="fc">&nbsp;                    long int64Value =</b>
&nbsp;                            ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                    ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                    ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                    ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                    offset += 8;</b>
<b class="fc">&nbsp;                    double doubleValue = Double.longBitsToDouble(int64Value);</b>
<b class="fc">&nbsp;                    return Double.toString(doubleValue);</b>
&nbsp;                }
&nbsp;                case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                    long int32Value =</b>
&nbsp;                            ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset]) &lt;&lt; 24);
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return Long.toString(int32Value * 1000);</b>
&nbsp;                }
&nbsp;                case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                    long minutes =</b>
&nbsp;                            ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset]) &lt;&lt; 24);
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return Long.toString(minutes * 60 * 1000);</b>
&nbsp;                }
&nbsp;                case BC_TIMESTAMP_MILLIS:
&nbsp;                case BC_INT64:
<b class="fc">&nbsp;                    long int64Value =</b>
&nbsp;                            ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                    ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                    ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                    ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                    ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                    ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                    ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                    ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                    offset += 8;</b>
<b class="fc">&nbsp;                    return Long.toString(int64Value);</b>
&nbsp;                case BC_BIGINT: {
<b class="fc">&nbsp;                    int len = readInt32Value();</b>
<b class="fc">&nbsp;                    byte[] bytes = new byte[len];</b>
<b class="fc">&nbsp;                    System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="fc">&nbsp;                    offset += len;</b>
<b class="fc">&nbsp;                    return new BigInteger(bytes).toString();</b>
&nbsp;                }
&nbsp;                case BC_DECIMAL: {
<b class="fc">&nbsp;                    int scale = readInt32Value();</b>
<b class="fc">&nbsp;                    BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                    BigDecimal decimal;
<b class="fc">&nbsp;                    if (scale == 0) {</b>
<b class="fc">&nbsp;                        decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return decimal.toString();</b>
&nbsp;                }
&nbsp;                case BC_TYPED_ANY: {
<b class="nc">&nbsp;                    Object typedAny = readAny();</b>
<b class="nc">&nbsp;                    return typedAny == null ? null : typedAny.toString();</b>
&nbsp;                }
&nbsp;                case BC_DECIMAL_LONG:
&nbsp;                case BC_BIGINT_LONG: {
<b class="fc">&nbsp;                    return Long.toString(</b>
<b class="fc">&nbsp;                            readInt64Value()</b>
&nbsp;                    );
&nbsp;                }
&nbsp;                case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                    double doubleValue = readInt64Value();</b>
<b class="fc">&nbsp;                    return Double.toString(doubleValue);</b>
&nbsp;                }
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;readString not support type &quot; + typeName(strtype) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (strlen &lt; 0) {</b>
<b class="fc">&nbsp;            return symbolTable.getName(-strlen);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        char[] chars = null;</b>
<b class="fc">&nbsp;        if (JVM_VERSION == 8 &amp;&amp; strtype == BC_STR_UTF8 &amp;&amp; strlen &lt; 8192) {</b>
<b class="fc">&nbsp;            final int cachedIndex = System.identityHashCode(Thread.currentThread()) &amp; (CACHE_SIZE - 1);</b>
<b class="fc">&nbsp;            chars = allocateCharArray(cachedIndex);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (chars != null) {</b>
<b class="fc">&nbsp;            int len = IOUtils.decodeUTF8(bytes, offset, strlen, chars);</b>
<b class="fc">&nbsp;            str = new String(chars, 0, len);</b>
<b class="fc">&nbsp;            releaseCharArray(cachedIndex, chars);</b>
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            str = new String(bytes, offset, strlen, charset);</b>
&nbsp;        }
<b class="fc">&nbsp;        offset += strlen;</b>
&nbsp;
<b class="fc">&nbsp;        if ((context.features &amp; Feature.TrimString.mask) != 0) {</b>
<b class="nc">&nbsp;            str = str.trim();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public char readCharValue() {
<b class="fc">&nbsp;        byte type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type == BC_CHAR) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            return (char) readInt32Value();</b>
<b class="nc">&nbsp;        } else if (type &gt;= BC_STR_ASCII_FIX_0 &amp;&amp; type &lt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            return (char) bytes[offset++];</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String str = readString();</b>
<b class="nc">&nbsp;        if (str == null || str.isEmpty()) {</b>
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return &#39;\0&#39;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.charAt(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readInt64Value() {
<b class="fc">&nbsp;        wasNull = false;</b>
&nbsp;
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;            return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                wasNull = true;</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="fc">&nbsp;                return (long) floatValue;</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                offset--;</b>
<b class="fc">&nbsp;                return (long) readDoubleValue();</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT:
<b class="fc">&nbsp;                return (long) ((float) readInt32Value());</b>
&nbsp;            case BC_DOUBLE_LONG:
<b class="fc">&nbsp;                return (long) ((double) readInt64Value());</b>
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long minutes =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="nc">&nbsp;                offset += 4;</b>
<b class="nc">&nbsp;                return minutes * 60 * 1000;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="fc">&nbsp;                long seconds =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return seconds * 1000;</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MILLIS:
&nbsp;            case BC_INT64:
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return int64Value;</b>
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal.longValue();</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                        return new BigInteger(str).longValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return new BigDecimal(str).longValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;readInt64Value not support &quot; + typeName(type) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int readInt32Value() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;            return (int) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                wasNull = true;</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                return (int) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return (int) int64Value;</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT:
<b class="fc">&nbsp;                return (int) (float) readInt32Value();</b>
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="fc">&nbsp;                return (int) floatValue;</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                offset--;</b>
<b class="fc">&nbsp;                return (int) readDoubleValue();</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES:
&nbsp;            case BC_TIMESTAMP_SECONDS:
&nbsp;            case BC_INT32:
&nbsp;            case BC_INT64_INT:
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return int32Value;</b>
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return new BigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;readInt32Value not support &quot; + typeName(type) + &quot;, offset &quot; + offset + &quot;/&quot; + bytes.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isBinary() {
<b class="fc">&nbsp;        return bytes[offset] == BC_BINARY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public byte[] readBinary() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type != BC_BINARY) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;not support input : &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int len = readLength();</b>
<b class="fc">&nbsp;        byte[] bytes = new byte[len];</b>
<b class="fc">&nbsp;        System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="fc">&nbsp;        offset += len;</b>
<b class="fc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Integer readInt32() {
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int value = readInt32Value();</b>
<b class="fc">&nbsp;        if (wasNull) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Long readInt64() {
<b class="fc">&nbsp;        long value = readInt64Value();</b>
<b class="fc">&nbsp;        if (wasNull) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final String readFixedAsciiString(int strlen) {
&nbsp;        String str;
<b class="fc">&nbsp;        if (STRING_CREATOR_JDK8 != null) {</b>
<b class="fc">&nbsp;            char[] chars = new char[strlen];</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; strlen; ++i) {</b>
<b class="fc">&nbsp;                chars[i] = (char) bytes[offset + i];</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE);</b>
<b class="fc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            str = new String(bytes, offset, strlen, StandardCharsets.ISO_8859_1);</b>
&nbsp;        }
<b class="fc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public float readFloatValue() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
&nbsp;
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                wasNull = true;</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return (float) int64Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return (float) Double.longBitsToDouble(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                return (float) (double) readInt64Value();</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            case BC_FALSE:
&nbsp;//            case FLOAT_NUM_0:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_TRUE:
&nbsp;//            case FLOAT_NUM_1:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return (float) (INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN));</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return new BigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;TODO : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double readDoubleValue() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                wasNull = true;</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return int16Value;</b>
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return (double) int64Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_FLOAT:
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE:
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return Double.longBitsToDouble(int64Value);</b>
&nbsp;            case BC_DOUBLE_LONG:
<b class="fc">&nbsp;                return readInt64Value();</b>
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str).intValue();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).intValue();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal.intValue();</b>
&nbsp;            }
&nbsp;            case BC_FALSE:
&nbsp;//            case FLOAT_NUM_0:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0;</b>
&nbsp;//            case FLOAT_NUM_1:
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                        return new BigInteger(str).intValue();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return new BigDecimal(str).intValue();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;TODO : &quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void readNumber0() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Number readNumber() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;            return (int) type;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;            return (long) INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;            return ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                    + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                    + (bytes[offset++] &amp; 0xFF);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                return null;</b>
&nbsp;            case BC_FALSE:
&nbsp;            case BC_DOUBLE_NUM_0:
<b class="fc">&nbsp;                return 0D;</b>
&nbsp;            case BC_TRUE:
&nbsp;            case BC_DOUBLE_NUM_1:
<b class="fc">&nbsp;                return 1D;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return bytes[offset++];</b>
&nbsp;            case BC_INT16: {
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return (short) int16Value;</b>
&nbsp;            }
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64_INT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return (long) int32Value;</b>
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return int64Value;</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                int len = readInt32Value();</b>
<b class="nc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="nc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="nc">&nbsp;                offset += len;</b>
<b class="nc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT_LONG: {
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return Float.intBitsToFloat(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                return (float) readInt32Value();</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE:
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return Double.longBitsToDouble(int64Value);</b>
&nbsp;            case BC_DOUBLE_LONG:
<b class="fc">&nbsp;                return (double) readInt64Value();</b>
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    return new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG: {
<b class="fc">&nbsp;                return BigDecimal.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return new BigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return new BigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_TYPED_ANY: {
<b class="nc">&nbsp;                String typeName = readString();</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;not support input type : &quot; + typeName);</b>
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    return new BigDecimal(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BigDecimal readBigDecimal() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                return null;</b>
&nbsp;            case BC_DOUBLE_NUM_0:
&nbsp;            case BC_FALSE:
<b class="fc">&nbsp;                return BigDecimal.ZERO;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="fc">&nbsp;                return BigDecimal.ONE;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return BigDecimal.valueOf(bytes[offset++]);</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf(int16Value);</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                float floatValue = (float) readInt32Value();</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf((long) floatValue);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf((long) floatValue);</b>
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                double doubleValue = Double.longBitsToDouble(int64Value);</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf(</b>
&nbsp;                        (long) doubleValue);
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT: {
<b class="nc">&nbsp;                return new BigDecimal(</b>
<b class="nc">&nbsp;                        readBigInteger()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
&nbsp;
<b class="fc">&nbsp;                if (bytes[offset] == BC_BIGINT_LONG) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    long unscaledLongValue = readInt64Value();</b>
<b class="fc">&nbsp;                    return BigDecimal.valueOf(unscaledLongValue, scale);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    return new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_DECIMAL_LONG: {
<b class="fc">&nbsp;                return BigDecimal.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                double doubleValue = readInt64Value();</b>
<b class="fc">&nbsp;                return BigDecimal.valueOf((long) doubleValue);</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return new BigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return new BigDecimal(str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                return new BigDecimal(str);</b>
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return BigDecimal.valueOf(type);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="fc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigDecimal.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    return new BigDecimal(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BigInteger readBigInteger() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                return null;</b>
&nbsp;            case BC_DOUBLE_NUM_0:
&nbsp;            case BC_FALSE:
<b class="fc">&nbsp;                return BigInteger.ZERO;</b>
&nbsp;            case BC_DOUBLE_NUM_1:
&nbsp;            case BC_TRUE:
<b class="fc">&nbsp;                return BigInteger.ONE;</b>
&nbsp;            case BC_INT8:
<b class="fc">&nbsp;                return BigInteger.valueOf(bytes[offset++]);</b>
&nbsp;            case BC_INT16:
<b class="fc">&nbsp;                int int16Value =</b>
&nbsp;                        ((bytes[offset + 1] &amp; 0xFF) +
&nbsp;                                (bytes[offset] &lt;&lt; 8));
<b class="fc">&nbsp;                offset += 2;</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(int16Value);</b>
&nbsp;            case BC_INT64_INT:
&nbsp;            case BC_INT32: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(int32Value);</b>
&nbsp;            }
&nbsp;            case BC_FLOAT_INT: {
<b class="fc">&nbsp;                float floatValue = (float) readInt32Value();</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) floatValue);
&nbsp;            }
&nbsp;            case BC_FLOAT: {
<b class="fc">&nbsp;                int int32Value =</b>
&nbsp;                        ((bytes[offset + 3] &amp; 0xFF)) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset]) &lt;&lt; 24);
<b class="fc">&nbsp;                offset += 4;</b>
<b class="fc">&nbsp;                float floatValue = Float.intBitsToFloat(int32Value);</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) floatValue);
&nbsp;            }
&nbsp;            case BC_DOUBLE: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                double doubleValue = Double.longBitsToDouble(int64Value);</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
&nbsp;                        (long) doubleValue);
&nbsp;            }
&nbsp;            case BC_INT64: {
<b class="fc">&nbsp;                long int64Value =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
<b class="fc">&nbsp;                return BigInteger.valueOf(int64Value);</b>
&nbsp;            }
&nbsp;            case BC_BIGINT:
&nbsp;            case BC_BINARY: {
<b class="fc">&nbsp;                int len = readInt32Value();</b>
<b class="fc">&nbsp;                byte[] bytes = new byte[len];</b>
<b class="fc">&nbsp;                System.arraycopy(this.bytes, offset, bytes, 0, len);</b>
<b class="fc">&nbsp;                offset += len;</b>
<b class="fc">&nbsp;                return new BigInteger(bytes);</b>
&nbsp;            }
&nbsp;            case BC_DECIMAL: {
<b class="fc">&nbsp;                int scale = readInt32Value();</b>
<b class="fc">&nbsp;                BigInteger unscaledValue = readBigInteger();</b>
&nbsp;                BigDecimal decimal;
<b class="fc">&nbsp;                if (scale == 0) {</b>
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    decimal = new BigDecimal(unscaledValue, scale);</b>
&nbsp;                }
<b class="fc">&nbsp;                return decimal.toBigInteger();</b>
&nbsp;            }
&nbsp;            case BC_BIGINT_LONG: {
<b class="fc">&nbsp;                return BigInteger.valueOf(</b>
<b class="fc">&nbsp;                        readInt64Value()</b>
&nbsp;                );
&nbsp;            }
&nbsp;            case BC_DOUBLE_LONG: {
<b class="fc">&nbsp;                double doubleValue = readInt64Value();</b>
<b class="fc">&nbsp;                return BigInteger.valueOf((long) doubleValue);</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new BigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF8: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                int strlen = readInt32Value();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                if (str.indexOf(&#39;.&#39;) == -1) {</b>
<b class="fc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new BigDecimal(str).toBigInteger();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_NUM_MIN &amp;&amp; type &lt;= BC_INT32_NUM_MAX) {</b>
<b class="fc">&nbsp;                    return BigInteger.valueOf(type);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_BYTE_MIN &amp;&amp; type &lt;= BC_INT32_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT32_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT32_SHORT_MIN &amp;&amp; type &lt;= BC_INT32_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT32_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_NUM_MIN &amp;&amp; type &lt;= BC_INT64_NUM_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = INT64_NUM_LOW_VALUE + (type - BC_INT64_NUM_MIN);</b>
<b class="fc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_BYTE_MIN &amp;&amp; type &lt;= BC_INT64_BYTE_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT64_BYTE_ZERO) &lt;&lt; 8)</b>
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_INT64_SHORT_MIN &amp;&amp; type &lt;= BC_INT64_SHORT_MAX) {</b>
<b class="fc">&nbsp;                    int intValue = ((type - BC_INT64_SHORT_ZERO) &lt;&lt; 16)</b>
&nbsp;                            + ((bytes[offset++] &amp; 0xFF) &lt;&lt; 8)
&nbsp;                            + (bytes[offset++] &amp; 0xFF);
<b class="fc">&nbsp;                    return BigInteger.valueOf(intValue);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;                    int strlen = type - BC_STR_ASCII_FIX_MIN;</b>
<b class="fc">&nbsp;                    String str = readFixedAsciiString(strlen);</b>
<b class="fc">&nbsp;                    offset += strlen;</b>
<b class="fc">&nbsp;                    return new BigInteger(str);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new JSONException(&quot;not support type :&quot; + typeName(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate() {
<b class="fc">&nbsp;        int type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type == BC_LOCAL_DATE) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="fc">&nbsp;            int month = bytes[offset++];</b>
<b class="fc">&nbsp;            int dayOfMonth = bytes[offset++];</b>
<b class="fc">&nbsp;            return LocalDate.of(year, month, dayOfMonth);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            int len = getStringLength();</b>
<b class="fc">&nbsp;            switch (len) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalDate8();</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    return readLocalDate9();</b>
&nbsp;                case 10: {
<b class="fc">&nbsp;                    return readLocalDate10();</b>
&nbsp;                }
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalDate11();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + len + &quot;, &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type == BC_STR_UTF8 || type == BC_STR_ASCII) {</b>
<b class="fc">&nbsp;            strtype = (byte) type;</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            strlen = readLength();</b>
<b class="fc">&nbsp;            switch (strlen) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalDate8();</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    return readLocalDate9();</b>
&nbsp;                case 10: {
<b class="fc">&nbsp;                    return readLocalDate10();</b>
&nbsp;                }
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalDate11();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDateTime readLocalDateTime() {
<b class="fc">&nbsp;        int type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type == BC_LOCAL_DATETIME) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="fc">&nbsp;            int month = bytes[offset++];</b>
<b class="fc">&nbsp;            int dayOfMonth = bytes[offset++];</b>
<b class="fc">&nbsp;            int hour = bytes[offset++];</b>
<b class="fc">&nbsp;            int minute = bytes[offset++];</b>
<b class="fc">&nbsp;            int second = bytes[offset++];</b>
&nbsp;
<b class="fc">&nbsp;            int nano = readInt32Value();</b>
&nbsp;
<b class="fc">&nbsp;            return LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            int len = getStringLength();</b>
&nbsp;            LocalDate localDate;
<b class="fc">&nbsp;            switch (len) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    localDate = readLocalDate8();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    localDate = readLocalDate9();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    localDate = readLocalDate10();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    localDate = readLocalDate11();</b>
<b class="nc">&nbsp;                    return localDate == null ? null : LocalDateTime.of(localDate, LocalTime.MIN);</b>
&nbsp;                case 16:
<b class="nc">&nbsp;                    return readLocalDateTime16();</b>
&nbsp;                case 17:
<b class="nc">&nbsp;                    return readLocalDateTime17();</b>
&nbsp;                case 18:
<b class="nc">&nbsp;                    return readLocalDateTime18();</b>
&nbsp;                case 19:
<b class="fc">&nbsp;                    return readLocalDateTime19();</b>
&nbsp;                case 21:
&nbsp;                case 22:
&nbsp;                case 23:
&nbsp;                case 24:
&nbsp;                case 25:
&nbsp;                case 26:
&nbsp;                case 27:
&nbsp;                case 28:
&nbsp;                case 29:
<b class="fc">&nbsp;                    LocalDateTime ldt = readLocalDateTimeX(len);</b>
<b class="fc">&nbsp;                    if (ldt != null) {</b>
<b class="fc">&nbsp;                        return ldt;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ZonedDateTime zdt = readZonedDateTimeX(len);</b>
<b class="nc">&nbsp;                    if (zdt != null) {</b>
<b class="nc">&nbsp;                        return zdt.toLocalDateTime();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw new JSONException(&quot;TODO : &quot; + len + &quot;, &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime16() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime17() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime10() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime11() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDate readLocalDate11() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected ZonedDateTime readZonedDateTimeX(int len) {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void skipLineComment() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalTime readLocalTime() {
<b class="fc">&nbsp;        int type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type == BC_LOCAL_TIME) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            int hour = bytes[offset++];</b>
<b class="fc">&nbsp;            int minute = bytes[offset++];</b>
<b class="fc">&nbsp;            int second = bytes[offset++];</b>
<b class="fc">&nbsp;            int nano = readInt32Value();</b>
<b class="fc">&nbsp;            return LocalTime.of(hour, minute, second, nano);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt;= BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            int len = getStringLength();</b>
<b class="fc">&nbsp;            switch (len) {</b>
&nbsp;                case 8:
<b class="fc">&nbsp;                    return readLocalTime8();</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    return readLocalTime10();</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalTime11();</b>
&nbsp;                case 12:
<b class="fc">&nbsp;                    return readLocalTime12();</b>
&nbsp;                case 18:
<b class="fc">&nbsp;                    return readLocalTime18();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;not support len : &quot; + len);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == BC_STR_UTF8 || type == BC_STR_ASCII) {</b>
<b class="nc">&nbsp;            strtype = (byte) type;</b>
<b class="nc">&nbsp;            offset++;</b>
<b class="nc">&nbsp;            strlen = readLength();</b>
<b class="nc">&nbsp;            switch (strlen) {</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return readLocalTime8();</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    return readLocalTime10();</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    return readLocalTime11();</b>
&nbsp;                case 12:
<b class="nc">&nbsp;                    return readLocalTime12();</b>
&nbsp;                case 18:
<b class="nc">&nbsp;                    return readLocalTime18();</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            throw new JSONException(&quot;not support len : &quot; + strlen);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Instant readInstant() {
<b class="fc">&nbsp;        int type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_TIMESTAMP: {
<b class="fc">&nbsp;                long second = readInt64Value();</b>
<b class="fc">&nbsp;                int nano = readInt32Value();</b>
<b class="fc">&nbsp;                return Instant.ofEpochSecond(second, nano);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long second = readInt32Value() * 60;</b>
<b class="nc">&nbsp;                return Instant.ofEpochSecond(second, 0);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long second = readInt32Value();</b>
<b class="nc">&nbsp;                return Instant.ofEpochSecond(second, 0);</b>
&nbsp;            }
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = readInt64Value();</b>
<b class="nc">&nbsp;                return Instant.ofEpochMilli(millis);</b>
&nbsp;            }
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ZonedDateTime readZonedDateTime() {
<b class="fc">&nbsp;        int type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_TIMESTAMP: {
<b class="nc">&nbsp;                long second = readInt64Value();</b>
<b class="nc">&nbsp;                int nano = readInt32Value();</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(second, nano);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_MINUTES: {
<b class="nc">&nbsp;                long second = readInt32Value() * 60;</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(second);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_SECONDS: {
<b class="nc">&nbsp;                long second = readInt32Value();</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochSecond(second);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);</b>
&nbsp;            }
&nbsp;            case BC_INT64:
&nbsp;            case BC_TIMESTAMP_MILLIS: {
<b class="nc">&nbsp;                long millis = readInt64Value();</b>
<b class="nc">&nbsp;                Instant instant = Instant.ofEpochMilli(millis);</b>
<b class="nc">&nbsp;                return ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);</b>
&nbsp;            }
&nbsp;            case BC_TIMESTAMP_WITH_TIMEZONE:
<b class="fc">&nbsp;                int year = (bytes[offset++] &lt;&lt; 8) + (bytes[offset++] &amp; 0xFF);</b>
<b class="fc">&nbsp;                int month = bytes[offset++];</b>
<b class="fc">&nbsp;                int dayOfMonth = bytes[offset++];</b>
<b class="fc">&nbsp;                int hour = bytes[offset++];</b>
<b class="fc">&nbsp;                int minute = bytes[offset++];</b>
<b class="fc">&nbsp;                int second = bytes[offset++];</b>
<b class="fc">&nbsp;                int nano = readInt32Value();</b>
<b class="fc">&nbsp;                LocalDateTime ldt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano);</b>
&nbsp;
&nbsp;                ZoneId zoneId;
<b class="fc">&nbsp;                long zoneIdHash = readValueHashCode();</b>
<b class="fc">&nbsp;                if (zoneIdHash == SHANGHAI_ZONE_ID_HASH) {</b>
<b class="fc">&nbsp;                    zoneId = SHANGHAI_ZONE_ID;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    String zoneIdStr = getString();</b>
<b class="fc">&nbsp;                    ZoneId contextZondId = context.getZoneId();</b>
<b class="fc">&nbsp;                    if (contextZondId.getId().equals(zoneIdStr)) {</b>
<b class="nc">&nbsp;                        zoneId = contextZondId;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        zoneId = ZoneId.of(zoneIdStr);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return ZonedDateTime.of(ldt, zoneId);</b>
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public UUID readUUID() {
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_NULL:
<b class="nc">&nbsp;                return null;</b>
&nbsp;            case BC_BINARY:
<b class="fc">&nbsp;                int len = readLength();</b>
<b class="fc">&nbsp;                if (len != 16) {</b>
<b class="nc">&nbsp;                    throw new JSONException(&quot;uuid not support &quot; + len);</b>
&nbsp;                }
<b class="fc">&nbsp;                long msb =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
&nbsp;
<b class="fc">&nbsp;                long lsb =</b>
&nbsp;                        ((bytes[offset + 7] &amp; 0xFFL)) +
&nbsp;                                ((bytes[offset + 6] &amp; 0xFFL) &lt;&lt; 8) +
&nbsp;                                ((bytes[offset + 5] &amp; 0xFFL) &lt;&lt; 16) +
&nbsp;                                ((bytes[offset + 4] &amp; 0xFFL) &lt;&lt; 24) +
&nbsp;                                ((bytes[offset + 3] &amp; 0xFFL) &lt;&lt; 32) +
&nbsp;                                ((bytes[offset + 2] &amp; 0xFFL) &lt;&lt; 40) +
&nbsp;                                ((bytes[offset + 1] &amp; 0xFFL) &lt;&lt; 48) +
&nbsp;                                ((long) (bytes[offset]) &lt;&lt; 56);
<b class="fc">&nbsp;                offset += 8;</b>
&nbsp;
<b class="fc">&nbsp;                return new UUID(msb, lsb);</b>
&nbsp;            case BC_STR_ASCII_FIX_32: {
<b class="fc">&nbsp;                long msb1 = parse4Nibbles(bytes, offset + 0);</b>
<b class="fc">&nbsp;                long msb2 = parse4Nibbles(bytes, offset + 4);</b>
<b class="fc">&nbsp;                long msb3 = parse4Nibbles(bytes, offset + 8);</b>
<b class="fc">&nbsp;                long msb4 = parse4Nibbles(bytes, offset + 12);</b>
<b class="fc">&nbsp;                long lsb1 = parse4Nibbles(bytes, offset + 16);</b>
<b class="fc">&nbsp;                long lsb2 = parse4Nibbles(bytes, offset + 20);</b>
<b class="fc">&nbsp;                long lsb3 = parse4Nibbles(bytes, offset + 24);</b>
<b class="fc">&nbsp;                long lsb4 = parse4Nibbles(bytes, offset + 28);</b>
<b class="fc">&nbsp;                if ((msb1 | msb2 | msb3 | msb4 | lsb1 | lsb2 | lsb3 | lsb4) &gt;= 0) {</b>
<b class="fc">&nbsp;                    offset += 32;</b>
<b class="fc">&nbsp;                    return new UUID(</b>
&nbsp;                            msb1 &lt;&lt; 48 | msb2 &lt;&lt; 32 | msb3 &lt;&lt; 16 | msb4,
&nbsp;                            lsb1 &lt;&lt; 48 | lsb2 &lt;&lt; 32 | lsb3 &lt;&lt; 16 | lsb4);
&nbsp;                }
<b class="nc">&nbsp;                throw new JSONException(&quot;Invalid UUID string:  &quot; + new String(bytes, offset, 32, StandardCharsets.US_ASCII));</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII_FIX_36: {
<b class="fc">&nbsp;                byte ch1 = bytes[offset + 8];</b>
<b class="fc">&nbsp;                byte ch2 = bytes[offset + 13];</b>
<b class="fc">&nbsp;                byte ch3 = bytes[offset + 18];</b>
<b class="fc">&nbsp;                byte ch4 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                if (ch1 == &#39;-&#39; &amp;&amp; ch2 == &#39;-&#39; &amp;&amp; ch3 == &#39;-&#39; &amp;&amp; ch4 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;                    long msb1 = parse4Nibbles(bytes, offset + 0);</b>
<b class="fc">&nbsp;                    long msb2 = parse4Nibbles(bytes, offset + 4);</b>
<b class="fc">&nbsp;                    long msb3 = parse4Nibbles(bytes, offset + 9);</b>
<b class="fc">&nbsp;                    long msb4 = parse4Nibbles(bytes, offset + 14);</b>
<b class="fc">&nbsp;                    long lsb1 = parse4Nibbles(bytes, offset + 19);</b>
<b class="fc">&nbsp;                    long lsb2 = parse4Nibbles(bytes, offset + 24);</b>
<b class="fc">&nbsp;                    long lsb3 = parse4Nibbles(bytes, offset + 28);</b>
<b class="fc">&nbsp;                    long lsb4 = parse4Nibbles(bytes, offset + 32);</b>
<b class="fc">&nbsp;                    if ((msb1 | msb2 | msb3 | msb4 | lsb1 | lsb2 | lsb3 | lsb4) &gt;= 0) {</b>
<b class="fc">&nbsp;                        offset += 36;</b>
<b class="fc">&nbsp;                        return new UUID(</b>
&nbsp;                                msb1 &lt;&lt; 48 | msb2 &lt;&lt; 32 | msb3 &lt;&lt; 16 | msb4,
&nbsp;                                lsb1 &lt;&lt; 48 | lsb2 &lt;&lt; 32 | lsb3 &lt;&lt; 16 | lsb4);
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                throw new JSONException(&quot;Invalid UUID string:  &quot; + new String(bytes, offset, 36, StandardCharsets.US_ASCII));</b>
&nbsp;            }
&nbsp;            case BC_STR_ASCII:
&nbsp;            case BC_STR_UTF8: {
<b class="nc">&nbsp;                int strlen = readLength();</b>
<b class="nc">&nbsp;                if (strlen == 32) {</b>
<b class="nc">&nbsp;                    long msb1 = parse4Nibbles(bytes, offset + 0);</b>
<b class="nc">&nbsp;                    long msb2 = parse4Nibbles(bytes, offset + 4);</b>
<b class="nc">&nbsp;                    long msb3 = parse4Nibbles(bytes, offset + 8);</b>
<b class="nc">&nbsp;                    long msb4 = parse4Nibbles(bytes, offset + 12);</b>
<b class="nc">&nbsp;                    long lsb1 = parse4Nibbles(bytes, offset + 16);</b>
<b class="nc">&nbsp;                    long lsb2 = parse4Nibbles(bytes, offset + 20);</b>
<b class="nc">&nbsp;                    long lsb3 = parse4Nibbles(bytes, offset + 24);</b>
<b class="nc">&nbsp;                    long lsb4 = parse4Nibbles(bytes, offset + 28);</b>
<b class="nc">&nbsp;                    if ((msb1 | msb2 | msb3 | msb4 | lsb1 | lsb2 | lsb3 | lsb4) &gt;= 0) {</b>
<b class="nc">&nbsp;                        offset += 32;</b>
<b class="nc">&nbsp;                        return new UUID(</b>
&nbsp;                                msb1 &lt;&lt; 48 | msb2 &lt;&lt; 32 | msb3 &lt;&lt; 16 | msb4,
&nbsp;                                lsb1 &lt;&lt; 48 | lsb2 &lt;&lt; 32 | lsb3 &lt;&lt; 16 | lsb4);
&nbsp;                    }
<b class="nc">&nbsp;                } else if (strlen == 36) {</b>
<b class="nc">&nbsp;                    byte ch1 = bytes[offset + 8];</b>
<b class="nc">&nbsp;                    byte ch2 = bytes[offset + 13];</b>
<b class="nc">&nbsp;                    byte ch3 = bytes[offset + 18];</b>
<b class="nc">&nbsp;                    byte ch4 = bytes[offset + 23];</b>
<b class="nc">&nbsp;                    if (ch1 == &#39;-&#39; &amp;&amp; ch2 == &#39;-&#39; &amp;&amp; ch3 == &#39;-&#39; &amp;&amp; ch4 == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                        long msb1 = parse4Nibbles(bytes, offset + 0);</b>
<b class="nc">&nbsp;                        long msb2 = parse4Nibbles(bytes, offset + 4);</b>
<b class="nc">&nbsp;                        long msb3 = parse4Nibbles(bytes, offset + 9);</b>
<b class="nc">&nbsp;                        long msb4 = parse4Nibbles(bytes, offset + 14);</b>
<b class="nc">&nbsp;                        long lsb1 = parse4Nibbles(bytes, offset + 19);</b>
<b class="nc">&nbsp;                        long lsb2 = parse4Nibbles(bytes, offset + 24);</b>
<b class="nc">&nbsp;                        long lsb3 = parse4Nibbles(bytes, offset + 28);</b>
<b class="nc">&nbsp;                        long lsb4 = parse4Nibbles(bytes, offset + 32);</b>
<b class="nc">&nbsp;                        if ((msb1 | msb2 | msb3 | msb4 | lsb1 | lsb2 | lsb3 | lsb4) &gt;= 0) {</b>
<b class="nc">&nbsp;                            offset += 36;</b>
<b class="nc">&nbsp;                            return new UUID(</b>
&nbsp;                                    msb1 &lt;&lt; 48 | msb2 &lt;&lt; 32 | msb3 &lt;&lt; 16 | msb4,
&nbsp;                                    lsb1 &lt;&lt; 48 | lsb2 &lt;&lt; 32 | lsb3 &lt;&lt; 16 | lsb4);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;Invalid UUID string:  &quot; + str);</b>
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                throw new JSONException(&quot;type not support : &quot; + JSONB.typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean readBoolValue() {
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        byte type = bytes[offset++];</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case BC_INT32_NUM_1:
&nbsp;            case BC_TRUE:
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case BC_INT32_NUM_0:
&nbsp;            case BC_FALSE:
<b class="fc">&nbsp;                return false;</b>
&nbsp;            case BC_NULL:
<b class="fc">&nbsp;                wasNull = true;</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            case BC_STR_ASCII_FIX_1:
<b class="fc">&nbsp;                if (bytes[offset] == &#39;1&#39; || bytes[offset] == &#39;Y&#39;) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (bytes[offset] == &#39;0&#39; || bytes[offset] == &#39;N&#39;) {</b>
<b class="fc">&nbsp;                    offset++;</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            case BC_STR_ASCII_FIX_4:
<b class="nc">&nbsp;                if (bytes[offset] == &#39;t&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;r&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;u&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;e&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bytes[offset] == &#39;T&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;R&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;U&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;E&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            case BC_STR_ASCII_FIX_5:
<b class="fc">&nbsp;                if (bytes[offset] == &#39;f&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;a&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;l&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;s&#39;
&nbsp;                        &amp;&amp; bytes[offset + 4] == &#39;e&#39;
&nbsp;                ) {
<b class="fc">&nbsp;                    offset += 5;</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (bytes[offset] == &#39;F&#39;</b>
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;A&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;L&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;S&#39;
&nbsp;                        &amp;&amp; bytes[offset + 4] == &#39;E&#39;
&nbsp;                ) {
<b class="fc">&nbsp;                    offset += 5;</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            case BC_STR_ASCII: {
<b class="fc">&nbsp;                strlen = readLength();</b>
<b class="fc">&nbsp;                if (strlen == 1) {</b>
<b class="nc">&nbsp;                    if (bytes[offset] == &#39;Y&#39;) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (bytes[offset] == &#39;N&#39;) {</b>
<b class="nc">&nbsp;                        offset++;</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                } else if (strlen == 4</b>
&nbsp;                        &amp;&amp; bytes[offset] == &#39;t&#39;
&nbsp;                        &amp;&amp; bytes[offset + 1] == &#39;r&#39;
&nbsp;                        &amp;&amp; bytes[offset + 2] == &#39;u&#39;
&nbsp;                        &amp;&amp; bytes[offset + 3] == &#39;e&#39;
&nbsp;                ) {
<b class="nc">&nbsp;                    offset += 4;</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (strlen == 5) {</b>
<b class="fc">&nbsp;                    if (bytes[offset] == &#39;f&#39;</b>
&nbsp;                            &amp;&amp; bytes[offset + 1] == &#39;a&#39;
&nbsp;                            &amp;&amp; bytes[offset + 2] == &#39;l&#39;
&nbsp;                            &amp;&amp; bytes[offset + 3] == &#39;s&#39;
&nbsp;                            &amp;&amp; bytes[offset + 4] == &#39;e&#39;) {
<b class="nc">&nbsp;                        offset += 5;</b>
<b class="nc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (bytes[offset] == &#39;F&#39;</b>
&nbsp;                            &amp;&amp; bytes[offset + 1] == &#39;A&#39;
&nbsp;                            &amp;&amp; bytes[offset + 2] == &#39;L&#39;
&nbsp;                            &amp;&amp; bytes[offset + 3] == &#39;S&#39;
&nbsp;                            &amp;&amp; bytes[offset + 4] == &#39;E&#39;) {
<b class="fc">&nbsp;                        offset += 5;</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.US_ASCII);</b>
<b class="nc">&nbsp;                offset += strlen;</b>
<b class="nc">&nbsp;                throw new JSONException(&quot;not support input &quot; + str);</b>
&nbsp;            }
&nbsp;            case BC_STR_UTF16LE: {
<b class="fc">&nbsp;                strlen = readLength();</b>
<b class="fc">&nbsp;                String str = new String(bytes, offset, strlen, StandardCharsets.UTF_16LE);</b>
<b class="fc">&nbsp;                offset += strlen;</b>
<b class="fc">&nbsp;                switch (str) {</b>
&nbsp;                    case &quot;0&quot;:
&nbsp;                    case &quot;N&quot;:
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    case &quot;1&quot;:
&nbsp;                    case &quot;Y&quot;:
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new JSONException(&quot;not support input &quot; + str);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            default:
<b class="nc">&nbsp;                throw new JSONException(&quot;not support type : &quot; + typeName(type));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatch(byte type) {
<b class="fc">&nbsp;        if (bytes[offset] == type) {</b>
<b class="fc">&nbsp;            offset++;</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected int getStringLength() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type &gt;= BC_STR_ASCII_FIX_MIN &amp;&amp; type &lt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="fc">&nbsp;            return type - BC_STR_ASCII_FIX_MIN;</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate8() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 8) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;        byte c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;        byte c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;        byte c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;        byte c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;        byte c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;        byte c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;        byte c7 = bytes[offset + 8];</b>
&nbsp;
&nbsp;        char y0, y1, y2, y3, m0, m1, d0, d1;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c6 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;            y0 = (char) c0;</b>
<b class="fc">&nbsp;            y1 = (char) c1;</b>
<b class="fc">&nbsp;            y2 = (char) c2;</b>
<b class="fc">&nbsp;            y3 = (char) c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            m1 = (char) c5;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            d1 = (char) c7;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            y0 = (char) c0;</b>
<b class="fc">&nbsp;            y1 = (char) c1;</b>
<b class="fc">&nbsp;            y2 = (char) c2;</b>
<b class="fc">&nbsp;            y3 = (char) c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = (char) c4;</b>
<b class="fc">&nbsp;            m1 = (char) c5;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = (char) c6;</b>
<b class="fc">&nbsp;            d1 = (char) c7;</b>
&nbsp;        }
&nbsp;
&nbsp;        int year;
<b class="fc">&nbsp;        if (y0 &gt;= &#39;0&#39; &amp;&amp; y0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; y1 &gt;= &#39;0&#39; &amp;&amp; y1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y2 &gt;= &#39;0&#39; &amp;&amp; y2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y3 &gt;= &#39;0&#39; &amp;&amp; y3 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            year = (y0 - &#39;0&#39;) * 1000 + (y1 - &#39;0&#39;) * 100 + (y2 - &#39;0&#39;) * 10 + (y3 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int month;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            month = (m0 - &#39;0&#39;) * 10 + (m1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int dom;
<b class="fc">&nbsp;        if (d0 &gt;= &#39;0&#39; &amp;&amp; d0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; d1 &gt;= &#39;0&#39; &amp;&amp; d1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            dom = (d0 - &#39;0&#39;) * 10 + (d1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        LocalDate ldt = LocalDate.of(year, month, dom);</b>
&nbsp;
<b class="fc">&nbsp;        offset += 9;</b>
<b class="fc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public LocalDate readLocalDate9() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 9) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;        byte c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;        byte c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;        byte c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;        byte c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;        byte c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;        byte c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;        byte c7 = bytes[offset + 8];</b>
<b class="fc">&nbsp;        byte c8 = bytes[offset + 9];</b>
&nbsp;
&nbsp;        char y0, y1, y2, y3, m0, m1, d0, d1;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c6 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;            y0 = (char) c0;</b>
<b class="fc">&nbsp;            y1 = (char) c1;</b>
<b class="fc">&nbsp;            y2 = (char) c2;</b>
<b class="fc">&nbsp;            y3 = (char) c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            m1 = (char) c5;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = (char) c7;</b>
<b class="fc">&nbsp;            d1 = (char) c8;</b>
<b class="fc">&nbsp;        } else if (c4 == &#39;-&#39; &amp;&amp; c7 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;            y0 = (char) c0;</b>
<b class="fc">&nbsp;            y1 = (char) c1;</b>
<b class="fc">&nbsp;            y2 = (char) c2;</b>
<b class="fc">&nbsp;            y3 = (char) c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = (char) c5;</b>
<b class="fc">&nbsp;            m1 = (char) c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            d1 = (char) c8;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int year;
<b class="fc">&nbsp;        if (y0 &gt;= &#39;0&#39; &amp;&amp; y0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; y1 &gt;= &#39;0&#39; &amp;&amp; y1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y2 &gt;= &#39;0&#39; &amp;&amp; y2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y3 &gt;= &#39;0&#39; &amp;&amp; y3 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            year = (y0 - &#39;0&#39;) * 1000 + (y1 - &#39;0&#39;) * 100 + (y2 - &#39;0&#39;) * 10 + (y3 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int month;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            month = (m0 - &#39;0&#39;) * 10 + (m1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int dom;
<b class="fc">&nbsp;        if (d0 &gt;= &#39;0&#39; &amp;&amp; d0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; d1 &gt;= &#39;0&#39; &amp;&amp; d1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            dom = (d0 - &#39;0&#39;) * 10 + (d1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        LocalDate ldt = LocalDate.of(year, month, dom);</b>
&nbsp;
<b class="fc">&nbsp;        offset += 10;</b>
<b class="fc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDate readLocalDate10() {
&nbsp;        byte c0, c1, c2, c3, c4, c5, c6, c7, c8, c9;
<b class="fc">&nbsp;        if (bytes[offset] == BC_STR_ASCII_FIX_MIN + 10) {</b>
<b class="fc">&nbsp;            c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;            c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;            c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;            c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;            c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;            c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;            c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;            c7 = bytes[offset + 8];</b>
<b class="fc">&nbsp;            c8 = bytes[offset + 9];</b>
<b class="fc">&nbsp;            c9 = bytes[offset + 10];</b>
<b class="fc">&nbsp;        } else if ((strtype == BC_STR_UTF8 || strtype == BC_STR_ASCII) &amp;&amp; strlen == 10) {</b>
<b class="fc">&nbsp;            c0 = bytes[offset + 0];</b>
<b class="fc">&nbsp;            c1 = bytes[offset + 1];</b>
<b class="fc">&nbsp;            c2 = bytes[offset + 2];</b>
<b class="fc">&nbsp;            c3 = bytes[offset + 3];</b>
<b class="fc">&nbsp;            c4 = bytes[offset + 4];</b>
<b class="fc">&nbsp;            c5 = bytes[offset + 5];</b>
<b class="fc">&nbsp;            c6 = bytes[offset + 6];</b>
<b class="fc">&nbsp;            c7 = bytes[offset + 7];</b>
<b class="fc">&nbsp;            c8 = bytes[offset + 8];</b>
<b class="fc">&nbsp;            c9 = bytes[offset + 9];</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        byte y0, y1, y2, y3, m0, m1, d0, d1;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c7 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;            y0 = c0;</b>
<b class="fc">&nbsp;            y1 = c1;</b>
<b class="fc">&nbsp;            y2 = c2;</b>
<b class="fc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c5;</b>
<b class="fc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = c8;</b>
<b class="fc">&nbsp;            d1 = c9;</b>
<b class="fc">&nbsp;        } else if (c4 == &#39;/&#39; &amp;&amp; c7 == &#39;/&#39;) { // tw : yyyy/mm/dd</b>
<b class="fc">&nbsp;            y0 = c0;</b>
<b class="fc">&nbsp;            y1 = c1;</b>
<b class="fc">&nbsp;            y2 = c2;</b>
<b class="fc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c5;</b>
<b class="fc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = c8;</b>
<b class="fc">&nbsp;            d1 = c9;</b>
<b class="fc">&nbsp;        } else if (c2 == &#39;.&#39; &amp;&amp; c5 == &#39;.&#39;) {</b>
<b class="fc">&nbsp;            d0 = c0;</b>
<b class="fc">&nbsp;            d1 = c1;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c3;</b>
<b class="fc">&nbsp;            m1 = c4;</b>
&nbsp;
<b class="fc">&nbsp;            y0 = c6;</b>
<b class="fc">&nbsp;            y1 = c7;</b>
<b class="fc">&nbsp;            y2 = c8;</b>
<b class="fc">&nbsp;            y3 = c9;</b>
<b class="fc">&nbsp;        } else if (c2 == &#39;-&#39; &amp;&amp; c5 == &#39;-&#39;) {</b>
<b class="fc">&nbsp;            d0 = c0;</b>
<b class="fc">&nbsp;            d1 = c1;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c3;</b>
<b class="fc">&nbsp;            m1 = c4;</b>
&nbsp;
<b class="fc">&nbsp;            y0 = c6;</b>
<b class="fc">&nbsp;            y1 = c7;</b>
<b class="fc">&nbsp;            y2 = c8;</b>
<b class="fc">&nbsp;            y3 = c9;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int year;
<b class="fc">&nbsp;        if (y0 &gt;= &#39;0&#39; &amp;&amp; y0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; y1 &gt;= &#39;0&#39; &amp;&amp; y1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y2 &gt;= &#39;0&#39; &amp;&amp; y2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y3 &gt;= &#39;0&#39; &amp;&amp; y3 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            year = (y0 - &#39;0&#39;) * 1000 + (y1 - &#39;0&#39;) * 100 + (y2 - &#39;0&#39;) * 10 + (y3 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int month;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            month = (m0 - &#39;0&#39;) * 10 + (m1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int dom;
<b class="fc">&nbsp;        if (d0 &gt;= &#39;0&#39; &amp;&amp; d0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; d1 &gt;= &#39;0&#39; &amp;&amp; d1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            dom = (d0 - &#39;0&#39;) * 10 + (d1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (year == 0 &amp;&amp; month == 0 &amp;&amp; dom == 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        LocalDate ldt = LocalDate.of(year, month, dom);</b>
&nbsp;
<b class="fc">&nbsp;        offset += 11;</b>
<b class="fc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime5() {
<b class="nc">&nbsp;        type = bytes[offset];</b>
<b class="nc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 5) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        byte c0 = bytes[offset + 1];</b>
<b class="nc">&nbsp;        byte c1 = bytes[offset + 2];</b>
<b class="nc">&nbsp;        byte c2 = bytes[offset + 3];</b>
<b class="nc">&nbsp;        byte c3 = bytes[offset + 4];</b>
<b class="nc">&nbsp;        byte c4 = bytes[offset + 5];</b>
&nbsp;
&nbsp;        byte h0, h1, i0, i1, s0, s1;
<b class="nc">&nbsp;        if (c2 == &#39;:&#39;) {</b>
<b class="nc">&nbsp;            h0 = c0;</b>
<b class="nc">&nbsp;            h1 = c1;</b>
<b class="nc">&nbsp;            i0 = c3;</b>
<b class="nc">&nbsp;            i1 = c4;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="nc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="nc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="nc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="nc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        offset += 6;</b>
&nbsp;
<b class="nc">&nbsp;        return LocalTime.of(hour, minute);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime8() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 8) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;        byte c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;        byte c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;        byte c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;        byte c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;        byte c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;        byte c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;        byte c7 = bytes[offset + 8];</b>
&nbsp;
&nbsp;        byte h0, h1, i0, i1, s0, s1;
<b class="fc">&nbsp;        if (c2 == &#39;:&#39; &amp;&amp; c5 == &#39;:&#39;) {</b>
<b class="fc">&nbsp;            h0 = c0;</b>
<b class="fc">&nbsp;            h1 = c1;</b>
<b class="fc">&nbsp;            i0 = c3;</b>
<b class="fc">&nbsp;            i1 = c4;</b>
<b class="fc">&nbsp;            s0 = c6;</b>
<b class="fc">&nbsp;            s1 = c7;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="fc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="fc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int seccond;
<b class="fc">&nbsp;        if (s0 &gt;= &#39;0&#39; &amp;&amp; s0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; s1 &gt;= &#39;0&#39; &amp;&amp; s1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            seccond = (s0 - &#39;0&#39;) * 10 + (s1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset += 9;</b>
&nbsp;
<b class="fc">&nbsp;        return LocalTime.of(hour, minute, seccond);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime12() {
&nbsp;        byte c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11;
<b class="fc">&nbsp;        if (bytes[offset] == BC_STR_ASCII_FIX_MIN + 12) {</b>
<b class="fc">&nbsp;            c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;            c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;            c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;            c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;            c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;            c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;            c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;            c7 = bytes[offset + 8];</b>
<b class="fc">&nbsp;            c8 = bytes[offset + 9];</b>
<b class="fc">&nbsp;            c9 = bytes[offset + 10];</b>
<b class="fc">&nbsp;            c10 = bytes[offset + 11];</b>
<b class="fc">&nbsp;            c11 = bytes[offset + 12];</b>
<b class="nc">&nbsp;        } else if ((strtype == BC_STR_UTF8 || strtype == BC_STR_ASCII) &amp;&amp; strlen == 12) {</b>
<b class="nc">&nbsp;            c0 = bytes[offset];</b>
<b class="nc">&nbsp;            c1 = bytes[offset + 1];</b>
<b class="nc">&nbsp;            c2 = bytes[offset + 2];</b>
<b class="nc">&nbsp;            c3 = bytes[offset + 3];</b>
<b class="nc">&nbsp;            c4 = bytes[offset + 4];</b>
<b class="nc">&nbsp;            c5 = bytes[offset + 5];</b>
<b class="nc">&nbsp;            c6 = bytes[offset + 6];</b>
<b class="nc">&nbsp;            c7 = bytes[offset + 7];</b>
<b class="nc">&nbsp;            c8 = bytes[offset + 8];</b>
<b class="nc">&nbsp;            c9 = bytes[offset + 9];</b>
<b class="nc">&nbsp;            c10 = bytes[offset + 10];</b>
<b class="nc">&nbsp;            c11 = bytes[offset + 11];</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        byte h0, h1, i0, i1, s0, s1, m0, m1, m2;
<b class="fc">&nbsp;        if (c2 == &#39;:&#39; &amp;&amp; c5 == &#39;:&#39; &amp;&amp; c8 == &#39;.&#39;) {</b>
<b class="fc">&nbsp;            h0 = c0;</b>
<b class="fc">&nbsp;            h1 = c1;</b>
<b class="fc">&nbsp;            i0 = c3;</b>
<b class="fc">&nbsp;            i1 = c4;</b>
<b class="fc">&nbsp;            s0 = c6;</b>
<b class="fc">&nbsp;            s1 = c7;</b>
<b class="fc">&nbsp;            m0 = c9;</b>
<b class="fc">&nbsp;            m1 = c10;</b>
<b class="fc">&nbsp;            m2 = c11;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="fc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="fc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int seccond;
<b class="fc">&nbsp;        if (s0 &gt;= &#39;0&#39; &amp;&amp; s0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; s1 &gt;= &#39;0&#39; &amp;&amp; s1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            seccond = (s0 - &#39;0&#39;) * 10 + (s1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int millis;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m2 &gt;= &#39;0&#39; &amp;&amp; m2 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            millis = (m0 - &#39;0&#39;) * 100 + (m1 - &#39;0&#39;) * 10 + (m2 - &#39;0&#39;);</b>
<b class="fc">&nbsp;            millis *= 1000_000;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset += 13;</b>
&nbsp;
<b class="fc">&nbsp;        return LocalTime.of(hour, minute, seccond, millis);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalTime readLocalTime18() {
&nbsp;        byte c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17;
<b class="fc">&nbsp;        if (bytes[offset] == BC_STR_ASCII_FIX_MIN + 18) {</b>
<b class="fc">&nbsp;            c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;            c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;            c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;            c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;            c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;            c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;            c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;            c7 = bytes[offset + 8];</b>
<b class="fc">&nbsp;            c8 = bytes[offset + 9];</b>
<b class="fc">&nbsp;            c9 = bytes[offset + 10];</b>
<b class="fc">&nbsp;            c10 = bytes[offset + 11];</b>
<b class="fc">&nbsp;            c11 = bytes[offset + 12];</b>
<b class="fc">&nbsp;            c12 = bytes[offset + 13];</b>
<b class="fc">&nbsp;            c13 = bytes[offset + 14];</b>
<b class="fc">&nbsp;            c14 = bytes[offset + 15];</b>
<b class="fc">&nbsp;            c15 = bytes[offset + 16];</b>
<b class="fc">&nbsp;            c16 = bytes[offset + 17];</b>
<b class="fc">&nbsp;            c17 = bytes[offset + 18];</b>
<b class="nc">&nbsp;        } else if ((strtype == BC_STR_UTF8 || strtype == BC_STR_ASCII) &amp;&amp; strlen == 18) {</b>
<b class="nc">&nbsp;            c0 = bytes[offset];</b>
<b class="nc">&nbsp;            c1 = bytes[offset + 1];</b>
<b class="nc">&nbsp;            c2 = bytes[offset + 2];</b>
<b class="nc">&nbsp;            c3 = bytes[offset + 3];</b>
<b class="nc">&nbsp;            c4 = bytes[offset + 4];</b>
<b class="nc">&nbsp;            c5 = bytes[offset + 5];</b>
<b class="nc">&nbsp;            c6 = bytes[offset + 6];</b>
<b class="nc">&nbsp;            c7 = bytes[offset + 7];</b>
<b class="nc">&nbsp;            c8 = bytes[offset + 8];</b>
<b class="nc">&nbsp;            c9 = bytes[offset + 9];</b>
<b class="nc">&nbsp;            c10 = bytes[offset + 10];</b>
<b class="nc">&nbsp;            c11 = bytes[offset + 11];</b>
<b class="nc">&nbsp;            c12 = bytes[offset + 12];</b>
<b class="nc">&nbsp;            c13 = bytes[offset + 13];</b>
<b class="nc">&nbsp;            c14 = bytes[offset + 14];</b>
<b class="nc">&nbsp;            c15 = bytes[offset + 15];</b>
<b class="nc">&nbsp;            c16 = bytes[offset + 16];</b>
<b class="nc">&nbsp;            c17 = bytes[offset + 17];</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        byte h0, h1, i0, i1, s0, s1, m0, m1, m2, m3, m4, m5, m6, m7, m8;
<b class="fc">&nbsp;        if (c2 == &#39;:&#39; &amp;&amp; c5 == &#39;:&#39; &amp;&amp; c8 == &#39;.&#39;) {</b>
<b class="fc">&nbsp;            h0 = c0;</b>
<b class="fc">&nbsp;            h1 = c1;</b>
<b class="fc">&nbsp;            i0 = c3;</b>
<b class="fc">&nbsp;            i1 = c4;</b>
<b class="fc">&nbsp;            s0 = c6;</b>
<b class="fc">&nbsp;            s1 = c7;</b>
<b class="fc">&nbsp;            m0 = c9;</b>
<b class="fc">&nbsp;            m1 = c10;</b>
<b class="fc">&nbsp;            m2 = c11;</b>
<b class="fc">&nbsp;            m3 = c12;</b>
<b class="fc">&nbsp;            m4 = c13;</b>
<b class="fc">&nbsp;            m5 = c14;</b>
<b class="fc">&nbsp;            m6 = c15;</b>
<b class="fc">&nbsp;            m7 = c16;</b>
<b class="fc">&nbsp;            m8 = c17;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="fc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="fc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int seccond;
<b class="fc">&nbsp;        if (s0 &gt;= &#39;0&#39; &amp;&amp; s0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; s1 &gt;= &#39;0&#39; &amp;&amp; s1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            seccond = (s0 - &#39;0&#39;) * 10 + (s1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int millis;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m2 &gt;= &#39;0&#39; &amp;&amp; m2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m3 &gt;= &#39;0&#39; &amp;&amp; m3 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m4 &gt;= &#39;0&#39; &amp;&amp; m4 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m5 &gt;= &#39;0&#39; &amp;&amp; m5 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m6 &gt;= &#39;0&#39; &amp;&amp; m6 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m7 &gt;= &#39;0&#39; &amp;&amp; m7 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; m8 &gt;= &#39;0&#39; &amp;&amp; m8 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            millis = (m0 - &#39;0&#39;) * 1000_000_00</b>
&nbsp;                    + (m1 - &#39;0&#39;) * 1000_000_0
&nbsp;                    + (m2 - &#39;0&#39;) * 1000_000
&nbsp;                    + (m3 - &#39;0&#39;) * 1000_00
&nbsp;                    + (m4 - &#39;0&#39;) * 1000_0
&nbsp;                    + (m5 - &#39;0&#39;) * 1000
&nbsp;                    + (m6 - &#39;0&#39;) * 100
&nbsp;                    + (m7 - &#39;0&#39;) * 10
&nbsp;                    + (m8 - &#39;0&#39;);
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset += 19;</b>
&nbsp;
<b class="fc">&nbsp;        return LocalTime.of(hour, minute, seccond, millis);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime18() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readMillis19() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 19) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        char c0 = (char) bytes[offset + 1];</b>
<b class="fc">&nbsp;        char c1 = (char) bytes[offset + 2];</b>
<b class="fc">&nbsp;        char c2 = (char) bytes[offset + 3];</b>
<b class="fc">&nbsp;        char c3 = (char) bytes[offset + 4];</b>
<b class="fc">&nbsp;        char c4 = (char) bytes[offset + 5];</b>
<b class="fc">&nbsp;        char c5 = (char) bytes[offset + 6];</b>
<b class="fc">&nbsp;        char c6 = (char) bytes[offset + 7];</b>
<b class="fc">&nbsp;        char c7 = (char) bytes[offset + 8];</b>
<b class="fc">&nbsp;        char c8 = (char) bytes[offset + 9];</b>
<b class="fc">&nbsp;        char c9 = (char) bytes[offset + 10];</b>
<b class="fc">&nbsp;        char c10 = (char) bytes[offset + 11];</b>
<b class="fc">&nbsp;        char c11 = (char) bytes[offset + 12];</b>
<b class="fc">&nbsp;        char c12 = (char) bytes[offset + 13];</b>
<b class="fc">&nbsp;        char c13 = (char) bytes[offset + 14];</b>
<b class="fc">&nbsp;        char c14 = (char) bytes[offset + 15];</b>
<b class="fc">&nbsp;        char c15 = (char) bytes[offset + 16];</b>
<b class="fc">&nbsp;        char c16 = (char) bytes[offset + 17];</b>
<b class="fc">&nbsp;        char c17 = (char) bytes[offset + 18];</b>
<b class="fc">&nbsp;        char c18 = (char) bytes[offset + 19];</b>
&nbsp;
&nbsp;        char y0, y1, y2, y3, m0, m1, d0, d1, h0, h1, i0, i1, s0, s1, S0, S1, S2;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c7 == &#39;-&#39; &amp;&amp; (c10 == &#39; &#39; || c10 == &#39;T&#39;) &amp;&amp; c13 == &#39;:&#39; &amp;&amp; c16 == &#39;:&#39;) {</b>
<b class="fc">&nbsp;            y0 = c0;</b>
<b class="fc">&nbsp;            y1 = c1;</b>
<b class="fc">&nbsp;            y2 = c2;</b>
<b class="fc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c5;</b>
<b class="fc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = c8;</b>
<b class="fc">&nbsp;            d1 = c9;</b>
&nbsp;
<b class="fc">&nbsp;            h0 = c11;</b>
<b class="fc">&nbsp;            h1 = c12;</b>
&nbsp;
<b class="fc">&nbsp;            i0 = c14;</b>
<b class="fc">&nbsp;            i1 = c15;</b>
&nbsp;
<b class="fc">&nbsp;            s0 = c17;</b>
<b class="fc">&nbsp;            s1 = c18;</b>
&nbsp;
<b class="fc">&nbsp;            S0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S1 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S2 = &#39;0&#39;;</b>
<b class="fc">&nbsp;        } else if (c4 == &#39;/&#39; &amp;&amp; c7 == &#39;/&#39; &amp;&amp; (c10 == &#39; &#39; || c10 == &#39;T&#39;) &amp;&amp; c13 == &#39;:&#39; &amp;&amp; c16 == &#39;:&#39;) {</b>
<b class="fc">&nbsp;            y0 = c0;</b>
<b class="fc">&nbsp;            y1 = c1;</b>
<b class="fc">&nbsp;            y2 = c2;</b>
<b class="fc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c5;</b>
<b class="fc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = c8;</b>
<b class="fc">&nbsp;            d1 = c9;</b>
&nbsp;
<b class="fc">&nbsp;            h0 = c11;</b>
<b class="fc">&nbsp;            h1 = c12;</b>
&nbsp;
<b class="fc">&nbsp;            i0 = c14;</b>
<b class="fc">&nbsp;            i1 = c15;</b>
&nbsp;
<b class="fc">&nbsp;            s0 = c17;</b>
<b class="fc">&nbsp;            s1 = c18;</b>
&nbsp;
<b class="fc">&nbsp;            S0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S1 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S2 = &#39;0&#39;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int year;
<b class="fc">&nbsp;        if (y0 &gt;= &#39;0&#39; &amp;&amp; y0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; y1 &gt;= &#39;0&#39; &amp;&amp; y1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y2 &gt;= &#39;0&#39; &amp;&amp; y2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y3 &gt;= &#39;0&#39; &amp;&amp; y3 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            year = (y0 - &#39;0&#39;) * 1000 + (y1 - &#39;0&#39;) * 100 + (y2 - &#39;0&#39;) * 10 + (y3 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int month;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            month = (m0 - &#39;0&#39;) * 10 + (m1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int dom;
<b class="fc">&nbsp;        if (d0 &gt;= &#39;0&#39; &amp;&amp; d0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; d1 &gt;= &#39;0&#39; &amp;&amp; d1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            dom = (d0 - &#39;0&#39;) * 10 + (d1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="fc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="fc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int second;
<b class="fc">&nbsp;        if (s0 &gt;= &#39;0&#39; &amp;&amp; s0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; s1 &gt;= &#39;0&#39; &amp;&amp; s1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            second = (s0 - &#39;0&#39;) * 10 + (s1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        int nanoOfSecond;
<b class="fc">&nbsp;        if (S0 &gt;= &#39;0&#39; &amp;&amp; S0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; S1 &gt;= &#39;0&#39; &amp;&amp; S1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; S2 &gt;= &#39;0&#39; &amp;&amp; S2 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            nanoOfSecond = (S0 - &#39;0&#39;) * 100</b>
&nbsp;                    + (S1 - &#39;0&#39;) * 10
&nbsp;                    + (S2 - &#39;0&#39;);
<b class="fc">&nbsp;            nanoOfSecond *= 1000_000;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset += 20;</b>
<b class="fc">&nbsp;        return DateUtils.millis(context.getZoneId(), year, month, dom, hour, minute, second, nanoOfSecond);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTime19() {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type != BC_STR_ASCII_FIX_MIN + 19) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        char c0 = (char) bytes[offset + 1];</b>
<b class="fc">&nbsp;        char c1 = (char) bytes[offset + 2];</b>
<b class="fc">&nbsp;        char c2 = (char) bytes[offset + 3];</b>
<b class="fc">&nbsp;        char c3 = (char) bytes[offset + 4];</b>
<b class="fc">&nbsp;        char c4 = (char) bytes[offset + 5];</b>
<b class="fc">&nbsp;        char c5 = (char) bytes[offset + 6];</b>
<b class="fc">&nbsp;        char c6 = (char) bytes[offset + 7];</b>
<b class="fc">&nbsp;        char c7 = (char) bytes[offset + 8];</b>
<b class="fc">&nbsp;        char c8 = (char) bytes[offset + 9];</b>
<b class="fc">&nbsp;        char c9 = (char) bytes[offset + 10];</b>
<b class="fc">&nbsp;        char c10 = (char) bytes[offset + 11];</b>
<b class="fc">&nbsp;        char c11 = (char) bytes[offset + 12];</b>
<b class="fc">&nbsp;        char c12 = (char) bytes[offset + 13];</b>
<b class="fc">&nbsp;        char c13 = (char) bytes[offset + 14];</b>
<b class="fc">&nbsp;        char c14 = (char) bytes[offset + 15];</b>
<b class="fc">&nbsp;        char c15 = (char) bytes[offset + 16];</b>
<b class="fc">&nbsp;        char c16 = (char) bytes[offset + 17];</b>
<b class="fc">&nbsp;        char c17 = (char) bytes[offset + 18];</b>
<b class="fc">&nbsp;        char c18 = (char) bytes[offset + 19];</b>
&nbsp;
&nbsp;        char y0, y1, y2, y3, m0, m1, d0, d1, h0, h1, i0, i1, s0, s1, S0, S1, S2;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c7 == &#39;-&#39; &amp;&amp; (c10 == &#39; &#39; || c10 == &#39;T&#39;) &amp;&amp; c13 == &#39;:&#39; &amp;&amp; c16 == &#39;:&#39;) {</b>
<b class="fc">&nbsp;            y0 = c0;</b>
<b class="fc">&nbsp;            y1 = c1;</b>
<b class="fc">&nbsp;            y2 = c2;</b>
<b class="fc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = c5;</b>
<b class="fc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = c8;</b>
<b class="fc">&nbsp;            d1 = c9;</b>
&nbsp;
<b class="fc">&nbsp;            h0 = c11;</b>
<b class="fc">&nbsp;            h1 = c12;</b>
&nbsp;
<b class="fc">&nbsp;            i0 = c14;</b>
<b class="fc">&nbsp;            i1 = c15;</b>
&nbsp;
<b class="fc">&nbsp;            s0 = c17;</b>
<b class="fc">&nbsp;            s1 = c18;</b>
&nbsp;
<b class="fc">&nbsp;            S0 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S1 = &#39;0&#39;;</b>
<b class="fc">&nbsp;            S2 = &#39;0&#39;;</b>
<b class="nc">&nbsp;        } else if (c4 == &#39;/&#39; &amp;&amp; c7 == &#39;/&#39; &amp;&amp; (c10 == &#39; &#39; || c10 == &#39;T&#39;) &amp;&amp; c13 == &#39;:&#39; &amp;&amp; c16 == &#39;:&#39;) {</b>
<b class="nc">&nbsp;            y0 = c0;</b>
<b class="nc">&nbsp;            y1 = c1;</b>
<b class="nc">&nbsp;            y2 = c2;</b>
<b class="nc">&nbsp;            y3 = c3;</b>
&nbsp;
<b class="nc">&nbsp;            m0 = c5;</b>
<b class="nc">&nbsp;            m1 = c6;</b>
&nbsp;
<b class="nc">&nbsp;            d0 = c8;</b>
<b class="nc">&nbsp;            d1 = c9;</b>
&nbsp;
<b class="nc">&nbsp;            h0 = c11;</b>
<b class="nc">&nbsp;            h1 = c12;</b>
&nbsp;
<b class="nc">&nbsp;            i0 = c14;</b>
<b class="nc">&nbsp;            i1 = c15;</b>
&nbsp;
<b class="nc">&nbsp;            s0 = c17;</b>
<b class="nc">&nbsp;            s1 = c18;</b>
&nbsp;
<b class="nc">&nbsp;            S0 = &#39;0&#39;;</b>
<b class="nc">&nbsp;            S1 = &#39;0&#39;;</b>
<b class="nc">&nbsp;            S2 = &#39;0&#39;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int year;
<b class="fc">&nbsp;        if (y0 &gt;= &#39;0&#39; &amp;&amp; y0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; y1 &gt;= &#39;0&#39; &amp;&amp; y1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y2 &gt;= &#39;0&#39; &amp;&amp; y2 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; y3 &gt;= &#39;0&#39; &amp;&amp; y3 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            year = (y0 - &#39;0&#39;) * 1000 + (y1 - &#39;0&#39;) * 100 + (y2 - &#39;0&#39;) * 10 + (y3 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int month;
<b class="fc">&nbsp;        if (m0 &gt;= &#39;0&#39; &amp;&amp; m0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; m1 &gt;= &#39;0&#39; &amp;&amp; m1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            month = (m0 - &#39;0&#39;) * 10 + (m1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int dom;
<b class="fc">&nbsp;        if (d0 &gt;= &#39;0&#39; &amp;&amp; d0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; d1 &gt;= &#39;0&#39; &amp;&amp; d1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            dom = (d0 - &#39;0&#39;) * 10 + (d1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int hour;
<b class="fc">&nbsp;        if (h0 &gt;= &#39;0&#39; &amp;&amp; h0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; h1 &gt;= &#39;0&#39; &amp;&amp; h1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            hour = (h0 - &#39;0&#39;) * 10 + (h1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int minute;
<b class="fc">&nbsp;        if (i0 &gt;= &#39;0&#39; &amp;&amp; i0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; i1 &gt;= &#39;0&#39; &amp;&amp; i1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            minute = (i0 - &#39;0&#39;) * 10 + (i1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int second;
<b class="fc">&nbsp;        if (s0 &gt;= &#39;0&#39; &amp;&amp; s0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; s1 &gt;= &#39;0&#39; &amp;&amp; s1 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            second = (s0 - &#39;0&#39;) * 10 + (s1 - &#39;0&#39;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        int millis;
<b class="fc">&nbsp;        if (S0 &gt;= &#39;0&#39; &amp;&amp; S0 &lt;= &#39;9&#39;</b>
&nbsp;                &amp;&amp; S1 &gt;= &#39;0&#39; &amp;&amp; S1 &lt;= &#39;9&#39;
&nbsp;                &amp;&amp; S2 &gt;= &#39;0&#39; &amp;&amp; S2 &lt;= &#39;9&#39;
&nbsp;        ) {
<b class="fc">&nbsp;            millis = (S0 - &#39;0&#39;) * 100</b>
&nbsp;                    + (S1 - &#39;0&#39;) * 10
&nbsp;                    + (S2 - &#39;0&#39;);
<b class="fc">&nbsp;            millis *= 1000_000;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        LocalDateTime ldt = LocalDateTime.of(year, month, dom, hour, minute, second, millis);</b>
&nbsp;
<b class="fc">&nbsp;        offset += 20;</b>
<b class="fc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected LocalDateTime readLocalDateTimeX(int len) {
<b class="fc">&nbsp;        type = bytes[offset];</b>
<b class="fc">&nbsp;        if (type &lt; BC_STR_ASCII_FIX_MIN || type &gt; BC_STR_ASCII_FIX_MAX) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;date only support string input&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (len &lt; 21 || len &gt; 29) {</b>
<b class="nc">&nbsp;            throw new JSONException(&quot;illeal localdatetime string : &quot; + readString());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte c0 = bytes[offset + 1];</b>
<b class="fc">&nbsp;        byte c1 = bytes[offset + 2];</b>
<b class="fc">&nbsp;        byte c2 = bytes[offset + 3];</b>
<b class="fc">&nbsp;        byte c3 = bytes[offset + 4];</b>
<b class="fc">&nbsp;        byte c4 = bytes[offset + 5];</b>
<b class="fc">&nbsp;        byte c5 = bytes[offset + 6];</b>
<b class="fc">&nbsp;        byte c6 = bytes[offset + 7];</b>
<b class="fc">&nbsp;        byte c7 = bytes[offset + 8];</b>
<b class="fc">&nbsp;        byte c8 = bytes[offset + 9];</b>
<b class="fc">&nbsp;        byte c9 = bytes[offset + 10];</b>
<b class="fc">&nbsp;        byte c10 = bytes[offset + 11];</b>
<b class="fc">&nbsp;        byte c11 = bytes[offset + 12];</b>
<b class="fc">&nbsp;        byte c12 = bytes[offset + 13];</b>
<b class="fc">&nbsp;        byte c13 = bytes[offset + 14];</b>
<b class="fc">&nbsp;        byte c14 = bytes[offset + 15];</b>
<b class="fc">&nbsp;        byte c15 = bytes[offset + 16];</b>
<b class="fc">&nbsp;        byte c16 = bytes[offset + 17];</b>
<b class="fc">&nbsp;        byte c17 = bytes[offset + 18];</b>
<b class="fc">&nbsp;        byte c18 = bytes[offset + 19];</b>
<b class="fc">&nbsp;        byte c19 = bytes[offset + 20];</b>
<b class="fc">&nbsp;        byte c20, c21 = &#39;0&#39;, c22 = &#39;0&#39;, c23 = &#39;0&#39;, c24 = &#39;0&#39;, c25 = &#39;0&#39;, c26 = &#39;0&#39;, c27 = &#39;0&#39;, c28 = &#39;0&#39;;</b>
<b class="fc">&nbsp;        switch (len) {</b>
&nbsp;            case 21:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 22:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 23:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 24:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 25:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                c24 = bytes[offset + 25];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 26:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                c24 = bytes[offset + 25];</b>
<b class="fc">&nbsp;                c25 = bytes[offset + 26];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 27:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                c24 = bytes[offset + 25];</b>
<b class="fc">&nbsp;                c25 = bytes[offset + 26];</b>
<b class="fc">&nbsp;                c26 = bytes[offset + 27];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 28:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                c24 = bytes[offset + 25];</b>
<b class="fc">&nbsp;                c25 = bytes[offset + 26];</b>
<b class="fc">&nbsp;                c26 = bytes[offset + 27];</b>
<b class="fc">&nbsp;                c27 = bytes[offset + 28];</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            default:
<b class="fc">&nbsp;                c20 = bytes[offset + 21];</b>
<b class="fc">&nbsp;                c21 = bytes[offset + 22];</b>
<b class="fc">&nbsp;                c22 = bytes[offset + 23];</b>
<b class="fc">&nbsp;                c23 = bytes[offset + 24];</b>
<b class="fc">&nbsp;                c24 = bytes[offset + 25];</b>
<b class="fc">&nbsp;                c25 = bytes[offset + 26];</b>
<b class="fc">&nbsp;                c26 = bytes[offset + 27];</b>
<b class="fc">&nbsp;                c27 = bytes[offset + 28];</b>
<b class="fc">&nbsp;                c28 = bytes[offset + 29];</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        char y0, y1, y2, y3, m0, m1, d0, d1, h0, h1, i0, i1, s0, s1, S0, S1, S2, S3, S4, S5, S6, S7, S8;
<b class="fc">&nbsp;        if (c4 == &#39;-&#39; &amp;&amp; c7 == &#39;-&#39; &amp;&amp; (c10 == &#39; &#39; || c10 == &#39;T&#39;) &amp;&amp; c13 == &#39;:&#39; &amp;&amp; c16 == &#39;:&#39; &amp;&amp; c19 == &#39;.&#39;) {</b>
<b class="fc">&nbsp;            y0 = (char) c0;</b>
<b class="fc">&nbsp;            y1 = (char) c1;</b>
<b class="fc">&nbsp;            y2 = (char) c2;</b>
<b class="fc">&nbsp;            y3 = (char) c3;</b>
&nbsp;
<b class="fc">&nbsp;            m0 = (char) c5;</b>
<b class="fc">&nbsp;            m1 = (char) c6;</b>
&nbsp;
<b class="fc">&nbsp;            d0 = (char) c8;</b>
<b class="fc">&nbsp;            d1 = (char) c9;</b>
&nbsp;
<b class="fc">&nbsp;            h0 = (char) c11;</b>
<b class="fc">&nbsp;            h1 = (char) c12;</b>
&nbsp;
<b class="fc">&nbsp;            i0 = (char) c14;</b>
<b class="fc">&nbsp;            i1 = (char) c15;</b>
&nbsp;
<b class="fc">&nbsp;            s0 = (char) c17;</b>
<b class="fc">&nbsp;            s1 = (char) c18;</b>
&nbsp;
<b class="fc">&nbsp;            S0 = (char) c20;</b>
<b class="fc">&nbsp;            S1 = (char) c21;</b>
<b class="fc">&nbsp;            S2 = (char) c22;</b>
<b class="fc">&nbsp;            S3 = (char) c23;</b>
<b class="fc">&nbsp;            S4 = (char) c24;</b>
<b class="fc">&nbsp;            S5 = (char) c25;</b>
<b class="fc">&nbsp;            S6 = (char) c26;</b>
<b class="fc">&nbsp;            S7 = (char) c27;</b>
<b class="fc">&nbsp;            S8 = (char) c28;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        LocalDateTime ldt = localDateTime(y0, y1, y2, y3, m0, m1, d0, d1, h0, h1, i0, i1, s0, s1, S0, S1, S2, S3, S4, S5, S6, S7, S8);</b>
<b class="fc">&nbsp;        if (ldt == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        offset += (len + 1);</b>
<b class="fc">&nbsp;        return ldt;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String readPattern() {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2) {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long readFieldNameHashCodeUnquote() {
<b class="fc">&nbsp;        return readFieldNameHashCode();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfSet() {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2, char c3) {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean nextIfMatchIdent(char c0, char c1, char c2, char c3, char c4, char c5) {
<b class="fc">&nbsp;        throw new JSONException(&quot;UnsupportedOperation&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final void close() {
<b class="fc">&nbsp;        if (valueBytes != null) {</b>
<b class="nc">&nbsp;            JSONFactory.releaseByteArray(cachedIndex, valueBytes);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 21:52</div>
</div>
</body>
</html>
