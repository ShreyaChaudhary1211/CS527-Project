[<Line: +import htsjdk.samtools.util.CloseableIterator;
>, <Line: +import htsjdk.variant.variantcontext.VariantContext;
>, <Line: +	protected final DatabaseVariantContextProvider variantProvider;
>, <Line: +	 * @param variantProvider
>, <Line: +	 *            {@link DatabaseVariantContextProvider} for querying database for
>, <Line: +	 *            {@link VariantContext} objects describing annotations from database.
>, <Line: +	public AbstractDBAnnotationDriver(DatabaseVariantContextProvider variantProvider, String fastaPath,
>, <Line: +			DBAnnotationOptions options, VariantContextToRecordConverter<RecordType> vcToRecord)
>, <Line: +			throws JannovarVarDBException {
>, <Line: +		this.variantProvider = variantProvider;
>, <Line: +		try (CloseableIterator<VariantContext> iter = variantProvider.query(obsVC.getContig(), obsVC.getStart() - 1,
>, <Line: +			// Fetch all overlapping and matching genotypes from database and pair them with the
>, <Line: +			// correct allele from vc.
>, <Line: +			// Use these records to annotate the variant call in obsVC (record-wise but also per
>, <Line: +			// alternative allele)
>, <Line: +	 * For SNVs, there should only be one value in the value set at which all alleles point to for
>, <Line: +	 * most cases. The selection of the record for each observed allele is delegated to the
>, <Line: +	 * subclass' {@link #pickAnnotatingDBRecords}.
>, <Line: +	 *            List of {@link GenotypeMatch} objects to build the annotating database records
>, <Line: +	 *            from
>, <Line: +	 *            whether or not to consider true matching alleles (<code>true</code>) or only
>, <Line: +	 *            position-based overlaps (<code>false</code>)
>, <Line: +	 * @return Resulting map from alternative observed allele ID (starting with 1) to the database
>, <Line: +	 *         record to use
>, <Line: +	 *            whether or not to consider true matching alleles (<code>true</code>) or only
>, <Line: +	 *            position-based overlaps (<code>false</code>)
>, <Line: +	 * There can be more than one database record, for example in the case that a SNV is squished
>, <Line: +	 * together with an indel.
>, <Line: +	 *            Map from alternative allele index to annotating <code>RecordType</code> with
>, <Line: +	 *            matching allele
>, <Line: +	 *            Map from alternative allele index to annotating <code>RecordType</code> with
>, <Line: +	 *            overlapping positions
>]
[<Line: -import java.io.File;
>, <Line: -import htsjdk.samtools.util.CloseableIterator;
>, <Line: -import htsjdk.variant.variantcontext.VariantContext;
>, <Line: -import htsjdk.variant.vcf.VCFFileReader;
>, <Line: -	protected final String vcfPath;
>, <Line: -	/** VCFReader to use for loading the VCF records */
>, <Line: -	protected final VCFFileReader vcfReader;
>, <Line: -	 * @param fastaPath
>, <Line: -	 *            FAI-indexed FASTA file with reference
>, <Line: -	public AbstractDBAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options,
>, <Line: -			VariantContextToRecordConverter<RecordType> vcToRecord) throws JannovarVarDBException {
>, <Line: -		this.vcfPath = vcfPath;
>, <Line: -		this.vcfReader = new VCFFileReader(new File(this.vcfPath), true);
>, <Line: -		try (CloseableIterator<VariantContext> iter = vcfReader.query(obsVC.getContig(), obsVC.getStart(),
>, <Line: -			// Fetch all overlapping and matching genotypes from database and pair them with the correct allele from vc.
>, <Line: -			// Use these records to annotate the variant call in obsVC (record-wise but also per alternative allele)
>, <Line: -	 * For SNVs, there should only be one value in the value set at which all alleles point to for most cases. The
>, <Line: -	 * selection of the record for each observed allele is delegated to the subclass' {@link #pickAnnotatingDBRecords}.
>, <Line: -	 *            List of {@link GenotypeMatch} objects to build the annotating database records from
>, <Line: -	 *            whether or not to consider true matching alleles (<code>true</code>) or only position-based overlaps
>, <Line: -	 *            (<code>false</code>)
>, <Line: -	 * @return Resulting map from alternative observed allele ID (starting with 1) to the database record to use
>, <Line: -	 *            whether or not to consider true matching alleles (<code>true</code>) or only position-based overlaps
>, <Line: -	 *            (<code>false</code>)
>, <Line: -	 * There can be more than one database record, for example in the case that a SNV is squished together with an
>, <Line: -	 * indel.
>, <Line: -	 *            Map from alternative allele index to annotating <code>RecordType</code> with matching allele
>, <Line: -	 *            Map from alternative allele index to annotating <code>RecordType</code> with overlapping positions
>]