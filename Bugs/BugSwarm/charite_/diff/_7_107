[<Line: +package de.charite.compbio.jannovar.mendel.bridge;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Map.Entry;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableMap;
>, <Line: +import com.google.common.collect.Lists;
>, <Line: +import de.charite.compbio.jannovar.mendel.ChromosomeType;
>, <Line: +import de.charite.compbio.jannovar.mendel.GenotypeBuilder;
>, <Line: +import de.charite.compbio.jannovar.mendel.GenotypeCalls;
>, <Line: +import de.charite.compbio.jannovar.mendel.GenotypeCallsBuilder;
>, <Line: +import de.charite.compbio.jannovar.mendel.IncompatiblePedigreeException;
>, <Line: +import de.charite.compbio.jannovar.mendel.MendelianInheritanceChecker;
>, <Line: +import de.charite.compbio.jannovar.mendel.ModeOfInheritance;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Pedigree;
>, <Line: +import htsjdk.variant.variantcontext.Allele;
>, <Line: +import htsjdk.variant.variantcontext.Genotype;
>, <Line: +import htsjdk.variant.variantcontext.VariantContext;
>, <Line: +import htsjdk.variant.variantcontext.VariantContextBuilder;
>, <Line: +/**
>, <Line: + * Helper class for annotating one {@link VariantContext} or a {@link Collection} thereof for compatibility with
>, <Line: + * Mendelian inheritance
>, <Line: + * 
>, <Line: + * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
>, <Line: + */
>, <Line: +public class VariantContextMendelianAnnotator {
>, <Line: +	/** Pedigree to use for checking for Mendelian compatibility */
>, <Line: +	private final Pedigree pedigree;
>, <Line: +	/** Implementation class to usee */
>, <Line: +	private final MendelianInheritanceChecker mendelChecker;
>, <Line: +	public VariantContextMendelianAnnotator(Pedigree pedigree) {
>, <Line: +		this.pedigree = pedigree;
>, <Line: +		this.mendelChecker = new MendelianInheritanceChecker(this.pedigree);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Annotate {@link VariantContext} with compatibility for Mendelian inheritance
>, <Line: +	 * 
>, <Line: +	 * @param vc
>, <Line: +	 *            {@link VariantContext} to check for compatibility and to annotate
>, <Line: +	 * @return Copy of <code>vc</code> with mendelian inheritance compatibility annotation
>, <Line: +	 * @throws CannotateAnnotateMendelianInheritance
>, <Line: +	 *             on problems with annotating the {@link VariantContext}
>, <Line: +	 */
>, <Line: +	public VariantContext annotateRecord(VariantContext vc) throws CannotateAnnotateMendelianInheritance {
>, <Line: +		return annotateRecords(ImmutableList.of(vc)).get(0);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Annotate {@link List} of {@link VariantContext} objects
>, <Line: +	 * 
>, <Line: +	 * @param vcs
>, <Line: +	 *            {@link VariantContext} objects to annotate
>, <Line: +	 * @return An {@link ImmutableList} of {@link VariantContext} copies of <code>vcs</code>
>, <Line: +	 * @throws CannotateAnnotateMendelianInheritance
>, <Line: +	 *             on problems with annotating the {@link VariantContext}s
>, <Line: +	 */
>, <Line: +	public ImmutableList<VariantContext> annotateRecords(List<VariantContext> vcs)
>, <Line: +			throws CannotateAnnotateMendelianInheritance {
>, <Line: +		// Convert VariantContext to GenotypeCalls objects
>, <Line: +		List<GenotypeCalls> gcs = buildGenotypeCalls(vcs);
>, <Line: +		ImmutableMap<ModeOfInheritance, ImmutableList<GenotypeCalls>> checkResult;
>, <Line: +		try {
>, <Line: +			checkResult = mendelChecker.checkMendelianInheritance(gcs);
>, <Line: +		} catch (IncompatiblePedigreeException e) {
>, <Line: +			throw new CannotateAnnotateMendelianInheritance(
>, <Line: +					"Problem with annotating VariantContext for Mendelian inheritance.", e);
>, <Line: +		}
>, <Line: +		// Build map of compatible Mendelian inheritance modes for each record
>, <Line: +		HashMap<Integer, ArrayList<String>> map = new HashMap<>();
>, <Line: +		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
>, <Line: +			final ModeOfInheritance mode = e.getKey();
>, <Line: +			final ImmutableList<GenotypeCalls> calls = e.getValue();
>, <Line: +			for (GenotypeCalls gc : calls) {
>, <Line: +				Integer key = (Integer) gc.getPayload();
>, <Line: +				map.putIfAbsent(key, Lists.newArrayList());
>, <Line: +				switch (mode) {
>, <Line: +				case AUTOSOMAL_DOMINANT:
>, <Line: +					map.get(key).add("AD");
>, <Line: +					break;
>, <Line: +				case AUTOSOMAL_RECESSIVE:
>, <Line: +					map.get(key).add("AR");
>, <Line: +					break;
>, <Line: +				case X_DOMINANT:
>, <Line: +					map.get(key).add("XD");
>, <Line: +					break;
>, <Line: +				case X_RECESSIVE:
>, <Line: +					map.get(key).add("XR");
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					break; // ignore
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Construct extended VariantContext objects with INHERITED attribute
>, <Line: +		ArrayList<VariantContextBuilder> vcBuilders = new ArrayList<>();
>, <Line: +		for (int i = 0; i < vcs.size(); ++i)
>, <Line: +			vcBuilders.add(new VariantContextBuilder(vcs.get(i)));
>, <Line: +		for (Entry<Integer, ArrayList<String>> e : map.entrySet()) {
>, <Line: +			VariantContextBuilder vcBuilder = vcBuilders.get(e.getKey());
>, <Line: +			vcBuilder.attribute(MendelVCFHeaderExtender.key(), map.values());
>, <Line: +		}
>, <Line: +		// Build final result list
>, <Line: +		ImmutableList.Builder<VariantContext> resultBuilder = new ImmutableList.Builder<>();
>, <Line: +		for (int i = 0; i < vcs.size(); ++i)
>, <Line: +			resultBuilder.add(vcBuilders.get(i).make());
>, <Line: +		return resultBuilder.build();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Compute compatible modes of inheritance for a list of {@link VariantContext} objects
>, <Line: +	 * 
>, <Line: +	 * @param vcs
>, <Line: +	 *            {@link VariantContext} objects to check for compatibility
>, <Line: +	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of {@link VariantContext} in <code>vcs</code>
>, <Line: +	 *         that is compatible with each mode
>, <Line: +	 * @throws CannotateAnnotateMendelianInheritance
>, <Line: +	 *             on problems with annotating mendelian inheritance
>, <Line: +	 */
>, <Line: +	public ImmutableMap<ModeOfInheritance, ImmutableList<VariantContext>> computeCompatibleInheritanceModes(
>, <Line: +			List<VariantContext> vcs) throws CannotateAnnotateMendelianInheritance {
>, <Line: +		// Perform annotation, preceded by building GenotypeCalls list
>, <Line: +		List<GenotypeCalls> gcs = buildGenotypeCalls(vcs);
>, <Line: +		ImmutableMap<ModeOfInheritance, ImmutableList<GenotypeCalls>> checkResult;
>, <Line: +		try {
>, <Line: +			checkResult = mendelChecker.checkMendelianInheritance(gcs);
>, <Line: +		} catch (IncompatiblePedigreeException e) {
>, <Line: +			throw new CannotateAnnotateMendelianInheritance(
>, <Line: +					"Problem with annotating VariantContext for Mendelian inheritance.", e);
>, <Line: +		}
>, <Line: +		// Build final result
>, <Line: +		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<VariantContext>> builder = new ImmutableMap.Builder<>();
>, <Line: +		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
>, <Line: +			ImmutableList.Builder<VariantContext> listBuilder = new ImmutableList.Builder<>();
>, <Line: +			for (GenotypeCalls gc : e.getValue())
>, <Line: +				listBuilder.add((VariantContext) gc.getPayload());
>, <Line: +			builder.put(e.getKey(), listBuilder.build());
>, <Line: +		}
>, <Line: +		return builder.build();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert a {@link List} of {@link VariantContext} objects into a list of {@link GenotypeCalls} objects
>, <Line: +	 * 
>, <Line: +	 * @param vcs
>, <Line: +	 *            input {@link Collection} of {@link VariantContext} objects
>, <Line: +	 * @return {@link List} of corresponding {@link GenotypeCalls} objects
>, <Line: +	 */
>, <Line: +	private List<GenotypeCalls> buildGenotypeCalls(Collection<VariantContext> vcs) {
>, <Line: +		ArrayList<GenotypeCalls> result = new ArrayList<>();
>, <Line: +		final ImmutableList<String> xNames = ImmutableList.of("x", "X", "23", "chrx", "chrX", "chr23");
>, <Line: +		final ImmutableList<String> mtNames = ImmutableList.of("m", "M", "mt", "MT", "chrm", "chrM", "chrmt", "chrMT");
>, <Line: +		for (VariantContext vc : vcs) {
>, <Line: +			GenotypeCallsBuilder builder = new GenotypeCallsBuilder();
>, <Line: +			builder.setPayload(vc);
>, <Line: +			if (xNames.contains(vc.getContig()))
>, <Line: +				builder.setChromType(ChromosomeType.X_CHROMOSOMAL);
>, <Line: +			else if (mtNames.contains(vc.getContig()))
>, <Line: +				builder.setChromType(ChromosomeType.MITOCHONDRIAL);
>, <Line: +			else
>, <Line: +				builder.setChromType(ChromosomeType.AUTOSOMAL);
>, <Line: +			for (Genotype gt : vc.getGenotypes()) {
>, <Line: +				GenotypeBuilder gtBuilder = new GenotypeBuilder();
>, <Line: +				for (Allele allele : gt.getAlleles()) {
>, <Line: +					final int aIDX = vc.getAlleleIndex(allele);
>, <Line: +					gtBuilder.getAlleleNumbers().add(aIDX);
>, <Line: +				}
>, <Line: +				builder.getSampleToGenotype().put(gt.getSampleName(), gtBuilder.build());
>, <Line: +			}
>, <Line: +			result.add(builder.build());
>, <Line: +		}
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +}
>]
[]