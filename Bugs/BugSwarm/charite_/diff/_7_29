[<Line: +package de.charite.compbio.jannovar.mendel.impl;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.HashSet;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Set;
>, <Line: +import java.util.stream.Collectors;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableMap;
>, <Line: +import de.charite.compbio.jannovar.mendel.ChromosomeType;
>, <Line: +import de.charite.compbio.jannovar.mendel.Genotype;
>, <Line: +import de.charite.compbio.jannovar.mendel.GenotypeCalls;
>, <Line: +import de.charite.compbio.jannovar.mendel.IncompatiblePedigreeException;
>, <Line: +import de.charite.compbio.jannovar.mendel.MendelianInheritanceChecker;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Disease;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Pedigree;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Person;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Sex;
>, <Line: +// TODO: also return no-call/not-observed variant
>, <Line: +/**
>, <Line: + * Helper class for checking a {@link GenotypeCalls} for compatibility with a {@link Pedigree} and X recessive compound
>, <Line: + * het. mode of inheritance.
>, <Line: + *
>, <Line: + * <h2>Compatibility Check</h2>
>, <Line: + *
>, <Line: + * In the case of a single individual, we require at least two het. genotype calls.
>, <Line: + *
>, <Line: + * In the case of multiple individuals, we require that the affects are compatible, that the parents of affected
>, <Line: + * individuals. Be careful, that the father must be {@link Disease#AFFECTED}. Therefore the father should be
>, <Line: + * {@link Disease#AFFECTED} and hom. alt.. We will allow het. because of miscalls.
>, <Line: + * 
>, <Line: + * Unaffected mothers are not are not hom. ref. for one allele, and that all unaffected individuals are not hom. alt.
>, <Line: + * and should not have it comp. het (only possible if parents are available).
>, <Line: + *
>, <Line: + * @author <a href="mailto:manuel.holtgrewe@charite.de">Manuel Holtgrewe</a>
>, <Line: + * @author <a href="mailto:max.schubach@charite.de">Max Schubach</a>
>, <Line: + * @author <a href="mailto:peter.robinson@charite.de">Peter N Robinson</a>
>, <Line: + */
>, <Line: +public class MendelianCheckerXRCompoundHet extends AbstractMendelianChecker {
>, <Line: +	/** list of siblings for each person in {@link #pedigree} */
>, <Line: +	private final ImmutableMap<Person, ImmutableList<Person>> siblings;
>, <Line: +	public MendelianCheckerXRCompoundHet(MendelianInheritanceChecker parent) {
>, <Line: +		super(parent);
>, <Line: +		this.siblings = queryDecorator.buildSiblings();
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public ImmutableList<GenotypeCalls> filterCompatibleRecords(Collection<GenotypeCalls> calls)
>, <Line: +			throws IncompatiblePedigreeException {
>, <Line: +		List<GenotypeCalls> xCalls = calls.stream().filter(call -> call.getChromType() == ChromosomeType.X_CHROMOSOMAL)
>, <Line: +				.collect(Collectors.toList());
>, <Line: +		if (pedigree.getNMembers() == 1)
>, <Line: +			return filterCompatibleRecordsSingleSample(xCalls);
>, <Line: +		else
>, <Line: +			return filterCompatibleRecordsMultiSample(xCalls);
>, <Line: +	}
>, <Line: +	private ImmutableList<GenotypeCalls> filterCompatibleRecordsSingleSample(Collection<GenotypeCalls> calls) {
>, <Line: +		if (pedigree.getMembers().get(0).getSex() == Sex.MALE)
>, <Line: +			return ImmutableList.of();
>, <Line: +		else
>, <Line: +			return new MendelianCheckerARCompoundHet(parent).filterCompatibleRecordsSingleSample(calls);
>, <Line: +	}
>, <Line: +	private ImmutableList<GenotypeCalls> filterCompatibleRecordsMultiSample(Collection<GenotypeCalls> calls) {
>, <Line: +		List<GenotypeCalls> autosomalCalls = calls.stream()
>, <Line: +				.filter(call -> call.getChromType() == ChromosomeType.AUTOSOMAL).collect(Collectors.toList());
>, <Line: +		// First, collect candidate genotype call lists from trios around affected individuals
>, <Line: +		ArrayList<Candidate> candidates = collectTrioCandidates(autosomalCalls);
>, <Line: +		// Then, check the candidates for all trios around affected individuals
>, <Line: +		Set<GenotypeCalls> result = new HashSet<>();
>, <Line: +		for (Candidate c : candidates) {
>, <Line: +			if (isCompatibleWithTriosAroundAffected(c)) {
>, <Line: +				// If candidate holds, check all unaffected for not being homozygous alt
>, <Line: +				if (isCompatibleWithUnaffected(c)) {
>, <Line: +					result.add(c.getMaternal());
>, <Line: +					result.add(c.getPaternal());
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return ImmutableList.copyOf(result);
>, <Line: +	}
>, <Line: +	private ArrayList<Candidate> collectTrioCandidates(Collection<GenotypeCalls> calls) {
>, <Line: +		ArrayList<Candidate> result = new ArrayList<Candidate>();
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			if (p.getDisease() == Disease.AFFECTED && (p.getFather() != null || p.getMother() != null)) {
>, <Line: +				List<GenotypeCalls> paternal = new ArrayList<GenotypeCalls>();
>, <Line: +				List<GenotypeCalls> maternal = new ArrayList<GenotypeCalls>();
>, <Line: +				for (GenotypeCalls gc : calls) {
>, <Line: +					// Child is heterozygous. male child/ukn can be homozygous
>, <Line: +					if ((gc.getGenotypeForSample(p.getName()).isHet()
>, <Line: +							|| gc.getGenotypeForSample(p.getName()).isNotObserved()
>, <Line: +							|| (p.getSex() != Sex.FEMALE && gc.getGenotypeForSample(p.getName()).isHomAlt()))) {
>, <Line: +						// collect candidates towards the paternal side
>, <Line: +						// (heterozygous (false call in father) or not observed
>, <Line: +						// in child and father. Not hom_alt or het in mother).
>, <Line: +						if ((p.getFather() == null || gc.getGenotypeForSample(p.getFather().getName()).isHet()
>, <Line: +								|| gc.getGenotypeForSample(p.getFather().getName()).isNotObserved()
>, <Line: +								|| gc.getGenotypeForSample(p.getFather().getName()).isHomAlt())
>, <Line: +								&& (p.getMother() == null
>, <Line: +										|| gc.getGenotypeForSample(p.getMother().getName()).isNotObserved()
>, <Line: +										|| gc.getGenotypeForSample(p.getMother().getName()).isHomRef()))
>, <Line: +							paternal.add(gc);
>, <Line: +						// collect candidates towards the maternal side
>, <Line: +						// (heterozygous or not observed in child and mother.
>, <Line: +						// For father no restriction, cause father should be affected if present.
>, <Line: +						if ((p.getMother() == null || gc.getGenotypeForSample(p.getMother().getName()).isHet()
>, <Line: +								|| gc.getGenotypeForSample(p.getMother().getName()).isNotObserved()))
>, <Line: +							maternal.add(gc);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				// Combine compatible paternal and maternal heterozygous variants
>, <Line: +				for (GenotypeCalls pat : paternal)
>, <Line: +					for (GenotypeCalls mat : maternal) {
>, <Line: +						if (pat == mat) // FIXME what means this NOW?
>, <Line: +							continue; // exclude if variants are identical
>, <Line: +						if (pat.getGenotypeForSample(p.getName()).isNotObserved()
>, <Line: +								&& (p.getFather() == null
>, <Line: +										|| pat.getGenotypeForSample(p.getFather().getName()).isNotObserved())
>, <Line: +								&& (p.getMother() == null
>, <Line: +										|| pat.getGenotypeForSample(p.getMother().getName()).isNotObserved()))
>, <Line: +							continue; // exclude if not observed in all from paternal
>, <Line: +						if (mat.getGenotypeForSample(p.getName()).isNotObserved()
>, <Line: +								&& (p.getFather() == null
>, <Line: +										|| mat.getGenotypeForSample(p.getFather().getName()).isNotObserved())
>, <Line: +								&& (p.getMother() == null
>, <Line: +										|| mat.getGenotypeForSample(p.getMother().getName()).isNotObserved()))
>, <Line: +							continue; // exclude if not observed in all from maternal
>, <Line: +						result.add(new Candidate(pat, mat));
>, <Line: +					}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +	private boolean isCompatibleWithTriosAroundAffected(Candidate c) {
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			if (p.getDisease() == Disease.AFFECTED) {
>, <Line: +				// we have to check this for paternal,maternal and vice versa.
>, <Line: +				// Paternal maternal inheritance can be different for other
>, <Line: +				// parents in the pedigree.
>, <Line: +				if (!isCompatibleWithTriosAndMaternalPaternalInheritanceAroundAffected(p, c.getPaternal(),
>, <Line: +						c.getMaternal()))
>, <Line: +					if (!isCompatibleWithTriosAndMaternalPaternalInheritanceAroundAffected(p, c.getMaternal(),
>, <Line: +							c.getPaternal()))
>, <Line: +						return false;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +	private boolean isCompatibleWithTriosAndMaternalPaternalInheritanceAroundAffected(Person p, GenotypeCalls paternal,
>, <Line: +			GenotypeCalls maternal) {
>, <Line: +		// None of the genotypes from the paternal or maternal call lists may be homozygous in a female index. can be
>, <Line: +		// homozygous else
>, <Line: +		if (paternal != null) {
>, <Line: +			final Genotype pGT = paternal.getGenotypeForSample(p.getName());
>, <Line: +			if ((pGT.isHomAlt() && p.getSex() == Sex.FEMALE) || pGT.isHomRef())
>, <Line: +				return false;
>, <Line: +		}
>, <Line: +		if (maternal != null) {
>, <Line: +			final Genotype mGT = maternal.getGenotypeForSample(p.getName());
>, <Line: +			if (p.getSex() == Sex.FEMALE && (mGT.isHomAlt() && mGT.isHomRef()))
>, <Line: +				return false;
>, <Line: +		}
>, <Line: +		// the paternal variant may not be homozygous REF in the father of
>, <Line: +		// p, if any
>, <Line: +		if (paternal != null && p.getFather() != null) {
>, <Line: +			final Genotype pGT = paternal.getGenotypeForSample(p.getFather().getName());
>, <Line: +			if (pGT.isHomRef())
>, <Line: +				return false;
>, <Line: +		}
>, <Line: +		// the maternal variant may not be homozygous in the mother of
>, <Line: +		// p, if any
>, <Line: +		if (maternal != null && p.getMother() != null) {
>, <Line: +			final Genotype mGT = maternal.getGenotypeForSample(p.getMother().getName());
>, <Line: +			if (mGT.isHomAlt() || mGT.isHomRef())
>, <Line: +				return false;
>, <Line: +		}
>, <Line: +		// none of the unaffected siblings may have the same genotypes
>, <Line: +		// as p
>, <Line: +		if (siblings != null && !siblings.isEmpty() && siblings.containsKey(p))
>, <Line: +			for (Person sibling : siblings.get(p))
>, <Line: +				if (sibling.getDisease() == Disease.UNAFFECTED) {
>, <Line: +					final Genotype pGT = paternal.getGenotypeForSample(sibling.getName());
>, <Line: +					final Genotype mGT = maternal.getGenotypeForSample(sibling.getName());
>, <Line: +					if (pGT.isHet() && mGT.isHet())
>, <Line: +						return false;
>, <Line: +				}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +	private boolean isCompatibleWithUnaffected(Candidate c) {
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			if (p.getDisease() == Disease.UNAFFECTED) {
>, <Line: +				boolean patHet = false;
>, <Line: +				boolean matHet = false;
>, <Line: +				// None of the genotypes from the paternal or maternal call lists may be homozygous in the index
>, <Line: +				if (c.getPaternal() != null) {
>, <Line: +					final Genotype pGT = c.getPaternal().getGenotypeForSample(p.getName());
>, <Line: +					if (pGT.isHomAlt() || (p.getSex() == Sex.MALE && pGT.isHet()))
>, <Line: +						return false;
>, <Line: +					if (pGT.isHet())
>, <Line: +						patHet = true;
>, <Line: +				}
>, <Line: +				if (c.getMaternal() != null) {
>, <Line: +					final Genotype mGT = c.getMaternal().getGenotypeForSample(p.getName());
>, <Line: +					if (mGT.isHomAlt() || (p.getSex() == Sex.MALE && mGT.isHet()))
>, <Line: +						return false;
>, <Line: +					if (mGT.isHet())
>, <Line: +						matHet = true;
>, <Line: +				}
>, <Line: +				// If mat and pat variant are heterozygous in an unaffected, check if they are on the same allele or not
>, <Line: +				if (patHet && matHet) {
>, <Line: +					if (c.getPaternal() != null && p.getFather() != null && c.getMaternal() != null
>, <Line: +							&& p.getMother() != null) {
>, <Line: +						final Genotype ppGT = c.getPaternal().getGenotypeForSample(p.getFather().getName());
>, <Line: +						final Genotype mpGT = c.getPaternal().getGenotypeForSample(p.getMother().getName());
>, <Line: +						final Genotype pmGT = c.getMaternal().getGenotypeForSample(p.getFather().getName());
>, <Line: +						final Genotype mmGT = c.getMaternal().getGenotypeForSample(p.getMother().getName());
>, <Line: +						// way one (paternal and maternal can now be switched
>, <Line: +						// around!
>, <Line: +						if (ppGT.isHet() && mpGT.isHomRef() && pmGT.isHomRef() && mmGT.isHet())
>, <Line: +							return false;
>, <Line: +						if (ppGT.isHomRef() && mpGT.isHet() && pmGT.isHet() && mmGT.isHomRef())
>, <Line: +							return false;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +}
>]
[]