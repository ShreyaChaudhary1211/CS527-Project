[<Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import net.sourceforge.argparse4j.inf.Namespace;
>, <Line: +	/** Raw command line arguments */
>, <Line: +	private String[] argv = null;
>, <Line: +	/** Configuration */
>, <Line: +	private JannovarAnnotateVCFOptions options;
>, <Line: +	public AnnotateVCFCommand(String[] argv, Namespace args) throws CommandLineParsingException {
>, <Line: +		this.argv = argv;
>, <Line: +		this.options = new JannovarAnnotateVCFOptions();
>, <Line: +		this.options.setFromArgs(args);
>, <Line: +		System.err.println(options.toString());
>, <Line: +		System.err.println("Deserializing transcripts...");
>, <Line: +		deserializeTranscriptDefinitionFile(options.getDatabaseFilePath());
>, <Line: +		final String vcfPath = options.getPathInputVCF();
>, <Line: +		try (VCFFileReader vcfReader = new VCFFileReader(new File(vcfPath), false)) {
>, <Line: +			if (this.options.getVerbosity() >= 1) {
>, <Line: +				final SAMSequenceDictionary seqDict = VCFFileReader.getSequenceDictionary(new File(vcfPath));
>, <Line: +				final GenomeRegionListFactoryFromSAMSequenceDictionary factory = new GenomeRegionListFactoryFromSAMSequenceDictionary();
>, <Line: +				this.progressReporter = new ProgressReporter(factory.construct(seqDict), 60);
>, <Line: +				this.progressReporter.printHeader();
>, <Line: +				this.progressReporter.start();
>, <Line: +			}
>, <Line: +			VCFHeader vcfHeader = vcfReader.getFileHeader();
>, <Line: +			System.err.println("Annotating VCF...");
>, <Line: +			final long startTime = System.nanoTime();
>, <Line: +			Stream<VariantContext> stream = vcfReader.iterator().stream();
>, <Line: +			// If configured, annotate using dbSNP VCF file (extend header to use for writing out)
>, <Line: +			if (options.pathVCFDBSNP != null) {
>, <Line: +				DBAnnotationOptions dbSNPOptions = DBAnnotationOptions.createDefaults();
>, <Line: +				dbSNPOptions.setIdentifierPrefix(options.prefixDBSNP);
>, <Line: +				DBVariantContextAnnotator dbSNPAnno = new DBVariantContextAnnotatorFactory()
>, <Line: +						.constructDBSNP(options.pathVCFDBSNP, options.pathFASTARef, dbSNPOptions);
>, <Line: +				dbSNPAnno.extendHeader(vcfHeader);
>, <Line: +				stream = stream.map(dbSNPAnno::annotateVariantContext);
>, <Line: +			}
>, <Line: +			// If configured, annotate using ExAC VCF file (extend header to use for writing out)
>, <Line: +			if (options.pathVCFExac != null) {
>, <Line: +				DBAnnotationOptions exacOptions = DBAnnotationOptions.createDefaults();
>, <Line: +				exacOptions.setIdentifierPrefix(options.prefixExac);
>, <Line: +				DBVariantContextAnnotator exacAnno = new DBVariantContextAnnotatorFactory()
>, <Line: +						.constructExac(options.pathVCFExac, options.pathFASTARef, exacOptions);
>, <Line: +				exacAnno.extendHeader(vcfHeader);
>, <Line: +				stream = stream.map(exacAnno::annotateVariantContext);
>, <Line: +			// If configured, annotate using UK10K VCF file (extend header to use for writing out)
>, <Line: +			if (options.pathVCFUK10K != null) {
>, <Line: +				DBAnnotationOptions exacOptions = DBAnnotationOptions.createDefaults();
>, <Line: +				exacOptions.setIdentifierPrefix(options.prefixUK10K);
>, <Line: +				DBVariantContextAnnotator uk10kAnno = new DBVariantContextAnnotatorFactory()
>, <Line: +						.constructUK10K(options.pathVCFUK10K, options.pathFASTARef, exacOptions);
>, <Line: +				uk10kAnno.extendHeader(vcfHeader);
>, <Line: +				stream = stream.map(uk10kAnno::annotateVariantContext);
>, <Line: +			}
>, <Line: +			// Extend header with INHERITANCE filter
>, <Line: +			if (options.pathPedFile != null) {
>, <Line: +				System.err.println("Extending header with INHERITANCE...");
>, <Line: +				new MendelVCFHeaderExtender().extendHeader(vcfHeader, "");
>, <Line: +			}
>, <Line: +			// Write result to output file
>, <Line: +			try (AnnotatedVCFWriter writer = new AnnotatedVCFWriter(refDict, vcfHeader, chromosomeMap, vcfPath, options,
>, <Line: +					ImmutableList.copyOf(argv)); VariantContextProcessor sink = buildMendelianProcessors(writer);) {
>, <Line: +				// Make current VC available to progress printer
>, <Line: +				if (this.progressReporter != null)
>, <Line: +					stream = stream.peek(vc -> this.progressReporter.setCurrentVC(vc));
>, <Line: +				stream.forEachOrdered(sink::put);
>, <Line: +				System.err.println("Wrote annotations to \"" + options.getPathOutputVCF() + "\"");
>, <Line: +				final long endTime = System.nanoTime();
>, <Line: +				System.err.println(String.format("Annotation and writing took %.2f sec.",
>, <Line: +						(endTime - startTime) / 1000.0 / 1000.0 / 1000.0));
>, <Line: +			} catch (IOException e) {
>, <Line: +				throw new JannovarException("Problem opening file", e);
>, <Line: +			}
>, <Line: +		} catch (IncompatiblePedigreeException e) {
>, <Line: +			System.err.println("VCF file " + vcfPath + " is not compatible to pedigree file " + options.pathPedFile);
>, <Line: +		} catch (VariantContextFilterException e) {
>, <Line: +			System.err.println("There was a problem annotating the VCF file");
>, <Line: +			System.err.println("The error message was as follows.  The stack trace below the error "
>, <Line: +					+ "message can help the developers debug the problem.\n");
>, <Line: +			System.err.println(e.getMessage());
>, <Line: +			System.err.println("\n");
>, <Line: +			e.printStackTrace(System.err);
>, <Line: +			return;
>]
[<Line: -import org.apache.commons.cli.ParseException;
>, <Line: -import de.charite.compbio.jannovar.JannovarOptions;
>, <Line: -import de.charite.compbio.jannovar.cmd.HelpRequestedException;
>, <Line: -	public AnnotateVCFCommand(String[] argv) throws CommandLineParsingException, HelpRequestedException {
>, <Line: -		super(argv);
>, <Line: -		options.print(System.err);
>, <Line: -		deserializeTranscriptDefinitionFile();
>, <Line: -		for (String vcfPath : options.vcfFilePaths) {
>, <Line: -			// initialize the VCF reader
>, <Line: -			try (VCFFileReader vcfReader = new VCFFileReader(new File(vcfPath), false)) {
>, <Line: -				if (this.options.verbosity >= 1) {
>, <Line: -					final SAMSequenceDictionary seqDict = VCFFileReader.getSequenceDictionary(new File(vcfPath));
>, <Line: -					final GenomeRegionListFactoryFromSAMSequenceDictionary factory = new GenomeRegionListFactoryFromSAMSequenceDictionary();
>, <Line: -					this.progressReporter = new ProgressReporter(factory.construct(seqDict), 60);
>, <Line: -					this.progressReporter.printHeader();
>, <Line: -					this.progressReporter.start();
>, <Line: -				}
>, <Line: -				VCFHeader vcfHeader = vcfReader.getFileHeader();
>, <Line: -				System.err.println("Annotating VCF...");
>, <Line: -				final long startTime = System.nanoTime();
>, <Line: -				Stream<VariantContext> stream = vcfReader.iterator().stream();
>, <Line: -				// If configured, annotate using dbSNP VCF file (extend header to use for writing out)
>, <Line: -				if (options.pathVCFDBSNP != null) {
>, <Line: -					DBAnnotationOptions dbSNPOptions = DBAnnotationOptions.createDefaults();
>, <Line: -					dbSNPOptions.setIdentifierPrefix(options.prefixDBSNP);
>, <Line: -					DBVariantContextAnnotator dbSNPAnno = new DBVariantContextAnnotatorFactory()
>, <Line: -							.constructDBSNP(options.pathVCFDBSNP, options.pathFASTARef, dbSNPOptions);
>, <Line: -					dbSNPAnno.extendHeader(vcfHeader);
>, <Line: -					stream = stream.map(dbSNPAnno::annotateVariantContext);
>, <Line: -				}
>, <Line: -				// If configured, annotate using ExAC VCF file (extend header to use for writing out)
>, <Line: -				if (options.pathVCFExac != null) {
>, <Line: -					DBAnnotationOptions exacOptions = DBAnnotationOptions.createDefaults();
>, <Line: -					exacOptions.setIdentifierPrefix(options.prefixExac);
>, <Line: -					DBVariantContextAnnotator exacAnno = new DBVariantContextAnnotatorFactory()
>, <Line: -							.constructExac(options.pathVCFExac, options.pathFASTARef, exacOptions);
>, <Line: -					exacAnno.extendHeader(vcfHeader);
>, <Line: -					stream = stream.map(exacAnno::annotateVariantContext);
>, <Line: -				}
>, <Line: -				// If configured, annotate using UK10K VCF file (extend header to use for writing out)
>, <Line: -				if (options.pathVCFUK10K != null) {
>, <Line: -					DBAnnotationOptions exacOptions = DBAnnotationOptions.createDefaults();
>, <Line: -					exacOptions.setIdentifierPrefix(options.prefixUK10K);
>, <Line: -					DBVariantContextAnnotator uk10kAnno = new DBVariantContextAnnotatorFactory()
>, <Line: -							.constructUK10K(options.pathVCFUK10K, options.pathFASTARef, exacOptions);
>, <Line: -					uk10kAnno.extendHeader(vcfHeader);
>, <Line: -					stream = stream.map(uk10kAnno::annotateVariantContext);
>, <Line: -				}
>, <Line: -				// Extend header with INHERITANCE filter
>, <Line: -				if (options.pathPedFile != null) {
>, <Line: -					System.err.println("Extending header with INHERITANCE...");
>, <Line: -					new MendelVCFHeaderExtender().extendHeader(vcfHeader, "");
>, <Line: -				}
>, <Line: -				// Write result to output file
>, <Line: -				try (AnnotatedVCFWriter writer = new AnnotatedVCFWriter(refDict, vcfHeader, chromosomeMap, vcfPath,
>, <Line: -						options, args); VariantContextProcessor sink = buildMendelianProcessors(writer);) {
>, <Line: -					// Make current VC available to progress printer
>, <Line: -					if (this.progressReporter != null)
>, <Line: -						stream = stream.peek(vc -> this.progressReporter.setCurrentVC(vc));
>, <Line: -					stream.forEachOrdered(sink::put);
>, <Line: -					System.err.println("Wrote annotations to \"" + writer.getOutFileName() + "\"");
>, <Line: -					final long endTime = System.nanoTime();
>, <Line: -					System.err.println(String.format("Annotation and writing took %.2f sec.",
>, <Line: -							(endTime - startTime) / 1000.0 / 1000.0 / 1000.0));
>, <Line: -				} catch (IOException e) {
>, <Line: -					throw new JannovarException("Problem opening file", e);
>, <Line: -				}
>, <Line: -			} catch (IncompatiblePedigreeException e) {
>, <Line: -				System.err
>, <Line: -						.println("VCF file " + vcfPath + " is not compatible to pedigree file " + options.pathPedFile);
>, <Line: -			} catch (VariantContextFilterException e) {
>, <Line: -				System.err.println("There was a problem annotating the VCF file");
>, <Line: -				System.err.println("The error message was as follows.  The stack trace below the error "
>, <Line: -						+ "message can help the developers debug the problem.\n");
>, <Line: -				System.err.println(e.getMessage());
>, <Line: -				System.err.println("\n");
>, <Line: -				e.printStackTrace(System.err);
>, <Line: -				return;
>, <Line: -	@Override
>, <Line: -	protected JannovarOptions parseCommandLine(String[] argv)
>, <Line: -			throws CommandLineParsingException, HelpRequestedException {
>, <Line: -		AnnotateVCFCommandLineParser parser = new AnnotateVCFCommandLineParser();
>, <Line: -		try {
>, <Line: -			return parser.parse(argv);
>, <Line: -		} catch (ParseException e) {
>, <Line: -			throw new CommandLineParsingException("Could not parse the command line.", e);
>, <Line: -		}
>, <Line: -	}
>]