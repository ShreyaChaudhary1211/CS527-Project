[<Line: + * Helper class for annotating one {@link VariantContext} or a
>, <Line: + * {@link Collection} thereof for compatibility with Mendelian inheritance
>, <Line: +	private final static ImmutableSet<String> VAR_FILTERS = ImmutableSet
>, <Line: +			.of("AllAffGtFiltered", "MaxFreqAd", "MaxFreqAr", "OffExome");
>, <Line: +	private final static ImmutableSet<String> VAR_FILTERS_AD =
>, <Line: +			ImmutableSet.of("MaxFreqAd");
>, <Line: +	private final static ImmutableSet<String> VAR_FILTERS_AR =
>, <Line: +			ImmutableSet.of("MaxFreqAr");
>, <Line: +	private final static ImmutableSet<String> GT_FILTERS =
>, <Line: +			ImmutableSet.of("MaxCov", "MinGq");
>, <Line: +	private final static ImmutableSet<String> GT_FILTERS_HOM_REF =
>, <Line: +			ImmutableSet.of("MinAafHomRef");
>, <Line: +	private final static ImmutableSet<String> GT_FILTERS_HOM_ALT =
>, <Line: +			ImmutableSet.of("MinCovHomAlt", "MinAafHomAlt");
>, <Line: +	private final static ImmutableSet<String> GT_FILTERS_HET =
>, <Line: +			ImmutableSet.of("MinCovHet", "MinAafHet", "MaxAafHet");
>, <Line: +	public VariantContextMendelianAnnotator(Pedigree pedigree,
>, <Line: +			boolean interpretGenotypeFilters, boolean interpretVariantFilters) {
>, <Line: +	 * Annotate {@link VariantContext} with compatibility for Mendelian
>, <Line: +	 * inheritance
>, <Line: +	 *            {@link VariantContext} to check for compatibility and to
>, <Line: +	 *            annotate
>, <Line: +	 * @return Copy of <code>vc</code> with mendelian inheritance compatibility
>, <Line: +	 *         annotation
>, <Line: +	public VariantContext annotateRecord(VariantContext vc)
>, <Line: +			throws CannotAnnotateMendelianInheritance {
>, <Line: +	 * If <code>self.interpretVariantFilters</code> then the variant contexts to
>, <Line: +	 * be considered for compound heterozygous will be prefiltered to those with
>, <Line: +	 * appropriately high frequency and not being annotated as synonymous
>, <Line: +	 * variant.
>, <Line: +	 * @return An {@link ImmutableList} of {@link VariantContext} copies of
>, <Line: +	 *         <code>vcs</code>
>, <Line: +	public ImmutableList<VariantContext> annotateRecords(
>, <Line: +			List<VariantContext> vcs)
>, <Line: +		// Super-ugly mapping from variant context to index in vcs
>, <Line: +		Map<Integer, Integer> identityToIndex = new HashMap<>();
>, <Line: +		for (int i = 0; i < vcs.size(); i++) {
>, <Line: +			identityToIndex.put(System.identityHashCode(vcs.get(i)), i);
>, <Line: +		// Compute compatible sub types
>, <Line: +		ImmutableMap<SubModeOfInheritance, ImmutableList<VariantContext>> compatibleSubModes =
>, <Line: +				computeCompatibleInheritanceSubModes(vcs);
>, <Line: +		for (Entry<SubModeOfInheritance, ImmutableList<VariantContext>> e : compatibleSubModes
>, <Line: +				.entrySet()) {
>, <Line: +			final SubModeOfInheritance subMode = e.getKey();
>, <Line: +			for (VariantContext vc : e.getValue()) {
>, <Line: +				int key = identityToIndex.get(System.identityHashCode(vc));
>, <Line: +				switch (subMode) {
>, <Line: +		// Construct extended VariantContext objects with INHERITED and
>, <Line: +		// INHERITANCE_RECESSIVE_DETAIL attributes
>, <Line: +			vcBuilder.attribute(MendelVCFHeaderExtender.keySub(),
>, <Line: +					subMap.get(e.getKey()));
>, <Line: +		ImmutableList.Builder<VariantContext> resultBuilder =
>, <Line: +				new ImmutableList.Builder<>();
>, <Line: +	 * Compute compatible modes of inheritance for a list of
>, <Line: +	 * {@link VariantContext} objects
>, <Line: +	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of
>, <Line: +	 *         {@link VariantContext} in <code>vcs</code> that is compatible
>, <Line: +	 *         with each mode
>, <Line: +			List<VariantContext> vcs)
>, <Line: +			throws CannotAnnotateMendelianInheritance {
>, <Line: +		List<GenotypeCalls> recessiveGCs = buildRecessiveGenotypeCalls(vcs);
>, <Line: +			checkResult = mendelChecker.checkMendelianInheritance(gcs, recessiveGCs);
>, <Line: +					"Problem with annotating VariantContext for Mendelian inheritance.",
>, <Line: +					e);
>, <Line: +		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<VariantContext>> builder =
>, <Line: +				new ImmutableMap.Builder<>();
>, <Line: +		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult
>, <Line: +				.entrySet()) {
>, <Line: +			ImmutableList.Builder<VariantContext> listBuilder =
>, <Line: +					new ImmutableList.Builder<>();
>, <Line: +	 * Compute compatible modes of inheritance for a list of
>, <Line: +	 * {@link VariantContext} objects
>, <Line: +	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of
>, <Line: +	 *         {@link VariantContext} in <code>vcs</code> that is compatible
>, <Line: +	 *         with each mode
>, <Line: +			List<VariantContext> vcs)
>, <Line: +			throws CannotAnnotateMendelianInheritance {
>, <Line: +		List<GenotypeCalls> recessiveGCs = buildRecessiveGenotypeCalls(vcs);
>, <Line: +			checkResult = mendelChecker.checkMendelianInheritanceSub(gcs, recessiveGCs);
>, <Line: +					"Problem with annotating VariantContext for Mendelian inheritance.",
>, <Line: +					e);
>, <Line: +		ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<VariantContext>> builder =
>, <Line: +				new ImmutableMap.Builder<>();
>, <Line: +		for (Entry<SubModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult
>, <Line: +				.entrySet()) {
>, <Line: +			ImmutableList.Builder<VariantContext> listBuilder =
>, <Line: +					new ImmutableList.Builder<>();
>, <Line: +	 * Convert a {@link List} of {@link VariantContext} objects into a list of
>, <Line: +	 * {@link GenotypeCalls} objects
>, <Line: +	private List<GenotypeCalls> buildGenotypeCalls(
>, <Line: +			Collection<VariantContext> vcs) {
>, <Line: +		final ImmutableList<String> xNames =
>, <Line: +				ImmutableList.of("x", "X", "23", "chrx", "chrX", "chr23");
>, <Line: +		final ImmutableList<String> mtNames = ImmutableList.of("m", "M", "mt",
>, <Line: +				"MT", "chrm", "chrM", "chrmt", "chrMT");
>, <Line: +					if (interpretGenotypeFilters && isFiltered(gtFilters,
>, <Line: +							GT_FILTERS, GT_FILTERS_HET))
>, <Line: +					if (interpretGenotypeFilters && isFiltered(gtFilters,
>, <Line: +							GT_FILTERS, GT_FILTERS_HOM_REF))
>, <Line: +				} else { // hom-alt or two overlapping hets, treated the same
>, <Line: +						 // for filtration
>, <Line: +					if (interpretGenotypeFilters && isFiltered(gtFilters,
>, <Line: +							GT_FILTERS, GT_FILTERS_HOM_ALT))
>, <Line: +						gtBuilder.getAlleleNumbers().add(
>, <Line: +								de.charite.compbio.jannovar.mendel.Genotype.NO_CALL);
>, <Line: +				builder.getSampleToGenotype().put(gt.getSampleName(),
>, <Line: +						gtBuilder.build());
>, <Line: +	/**
>, <Line: +	 * Build and return List of GenotypeCalls object filtered with recessive
>, <Line: +	 * filter settings.
>, <Line: +	 */
>, <Line: +	List<GenotypeCalls> buildRecessiveGenotypeCalls(List<VariantContext> vcs) {
>, <Line: +		// TODO: filter for synonymous variant currently broken if annotating
>, <Line: +		// with all variants... :(
>, <Line: +		final String synonymous =
>, <Line: +				VariantEffect.SYNONYMOUS_VARIANT.getSequenceOntologyTerm();
>, <Line: +		// Filter functor for recessive filtration
>, <Line: +		Predicate<VariantContext> keepFreqRecessive;
>, <Line: +		if (interpretVariantFilters) {
>, <Line: +			// TODO: this needs refinement
>, <Line: +			keepFreqRecessive = vc -> {
>, <Line: +				return !isFiltered(vc.getFilters(), VAR_FILTERS, VAR_FILTERS_AR)
>, <Line: +						&& !vc.getAttributeAsString("ANN", "")
>, <Line: +								.contains(synonymous);
>, <Line: +			};
>, <Line: +		} else {
>, <Line: +			keepFreqRecessive = vc -> true;
>, <Line: +		}
>, <Line: +		return buildGenotypeCalls(vcs.stream().filter(keepFreqRecessive)
>, <Line: +				.collect(Collectors.toList()));
>, <Line: +	}
>, <Line: +	private boolean isFiltered(Collection<String> vcFilters,
>, <Line: +			Collection<String> filtersA, Collection<String> filtersB) {
>, <Line: +	private boolean isFiltered(Collection<String> vcFilters,
>, <Line: +			Collection<String> filtersA) {
>]
[<Line: - * Helper class for annotating one {@link VariantContext} or a {@link Collection} thereof for compatibility with
>, <Line: - * Mendelian inheritance
>, <Line: -	private final static ImmutableSet<String> VAR_FILTERS = ImmutableSet.of("AllAffGtFiltered", "MaxFreqAd",
>, <Line: -			"MaxFreqAr", "OffExome");
>, <Line: -	private final static ImmutableSet<String> VAR_FILTERS_AD = ImmutableSet.of("MaxFreqAd");
>, <Line: -	private final static ImmutableSet<String> VAR_FILTERS_AR = ImmutableSet.of("MaxFreqAr");
>, <Line: -	private final static ImmutableSet<String> GT_FILTERS = ImmutableSet.of("MaxCov", "MinGq");
>, <Line: -	private final static ImmutableSet<String> GT_FILTERS_HOM_REF = ImmutableSet.of("MinAafHomRef");
>, <Line: -	private final static ImmutableSet<String> GT_FILTERS_HOM_ALT = ImmutableSet.of("MinCovHomAlt", "MinAafHomAlt");
>, <Line: -	private final static ImmutableSet<String> GT_FILTERS_HET = ImmutableSet.of("MinCovHet", "MinAafHet", "MaxAafHet");
>, <Line: -	public VariantContextMendelianAnnotator(Pedigree pedigree, boolean interpretGenotypeFilters,
>, <Line: -			boolean interpretVariantFilters) {
>, <Line: -	 * Annotate {@link VariantContext} with compatibility for Mendelian inheritance
>, <Line: -	 *            {@link VariantContext} to check for compatibility and to annotate
>, <Line: -	 * @return Copy of <code>vc</code> with mendelian inheritance compatibility annotation
>, <Line: -	public VariantContext annotateRecord(VariantContext vc) throws CannotAnnotateMendelianInheritance {
>, <Line: -	 * If <code>self.interpretVariantFilters</code> then the variant contexts to be considered for compound heterozygous
>, <Line: -	 * will be prefiltered to those with appropriately high frequency and not being annotated as synonymous variant.
>, <Line: -	 * @return An {@link ImmutableList} of {@link VariantContext} copies of <code>vcs</code>
>, <Line: -	public ImmutableList<VariantContext> annotateRecords(List<VariantContext> vcs)
>, <Line: -		// TODO: filter for synonymous variant currently broken if annotating with all variants... :(
>, <Line: -		final String synonymous = VariantEffect.SYNONYMOUS_VARIANT.getSequenceOntologyTerm();
>, <Line: -		// Filter functor for recessive filtration
>, <Line: -		Predicate<VariantContext> keepFreqRecessive;
>, <Line: -		if (interpretVariantFilters) {
>, <Line: -			keepFreqRecessive = vc -> {
>, <Line: -				return !isFiltered(vc.getFilters(), VAR_FILTERS, VAR_FILTERS_AR)
>, <Line: -						&& !vc.getAttributeAsString("ANN", "").contains(synonymous);
>, <Line: -			};
>, <Line: -		} else {
>, <Line: -			keepFreqRecessive = vc -> true;
>, <Line: -		// Create mapping from MOH to genotype calls and pre-filter if configured to do so
>, <Line: -		HashMap<SubModeOfInheritance, List<GenotypeCalls>> origCalls = new HashMap<>();
>, <Line: -		final List<GenotypeCalls> allCalls = buildGenotypeCalls(vcs);
>, <Line: -		final List<GenotypeCalls> recessiveCalls = buildGenotypeCalls(
>, <Line: -				vcs.stream().filter(keepFreqRecessive).collect(Collectors.toList()));
>, <Line: -		origCalls.put(SubModeOfInheritance.AUTOSOMAL_DOMINANT, allCalls);
>, <Line: -		origCalls.put(SubModeOfInheritance.X_DOMINANT, allCalls);
>, <Line: -		origCalls.put(SubModeOfInheritance.AUTOSOMAL_RECESSIVE_COMP_HET, recessiveCalls);
>, <Line: -		origCalls.put(SubModeOfInheritance.AUTOSOMAL_RECESSIVE_HOM_ALT, allCalls);
>, <Line: -		origCalls.put(SubModeOfInheritance.X_RECESSIVE_COMP_HET, recessiveCalls);
>, <Line: -		origCalls.put(SubModeOfInheritance.X_RECESSIVE_HOM_ALT, allCalls);
>, <Line: -		// Filter to compatible records
>, <Line: -		HashMap<SubModeOfInheritance, List<GenotypeCalls>> filteredGenotypeCalls = new HashMap<>();
>, <Line: -		try {
>, <Line: -			for (Entry<SubModeOfInheritance, List<GenotypeCalls>> e : origCalls.entrySet())
>, <Line: -				filteredGenotypeCalls.put(e.getKey(),
>, <Line: -						mendelChecker.filterCompatibleRecordsSub(e.getValue(), e.getKey()));
>, <Line: -		} catch (IncompatiblePedigreeException e) {
>, <Line: -			throw new CannotAnnotateMendelianInheritance(
>, <Line: -					"Problem with annotating VariantContext for Mendelian inheritance.", e);
>, <Line: -		}
>, <Line: -		for (Entry<SubModeOfInheritance, List<GenotypeCalls>> e : filteredGenotypeCalls.entrySet()) {
>, <Line: -			final SubModeOfInheritance mode = e.getKey();
>, <Line: -			final List<GenotypeCalls> calls = e.getValue();
>, <Line: -			for (GenotypeCalls gc : calls) {
>, <Line: -				Integer key = (Integer) gc.getPayload();
>, <Line: -				switch (mode) {
>, <Line: -		// Construct extended VariantContext objects with INHERITED and INHERITANCE_RECESSIVE_DETAIL attributes
>, <Line: -			vcBuilder.attribute(MendelVCFHeaderExtender.keySub(), subMap.get(e.getKey()));
>, <Line: -		ImmutableList.Builder<VariantContext> resultBuilder = new ImmutableList.Builder<>();
>, <Line: -	 * Compute compatible modes of inheritance for a list of {@link VariantContext} objects
>, <Line: -	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of {@link VariantContext} in <code>vcs</code>
>, <Line: -	 *         that is compatible with each mode
>, <Line: -			List<VariantContext> vcs) throws CannotAnnotateMendelianInheritance {
>, <Line: -			checkResult = mendelChecker.checkMendelianInheritance(gcs);
>, <Line: -					"Problem with annotating VariantContext for Mendelian inheritance.", e);
>, <Line: -		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<VariantContext>> builder = new ImmutableMap.Builder<>();
>, <Line: -		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
>, <Line: -			ImmutableList.Builder<VariantContext> listBuilder = new ImmutableList.Builder<>();
>, <Line: -	 * Compute compatible modes of inheritance for a list of {@link VariantContext} objects
>, <Line: -	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of {@link VariantContext} in <code>vcs</code>
>, <Line: -	 *         that is compatible with each mode
>, <Line: -			List<VariantContext> vcs) throws CannotAnnotateMendelianInheritance {
>, <Line: -			checkResult = mendelChecker.checkMendelianInheritanceSub(gcs);
>, <Line: -					"Problem with annotating VariantContext for Mendelian inheritance.", e);
>, <Line: -		ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<VariantContext>> builder = new ImmutableMap.Builder<>();
>, <Line: -		for (Entry<SubModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
>, <Line: -			ImmutableList.Builder<VariantContext> listBuilder = new ImmutableList.Builder<>();
>, <Line: -	 * Convert a {@link List} of {@link VariantContext} objects into a list of {@link GenotypeCalls} objects
>, <Line: -	private List<GenotypeCalls> buildGenotypeCalls(Collection<VariantContext> vcs) {
>, <Line: -		final ImmutableList<String> xNames = ImmutableList.of("x", "X", "23", "chrx", "chrX", "chr23");
>, <Line: -		final ImmutableList<String> mtNames = ImmutableList.of("m", "M", "mt", "MT", "chrm", "chrM", "chrmt", "chrMT");
>, <Line: -					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HET))
>, <Line: -					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HOM_REF))
>, <Line: -				} else { // hom-alt or two overlapping hets, treated the same for filtration
>, <Line: -					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HOM_ALT))
>, <Line: -						gtBuilder.getAlleleNumbers().add(de.charite.compbio.jannovar.mendel.Genotype.NO_CALL);
>, <Line: -				builder.getSampleToGenotype().put(gt.getSampleName(), gtBuilder.build());
>, <Line: -	private boolean isFiltered(Collection<String> vcFilters, Collection<String> filtersA, Collection<String> filtersB) {
>, <Line: -	private boolean isFiltered(Collection<String> vcFilters, Collection<String> filtersA) {
>]