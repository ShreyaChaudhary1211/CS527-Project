[<Line: +package de.charite.compbio.jannovar.mendel.filter;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Collections;
>, <Line: +import java.util.Comparator;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.Map.Entry;
>, <Line: +import java.util.function.Consumer;
>, <Line: +import java.util.stream.Collectors;
>, <Line: +import org.slf4j.Logger;
>, <Line: +import org.slf4j.LoggerFactory;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableMap;
>, <Line: +import de.charite.compbio.jannovar.data.Chromosome;
>, <Line: +import de.charite.compbio.jannovar.data.JannovarData;
>, <Line: +import de.charite.compbio.jannovar.data.ReferenceDictionary;
>, <Line: +import de.charite.compbio.jannovar.impl.intervals.Interval;
>, <Line: +import de.charite.compbio.jannovar.impl.intervals.IntervalArray;
>, <Line: +import de.charite.compbio.jannovar.mendel.ModeOfInheritance;
>, <Line: +import de.charite.compbio.jannovar.mendel.bridge.CannotateAnnotateMendelianInheritance;
>, <Line: +import de.charite.compbio.jannovar.mendel.bridge.MendelVCFHeaderExtender;
>, <Line: +import de.charite.compbio.jannovar.mendel.bridge.VariantContextMendelianAnnotator;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Pedigree;
>, <Line: +import de.charite.compbio.jannovar.reference.GenomeInterval;
>, <Line: +import de.charite.compbio.jannovar.reference.Strand;
>, <Line: +import de.charite.compbio.jannovar.reference.TranscriptModel;
>, <Line: +import htsjdk.variant.variantcontext.VariantContext;
>, <Line: +import htsjdk.variant.variantcontext.VariantContextBuilder;
>, <Line: +/**
>, <Line: + * Process {@link VariantContext} objects and annotate them with mendelian inheritance compatibility
>, <Line: + * 
>, <Line: + * The variants put into the processor must be clustered by contig name and sorted by begin position
>, <Line: + * 
>, <Line: + * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
>, <Line: + */
>, <Line: +public class GeneWiseMendelianAnnotationProcessor implements VariantContextProcessor {
>, <Line: +	/** The logger object to use */
>, <Line: +	private static final Logger LOGGER = LoggerFactory.getLogger(GeneWiseMendelianAnnotationProcessor.class);
>, <Line: +	/** The {@link Pedigree} to use for the computation */
>, <Line: +	private final Pedigree pedigree;
>, <Line: +	/** The {@link VariantContextMendelianAnnotator} to use for mendelian compatibility annotation */
>, <Line: +	private final VariantContextMendelianAnnotator annotator;
>, <Line: +	/** The {@link JannovarData} to use for extracting the genes from */
>, <Line: +	private JannovarData jannovarData;
>, <Line: +	/** Next step in pipeline after processing of {@link VariantContext} is complete */
>, <Line: +	private final Consumer<VariantContext> sink;
>, <Line: +	/** Currently active genes and variants assigned to them. */
>, <Line: +	HashMap<Gene, ArrayList<VariantContext>> activeGenes = new HashMap<>();
>, <Line: +	/** Currently buffered variants. */
>, <Line: +	HashMap<VariantContext, VariantContextCounter> activeVariants = new HashMap<>();
>, <Line: +	/** List of genes, indexed by interval tree */
>, <Line: +	private final GeneList geneList;
>, <Line: +	/**
>, <Line: +	 * Construct processor with the path to the PED file to use
>, <Line: +	 * 
>, <Line: +	 * @param pedigree
>, <Line: +	 *            the {@link Pedigree} object to use
>, <Line: +	 * @param jannovarData
>, <Line: +	 *            {@link JannovarData} object to use for getting the genes from
>, <Line: +	 * @param sink
>, <Line: +	 *            location to write the {@link VariantContext} to
>, <Line: +	 */
>, <Line: +	public GeneWiseMendelianAnnotationProcessor(Pedigree pedigree, JannovarData jannovarData,
>, <Line: +			Consumer<VariantContext> sink) {
>, <Line: +		this.pedigree = pedigree;
>, <Line: +		this.jannovarData = jannovarData;
>, <Line: +		this.sink = sink;
>, <Line: +		this.geneList = buildGeneList(this.jannovarData);
>, <Line: +		this.annotator = new VariantContextMendelianAnnotator(this.pedigree);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void put(VariantContext vc) throws VariantContextFilterException {
>, <Line: +		LOGGER.trace("Putting variant {} into inheritance filter", new Object[] { vc });
>, <Line: +		// Resolve contig that we work on, trigger start of new contig if necessary
>, <Line: +		final ReferenceDictionary refDict = jannovarData.getRefDict();
>, <Line: +		if (!refDict.getContigNameToID().containsKey(vc.getContig())) {
>, <Line: +			LOGGER.trace("Unknown contig in " + vc.getContig() + ", flushing current contig and writing out.");
>, <Line: +			markDoneGenes(-1, -1);
>, <Line: +			sink.accept(vc);
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		final int contigID = refDict.getContigNameToID().get(vc.getContig());
>, <Line: +		IntervalArray<Gene> iTree = geneList.getGeneIntervalTree().get(contigID);
>, <Line: +		// Consider this variant for each affected gene
>, <Line: +		GenomeInterval changeInterval = new GenomeInterval(refDict, Strand.FWD, contigID, vc.getStart() - 1,
>, <Line: +				vc.getEnd());
>, <Line: +		final IntervalArray<Gene>.QueryResult qr;
>, <Line: +		if (changeInterval.length() == 0)
>, <Line: +			qr = iTree.findOverlappingWithPoint(changeInterval.getBeginPos());
>, <Line: +		else
>, <Line: +			qr = iTree.findOverlappingWithInterval(changeInterval.getBeginPos(), changeInterval.getEndPos());
>, <Line: +		for (Gene gene : qr.getEntries())
>, <Line: +			if (isGeneAffectedByChange(gene, vc))
>, <Line: +				putVariantForGene(vc, gene);
>, <Line: +		// Write out all variants left of variant
>, <Line: +		markDoneGenes(contigID, vc.getStart() - 1);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @return <code>true</code> if <code>gene</code> is affected by <code>variantContext</code>
>, <Line: +	 */
>, <Line: +	private boolean isGeneAffectedByChange(Gene gene, VariantContext vc) {
>, <Line: +		final ReferenceDictionary refDict = jannovarData.getRefDict();
>, <Line: +		final int contigID = refDict.getContigNameToID().get(vc.getContig());
>, <Line: +		final GenomeInterval changeInterval = new GenomeInterval(refDict, Strand.FWD, contigID, vc.getStart() - 1,
>, <Line: +				vc.getEnd());
>, <Line: +		if (changeInterval.length() == 0 && gene.getRegion().contains(changeInterval.getGenomeBeginPos())
>, <Line: +				&& gene.getRegion().contains(changeInterval.getGenomeBeginPos().shifted(-1)))
>, <Line: +			return false;
>, <Line: +		else if (changeInterval.length() != 0 && gene.getRegion().overlapsWith(changeInterval))
>, <Line: +			return true;
>, <Line: +		else
>, <Line: +			return false;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void close() {
>, <Line: +		LOGGER.trace("Closing mendelian annotation processor");
>, <Line: +		markDoneGenes(-1, -1);
>, <Line: +		// There should be no more active variants or genes
>, <Line: +		if (!activeVariants.isEmpty())
>, <Line: +			throw new VariantContextFilterException("All variants should be inactive now");
>, <Line: +		if (!activeGenes.isEmpty())
>, <Line: +			throw new VariantContextFilterException("All genes should be inactive now");
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Build {@link GeneList} to be used in the filter.
>, <Line: +	 *
>, <Line: +	 * @param jannovarDB
>, <Line: +	 *            data base to use for building gene list
>, <Line: +	 * @return list of genes, built from <code>jannovarDB</code>.
>, <Line: +	 */
>, <Line: +	private static GeneList buildGeneList(JannovarData jannovarDB) {
>, <Line: +		// create one GeneBuilder for each gene, collect all transcripts for the gene
>, <Line: +		HashMap<String, GeneBuilder> geneMap = new HashMap<String, GeneBuilder>();
>, <Line: +		for (Chromosome chrom : jannovarDB.getChromosomes().values())
>, <Line: +			for (Interval<TranscriptModel> itv : chrom.getTMIntervalTree().getIntervals()) {
>, <Line: +				TranscriptModel tm = itv.getValue();
>, <Line: +				if (!geneMap.containsKey(tm.getGeneSymbol()))
>, <Line: +					geneMap.put(tm.getGeneSymbol(), new GeneBuilder(jannovarDB.getRefDict(), tm.getGeneSymbol()));
>, <Line: +				geneMap.get(tm.getGeneSymbol()).addTranscriptModel(tm);
>, <Line: +			}
>, <Line: +		// construct GeneList from geneMap
>, <Line: +		ImmutableList.Builder<Gene> builder = new ImmutableList.Builder<Gene>();
>, <Line: +		for (GeneBuilder gene : geneMap.values())
>, <Line: +			builder.add(gene.build());
>, <Line: +		return new GeneList(builder.build());
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Register {@link FlaggedVariant} as active for the given gene.
>, <Line: +	 */
>, <Line: +	private void putVariantForGene(VariantContext vc, Gene gene) {
>, <Line: +		LOGGER.trace("Assigning variant {} to gene {}", new Object[] { vc, gene });
>, <Line: +		// Register VariantContext as active
>, <Line: +		activeVariants.computeIfAbsent(vc, x -> new VariantContextCounter(x, 0));
>, <Line: +		activeVariants.get(vc).increment();
>, <Line: +		// Register VariantContext for gene
>, <Line: +		activeGenes.computeIfAbsent(gene, x -> new ArrayList<>());
>, <Line: +		activeGenes.get(gene).add(vc);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Mark genes left of <code>(contigID, pos)</code> as done.
>, <Line: +	 *
>, <Line: +	 * @param contigID
>, <Line: +	 *            numeric contig ID, as taken from {@link JannovarDB#refDict} from {@link #jannovarDB}.
>, <Line: +	 * @param pos
>, <Line: +	 *            zero-based position on the given contig
>, <Line: +	 * @throws VariantContextFilterException
>, <Line: +	 *             on problems with filtration
>, <Line: +	 */
>, <Line: +	private void markDoneGenes(int contigID, int pos) throws VariantContextFilterException {
>, <Line: +		ArrayList<Gene> doneGenes = new ArrayList<Gene>();
>, <Line: +		for (Entry<Gene, ArrayList<VariantContext>> entry : activeGenes.entrySet()) {
>, <Line: +			Gene gene = entry.getKey();
>, <Line: +			if (gene.getRegion().getChr() != contigID)
>, <Line: +				doneGenes.add(gene);
>, <Line: +			else if (gene.getRegion().getEndPos() <= pos)
>, <Line: +				doneGenes.add(gene);
>, <Line: +		}
>, <Line: +		for (Gene gene : doneGenes) {
>, <Line: +			processedGene(gene);
>, <Line: +			activeGenes.remove(gene);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Builds genotype call lists for variants in currently active genes, checks for compatibility, and in case of
>, <Line: +	 * compatibility, marks variants in <code>gene</code> as compatible.
>, <Line: +	 * 
>, <Line: +	 * @throws VariantContextFilterException
>, <Line: +	 *             in case of problems with processing the variant
>, <Line: +	 * @throws CannotateAnnotateMendelianInheritance
>, <Line: +	 *             in case of problems with Mendelian inheritance annotation
>, <Line: +	 */
>, <Line: +	private void checkVariantsForGene(Gene gene)
>, <Line: +			throws VariantContextFilterException, CannotateAnnotateMendelianInheritance {
>, <Line: +		// Compute compatible modes for all variants in the gene
>, <Line: +		final ArrayList<VariantContext> variantsForGene = activeGenes.get(gene);
>, <Line: +		ImmutableMap<ModeOfInheritance, ImmutableList<VariantContext>> compatibleMap = annotator
>, <Line: +				.computeCompatibleInheritanceModes(variantsForGene);
>, <Line: +		// Annotate the variants with new compatible modes
>, <Line: +		for (Entry<ModeOfInheritance, ImmutableList<VariantContext>> e : compatibleMap.entrySet()) {
>, <Line: +			for (VariantContext vc : e.getValue()) {
>, <Line: +				activeVariants.get(vc).addCompatibleMode(e.getKey());
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Decrease counter for all variants located in <code>gene</code>.
>, <Line: +	 *
>, <Line: +	 * @param gene
>, <Line: +	 *            the {@link Gene} to mark the variants for
>, <Line: +	 */
>, <Line: +	private void processedGene(Gene gene) throws VariantContextFilterException {
>, <Line: +		try {
>, <Line: +			checkVariantsForGene(gene);
>, <Line: +		} catch (CannotateAnnotateMendelianInheritance e) {
>, <Line: +			throw new VariantContextFilterException("Problem with annotating variant for Mendelian inheritance", e);
>, <Line: +		}
>, <Line: +		LOGGER.trace("Gene done {}", new Object[] { gene.getName() });
>, <Line: +		// decrease count of variants that lie in gene (that is now ignored)
>, <Line: +		ArrayList<VariantContextCounter> done = new ArrayList<VariantContextCounter>();
>, <Line: +		for (VariantContextCounter var : activeVariants.values()) {
>, <Line: +			if (isGeneAffectedByChange(gene, var.getVariantContext())) {
>, <Line: +				LOGGER.trace("Gene {} done for variant {}", new Object[] { gene.getName(),
>, <Line: +						var.getVariantContext().getContig() + ":" + var.getVariantContext().getStart() });
>, <Line: +				var.decrement();
>, <Line: +			}
>, <Line: +			if (var.getCounter() == 0)
>, <Line: +				done.add(var);
>, <Line: +		}
>, <Line: +		// Sort done by coordinate
>, <Line: +		Collections.sort(done, new Comparator<VariantContextCounter>() {
>, <Line: +			@Override
>, <Line: +			public int compare(VariantContextCounter lhs, VariantContextCounter rhs) {
>, <Line: +				return (lhs.getVariantContext().getStart() - rhs.getVariantContext().getStart());
>, <Line: +			}
>, <Line: +		});
>, <Line: +		// Remove completed variants and write out if passing
>, <Line: +		for (VariantContextCounter var : done) {
>, <Line: +			activeVariants.remove(var.getVariantContext());
>, <Line: +			ArrayList<String> modes = new ArrayList<>();
>, <Line: +			modes.addAll(var.getCompatibleModes().stream().map(m -> m.getAbbreviation()).filter(m -> m != null)
>, <Line: +					.collect(Collectors.toList()));
>, <Line: +			if (modes.isEmpty()) {
>, <Line: +				sink.accept(var.getVariantContext());
>, <Line: +			} else {
>, <Line: +				VariantContextBuilder vcBuilder = new VariantContextBuilder(var.getVariantContext());
>, <Line: +				vcBuilder.attribute(MendelVCFHeaderExtender.key(), modes);
>, <Line: +				sink.accept(vcBuilder.make());
>, <Line: +			}
>, <Line: +		}
>, <Line: +		LOGGER.trace("Gene {} is inactive now", new Object[] { gene.getName() });
>, <Line: +		// Mark gene as done
>, <Line: +		activeGenes.remove(gene);
>, <Line: +	}
>, <Line: +}
>]
[]