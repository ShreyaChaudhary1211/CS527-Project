[<Line: +package de.charite.compbio.jannovar.vardbs.generic_tsv;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.AlleleMatcher;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.DBAnnotationDriver;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.DatabaseVariantContextProvider;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
>, <Line: +import htsjdk.samtools.util.CloseableIterator;
>, <Line: +import htsjdk.variant.variantcontext.VariantContext;
>, <Line: +import htsjdk.variant.variantcontext.VariantContextBuilder;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.Comparator;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +/**
>, <Line: + * Annotation driver class for annotations generic TSV data
>, <Line: + *
>, <Line: + * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
>, <Line: + */
>, <Line: +public final class GenericTSVAnnotationDriver implements DBAnnotationDriver {
>, <Line: +	/** Path to dbSNP VCF file */
>, <Line: +	private final DatabaseVariantContextProvider variantProvider;
>, <Line: +	/** Helper objects for matching alleles */
>, <Line: +	private final AlleleMatcher matcher;
>, <Line: +	/** Configuration */
>, <Line: +	private final GenericTSVAnnotationOptions options;
>, <Line: +	public GenericTSVAnnotationDriver(String fastaPath, GenericTSVAnnotationOptions options)
>, <Line: +			throws JannovarVarDBException {
>, <Line: +		this.variantProvider = new GenericTSVVariantContextProvider(options);
>, <Line: +		this.matcher = new AlleleMatcher(fastaPath);
>, <Line: +		this.options = options;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public VCFHeaderExtender constructVCFHeaderExtender() {
>, <Line: +		return new GenericTSVHeaderExtender(options);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public VariantContext annotateVariantContext(VariantContext vc) {
>, <Line: +		VariantContextBuilder builder = new VariantContextBuilder(vc);
>, <Line: +		// Matching and overlapping records for each allele. For the generic TSV annotation, we
>, <Line: +		// assume that only one allele is given for each database record.
>, <Line: +		Map<Integer, List<VariantContext>> dbRecordsMatch = null;
>, <Line: +		Map<Integer, List<VariantContext>> dbRecordsOverlap = null;
>, <Line: +		if (options.isReportOverlapping() && options.isReportOverlappingAsMatching()) {
>, <Line: +			dbRecordsMatch = pickDBRecords(vc, false);
>, <Line: +		} else {
>, <Line: +			dbRecordsMatch = pickDBRecords(vc, true);
>, <Line: +			dbRecordsOverlap = pickDBRecords(vc, false);
>, <Line: +		}
>, <Line: +		// Annotate with records with genotype matches
>, <Line: +		for (int i = 0; i < options.getValueColumnDescriptions().size(); i++) {
>, <Line: +			final String colName = options.getColumnNames().get(i);
>, <Line: +			final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
>, <Line: +					.get(colName);
>, <Line: +			final String refColName = desc.getRefField();
>, <Line: +			final GenericTSVValueColumnDescription refDesc = options.getValueColumnDescriptions()
>, <Line: +					.get(refColName);
>, <Line: +			annotateWith(vc, "", dbRecordsMatch, desc, refDesc, builder);
>, <Line: +		}
>, <Line: +		// Annotate with records with overlapping positions
>, <Line: +		if (options.isReportOverlapping() && !options.isReportOverlappingAsMatching()) {
>, <Line: +			for (int i = 0; i < options.getValueColumnDescriptions().size(); i++) {
>, <Line: +				final String colName = options.getColumnNames().get(i);
>, <Line: +				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
>, <Line: +						.get(colName);
>, <Line: +				final String refColName = desc.getRefField();
>, <Line: +				final GenericTSVValueColumnDescription refDesc = options
>, <Line: +						.getValueColumnDescriptions().get(refColName);
>, <Line: +				annotateWith(vc, "OVL_", dbRecordsOverlap, desc, refDesc, builder);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return builder.make();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Pick database records for the given {@link VariantContext} <code>vc</code>.
>, <Line: +	 */
>, <Line: +	private Map<Integer, List<VariantContext>> pickDBRecords(VariantContext vc,
>, <Line: +			boolean requireGenotypeMatch) {
>, <Line: +		final Map<Integer, List<VariantContext>> result = new HashMap<>();
>, <Line: +		for (int i = 0; i < vc.getNAlleles(); ++i) {
>, <Line: +			result.put(i, new ArrayList<>());
>, <Line: +		}
>, <Line: +		try (CloseableIterator<VariantContext> it = variantProvider.query(vc.getContig(),
>, <Line: +				vc.getStart() - 1, vc.getEnd())) {
>, <Line: +			while (it.hasNext()) {
>, <Line: +				final VariantContext dbVC = it.next();
>, <Line: +				for (int i = 0; i < vc.getNAlleles(); ++i) {
>, <Line: +					final Collection<GenotypeMatch> matches;
>, <Line: +					if (requireGenotypeMatch) {
>, <Line: +						matches = matcher.matchGenotypes(vc, dbVC);
>, <Line: +					} else {
>, <Line: +						matches = matcher.positionOverlaps(vc, dbVC);
>, <Line: +					}
>, <Line: +					for (GenotypeMatch match : matches) {
>, <Line: +						result.get(match.getObservedAllele()).add(dbVC);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Helper for comparable pairs.
>, <Line: +	 */
>, <Line: +	private static class LabeledValue<Label extends Comparable<Label>, Value>
>, <Line: +			implements Comparable<LabeledValue<Label, Value>> {
>, <Line: +		private final Label label;
>, <Line: +		private final Value value;
>, <Line: +		public LabeledValue(Label label, Value value) {
>, <Line: +			this.label = label;
>, <Line: +			this.value = value;
>, <Line: +		}
>, <Line: +		public Label getLabel() {
>, <Line: +			return label;
>, <Line: +		}
>, <Line: +		public Value getValue() {
>, <Line: +			return value;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "LabeledValue [label=" + label + ", value=" + value + "]";
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public int compareTo(LabeledValue<Label, Value> o) {
>, <Line: +			return label.compareTo(o.getLabel());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Annotate <code>vc</code> with the annotating database records.
>, <Line: +	 * 
>, <Line: +	 * @param refDesc
>, <Line: +	 */
>, <Line: +	private void annotateWith(VariantContext vc, String infix,
>, <Line: +			Map<Integer, List<VariantContext>> dbRecords, GenericTSVValueColumnDescription desc,
>, <Line: +			GenericTSVValueColumnDescription refDesc, VariantContextBuilder builder) {
>, <Line: +		if (dbRecords.values().stream().allMatch(lst -> lst.isEmpty())) {
>, <Line: +			return; // no annotation necessary
>, <Line: +		}
>, <Line: +		switch (desc.getValueType()) {
>, <Line: +		case Character:
>, <Line: +			switch (refDesc.getValueType()) {
>, <Line: +			case Character:
>, <Line: +				this.<Character, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Flag:
>, <Line: +				this.<Boolean, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Float:
>, <Line: +				this.<Double, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Double.MIN_VALUE, Double.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case Integer:
>, <Line: +				this.<Integer, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case String:
>, <Line: +			default:
>, <Line: +				this.<String, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case Flag:
>, <Line: +			switch (refDesc.getValueType()) {
>, <Line: +			case Character:
>, <Line: +				this.<Character, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Flag:
>, <Line: +				this.<Boolean, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Float:
>, <Line: +				this.<Double, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Double.MIN_VALUE, Double.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case Integer:
>, <Line: +				this.<Integer, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case String:
>, <Line: +			default:
>, <Line: +				this.<String, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case Float:
>, <Line: +			switch (refDesc.getValueType()) {
>, <Line: +			case Character:
>, <Line: +				this.<Character, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Flag:
>, <Line: +				this.<Boolean, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Float:
>, <Line: +				this.<Double, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
>, <Line: +						Double.MIN_VALUE, Double.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case Integer:
>, <Line: +				this.<Integer, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case String:
>, <Line: +			default:
>, <Line: +				this.<String, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
>, <Line: +						null, null);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case Integer:
>, <Line: +			switch (refDesc.getValueType()) {
>, <Line: +			case Character:
>, <Line: +				this.<Character, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Flag:
>, <Line: +				this.<Boolean, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Float:
>, <Line: +				this.<Double, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Double.MIN_VALUE, Double.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case Integer:
>, <Line: +				this.<Integer, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case String:
>, <Line: +			default:
>, <Line: +				this.<String, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case String:
>, <Line: +		default:
>, <Line: +			switch (refDesc.getValueType()) {
>, <Line: +			case Character:
>, <Line: +				this.<Character, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Flag:
>, <Line: +				this.<Boolean, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, null, null);
>, <Line: +				break;
>, <Line: +			case Float:
>, <Line: +				this.<Double, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
>, <Line: +						Double.MIN_VALUE, Double.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case Integer:
>, <Line: +				this.<Integer, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
>, <Line: +						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
>, <Line: +				break;
>, <Line: +			case String:
>, <Line: +			default:
>, <Line: +				this.<String, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
>, <Line: +						null, null);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private <Label extends Comparable<Label>, Value> void annotateWithImpl(VariantContext vc,
>, <Line: +			String infix, Map<Integer, List<VariantContext>> dbRecords,
>, <Line: +			GenericTSVValueColumnDescription desc, GenericTSVValueColumnDescription refDesc,
>, <Line: +			VariantContextBuilder builder, Label minValue, Label maxValue) {
>, <Line: +		// Prepare annotation list with one entry for each allele
>, <Line: +		final List<Object> annotations = new ArrayList<>();
>, <Line: +		final Map<Integer, List<LabeledValue<Label, Value>>> labeledValues = new HashMap<>();
>, <Line: +		for (int alleleNo = 0; alleleNo < vc.getNAlleles(); ++alleleNo) {
>, <Line: +			annotations.add(".");
>, <Line: +			labeledValues.put(alleleNo, new ArrayList<>());
>, <Line: +			for (VariantContext dbRecord : dbRecords.get(alleleNo)) {
>, <Line: +				Label label = (Label) dbRecord.getAttribute(refDesc.getFieldName());
>, <Line: +				if (label == null && minValue != null && maxValue != null) {
>, <Line: +					if (refDesc
>, <Line: +							.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MIN) {
>, <Line: +						label = maxValue;
>, <Line: +					} else if (refDesc
>, <Line: +							.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MAX) {
>, <Line: +						label = minValue;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				labeledValues.get(alleleNo).add(new LabeledValue<Label, Value>(label,
>, <Line: +						(Value) dbRecord.getAttribute(desc.getFieldName())));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		switch (refDesc.getValueType()) {
>, <Line: +		case Character:
>, <Line: +		case Flag:
>, <Line: +		case String:
>, <Line: +			// Only pick first available
>, <Line: +			for (int j = 0; j < vc.getNAlleles(); ++j) {
>, <Line: +				if (!labeledValues.get(j).isEmpty()) {
>, <Line: +					annotations.set(j, labeledValues.get(j).get(0).getValue());
>, <Line: +				}
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case Float:
>, <Line: +			for (int j = 0; j < vc.getNAlleles(); ++j) {
>, <Line: +				if (!labeledValues.get(j).isEmpty()) {
>, <Line: +					switch (refDesc.getAccumulationStrategy()) {
>, <Line: +					case AVERAGE:
>, <Line: +						annotations.set(j, labeledValues.get(j).stream()
>, <Line: +								.mapToDouble(x -> (Double) x.getValue()).average().orElse(0.0));
>, <Line: +						break;
>, <Line: +					case CHOOSE_FIRST:
>, <Line: +						annotations.set(j, labeledValues.get(j).get(0).getValue());
>, <Line: +						break;
>, <Line: +					case CHOOSE_MIN:
>, <Line: +						annotations.set(j,
>, <Line: +								labeledValues.get(j).stream()
>, <Line: +										.min(Comparator.<LabeledValue<Label, Value>> naturalOrder())
>, <Line: +										.map(x -> (Object) x.getValue()).orElse("."));
>, <Line: +						break;
>, <Line: +					case CHOOSE_MAX:
>, <Line: +					default:
>, <Line: +						annotations.set(j,
>, <Line: +								labeledValues.get(j).stream()
>, <Line: +										.max(Comparator.<LabeledValue<Label, Value>> naturalOrder())
>, <Line: +										.map(x -> (Object) x.getValue()).orElse("."));
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case Integer:
>, <Line: +			for (int j = 0; j < vc.getNAlleles(); ++j) {
>, <Line: +				if (!labeledValues.get(j).isEmpty()) {
>, <Line: +					switch (refDesc.getAccumulationStrategy()) {
>, <Line: +					case AVERAGE:
>, <Line: +						annotations.set(j, labeledValues.get(j).stream()
>, <Line: +								.mapToDouble(x -> (Integer) x.getValue()).average().orElse(0.0));
>, <Line: +						break;
>, <Line: +					case CHOOSE_FIRST:
>, <Line: +						annotations.set(j, labeledValues.get(j).get(0).getValue());
>, <Line: +						break;
>, <Line: +					case CHOOSE_MIN:
>, <Line: +						annotations.set(j,
>, <Line: +								labeledValues.get(j).stream()
>, <Line: +										.min(Comparator.<LabeledValue<Label, Value>> naturalOrder())
>, <Line: +										.map(x -> (Object) x.getValue()).orElse("."));
>, <Line: +						break;
>, <Line: +					case CHOOSE_MAX:
>, <Line: +					default:
>, <Line: +						annotations.set(j,
>, <Line: +								labeledValues.get(j).stream()
>, <Line: +										.max(Comparator.<LabeledValue<Label, Value>> naturalOrder())
>, <Line: +										.map(x -> (Object) x.getValue()).orElse("."));
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		default:
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		if (!options.isRefAlleleAnnotated()) {
>, <Line: +			annotations.remove(0);
>, <Line: +		}
>, <Line: +		// Put annotation into variant context builder
>, <Line: +		final String label = options.getVCFIdentifierPrefix() + infix + desc.getFieldName();
>, <Line: +		builder.attribute(label, annotations);
>, <Line: +	}
>, <Line: +}
>]
[]