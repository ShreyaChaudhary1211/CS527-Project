[<Line: +import de.charite.compbio.jannovar.filter.facade.GenotypeThresholdFilterAnnotator;
>, <Line: +import de.charite.compbio.jannovar.filter.impl.var.VariantThresholdFilterAnnotator;
>, <Line: +import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions.MultipleMatchBehaviour;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationDriver;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationOptions;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationTarget;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVValueColumnDescription;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_vcf.GenericVCFAnnotationDriver;
>, <Line: +import de.charite.compbio.jannovar.vardbs.generic_vcf.GenericVCFAnnotationOptions;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.Map;
>, <Line: +		final boolean useInterval = (options.getInterval() != null && !options.getInterval().equals(""));
>, <Line: +				final SAMSequenceDictionary seqDict = VCFFileReader.getSequenceDictionary(new File(vcfPath));
>, <Line: +					System.err.println("Progress reporting does not work because VCF file is missing the contig "
>, <Line: +							+ "lines in the header.");
>, <Line: +						.constructGnomad(options.pathVCFGnomadExomes, options.pathFASTARef, gnomadOptions);
>, <Line: +						.constructGnomad(options.pathVCFGnomadGenomes, options.pathFASTARef, gnomadOptions);
>, <Line: +						.constructClinVar(options.pathClinVar, options.pathFASTARef, clinVarOptions);
>, <Line: +			// Add step for annotating with variant effect
>, <Line: +			VariantEffectHeaderExtender extender = new VariantEffectHeaderExtender();
>, <Line: +			extender.addHeaders(vcfHeader);
>, <Line: +			VariantContextAnnotator variantEffectAnnotator =
>, <Line: +					new VariantContextAnnotator(refDict, chromosomeMap,
>, <Line: +							new VariantContextAnnotator.Options(!options.isShowAll(),
>, <Line: +									options.isEscapeAnnField(), options.isNt3PrimeShifting(),
>, <Line: +									options.isOffTargetFilterEnabled(),
>, <Line: +									options.isOffTargetFilterUtrIsOffTarget(),
>, <Line: +									options.isOffTargetFilterIntronicSpliceIsOffTarget()));
>, <Line: +			stream = stream.map(variantEffectAnnotator::annotateVariantContext);
>, <Line: +			ArrayList<String> affecteds = new ArrayList<>();
>, <Line: +						options.getThreshFiltMinGtAafHomAlt(), options.getThreshFiltMaxGtAafHomRef(),
>, <Line: +						options.getPrefixExac(), options.getPrefixDBSNP(), options.getPrefixGnomadGenomes(),
>, <Line: +						options.getPrefixGnomadExomes(), options.getThreshFiltMaxAlleleFrequencyAd(),
>, <Line: +				GenotypeThresholdFilterAnnotator gtThresholdFilterAnno =
>, <Line: +						new GenotypeThresholdFilterAnnotator(thresholdFilterOptions);
>, <Line: +				stream = stream.map(gtThresholdFilterAnno::annotateVariantContext);
>, <Line: +							options.getThreshDeNovoParentAd2(), options.isUseParentGtIsFiltered());
>, <Line: +					PedigreeFilterAnnotator pedFilterAnnotator = new PedigreeFilterAnnotator(pedFilterOptions,
>, <Line: +							pedigree);
>, <Line: +				if (options.useThresholdFilters) {
>, <Line: +					VariantThresholdFilterAnnotator varThresholdFilterAnno =
>, <Line: +							new VariantThresholdFilterAnnotator(thresholdFilterOptions, affecteds);
>, <Line: +					stream = stream.map(varThresholdFilterAnno::annotateVariantContext);
>, <Line: +			// Annotate from BED files
>, <Line: +			List<BedFileAnnotator> bedFileAnnotators = new ArrayList<>();
>, <Line: +			for (BedAnnotationOptions bedAnnotationOptions : options.getBedAnnotationOptions()) {
>, <Line: +				BedFileAnnotator annotator = new BedFileAnnotator(bedAnnotationOptions);
>, <Line: +				bedFileAnnotators.add(annotator);
>, <Line: +				annotator.extendHeader(vcfHeader);
>, <Line: +				stream = stream.map(annotator::annotateVariantContext);
>, <Line: +			}
>, <Line: +			// Annotate using dbNSFP
>, <Line: +			GenericTSVAnnotationDriver dbNsfpAnnotator;
>, <Line: +			if (options.getPathDbNsfp() != null) {
>, <Line: +				Map<String, GenericTSVValueColumnDescription> descriptions = new HashMap<>();
>, <Line: +				for (String colName : options.getColumnsDbNsfp()) {
>, <Line: +					descriptions.put(colName, DbNsfpFields.DBNSFP_FIELDS.get(colName));
>, <Line: +				}
>, <Line: +				GenericTSVAnnotationOptions dbNsfpAnnotationOptions = new GenericTSVAnnotationOptions(true, false,
>, <Line: +						options.getPrefixDbNsfp(), MultipleMatchBehaviour.BEST_ONLY, new File(options.getPathDbNsfp()),
>, <Line: +						GenericTSVAnnotationTarget.VARIANT, true, options.getDbNsfpColContig(),
>, <Line: +						options.getDbNsfpColPosition(), options.getDbNsfpColPosition(), 3, 4, false, 
>, <Line: +						options.getColumnsDbNsfp(), descriptions);
>, <Line: +				dbNsfpAnnotator = new GenericTSVAnnotationDriver(options.getPathFASTARef(), dbNsfpAnnotationOptions);
>, <Line: +				dbNsfpAnnotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
>, <Line: +				stream = stream.map(dbNsfpAnnotator::annotateVariantContext);
>, <Line: +			}
>, <Line: +			// Annotate from generic TSV files
>, <Line: +			List<GenericTSVAnnotationDriver> tsvAnnotators = new ArrayList<>();
>, <Line: +			for (GenericTSVAnnotationOptions tsvAnnotationOptions : options.getTsvAnnotationOptions()) {
>, <Line: +				GenericTSVAnnotationDriver annotator = new GenericTSVAnnotationDriver(options.getPathFASTARef(),
>, <Line: +						tsvAnnotationOptions);
>, <Line: +				tsvAnnotators.add(annotator);
>, <Line: +				annotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
>, <Line: +				stream = stream.map(annotator::annotateVariantContext);
>, <Line: +			}
>, <Line: +			// Annotate from generic VCF files
>, <Line: +			List<GenericVCFAnnotationDriver> vcfAnnotators = new ArrayList<>();
>, <Line: +			for (GenericVCFAnnotationOptions vcfAnnotationOptions : options.getVcfAnnotationOptions()) {
>, <Line: +				GenericVCFAnnotationDriver annotator = new GenericVCFAnnotationDriver(
>, <Line: +						vcfAnnotationOptions.getPathVcfFile(), options.getPathFASTARef(), vcfAnnotationOptions);
>, <Line: +				vcfAnnotators.add(annotator);
>, <Line: +				annotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
>, <Line: +				stream = stream.map(annotator::annotateVariantContext);
>, <Line: +			}
>, <Line: +				System.err
>, <Line: +						.println("VCF file " + vcfPath + " is not compatible to pedigree file " + options.pathPedFile);
>, <Line: +	 * @param vcfHeader {@link VCFHeader}, for checking compatibility and getting sample name in
>, <Line: +	 *        case of singleton pedigree construction
>, <Line: +	 * @throws PedParseException in the case of problems with parsing pedigrees
>, <Line: +			final PedPerson pedPerson =
>, <Line: +					new PedPerson(sampleName, sampleName, "0", "0", Sex.UNKNOWN, Disease.AFFECTED);
>, <Line: +			final PedFileContents pedContents =
>, <Line: +					new PedFileContents(ImmutableList.of(), ImmutableList.of(pedPerson));
>, <Line: +	 * @param writer the place to put put the VariantContext to after filtration
>, <Line: +	 * @param vcfHeader {@link VCFHeader}, for checking compatibility and getting sample name in
>, <Line: +	 *        case of singleton pedigree construction
>, <Line: +	 * @throws IOException in case of problems with opening the pedigree file
>, <Line: +	 * @throws PedParseException in the case of problems with parsing pedigrees
>, <Line: +	 * @throws IncompatiblePedigreeException If the pedigree is incompatible with the VCF file
>, <Line: +			final GeneWiseMendelianAnnotationProcessor mendelProcessor =
>, <Line: +					new GeneWiseMendelianAnnotationProcessor(pedigree, jannovarData,
>, <Line: +							vc -> writer.add(vc), options.isInheritanceAnnoUseFilters());
>, <Line: +	 * @param pedigree {@link Pedigree} to check for compatibility
>, <Line: +	 * @param vcfHeader {@link VCFHeader} to check for compatibility
>, <Line: +	 * @throws IncompatiblePedigreeException if the VCF file is not compatible with the pedigree
>, <Line: +		if (!missing.isEmpty()) throw new IncompatiblePedigreeException(
>, <Line: +				"The VCF file has the following sample names not present in Pedigree: "
>, <Line: +						+ Joiner.on(", ").join(missing));
>]
[<Line: -import de.charite.compbio.jannovar.filter.facade.ThresholdFilterAnnotator;
>, <Line: -		final boolean useInterval = (options.getInterval() != null
>, <Line: -				&& !options.getInterval().equals(""));
>, <Line: -				final SAMSequenceDictionary seqDict = VCFFileReader
>, <Line: -						.getSequenceDictionary(new File(vcfPath));
>, <Line: -					System.err.println(
>, <Line: -							"Progress reporting does not work because VCF file is missing the contig "
>, <Line: -									+ "lines in the header.");
>, <Line: -						.constructGnomad(options.pathVCFGnomadExomes, options.pathFASTARef,
>, <Line: -								gnomadOptions);
>, <Line: -						.constructGnomad(options.pathVCFGnomadGenomes, options.pathFASTARef,
>, <Line: -								gnomadOptions);
>, <Line: -						.constructClinVar(options.pathClinVar, options.pathFASTARef,
>, <Line: -								clinVarOptions);
>, <Line: -						options.getThreshFiltMinGtAafHomAlt(),
>, <Line: -						options.getThreshFiltMaxGtAafHomRef(), options.getPrefixExac(),
>, <Line: -						options.getPrefixDBSNP(), options.getPrefixGnomadGenomes(),
>, <Line: -						options.getPrefixGnomadExomes(),
>, <Line: -						options.getThreshFiltMaxAlleleFrequencyAd(),
>, <Line: -				ArrayList<String> affecteds = new ArrayList<>();
>, <Line: -				ThresholdFilterAnnotator thresholdFilterAnno = new ThresholdFilterAnnotator(
>, <Line: -						thresholdFilterOptions, affecteds);
>, <Line: -				stream = stream.map(thresholdFilterAnno::annotateVariantContext);
>, <Line: -							options.getThreshDeNovoParentAd2());
>, <Line: -					PedigreeFilterAnnotator pedFilterAnnotator = new PedigreeFilterAnnotator(
>, <Line: -							pedFilterOptions, pedigree);
>, <Line: -				// Annotate from BED files
>, <Line: -				List<BedFileAnnotator> annotators = new ArrayList<>();
>, <Line: -				for (BedAnnotationOptions bedAnnotationOptions : options.getBedAnnotationOptions()) {
>, <Line: -					BedFileAnnotator annotator = new BedFileAnnotator(bedAnnotationOptions);
>, <Line: -					annotators.add(annotator);
>, <Line: -					annotator.extendHeader(vcfHeader);
>, <Line: -					stream = stream.map(annotator::annotateVariantContext);
>, <Line: -			// Add step for annotating with variant effect
>, <Line: -			VariantEffectHeaderExtender extender = new VariantEffectHeaderExtender();
>, <Line: -			extender.addHeaders(vcfHeader);
>, <Line: -			VariantContextAnnotator annotator = new VariantContextAnnotator(refDict, chromosomeMap,
>, <Line: -					new VariantContextAnnotator.Options(!options.isShowAll(),
>, <Line: -							options.isEscapeAnnField(), options.isNt3PrimeShifting(),
>, <Line: -							options.isOffTargetFilterEnabled(),
>, <Line: -							options.isOffTargetFilterUtrIsOffTarget(),
>, <Line: -							options.isOffTargetFilterIntronicSpliceIsOffTarget()));
>, <Line: -			stream = stream.map(annotator::annotateVariantContext);
>, <Line: -				System.err.println("VCF file " + vcfPath + " is not compatible to pedigree file "
>, <Line: -						+ options.pathPedFile);
>, <Line: -	 * @param vcfHeader
>, <Line: -	 *            {@link VCFHeader}, for checking compatibility and getting sample name in case of
>, <Line: -	 *            singleton pedigree construction
>, <Line: -	 * @throws PedParseException
>, <Line: -	 *             in the case of problems with parsing pedigrees
>, <Line: -			final PedPerson pedPerson = new PedPerson(sampleName, sampleName, "0", "0", Sex.UNKNOWN,
>, <Line: -					Disease.AFFECTED);
>, <Line: -			final PedFileContents pedContents = new PedFileContents(ImmutableList.of(),
>, <Line: -					ImmutableList.of(pedPerson));
>, <Line: -	 * @param writer
>, <Line: -	 *            the place to put put the VariantContext to after filtration
>, <Line: -	 * @param vcfHeader
>, <Line: -	 *            {@link VCFHeader}, for checking compatibility and getting sample name in case of
>, <Line: -	 *            singleton pedigree construction
>, <Line: -	 * @throws IOException
>, <Line: -	 *             in case of problems with opening the pedigree file
>, <Line: -	 * @throws PedParseException
>, <Line: -	 *             in the case of problems with parsing pedigrees
>, <Line: -	 * @throws IncompatiblePedigreeException
>, <Line: -	 *             If the pedigree is incompatible with the VCF file
>, <Line: -			final GeneWiseMendelianAnnotationProcessor mendelProcessor = new GeneWiseMendelianAnnotationProcessor(
>, <Line: -					pedigree, jannovarData, vc -> writer.add(vc),
>, <Line: -					options.isInheritanceAnnoUseFilters());
>, <Line: -	 * @param pedigree
>, <Line: -	 *            {@link Pedigree} to check for compatibility
>, <Line: -	 * @param vcfHeader
>, <Line: -	 *            {@link VCFHeader} to check for compatibility
>, <Line: -	 * @throws IncompatiblePedigreeException
>, <Line: -	 *             if the VCF file is not compatible with the pedigree
>, <Line: -		if (!missing.isEmpty())
>, <Line: -			throw new IncompatiblePedigreeException(
>, <Line: -					"The VCF file has the following sample names not present in Pedigree: "
>, <Line: -							+ Joiner.on(", ").join(missing));
>]