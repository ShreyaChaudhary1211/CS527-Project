[<Line: +package de.charite.compbio.jannovar.mendel.impl;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.List;
>, <Line: +import java.util.stream.Collectors;
>, <Line: +import java.util.stream.Stream;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableSet;
>, <Line: +import de.charite.compbio.jannovar.mendel.ChromosomeType;
>, <Line: +import de.charite.compbio.jannovar.mendel.Genotype;
>, <Line: +import de.charite.compbio.jannovar.mendel.GenotypeCalls;
>, <Line: +import de.charite.compbio.jannovar.mendel.IncompatiblePedigreeException;
>, <Line: +import de.charite.compbio.jannovar.mendel.MendelianInheritanceChecker;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Disease;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Pedigree;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Person;
>, <Line: +import de.charite.compbio.jannovar.pedigree.Sex;
>, <Line: +/**
>, <Line: + * Helper class for checking a {@link GenotypeCalls} for compatibility with a {@link Pedigree} and AR homozygous mode
>, <Line: + *
>, <Line: + * <h2>Compatibility Check</h2>
>, <Line: + *
>, <Line: + * In the case of a single individual, we require hom. alt.
>, <Line: + *
>, <Line: + * In the case of multiple individuals, we require that the affects are compatible, that the unaffected parents of hom.
>, <Line: + * alt. unaffected females are not are not hom. ref., and that all unaffected individuals are not hom. alt. The affected
>, <Line: + * individuals are compatible if no affected individual is hom. ref. or het. and there is at least one affected
>, <Line: + * individual that is hom. alt.
>, <Line: + *
>, <Line: + * @author <a href="mailto:manuel.holtgrewe@charite.de">Manuel Holtgrewe</a>
>, <Line: + * @author <a href="mailto:max.schubach@charite.de">Max Schubach</a>
>, <Line: + * @author <a href="mailto:peter.robinson@charite.de">Peter N Robinson</a>
>, <Line: + * @version 0.15-SNAPSHOT
>, <Line: + */
>, <Line: +public class MendelianCheckerXRHom extends AbstractMendelianChecker {
>, <Line: +	public MendelianCheckerXRHom(MendelianInheritanceChecker parent) {
>, <Line: +		super(parent);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public ImmutableList<GenotypeCalls> filterCompatibleRecords(Collection<GenotypeCalls> calls)
>, <Line: +			throws IncompatiblePedigreeException {
>, <Line: +		// Filter to calls on X chromosome
>, <Line: +		Stream<GenotypeCalls> xCalls = calls.stream()
>, <Line: +				.filter(call -> call.getChromType() == ChromosomeType.X_CHROMOSOMAL);
>, <Line: +		// Filter to calls compatible with AD inheritance
>, <Line: +		Stream<GenotypeCalls> compatibleCalls;
>, <Line: +		if (this.pedigree.getNMembers() == 1)
>, <Line: +			compatibleCalls = xCalls.filter(this::isCompatibleSingleton);
>, <Line: +		else
>, <Line: +			compatibleCalls = xCalls.filter(this::isCompatibleFamily);
>, <Line: +		return ImmutableList.copyOf(compatibleCalls.collect(Collectors.toList()));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @return whether <code>calls</code> is compatible with AR homozygous inheritance in the case of a single
>, <Line: +	 *         individual in the pedigree
>, <Line: +	 */
>, <Line: +	private boolean isCompatibleSingleton(GenotypeCalls calls) {
>, <Line: +		if (calls.getNSamples() == 0)
>, <Line: +			return false; // no calls!
>, <Line: +		if (calls.getGenotypeBySampleNo(0).isHomAlt())
>, <Line: +			return true;
>, <Line: +		else if (pedigree.getMembers().get(0).getSex() != Sex.FEMALE && calls.getGenotypeBySampleNo(0).isHet())
>, <Line: +			return true;
>, <Line: +		else
>, <Line: +			return false;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @return whether <code>calls</code> is compatible with AR homozygous inheritance in the case of multiple
>, <Line: +	 *         individuals in the pedigree
>, <Line: +	 */
>, <Line: +	private boolean isCompatibleFamily(GenotypeCalls calls) {
>, <Line: +		return (affectedsAreCompatible(calls) && parentsAreCompatible(calls) && unaffectedsAreCompatible(calls));
>, <Line: +	}
>, <Line: +	private boolean affectedsAreCompatible(GenotypeCalls calls) {
>, <Line: +		int numVar = 0;
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			final String name = p.getName();
>, <Line: +			final Genotype gt = calls.getGenotypeForSample(name);
>, <Line: +			if (p.getDisease() == Disease.AFFECTED) {
>, <Line: +				if (gt.isHomRef()) {
>, <Line: +					// Cannot be disease-causing mutation, an affected male or female does not have it
>, <Line: +					return false;
>, <Line: +				} else if (p.getSex() == Sex.FEMALE && gt.isHet()) {
>, <Line: +					// Cannot be disease-causing mutation if a female have it heterozygous. For a male we think it is a
>, <Line: +					// misscall (alt instead of het)
>, <Line: +					return false;
>, <Line: +				} else if (gt.isHomAlt() || (p.getSex() != Sex.FEMALE && gt.isHet())) {
>, <Line: +					numVar += 1;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return (numVar > 0);
>, <Line: +	}
>, <Line: +	private boolean parentsAreCompatible(GenotypeCalls calls) {
>, <Line: +		final ImmutableSet<String> femaleParentNames = queryDecorator.getAffectedFemaleParentNames();
>, <Line: +		final ImmutableSet<String> maleParentNames = queryDecorator.getAffectedFemaleParentNames();
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			final Genotype gt = calls.getGenotypeForSample(p.getName());
>, <Line: +			if (femaleParentNames.contains(p.getName())) {
>, <Line: +				if (p.getSex() == Sex.MALE && p.getDisease() == Disease.UNAFFECTED) {
>, <Line: +					// Must always be affected. If affected it is already checked!
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				if (p.getSex() == Sex.FEMALE && (gt.isHomAlt() || gt.isHomRef())) {
>, <Line: +					// Cannot be disease-causing mutation if mother of patient is homozygous or not the carrier
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			} else if (maleParentNames.contains(p.getName())) {
>, <Line: +				if (p.getSex() == Sex.MALE && p.getDisease() == Disease.UNAFFECTED && (gt.isHomAlt() || gt.isHet())) {
>, <Line: +					// Unaffected male can not me heterozygos (wrong call) or hemizygous
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				if (p.getSex() == Sex.FEMALE && gt.isHomAlt()) {
>, <Line: +					// Cannot be disease-causing mutation if mother of patient is homozygous
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +	private boolean unaffectedsAreCompatible(GenotypeCalls calls) {
>, <Line: +		final ImmutableSet<String> unaffectedNames = queryDecorator.getUnaffectedNames();
>, <Line: +		for (Person p : pedigree.getMembers()) {
>, <Line: +			if (unaffectedNames.contains(p.getName())) {
>, <Line: +				final Genotype gt = calls.getGenotypeForSample(p.getName());
>, <Line: +				// Strict handling. Males cannot be called heterozygous (will be seen as a homozygous mutation)
>, <Line: +				if (p.isMale() && (gt.isHet() || gt.isHomAlt()))
>, <Line: +					return false;
>, <Line: +				else if (gt.isHomAlt())
>, <Line: +					return false; // cannot be disease-causing mutation (female or unknown)
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +}
>]
[]