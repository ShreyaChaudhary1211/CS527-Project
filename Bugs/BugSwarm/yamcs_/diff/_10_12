[<Line: +import java.util.function.Consumer;
>, <Line: +import org.rocksdb.RocksDBException;
>, <Line: +import org.yamcs.YProcessor;
>, <Line: +import org.yamcs.YamcsServer;
>, <Line: +import org.yamcs.parameter.ParameterCache;
>, <Line: +import org.yamcs.parameter.ParameterValue;
>, <Line: +import org.yamcs.parameterarchive.ConsumerAbortException;
>, <Line: +import org.yamcs.parameterarchive.MultiParameterDataRetrieval;
>, <Line: +import org.yamcs.parameterarchive.MultipleParameterValueRequest;
>, <Line: +import org.yamcs.parameterarchive.ParameterArchive;
>, <Line: +import org.yamcs.parameterarchive.ParameterGroupIdDb;
>, <Line: +import org.yamcs.parameterarchive.ParameterIdDb;
>, <Line: +import org.yamcs.parameterarchive.ParameterIdDb.ParameterId;
>, <Line: +import org.yamcs.parameterarchive.ParameterIdValueList;
>, <Line: +import org.yamcs.parameterarchive.ParameterValueArray;
>, <Line: +import org.yamcs.parameterarchive.SingleParameterDataRetrieval;
>, <Line: +import org.yamcs.parameterarchive.SingleParameterValueRequest;
>, <Line: +import org.yamcs.protobuf.Yamcs.Value;
>, <Line: +import org.yamcs.protobuf.Yamcs.Value.Type;
>, <Line: +import org.yamcs.utils.DecodingException;
>, <Line: +import org.yamcs.utils.IntArray;
>, <Line: +import org.yamcs.web.NotFoundException;
>, <Line: +/**
>, <Line: + * Provides parameters from ParameterArchive or via replays using {@link ArchiveParameterReplayRestHandler}
>, <Line: + * @author nm
>, <Line: + *
>, <Line: + */
>, <Line: +    private static final String DEFAULT_PROCESSOR = "realtime";
>, <Line: +    private ArchiveParameterReplayRestHandler aprh = new ArchiveParameterReplayRestHandler();
>, <Line: +        if(isReplayAsked(req)) {
>, <Line: +            aprh.getParameterSamples(req);
>, <Line: +            return;
>, <Line: +        }
>, <Line: +        String instance = verifyInstance(req, req.getRouteParam("instance"));
>, <Line: +        YProcessor realtimeProcessor = getRealtimeProc(instance, req);
>, <Line: +        /*
>, <Line: +        TODO check commented out, in order to support sampling system parameters
>, <Line: +        which don't have a type
>, <Line: +        if (ptype == null) {
>, <Line: +            throw new BadRequestException("Requested parameter has no type");
>, <Line: +        } else if (!(ptype instanceof FloatParameterType) && !(ptype instanceof IntegerParameterType)) {
>, <Line: +        }*/
>, <Line: +        long start = req.getQueryParameterAsDate("start", 0);
>, <Line: +        long stop = req.getQueryParameterAsDate("stop", TimeEncoding.getWallclockTime());
>, <Line: +        RestDownsampler sampler = new RestDownsampler(stop);
>, <Line: +        ParameterArchive parchive = getParameterArchive(instance);
>, <Line: +        ParameterIdDb piddb = parchive.getParameterIdDb();
>, <Line: +        ParameterCache pcache = null;
>, <Line: +        if(realtimeProcessor!=null) {
>, <Line: +            pcache = realtimeProcessor.getParameterCache();
>, <Line: +        ParameterId[] pids = piddb.get(p.getQualifiedName());
>, <Line: +        if(pids == null) {
>, <Line: +            log.warn("No parameter id found in the parameter archive for {}", p.getQualifiedName());
>, <Line: +            if(pcache!=null) {
>, <Line: +                sampleDataFromCache(pcache, p, start, stop, sampler);
>, <Line: +            }
>, <Line: +        } else {
>, <Line: +            ParameterGroupIdDb pgidDb = parchive.getParameterGroupIdDb();
>, <Line: +            for(ParameterId pid: pids) {
>, <Line: +                int parameterId = pid.pid;
>, <Line: +                Value.Type engType = pids[0].engType;
>, <Line: +                int[] pgids = pgidDb.getAllGroups(parameterId);
>, <Line: +                if(pgids.length ==0 ){
>, <Line: +                    log.error("Found no parameter group for parameter Id {}", parameterId);
>, <Line: +                    continue;
>, <Line: +                }
>, <Line: +                log.info("Executing a single parameter value request for time interval [{} - {}] parameterId: {} and parameter groups: {}", TimeEncoding.toString(start), TimeEncoding.toString(stop), parameterId, Arrays.toString(pgids));
>, <Line: +                SingleParameterValueRequest spvr = new SingleParameterValueRequest(start, stop, parameterId, pgids, true);
>, <Line: +                sampleDataForParameterId(parchive, engType, spvr, sampler);
>, <Line: +                if(pcache!=null) {
>, <Line: +                    sampleDataFromCache(pcache, p, start, stop, sampler);
>, <Line: +        }
>, <Line: +        TimeSeries.Builder series = TimeSeries.newBuilder();
>, <Line: +        for (Sample s : sampler.collect()) {
>, <Line: +            series.addSample(ArchiveHelper.toGPBSample(s));
>, <Line: +        }
>, <Line: +        completeOK(req, series.build(), SchemaPvalue.TimeSeries.WRITE);
>, <Line: +    }
>, <Line: +    private void sampleDataFromCache(ParameterCache pcache, Parameter p, long start, long stop, RestDownsampler sampler) {
>, <Line: +        //grab some data from the realtime processor cache
>, <Line: +        List<org.yamcs.parameter.ParameterValue> pvlist = pcache.getAllValues(p);
>, <Line: +        if(pvlist!=null) {
>, <Line: +            int n = pvlist.size();
>, <Line: +            for(int i = n-1; i>=0; i--) {
>, <Line: +                org.yamcs.parameter.ParameterValue pv = pvlist.get(i);
>, <Line: +                if(pv.getGenerationTime() < start) continue;
>, <Line: +                if(pv.getGenerationTime() > stop) break;
>, <Line: +                if(pv.getGenerationTime() > sampler.lastSampleTime()) {
>, <Line: +                    sampler.process(pv);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private void sampleDataForParameterId(ParameterArchive parchive, Value.Type engType, SingleParameterValueRequest spvr, RestDownsampler sampler) throws HttpException {
>, <Line: +        spvr.setRetrieveEngineeringValues(true);
>, <Line: +        spvr.setRetrieveParameterStatus(false);
>, <Line: +        spvr.setRetrieveRawValues(false);
>, <Line: +        SingleParameterDataRetrieval spdr = new SingleParameterDataRetrieval(parchive, spvr);
>, <Line: +        try {
>, <Line: +            spdr.retrieve(new Consumer<ParameterValueArray>() {
>, <Line: +                @Override
>, <Line: +                public void accept(ParameterValueArray t) {
>, <Line: +                    Object o = t.getEngValues();
>, <Line: +                    long[] timestamps = t.getTimestamps();
>, <Line: +                    int n = timestamps.length;
>, <Line: +                    if(o instanceof float[]) {
>, <Line: +                        float[] values = (float[])o;
>, <Line: +                        for(int i=0;i<n;i++) {
>, <Line: +                            sampler.process(timestamps[i], values[i]);
>, <Line: +                        }
>, <Line: +                    } else if(o instanceof double[]) {
>, <Line: +                        double[] values = (double[])o;
>, <Line: +                        for(int i=0;i<n;i++) {
>, <Line: +                            sampler.process(timestamps[i], values[i]);
>, <Line: +                        }
>, <Line: +                    } else if(o instanceof long[]) {
>, <Line: +                        long[] values = (long[])o;
>, <Line: +                        for(int i=0;i<n;i++) {
>, <Line: +                            if(engType==Type.UINT64) {
>, <Line: +                                sampler.process(timestamps[i], unsignedLongToDouble(values[i]));
>, <Line: +                            } else {
>, <Line: +                                sampler.process(timestamps[i], values[i]);
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    } else if(o instanceof int[]) {
>, <Line: +                        int[] values = (int[])o;
>, <Line: +                        for(int i=0;i<n;i++) {
>, <Line: +                            if(engType==Type.UINT32) {
>, <Line: +                                sampler.process(timestamps[i], values[i]&0xFFFFFFFFL);
>, <Line: +                            } else {
>, <Line: +                                sampler.process(timestamps[i], values[i]);
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    } else {
>, <Line: +                        log.warn("Unexpected value type " + o.getClass());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            });
>, <Line: +        } catch (RocksDBException | DecodingException e) {
>, <Line: +            log.warn("Received exception during parmaeter retrieval ", e);
>, <Line: +            throw new InternalServerErrorException(e.getMessage());
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private static ParameterArchive getParameterArchive(String instance) throws BadRequestException {
>, <Line: +        ParameterArchive parameterArchive = YamcsServer.getService(instance, ParameterArchive.class);
>, <Line: +        if (parameterArchive == null) {
>, <Line: +            throw new BadRequestException("ParameterArchive not configured for this instance");
>, <Line: +        }
>, <Line: +        return parameterArchive;
>, <Line: +    /**copied from guava*/
>, <Line: +    double unsignedLongToDouble(long x) {
>, <Line: +        double d = (double) (x & 0x7fffffffffffffffL);
>, <Line: +        if (x < 0) {
>, <Line: +            d += 0x1.0p63;
>, <Line: +        }
>, <Line: +        return d;
>, <Line: +    }
>, <Line: +        if(isReplayAsked(req)) {
>, <Line: +            aprh.listParameterHistory(req);
>, <Line: +            return;
>, <Line: +        }
>, <Line: +        NameDescriptionWithId<Parameter> requestedParamWithId = verifyParameterWithId(req, mdb, req.getRouteParam("name"));
>, <Line: +        Parameter p = requestedParamWithId.getItem();
>, <Line: +        NamedObjectId requestedId = requestedParamWithId.getRequestedId();
>, <Line: +        if(req.hasQueryParameter("pos")) throw new BadRequestException("pos not supported");
>, <Line: +        long start = req.getQueryParameterAsDate("start", 0);
>, <Line: +        long stop = req.getQueryParameterAsDate("stop", TimeEncoding.getWallclockTime());
>, <Line: +        boolean ascending = !req.asksDescending(true);
>, <Line: +        ParameterArchive parchive = getParameterArchive(instance);
>, <Line: +        ParameterIdDb piddb = parchive.getParameterIdDb();
>, <Line: +        IntArray pidArray = new IntArray();
>, <Line: +        IntArray pgidArray = new IntArray();
>, <Line: +        ParameterId[] pids = piddb.get(p.getQualifiedName());
>, <Line: +        if(pids != null) {
>, <Line: +            ParameterGroupIdDb pgidDb = parchive.getParameterGroupIdDb();
>, <Line: +            for(ParameterId pid:pids) {
>, <Line: +                int[] pgids = pgidDb.getAllGroups(pid.pid);
>, <Line: +                for(int pgid: pgids) {
>, <Line: +                    pidArray.add(pid.pid);
>, <Line: +                    pgidArray.add(pgid);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            if(pidArray.isEmpty()) {
>, <Line: +                log.error("No parameter group id found in the parameter archive for {}", p.getQualifiedName());
>, <Line: +                throw new NotFoundException(req);
>, <Line: +            }
>, <Line: +        } else {
>, <Line: +            log.warn("No parameter id found in the parameter archive for {}", p.getQualifiedName());
>, <Line: +        }
>, <Line: +        String[] pnames = new String[pidArray.size()];
>, <Line: +        Arrays.fill(pnames, p.getQualifiedName());
>, <Line: +        MultipleParameterValueRequest mpvr = new MultipleParameterValueRequest(start, stop, pnames, pidArray.toArray(), pgidArray.toArray(), ascending);
>, <Line: +        mpvr.setRetrieveRawValues(true);
>, <Line: +        // do not use set limit because the data can be filtered down (e.g. noRepeat) and the limit applies the final filtered data not to the input
>, <Line: +        // one day the parameter archive will be smarter and do the filtering inside
>, <Line: +        //mpvr.setLimit(limit);
>, <Line: +        YProcessor realtimeProcessor = getRealtimeProc(instance, req);
>, <Line: +        ParameterCache pcache = null;
>, <Line: +        if(realtimeProcessor!=null) {
>, <Line: +            pcache = realtimeProcessor.getParameterCache();
>, <Line: +        }
>, <Line: +                List<NamedObjectId> idList = Arrays.asList(requestedId);
>, <Line: +                RestParameterReplayListener replayListener = new RestParameterReplayListener(0, limit, req) {
>, <Line: +                    public void onParameterData(ParameterValueWithId pvwid) {
>, <Line: +                            List<org.yamcs.protobuf.Pvalue.ParameterValue> pvlist = new ArrayList<>(1);
>, <Line: +                            pvlist.add(pvwid.toGbpParameterValue());
>, <Line: +                //FIXME - make async
>, <Line: +                retrieveParameterData(parchive, pcache, p, requestedId, mpvr, replayListener);
>, <Line: +            } catch (IOException|DecodingException|RocksDBException e) {
>, <Line: +            completeOK(req, MediaType.CSV, buf);
>, <Line: +            try {
>, <Line: +                RestParameterReplayListener replayListener = new RestParameterReplayListener(0, limit, req) {
>, <Line: +                    @Override
>, <Line: +                    public void onParameterData(ParameterValueWithId  pvwid) {
>, <Line: +                        resultb.addParameter(pvwid.toGbpParameterValue());
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void update(ParameterValueWithId pvwid) {
>, <Line: +                        super.update(pvwid);
>, <Line: +                };
>, <Line: +                replayListener.setNoRepeat(noRepeat);
>, <Line: +              //FIXME - make async
>, <Line: +                retrieveParameterData(parchive, pcache, p, requestedId, mpvr, replayListener);
>, <Line: +            } catch (DecodingException|RocksDBException e) {
>, <Line: +                throw new InternalServerErrorException(e);
>, <Line: +            }
>, <Line: +            completeOK(req, resultb.build(), SchemaPvalue.ParameterData.WRITE);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private void retrieveParameterData(ParameterArchive parchive,  ParameterCache pcache, Parameter p, NamedObjectId id,
>, <Line: +            MultipleParameterValueRequest mpvr, RestParameterReplayListener replayListener) throws RocksDBException, DecodingException {
>, <Line: +        MutableLong lastParameterTime = new MutableLong(TimeEncoding.INVALID_INSTANT);
>, <Line: +        Consumer<ParameterIdValueList> consumer = new Consumer<ParameterIdValueList>() {
>, <Line: +            boolean first = true;
>, <Line: +            @Override
>, <Line: +            public void accept(ParameterIdValueList pidvList) {
>, <Line: +                lastParameterTime.l = pidvList.getValues().get(0).getGenerationTime();
>, <Line: +                if(first && !mpvr.isAscending() && (pcache!=null)) { //retrieve data from cache first
>, <Line: +                    first = false;
>, <Line: +                    sendFromCache(p, id, pcache, false, lastParameterTime.l, mpvr.getStop(), replayListener);
>, <Line: +                ParameterValue pv = pidvList.getValues().get(0);
>, <Line: +                replayListener.update(new ParameterValueWithId(pv, id));
>, <Line: +                if(replayListener.isReplayAbortRequested()) throw new ConsumerAbortException();
>, <Line: +            }
>, <Line: +        };
>, <Line: +        MultiParameterDataRetrieval mpdr = new MultiParameterDataRetrieval(parchive, mpvr);
>, <Line: +        mpdr.retrieve(consumer);
>, <Line: +        //now add some data from cache
>, <Line: +        if (pcache!=null) {
>, <Line: +            if(mpvr.isAscending())  {
>, <Line: +                long start = (lastParameterTime.l==TimeEncoding.INVALID_INSTANT)?mpvr.getStart()-1:lastParameterTime.l;
>, <Line: +                sendFromCache(p, id, pcache, true, start, mpvr.getStop(), replayListener);      
>, <Line: +            } else if (lastParameterTime.l==TimeEncoding.INVALID_INSTANT) {  //no data retrieved from archive, but maybe there is still something in the cache to send
>, <Line: +                sendFromCache(p, id, pcache, false, mpvr.getStart(), mpvr.getStop(), replayListener);
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    //send data from cache with timestamps in (start, stop) if ascending or (start, stop] if descending interval 
>, <Line: +    private void sendFromCache(Parameter p, NamedObjectId id, ParameterCache pcache, boolean ascending, long start, long stop, RestParameterReplayListener replayListener) {
>, <Line: +        List<ParameterValue> pvlist = pcache.getAllValues(p);
>, <Line: +        if(pvlist==null) return;
>, <Line: +        if(ascending) {
>, <Line: +            int n = pvlist.size();
>, <Line: +            for(int i = n-1; i>=0 ; i-- ) {
>, <Line: +                org.yamcs.parameter.ParameterValue pv = pvlist.get(i);
>, <Line: +                if(pv.getGenerationTime() >= stop) break;
>, <Line: +                if(pv.getGenerationTime()> start) {
>, <Line: +                    replayListener.update(new ParameterValueWithId(pv, id));
>, <Line: +                    if(replayListener.isReplayAbortRequested()) break;
>, <Line: +            }
>, <Line: +        } else {
>, <Line: +            for(ParameterValue pv:pvlist) {
>, <Line: +                if(pv.getGenerationTime()>stop) continue;
>, <Line: +                if(pv.getGenerationTime() <= start) break;
>, <Line: +                replayListener.update(new ParameterValueWithId(pv, id));
>, <Line: +                if(replayListener.isReplayAbortRequested()) break;
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private YProcessor getRealtimeProc(String instance, RestRequest req) throws NotFoundException {
>, <Line: +        String processorName;
>, <Line: +        if(req.hasQueryParameter("norealtime")) {
>, <Line: +            return null;
>, <Line: +        } else {
>, <Line: +            if(req.hasQueryParameter("processor")) {
>, <Line: +                processorName = req.getQueryParameter("processor");
>, <Line: +            } else {
>, <Line: +                processorName = DEFAULT_PROCESSOR;
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return YProcessor.getInstance(instance, processorName);
>, <Line: +    }
>, <Line: +    private boolean isReplayAsked(RestRequest req) throws HttpException {
>, <Line: +        if(!req.hasQueryParameter("source")) return false;
>, <Line: +        String source = req.getQueryParameter("source");
>, <Line: +        if(source.equalsIgnoreCase("ParameterArchive")) {
>, <Line: +            return false;
>, <Line: +        } else if(source.equalsIgnoreCase("replay")) {
>, <Line: +            return true;
>, <Line: +        } else {
>, <Line: +            throw new BadRequestException("Bad value for parameter 'source'; valid values are: 'ParameterArchive' or 'replay'");
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private class MutableLong {
>, <Line: +        long l;
>, <Line: +        public MutableLong(long l) {
>, <Line: +            this.l = l;
>]
[<Line: -import java.util.concurrent.CompletableFuture;
>, <Line: -import org.yamcs.protobuf.Pvalue.ParameterValue;
>, <Line: -import org.yamcs.protobuf.Yamcs.EndAction;
>, <Line: -import org.yamcs.protobuf.Yamcs.ParameterReplayRequest;
>, <Line: -import org.yamcs.protobuf.Yamcs.ReplayRequest;
>, <Line: -import org.yamcs.protobuf.Yamcs.ReplaySpeed;
>, <Line: -import org.yamcs.protobuf.Yamcs.ReplaySpeed.ReplaySpeedType;
>, <Line: -import org.yamcs.web.rest.RestReplayListener;
>, <Line: -import org.yamcs.xtce.FloatParameterType;
>, <Line: -import org.yamcs.xtce.IntegerParameterType;
>, <Line: -import org.yamcs.xtce.ParameterType;
>, <Line: -     *        rest request
>, <Line: -        String instance = verifyInstance(req, req.getRouteParam("instance"));
>, <Line: -        if ((ptype != null) && (!(ptype instanceof FloatParameterType) && !(ptype instanceof IntegerParameterType))) {
>, <Line: -        }
>, <Line: -        ReplayRequest.Builder rr = ReplayRequest.newBuilder().setEndAction(EndAction.QUIT);
>, <Line: -        rr.setSpeed(ReplaySpeed.newBuilder().setType(ReplaySpeedType.AFAP));
>, <Line: -        NamedObjectId id = NamedObjectId.newBuilder().setName(p.getQualifiedName()).build();
>, <Line: -        rr.setParameterRequest(ParameterReplayRequest.newBuilder().addNameFilter(id));
>, <Line: -        if (req.hasQueryParameter("start")) {
>, <Line: -            rr.setStart(req.getQueryParameterAsDate("start"));
>, <Line: -        rr.setStop(req.getQueryParameterAsDate("stop", TimeEncoding.getWallclockTime()));
>, <Line: -        RestDownsampler sampler = new RestDownsampler(rr.getStop());
>, <Line: -        RestReplays.replay(instance, req.getAuthToken(), rr.build(), new RestReplayListener() {
>, <Line: -            @Override
>, <Line: -            public void onParameterData(List<ParameterValueWithId> params) {
>, <Line: -                for (ParameterValueWithId pvalid : params) {
>, <Line: -                    sampler.process(pvalid.getParameterValue());
>, <Line: -            @Override
>, <Line: -            public void replayFinished() {
>, <Line: -                TimeSeries.Builder series = TimeSeries.newBuilder();
>, <Line: -                for (Sample s : sampler.collect()) {
>, <Line: -                    series.addSample(ArchiveHelper.toGPBSample(s));
>, <Line: -                completeOK(req, series.build(), SchemaPvalue.TimeSeries.WRITE);
>, <Line: -            @Override
>, <Line: -            public void replayFailed(Throwable t) {
>, <Line: -                completeWithError(req, new InternalServerErrorException(t));
>, <Line: -            }
>, <Line: -        });
>, <Line: -        String pathName = req.getRouteParam("name");
>, <Line: -        NameDescriptionWithId<Parameter> p = verifyParameterWithId(req, mdb, pathName);
>, <Line: -        long pos = req.getQueryParameterAsLong("pos", 0);
>, <Line: -        ReplayRequest rr = ArchiveHelper.toParameterReplayRequest(req, p.getItem(), true);
>, <Line: -                List<NamedObjectId> idList = Arrays.asList(p.getRequestedId());
>, <Line: -                RestParameterReplayListener replayListener = new RestParameterReplayListener(pos, limit, req) {
>, <Line: -                    public void onParameterData(List<ParameterValueWithId> params) {
>, <Line: -                            List<ParameterValue> pvlist = new ArrayList<>();
>, <Line: -                            for(ParameterValueWithId pvalid: params) {
>, <Line: -                                pvlist.add(pvalid.toGbpParameterValue());
>, <Line: -                            }
>, <Line: -                            completeWithError(req, new InternalServerErrorException(e));
>, <Line: -                    public void replayFinished() {
>, <Line: -                        completeOK(req, MediaType.CSV, buf);
>, <Line: -                    }
>, <Line: -                RestReplays.replay(instance, req.getAuthToken(), rr, replayListener);
>, <Line: -            } catch (IOException e) {
>, <Line: -            RestParameterReplayListener replayListener = new RestParameterReplayListener(pos, limit, req) {
>, <Line: -                @Override
>, <Line: -                public void onParameterData(List<ParameterValueWithId> params) {
>, <Line: -                    for(ParameterValueWithId pvalid: params) {
>, <Line: -                        resultb.addParameter(pvalid.toGbpParameterValue());
>, <Line: -                @Override
>, <Line: -                public void replayFinished() {
>, <Line: -                    completeOK(req, resultb.build(), SchemaPvalue.ParameterData.WRITE);
>, <Line: -            };
>, <Line: -            replayListener.setNoRepeat(noRepeat);
>, <Line: -            RestReplays.replay(instance, req.getAuthToken(), rr, replayListener);
>]