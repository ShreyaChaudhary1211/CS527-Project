[<Line: +package org.yamcs.algorithms;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.HashSet;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Set;
>, <Line: +import java.util.concurrent.CopyOnWriteArrayList;
>, <Line: +import org.slf4j.Logger;
>, <Line: +import org.slf4j.LoggerFactory;
>, <Line: +import org.yamcs.parameter.ParameterValue;
>, <Line: +import org.yamcs.xtce.Algorithm;
>, <Line: +import org.yamcs.xtce.InputParameter;
>, <Line: +import org.yamcs.xtce.OnParameterUpdateTrigger;
>, <Line: +import org.yamcs.xtce.Parameter;
>, <Line: +import org.yamcs.xtce.ParameterInstanceRef;
>, <Line: +public abstract class AbstractAlgorithmExecutor implements AlgorithmExecutor {
>, <Line: +    final protected AlgorithmExecutionContext execCtx;
>, <Line: +    final protected Algorithm algorithmDef;
>, <Line: +    final protected CopyOnWriteArrayList<AlgorithmExecListener> execListeners = new CopyOnWriteArrayList<AlgorithmExecListener>();
>, <Line: +    // Keep only unique arguments (for subscription purposes)
>, <Line: +    protected Set<Parameter> requiredParameters = new HashSet<Parameter>();
>, <Line: +    protected Set<InputParameter>mandatoryToRun = new HashSet<InputParameter>();
>, <Line: +    private Map<InputParameter,ParameterValue> inputValues = new HashMap<InputParameter,ParameterValue>();
>, <Line: +    static final Logger log = LoggerFactory.getLogger(AbstractAlgorithmExecutor.class);
>, <Line: +    public AbstractAlgorithmExecutor(Algorithm algorithmDef, AlgorithmExecutionContext execCtx) {
>, <Line: +        this.algorithmDef = algorithmDef;
>, <Line: +        this.execCtx = execCtx;
>, <Line: +        for(InputParameter inputParameter:algorithmDef.getInputSet()) {
>, <Line: +            requiredParameters.add(inputParameter.getParameterInstance().getParameter());
>, <Line: +            // Default-define all input values to null to prevent ugly runtime errors
>, <Line: +            String scriptName = inputParameter.getInputName();
>, <Line: +            if(scriptName==null) {
>, <Line: +                scriptName = inputParameter.getParameterInstance().getParameter().getName();
>, <Line: +            }
>, <Line: +            if(inputParameter.isMandatory()) mandatoryToRun.add(inputParameter);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * update the parameters and return true if the algorithm should run
>, <Line: +     * @param items
>, <Line: +     * @return true if the algorithm should run
>, <Line: +     */
>, <Line: +    public synchronized boolean updateParameters(ArrayList<ParameterValue> items) {
>, <Line: +        ArrayList<ParameterValue> allItems=new ArrayList<ParameterValue>(items);
>, <Line: +        boolean skipRun=false;
>, <Line: +        // Set algorithm arguments based on incoming values
>, <Line: +        for(InputParameter inputParameter:algorithmDef.getInputSet()) {
>, <Line: +            ParameterInstanceRef pInstance = inputParameter.getParameterInstance();
>, <Line: +            for(ParameterValue pval:allItems) {
>, <Line: +                if(pInstance.getParameter().equals(pval.getParameter())) {
>, <Line: +                    if(getLookbackSize(pInstance.getParameter())==0) {
>, <Line: +                        updateInput(inputParameter, pval);
>, <Line: +                        inputValues.put(inputParameter, pval);
>, <Line: +                    } else {
>, <Line: +                        ParameterValue historicValue=execCtx.getHistoricValue(pInstance);
>, <Line: +                        if(historicValue!=null) {
>, <Line: +                            updateInput(inputParameter, historicValue);
>, <Line: +                            inputValues.put(inputParameter, historicValue);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            if(!skipRun && inputParameter.isMandatory() && !inputValues.containsKey(inputParameter)) {
>, <Line: +                log.trace("Not running algorithm {} because mandatory input {} is not present", algorithmDef.getName(), inputParameter.getInputName());
>, <Line: +                skipRun = true;
>, <Line: +            }
>, <Line: +        }
>, <Line: +        // But run it only, if this satisfies an onParameterUpdate trigger
>, <Line: +        boolean triggered=false;
>, <Line: +        for(OnParameterUpdateTrigger trigger:algorithmDef.getTriggerSet().getOnParameterUpdateTriggers()) {
>, <Line: +            if(triggered) break;
>, <Line: +            for(ParameterValue pval:allItems) {
>, <Line: +                if(pval.getParameter().equals(trigger.getParameter())) {
>, <Line: +                    triggered=true;
>, <Line: +                    break;
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        boolean shouldRun =(!skipRun && triggered);
>, <Line: +        return shouldRun;
>, <Line: +    }
>, <Line: +    abstract protected void updateInput(InputParameter inputParameter, ParameterValue newValue);
>, <Line: +    protected void propagateToListeners(Object returnValue,  List<ParameterValue> outputValues){
>, <Line: +        for(AlgorithmExecListener listener: execListeners) {
>, <Line: +            listener.algorithmRun(returnValue, outputValues);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public void addExecListener(AlgorithmExecListener listener) {
>, <Line: +        execListeners.add(listener);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public AlgorithmExecutionContext getExecutionContext() {
>, <Line: +        return execCtx;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int getLookbackSize(Parameter parameter) {
>, <Line: +        // e.g. [ -3, -2, -1, 0 ]
>, <Line: +        int min=0;
>, <Line: +        for(InputParameter p:algorithmDef.getInputSet()) {
>, <Line: +            ParameterInstanceRef pInstance=p.getParameterInstance();
>, <Line: +            if(pInstance.getParameter().equals(parameter) && pInstance.getInstance()<min) {
>, <Line: +                min=p.getParameterInstance().getInstance();
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return -min;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public Set<Parameter> getRequiredParameters() {
>, <Line: +        return requiredParameters;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public Algorithm getAlgorithm() {
>, <Line: +        return algorithmDef;
>, <Line: +    }
>, <Line: +}
>]
[]