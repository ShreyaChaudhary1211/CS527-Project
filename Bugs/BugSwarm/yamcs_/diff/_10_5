[<Line: +import java.util.regex.Matcher;
>, <Line: +import java.util.regex.Pattern;
>, <Line: +import org.yamcs.utils.YObjectLoader;
>, <Line: +import org.yaml.snakeyaml.Yaml;
>, <Line: +    CopyOnWriteArrayList<AlgorithmExecutor> executionOrder=new CopyOnWriteArrayList<AlgorithmExecutor>();
>, <Line: +            final AlgorithmExecutor engine = ctx.getExecutor(algo);
>, <Line: +        AlgorithmExecutor executor = execCtx.getExecutor(algorithm);
>, <Line: +        if(executor!=null) {
>, <Line: +                executor.addExecListener(listener);
>, <Line: +        String algLang = algorithm.getLanguage();
>, <Line: +        if(algLang.equalsIgnoreCase("java")) {
>, <Line: +            executor = loadJavaExecutor(algorithm, execCtx);
>, <Line: +        } else {
>, <Line: +            ScriptEngine scriptEngine = scriptEngineManager.getEngineByName(algorithm.getLanguage());
>, <Line: +            if(scriptEngine==null) throw new RuntimeException("Cannot created a script engine for language '"+algorithm.getLanguage()+"'");
>, <Line: +            scriptEngine.put("Yamcs", new AlgorithmUtils(yproc, xtcedb, algorithm.getName()));
>, <Line: +            executor = new ScriptAlgorithmExecutor(algorithm, scriptEngine, execCtx);
>, <Line: +        }
>, <Line: +            executor.addExecListener(listener);
>, <Line: +        execCtx.addAlgorithm(algorithm, executor);
>, <Line: +            for(Parameter param:executor.getRequiredParameters()) {
>, <Line: +                int lookbackSize=executor.getLookbackSize(param);
>, <Line: +            executionOrder.add(executor); // Add at the back (dependent algorithms will come in front)
>, <Line: +                    , executor.getAlgorithm().getName(), e.invalidParameters), e);
>, <Line: +                    + executor.getAlgorithm().getName(), e);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private AlgorithmExecutor loadJavaExecutor(Algorithm alg, AlgorithmExecutionContext execCtx) {
>, <Line: +        Pattern p = Pattern.compile("([\\w\\$\\.]+)(\\(.*\\))?", Pattern.DOTALL);
>, <Line: +        Matcher m = p.matcher(alg.getAlgorithmText());
>, <Line: +        if(!m.matches()) {
>, <Line: +            log.warn("Cannot parse algorithm text '{}'", alg.getAlgorithmText());
>, <Line: +            throw new RuntimeException("Cannot parse algorithm text '"+alg.getAlgorithmText()+"'");
>, <Line: +        }
>, <Line: +        String className = m.group(1);
>, <Line: +        try {
>, <Line: +            String s = m.group(2); //this includes the parentheses
>, <Line: +            Object arg = null;
>, <Line: +            if(s!=null && s.length()>2) {//s.length>2 is to make sure there is something in between the parentheses
>, <Line: +                Yaml yaml = new Yaml();
>, <Line: +                arg = yaml.load(s.substring(1, s.length()-1));
>, <Line: +            }
>, <Line: +            if(arg==null){
>, <Line: +                return YObjectLoader.loadObject(className, alg, execCtx);
>, <Line: +            } else {
>, <Line: +                return YObjectLoader.loadObject(className, alg, execCtx, arg);
>, <Line: +            }
>, <Line: +        } catch (ConfigurationException | IOException e) {
>, <Line: +            log.warn("Cannot load object for algorithm", e);
>, <Line: +            throw new RuntimeException(e);
>, <Line: +        AlgorithmExecutor engine = execCtx.remove(algorithm);
>, <Line: +            for(Iterator<AlgorithmExecutor> it=Lists.reverse(executionOrder).iterator();it.hasNext();) {
>, <Line: +                AlgorithmExecutor engine = it.next();
>, <Line: +        for(AlgorithmExecutor executor:executionOrder) {
>, <Line: +            if(ctx==globalCtx || executor.getExecutionContext()==ctx) {
>, <Line: +                boolean shouldRun = executor.updateParameters(allItems);
>, <Line: +                    List<ParameterValue> r = executor.runAlgorithm(acqTime, genTime);
>]
[<Line: -import org.yamcs.utils.TimeEncoding;
>, <Line: -    CopyOnWriteArrayList<AlgorithmEngine> executionOrder=new CopyOnWriteArrayList<AlgorithmEngine>();
>, <Line: -            final AlgorithmEngine engine = ctx.getEngine(algo);
>, <Line: -        AlgorithmEngine engine = execCtx.getEngine(algorithm);
>, <Line: -        if(engine!=null) {
>, <Line: -                engine.addExecListener(listener);
>, <Line: -        ScriptEngine scriptEngine=scriptEngineManager.getEngineByName(algorithm.getLanguage());
>, <Line: -        if(scriptEngine==null) throw new RuntimeException("Cannot created a script engine for language '"+algorithm.getLanguage()+"'");
>, <Line: -        scriptEngine.put("Yamcs", new AlgorithmUtils(yproc, xtcedb, algorithm.getName()));
>, <Line: -        engine=new AlgorithmEngine(algorithm, scriptEngine, execCtx);
>, <Line: -            engine.addExecListener(listener);
>, <Line: -        execCtx.addAlgorithm(algorithm, engine);
>, <Line: -            for(Parameter param:engine.getRequiredParameters()) {
>, <Line: -                int lookbackSize=engine.getLookbackSize(param);
>, <Line: -            executionOrder.add(engine); // Add at the back (dependent algorithms will come in front)
>, <Line: -                    , engine.getAlgorithm().getName(), e.invalidParameters), e);
>, <Line: -                    + engine.getAlgorithm().getName(), e);
>, <Line: -        AlgorithmEngine engine = execCtx.remove(algorithm);
>, <Line: -            for(Iterator<AlgorithmEngine> it=Lists.reverse(executionOrder).iterator();it.hasNext();) {
>, <Line: -                AlgorithmEngine engine = it.next();
>, <Line: -        for(AlgorithmEngine engine:executionOrder) {
>, <Line: -            if(ctx==globalCtx || engine.execCtx==ctx) {
>, <Line: -                boolean shouldRun = engine.updateParameters(allItems);
>, <Line: -                    List<ParameterValue> r = engine.runAlgorithm(acqTime, genTime);
>]