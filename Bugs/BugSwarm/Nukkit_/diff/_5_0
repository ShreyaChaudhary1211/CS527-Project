[<Line: +import cn.nukkit.event.inventory.CraftItemEvent;
>, <Line: +        SetPlayerGameTypePacket pk = new SetPlayerGameTypePacket();
>, <Line: +                    HashMap<Integer, Float> damage = new HashMap<>();
>, <Line: +                    damage.put(EntityDamageEvent.MODIFIER_BASE, damageTable.getOrDefault(item.getId(), 1f));
>, <Line: +                if (!this.spawned || containerClosePacket.windowid == 0) {
>, <Line: +                if (this.windowIndex.containsKey(containerClosePacket.windowid)) {
>, <Line: +                } else {
>, <Line: +            case ProtocolInfo.CRAFTING_EVENT_PACKET:
>, <Line: +                CraftingEventPacket craftingEventPacket = (CraftingEventPacket) packet;
>, <Line: +                if (!this.spawned || !this.isAlive()) {
>, <Line: +                    break;
>, <Line: +                } else if (!this.windowIndex.containsKey(craftingEventPacket.windowId)) {
>, <Line: +                    this.inventory.sendContents(this);
>, <Line: +                    containerClosePacket = new ContainerClosePacket();
>, <Line: +                    containerClosePacket.windowid = craftingEventPacket.windowId;
>, <Line: +                    this.dataPacket(containerClosePacket);
>, <Line: +                    break;
>, <Line: +                }
>, <Line: +                Recipe recipe = this.server.getCraftingManager().getRecipe(craftingEventPacket.id);
>, <Line: +                if ((recipe == null) || (((recipe instanceof BigShapelessRecipe) || (recipe instanceof BigShapedRecipe)) && this.craftingType == 0)) {
>, <Line: +                    this.inventory.sendContents(this);
>, <Line: +                    break;
>, <Line: +                }
>, <Line: +                for (int i = 0; i < craftingEventPacket.input.length; i++) {
>, <Line: +                    Item inputItem = craftingEventPacket.input[i];
>, <Line: +                    if (inputItem.getDamage() == -1 || inputItem.getDamage() == 0xffff) {
>, <Line: +                        inputItem.setDamage(null);
>, <Line: +                    if (i < 9 && inputItem.getId() > 0) {
>, <Line: +                        inputItem.setCount(1);
>, <Line: +                }
>, <Line: +                boolean canCraft = true;
>, <Line: +                if (recipe instanceof ShapedRecipe) {
>, <Line: +                    for (int x = 0; x < 3 && canCraft; ++x) {
>, <Line: +                        for (int y = 0; y < 3; ++y) {
>, <Line: +                            item = craftingEventPacket.input[y * 3 + x];
>, <Line: +                            Item ingredient = ((ShapedRecipe) recipe).getIngredient(x, y);
>, <Line: +                            //todo: check this https://github.com/PocketMine/PocketMine-MP/commit/58709293cf4eee2e836a94226bbba4aca0f53908
>, <Line: +                            if (item.getCount() > 0 && item.getId() > 0) {
>, <Line: +                                if (ingredient == null || !ingredient.deepEquals(item, ingredient.hasMeta(), ingredient.getCompoundTag() != null)) {
>, <Line: +                                    canCraft = false;
>, <Line: +                                    break;
>, <Line: +                                }
>, <Line: +                            } else if (ingredient != null && ingredient.getId() != 0) {
>, <Line: +                                canCraft = false;
>, <Line: +                                break;
>, <Line: +                } else if (recipe instanceof ShapelessRecipe) {
>, <Line: +                    List<Item> needed = ((ShapelessRecipe) recipe).getIngredientList();
>, <Line: +                    for (int x = 0; x < 3 && canCraft; ++x) {
>, <Line: +                        for (int y = 0; y < 3; ++y) {
>, <Line: +                            item = craftingEventPacket.input[y * 3 + x].clone();
>, <Line: +                            for (Item n : new ArrayList<>(needed)) {
>, <Line: +                                if (n.deepEquals(item, n.hasMeta(), n.getCompoundTag() != null)) {
>, <Line: +                                    int remove = Math.min(n.getCount(), item.getCount());
>, <Line: +                                    n.setCount(n.getCount() - remove);
>, <Line: +                                    item.setCount(item.getCount() - remove);
>, <Line: +                                    if (n.getCount() == 0) {
>, <Line: +                                        needed.remove(n);
>, <Line: +                                    }
>, <Line: +                                }
>, <Line: +                            }
>, <Line: +                            if (item.getCount() > 0) {
>, <Line: +                                canCraft = false;
>, <Line: +                    if (!needed.isEmpty()) {
>, <Line: +                        canCraft = false;
>, <Line: +                } else {
>, <Line: +                    canCraft = false;
>, <Line: +                Item[] ingredients = craftingEventPacket.input;
>, <Line: +                Item result = craftingEventPacket.output[0];
>, <Line: +                if (!canCraft || !recipe.getResult().deepEquals(result)) {
>, <Line: +                    this.server.getLogger().debug("Unmatched recipe " + recipe.getId() + " from player " + this.getName() + ": expected " + recipe.getResult() + ", got " + result + ", using: " + Arrays.asList(ingredients).toString());
>, <Line: +                    this.inventory.sendContents(this);
>, <Line: +                int[] used = new int[this.inventory.getSize()];
>, <Line: +                for (Item ingredient : ingredients) {
>, <Line: +                    slot = -1;
>, <Line: +                    for (int index : this.inventory.getContents().keySet()) {
>, <Line: +                        Item i = this.inventory.getContents().get(index);
>, <Line: +                        if (ingredient.getId() != 0 && ingredient.deepEquals(i, i.hasMeta()) && (i.getCount() - used[index]) >= 1) {
>, <Line: +                            slot = index;
>, <Line: +                            used[index]++;
>, <Line: +                            break;
>, <Line: +                    if (ingredient.getId() != 0 && slot == -1) {
>, <Line: +                        canCraft = false;
>, <Line: +                }
>, <Line: +                if (!canCraft) {
>, <Line: +                    this.server.getLogger().debug("Unmatched recipe " + recipe.getId() + " from player " + this.getName() + ": client does not have enough items, using: " + Arrays.asList(ingredients).toString());
>, <Line: +                    this.inventory.sendContents(this);
>, <Line: +                CraftItemEvent craftItemEvent;
>, <Line: +                this.server.getPluginManager().callEvent(craftItemEvent = new CraftItemEvent(this, ingredients, recipe));
>, <Line: +                if (craftItemEvent.isCancelled()) {
>, <Line: +                    this.inventory.sendContents(this);
>, <Line: +                for (int i = 0; i < used.length; i++) {
>, <Line: +                    int count = used[i];
>, <Line: +                    if (count == 0) {
>, <Line: +                        continue;
>, <Line: +                    }
>, <Line: +                    item = this.inventory.getItem(i);
>, <Line: +                    Item newItem;
>, <Line: +                    if (item.getCount() > count) {
>, <Line: +                        newItem = item.clone();
>, <Line: +                        newItem.setCount(item.getCount() - count);
>, <Line: +                    } else {
>, <Line: +                        newItem = Item.get(Item.AIR, 0, 0);
>, <Line: +                    this.inventory.setItem(i, newItem);
>, <Line: +                Item[] extraItem = this.inventory.addItem(recipe.getResult());
>, <Line: +                if (extraItem.length > 0) {
>, <Line: +                    for (Item i : extraItem) {
>, <Line: +                        this.level.dropItem(this, i);
>, <Line: +                    }
>, <Line: +                //todo: achievement
>]
[<Line: -        Position spawnPosition = this.getSpawn();
>, <Line: -        StartGamePacket pk = new StartGamePacket();
>, <Line: -        pk.seed = -1;
>, <Line: -        pk.x = (float) this.x;
>, <Line: -        pk.y = (float) this.y;
>, <Line: -        pk.z = (float) this.z;
>, <Line: -        pk.spawnX = (int) spawnPosition.x;
>, <Line: -        pk.spawnY = (int) spawnPosition.y;
>, <Line: -        pk.spawnZ = (int) spawnPosition.z;
>, <Line: -        pk.generator = 1; //0 old, 1 infinite, 2 flat
>, <Line: -        pk.eid = 0;
>, <Line: -        /*pk = new SetHealthPacket();
>, <Line: -        pk.health = this.getHealth();
>, <Line: -        this.dataPacket(pk);*/
>, <Line: -                    HashMap<Integer, Float> damage = new HashMap<Integer, Float>() {
>, <Line: -                        {
>, <Line: -                            put(EntityDamageEvent.MODIFIER_BASE, damageTable.getOrDefault(item.getId(), 1f));
>, <Line: -                        }
>, <Line: -                    };
>, <Line: -                if(!this.spawned || containerClosePacket.windowid == 0){
>, <Line: -                if(this.windowIndex.containsKey(containerClosePacket.windowid)){
>, <Line: -                }else{
>, <Line: -            case ProtocolInfo.CONTAINER_SET_CONTENT_PACKET:
>, <Line: -                ContainerSetContentPacket containerSetContentPacket = (ContainerSetContentPacket) packet;
>, <Line: -                if(containerSetContentPacket.windowid == ContainerSetContentPacket.SPECIAL_CRAFTING){
>, <Line: -                    if(containerSetContentPacket.slots.length < 9){
>, <Line: -                        this.inventory.sendContents(this);
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                    for (int i = 0; i < containerSetContentPacket.slots.length; i++) {
>, <Line: -                        Item itemInContainerSetPacketSlot = containerSetContentPacket.slots[i];
>, <Line: -                        if(itemInContainerSetPacketSlot.getDamage() == -1 ||
>, <Line: -                                itemInContainerSetPacketSlot.getDamage() == 0xffff
>, <Line: -                                ){
>, <Line: -                            itemInContainerSetPacketSlot.setDamage(null);
>, <Line: -                        }
>, <Line: -                        if(i < 9 && itemInContainerSetPacketSlot.getId() > 0){
>, <Line: -                            itemInContainerSetPacketSlot.setCount(1);
>, <Line: -                        }
>, <Line: -                    Item result = containerSetContentPacket.slots[9];
>, <Line: -                    ShapelessRecipe recipe;
>, <Line: -                    if(this.craftingType == 1 || this.craftingType == 2){
>, <Line: -                        recipe = new BigShapelessRecipe(result);
>, <Line: -                    }else{
>, <Line: -                        recipe = new ShapelessRecipe(result);
>, <Line: -                    /** @var Item[] ingredients */
>, <Line: -                    Item[] ingredients = new Item[]{};
>, <Line: -                    for(int x = 0; x < 3; ++x){
>, <Line: -                        for(int y = 0; y < 3; ++y){
>, <Line: -                            Item itemInSlots = containerSetContentPacket.slots[x * 3 + y];
>, <Line: -                            if(itemInSlots.getCount() > 0 && itemInSlots.getId() > 0){
>, <Line: -                                //TODO shaped
>, <Line: -                                recipe.addIngredient(itemInSlots);
>, <Line: -                                ingredients[x * 3 + y] = itemInSlots;
>, <Line: -                    if(!Server.getInstance().getCraftingManager().matchRecipe(recipe)){
>, <Line: -                        String recipesString = "";
>, <Line: -                        for(Item i : recipe.getIngredientList()){
>, <Line: -                            recipesString += i + ",";
>, <Line: -                        }
>, <Line: -                        this.server.getLogger().debug("Unmatched recipe from player "+ this.getName() +
>, <Line: -                                ": " + recipe.getResult()+", using: " + recipesString);
>, <Line: -                        this.inventory.sendContents(this);
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                    boolean canCraft = true;
>, <Line: -                    int[] used = new int[this.inventory.getSize()];
>, <Line: -                    for(Item ingredient : ingredients){
>, <Line: -                        int slotInIngredients = -1;
>, <Line: -                        boolean checkDamage = ingredient.getDamage() != 0; //  ingredient.getDamage() == null ? false : true;
>, <Line: -                        for(Integer index : this.inventory.getContents().keySet()){
>, <Line: -                            Item i = this.inventory.getContents().get(index);
>, <Line: -                            if(ingredient.equals(i, checkDamage) && (i.getCount() - used[index]) >= 1){
>, <Line: -                                slotInIngredients = index;
>, <Line: -                                used[index]++;
>, <Line: -                        if(slotInIngredients == -1){
>, <Line: -                            canCraft = false;
>, <Line: -                            break;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    if(!canCraft){
>, <Line: -                        this.inventory.sendContents(this);
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                    for (int i = 0; i < used.length; i++) {
>, <Line: -                        int count = used[i];
>, <Line: -                        if(count == 0){
>, <Line: -                            continue;
>, <Line: -                        }
>, <Line: -                        Item itemInUsed = this.inventory.getItem(i);
>, <Line: -                        Item newItem;
>, <Line: -                        if(itemInUsed.getCount() > count){
>, <Line: -                            newItem = itemInUsed.clone();
>, <Line: -                            newItem.setCount(itemInUsed.getCount() - count);
>, <Line: -                        }else{
>, <Line: -                            newItem = Item.get(Item.AIR, 0, 0);
>, <Line: -                        }
>, <Line: -                        this.inventory.setItem(i, newItem);
>, <Line: -                    Item[] extraItems = this.inventory.addItem(recipe.getResult());
>, <Line: -                    if(extraItems.length > 0){
>, <Line: -                        for(Item extraItem : extraItems){
>, <Line: -                            this.level.dropItem(this, extraItem);
>, <Line: -                        }
>, <Line: -                    //todo award achievement
>, <Line: -                break;
>, <Line: -            /*
>, <Line: -            case ProtocolInfo.CONTAINER_SET_SLOT_PACKET:
>, <Line: -                ContainerSetSlotPacket containerSetSlotPacket = (ContainerSetSlotPacket) packet;
>, <Line: -                if(!this.spawned || this.blocked || !this.isAlive()){
>, <Line: -                    break;
>, <Line: -                }
>, <Line: -                if(containerSetSlotPacket.slot < 0){
>, <Line: -                Transaction transaction;
>, <Line: -                if(containerSetSlotPacket.windowid == 0){ //Our inventory
>, <Line: -                    if(containerSetSlotPacket.slot >= this.inventory.getSize()){
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                    if(this.isCreative()){
>, <Line: -                        if(Item.getCreativeItemIndex(containerSetSlotPacket.item) != -1){
>, <Line: -                            this.inventory.setItem(containerSetSlotPacket.slot, containerSetSlotPacket.item);
>, <Line: -                            this.inventory.setHotbarSlotIndex(containerSetSlotPacket.slot, containerSetSlotPacket.slot); //links hotbar[containerSetSlotPacket.slot] to slots[containerSetSlotPacket.slot]
>, <Line: -                    transaction = new BaseTransaction(this.inventory, containerSetSlotPacket.slot, this.inventory.getItem(containerSetSlotPacket.slot), containerSetSlotPacket.item);
>, <Line: -                }else if(containerSetSlotPacket.windowid == ContainerSetContentPacket.SPECIAL_ARMOR){ //Our armor
>, <Line: -                    if(containerSetSlotPacket.slot >= 4){
>, <Line: -                    transaction = new BaseTransaction(this.inventory, containerSetSlotPacket.slot + this.inventory.getSize(), this.inventory.getArmorItem(containerSetSlotPacket.slot), containerSetSlotPacket.item);
>, <Line: -                }else if(this.windowIndex.containsKey(containerSetSlotPacket.windowid)){
>, <Line: -                    this.craftingType = 0;
>, <Line: -                    Inventory inv = this.windowIndex.get(containerSetSlotPacket.windowid);
>, <Line: -                    transaction = new BaseTransaction(inv, containerSetSlotPacket.slot, inv.getItem(containerSetSlotPacket.slot), containerSetSlotPacket.item);
>, <Line: -                }else{
>, <Line: -                if(transaction.getSourceItem().equals(transaction.getTargetItem(), true) && transaction.getTargetItem().getCount() == transaction.getSourceItem().getCount()){ //No changes!
>, <Line: -                    //No changes, just a local inventory update sent by the server
>, <Line: -                //?
>, <Line: -                if(this.currentTransaction == null || this.currentTransaction.getCreationTime() < (System.currentTimeMillis() - 8)){
>, <Line: -                    if(this.currentTransaction != null){
>, <Line: -                        for(Inventory inventory : this.currentTransaction.getInventories()){
>, <Line: -                            if(inventory instanceof PlayerInventory){
>, <Line: -                                ((PlayerInventory)inventory).sendArmorContents(this);
>, <Line: -                            }
>, <Line: -                            inventory.sendContents(this);
>, <Line: -                        }
>, <Line: -                    this.currentTransaction = new SimpleTransactionGroup(this);
>, <Line: -                this.currentTransaction.addTransaction(transaction);
>, <Line: -                if(this.currentTransaction.canExecute()){
>, <Line: -                    //todo achievements
>, <Line: -                    this.currentTransaction = null;
>, <Line: -                break;
>, <Line: -            */
>, <Line: -            case ProtocolInfo.BLOCK_ENTITY_DATA_PACKET:
>]