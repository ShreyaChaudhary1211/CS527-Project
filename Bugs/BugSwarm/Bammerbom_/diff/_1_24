[<Line: +/*
>, <Line: + * This file is part of UltimateCore, licensed under the MIT License (MIT).
>, <Line: + *
>, <Line: + * Copyright (c) Bammerbom
>, <Line: + *
>, <Line: + * Permission is hereby granted, free of charge, to any person obtaining a copy
>, <Line: + * of this software and associated documentation files (the "Software"), to deal
>, <Line: + * in the Software without restriction, including without limitation the rights
>, <Line: + * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
>, <Line: + * copies of the Software, and to permit persons to whom the Software is
>, <Line: + * furnished to do so, subject to the following conditions:
>, <Line: + *
>, <Line: + * The above copyright notice and this permission notice shall be included in
>, <Line: + * all copies or substantial portions of the Software.
>, <Line: + *
>, <Line: + * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
>, <Line: + * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
>, <Line: + * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
>, <Line: + * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
>, <Line: + * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
>, <Line: + * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
>, <Line: + * THE SOFTWARE.
>, <Line: + */
>, <Line: +package bammerbom.ultimatecore.sponge.modules.tablist.runnables;
>, <Line: +import bammerbom.ultimatecore.sponge.api.module.Modules;
>, <Line: +import bammerbom.ultimatecore.sponge.config.ModuleConfig;
>, <Line: +import bammerbom.ultimatecore.sponge.utils.Messages;
>, <Line: +import bammerbom.ultimatecore.sponge.utils.StringUtil;
>, <Line: +import bammerbom.ultimatecore.sponge.utils.VariableUtil;
>, <Line: +import com.google.common.reflect.TypeToken;
>, <Line: +import ninja.leaping.configurate.commented.CommentedConfigurationNode;
>, <Line: +import ninja.leaping.configurate.objectmapping.ObjectMappingException;
>, <Line: +import org.spongepowered.api.Sponge;
>, <Line: +import org.spongepowered.api.entity.living.player.Player;
>, <Line: +import org.spongepowered.api.entity.living.player.tab.TabList;
>, <Line: +import org.spongepowered.api.entity.living.player.tab.TabListEntry;
>, <Line: +import org.spongepowered.api.service.permission.Subject;
>, <Line: +import org.spongepowered.api.text.Text;
>, <Line: +import java.util.*;
>, <Line: +public class TablistRunnable implements Runnable {
>, <Line: +    @Override
>, <Line: +    public void run() {
>, <Line: +        ModuleConfig config = Modules.TABLIST.get().getConfig().get();
>, <Line: +        boolean enablehf = config.get().getNode("headerfooter", "enable").getBoolean();
>, <Line: +        boolean enablenames = config.get().getNode("names", "enable").getBoolean();
>, <Line: +        if (!enablehf && !enablenames) {
>, <Line: +            return;
>, <Line: +        }
>, <Line: +        HashMap<Player, Text> names = new HashMap<>();
>, <Line: +        if (enablenames) {
>, <Line: +            for (Player p : Sponge.getServer().getOnlinePlayers()) {
>, <Line: +                names.put(p, getName(p));
>, <Line: +            }
>, <Line: +        }
>, <Line: +        String header;
>, <Line: +        String footer;
>, <Line: +        try {
>, <Line: +            header = StringUtil.join("\n", config.get().getNode("headerfooter", "header").getList(TypeToken.of(String.class)));
>, <Line: +            footer = StringUtil.join("\n", config.get().getNode("headerfooter", "footer").getList(TypeToken.of(String.class)));
>, <Line: +        } catch (ObjectMappingException e) {
>, <Line: +            e.printStackTrace();
>, <Line: +            return;
>, <Line: +        }
>, <Line: +        for (Player p : Sponge.getServer().getOnlinePlayers()) {
>, <Line: +            TabList list = p.getTabList();
>, <Line: +            //Header and footer
>, <Line: +            if (enablehf) {
>, <Line: +                list.setHeaderAndFooter(VariableUtil.replaceVariables(Messages.toText(header), p), VariableUtil.replaceVariables(Messages.toText(footer), p));
>, <Line: +            }
>, <Line: +            //Names
>, <Line: +            if (enablenames) {
>, <Line: +                new ArrayList<>(list.getEntries()).forEach(entry -> list.removeEntry(entry.getProfile().getUniqueId()));
>, <Line: +                names.forEach((player, name) -> list.addEntry(TabListEntry.builder().displayName(name).gameMode(player.gameMode().get()).latency(player.getConnection().getLatency()).list
>, <Line: +                        (list).profile(player.getProfile()).build()));
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private Text getName(Player p) {
>, <Line: +        ModuleConfig config = Modules.TABLIST.get().getConfig().get();
>, <Line: +        CommentedConfigurationNode node = config.get();
>, <Line: +        Text name = Messages.toText(node.getNode("names", "default", "format").getString());
>, <Line: +        //Check if the user is in any groups, if so replace the header/body/footer with that of the group
>, <Line: +        List<Subject> subjects = p.getSubjectData().getParents(new HashSet<>());
>, <Line: +        List<String> subjectnames = new ArrayList<>();
>, <Line: +        for (Subject su : subjects) {
>, <Line: +            subjectnames.add(su.getIdentifier());
>, <Line: +        }
>, <Line: +        Map<Object, ? extends CommentedConfigurationNode> children = node.getNode("names", "groups").getChildrenMap();
>, <Line: +        for (Object o : children.keySet()) {
>, <Line: +            if (subjectnames.contains(o.toString())) {
>, <Line: +                CommentedConfigurationNode subnode = children.get(o);
>, <Line: +                name = Messages.toText(subnode.getNode("format").getString());
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return VariableUtil.replaceVariables(name, p);
>, <Line: +    }
>, <Line: +}
>]
[]