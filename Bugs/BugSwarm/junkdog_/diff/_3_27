[<Line: +package com.artemis.injection;
>, <Line: +import com.artemis.BaseSystem;
>, <Line: +import com.artemis.ComponentMapper;
>, <Line: +import com.artemis.Manager;
>, <Line: +import com.artemis.MundaneWireException;
>, <Line: +import com.artemis.World;
>, <Line: +import com.artemis.WorldConfiguration;
>, <Line: +import com.artemis.utils.reflect.ClassReflection;
>, <Line: +import com.artemis.utils.reflect.Field;
>, <Line: +import com.artemis.utils.reflect.ReflectionException;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +/**
>, <Line: + * By default, injects {@link ComponentMapper}, {@link BaseSystem} and {@link Manager} types into systems and
>, <Line: + * managers. Can also inject arbitrary types if registered through {@link WorldConfiguration#register}.
>, <Line: + *
>, <Line: + * Caches all type-information.
>, <Line: + *
>, <Line: + * <p>
>, <Line: + *  For greater control over the dependency-resolution, provide a {@link FieldHandler} to {@link #setFieldHandler(FieldHandler)},
>, <Line: + *  which will be used to resolve dependency values instead.
>, <Line: + * </p>
>, <Line: + *
>, <Line: + * @author Arni Arent
>, <Line: + * @author Snorre E. Brekke
>, <Line: + *
>, <Line: + * @see com.artemis.injection.FieldHandler
>, <Line: + */
>, <Line: +public final class CachedInjector implements Injector {
>, <Line: +    private InjectionCache cache = new InjectionCache();
>, <Line: +    private FieldHandler fieldHandler;
>, <Line: +    @Override
>, <Line: +    public Injector setFieldHandler(FieldHandler fieldHandler) {
>, <Line: +        this.fieldHandler = fieldHandler;
>, <Line: +        return this;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public void initialize(World world, Map<String, Object> injectables) {
>, <Line: +        if (fieldHandler == null) {
>, <Line: +            fieldHandler = new FieldHandler(cache, injectables);
>, <Line: +        }
>, <Line: +        fieldHandler.initialize(world);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean isInjectable(Object target) {
>, <Line: +        try {
>, <Line: +            CachedClass cachedClass = cache.getCachedClass(target.getClass());
>, <Line: +            return cachedClass.wireType == WireType.WIRE;
>, <Line: +        } catch (ReflectionException e) {
>, <Line: +            throw new MundaneWireException("Error while wiring", e);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public void inject(Object target) throws RuntimeException {
>, <Line: +        try {
>, <Line: +            Class<?> clazz = target.getClass();
>, <Line: +            CachedClass cachedClass = cache.getCachedClass(clazz);
>, <Line: +            if (cachedClass.wireType == WireType.WIRE) {
>, <Line: +                injectValidFields(target, cachedClass);
>, <Line: +            } else {
>, <Line: +                injectAnnotatedFields(target, cachedClass);
>, <Line: +            }
>, <Line: +        } catch (ReflectionException e) {
>, <Line: +            throw new MundaneWireException("Error while wiring", e);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private void injectValidFields(Object target, CachedClass cachedClass)
>, <Line: +            throws ReflectionException {
>, <Line: +        Field[] declaredFields = getAllFields(cachedClass);
>, <Line: +        for (int i = 0, s = declaredFields.length; s > i; i++) {
>, <Line: +            injectField(target, declaredFields[i], cachedClass.failOnNull);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private Field[] getAllFields(CachedClass cachedClass) {
>, <Line: +        Field[] declaredFields = cachedClass.allFields;
>, <Line: +        if (declaredFields == null) {
>, <Line: +            List<Field> fieldList = new ArrayList<Field>();
>, <Line: +            Class<?> clazz = cachedClass.clazz;
>, <Line: +            collectDeclaredFields(fieldList, clazz);
>, <Line: +            while (cachedClass.injectInherited && (clazz = clazz.getSuperclass()) != Object.class) {
>, <Line: +                collectDeclaredFields(fieldList, clazz);
>, <Line: +            }
>, <Line: +            cachedClass.allFields = declaredFields = fieldList.toArray(new Field[fieldList.size()]);
>, <Line: +        }
>, <Line: +        return declaredFields;
>, <Line: +    }
>, <Line: +    private void collectDeclaredFields(List<Field> fieldList, Class<?> clazz) {
>, <Line: +        Field[] classFields = ClassReflection.getDeclaredFields(clazz);
>, <Line: +        for (int i = 0; i < classFields.length; i++) {
>, <Line: +            fieldList.add(classFields[i]);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private void injectAnnotatedFields(Object target, CachedClass cachedClass)
>, <Line: +            throws ReflectionException {
>, <Line: +        injectClass(target, cachedClass);
>, <Line: +    }
>, <Line: +    @SuppressWarnings("deprecation")
>, <Line: +    private void injectClass(Object target, CachedClass cachedClass) throws ReflectionException {
>, <Line: +        Field[] declaredFields = getAllFields(cachedClass);
>, <Line: +        for (int i = 0, s = declaredFields.length; s > i; i++) {
>, <Line: +            Field field = declaredFields[i];
>, <Line: +            CachedField cachedField = cache.getCachedField(field);
>, <Line: +            if (cachedField.wireType != WireType.IGNORED) {
>, <Line: +                injectField(target, field, cachedField.wireType == WireType.WIRE);
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +    private void injectField(Object target, Field field, boolean failOnNotInjected)
>, <Line: +            throws ReflectionException {
>, <Line: +        Class<?> fieldType;
>, <Line: +        try {
>, <Line: +            fieldType = field.getType();
>, <Line: +        } catch (RuntimeException ignore) {
>, <Line: +            // Swallow exception caused by missing typedata on gwt platfString.format("Failed to inject %s into %s:
>, <Line: +            // %s not registered with world.")orm.
>, <Line: +            // @todo Workaround, awaiting junkdog-ification. Silently failing injections might be undesirable for
>, <Line: +            // users failing to add systems/components to gwt reflection inclusion config.
>, <Line: +            return;
>, <Line: +        }
>, <Line: +        Object resolve = fieldHandler.resolve(fieldType, field);
>, <Line: +        if (resolve != null) {
>, <Line: +            setField(target, field, resolve);
>, <Line: +        }
>, <Line: +        if (resolve == null && failOnNotInjected && cache.getFieldClassType(fieldType) != ClassType.CUSTOM ) {
>, <Line: +            throw onFailedInjection(fieldType.getSimpleName(), field);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private void setField(Object target, Field field, Object fieldValue) throws ReflectionException {
>, <Line: +        field.setAccessible(true);
>, <Line: +        field.set(target, fieldValue);
>, <Line: +    }
>, <Line: +    private MundaneWireException onFailedInjection(String typeName, Field failedInjection) {
>, <Line: +        String error = new StringBuilder()
>, <Line: +                .append("Failed to inject ").append(failedInjection.getType().getName())
>, <Line: +                .append(" into ").append(failedInjection.getDeclaringClass().getName()).append(": ")
>, <Line: +                .append(typeName).append(" not registered with world.")
>, <Line: +                .toString();
>, <Line: +        return new MundaneWireException(error);
>, <Line: +    }
>, <Line: +}
>]
[]