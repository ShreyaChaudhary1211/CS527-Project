[<Line: +/**
>, <Line: + * Represents ObjectPropertyExpression from the OWL 2 QL Specification
>, <Line: + * 
>, <Line: + * ObjectPropertyExpression := ObjectProperty | InverseObjectProperty
>, <Line: + * InverseObjectProperty := 'ObjectInverseOf' '(' ObjectProperty ')'
>, <Line: + * 
>, <Line: + * Support for owl:topObjectProperty and owl:bottomObjectProperty
>, <Line: + *     - the inverses of the two coincide with themselves (rule [R6])
>, <Line: + * 
>, <Line: + * @author Roman Kontchakov
>, <Line: + *
>, <Line: + */
>, <Line: +	private static final OBDADataFactory ofac = OBDADataFactoryImpl.getInstance();
>, <Line: +	static final ObjectPropertyExpression owlTopObjectProperty = new ObjectPropertyExpressionImpl(owlTopObjectPropertyIRI); 
>, <Line: +	static final ObjectPropertyExpression owlBottomObjectProperty = new ObjectPropertyExpressionImpl(owlBottomObjectPropertyIRI); 
>, <Line: +	/**
>, <Line: +	 * general constructor 
>, <Line: +	 * 
>, <Line: +	 * @param p
>, <Line: +	 */
>, <Line: +	ObjectPropertyExpressionImpl(String name) {
>, <Line: +		this.predicate = ofac.getObjectPropertyPredicate(name);
>, <Line: +		this.string = name;
>, <Line: +		this.isTop = name.equals(owlTopObjectPropertyIRI);
>, <Line: +		this.isBottom = name.equals(owlBottomObjectPropertyIRI);
>, <Line: +			this.inverseProperty = this;   // rule [R6] 
>, <Line: +			this.inverseProperty = new ObjectPropertyExpressionImpl(predicate, this);
>, <Line: +	 *  (this constructor is never applied to the top and bottom properties)
>, <Line: +	private ObjectPropertyExpressionImpl(Predicate p, ObjectPropertyExpressionImpl inverseProperty) {
>, <Line: +		this.isInverse = true; // always inverted
>, <Line: +		// always inverted
>, <Line: +		this.string = new StringBuilder().append(predicate.getName()).append("^-").toString();
>, <Line: +	@Override
>, <Line: +	public String getName() {
>, <Line: +		return predicate.getName();
>, <Line: +	}
>, <Line: +		if (obj == this)
>, <Line: +			return true;
>, <Line: +			return string.equals(other.string) && (isInverse == other.isInverse);
>, <Line: +			return (isInverse == false) && getName().equals(other.getName());
>]
[<Line: -	static final ObjectPropertyExpression owlTopObjectProperty = initialize(owlTopObjectPropertyIRI); 
>, <Line: -	static final ObjectPropertyExpression owlBottomObjectProperty = initialize(owlBottomObjectPropertyIRI); 
>, <Line: -	private static ObjectPropertyExpression initialize(String uri) {
>, <Line: -		final OBDADataFactory ofac = OBDADataFactoryImpl.getInstance();
>, <Line: -		Predicate prop = ofac.getObjectPropertyPredicate(uri);
>, <Line: -		return new ObjectPropertyExpressionImpl(prop);  	
>, <Line: -	}
>, <Line: -	ObjectPropertyExpressionImpl(Predicate p) {
>, <Line: -		this.predicate = p;
>, <Line: -		this.isTop = predicate.getName().equals(owlTopObjectPropertyIRI);
>, <Line: -		this.isBottom = predicate.getName().equals(owlBottomObjectPropertyIRI);
>, <Line: -			this.inverseProperty = this;   // [R1] in the grammar simplification rules
>, <Line: -		else
>, <Line: -			this.inverseProperty = new ObjectPropertyExpressionImpl(p, !isInverse, this);
>, <Line: -		if (isInverse) {
>, <Line: -			StringBuilder bf = new StringBuilder();
>, <Line: -			bf.append(predicate.toString());
>, <Line: -			bf.append("^-");
>, <Line: -			this.string =  bf.toString();
>, <Line: -		}
>, <Line: -			this.string = predicate.toString();
>, <Line: -	 * @param isInverse
>, <Line: -	private ObjectPropertyExpressionImpl(Predicate p, boolean isInverse, ObjectPropertyExpressionImpl inverseProperty) {
>, <Line: -		this.isInverse = isInverse;
>, <Line: -		StringBuilder bf = new StringBuilder();
>, <Line: -		bf.append(predicate.toString());
>, <Line: -		if (isInverse) 
>, <Line: -			bf.append("^-");
>, <Line: -		this.string =  bf.toString();
>, <Line: -			return (isInverse == other.isInverse) && predicate.equals(other.predicate);
>, <Line: -			return (isInverse == false) && predicate.equals(other.getPredicate());
>]