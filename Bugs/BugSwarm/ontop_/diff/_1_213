[<Line: +import it.unibz.krdb.obda.ontology.BinaryAxiom;
>, <Line: +import it.unibz.krdb.obda.ontology.ClassExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataPropertyExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataPropertyRangeExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataRangeExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataSomeValuesFrom;
>, <Line: +import it.unibz.krdb.obda.ontology.Datatype;
>, <Line: +import it.unibz.krdb.obda.ontology.OClass;
>, <Line: +import it.unibz.krdb.obda.ontology.ObjectPropertyExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.ObjectSomeValuesFrom;
>, <Line: +import it.unibz.krdb.obda.ontology.Ontology;
>, <Line: +import it.unibz.krdb.obda.ontology.impl.DatatypeImpl;
>, <Line: +import java.util.Collections;
>, <Line: +import java.util.Comparator;
>, <Line: +import com.google.common.collect.ImmutableSet;
>, <Line: + * TBoxReasonerImpl
>, <Line: + * 
>, <Line: + *    a DAG-based TBox reasoner
>, <Line: + *    
>, <Line: + * @author Roman Kontchakov
>, <Line: +	 * constructs a TBox reasoner from an ontology
>, <Line: +	 * @param onto: ontology
>, <Line: +	public static TBoxReasoner create(Ontology onto) {
>, <Line: +		return create(onto, false);
>, <Line: +	}
>, <Line: +	public static TBoxReasoner create(Ontology onto, boolean equivalenceReduced) {
>, <Line: +		final DefaultDirectedGraph<ObjectPropertyExpression, DefaultEdge> objectPropertyGraph = 
>, <Line: +				getObjectPropertyGraph(onto);
>, <Line: +		final EquivalencesDAGImpl<ObjectPropertyExpression> objectPropertyDAG = 
>, <Line: +				EquivalencesDAGImpl.getEquivalencesDAG(objectPropertyGraph);
>, <Line: +		final DefaultDirectedGraph<DataPropertyExpression, DefaultEdge> dataPropertyGraph = 
>, <Line: +				getDataPropertyGraph(onto);
>, <Line: +		final EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG = 
>, <Line: +				EquivalencesDAGImpl.getEquivalencesDAG(dataPropertyGraph);	
>, <Line: +		final EquivalencesDAGImpl<ClassExpression> classDAG = 
>, <Line: +				 EquivalencesDAGImpl.getEquivalencesDAG(getClassGraph(onto, objectPropertyGraph, dataPropertyGraph));
>, <Line: +		final EquivalencesDAGImpl<DataRangeExpression> dataRangeDAG = 
>, <Line: +				 EquivalencesDAGImpl.getEquivalencesDAG(getDataRangeGraph(onto, dataPropertyGraph));
>, <Line: +		TBoxReasonerImpl r = new TBoxReasonerImpl(classDAG, dataRangeDAG, objectPropertyDAG, dataPropertyDAG);
>, <Line: +		if (equivalenceReduced) {
>, <Line: +			r = getEquivalenceSimplifiedReasoner(r);
>, <Line: +		}
>, <Line: +		return r;
>, <Line: +	 * constructs from DAGs
>, <Line: +						EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG) {
>, <Line: +	 * Return the DAG of object properties
>, <Line: +	/**
>, <Line: +	 * Return the DAG of data properties
>, <Line: +	 * 
>, <Line: +	 * @return DAG 
>, <Line: +	 */
>, <Line: +			int compared = o1.getName().compareTo(o2.getName()); 
>, <Line: +			int compared = o1.getName().compareTo(o2.getName()); 
>, <Line: +	private static void chooseObjectPropertyRepresentatives(EquivalencesDAGImpl<ObjectPropertyExpression> dag) {
>, <Line: +	private static void chooseDataPropertyRepresentatives(EquivalencesDAGImpl<DataPropertyExpression> dag) {
>, <Line: +			return o1.getName().compareTo(o2.getName());
>, <Line: +	private static void chooseClassRepresentatives(EquivalencesDAGImpl<ClassExpression> dag, 
>, <Line: +						representative = propRep.getDomainRestriction(DatatypeImpl.rdfsLiteral);
>, <Line: +	private static void chooseDataRangeRepresentatives(EquivalencesDAGImpl<DataRangeExpression> dag, 
>, <Line: +		for (Equivalences<DataRangeExpression> equivalenceSet : dag) {
>, <Line: +			DataRangeExpression representative = null;			
>, <Line: +			if (equivalenceSet.size() <= 1) {
>, <Line: +				representative = equivalenceSet.iterator().next();
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				// find a named class as a representative 
>, <Line: +				Datatype namedRepresentative = null;
>, <Line: +				for (DataRangeExpression e : equivalenceSet) 
>, <Line: +					if (e instanceof Datatype) {
>, <Line: +						if (namedRepresentative == null || datatypeComparator.compare((Datatype)e, namedRepresentative) < 0)
>, <Line: +							namedRepresentative = (Datatype)e;
>, <Line: +					}
>, <Line: +				if (namedRepresentative == null) {
>, <Line: +					DataRangeExpression first = equivalenceSet.iterator().next();
>, <Line: +					assert (first instanceof DataPropertyRangeExpression);
>, <Line: +					DataPropertyRangeExpression firstp = (DataPropertyRangeExpression)first;
>, <Line: +					DataPropertyExpression prop = firstp.getProperty();
>, <Line: +	                Equivalences<DataPropertyExpression> vertex = dataPropertyDAG.getVertex(prop);
>, <Line: +	                if (vertex == null){
>, <Line: +	                    throw new IllegalStateException("Unknown data property: " + prop);
>, <Line: +	                }
>, <Line: +	                DataPropertyExpression propRep = vertex.getRepresentative();
>, <Line: +					representative = propRep.getRange();
>, <Line: +				}
>, <Line: +				else
>, <Line: +					representative = namedRepresentative;
>, <Line: +			equivalenceSet.setRepresentative(representative);
>, <Line: +			if (representative instanceof OClass)
>, <Line: +				equivalenceSet.setIndexed();
>, <Line: +		}		
>, <Line: +	/**
>, <Line: +	 * constructs a TBoxReasoner that has a reduced number of classes and properties in each equivalent class
>, <Line: +	 *  
>, <Line: +	 *   - each object property equivalence class contains one property (representative)
>, <Line: +	 *     except when the representative property is equivalent to its inverse, in which 
>, <Line: +	 *     case the equivalence class contains both the property and its inverse
>, <Line: +	 *     
>, <Line: +	 *   - each data property equivalence class contains a single property (representative)
>, <Line: +	 *   
>, <Line: +	 *   - each class equivalence class contains the representative and all domains / ranges 
>, <Line: +	 *     of the representatives of property equivalence classes
>, <Line: +	 *     
>, <Line: +	 *  in other words, the constructed TBoxReasoner is the restriction to the vocabulary of the representatives
>, <Line: +	 *     all other symbols are mapped to the nodes via *Equivalences hash-maps
>, <Line: +	 *     
>, <Line: +	 * @param reasoner
>, <Line: +	 * @return reduced reasoner
>, <Line: +	 */
>, <Line: +	private static TBoxReasonerImpl getEquivalenceSimplifiedReasoner(TBoxReasoner reasoner) {
>, <Line: +		// OBJECT PROPERTIES
>, <Line: +		// 		
>, <Line: +		SimpleDirectedGraph<Equivalences<ObjectPropertyExpression>, DefaultEdge> objectProperties 
>, <Line: +			ObjectPropertyExpression rep = node.getRepresentative();
>, <Line: +			ObjectPropertyExpression repInv = rep.getInverse();
>, <Line: +			Equivalences<ObjectPropertyExpression> reducedNode;
>, <Line: +			if (!node.contains(repInv))
>, <Line: +				reducedNode = new Equivalences<>(ImmutableSet.of(rep), rep, node.isIndexed());
>, <Line: +			else
>, <Line: +				// the object property is equivalent to its inverse
>, <Line: +				reducedNode = new Equivalences<>(ImmutableSet.of(rep, repInv), rep, node.isIndexed());	
>, <Line: +		EquivalencesDAGImpl<ObjectPropertyExpression> objectPropertyDAG = EquivalencesDAGImpl.reduce(
>, <Line: +				(EquivalencesDAGImpl<ObjectPropertyExpression>)reasoner.getObjectPropertyDAG(), objectProperties);
>, <Line: +		// DATA PROPERTIES
>, <Line: +		// 		
>, <Line: +		SimpleDirectedGraph<Equivalences<DataPropertyExpression>, DefaultEdge> dataProperties 
>, <Line: +			DataPropertyExpression rep = node.getRepresentative();
>, <Line: +			Equivalences<DataPropertyExpression> reducedNode = new Equivalences<>(ImmutableSet.of(rep), rep, node.isIndexed());
>, <Line: +		EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG = EquivalencesDAGImpl.reduce(
>, <Line: +				(EquivalencesDAGImpl<DataPropertyExpression>)reasoner.getDataPropertyDAG(), dataProperties);
>, <Line: +		SimpleDirectedGraph<Equivalences<ClassExpression>, DefaultEdge> classes = new SimpleDirectedGraph<>(DefaultEdge.class);
>, <Line: +			ImmutableSet.Builder<ClassExpression> reduced = new ImmutableSet.Builder<>();	
>, <Line: +				else if (equi instanceof OClass) {
>, <Line: +					//OClass equiClass = (OClass) equi;
>, <Line: +					//classEquivalenceMap.put(equiClass.getName(), (OClass)rep);
>, <Line: +					if (objectPropertyDAG.getVertex(((ObjectSomeValuesFrom) equi).getProperty()) != null)
>, <Line: +					if (dataPropertyDAG.getVertex(((DataSomeValuesFrom) equi).getProperty()) != null)
>, <Line: +			Equivalences<ClassExpression> reducedNode = new Equivalences<>(reduced.build(), rep, node.isIndexed());			
>, <Line: +		EquivalencesDAGImpl<ClassExpression> classDAG = EquivalencesDAGImpl.reduce(
>, <Line: +				(EquivalencesDAGImpl<ClassExpression>)reasoner.getClassDAG(), classes);
>, <Line: +		// DATA RANGES
>, <Line: +		// 
>, <Line: +		// TODO: a proper implementation is in order here
>, <Line: +		return new TBoxReasonerImpl(classDAG, (EquivalencesDAGImpl<DataRangeExpression>)reasoner.getDataRangeDAG(), 
>, <Line: +				objectPropertyDAG, dataPropertyDAG);
>, <Line: +	/**
>, <Line: +	 *  graph representation of object property inclusions in the ontology
>, <Line: +	 *  
>, <Line: +	 *  adds inclusions between the inverses of R and S if
>, <Line: +	 *         R is declared a sub-property of S in the ontology
>, <Line: +	 * 
>, <Line: +	 * @param an ontology 
>, <Line: +	 * @return the graph of the property inclusions 
>, <Line: +	 */
>, <Line: +	private static DefaultDirectedGraph<ObjectPropertyExpression,DefaultEdge> getObjectPropertyGraph(Ontology ontology) {
>, <Line: +		DefaultDirectedGraph<ObjectPropertyExpression,DefaultEdge> graph = new DefaultDirectedGraph<>(DefaultEdge.class);
>, <Line: +		for (ObjectPropertyExpression role : ontology.getVocabulary().getObjectProperties()) {
>, <Line: +			if (!role.isBottom() && !role.isTop()) {
>, <Line: +				graph.addVertex(role);
>, <Line: +				graph.addVertex(role.getInverse());
>, <Line: +		for (ObjectPropertyExpression role : ontology.getAuxiliaryObjectProperties()) {
>, <Line: +			graph.addVertex(role);
>, <Line: +			graph.addVertex(role.getInverse());
>, <Line: +		}
>, <Line: +		// property inclusions
>, <Line: +		for (BinaryAxiom<ObjectPropertyExpression> roleIncl : ontology.getSubObjectPropertyAxioms()) {
>, <Line: +			// adds the direct edge and the inverse (e.g., R ISA S and R- ISA S-)
>, <Line: +			graph.addEdge(roleIncl.getSub(), roleIncl.getSuper());			
>, <Line: +			graph.addEdge(roleIncl.getSub().getInverse(), roleIncl.getSuper().getInverse());
>, <Line: +		}
>, <Line: +	/**
>, <Line: +	 *  graph representation of data property inclusions in the ontology
>, <Line: +	 *  
>, <Line: +	 *  adds inclusions between the inverses of R and S if
>, <Line: +	 *         R is declared a sub-property of S in the ontology
>, <Line: +	 * 
>, <Line: +	 * @param an ontology 
>, <Line: +	 * @return the graph of the property inclusions 
>, <Line: +	 */
>, <Line: +	private static DefaultDirectedGraph<DataPropertyExpression,DefaultEdge> getDataPropertyGraph(Ontology ontology) {
>, <Line: +		DefaultDirectedGraph<DataPropertyExpression,DefaultEdge> graph = new DefaultDirectedGraph<>(DefaultEdge.class);
>, <Line: +		for (DataPropertyExpression role : ontology.getVocabulary().getDataProperties()) 
>, <Line: +			if (!role.isBottom() && !role.isTop()) 
>, <Line: +				graph.addVertex(role);
>, <Line: +		for (BinaryAxiom<DataPropertyExpression> roleIncl : ontology.getSubDataPropertyAxioms()) 
>, <Line: +			graph.addEdge(roleIncl.getSub(), roleIncl.getSuper());
>, <Line: +		return graph;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * graph representation of the class inclusions in the ontology
>, <Line: +	 * adds inclusions of the domain of R in the domain of S if
>, <Line: +	 *           the provided property graph has an edge from R to S
>, <Line: +	 *           (given the getPropertyGraph algorithm, this also 
>, <Line: +	 *           implies inclusions of the range of R in the range of S
>, <Line: +	 * @param ontology
>, <Line: +	 * @param objectPropertyGraph obtained by getObjectPropertyGraph
>, <Line: +	 * @param dataPropertyGraph obtained by getDataPropertyGraph
>, <Line: +	 * @return the graph of the concept inclusions
>, <Line: +	private static DefaultDirectedGraph<ClassExpression,DefaultEdge> getClassGraph (Ontology ontology, 
>, <Line: +													DefaultDirectedGraph<ObjectPropertyExpression,DefaultEdge> objectPropertyGraph, 
>, <Line: +													DefaultDirectedGraph<DataPropertyExpression,DefaultEdge> dataPropertyGraph) {
>, <Line: +		DefaultDirectedGraph<ClassExpression,DefaultEdge> graph = new DefaultDirectedGraph<>(DefaultEdge.class);
>, <Line: +		for (OClass concept : ontology.getVocabulary().getClasses()) 
>, <Line: +			if (!concept.isBottom() && !concept.isTop()) 
>, <Line: +				graph.addVertex(concept);
>, <Line: +		// domains and ranges of roles
>, <Line: +		for (ObjectPropertyExpression role : objectPropertyGraph.vertexSet()) 
>, <Line: +			graph.addVertex(role.getDomain());			
>, <Line: +		// edges between the domains and ranges for sub-properties
>, <Line: +		for (DefaultEdge edge : objectPropertyGraph.edgeSet()) {
>, <Line: +			ObjectPropertyExpression child = objectPropertyGraph.getEdgeSource(edge);
>, <Line: +			ObjectPropertyExpression parent = objectPropertyGraph.getEdgeTarget(edge);
>, <Line: +			graph.addEdge(child.getDomain(), parent.getDomain());		
>, <Line: +		// domains and ranges of roles
>, <Line: +		for (DataPropertyExpression role : dataPropertyGraph.vertexSet()) 
>, <Line: +			for (DataSomeValuesFrom dom : role.getAllDomainRestrictions())
>, <Line: +				graph.addVertex(dom);			
>, <Line: +		// edges between the domains and ranges for sub-properties
>, <Line: +		for (DefaultEdge edge : dataPropertyGraph.edgeSet()) {
>, <Line: +			DataPropertyExpression child = dataPropertyGraph.getEdgeSource(edge);
>, <Line: +			DataPropertyExpression parent = dataPropertyGraph.getEdgeTarget(edge);
>, <Line: +			graph.addEdge(child.getDomainRestriction(DatatypeImpl.rdfsLiteral), parent.getDomainRestriction(DatatypeImpl.rdfsLiteral));		
>, <Line: +		}
>, <Line: +		// class inclusions from the ontology
>, <Line: +		for (BinaryAxiom<ClassExpression> clsIncl : ontology.getSubClassAxioms()) 
>, <Line: +			graph.addEdge(clsIncl.getSub(), clsIncl.getSuper());
>, <Line: +		return graph;
>, <Line: +	}
>, <Line: +	private static DefaultDirectedGraph<DataRangeExpression,DefaultEdge> getDataRangeGraph (Ontology ontology, 
>, <Line: +							DefaultDirectedGraph<DataPropertyExpression,DefaultEdge> dataPropertyGraph) {
>, <Line: +		DefaultDirectedGraph<DataRangeExpression,DefaultEdge> dataRangeGraph 
>, <Line: +					= new  DefaultDirectedGraph<DataRangeExpression,DefaultEdge>(DefaultEdge.class);
>, <Line: +		// ranges of roles
>, <Line: +		for (DataPropertyExpression role : dataPropertyGraph.vertexSet()) 
>, <Line: +			dataRangeGraph.addVertex(role.getRange());			
>, <Line: +		// edges between the ranges for sub-properties
>, <Line: +		for (DefaultEdge edge : dataPropertyGraph.edgeSet()) {
>, <Line: +			DataPropertyExpression child = dataPropertyGraph.getEdgeSource(edge);
>, <Line: +			DataPropertyExpression parent = dataPropertyGraph.getEdgeTarget(edge);
>, <Line: +			dataRangeGraph.addEdge(child.getRange(), parent.getRange());		
>, <Line: +		}
>, <Line: +		// data range inclusions from the ontology
>, <Line: +		for (BinaryAxiom<DataRangeExpression> clsIncl : ontology.getSubDataRangeAxioms()) {
>, <Line: +			dataRangeGraph.addVertex(clsIncl.getSuper()); // Datatype is not among the vertices from the start
>, <Line: +			dataRangeGraph.addEdge(clsIncl.getSub(), clsIncl.getSuper());
>, <Line: +		return dataRangeGraph;
>]
[<Line: -import it.unibz.krdb.obda.model.Predicate;
>, <Line: -import it.unibz.krdb.obda.ontology.*;
>, <Line: -import java.util.*;
>, <Line: - * Allows to reason over the TBox using  DAG or graph
>, <Line: -	 * the EquivalenceMap maps predicates to the representatives of their equivalence class (in TBox)
>, <Line: -	 * 
>, <Line: -	 * it contains 
>, <Line: -	 * 		- an entry for each property name other than the representative of an equivalence class 
>, <Line: -	 * 				(or its inverse)
>, <Line: -	 * 		- an entry for each class name other than the representative of its equivalence class
>, <Line: -	private final Map<Predicate, OClass> classEquivalenceMap;
>, <Line: -	private final Map<Predicate, ObjectPropertyExpression> objectPropertyEquivalenceMap;	
>, <Line: -	private final Map<Predicate, DataPropertyExpression> dataPropertyEquivalenceMap;	
>, <Line: -	/**
>, <Line: -	 * constructs from a raw ontology
>, <Line: -	 * @param onto: ontology
>, <Line: -	 */
>, <Line: -	public TBoxReasonerImpl(Ontology onto) {
>, <Line: -		objectPropertyDAG = EquivalencesDAGImpl.getEquivalencesDAG(OntologyGraph.getObjectPropertyGraph(onto));	
>, <Line: -		dataPropertyDAG = EquivalencesDAGImpl.getEquivalencesDAG(OntologyGraph.getDataPropertyGraph(onto));	
>, <Line: -		classDAG = EquivalencesDAGImpl.getEquivalencesDAG(OntologyGraph.getClassGraph(onto, objectPropertyDAG.getGraph(), dataPropertyDAG.getGraph(), false));
>, <Line: -		dataRangeDAG = EquivalencesDAGImpl.getEquivalencesDAG(OntologyGraph.getDataRangeGraph(onto, dataPropertyDAG.getGraph()));
>, <Line: -		this.classEquivalenceMap = new HashMap<>();
>, <Line: -		this.objectPropertyEquivalenceMap = new  HashMap<>();		
>, <Line: -		this.dataPropertyEquivalenceMap = new  HashMap<>();		
>, <Line: -	 * constructs from DAGs and equivalence maps (for the equivalence simplification) 
>, <Line: -	 * @param classEquivalenceMap
>, <Line: -	 * @param propertyEquivalenceMap
>, <Line: -						EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG, 
>, <Line: -						Map<Predicate, OClass> classEquivalenceMap, 
>, <Line: -						Map<Predicate, ObjectPropertyExpression> objectPropertyEquivalenceMap,
>, <Line: -						Map<Predicate, DataPropertyExpression> dataPropertyEquivalenceMap) {
>, <Line: -		this.classEquivalenceMap = classEquivalenceMap;
>, <Line: -		this.objectPropertyEquivalenceMap = objectPropertyEquivalenceMap;		
>, <Line: -		this.dataPropertyEquivalenceMap = dataPropertyEquivalenceMap;		
>, <Line: -	}
>, <Line: -    /**
>, <Line: -     * constructs from graphs (for the chain reasoner)
>, <Line: -     * @param propertyGraph
>, <Line: -     * @param classGraph
>, <Line: -     */
>, <Line: -	private TBoxReasonerImpl(DefaultDirectedGraph<ObjectPropertyExpression,DefaultEdge> objectPropertyGraph, 
>, <Line: -					DefaultDirectedGraph<DataPropertyExpression,DefaultEdge> dataPropertyGraph, 
>, <Line: -					DefaultDirectedGraph<ClassExpression,DefaultEdge> classGraph,
>, <Line: -					DefaultDirectedGraph<DataRangeExpression,DefaultEdge> dataRangeGraph) {
>, <Line: -		objectPropertyDAG = EquivalencesDAGImpl.getEquivalencesDAG(objectPropertyGraph);		
>, <Line: -		dataPropertyDAG = EquivalencesDAGImpl.getEquivalencesDAG(dataPropertyGraph);		
>, <Line: -		classDAG = EquivalencesDAGImpl.getEquivalencesDAG(classGraph);
>, <Line: -		dataRangeDAG = EquivalencesDAGImpl.getEquivalencesDAG(dataRangeGraph);
>, <Line: -		chooseObjectPropertyRepresentatives(objectPropertyDAG);
>, <Line: -		chooseDataPropertyRepresentatives(dataPropertyDAG);
>, <Line: -		chooseClassRepresentatives(classDAG, objectPropertyDAG, dataPropertyDAG);
>, <Line: -		chooseDataRangeRepresentatives(dataRangeDAG, dataPropertyDAG);
>, <Line: -		this.classEquivalenceMap = new HashMap<>();
>, <Line: -		this.objectPropertyEquivalenceMap = new  HashMap<>();				
>, <Line: -		this.dataPropertyEquivalenceMap = new  HashMap<>();				
>, <Line: -	 * Return the DAG of properties
>, <Line: -	@Override
>, <Line: -	public OClass getClassRepresentative(OClass p) {
>, <Line: -		return classEquivalenceMap.get(p.getPredicate());
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public ObjectPropertyExpression getObjectPropertyRepresentative(ObjectPropertyExpression p) {
>, <Line: -		return objectPropertyEquivalenceMap.get(p.getPredicate());
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public DataPropertyExpression getDataPropertyRepresentative(DataPropertyExpression p) {
>, <Line: -		return dataPropertyEquivalenceMap.get(p.getPredicate());
>, <Line: -	}
>, <Line: -			int compared = o1.getPredicate().getName().compareTo(o2.getPredicate().getName()); 
>, <Line: -			int compared = o1.getPredicate().getName().compareTo(o2.getPredicate().getName()); 
>, <Line: -	public static void chooseObjectPropertyRepresentatives(EquivalencesDAGImpl<ObjectPropertyExpression> dag) {
>, <Line: -			// System.out.println("SET REP: " + set);
>, <Line: -				//System.out.println("SET REP: " + setInv);
>, <Line: -	public static void chooseDataPropertyRepresentatives(EquivalencesDAGImpl<DataPropertyExpression> dag) {
>, <Line: -			return o1.getPredicate().getName().compareTo(o2.getPredicate().getName());
>, <Line: -	public static void chooseClassRepresentatives(EquivalencesDAGImpl<ClassExpression> dag, 
>, <Line: -						representative = propRep.getDomain();
>, <Line: -	public static void chooseDataRangeRepresentatives(EquivalencesDAGImpl<DataRangeExpression> dag, 
>, <Line: -	for (Equivalences<DataRangeExpression> equivalenceSet : dag) {
>, <Line: -		DataRangeExpression representative = null;			
>, <Line: -		if (equivalenceSet.size() <= 1) {
>, <Line: -			representative = equivalenceSet.iterator().next();
>, <Line: -		}
>, <Line: -		else {
>, <Line: -			// find a named class as a representative 
>, <Line: -			Datatype namedRepresentative = null;
>, <Line: -			for (DataRangeExpression e : equivalenceSet) 
>, <Line: -				if (e instanceof Datatype) {
>, <Line: -					if (namedRepresentative == null || datatypeComparator.compare((Datatype)e, namedRepresentative) < 0)
>, <Line: -						namedRepresentative = (Datatype)e;
>, <Line: -				}
>, <Line: -			if (namedRepresentative == null) {
>, <Line: -				DataRangeExpression first = equivalenceSet.iterator().next();
>, <Line: -				assert (first instanceof DataPropertyRangeExpression);
>, <Line: -				DataPropertyRangeExpression firstp = (DataPropertyRangeExpression)first;
>, <Line: -				DataPropertyExpression prop = firstp.getProperty();
>, <Line: -                Equivalences<DataPropertyExpression> vertex = dataPropertyDAG.getVertex(prop);
>, <Line: -                if (vertex == null){
>, <Line: -                    throw new IllegalStateException("Unknown data property: " + prop);
>, <Line: -                }
>, <Line: -                DataPropertyExpression propRep = vertex.getRepresentative();
>, <Line: -				representative = propRep.getRange();
>, <Line: -			else
>, <Line: -				representative = namedRepresentative;
>, <Line: -		}
>, <Line: -		equivalenceSet.setRepresentative(representative);
>, <Line: -		if (representative instanceof OClass)
>, <Line: -			equivalenceSet.setIndexed();
>, <Line: -}
>, <Line: -	public static TBoxReasonerImpl getEquivalenceSimplifiedReasoner(TBoxReasoner reasoner) {
>, <Line: -		Map<Predicate, ObjectPropertyExpression> objectPropertyEquivalenceMap = new HashMap<>();
>, <Line: -		SimpleDirectedGraph <Equivalences<ObjectPropertyExpression>,DefaultEdge> objectProperties 
>, <Line: -		Map<ObjectPropertyExpression, Equivalences<ObjectPropertyExpression>> objectPropertyEquivalences = new HashMap<>();
>, <Line: -			ObjectPropertyExpression prop = node.getRepresentative();
>, <Line: -			ObjectPropertyExpression inverseProp = prop.getInverse();
>, <Line: -			Set<ObjectPropertyExpression> reduced = new HashSet<>();
>, <Line: -			Equivalences<ObjectPropertyExpression> reducedNode = new Equivalences<>(reduced, prop);
>, <Line: -			for (ObjectPropertyExpression equi : node) {
>, <Line: -				// no map entry if the property coincides with its inverse
>, <Line: -				if (equi.equals(prop) || equi.equals(inverseProp)) {
>, <Line: -					objectPropertyEquivalences.put(equi, reducedNode);
>, <Line: -					reduced.add(equi);
>, <Line: -					continue;
>, <Line: -				}
>, <Line: -				// if the property is different from its inverse, an entry is created 
>, <Line: -				// (taking the inverses into account)
>, <Line: -				if (equi.isInverse()) 
>, <Line: -					objectPropertyEquivalenceMap.put(equi.getPredicate(), inverseProp);
>, <Line: -				else 
>, <Line: -					objectPropertyEquivalenceMap.put(equi.getPredicate(), prop);
>, <Line: -			}
>, <Line: -			if (node.isIndexed())
>, <Line: -				reducedNode.setIndexed();
>, <Line: -		// create edges for the properties graph
>, <Line: -		copyEdges(reasoner.getObjectPropertyDAG(), objectPropertyEquivalences, objectProperties);
>, <Line: -		EquivalencesDAGImpl<ObjectPropertyExpression> objectPropertyDAG = new EquivalencesDAGImpl<>(null, objectProperties, objectPropertyEquivalences);
>, <Line: -		Map<Predicate, DataPropertyExpression> dataPropertyEquivalenceMap = new HashMap<>();
>, <Line: -		SimpleDirectedGraph <Equivalences<DataPropertyExpression>,DefaultEdge> dataProperties 
>, <Line: -		Map<DataPropertyExpression, Equivalences<DataPropertyExpression>> dataPropertyEquivalences = new HashMap<>();
>, <Line: -			DataPropertyExpression prop = node.getRepresentative();
>, <Line: -			Set<DataPropertyExpression> reduced = new HashSet<>();
>, <Line: -			Equivalences<DataPropertyExpression> reducedNode = new Equivalences<>(reduced, prop);
>, <Line: -			for (DataPropertyExpression equi : node) {
>, <Line: -				// no map entry if the property coincides with its inverse
>, <Line: -				if (equi.equals(prop)) {
>, <Line: -					dataPropertyEquivalences.put(equi, reducedNode);
>, <Line: -					reduced.add(equi);
>, <Line: -					continue;
>, <Line: -				}
>, <Line: -				// if the property is different from its inverse, an entry is created 
>, <Line: -				// (taking the inverses into account)
>, <Line: -				dataPropertyEquivalenceMap.put(equi.getPredicate(), prop);
>, <Line: -			}
>, <Line: -			if (node.isIndexed())
>, <Line: -				reducedNode.setIndexed();
>, <Line: -		// create edges for the properties graph
>, <Line: -		copyEdges(reasoner.getDataPropertyDAG(), dataPropertyEquivalences, dataProperties);
>, <Line: -		EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG = new EquivalencesDAGImpl<>(null, dataProperties, dataPropertyEquivalences);
>, <Line: -		//
>, <Line: -		Map<Predicate, OClass> classEquivalenceMap = new HashMap<>();
>, <Line: -		SimpleDirectedGraph <Equivalences<ClassExpression>,DefaultEdge> classes = new SimpleDirectedGraph<>(DefaultEdge.class);
>, <Line: -		Map<ClassExpression, Equivalences<ClassExpression>> classEquivalences = new HashMap<>();
>, <Line: -			Set<ClassExpression> reduced = new HashSet<>();
>, <Line: -			Equivalences<ClassExpression> reducedNode = new Equivalences<>(reduced, rep);
>, <Line: -					classEquivalences.put(equi, reducedNode);
>, <Line: -					continue;
>, <Line: -				if (equi instanceof OClass) {
>, <Line: -					OClass equiClass = (OClass) equi;
>, <Line: -					classEquivalenceMap.put(equiClass.getPredicate(), (OClass)rep);
>, <Line: -					Predicate pred = ((ObjectSomeValuesFrom)equi).getProperty().getPredicate();
>, <Line: -					if (objectPropertyEquivalenceMap.get(pred) == null) {
>, <Line: -						classEquivalences.put(equi, reducedNode);
>, <Line: -					}
>, <Line: -					assert (equi instanceof DataSomeValuesFrom);
>, <Line: -					Predicate pred = ((DataSomeValuesFrom)equi).getProperty().getPredicate();
>, <Line: -					if (dataPropertyEquivalenceMap.get(pred) == null) {
>, <Line: -						classEquivalences.put(equi, reducedNode);
>, <Line: -					}
>, <Line: -			if (node.isIndexed())
>, <Line: -				reducedNode.setIndexed();
>, <Line: -		// create edges for the classes graph
>, <Line: -		copyEdges(reasoner.getClassDAG(), classEquivalences, classes);
>, <Line: -		EquivalencesDAGImpl<ClassExpression> classDAG = new EquivalencesDAGImpl<>(null, classes, classEquivalences);
>, <Line: -		return new TBoxReasonerImpl(classDAG,  (EquivalencesDAGImpl<DataRangeExpression>)reasoner.getDataRangeDAG(), objectPropertyDAG, dataPropertyDAG, classEquivalenceMap, objectPropertyEquivalenceMap, dataPropertyEquivalenceMap);
>, <Line: -	private static <T> void copyEdges(EquivalencesDAG<T> source, Map<T, Equivalences<T>> eqMap, SimpleDirectedGraph <Equivalences<T>,DefaultEdge> target) {
>, <Line: -		for (Equivalences<T> node : source) {
>, <Line: -			T rep = node.getRepresentative();
>, <Line: -			Equivalences<T> reducedNode = eqMap.get(rep);
>, <Line: -			for (Equivalences<T> subNode : source.getDirectSub(node)) {
>, <Line: -				T subRep = subNode.getRepresentative();
>, <Line: -				Equivalences<T> subReducedNode = eqMap.get(subRep);
>, <Line: -				target.addEdge(subReducedNode, reducedNode);
>, <Line: -			}
>, <Line: -		}		
>, <Line: -	}
>, <Line: -/*	
>, <Line: -	private static <T> DefaultDirectedGraph<T,DefaultEdge> getGraphFromDAG(EquivalencesDAG<T> source) {
>, <Line: -		DefaultDirectedGraph<T,DefaultEdge> graph = new DefaultDirectedGraph<T,DefaultEdge>(DefaultEdge.class);
>, <Line: -		for (Equivalences<T> node : source) {
>, <Line: -			for (T v : node) 
>, <Line: -				graph.addVertex(v);
>, <Line: -			for (T v : node)  {
>, <Line: -				graph.addEdge(v, node.getRepresentative());
>, <Line: -				graph.addEdge(node.getRepresentative(), v);
>, <Line: -		for (Equivalences<T> node : source) 
>, <Line: -			for (Equivalences<T> subNode : source.getDirectSub(node)) 
>, <Line: -				graph.addEdge(subNode.getRepresentative(), node.getRepresentative());
>, <Line: -*/	
>, <Line: -//	public static TBoxReasonerImpl getChainReasoner2(Ontology onto) {
>, <Line: -//		
>, <Line: -//		return new TBoxReasonerImpl((OntologyGraph.getGraph(onto, true)));		
>, <Line: -//	}
>, <Line: -	/***
>, <Line: -	 * Modifies the DAG so that \exists R = \exists R-, so that the reachability
>, <Line: -	 * relation of the original DAG gets extended to the reachability relation
>, <Line: -	 * of T and Sigma chains.
>, <Line: -	public static TBoxReasoner getChainReasoner(TBoxReasonerImpl tbox) {		
>, <Line: -		EquivalencesDAG<ClassExpression> classes = tbox.getClassDAG();
>, <Line: -		// move everything to a graph that admits cycles
>, <Line: -		DefaultDirectedGraph<ClassExpression,DefaultEdge> modifiedGraph = 
>, <Line: -				new  DefaultDirectedGraph<>(DefaultEdge.class);
>, <Line: -		// clone all the vertex and edges from dag
>, <Line: -		for (Equivalences<ClassExpression> v : classes) 
>, <Line: -			modifiedGraph.addVertex(v.getRepresentative());
>, <Line: -		for (Equivalences<ClassExpression> v : classes) {
>, <Line: -			ClassExpression s = v.getRepresentative();
>, <Line: -			for (Equivalences<ClassExpression> vp : classes.getDirectSuper(v))
>, <Line: -				modifiedGraph.addEdge(s, vp.getRepresentative());
>, <Line: -		HashSet<ClassExpression> processedNodes = new HashSet<>();
>, <Line: -		for (Equivalences<ClassExpression> existsNode : classes) {
>, <Line: -			ClassExpression node = existsNode.getRepresentative();
>, <Line: -			if ((!(node instanceof ObjectSomeValuesFrom) /*&& !(node instanceof DataSomeValuesFrom)*/) || processedNodes.contains(node)) 
>, <Line: -				continue;
>, <Line: -			/*
>, <Line: -			 * Adding a cycle between exists R and exists R- for each R.
>, <Line: -			 */
>, <Line: -			ClassExpression invNode;
>, <Line: -			//if (node instanceof ObjectSomeValuesFrom) {
>, <Line: -				ObjectPropertyExpression exists = ((ObjectSomeValuesFrom) node).getProperty();
>, <Line: -				invNode = exists.getInverse().getDomain();				
>, <Line: -			//}
>, <Line: -			/*	
>, <Line: -			else {
>, <Line: -				DataPropertyExpression exists = ((DataSomeValuesFrom) node).getProperty();
>, <Line: -				invNode = fac.createPropertySomeRestriction(exists.getInverse());
>, <Line: -			// TODO: fix DataRange
>, <Line: -//				invNode = fac.createDataPropertyRange((DataPropertyExpression)exists);		
>, <Line: -			}
>, <Line: -			*/	
>, <Line: -			Equivalences<ClassExpression> existsInvNode = classes.getVertex(invNode);
>, <Line: -			for (Equivalences<ClassExpression> children : classes.getDirectSub(existsNode)) {
>, <Line: -				ClassExpression child = children.getRepresentative(); 
>, <Line: -				if (!child.equals(existsInvNode))
>, <Line: -					modifiedGraph.addEdge(child, existsInvNode.getRepresentative());
>, <Line: -			}
>, <Line: -			for (Equivalences<ClassExpression> children : classes.getDirectSub(existsInvNode)) {
>, <Line: -				ClassExpression child = children.getRepresentative(); 
>, <Line: -				if (!child.equals(existsNode))
>, <Line: -					modifiedGraph.addEdge(child, existsNode.getRepresentative());
>, <Line: -			}
>, <Line: -			for (Equivalences<ClassExpression> parents : classes.getDirectSuper(existsNode)) {
>, <Line: -				ClassExpression parent = parents.getRepresentative(); 
>, <Line: -				if (!parent.equals(existsInvNode))
>, <Line: -					modifiedGraph.addEdge(existsInvNode.getRepresentative(), parent);
>, <Line: -			}
>, <Line: -			for (Equivalences<ClassExpression> parents : classes.getDirectSuper(existsInvNode)) {
>, <Line: -				ClassExpression parent = parents.getRepresentative(); 
>, <Line: -				if (!parent.equals(existsInvNode))
>, <Line: -					modifiedGraph.addEdge(existsNode.getRepresentative(), parent);
>, <Line: -			}
>, <Line: -			processedNodes.add(existsNode.getRepresentative());
>, <Line: -			processedNodes.add(existsInvNode.getRepresentative());
>, <Line: -		/* Collapsing the cycles */
>, <Line: -		return new TBoxReasonerImpl(tbox.objectPropertyDAG.getGraph(), tbox.dataPropertyDAG.getGraph(), 
>, <Line: -									modifiedGraph, tbox.dataRangeDAG.getGraph());
>]