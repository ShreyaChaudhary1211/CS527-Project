[<Line: +import it.unibz.krdb.obda.model.DatatypeFactory;
>, <Line: +import it.unibz.krdb.obda.model.OBDADataFactory;
>, <Line: +import it.unibz.krdb.obda.model.Predicate;
>, <Line: +import it.unibz.krdb.obda.model.Predicate.COL_TYPE;
>, <Line: +import it.unibz.krdb.obda.model.impl.OBDADataFactoryImpl;
>, <Line: +import it.unibz.krdb.obda.ontology.DataPropertyRangeExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataSomeValuesFrom;
>, <Line: +import it.unibz.krdb.obda.ontology.Datatype;
>, <Line: +import it.unibz.krdb.obda.ontology.DescriptionBT;
>, <Line: +import it.unibz.krdb.obda.ontology.ImmutableOntologyVocabulary;
>, <Line: +import it.unibz.krdb.obda.ontology.InconsistentOntologyException;
>, <Line: +import it.unibz.krdb.obda.ontology.OClass;
>, <Line: +import it.unibz.krdb.obda.ontology.ObjectSomeValuesFrom;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.HashSet;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableMap;
>, <Line: +	private static final OBDADataFactory obdafac = OBDADataFactoryImpl.getInstance();
>, <Line: +	private final ImmutableOntologyVocabularyImpl vocabulary;
>, <Line: +	// axioms 
>, <Line: +	private final static class Hierarchy<T extends DescriptionBT> {
>, <Line: +		private final List<BinaryAxiom<T>> inclusions = new ArrayList<>();
>, <Line: +		private final List<NaryAxiom<T>> disjointness = new ArrayList<>();
>, <Line: +		/**
>, <Line: +		 * implements rules [D1], [O1] and [C1]:<br>
>, <Line: +		 *    - ignore if e1 is bot or e2 is top<br>
>, <Line: +		 *    - replace by emptiness if e2 is bot but e1 is not top<br>
>, <Line: +		 *    - inconsistency if e1 is top and e2 is bot
>, <Line: +		 *    
>, <Line: +		 * @param e1
>, <Line: +		 * @param e2
>, <Line: +		 * @throws InconsistentOntologyException 
>, <Line: +		 */
>, <Line: +		void addInclusion(T e1, T e2) throws InconsistentOntologyException {
>, <Line: +			if (e1.isBottom() || e2.isTop()) 
>, <Line: +				return;
>, <Line: +			if (e2.isBottom()) { // emptiness
>, <Line: +				if (e1.isTop())
>, <Line: +					throw new InconsistentOntologyException();
>, <Line: +				NaryAxiom<T> ax = new NaryAxiomImpl<>(ImmutableList.of(e1, e1));
>, <Line: +				disjointness.add(ax);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				BinaryAxiom<T> ax = new BinaryAxiomImpl<>(e1, e2);
>, <Line: +				inclusions.add(ax);
>, <Line: +			}	
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * implements an extension of [D2], [O2] and [C2]:<br>
>, <Line: +		 *     - eliminates all occurrences of bot and if the result contains<br>
>, <Line: +		 *     - no top and at least two elements then disjointness<br>
>, <Line: +		 *     - one top then emptiness of all other elements<br>
>, <Line: +		 *     - two tops then inconsistency (this behavior is an extension of OWL 2, where duplicates are removed from the list)
>, <Line: +		 *     
>, <Line: +		 * @param es
>, <Line: +		 * @throws InconsistentOntologyException
>, <Line: +		 */
>, <Line: +		void addDisjointness(T... es) throws InconsistentOntologyException {
>, <Line: +			ImmutableList.Builder<T> sb = new ImmutableList.Builder<>();
>, <Line: +			int numberOfTop = 0;
>, <Line: +			for (T e : es) {
>, <Line: +				//checkSignature(e);
>, <Line: +				if (e.isBottom())
>, <Line: +					continue;
>, <Line: +				else if (e.isTop()) 
>, <Line: +					numberOfTop++;
>, <Line: +				else 
>, <Line: +					sb.add(e);
>, <Line: +			}
>, <Line: +			ImmutableList<T> nonTrivialElements = sb.build();
>, <Line: +			if (numberOfTop == 0) {
>, <Line: +				if (nonTrivialElements.size() >= 2) {
>, <Line: +					NaryAxiomImpl<T> ax = new NaryAxiomImpl<>(nonTrivialElements);
>, <Line: +					disjointness.add(ax);
>, <Line: +				}
>, <Line: +				// if 0 or 1 non-bottom elements then do nothing 
>, <Line: +			}
>, <Line: +			else if (numberOfTop == 1) {
>, <Line: +				for (T dpe : nonTrivialElements) {
>, <Line: +					NaryAxiomImpl<T> ax = new NaryAxiomImpl<>(ImmutableList.of(dpe, dpe));
>, <Line: +					disjointness.add(ax);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			else // many tops 
>, <Line: +				throw new InconsistentOntologyException();
>, <Line: +		}
>, <Line: +	};
>, <Line: +	private final Hierarchy<ClassExpression> classAxioms = new Hierarchy<>();
>, <Line: +	private final Hierarchy<ObjectPropertyExpression> objectPropertyAxioms = new Hierarchy<>();
>, <Line: +	private final Hierarchy<DataPropertyExpression> dataPropertyAxioms = new Hierarchy<>();
>, <Line: +	private final List<BinaryAxiom<DataRangeExpression>> subDataRangeAxioms = new ArrayList<>();
>, <Line: +	private final Set<ObjectPropertyExpression> reflexiveObjectPropertyAxioms = new HashSet<>();
>, <Line: +	private final Set<ObjectPropertyExpression> irreflexiveObjectPropertyAxioms = new HashSet<>();
>, <Line: +	private final Set<ObjectPropertyExpression> functionalObjectPropertyAxioms = new LinkedHashSet<>();
>, <Line: +	private final Set<DataPropertyExpression> functionalDataPropertyAxioms = new LinkedHashSet<>();
>, <Line: +	// assertions
>, <Line: +	private final List<ClassAssertion> classAssertions = new ArrayList<>();
>, <Line: +	private final List<ObjectPropertyAssertion> objectPropertyAssertions = new ArrayList<>();
>, <Line: +	private final List<DataPropertyAssertion> dataPropertyAssertions = new ArrayList<>();
>, <Line: +	// auxiliary symbols (for normalization)
>, <Line: +	private final Set<ObjectPropertyExpression> auxObjectProperties = new HashSet<>();
>, <Line: +	private static final String AUXROLEURI = "AUX.ROLE"; 
>, <Line: +	private int auxCounter = 0; 
>, <Line: +	// exception messages
>, <Line: +	private static final String CLASS_NOT_FOUND = "Class not found: ";	
>, <Line: +	private static final String OBJECT_PROPERTY_NOT_FOUND = "ObjectProperty not found: ";
>, <Line: +	private static final String DATA_PROPERTY_NOT_FOUND = "DataProperty not found: ";
>, <Line: +	private static final String DATATYPE_NOT_FOUND = "Datatype not found: ";
>, <Line: +	public static final ImmutableMap<String, Datatype> OWL2QLDatatypes;
>, <Line: +	private static final String xml  = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
>, <Line: +	private static final String rdfs = "http://www.w3.org/2000/01/rdf-schema#";	
>, <Line: +	private static final String owl = "http://www.w3.org/2002/07/owl#";
>, <Line: +	private static final String xsd = "http://www.w3.org/2001/XMLSchema#";
>, <Line: +	static {
>, <Line: +		DatatypeFactory ofac = obdafac.getDatatypeFactory();
>, <Line: +		OWL2QLDatatypes = ImmutableMap.<String, Datatype>builder()
>, <Line: +				.put(xml + "PlainLiteral", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.LITERAL))) // 	rdf:PlainLiteral
>, <Line: +				.put(xml + "XMLLiteral", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) //	rdf:XMLLiteral
>, <Line: +				.put(rdfs + "Literal", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.LITERAL))) //		rdfs:Literal
>, <Line: +				.put(owl + "real", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.DECIMAL))) // 			owl:real
>, <Line: +				.put(owl + "rational", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.DECIMAL))) // 		owl:rational		
>, <Line: +				.put(xsd + "decimal", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.DECIMAL))) // 	xsd:decimal
>, <Line: +				.put(xsd + "integer", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.INTEGER))) // 	xsd:integer
>, <Line: +				.put(xsd + "nonNegativeInteger", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.NON_NEGATIVE_INTEGER))) // 	xsd:nonNegativeInteger
>, <Line: +				.put(xsd + "string", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:string
>, <Line: +				.put(xsd + "normalizedString", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:normalizedString
>, <Line: +				.put(xsd + "token", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:token
>, <Line: +				.put(xsd + "Name", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:Name
>, <Line: +				.put(xsd + "NCName", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) //	xsd:NCName
>, <Line: +				.put(xsd + "NMTOKEN", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:NMTOKEN
>, <Line: +				.put(xsd + "hexBinary", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:hexBinary
>, <Line: +				.put(xsd + "base64Binary", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:base64Binary
>, <Line: +				.put(xsd + "anyURI", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.STRING))) // 	xsd:anyURI
>, <Line: +				.put(xsd + "dateTime", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.DATETIME))) // 	xsd:dateTime
>, <Line: +				.put(xsd + "dateTimeStamp", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.DATETIME_STAMP))) // 	xsd:dateTimeStamp
>, <Line: +				.put(xsd + "int", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.INT))) // 	TEMPORARY FOR Q9 / FISHMARK
>, <Line: +				.put(xsd + "long", new DatatypeImpl(ofac.getTypePredicate(COL_TYPE.LONG))) // 	TEMPORARY FOR OntologyTypesTest
>, <Line: +				.build();
>, <Line: +/*	
>, <Line: +	// PREVIOUSLY SUPPORTED built-in datatypes 
>, <Line: +	final static Set<Predicate> builtinDatatypes;
>, <Line: +	static { // static block
>, <Line: +		DatatypeFactory dfac = OBDADataFactoryImpl.getInstance().getDatatypeFactory();
>, <Line: +		builtinDatatypes = new HashSet<>();
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.LITERAL)); //  .RDFS_LITERAL);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.STRING)); // .XSD_STRING);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.INTEGER)); //OBDAVocabulary.XSD_INTEGER);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NEGATIVE_INTEGER)); // XSD_NEGATIVE_INTEGER);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.INT)); // OBDAVocabulary.XSD_INT);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NON_NEGATIVE_INTEGER)); //OBDAVocabulary.XSD_NON_NEGATIVE_INTEGER);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.UNSIGNED_INT)); // OBDAVocabulary.XSD_UNSIGNED_INT);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.POSITIVE_INTEGER)); //.XSD_POSITIVE_INTEGER);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NON_POSITIVE_INTEGER)); // OBDAVocabulary.XSD_NON_POSITIVE_INTEGER);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.LONG)); // OBDAVocabulary.XSD_LONG);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DECIMAL)); // OBDAVocabulary.XSD_DECIMAL);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DOUBLE)); // OBDAVocabulary.XSD_DOUBLE);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.FLOAT)); // OBDAVocabulary.XSD_FLOAT);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DATETIME)); // OBDAVocabulary.XSD_DATETIME);
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.BOOLEAN)); // OBDAVocabulary.XSD_BOOLEAN
>, <Line: +		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DATETIME_STAMP)); // OBDAVocabulary.XSD_DATETIME_STAMP
>, <Line: +	}
>, <Line: +*/	
>, <Line: +	private final class ImmutableOntologyVocabularyImpl implements ImmutableOntologyVocabulary {
>, <Line: +		final ImmutableMap<String, OClass> concepts;
>, <Line: +		final ImmutableMap<String, ObjectPropertyExpression> objectProperties;
>, <Line: +		final ImmutableMap<String, DataPropertyExpression> dataProperties;
>, <Line: +		ImmutableOntologyVocabularyImpl(OntologyVocabularyImpl voc) {
>, <Line: +			concepts = ImmutableMap.<String, OClass>builder()
>, <Line: +				.putAll(voc.concepts)
>, <Line: +				.put(ClassImpl.owlThingIRI, ClassImpl.owlThing)
>, <Line: +				.put(ClassImpl.owlNothingIRI, ClassImpl.owlNothing).build();
>, <Line: +			objectProperties = ImmutableMap.<String, ObjectPropertyExpression>builder()
>, <Line: +				.putAll(voc.objectProperties)
>, <Line: +				.put(ObjectPropertyExpressionImpl.owlTopObjectPropertyIRI, ObjectPropertyExpressionImpl.owlTopObjectProperty)
>, <Line: +				.put(ObjectPropertyExpressionImpl.owlBottomObjectPropertyIRI, ObjectPropertyExpressionImpl.owlBottomObjectProperty).build();
>, <Line: +			dataProperties  = ImmutableMap.<String, DataPropertyExpression>builder() 
>, <Line: +				.putAll(voc.dataProperties)
>, <Line: +				.put(DataPropertyExpressionImpl.owlTopDataPropertyIRI, DataPropertyExpressionImpl.owlTopDataProperty)
>, <Line: +				.put(DataPropertyExpressionImpl.owlBottomDataPropertyIRI, DataPropertyExpressionImpl.owlBottomDataProperty).build();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public OClass getClass(String uri) {
>, <Line: +			OClass oc = concepts.get(uri);
>, <Line: +			if (oc == null)
>, <Line: +				throw new RuntimeException(CLASS_NOT_FOUND + uri);
>, <Line: +			return oc;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public ObjectPropertyExpression getObjectProperty(String uri) {
>, <Line: +			ObjectPropertyExpression ope = objectProperties.get(uri);
>, <Line: +			if (ope == null)
>, <Line: +				throw new RuntimeException(OBJECT_PROPERTY_NOT_FOUND + uri);
>, <Line: +			return ope;
>, <Line: +		@Override
>, <Line: +		public DataPropertyExpression getDataProperty(String uri) {
>, <Line: +			DataPropertyExpression dpe = dataProperties.get(uri);
>, <Line: +			if (dpe == null)
>, <Line: +				throw new RuntimeException(DATA_PROPERTY_NOT_FOUND + uri);
>, <Line: +			return dpe;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean containsClass(String uri) {
>, <Line: +			return concepts.containsKey(uri);
>, <Line: +		@Override
>, <Line: +		public boolean containsObjectProperty(String uri) {
>, <Line: +			return objectProperties.containsKey(uri);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean containsDataProperty(String uri) {
>, <Line: +			return dataProperties.containsKey(uri);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Collection<OClass> getClasses() {
>, <Line: +			return concepts.values();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Collection<ObjectPropertyExpression> getObjectProperties() {
>, <Line: +			return objectProperties.values();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Collection<DataPropertyExpression> getDataProperties() {
>, <Line: +			return dataProperties.values();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean isEmpty() {
>, <Line: +			// the minimum size is 2 because of \top / \bopttom
>, <Line: +			return concepts.size() == 2 && objectProperties.size() == 2 && dataProperties.size() == 2;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Datatype getDatatype(String uri) {
>, <Line: +			Datatype dt = OWL2QLDatatypes.get(uri);
>, <Line: +			if (dt == null)
>, <Line: +				throw new RuntimeException(DATATYPE_NOT_FOUND + uri);
>, <Line: +			return dt;
>, <Line: +	OntologyImpl(OntologyVocabularyImpl voc) {
>, <Line: +		this.vocabulary = new ImmutableOntologyVocabularyImpl(voc);
>, <Line: +	}
>, <Line: +	public ImmutableOntologyVocabulary getVocabulary() {
>, <Line: +		return vocabulary;
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds subclass axiom
>, <Line: +	 * <p>
>, <Line: +	 * SubClassOf := 'SubClassOf' '(' axiomAnnotations subClassExpression superClassExpression ')'
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [C1]:<br>
>, <Line: +	 *    - ignore the axiom if the first argument is owl:Nothing or the second argument is owl:Thing<br>
>, <Line: +	 *    - replace by a disjointness axiom if the second argument is owl:Nothing but the first is not owl:Thing<br>
>, <Line: +	 *    - inconsistency if the first argument is owl:Thing but the second one is not owl:Nothing
>, <Line: +	 * <p>
>, <Line: +	 * Implements rules [D5] and [O5] (in conjunction with DataSomeValuesFromImpl and ObjectSomeValuesFromImpl)<br>
>, <Line: +	 *    - if the first argument is syntactically "equivalent" to owl:Thing, then replace it by owl:Thing
>, <Line: +	 *    
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void addSubClassOfAxiom(ClassExpression ce1, ClassExpression ce2) throws InconsistentOntologyException {
>, <Line: +		checkSignature(ce1);
>, <Line: +		checkSignature(ce2);
>, <Line: +		if (ce1.isTop())
>, <Line: +			ce1 = ClassImpl.owlThing; // rules [D5] and [O5]
>, <Line: +		classAxioms.addInclusion(ce1, ce2);
>, <Line: +	}	
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds a data property range axiom
>, <Line: +	 * <p>
>, <Line: +	 * DataPropertyRange := 'DataPropertyRange' '(' axiomAnnotations DataPropertyExpression DataRange ')'
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [D3]:
>, <Line: +	 *     - ignore if the property is bot or the range is rdfs:Literal (top datatype)
>, <Line: +	 *     - inconsistency if the property is top but the range is not rdfs:Literal
>, <Line: +	 *     
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	public void addDataPropertyRangeAxiom(DataPropertyRangeExpression range, Datatype datatype) throws InconsistentOntologyException {
>, <Line: +		checkSignature(range);
>, <Line: +		checkSignature(datatype);
>, <Line: +		if (datatype.equals(DatatypeImpl.rdfsLiteral))
>, <Line: +			return;
>, <Line: +		// otherwise the datatype is not top
>, <Line: +		if (range.getProperty().isBottom())
>, <Line: +			return;
>, <Line: +		if (range.getProperty().isTop())
>, <Line: +			throw new InconsistentOntologyException();
>, <Line: +		BinaryAxiom<DataRangeExpression> ax = new BinaryAxiomImpl<>(range, datatype);
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds an object subproperty axiom
>, <Line: +	 * <p>
>, <Line: +	 * SubObjectPropertyOf := 'SubObjectPropertyOf' '(' axiomAnnotations 
>, <Line: +	 * 						ObjectPropertyExpression ObjectPropertyExpression ')'
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [O1]:<br>
>, <Line: +	 *    - ignore the axiom if the first argument is owl:bottomObjectProperty 
>, <Line: +	 *    				or the second argument is owl:topObjectProperty<br>
>, <Line: +	 *    - replace by a disjointness axiom if the second argument is owl:bottomObjectProperty 
>, <Line: +	 *                but the first one is not owl:topObjectProperty<br>
>, <Line: +	 *    - inconsistency if the first is  owl:topObjectProperty but the second is owl:bottomObjectProperty 
>, <Line: +	 *    
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	public void addSubPropertyOfAxiom(ObjectPropertyExpression ope1, ObjectPropertyExpression ope2) throws InconsistentOntologyException {
>, <Line: +		checkSignature(ope1);
>, <Line: +		checkSignature(ope2);
>, <Line: +		objectPropertyAxioms.addInclusion(ope1, ope2);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds a data subproperty axiom
>, <Line: +	 * <p>
>, <Line: +	 * SubDataPropertyOf := 'SubDataPropertyOf' '(' axiomAnnotations 
>, <Line: +	 * 					subDataPropertyExpression superDataPropertyExpression ')'<br>
>, <Line: +	 * subDataPropertyExpression := DataPropertyExpression<br>
>, <Line: +	 * superDataPropertyExpression := DataPropertyExpression
>, <Line: +	 * <p>
>, <Line: +	 * implements rule [D1]:<br>
>, <Line: +	 *    - ignore the axiom if the first argument is owl:bottomDataProperty 
>, <Line: +	 *    			  or the second argument is owl:topDataProperty<br>
>, <Line: +	 *    - replace by a disjointness axiom if the second argument is owl:bottomDataProperty 
>, <Line: +	 *                but the first one is not owl:topDataProperty<br>
>, <Line: +	 *    - inconsistency if the first is  owl:topDataProperty but the second is owl:bottomDataProperty 
>, <Line: +	 *    
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	public void addSubPropertyOfAxiom(DataPropertyExpression dpe1, DataPropertyExpression dpe2) throws InconsistentOntologyException {
>, <Line: +		checkSignature(dpe1);
>, <Line: +		checkSignature(dpe2);
>, <Line: +		dataPropertyAxioms.addInclusion(dpe1, dpe2);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds class disjointness axiom
>, <Line: +	 * <p>
>, <Line: +	 * DisjointClasses := 'DisjointClasses' '(' axiomAnnotations 
>, <Line: +	 * 			subClassExpression subClassExpression { subClassExpression } ')'<br>
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [C2]:<br>
>, <Line: +	 *     - eliminates all occurrences of bot and if the result contains<br>
>, <Line: +	 *     - no top and at least two elements then disjointness<br>
>, <Line: +	 *     - one top then emptiness of all other elements<br>
>, <Line: +	 *     - two tops then inconsistency (this behavior is an extension of OWL 2, where duplicates are removed from the list) 
>, <Line: +	 */
>, <Line: +	public void addDisjointClassesAxiom(ClassExpression... ces) throws InconsistentOntologyException {	
>, <Line: +		for (ClassExpression c : ces)
>, <Line: +			checkSignature(c);
>, <Line: +		classAxioms.addDisjointness(ces);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds object property disjointness axiom
>, <Line: +	 * <p>
>, <Line: +	 * DisjointObjectProperties := 'DisjointObjectProperties' '(' axiomAnnotations
>, <Line: +	 * 		 ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')'<br>
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [O2]:<br>
>, <Line: +	 *     - eliminates all occurrences of bot and if the result contains<br>
>, <Line: +	 *     - no top and at least two elements then disjointness<br>
>, <Line: +	 *     - one top then emptiness of all other elements<br>
>, <Line: +	 *     - two tops then inconsistency (this behavior is an extension of OWL 2, where duplicates are removed from the list) 
>, <Line: +	 */
>, <Line: +	public void addDisjointObjectPropertiesAxiom(ObjectPropertyExpression... opes) throws InconsistentOntologyException {
>, <Line: +		for (ObjectPropertyExpression p : opes)
>, <Line: +			checkSignature(p);
>, <Line: +		objectPropertyAxioms.addDisjointness(opes);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds data property disjointness axiom
>, <Line: +	 * <p>
>, <Line: +	 * DisjointDataProperties := 'DisjointDataProperties' '(' axiomAnnotations 
>, <Line: +	 * 				DataPropertyExpression DataPropertyExpression { DataPropertyExpression } ')'<br>
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [D2]:<br>
>, <Line: +	 *     - eliminates all occurrences of bot and if the result contains<br>
>, <Line: +	 *     - no top and at least two elements then disjointness<br>
>, <Line: +	 *     - one top then emptiness of all other elements<br>
>, <Line: +	 *     - two tops then inconsistency (this behavior is an extension of OWL 2, where duplicates are removed from the list) 
>, <Line: +	 */
>, <Line: +	public void addDisjointDataPropertiesAxiom(DataPropertyExpression... dpes) throws InconsistentOntologyException {
>, <Line: +		for (DataPropertyExpression dpe : dpes)
>, <Line: +			checkSignature(dpe);
>, <Line: +		dataPropertyAxioms.addDisjointness(dpes);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds a reflexive object property axiom
>, <Line: +	 * <p>
>, <Line: +	 * ReflexiveObjectProperty := 'ReflexiveObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [O3]:<br>
>, <Line: +	 *     - ignores if top (which is reflexive by definition)<br>
>, <Line: +	 *     - inconsistency if bot (which is not reflexive)<br>
>, <Line: +	 *     - otherwise, removes the inverse if required
>, <Line: +	 *     
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void addReflexiveObjectPropertyAxiom(ObjectPropertyExpression ope) throws InconsistentOntologyException {
>, <Line: +		if (ope.isTop())
>, <Line: +			return;
>, <Line: +		if (ope.isBottom())
>, <Line: +			throw new InconsistentOntologyException();
>, <Line: +		if (ope.isInverse())
>, <Line: +			reflexiveObjectPropertyAxioms.add(ope.getInverse());
>, <Line: +		else
>, <Line: +			reflexiveObjectPropertyAxioms.add(ope);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Normalizes and adds an irreflexive object property axiom
>, <Line: +	 * <p>
>, <Line: +	 * ReflexiveObjectProperty := 'ReflexiveObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * <p>
>, <Line: +	 * Implements rule [O3]:<br>
>, <Line: +	 *     - ignores if bot (which is irreflexive by definition)<br>
>, <Line: +	 *     - inconsistency if top (which is reflexive)<br>
>, <Line: +	 *     - otherwise, removes the inverse if required
>, <Line: +	 *     
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void addIrreflexiveObjectPropertyAxiom(ObjectPropertyExpression ope) throws InconsistentOntologyException {
>, <Line: +		if (ope.isTop())
>, <Line: +			throw new InconsistentOntologyException();
>, <Line: +		if (ope.isBottom())
>, <Line: +			return;
>, <Line: +		if (ope.isInverse())
>, <Line: +			irreflexiveObjectPropertyAxioms.add(ope.getInverse());
>, <Line: +		else
>, <Line: +			irreflexiveObjectPropertyAxioms.add(ope);
>, <Line: +		checkSignature(prop);
>, <Line: +		checkSignature(prop);
>, <Line: +		checkSignature(assertion.getConcept());
>, <Line: +		checkSignature(assertion.getProperty());
>, <Line: +		checkSignature(assertion.getProperty());
>, <Line: +	public Collection<BinaryAxiom<ClassExpression>> getSubClassAxioms() {
>, <Line: +		return Collections.unmodifiableList(classAxioms.inclusions);
>, <Line: +	public Collection<BinaryAxiom<DataRangeExpression>> getSubDataRangeAxioms() {
>, <Line: +	public Collection<BinaryAxiom<ObjectPropertyExpression>> getSubObjectPropertyAxioms() {
>, <Line: +		return Collections.unmodifiableList(objectPropertyAxioms.inclusions);
>, <Line: +	public Collection<BinaryAxiom<DataPropertyExpression>> getSubDataPropertyAxioms() {
>, <Line: +		return Collections.unmodifiableList(dataPropertyAxioms.inclusions);
>, <Line: +	public Collection<NaryAxiom<ClassExpression>> getDisjointClassesAxioms() {
>, <Line: +		return Collections.unmodifiableList(classAxioms.disjointness);
>, <Line: +	}
>, <Line: +	@Override 
>, <Line: +	public Collection<NaryAxiom<ObjectPropertyExpression>> getDisjointObjectPropertiesAxioms() {
>, <Line: +		return Collections.unmodifiableList(objectPropertyAxioms.disjointness);
>, <Line: +	}
>, <Line: +	@Override 
>, <Line: +	public Collection<NaryAxiom<DataPropertyExpression>> getDisjointDataPropertiesAxioms() {
>, <Line: +		return Collections.unmodifiableList(dataPropertyAxioms.disjointness);
>, <Line: +	public Collection<ObjectPropertyExpression> getReflexiveObjectPropertyAxioms() {
>, <Line: +		return Collections.unmodifiableSet(reflexiveObjectPropertyAxioms);
>, <Line: +	public Collection<ObjectPropertyExpression> getIrreflexiveObjectPropertyAxioms() {
>, <Line: +		return Collections.unmodifiableSet(irreflexiveObjectPropertyAxioms);
>, <Line: +		str.append("[Ontology info.")
>, <Line: +		 	.append(String.format(" Axioms: %d", classAxioms.inclusions.size() + 
>, <Line: +		 			objectPropertyAxioms.inclusions.size() + dataPropertyAxioms.inclusions.size()))
>, <Line: +			.append(String.format(" Classes: %d", vocabulary.getClasses().size()))
>, <Line: +			.append(String.format(" Object Properties: %d", vocabulary.getObjectProperties().size()))
>, <Line: +			.append(String.format(" Data Properties: %d]", vocabulary.getDataProperties().size()));
>, <Line: +	public ObjectPropertyExpression createAuxiliaryObjectProperty() {
>, <Line: +		ObjectPropertyExpression ope = new ObjectPropertyExpressionImpl(AUXROLEURI + auxCounter);
>, <Line: +		auxCounter++ ;
>, <Line: +		auxObjectProperties.add(ope);
>, <Line: +		return ope;
>, <Line: +	@Override
>, <Line: +	public Collection<ObjectPropertyExpression> getAuxiliaryObjectProperties() {
>, <Line: +		return Collections.unmodifiableSet(auxObjectProperties);
>, <Line: +	}
>, <Line: +	private void checkSignature(ClassExpression desc) {		
>, <Line: +		if (desc instanceof OClass) {
>, <Line: +			OClass cl = (OClass) desc;
>, <Line: +			if (!vocabulary.concepts.containsKey(cl.getName()))
>, <Line: +				throw new IllegalArgumentException(CLASS_NOT_FOUND + desc);
>, <Line: +		}	
>, <Line: +		else if (desc instanceof ObjectSomeValuesFrom) {
>, <Line: +			checkSignature(((ObjectSomeValuesFrom) desc).getProperty());
>, <Line: +		}
>, <Line: +		else  {
>, <Line: +			assert (desc instanceof DataSomeValuesFrom);
>, <Line: +			checkSignature(((DataSomeValuesFrom) desc).getProperty());
>, <Line: +		}
>, <Line: +	}	
>, <Line: +	private void checkSignature(Datatype desc) {		
>, <Line: +		Predicate pred = desc.getPredicate();
>, <Line: +		if (!OWL2QLDatatypes.containsKey(pred.getName())) 
>, <Line: +			throw new IllegalArgumentException(DATATYPE_NOT_FOUND + pred);
>, <Line: +	}
>, <Line: +	private void checkSignature(DataPropertyRangeExpression desc) {		
>, <Line: +		checkSignature(desc.getProperty());
>, <Line: +	}
>, <Line: +	private void checkSignature(ObjectPropertyExpression prop) {	
>, <Line: +		if (prop.isInverse()) 
>, <Line: +			prop = prop.getInverse();
>, <Line: +		if (!vocabulary.containsObjectProperty(prop.getName()) && !auxObjectProperties.contains(prop)) 
>, <Line: +				throw new IllegalArgumentException(OBJECT_PROPERTY_NOT_FOUND + prop);
>, <Line: +	}
>, <Line: +	private void checkSignature(DataPropertyExpression prop) {
>, <Line: +		if (!vocabulary.containsDataProperty(prop.getName()))
>, <Line: +			throw new IllegalArgumentException(DATA_PROPERTY_NOT_FOUND + prop);
>, <Line: +	}
>]
[<Line: -import it.unibz.krdb.obda.ontology.OntologyVocabulary;
>, <Line: -	private final OntologyVocabularyImpl vocabulary = new OntologyVocabularyImpl();
>, <Line: -	// axioms and assertions
>, <Line: -	private final List<BinaryAxiom<ClassExpression>> subClassAxioms = new ArrayList<BinaryAxiom<ClassExpression>>();
>, <Line: -	private final List<BinaryAxiom<DataRangeExpression>> subDataRangeAxioms = new ArrayList<BinaryAxiom<DataRangeExpression>>();
>, <Line: -	private final List<BinaryAxiom<ObjectPropertyExpression>> subObjectPropertyAxioms = new ArrayList<BinaryAxiom<ObjectPropertyExpression>>();
>, <Line: -	private final List<BinaryAxiom<DataPropertyExpression>> subDataPropertyAxioms = new ArrayList<BinaryAxiom<DataPropertyExpression>>();
>, <Line: -	private final List<NaryAxiom<ClassExpression>> disjointClassesAxioms = new ArrayList<NaryAxiom<ClassExpression>>();
>, <Line: -	private final List<NaryAxiom<ObjectPropertyExpression>> disjointObjectPropertiesAxioms = new ArrayList<NaryAxiom<ObjectPropertyExpression>>();
>, <Line: -	private final List<NaryAxiom<DataPropertyExpression>> disjointDataPropertiesAxioms = new ArrayList<NaryAxiom<DataPropertyExpression>>();
>, <Line: -	private final Set<ObjectPropertyExpression> functionalObjectPropertyAxioms = new LinkedHashSet<ObjectPropertyExpression>();
>, <Line: -	private final Set<DataPropertyExpression> functionalDataPropertyAxioms = new LinkedHashSet<DataPropertyExpression>();
>, <Line: -	private final List<ClassAssertion> classAssertions = new ArrayList<ClassAssertion>();
>, <Line: -	private final List<ObjectPropertyAssertion> objectPropertyAssertions = new ArrayList<ObjectPropertyAssertion>();
>, <Line: -	private final List<DataPropertyAssertion> dataPropertyAssertions = new ArrayList<DataPropertyAssertion>();
>, <Line: -	OntologyImpl() {
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public OntologyImpl clone() {
>, <Line: -		OntologyImpl clone = new OntologyImpl();
>, <Line: -		clone.subClassAxioms.addAll(subClassAxioms);
>, <Line: -		clone.subObjectPropertyAxioms.addAll(subObjectPropertyAxioms);
>, <Line: -		clone.subDataPropertyAxioms.addAll(subDataPropertyAxioms);
>, <Line: -		clone.vocabulary.merge(vocabulary);
>, <Line: -		return clone;
>, <Line: -	@Override
>, <Line: -	public void addSubClassOfAxiomWithReferencedEntities(ClassExpression concept1, ClassExpression concept2) {	
>, <Line: -		vocabulary.addReferencedEntries(concept1);
>, <Line: -		vocabulary.addReferencedEntries(concept2);
>, <Line: -		if (!concept1.isNothing() && !concept2.isThing()) {
>, <Line: -			BinaryAxiom<ClassExpression> assertion = new BinaryAxiomImpl<ClassExpression>(concept1, concept2);
>, <Line: -			subClassAxioms.add(assertion);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public void addSubClassOfAxiomWithReferencedEntities(DataRangeExpression concept1, DataRangeExpression concept2) {
>, <Line: -		vocabulary.addReferencedEntries(concept1);
>, <Line: -		vocabulary.addReferencedEntries(concept2);
>, <Line: -		BinaryAxiom<DataRangeExpression> assertion = new BinaryAxiomImpl<DataRangeExpression>(concept1, concept2);
>, <Line: -		subDataRangeAxioms.add(assertion);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public void addSubPropertyOfAxiomWithReferencedEntities(ObjectPropertyExpression included, ObjectPropertyExpression including) {
>, <Line: -		vocabulary.addReferencedEntries(included);
>, <Line: -		vocabulary.addReferencedEntries(including);
>, <Line: -		if (!included.isBottom() && !including.isTop()) {
>, <Line: -			BinaryAxiom<ObjectPropertyExpression> assertion = new BinaryAxiomImpl<ObjectPropertyExpression>(included, including);
>, <Line: -			subObjectPropertyAxioms.add(assertion);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public void addSubPropertyOfAxiomWithReferencedEntities(DataPropertyExpression included, DataPropertyExpression including) {
>, <Line: -		vocabulary.addReferencedEntries(included);
>, <Line: -		vocabulary.addReferencedEntries(including);
>, <Line: -		if (!included.isBottom() && !including.isTop()) {
>, <Line: -			BinaryAxiom<DataPropertyExpression> assertion = new BinaryAxiomImpl<DataPropertyExpression>(included, including);
>, <Line: -			subDataPropertyAxioms.add(assertion);
>, <Line: -	public void addSubClassOfAxiom(ClassExpression concept1, ClassExpression concept2) {
>, <Line: -		vocabulary.checkSignature(concept1);
>, <Line: -		vocabulary.checkSignature(concept2);
>, <Line: -		if (!concept1.isNothing() && !concept2.isThing()) {
>, <Line: -			BinaryAxiom<ClassExpression> ax = new BinaryAxiomImpl<ClassExpression>(concept1, concept2);
>, <Line: -			subClassAxioms.add(ax);
>, <Line: -		}
>, <Line: -	public void addSubClassOfAxiom(DataRangeExpression concept1, DataRangeExpression concept2) {
>, <Line: -		vocabulary.checkSignature(concept1);
>, <Line: -		vocabulary.checkSignature(concept2);
>, <Line: -		BinaryAxiom<DataRangeExpression> ax = new BinaryAxiomImpl<DataRangeExpression>(concept1, concept2);
>, <Line: -	public void addSubPropertyOfAxiom(ObjectPropertyExpression included, ObjectPropertyExpression including) {
>, <Line: -		vocabulary.checkSignature(included);
>, <Line: -		vocabulary.checkSignature(including);
>, <Line: -		if (!included.isBottom() && !including.isTop()) {
>, <Line: -			BinaryAxiom<ObjectPropertyExpression> ax = new BinaryAxiomImpl<ObjectPropertyExpression>(included, including);
>, <Line: -			subObjectPropertyAxioms.add(ax);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public void addSubPropertyOfAxiom(DataPropertyExpression included, DataPropertyExpression including) {
>, <Line: -		vocabulary.checkSignature(included);
>, <Line: -		vocabulary.checkSignature(including);
>, <Line: -		if (!included.isBottom() && !including.isTop()) {
>, <Line: -			BinaryAxiom<DataPropertyExpression> ax = new BinaryAxiomImpl<DataPropertyExpression>(included, including);
>, <Line: -			subDataPropertyAxioms.add(ax);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public void addDisjointClassesAxiom(Set<ClassExpression> classes) {	
>, <Line: -		for (ClassExpression c : classes)
>, <Line: -			vocabulary.checkSignature(c);
>, <Line: -		NaryAxiom<ClassExpression> ax = new NaryAxiomImpl<ClassExpression>(classes);
>, <Line: -		disjointClassesAxioms.add(ax);
>, <Line: -	}
>, <Line: -	public void addDisjointObjectPropertiesAxiom(Set<ObjectPropertyExpression> props) {
>, <Line: -		for (ObjectPropertyExpression p : props)
>, <Line: -			vocabulary.checkSignature(p);
>, <Line: -		NaryAxiomImpl<ObjectPropertyExpression> ax = new NaryAxiomImpl<ObjectPropertyExpression>(props);
>, <Line: -		disjointObjectPropertiesAxioms.add(ax);
>, <Line: -	}
>, <Line: -	public void addDisjointDataPropertiesAxiom(Set<DataPropertyExpression> props) {
>, <Line: -		for (DataPropertyExpression p : props)
>, <Line: -			vocabulary.checkSignature(p);
>, <Line: -		NaryAxiomImpl<DataPropertyExpression> ax = new NaryAxiomImpl<DataPropertyExpression>(props);
>, <Line: -		disjointDataPropertiesAxioms.add(ax);
>, <Line: -		vocabulary.checkSignature(prop);
>, <Line: -		vocabulary.checkSignature(prop);
>, <Line: -		vocabulary.checkSignature(assertion.getConcept());
>, <Line: -		vocabulary.checkSignature(assertion.getProperty());
>, <Line: -		vocabulary.checkSignature(assertion.getProperty());
>, <Line: -	public List<BinaryAxiom<ClassExpression>> getSubClassAxioms() {
>, <Line: -		return Collections.unmodifiableList(subClassAxioms);
>, <Line: -	public List<BinaryAxiom<DataRangeExpression>> getSubDataRangeAxioms() {
>, <Line: -	public List<BinaryAxiom<ObjectPropertyExpression>> getSubObjectPropertyAxioms() {
>, <Line: -		return Collections.unmodifiableList(subObjectPropertyAxioms);
>, <Line: -	public List<BinaryAxiom<DataPropertyExpression>> getSubDataPropertyAxioms() {
>, <Line: -		return Collections.unmodifiableList(subDataPropertyAxioms);
>, <Line: -	public List<NaryAxiom<ClassExpression>> getDisjointClassesAxioms() {
>, <Line: -		return Collections.unmodifiableList(disjointClassesAxioms);
>, <Line: -	public List<NaryAxiom<ObjectPropertyExpression>> getDisjointObjectPropertiesAxioms() {
>, <Line: -		return Collections.unmodifiableList(disjointObjectPropertiesAxioms);
>, <Line: -	public List<NaryAxiom<DataPropertyExpression>> getDisjointDataPropertiesAxioms() {
>, <Line: -		return Collections.unmodifiableList(disjointDataPropertiesAxioms);
>, <Line: -		str.append("[Ontology info.");
>, <Line: -		str.append(String.format(" Axioms: %d", subClassAxioms.size() + subObjectPropertyAxioms.size() + subDataPropertyAxioms.size()));
>, <Line: -		str.append(String.format(" Classes: %d", getVocabulary().getClasses().size()));
>, <Line: -		str.append(String.format(" Object Properties: %d", getVocabulary().getObjectProperties().size()));
>, <Line: -		str.append(String.format(" Data Properties: %d]", getVocabulary().getDataProperties().size()));
>, <Line: -	public OntologyVocabulary getVocabulary() {
>, <Line: -		return vocabulary;
>]