[<Line: +/*
>, <Line: + * #%L
>, <Line: + * ontop-obdalib-core
>, <Line: + * %%
>, <Line: + * Copyright (C) 2009 - 2014 Free University of Bozen-Bolzano
>, <Line: + * %%
>, <Line: + * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: + * you may not use this file except in compliance with the License.
>, <Line: + * You may obtain a copy of the License at
>, <Line: + * 
>, <Line: + *      http://www.apache.org/licenses/LICENSE-2.0
>, <Line: + * 
>, <Line: + * Unless required by applicable law or agreed to in writing, software
>, <Line: + * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: + * See the License for the specific language governing permissions and
>, <Line: + * limitations under the License.
>, <Line: + * #L%
>, <Line: + */
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.Map;
>, <Line: +import it.unibz.krdb.obda.ontology.ImmutableOntologyVocabulary;
>, <Line: +/**
>, <Line: + * Implements OntologyVocabulary 
>, <Line: + * by providing look-up tables for classes, object and data properties
>, <Line: + * (checks whether the name has been declared)
>, <Line: + * 
>, <Line: + * NOTE: the sets of classes, object and data properties DO NOT contain 
>, <Line: + *       top/bottom elements
>, <Line: + *       HOWEVER, they are recognized as valid class and property names
>, <Line: + * 
>, <Line: + * @author Roman Kontchakov
>, <Line: + *
>, <Line: + */
>, <Line: +public class OntologyVocabularyImpl implements OntologyVocabulary {
>, <Line: +	final Map<String, OClass> concepts = new HashMap<>();
>, <Line: +	final Map<String, ObjectPropertyExpression> objectProperties = new HashMap<>();
>, <Line: +	final Map<String, DataPropertyExpression> dataProperties = new HashMap<>();
>, <Line: +	private static final String CLASS_NOT_FOUND = "Class not found: ";	
>, <Line: +	private static final String OBJECT_PROPERTY_NOT_FOUND = "ObjectProperty not found: ";
>, <Line: +	private static final String DATA_PROPERTY_NOT_FOUND = "DataProperty not found: ";
>, <Line: +	private static final String DATATYPE_NOT_FOUND = "Datatype not found: ";
>, <Line: +	public OntologyVocabularyImpl() {		
>, <Line: +		OClass oc = concepts.get(uri);
>, <Line: +		if (oc != null) 
>, <Line: +			return oc;
>, <Line: +		else if (uri.equals(ClassImpl.owlThingIRI))
>, <Line: +			return ClassImpl.owlThing;
>, <Line: +		else if (uri.equals(ClassImpl.owlNothingIRI))
>, <Line: +			return ClassImpl.owlNothing;
>, <Line: +		else
>, <Line: +			throw new RuntimeException(CLASS_NOT_FOUND + uri);
>, <Line: +		ObjectPropertyExpression ope = objectProperties.get(uri);
>, <Line: +		if (ope != null) 
>, <Line: +			return ope;
>, <Line: +		else if (uri.equals(ObjectPropertyExpressionImpl.owlBottomObjectPropertyIRI))
>, <Line: +			return ObjectPropertyExpressionImpl.owlBottomObjectProperty;
>, <Line: +		else if (uri.equals(ObjectPropertyExpressionImpl.owlTopObjectPropertyIRI))
>, <Line: +			return ObjectPropertyExpressionImpl.owlTopObjectProperty;
>, <Line: +		else
>, <Line: +			throw new RuntimeException(OBJECT_PROPERTY_NOT_FOUND + uri);
>, <Line: +		DataPropertyExpression dpe = dataProperties.get(uri);
>, <Line: +		if (dpe != null) 
>, <Line: +			return dpe;
>, <Line: +		else if (uri.equals(DataPropertyExpressionImpl.owlBottomDataPropertyIRI))
>, <Line: +			return DataPropertyExpressionImpl.owlBottomDataProperty;
>, <Line: +		else if (uri.equals(DataPropertyExpressionImpl.owlTopDataPropertyIRI))
>, <Line: +			return DataPropertyExpressionImpl.owlTopDataProperty;
>, <Line: +		else
>, <Line: +			throw new RuntimeException(DATA_PROPERTY_NOT_FOUND + uri);
>, <Line: +	public Datatype getDatatype(String uri) {
>, <Line: +		Datatype dt = OntologyImpl.OWL2QLDatatypes.get(uri);
>, <Line: +		if (dt == null)
>, <Line: +			throw new RuntimeException(DATATYPE_NOT_FOUND + uri);
>, <Line: +		return dt;
>, <Line: +	public Collection<OClass> getClasses() {
>, <Line: +		return concepts.values();
>, <Line: +	public Collection<ObjectPropertyExpression> getObjectProperties() {
>, <Line: +		return objectProperties.values();
>, <Line: +	public Collection<DataPropertyExpression> getDataProperties() {
>, <Line: +		return dataProperties.values();
>, <Line: +	@Override
>, <Line: +	public boolean isEmpty() {
>, <Line: +		return concepts.isEmpty() && objectProperties.isEmpty() && dataProperties.isEmpty();
>, <Line: +	@Override
>, <Line: +	public OClass createClass(String uri) {
>, <Line: +		OClass cd = new ClassImpl(uri);
>, <Line: +		if (!cd.isBottom() && !cd.isTop())
>, <Line: +			concepts.put(uri, cd);
>, <Line: +		return cd;
>, <Line: +	@Override
>, <Line: +	public DataPropertyExpression createDataProperty(String uri) {
>, <Line: +		DataPropertyExpression rd = new DataPropertyExpressionImpl(uri);
>, <Line: +		if (!rd.isBottom() && !rd.isTop()) 
>, <Line: +			dataProperties.put(uri, rd);
>, <Line: +		return rd;
>, <Line: +	@Override
>, <Line: +	public ObjectPropertyExpression createObjectProperty(String uri) {
>, <Line: +		ObjectPropertyExpression rd = new ObjectPropertyExpressionImpl(uri);
>, <Line: +		if (!rd.isBottom() && !rd.isTop()) 
>, <Line: +			objectProperties.put(uri, rd);
>, <Line: +		return rd;
>, <Line: +	@Override
>, <Line: +	public void merge(ImmutableOntologyVocabulary v) {
>, <Line: +		if (v instanceof OntologyVocabularyImpl) {
>, <Line: +			OntologyVocabularyImpl vi = (OntologyVocabularyImpl)v;
>, <Line: +			concepts.putAll(vi.concepts);
>, <Line: +			objectProperties.putAll(vi.objectProperties);
>, <Line: +			dataProperties.putAll(vi.dataProperties);
>, <Line: +			for (OClass oc : v.getClasses())
>, <Line: +				if (!oc.isTop() && !oc.isBottom())
>, <Line: +					concepts.put(oc.getName(), oc);
>, <Line: +			for (ObjectPropertyExpression ope : v.getObjectProperties())
>, <Line: +				if (!ope.isTop() && !ope.isBottom())
>, <Line: +					objectProperties.put(ope.getName(), ope);
>, <Line: +			for (DataPropertyExpression dpe : v.getDataProperties())
>, <Line: +				if (!dpe.isTop() && !dpe.isBottom())
>, <Line: +					dataProperties.put(dpe.getName(), dpe);
>, <Line: +	@Override
>, <Line: +	public void removeClass(String classname) {
>, <Line: +		concepts.remove(classname);
>, <Line: +	@Override
>, <Line: +	public void removeObjectProperty(String property) {
>, <Line: +		objectProperties.remove(property);
>, <Line: +	public void removeDataProperty(String property) {
>, <Line: +		dataProperties.remove(property);
>, <Line: +	public boolean containsClass(String uri) {
>, <Line: +		return concepts.containsKey(uri);
>, <Line: +	@Override
>, <Line: +	public boolean containsObjectProperty(String uri) {
>, <Line: +		return objectProperties.containsKey(uri);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean containsDataProperty(String uri) {
>, <Line: +		return dataProperties.containsKey(uri);
>, <Line: +	}
>]
[<Line: -import java.util.Collections;
>, <Line: -import java.util.HashSet;
>, <Line: -import java.util.Set;
>, <Line: -import it.unibz.krdb.obda.model.DatatypeFactory;
>, <Line: -import it.unibz.krdb.obda.model.Predicate;
>, <Line: -import it.unibz.krdb.obda.model.Predicate.COL_TYPE;
>, <Line: -import it.unibz.krdb.obda.model.impl.OBDADataFactoryImpl;
>, <Line: -import it.unibz.krdb.obda.ontology.ClassExpression;
>, <Line: -import it.unibz.krdb.obda.ontology.DataPropertyRangeExpression;
>, <Line: -import it.unibz.krdb.obda.ontology.DataRangeExpression;
>, <Line: -import it.unibz.krdb.obda.ontology.DataSomeValuesFrom;
>, <Line: -import it.unibz.krdb.obda.ontology.ObjectSomeValuesFrom;
>, <Line: -import it.unibz.krdb.obda.ontology.OntologyFactory;
>, <Line: -public class OntologyVocabularyImpl implements OntologyVocabulary {
>, <Line: -	private static OntologyFactory ofac;
>, <Line: -	// signature
>, <Line: -	private final Set<OClass> concepts = new HashSet<OClass>();
>, <Line: -	private final Set<ObjectPropertyExpression> objectProperties = new HashSet<ObjectPropertyExpression>();
>, <Line: -	private final Set<ObjectPropertyExpression> auxObjectProperties = new HashSet<ObjectPropertyExpression>();
>, <Line: -	private final Set<DataPropertyExpression> dataProperties = new HashSet<DataPropertyExpression>();
>, <Line: -	private final Set<DataPropertyExpression> auxDataProperties = new HashSet<DataPropertyExpression>();
>, <Line: -	// auxiliary symbols and built-in datatypes 
>, <Line: -	private final static Set<Predicate> builtinDatatypes;
>, <Line: -	static { // static block
>, <Line: -		ofac = OntologyFactoryImpl.getInstance();
>, <Line: -		DatatypeFactory dfac = OBDADataFactoryImpl.getInstance().getDatatypeFactory();
>, <Line: -		builtinDatatypes = new HashSet<Predicate>();
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.LITERAL)); //  .RDFS_LITERAL);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.STRING)); // .XSD_STRING);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.INTEGER)); //OBDAVocabulary.XSD_INTEGER);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NEGATIVE_INTEGER)); // XSD_NEGATIVE_INTEGER);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.INT)); // OBDAVocabulary.XSD_INT);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NON_NEGATIVE_INTEGER)); //OBDAVocabulary.XSD_NON_NEGATIVE_INTEGER);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.UNSIGNED_INT)); // OBDAVocabulary.XSD_UNSIGNED_INT);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.POSITIVE_INTEGER)); //.XSD_POSITIVE_INTEGER);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.NON_POSITIVE_INTEGER)); // OBDAVocabulary.XSD_NON_POSITIVE_INTEGER);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.LONG)); // OBDAVocabulary.XSD_LONG);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DECIMAL)); // OBDAVocabulary.XSD_DECIMAL);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DOUBLE)); // OBDAVocabulary.XSD_DOUBLE);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.FLOAT)); // OBDAVocabulary.XSD_FLOAT);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DATETIME)); // OBDAVocabulary.XSD_DATETIME);
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.BOOLEAN)); // OBDAVocabulary.XSD_BOOLEAN
>, <Line: -		builtinDatatypes.add(dfac.getTypePredicate(COL_TYPE.DATETIME_STAMP)); // OBDAVocabulary.XSD_DATETIME_STAMP
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public OClass createClass(String uri) {
>, <Line: -		OClass cd = ofac.createClass(uri);
>, <Line: -		if (!cd.isNothing() && !cd.isThing())
>, <Line: -			concepts.add(cd);
>, <Line: -		return cd;
>, <Line: -		OClass cd = ofac.createClass(uri);
>, <Line: -		if (!cd.isNothing() && !cd.isThing() && !concepts.contains(cd))
>, <Line: -			throw new RuntimeException("Class not found: " + uri);
>, <Line: -		return cd;
>, <Line: -	@Override
>, <Line: -	public ObjectPropertyExpression createObjectProperty(String uri) {
>, <Line: -		ObjectPropertyExpression rd = ofac.createObjectProperty(uri);
>, <Line: -		if (!rd.isBottom() && !rd.isTop()) {
>, <Line: -			if (isAuxiliaryProperty(rd))
>, <Line: -				auxObjectProperties.add(rd);
>, <Line: -			else
>, <Line: -				objectProperties.add(rd);
>, <Line: -		}
>, <Line: -		return rd;
>, <Line: -	}
>, <Line: -		ObjectPropertyExpression rd = ofac.createObjectProperty(uri);
>, <Line: -		if (!rd.isBottom() && !rd.isTop() && !objectProperties.contains(rd))
>, <Line: -			throw new RuntimeException("Object property not found: " + uri);
>, <Line: -		return rd;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public DataPropertyExpression createDataProperty(String uri) {
>, <Line: -		DataPropertyExpression rd = ofac.createDataProperty(uri);
>, <Line: -		if (!rd.isBottom() && !rd.isTop()) {
>, <Line: -			if (isAuxiliaryProperty(rd))
>, <Line: -				auxDataProperties.add(rd);
>, <Line: -			else
>, <Line: -				dataProperties.add(rd);
>, <Line: -		}
>, <Line: -		return rd;
>, <Line: -		DataPropertyExpression rd = ofac.createDataProperty(uri);
>, <Line: -		if (!rd.isBottom() && !rd.isTop() && !dataProperties.contains(rd))
>, <Line: -			throw new RuntimeException("Data property not found: " + uri);			
>, <Line: -		return rd;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public Set<OClass> getClasses() {
>, <Line: -		return Collections.unmodifiableSet(concepts);
>, <Line: -	public Set<ObjectPropertyExpression> getObjectProperties() {
>, <Line: -		return Collections.unmodifiableSet(objectProperties);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public Set<DataPropertyExpression> getDataProperties() {
>, <Line: -		return Collections.unmodifiableSet(dataProperties);
>, <Line: -	private static final String AUXROLEURI = "ER.A-AUXROLE"; 
>, <Line: -	private static int auxCounter = 0; // THIS IS SHARED AMONG ALL INSTANCES!
>, <Line: -	public ObjectPropertyExpression createAuxiliaryObjectProperty() {
>, <Line: -		ObjectPropertyExpression rd = ofac.createObjectProperty(AUXROLEURI + auxCounter);
>, <Line: -		auxCounter++ ;
>, <Line: -		auxObjectProperties.add(rd);
>, <Line: -		return rd;
>, <Line: -	public DataPropertyExpression createAuxiliaryDataProperty() {
>, <Line: -		DataPropertyExpression rd = createDataProperty(AUXROLEURI + auxCounter);
>, <Line: -		auxCounter++ ;
>, <Line: -		auxDataProperties.add(rd);
>, <Line: -		return rd;
>, <Line: -	public Set<ObjectPropertyExpression> getAuxiliaryObjectProperties() {
>, <Line: -		return Collections.unmodifiableSet(auxObjectProperties);
>, <Line: -	@Override
>, <Line: -	public Set<DataPropertyExpression> getAuxiliaryDataProperties() {
>, <Line: -		return Collections.unmodifiableSet(auxDataProperties);
>, <Line: -	}
>, <Line: -	// TODO: remove static
>, <Line: -	@Deprecated
>, <Line: -	public static boolean isAuxiliaryProperty(ObjectPropertyExpression role) {
>, <Line: -		return role.getPredicate().getName().toString().startsWith(AUXROLEURI);	
>, <Line: -	}
>, <Line: -	@Deprecated
>, <Line: -	public static boolean isAuxiliaryProperty(DataPropertyExpression role) {
>, <Line: -		return role.getPredicate().getName().toString().startsWith(AUXROLEURI);	
>, <Line: -	}
>, <Line: -	boolean addReferencedEntries(ClassExpression desc) {
>, <Line: -		if (desc instanceof OClass) {
>, <Line: -			OClass cl = (OClass)desc;
>, <Line: -			if (!isBuiltIn(cl)) {
>, <Line: -				concepts.add(cl);
>, <Line: -				return true;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		else if (desc instanceof ObjectSomeValuesFrom)  {
>, <Line: -			ObjectPropertyExpression prop = ((ObjectSomeValuesFrom) desc).getProperty();
>, <Line: -			return addReferencedEntries(prop);
>, <Line: -		}
>, <Line: -		else  {
>, <Line: -			assert (desc instanceof DataSomeValuesFrom);
>, <Line: -			DataPropertyExpression prop = ((DataSomeValuesFrom) desc).getProperty();
>, <Line: -			return addReferencedEntries(prop);
>, <Line: -		}
>, <Line: -		return false;
>, <Line: -	}
>, <Line: -	boolean addReferencedEntries(DataRangeExpression desc) {
>, <Line: -		if (desc instanceof Datatype)  {
>, <Line: -			// NO-OP
>, <Line: -			// datatypes.add((Datatype) desc);
>, <Line: -			return true;
>, <Line: -		}
>, <Line: -		else  {
>, <Line: -			assert (desc instanceof DataPropertyRangeExpression);
>, <Line: -			DataPropertyExpression prop = ((DataPropertyRangeExpression) desc).getProperty();
>, <Line: -			return addReferencedEntries(prop);			
>, <Line: -		}
>, <Line: -	boolean addReferencedEntries(ObjectPropertyExpression prop) {
>, <Line: -		if (prop.isInverse()) {
>, <Line: -			if (!isBuiltIn(prop.getInverse())) {
>, <Line: -				ObjectPropertyExpression p = prop.getInverse();
>, <Line: -				if (isAuxiliaryProperty(p))
>, <Line: -					auxObjectProperties.add(p);
>, <Line: -				else
>, <Line: -					objectProperties.add(p);
>, <Line: -				return true;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		else {
>, <Line: -			if (!isBuiltIn(prop)) {
>, <Line: -				if (isAuxiliaryProperty(prop))
>, <Line: -					auxObjectProperties.add(prop);
>, <Line: -				else
>, <Line: -					objectProperties.add(prop);
>, <Line: -				return true;
>, <Line: -			}			
>, <Line: -		}
>, <Line: -		return false;
>, <Line: -	}
>, <Line: -	boolean addReferencedEntries(DataPropertyExpression prop) {
>, <Line: -		if (!isBuiltIn(prop)) {
>, <Line: -			if (isAuxiliaryProperty(prop))
>, <Line: -				auxDataProperties.add(prop);
>, <Line: -			else
>, <Line: -				dataProperties.add(prop);
>, <Line: -			return true;
>, <Line: -		}
>, <Line: -		return false;
>, <Line: -	}
>, <Line: -	private boolean isBuiltIn(OClass cl) {
>, <Line: -		return cl.isNothing() || cl.isThing();
>, <Line: -	}
>, <Line: -	private boolean isBuiltIn(ObjectPropertyExpression prop) {
>, <Line: -		return prop.isBottom() || prop.isTop() || auxObjectProperties.contains(prop);
>, <Line: -	private boolean isBuiltIn(DataPropertyExpression prop) {
>, <Line: -		return prop.isBottom() || prop.isTop() || auxDataProperties.contains(prop);
>, <Line: -	void checkSignature(ClassExpression desc) {
>, <Line: -		if (desc instanceof OClass) {
>, <Line: -			if (!concepts.contains(desc) && !isBuiltIn((OClass)desc))
>, <Line: -				throw new IllegalArgumentException("Class predicate is unknown: " + desc);
>, <Line: -		}	
>, <Line: -		else if (desc instanceof ObjectSomeValuesFrom) {
>, <Line: -			checkSignature(((ObjectSomeValuesFrom) desc).getProperty());
>, <Line: -		}
>, <Line: -		else  {
>, <Line: -			assert (desc instanceof DataSomeValuesFrom);
>, <Line: -			checkSignature(((DataSomeValuesFrom) desc).getProperty());
>, <Line: -		}
>, <Line: -	void checkSignature(DataRangeExpression desc) {
>, <Line: -		if (desc instanceof Datatype) {
>, <Line: -			Predicate pred = ((Datatype) desc).getPredicate();
>, <Line: -			if (!builtinDatatypes.contains(pred)) 
>, <Line: -				throw new IllegalArgumentException("Datatype predicate is unknown: " + pred);
>, <Line: -			assert (desc instanceof DataPropertyRangeExpression);
>, <Line: -			checkSignature(((DataPropertyRangeExpression) desc).getProperty());
>, <Line: -	void checkSignature(ObjectPropertyExpression prop) {
>, <Line: -		if (prop.isInverse()) {
>, <Line: -			if (!objectProperties.contains(prop.getInverse()) && !isBuiltIn(prop.getInverse())) 
>, <Line: -				throw new IllegalArgumentException("At least one of these predicates is unknown: " + prop.getInverse());
>, <Line: -		}
>, <Line: -		else {
>, <Line: -			if (!objectProperties.contains(prop) && !isBuiltIn(prop)) 
>, <Line: -				throw new IllegalArgumentException("At least one of these predicates is unknown: " + prop);
>, <Line: -		}
>, <Line: -	void checkSignature(DataPropertyExpression prop) {
>, <Line: -		if (!dataProperties.contains(prop) && !isBuiltIn(prop))
>, <Line: -			throw new IllegalArgumentException("At least one of these predicates is unknown: " + prop);
>, <Line: -	public void merge(OntologyVocabulary v) {
>, <Line: -		concepts.addAll(v.getClasses());
>, <Line: -		objectProperties.addAll(v.getObjectProperties());
>, <Line: -		dataProperties.addAll(v.getDataProperties());
>, <Line: -		auxObjectProperties.addAll(v.getAuxiliaryObjectProperties());
>, <Line: -		auxDataProperties.addAll(v.getAuxiliaryDataProperties());
>, <Line: -	public boolean isEmpty() {
>, <Line: -		return concepts.isEmpty() && objectProperties.isEmpty() && dataProperties.isEmpty();
>]