[<Line: +import it.unibz.krdb.obda.model.BuiltinPredicate;
>, <Line: +import it.unibz.krdb.obda.model.CQIE;
>, <Line: +import it.unibz.krdb.obda.model.Function;
>, <Line: +import it.unibz.krdb.obda.model.OBDADataFactory;
>, <Line: +import it.unibz.krdb.obda.model.Predicate;
>, <Line: +import it.unibz.krdb.obda.model.Term;
>, <Line: +import it.unibz.krdb.obda.ontology.ClassExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataPropertyExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.DataSomeValuesFrom;
>, <Line: +import it.unibz.krdb.obda.ontology.OClass;
>, <Line: +import it.unibz.krdb.obda.ontology.ObjectPropertyExpression;
>, <Line: +import it.unibz.krdb.obda.ontology.ObjectSomeValuesFrom;
>, <Line: +import it.unibz.krdb.obda.owlrefplatform.core.basicoperations.*;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Collections;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.HashSet;
>, <Line: +import java.util.Iterator;
>, <Line: +import java.util.LinkedList;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Set;
>, <Line: +	private static final boolean noCQC = false;		
>, <Line: +			if (noCQC) {
>, <Line: +				for (TMappingRule r : rules)
>, <Line: +					if (r.equals(newRule))
>, <Line: +						return;
>, <Line: +				rules.add(newRule);
>, <Line: +				return;
>, <Line: +			}
>, <Line: +					List<List<Function>> filterAtoms = new ArrayList<>(existingconditions.size() + 1);
>, <Line: +						boolean found2 = true;
>, <Line: +						for (Function ec : econd) 
>, <Line: +							if (!newconditions.contains(ec)) {
>, <Line: +								found2 = false;
>, <Line: +								break;
>, <Line: +							}
>, <Line: +						// if each of the existing conditions is found then the new condition is redundant
>, <Line: +						if (found2)
>, <Line: +							return;
>, <Line: +						// if each of the new conditions is found among econd then the old condition is redundant
>, <Line: +						if (found) {
>, <Line: +							//System.err.println(econd + " contains " + newconditions);
>, <Line: +						}
>, <Line: +						else
>, <Line: +							filterAtoms.add(TMappingRule.cloneList(econd));		
>, <Line: +					filterAtoms.add(newconditions);
>, <Line: +					newRule = new TMappingRule(currentRule, filterAtoms);
>, <Line: +		final boolean printouts = false;
>, <Line: +		if (printouts)
>, <Line: +			System.out.println("ORIGINAL MAPPING SIZE: " + originalMappings.size());
>, <Line: +		if (printouts)
>, <Line: +			System.out.println("===CHECKING REDUNDANCY: " + cqc);
>, <Line: +			if (!noCQC)
>, <Line: +				mapping = cqc.removeRedundantAtoms(mapping);
>, <Line: +			else {
>, <Line: +				int c = 0;
>, <Line: +				for (Function a : mapping.getBody()) 
>, <Line: +					if (!(a.getFunctionSymbol() instanceof BuiltinPredicate))
>, <Line: +						c++;
>, <Line: +				if (c == 1)
>, <Line: +					CQContainmentCheckUnderLIDs.oneAtomQs++;
>, <Line: +				else if (c == 2)
>, <Line: +					CQContainmentCheckUnderLIDs.twoAtomQs++;
>, <Line: +			}	
>, <Line: +		if (printouts)
>, <Line: +			System.out.println("===END OF CHECKING REDUNDANCY: " + CQContainmentCheckUnderLIDs.oneAtomQs + "/" + CQContainmentCheckUnderLIDs.twoAtomQs);
>, <Line: +		Map<Integer, Set<Predicate>> frequences = new HashMap<>();
>, <Line: +		for (Entry<Predicate, TMappingIndexEntry> entry : mappingIndex.entrySet()) {
>, <Line: +			if (printouts && !entry.getValue().rules.isEmpty()) {
>, <Line: +				Set<Predicate> freq = frequences.get(entry.getValue().rules.size());
>, <Line: +				if (freq == null) {
>, <Line: +					freq = new HashSet<>();
>, <Line: +					frequences.put(entry.getValue().rules.size(), freq);
>, <Line: +				}
>, <Line: +				freq.add(entry.getKey());
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (printouts) {
>, <Line: +			System.out.println("T-MAPPING SIZE: " + tmappingsProgram.size());
>, <Line: +			List<Integer> sorted = new ArrayList<>(frequences.keySet());
>, <Line: +			Collections.sort(sorted);
>, <Line: +			for (Integer idx : sorted) {
>, <Line: +				for (Predicate p : frequences.get(idx)) {
>, <Line: +					TMappingIndexEntry e = 	mappingIndex.get(p);
>, <Line: +					System.out.println(p + " " + e.rules.size());
>, <Line: +					for (TMappingRule r : e.rules) 
>, <Line: +						System.out.println("    " + r.asCQIE());
>, <Line: +				}
>, <Line: +			}
>, <Line: +			int total = 0;
>, <Line: +			for (Integer idx: sorted) {
>, <Line: +				System.out.println("   " + idx + ": " +  frequences.get(idx).size() + " " + frequences.get(idx));
>, <Line: +				total += frequences.get(idx).size();
>, <Line: +			}
>, <Line: +			System.out.println("NUMBER OF PREDICATES: " + total);
>, <Line: +		}
>]
[<Line: -import it.unibz.krdb.obda.model.*;
>, <Line: -import it.unibz.krdb.obda.ontology.*;
>, <Line: -import it.unibz.krdb.obda.owlrefplatform.core.basicoperations.CQContainmentCheckUnderLIDs;
>, <Line: -import it.unibz.krdb.obda.owlrefplatform.core.basicoperations.Substitution;
>, <Line: -import it.unibz.krdb.obda.owlrefplatform.core.basicoperations.SubstitutionUtilities;
>, <Line: -import java.util.*;
>, <Line: -						// if each of the new conditions is found among econd then the new map is redundant
>, <Line: -						if (found)
>, <Line: -							return;
>, <Line: -					newRule = new TMappingRule(currentRule, newconditions);
>, <Line: -		for (Entry<Predicate, TMappingIndexEntry> entry : mappingIndex.entrySet()) 
>]