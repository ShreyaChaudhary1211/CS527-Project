[<Line: +package it.unibz.krdb.obda.owlapi3;
>, <Line: +import it.unibz.krdb.obda.ontology.*;
>, <Line: +import it.unibz.krdb.obda.ontology.impl.ClassImpl;
>, <Line: +import it.unibz.krdb.obda.ontology.impl.DataPropertyExpressionImpl;
>, <Line: +import it.unibz.krdb.obda.ontology.impl.DatatypeImpl;
>, <Line: +import it.unibz.krdb.obda.ontology.impl.OntologyFactoryImpl;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.HashSet;
>, <Line: +import java.util.Iterator;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Set;
>, <Line: +import org.semanticweb.owlapi.model.*;
>, <Line: +import org.semanticweb.owlapi.vocab.OWL2Datatype;
>, <Line: +import org.slf4j.Logger;
>, <Line: +import org.slf4j.LoggerFactory;
>, <Line: +import com.google.common.collect.ImmutableMap;
>, <Line: +/**
>, <Line: + * 
>, <Line: + * @author Roman Kontchakov
>, <Line: + */
>, <Line: +public class OWLAPI3TranslatorOWL2QL implements OWLAxiomVisitor {
>, <Line: +	// If we need to construct auxiliary subclass axioms for A ISA exists R.C we
>, <Line: +	// put them in this map to avoid generating too many auxiliary roles/classes
>, <Line: +	private final Map<OWLObjectPropertyExpression, Map<OWLClassExpression, ObjectSomeValuesFrom>> auxiliaryClassProperties = new HashMap<>();
>, <Line: +	private static final OntologyFactory ofac = OntologyFactoryImpl.getInstance();
>, <Line: +	private static final Logger log = LoggerFactory.getLogger(OWLAPI3TranslatorOWL2QL.class);
>, <Line: +	private static final String INCONSISTENT_ONTOLOGY = "The OWL 2 QL ontology is inconsistent due to axiom {}";
>, <Line: +	private static final String INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE = "Inconsistency due to axiom ";
>, <Line: +	private static final String NOT_SUPPORTED = "Axiom does not belong to OWL 2 QL: {}";
>, <Line: +	private static final String NOT_SUPPORTED_EXT = "Axiom does not belong to OWL 2 QL: {} ({})";
>, <Line: +	private final Ontology dl_onto;
>, <Line: +	private final OWLAPI3TranslatorHelper helper;
>, <Line: +	private final boolean functionalityAxioms = true; // TEMPORARY FIX
>, <Line: +	private final boolean minCardinalityClassExpressions = true; // TEMPORARY FIX
>, <Line: +	private final boolean nestedQualifiedExistentials = true; // TEMPORARY FIX
>, <Line: +	public OWLAPI3TranslatorOWL2QL(Collection<OWLOntology> owls) {
>, <Line: +		dl_onto = createOntology(owls);
>, <Line: +		helper = new OWLAPI3TranslatorHelper(dl_onto.getVocabulary());
>, <Line: +	}
>, <Line: +	public ImmutableOntologyVocabulary getVocabulary() {
>, <Line: +		return dl_onto.getVocabulary();
>, <Line: +	}
>, <Line: +	public Ontology getOntology() {
>, <Line: +		return dl_onto;
>, <Line: +	}
>, <Line: +	public static class TranslationException extends Exception {
>, <Line: +		private static final long serialVersionUID = 7917688953760608030L;
>, <Line: +		public TranslationException() {
>, <Line: +		}
>, <Line: +		public TranslationException(String msg) {
>, <Line: +			super(msg);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (1)
>, <Line: +	 * 
>, <Line: +	 * SubClassOf := 'SubClassOf' '(' axiomAnnotations subClassExpression superClassExpression ')'
>, <Line: +	 * subClassExpression := Class | subObjectSomeValuesFrom | subObjectSomeValuesFrom
>, <Line: +	 * subObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression owl:Thing ')'
>, <Line: +	 * DataSomeValuesFrom := 'DataSomeValuesFrom' '(' DataPropertyExpression { DataPropertyExpression } DataRange ')'
>, <Line: +	 * superClassExpression := Class | superObjectIntersectionOf | superObjectComplementOf |  
>, <Line: +	 *                         superObjectSomeValuesFrom | DataSomeValuesFrom
>, <Line: +	 * superObjectIntersectionOf := 'ObjectIntersectionOf' '(' superClassExpression superClassExpression 
>, <Line: +	 *                           { superClassExpression } ')'                        
>, <Line: +	 * superObjectComplementOf := 'ObjectComplementOf' '(' subClassExpression ')'
>, <Line: +	 * superObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression Class ')'                          
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSubClassOfAxiom ax) {
>, <Line: +		try {
>, <Line: +			ClassExpression subDescription = getSubclassExpression(ax.getSubClass());
>, <Line: +			addSubClassAxioms(subDescription, ax.getSuperClass());
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (2)
>, <Line: +	 * 
>, <Line: +	 * EquivalentClasses := 'EquivalentClasses' '(' axiomAnnotations 
>, <Line: +	 * 						subClassExpression subClassExpression { subClassExpression } ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubClassOfAxiom (rule [R1])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLEquivalentClassesAxiom ax) {
>, <Line: +		try {
>, <Line: +			Iterator<OWLClassExpression> it = ax.getClassExpressions().iterator();
>, <Line: +			ClassExpression first = getSubclassExpression(it.next());
>, <Line: +			ClassExpression previous = first;
>, <Line: +			while (it.hasNext()) {
>, <Line: +				ClassExpression current = getSubclassExpression(it.next());
>, <Line: +				dl_onto.addSubClassOfAxiom(previous, current);
>, <Line: +				previous = current;
>, <Line: +			}
>, <Line: +			dl_onto.addSubClassOfAxiom(previous, first);
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (3)
>, <Line: +	 * 
>, <Line: +	 * DisjointClasses := 'DisjointClasses' '(' axiomAnnotations subClassExpression subClassExpression 
>, <Line: +	 *                     { subClassExpression } ')'
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDisjointClassesAxiom ax) {
>, <Line: +		try {
>, <Line: +			// ax.getClassExpressions() is a set!
>, <Line: +			ClassExpression[] disjointProperties = new ClassExpression[ax.getClassExpressions().size()];
>, <Line: +			int i = 0;
>, <Line: +			for (OWLClassExpression ce : ax.getClassExpressions()) {
>, <Line: +				ClassExpression c = getSubclassExpression(ce);
>, <Line: +				disjointProperties[i++] = c;
>, <Line: +			}
>, <Line: +			dl_onto.addDisjointClassesAxiom(disjointProperties);		
>, <Line: +		}
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (4) 
>, <Line: +	 * 
>, <Line: +	 * ClassAssertion := 'ClassAssertion' '(' axiomAnnotations Class Individual ')'
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLClassAssertionAxiom ax) {
>, <Line: +		try {
>, <Line: +			ClassAssertion a = helper.translate(ax);
>, <Line: +			if (a != null)
>, <Line: +				dl_onto.addClassAssertion(a);
>, <Line: +		}
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}		
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		} 
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (5)
>, <Line: +	 * 
>, <Line: +	 * SubObjectPropertyOf := 'SubObjectPropertyOf' '(' axiomAnnotations 
>, <Line: +	 * 												ObjectPropertyExpression ObjectPropertyExpression ')'
>, <Line: +	 * ObjectPropertyExpression := ObjectProperty | InverseObjectProperty
>, <Line: +	 * InverseObjectProperty := 'ObjectInverseOf' '(' ObjectProperty ')'
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSubObjectPropertyOfAxiom ax) {		
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope1 = helper.getPropertyExpression(ax.getSubProperty());
>, <Line: +			ObjectPropertyExpression ope2 = helper.getPropertyExpression(ax.getSuperProperty());
>, <Line: +			dl_onto.addSubPropertyOfAxiom(ope1, ope2);	
>, <Line: +		}		
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		} 
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (6)
>, <Line: +	 * 
>, <Line: +	 * EquivalentObjectProperties := 'EquivalentObjectProperties' '(' axiomAnnotations 
>, <Line: +	 * 								ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubObjectPropertyOfAxiom (rule [R1])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLEquivalentObjectPropertiesAxiom ax) {
>, <Line: +		try {
>, <Line: +			Iterator<OWLObjectPropertyExpression> it = ax.getProperties().iterator();
>, <Line: +			ObjectPropertyExpression first = helper.getPropertyExpression(it.next());
>, <Line: +			ObjectPropertyExpression previous = first;
>, <Line: +			while (it.hasNext()) {
>, <Line: +				ObjectPropertyExpression current = helper.getPropertyExpression(it.next());
>, <Line: +				dl_onto.addSubPropertyOfAxiom(previous, current);
>, <Line: +				previous = current;
>, <Line: +			}
>, <Line: +			dl_onto.addSubPropertyOfAxiom(previous, first);
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (7)
>, <Line: +	 * 
>, <Line: +	 * DisjointObjectProperties := 'DisjointObjectProperties' '(' axiomAnnotations 
>, <Line: +	 * 			ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')'
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDisjointObjectPropertiesAxiom ax) {
>, <Line: +		try {
>, <Line: +			// ax.Properties() is a set!
>, <Line: +			ObjectPropertyExpression[] opes = new ObjectPropertyExpression[ax.getProperties().size()];
>, <Line: +			int i = 0;
>, <Line: +			for (OWLObjectPropertyExpression prop : ax.getProperties()) {
>, <Line: +				ObjectPropertyExpression ope = helper.getPropertyExpression(prop);
>, <Line: +				opes[i++] = ope;
>, <Line: +			}
>, <Line: +			dl_onto.addDisjointObjectPropertiesAxiom(opes);		
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (8)
>, <Line: +	 * 
>, <Line: +	 * InverseObjectProperties := 'InverseObjectProperties' '(' axiomAnnotations 
>, <Line: +	 * 									ObjectPropertyExpression ObjectPropertyExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubObjectPropertyOfAxiom (rule [R1])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLInverseObjectPropertiesAxiom ax) {		
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope1 = helper.getPropertyExpression(ax.getFirstProperty());
>, <Line: +			ObjectPropertyExpression ope2 = helper.getPropertyExpression(ax.getSecondProperty());
>, <Line: +			dl_onto.addSubPropertyOfAxiom(ope1, ope2.getInverse());
>, <Line: +			dl_onto.addSubPropertyOfAxiom(ope2, ope1.getInverse());		
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (9)
>, <Line: +	 * 
>, <Line: +	 * ObjectPropertyDomain := 'ObjectPropertyDomain' '(' axiomAnnotations ObjectPropertyExpression superClassExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubClassOfAxiom (rule [R2])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLObjectPropertyDomainAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			addSubClassAxioms(ope.getDomain(), ax.getDomain());
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (10)
>, <Line: +	 * 
>, <Line: +	 * ObjectPropertyRange := 'ObjectPropertyRange' '(' axiomAnnotations ObjectPropertyExpression superClassExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubClassOfAxiom (rule [R2])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLObjectPropertyRangeAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			addSubClassAxioms(ope.getRange(), ax.getRange());
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (11)
>, <Line: +	 * 
>, <Line: +	 * ReflexiveObjectProperty := 'ReflexiveObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLReflexiveObjectPropertyAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addReflexiveObjectPropertyAxiom(ope);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (12)
>, <Line: +	 * 
>, <Line: +	 * IrreflexiveObjectProperty := 'IrreflexiveObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLIrreflexiveObjectPropertyAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addIrreflexiveObjectPropertyAxiom(ope);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (13)
>, <Line: +	 * 
>, <Line: +	 * SymmetricObjectProperty := 'SymmetricObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubObjectPropertyOfAxiom (rule [R3])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSymmetricObjectPropertyAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addSubPropertyOfAxiom(ope, ope.getInverse());
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (14)
>, <Line: +	 * 
>, <Line: +	 * AsymmetricObjectProperty :='AsymmetricObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by DisjointObjectPropertiesAxiom (rule [R3])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLAsymmetricObjectPropertyAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addDisjointObjectPropertiesAxiom(ope, ope.getInverse());
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (15)
>, <Line: +	 * 
>, <Line: +	 * ObjectPropertyAssertion := 'ObjectPropertyAssertion' '(' axiomAnnotations ObjectPropertyExpression 
>, <Line: +	 * 				sourceIndividual targetIndividual ')'
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLObjectPropertyAssertionAxiom ax) {
>, <Line: +		try {
>, <Line: +			ObjectPropertyAssertion a = helper.translate(ax);
>, <Line: +			if (a != null)
>, <Line: +				dl_onto.addObjectPropertyAssertion(a);
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}						
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (16) 
>, <Line: +	 * 
>, <Line: +	 * SubDataPropertyOf := 'SubDataPropertyOf' '(' axiomAnnotations 
>, <Line: +	 * 							subDataPropertyExpression superDataPropertyExpression ')'
>, <Line: +	 * subDataPropertyExpression := DataPropertyExpression
>, <Line: +	 * superDataPropertyExpression := DataPropertyExpression
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSubDataPropertyOfAxiom ax) {
>, <Line: +		try {
>, <Line: +			DataPropertyExpression dpe1 = helper.getPropertyExpression(ax.getSubProperty());
>, <Line: +			DataPropertyExpression dpe2 = helper.getPropertyExpression(ax.getSuperProperty());
>, <Line: +			dl_onto.addSubPropertyOfAxiom(dpe1, dpe2);	
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}						
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (17)
>, <Line: +	 * 
>, <Line: +	 * EquivalentDataProperties := 'EquivalentDataProperties' '(' axiomAnnotations 
>, <Line: +	 * 								DataPropertyExpression DataPropertyExpression { DataPropertyExpression } ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubDataPropertyOfAxiom (rule [R1])	
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLEquivalentDataPropertiesAxiom ax) {	
>, <Line: +		try {
>, <Line: +			Iterator<OWLDataPropertyExpression> it = ax.getProperties().iterator();
>, <Line: +			DataPropertyExpression first = helper.getPropertyExpression(it.next());
>, <Line: +			DataPropertyExpression previous = first;
>, <Line: +			while (it.hasNext()) {
>, <Line: +				DataPropertyExpression current = helper.getPropertyExpression(it.next());
>, <Line: +				dl_onto.addSubPropertyOfAxiom(previous, current);
>, <Line: +				previous = current;
>, <Line: +			}
>, <Line: +			dl_onto.addSubPropertyOfAxiom(previous, first);
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}						
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (18)
>, <Line: +	 * 
>, <Line: +	 * DisjointDataProperties := 'DisjointDataProperties' '(' axiomAnnotations 
>, <Line: +	 * 					DataPropertyExpression DataPropertyExpression { DataPropertyExpression } ')'
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDisjointDataPropertiesAxiom ax) {
>, <Line: +		try {
>, <Line: +			// ax.Properties() is a set!
>, <Line: +			DataPropertyExpression[] dpes = new DataPropertyExpression[ax.getProperties().size()];
>, <Line: +			int i = 0;
>, <Line: +			for (OWLDataPropertyExpression prop : ax.getProperties()) {
>, <Line: +				DataPropertyExpression dpe = helper.getPropertyExpression(prop);
>, <Line: +				dpes[i++] = dpe;
>, <Line: +			}
>, <Line: +			dl_onto.addDisjointDataPropertiesAxiom(dpes);		
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (19)
>, <Line: +	 * 
>, <Line: +	 * DataPropertyDomain := 'DataPropertyDomain' '(' axiomAnnotations DataPropertyExpression superClassExpression ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by SubClassOfAxiom (rule [R2])
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDataPropertyDomainAxiom ax) {
>, <Line: +		try {
>, <Line: +			DataPropertyExpression role = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			addSubClassAxioms(role.getDomainRestriction(DatatypeImpl.rdfsLiteral), ax.getDomain());		
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		}
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (20)
>, <Line: +	 * 
>, <Line: +	 * DataPropertyRange := 'DataPropertyRange' '(' axiomAnnotations DataPropertyExpression DataRange ')'
>, <Line: +	 * 
>, <Line: +	 * replaced by data property inclusion with bottomDataProperty if DataRange is empty (rule [DT1.1])
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDataPropertyRangeAxiom ax) {
>, <Line: +		DataPropertyExpression dpe = helper.getPropertyExpression(ax.getProperty());
>, <Line: +		try {
>, <Line: +			OWL2Datatype owlDatatype = getCanonicalDatatype(ax.getRange());
>, <Line: +			if (owlDatatype == null) {
>, <Line: +				// range is empty (rule [DT1.1])
>, <Line: +				dl_onto.addSubPropertyOfAxiom(dpe, DataPropertyExpressionImpl.owlBottomDataProperty);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				//Predicate.COL_TYPE columnType = OWLTypeMapper.getType(owlDatatype);
>, <Line: +				//Datatype datatype = ofac.createDataType(columnType);
>, <Line: +				Datatype datatype = dl_onto.getVocabulary().getDatatype(owlDatatype.getIRI().toString());
>, <Line: +				dl_onto.addDataPropertyRangeAxiom(dpe.getRange(), datatype);		
>, <Line: +			}		
>, <Line: +		} 
>, <Line: +		catch (TranslationException e) {
>, <Line: +			log.warn(NOT_SUPPORTED_EXT, ax, e);
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (21)
>, <Line: +	 * 
>, <Line: +	 * DataPropertyAssertion := 'DataPropertyAssertion' '(' axiomAnnotations 
>, <Line: +	 * 			DataPropertyExpression sourceIndividual targetValue ')'
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDataPropertyAssertionAxiom ax) {
>, <Line: +		try {
>, <Line: +			DataPropertyAssertion a = helper.translate(ax);
>, <Line: +			if (a != null)
>, <Line: +				dl_onto.addDataPropertyAssertion(a);
>, <Line: +		} 
>, <Line: +		catch (InconsistentOntologyException e) {
>, <Line: +			log.warn(INCONSISTENT_ONTOLOGY, ax);
>, <Line: +			throw new RuntimeException(INCONSISTENT_ONTOLOGY_EXCEPTION_MESSAGE + ax);
>, <Line: +		}
>, <Line: +		catch (TranslationException e) {
>, <Line: +			throw new RuntimeException(e.getMessage());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (22)
>, <Line: +	 * 
>, <Line: +	 * DifferentIndividuals := 'DifferentIndividuals' '(' axiomAnnotations Individual Individual { Individual } ')'
>, <Line: +	 * 
>, <Line: +	 * (simply ignored because it has no effect on reasoning)
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDifferentIndividualsAxiom ax) {
>, <Line: +		// NO-OP: DifferentInfividualsAxioms have no effect in OWL 2 QL
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (23)
>, <Line: +	 * 
>, <Line: +	 * DatatypeDefinition := 'DatatypeDefinition' '(' axiomAnnotations Datatype DataRange ')'
>, <Line: +	 * DataRange := Datatype | DataIntersectionOf
>, <Line: +	 * DataIntersectionOf := 'DataIntersectionOf' '(' DataRange DataRange { DataRange } ')'
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDatatypeDefinitionAxiom ax) {
>, <Line: +		// NO-OP: datatype definitions are handled when they are used in data property restrictions 
>, <Line: +	}
>, <Line: +	private OWL2Datatype getCanonicalDatatype(OWLDataRange dr) throws TranslationException {
>, <Line: +		return getCanonicalDatatype(OWL2Datatype.RDFS_LITERAL, dr);
>, <Line: +	}
>, <Line: +	private OWL2Datatype getCanonicalDatatype(OWL2Datatype dt0, OWLDataRange dr) throws TranslationException {
>, <Line: +		switch (dr.getDataRangeType()) {
>, <Line: +		case DATATYPE:
>, <Line: +			OWLDatatype dtype = dr.asOWLDatatype();
>, <Line: +			if (dtype.isBuiltIn()) {
>, <Line: +				OWL2Datatype dt1 = dtype.getBuiltInDatatype();
>, <Line: +				if (!DATATYPE_GROUP.containsKey(dt1)) 
>, <Line: +					throw new TranslationException("unsupported datatype: " + dt1);
>, <Line: +				return getIntersection(dt0, dt1);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				Set<OWLDatatypeDefinitionAxiom> defs = currentOWLOntology.getDatatypeDefinitions(dtype);
>, <Line: +				if (defs == null)
>, <Line: +					throw new TranslationException("undeclared datatype: " + dtype);
>, <Line: +				for (OWLDatatypeDefinitionAxiom def : defs) 
>, <Line: +					dt0 = getCanonicalDatatype(dt0, def.getDataRange());
>, <Line: +				return dt0;
>, <Line: +			}
>, <Line: +		case DATA_INTERSECTION_OF:
>, <Line: +			for (OWLDataRange d : ((OWLDataIntersectionOf)dr).getOperands())
>, <Line: +				dt0 = getCanonicalDatatype(dt0, d);
>, <Line: +			return dt0;
>, <Line: +		default:	
>, <Line: +			throw new TranslationException("unsupported OWLDataRange construct: " + dr);
>, <Line: +		}
>, <Line: +	}
>, <Line: +/*
>, <Line: + *  All datatypes supported in OWL 2 QL
>, <Line: + *   numbers specify the group: a group is formed by the second-level datatypes
>, <Line: + *      (the second-level datatypes are disjoint --  primitive XSD datatypes are marked *)
>, <Line: +    OWL2Datatype.RDFS_LITERAL, //		rdfs:Literal
>, <Line: +	1. OWL2Datatype.RDF_XML_LITERAL, //	rdf:XMLLiteral
>, <Line: +	2. OWL2Datatype.OWL_REAL, // 			owl:real
>, <Line: +	   + OWL2Datatype.OWL_RATIONAL, // 		owl:rational		
>, <Line: +	     * OWL2Datatype.XSD_DECIMAL, // 	xsd:decimal
>, <Line: +	       - OWL2Datatype.XSD_INTEGER, // 	xsd:integer
>, <Line: +	       - - OWL2Datatype.XSD_NON_NEGATIVE_INTEGER, // 	xsd:nonNegativeInteger
>, <Line: +	3. OWL2Datatype.RDF_PLAIN_LITERAL, // 	rdf:PlainLiteral
>, <Line: +	   * OWL2Datatype.XSD_STRING, // 	xsd:string
>, <Line: +	     - OWL2Datatype.XSD_NORMALIZED_STRING, // 	xsd:normalizedString
>, <Line: +	     - - OWL2Datatype.XSD_TOKEN, // 	xsd:token
>, <Line: +	     - - - OWL2Datatype.XSD_NMTOKEN, // 	xsd:NMTOKEN (see 2.3 in http://www.w3.org/TR/xml11)
>, <Line: +	     - - - - OWL2Datatype.XSD_NAME,  // 	xsd:Name
>, <Line: +	     - - - - - OWL2Datatype.XSD_NCNAME, //	xsd:NCName
>, <Line: +	4* OWL2Datatype.XSD_HEX_BINARY, // 	xsd:hexBinary
>, <Line: +	5* OWL2Datatype.XSD_BASE_64_BINARY, // 	xsd:base64Binary
>, <Line: +	6* OWL2Datatype.XSD_ANY_URI, // 	xsd:anyURI
>, <Line: +	7* OWL2Datatype.XSD_DATE_TIME, // 	xsd:dateTime
>, <Line: +	   - OWL2Datatype.XSD_DATE_TIME_STAMP // 	xsd:dateTimeStamp
>, <Line: +*/
>, <Line: +	private static final Map<OWL2Datatype, Integer> DATATYPE_GROUP = ImmutableMap.<OWL2Datatype, Integer>builder()
>, <Line: +			.put(OWL2Datatype.RDF_PLAIN_LITERAL, 3) // 	rdf:PlainLiteral
>, <Line: +			.put(OWL2Datatype.RDF_XML_LITERAL, 1) //	rdf:XMLLiteral
>, <Line: +			.put(OWL2Datatype.RDFS_LITERAL, 0) //		rdfs:Literal
>, <Line: +			.put(OWL2Datatype.OWL_REAL, 2) // 			owl:real
>, <Line: +			.put(OWL2Datatype.OWL_RATIONAL, 2) // 		owl:rational		
>, <Line: +			.put(OWL2Datatype.XSD_DECIMAL, 2) // 	xsd:decimal
>, <Line: +			.put(OWL2Datatype.XSD_INTEGER, 2) // 	xsd:integer
>, <Line: +			.put(OWL2Datatype.XSD_NON_NEGATIVE_INTEGER, 2) // 	xsd:nonNegativeInteger
>, <Line: +			.put(OWL2Datatype.XSD_STRING, 3) // 	xsd:string
>, <Line: +			.put(OWL2Datatype.XSD_NORMALIZED_STRING, 3) // 	xsd:normalizedString
>, <Line: +			.put(OWL2Datatype.XSD_TOKEN, 3) // 	xsd:token
>, <Line: +			.put(OWL2Datatype.XSD_NAME,  3) // 	xsd:Name
>, <Line: +			.put(OWL2Datatype.XSD_NCNAME, 3) //	xsd:NCName
>, <Line: +			.put(OWL2Datatype.XSD_NMTOKEN, 3) // 	xsd:NMTOKEN
>, <Line: +			.put(OWL2Datatype.XSD_HEX_BINARY, 4) // 	xsd:hexBinary
>, <Line: +			.put(OWL2Datatype.XSD_BASE_64_BINARY, 5) // 	xsd:base64Binary
>, <Line: +			.put(OWL2Datatype.XSD_ANY_URI, 6) // 	xsd:anyURI
>, <Line: +			.put(OWL2Datatype.XSD_DATE_TIME, 7) // 	xsd:dateTime
>, <Line: +			.put(OWL2Datatype.XSD_DATE_TIME_STAMP, 7) // 	xsd:dateTimeStamp
>, <Line: +			.put(OWL2Datatype.XSD_INT, 8) // 	TEMPORARY FOR Q9 / FISHMARK
>, <Line: +			.put(OWL2Datatype.XSD_LONG, 9) // 	TEMPORARY FOR OntologyTypesTest
>, <Line: +			.build();
>, <Line: +	// these three maps order specify linear order in each of the groups
>, <Line: +	//    the super-type has a smaller index
>, <Line: +	private static final Map<OWL2Datatype, Integer> DATATYPE_ORDER_IN_GROUP2 = ImmutableMap.of(
>, <Line: +			OWL2Datatype.OWL_REAL, 0, // 			owl:real
>, <Line: +			OWL2Datatype.OWL_RATIONAL, 1, // 		owl:rational		
>, <Line: +			OWL2Datatype.XSD_DECIMAL, 2, // 	xsd:decimal
>, <Line: +			OWL2Datatype.XSD_INTEGER, 3, // 	xsd:integer
>, <Line: +			OWL2Datatype.XSD_NON_NEGATIVE_INTEGER, 4); // 	xsd:nonNegativeInteger
>, <Line: +	private static final Map<OWL2Datatype, Integer> DATATYPE_ORDER_IN_GROUP3 = ImmutableMap.<OWL2Datatype, Integer>builder()
>, <Line: +			.put(OWL2Datatype.RDF_PLAIN_LITERAL, 0) // 	rdf:PlainLiteral
>, <Line: +			.put(OWL2Datatype.XSD_STRING, 1) // 	xsd:string
>, <Line: +			.put(OWL2Datatype.XSD_NORMALIZED_STRING, 2) // 	xsd:normalizedString
>, <Line: +			.put(OWL2Datatype.XSD_TOKEN, 3) // 	xsd:token
>, <Line: +			.put(OWL2Datatype.XSD_NMTOKEN, 4) // 	xsd:NMTOKEN (see 2.3 in http://www.w3.org/TR/xml11)
>, <Line: +			.put(OWL2Datatype.XSD_NAME,  5) // 	xsd:Name
>, <Line: +			.put(OWL2Datatype.XSD_NCNAME, 6)//	xsd:NCName
>, <Line: +			.build();
>, <Line: +	private static final Map<OWL2Datatype, Integer> DATATYPE_ORDER_IN_GROUP7 = ImmutableMap.of(
>, <Line: +			OWL2Datatype.XSD_DATE_TIME, 0, // 	xsd:dateTime
>, <Line: +			OWL2Datatype.XSD_DATE_TIME_STAMP, 1); // 	xsd:dateTimeStamp
>, <Line: +	/**
>, <Line: +	 * computes intersection of dt0 and dt1 (null is the empty datatype)
>, <Line: +	 *     (in OWL 2 QL, this will always coincide with one of the two)
>, <Line: +	 *     
>, <Line: +	 * @param dt0
>, <Line: +	 * @param dt1
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private static OWL2Datatype getIntersection(OWL2Datatype dt0, OWL2Datatype dt1) {
>, <Line: +		// intersection with the empty datatype is empty
>, <Line: +		if (dt0 == null || dt1 == null)
>, <Line: +			return null;
>, <Line: +		int g0 = DATATYPE_GROUP.get(dt0);
>, <Line: +		int g1 = DATATYPE_GROUP.get(dt1);
>, <Line: +		// intersection with the top datatype is the other argument		
>, <Line: +		if (g0 == 0)
>, <Line: +			return dt1;
>, <Line: +		if (g1 == 0)
>, <Line: +			return dt0;
>, <Line: +		// both arguments are neither empty nor the top datatype
>, <Line: +		// if they belong to different groups, then the intersection is empty
>, <Line: +		if (g0 != g1)
>, <Line: +			return null;
>, <Line: +		// groups but 2, 3 and 7 require special treatment
>, <Line: +		// all other groups contain just one datatype
>, <Line: +		Map<OWL2Datatype, Integer> linearOrder;
>, <Line: +		if (g0 == 2)
>, <Line: +			linearOrder = DATATYPE_ORDER_IN_GROUP2;
>, <Line: +		else if (g0 == 3)
>, <Line: +			linearOrder = DATATYPE_ORDER_IN_GROUP3;
>, <Line: +		else if (g0 == 7) 
>, <Line: +			linearOrder = DATATYPE_ORDER_IN_GROUP7;
>, <Line: +		else
>, <Line: +			return dt0;
>, <Line: +		int o0 = linearOrder.get(dt0);
>, <Line: +		int o1 = linearOrder.get(dt1);
>, <Line: +		if (o0 > o1)
>, <Line: +			return dt0;
>, <Line: +		return dt1;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * 
>, <Line: +	 * SERVICE METHODS
>, <Line: +	 * 
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * (CL)
>, <Line: +	 * 
>, <Line: +	 * subClassExpression := Class | subObjectSomeValuesFrom | DataSomeValuesFrom
>, <Line: +	 * 
>, <Line: +	 * subObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression owl:Thing ')'
>, <Line: +	 * DataSomeValuesFrom := 'DataSomeValuesFrom' '(' DataPropertyExpression DataRange ')'
>, <Line: +	 * 
>, <Line: +	 * @param owlCE
>, <Line: +	 * @return
>, <Line: +	 * @throws TranslationException
>, <Line: +	 */
>, <Line: +	private ClassExpression getSubclassExpression(OWLClassExpression owlCE) throws TranslationException {
>, <Line: +		if (owlCE instanceof OWLClass) {
>, <Line: +			return helper.getOClass((OWLClass)owlCE);
>, <Line: +		} 
>, <Line: +		else if (owlCE instanceof OWLObjectSomeValuesFrom) {
>, <Line: +			OWLObjectSomeValuesFrom someexp = (OWLObjectSomeValuesFrom)owlCE;
>, <Line: +			if (!someexp.getFiller().isOWLThing()) 
>, <Line: +				throw new TranslationException();
>, <Line: +			return helper.getPropertyExpression(someexp.getProperty()).getDomain();		
>, <Line: +		} 
>, <Line: +		else if (owlCE instanceof OWLDataSomeValuesFrom) {
>, <Line: +			OWLDataSomeValuesFrom someexp = (OWLDataSomeValuesFrom) owlCE;
>, <Line: +			return getDataSomeValuesFrom(someexp.getProperty(), someexp.getFiller());
>, <Line: +		}
>, <Line: +		else if (minCardinalityClassExpressions && owlCE instanceof OWLObjectMinCardinality) {
>, <Line: +			OWLObjectMinCardinality someexp = (OWLObjectMinCardinality) owlCE;
>, <Line: +			if (someexp.getCardinality() != 1 || !someexp.getFiller().isOWLThing()) 
>, <Line: +				throw new TranslationException();
>, <Line: +			return helper.getPropertyExpression(someexp.getProperty()).getDomain();
>, <Line: +		} 
>, <Line: +		else if (minCardinalityClassExpressions && owlCE instanceof OWLDataMinCardinality) {
>, <Line: +			OWLDataMinCardinality someexp = (OWLDataMinCardinality) owlCE;
>, <Line: +			if (someexp.getCardinality() != 1) 
>, <Line: +				throw new TranslationException();
>, <Line: +			return getDataSomeValuesFrom(someexp.getProperty(), someexp.getFiller());
>, <Line: +		} 
>, <Line: +		else
>, <Line: +			throw new TranslationException("unsupported construct " + owlCE);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * (CR)
>, <Line: +	 * 
>, <Line: +	 * superClassExpression := Class | superObjectIntersectionOf | superObjectComplementOf | 
>, <Line: +	 * 								superObjectSomeValuesFrom | DataSomeValuesFrom
>, <Line: +	 * 
>, <Line: +	 * superObjectIntersectionOf := 'ObjectIntersectionOf' '(' superClassExpression superClassExpression { superClassExpression } ')'
>, <Line: +	 * superObjectComplementOf := 'ObjectComplementOf' '(' subClassExpression ')'
>, <Line: +	 * superObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression Class ')'
>, <Line: +	 * DataSomeValuesFrom := 'DataSomeValuesFrom' '(' DataPropertyExpression DataRange ')'
>, <Line: +	 * 
>, <Line: +	 * replaces ObjectIntersectionOf by a number of subClassOf axioms (rule [R4])
>, <Line: +	 *          superObjectComplementOf by disjointness axioms (rule [R5])
>, <Line: +	 *          
>, <Line: +	 * @throws InconsistentOntologyException 
>, <Line: +	 */
>, <Line: +	private void addSubClassAxioms(ClassExpression ce1, OWLClassExpression owlCE2) throws TranslationException, InconsistentOntologyException {
>, <Line: +		// .asConjunctSet() flattens out the intersections and the loop deals with [R4]
>, <Line: +		for (OWLClassExpression superClass : owlCE2.asConjunctSet()) {
>, <Line: +			if (superClass instanceof OWLClass) {				
>, <Line: +				ClassExpression ce2 = helper.getOClass((OWLClass)superClass);
>, <Line: +				dl_onto.addSubClassOfAxiom(ce1, ce2);
>, <Line: +			} 
>, <Line: +			else if (superClass instanceof OWLObjectSomeValuesFrom) {
>, <Line: +				OWLObjectSomeValuesFrom someexp = (OWLObjectSomeValuesFrom) superClass;
>, <Line: +				addSubClassOfObjectSomeValuesFromAxiom(ce1, someexp.getProperty(), someexp.getFiller());
>, <Line: +			} 
>, <Line: +			else if (superClass instanceof OWLDataSomeValuesFrom) {
>, <Line: +				OWLDataSomeValuesFrom someexp = (OWLDataSomeValuesFrom) superClass;
>, <Line: +				ClassExpression ce2 = getDataSomeValuesFrom(someexp.getProperty(), someexp.getFiller());
>, <Line: +				//if ((ce2 instanceof DataSomeValuesFrom) && 
>, <Line: +				//		!((DataSomeValuesFrom)ce2).getDatatype().equals(DatatypeImpl.rdfsLiteral))
>, <Line: +				//	System.err.println("CI WITH QDD: " + ce1 + " <= " + ce2);
>, <Line: +				dl_onto.addSubClassOfAxiom(ce1, ce2);
>, <Line: +			} 
>, <Line: +			else if (superClass instanceof OWLObjectComplementOf) {
>, <Line: +				OWLObjectComplementOf superC = (OWLObjectComplementOf)superClass;
>, <Line: +				// [R5]
>, <Line: +				ClassExpression ce2 = getSubclassExpression(superC.getOperand());
>, <Line: +				dl_onto.addDisjointClassesAxiom(ce1, ce2);
>, <Line: +			}
>, <Line: +			else if (minCardinalityClassExpressions && superClass instanceof OWLObjectMinCardinality) {
>, <Line: +				OWLObjectMinCardinality someexp = (OWLObjectMinCardinality) superClass;
>, <Line: +				if (someexp.getCardinality() != 1) 
>, <Line: +					throw new TranslationException();
>, <Line: +				addSubClassOfObjectSomeValuesFromAxiom(ce1, someexp.getProperty(), someexp.getFiller());
>, <Line: +			} 
>, <Line: +			else if (minCardinalityClassExpressions && superClass instanceof OWLDataMinCardinality) {
>, <Line: +				OWLDataMinCardinality someexp = (OWLDataMinCardinality) superClass;				
>, <Line: +				if (someexp.getCardinality() != 1) 
>, <Line: +					throw new TranslationException();
>, <Line: +				ClassExpression ce2 = getDataSomeValuesFrom(someexp.getProperty(), someexp.getFiller());
>, <Line: +				dl_onto.addSubClassOfAxiom(ce1, ce2);
>, <Line: +			} 
>, <Line: +			else
>, <Line: +				throw new TranslationException("unsupported operation in " + superClass);			
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private void addSubClassOfObjectSomeValuesFromAxiom(ClassExpression ce1, OWLObjectPropertyExpression owlOPE, OWLClassExpression owlCE) throws TranslationException, InconsistentOntologyException {
>, <Line: +		// rule [C0]
>, <Line: +		if (owlOPE.isOWLBottomObjectProperty() || owlCE.isOWLNothing()) {
>, <Line: +			dl_onto.addSubClassOfAxiom(ce1, ClassImpl.owlNothing);
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			if (owlCE.isOWLThing()) {
>, <Line: +				if (!owlOPE.isOWLTopObjectProperty()) { // this check is not really needed
>, <Line: +					ObjectPropertyExpression ope = helper.getPropertyExpression(owlOPE);
>, <Line: +					dl_onto.addSubClassOfAxiom(ce1, ope.getDomain());		
>, <Line: +				}
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				Map<OWLClassExpression, ObjectSomeValuesFrom> entry = auxiliaryClassProperties.get(owlOPE);
>, <Line: +				if (entry == null) {
>, <Line: +					entry = new HashMap<>();
>, <Line: +					auxiliaryClassProperties.put(owlOPE, entry);
>, <Line: +				}
>, <Line: +				ObjectSomeValuesFrom existsSA = entry.get(owlCE);
>, <Line: +				if (existsSA == null) {
>, <Line: +					// no replacement found for this exists R.A, creating a new one						
>, <Line: +					ObjectPropertyExpression R = helper.getPropertyExpression(owlOPE);
>, <Line: +					ObjectPropertyExpression SA = dl_onto.createAuxiliaryObjectProperty();
>, <Line: +					if (R.isInverse())
>, <Line: +						SA = SA.getInverse();
>, <Line: +					existsSA = SA.getDomain();
>, <Line: +					entry.put(owlCE, existsSA);
>, <Line: +					//System.err.println("AUX:" + owlOPE + "." + owlCE);
>, <Line: +					if (owlCE instanceof OWLClass) {
>, <Line: +						ClassExpression A = getSubclassExpression(owlCE);
>, <Line: +						dl_onto.addSubClassOfAxiom(SA.getRange(), A);
>, <Line: +					}
>, <Line: +					else if (nestedQualifiedExistentials) {
>, <Line: +						addSubClassAxioms(SA.getRange(), owlCE);
>, <Line: +					}
>, <Line: +					else
>, <Line: +						throw new TranslationException("Complex expression in the superclass filler"); 
>, <Line: +					dl_onto.addSubPropertyOfAxiom(SA, R);
>, <Line: +				}
>, <Line: +				dl_onto.addSubClassOfAxiom(ce1, existsSA);			
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private ClassExpression getDataSomeValuesFrom(OWLDataPropertyExpression owlDPE, OWLDataRange owlDR) throws TranslationException {
>, <Line: +		OWL2Datatype owlDatatype = getCanonicalDatatype(owlDR);
>, <Line: +		if (owlDatatype == null) {
>, <Line: +			// rule [DT1.2]
>, <Line: +			return ClassImpl.owlNothing;
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			Datatype datatype = dl_onto.getVocabulary().getDatatype(owlDatatype.getIRI().toString());
>, <Line: +			//if (!datatype.equals(DatatypeImpl.rdfsLiteral))
>, <Line: +			//	System.err.println("QDD: " + owlDPE + "." + owlDR);
>, <Line: +			DataPropertyExpression dpe = helper.getPropertyExpression(owlDPE);			
>, <Line: +			return dpe.getDomainRestriction(datatype);
>, <Line: +		}				
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDisjointUnionAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLFunctionalObjectPropertyAxiom ax) {
>, <Line: +		// TEMPORARY FIX
>, <Line: +		if (functionalityAxioms) {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addFunctionalObjectPropertyAxiom(ope);
>, <Line: +		}
>, <Line: +		else
>, <Line: +			log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLInverseFunctionalObjectPropertyAxiom ax) {
>, <Line: +		// TEMPORARY FIX
>, <Line: +		if (functionalityAxioms) {
>, <Line: +			ObjectPropertyExpression ope = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addFunctionalObjectPropertyAxiom(ope.getInverse());
>, <Line: +		}
>, <Line: +		else
>, <Line: +			log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLTransitiveObjectPropertyAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLNegativeObjectPropertyAssertionAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLFunctionalDataPropertyAxiom ax) {
>, <Line: +		// TEMPORARY FIX
>, <Line: +		if (functionalityAxioms) {
>, <Line: +			DataPropertyExpression dpe = helper.getPropertyExpression(ax.getProperty());
>, <Line: +			dl_onto.addFunctionalDataPropertyAxiom(dpe);		
>, <Line: +		}
>, <Line: +		else
>, <Line: +			log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLNegativeDataPropertyAssertionAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSameIndividualAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSubPropertyChainOfAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLHasKeyAxiom ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(SWRLRule ax) {
>, <Line: +		log.warn(NOT_SUPPORTED, ax);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLAnnotationAssertionAxiom arg0) {
>, <Line: +		// NO-OP: AnnotationAxioms have no effect
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLSubAnnotationPropertyOfAxiom arg0) {
>, <Line: +		// NO-OP: AnnotationAxioms have no effect
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLAnnotationPropertyDomainAxiom arg0) {
>, <Line: +		// NO-OP: AnnotationAxioms have no effect
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLAnnotationPropertyRangeAxiom arg0) {
>, <Line: +		// NO-OP: AnnotationAxioms have no effect
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void visit(OWLDeclarationAxiom ax) {
>, <Line: +		// NO-OP: DeclarationAxioms are handled in prepare()
>, <Line: +	}
>, <Line: +	private OWLOntology currentOWLOntology; // required to retrieve datatype definitions 
>, <Line: +	private final Set<String> objectproperties = new HashSet<>();
>, <Line: +	private final Set<String> dataproperties = new HashSet<>();
>, <Line: +	private final Set<String> punnedPredicates = new HashSet<>();
>, <Line: +	public void setCurrentOWLOntology(OWLOntology owl) {
>, <Line: +		currentOWLOntology = owl;
>, <Line: +	}
>, <Line: +	private final Ontology createOntology(Collection<OWLOntology> owls) {
>, <Line: +		OntologyVocabulary vb = OntologyFactoryImpl.getInstance().createVocabulary();
>, <Line: +		// add all definitions for classes and properties		
>, <Line: +		for (OWLOntology owl : owls) {
>, <Line: +			for (OWLClass entity : owl.getClassesInSignature())  {
>, <Line: +				String uri = entity.getIRI().toString();
>, <Line: +				vb.createClass(uri);			
>, <Line: +			}
>, <Line: +			for (OWLObjectProperty prop : owl.getObjectPropertiesInSignature()) {
>, <Line: +				String uri = prop.getIRI().toString();
>, <Line: +				if (dataproperties.contains(uri))  {
>, <Line: +					punnedPredicates.add(uri); 
>, <Line: +					log.warn("Quest can become unstable with properties declared as both data and object. Offending property: " + uri);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					objectproperties.add(uri);
>, <Line: +					vb.createObjectProperty(uri);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			for (OWLDataProperty prop : owl.getDataPropertiesInSignature())  {
>, <Line: +				String uri = prop.getIRI().toString();
>, <Line: +				if (objectproperties.contains(uri)) {
>, <Line: +					punnedPredicates.add(uri);
>, <Line: +					log.warn("Quest can become unstable with properties declared as both data and object. Offending property: " + uri);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					dataproperties.add(uri);
>, <Line: +					vb.createDataProperty(uri);
>, <Line: +				}
>, <Line: +			}			
>, <Line: +		}
>, <Line: +		return ofac.createOntology(vb);		
>, <Line: +	}
>, <Line: +}
>]
[]