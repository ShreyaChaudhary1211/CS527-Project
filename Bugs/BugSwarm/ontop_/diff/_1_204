[<Line: +                boolean innerchanges = applySingletonSubstitution(fclone, substitution);
>, <Line: +    /**
>, <Line: +     * May alter the functionalTerm (mutable style)
>, <Line: +     *
>, <Line: +     * Recursive
>, <Line: +     */
>, <Line: +    private static boolean applySingletonSubstitution(Function functionalTerm, SingletonSubstitution substitution) {
>, <Line: +        List<Term> innerTerms = functionalTerm.getTerms();
>, <Line: +        boolean innerchanges = false;
>, <Line: +        // TODO this ways of changing inner terms in functions is not
>, <Line: +        // optimal, modify
>, <Line: +        for (int i = 0; i < innerTerms.size(); i++) {
>, <Line: +            Term innerTerm = innerTerms.get(i);
>, <Line: +            if (innerTerm instanceof Function) {
>, <Line: +                // Recursive call
>, <Line: +                innerchanges = innerchanges || applySingletonSubstitution((Function)innerTerm, substitution);
>, <Line: +            }
>, <Line: +            else if (substitution.getVariable().equals(innerTerm)) { // ROMAN: no need in isEqual(innerTerm, s.getVariable())
>, <Line: +                functionalTerm.getTerms().set(i, substitution.getTerm());
>, <Line: +                innerchanges = true;
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return innerchanges;
>, <Line: +    }
>]
[<Line: -                boolean innerchanges = false;
>, <Line: -                // TODO this ways of changing inner terms in functions is not
>, <Line: -                // optimal, modify
>, <Line: -                for (int i = 0; i < innerTerms.size(); i++) {
>, <Line: -                    Term innerTerm = innerTerms.get(i);
>, <Line: -                    if (substitution.getVariable().equals(innerTerm)) { // ROMAN: no need in isEqual(innerTerm, s.getVariable())
>, <Line: -                        fclone.getTerms().set(i, substitution.getTerm());
>, <Line: -                        innerchanges = true;
>, <Line: -                    }
>, <Line: -                }
>]