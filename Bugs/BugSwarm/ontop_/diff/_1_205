[<Line: +/*
>, <Line: +        // Basic case: if predicates are different or their arity is different,
>, <Line: +        // then no unifier
>, <Line: +        if ((first.getArity() != second.getArity()
>, <Line: +                || !first.getFunctionSymbol().equals(second.getFunctionSymbol()))) {
>, <Line: +            return null;
>, <Line: +        }
>, <Line: +        Function firstAtom = (Function) first.clone();
>, <Line: +        Function secondAtom = (Function) second.clone();
>, <Line: +        int arity = first.getArity();
>, <Line: +        Substitution mgu = new SubstitutionImpl();
>, <Line: +        // Computing the disagreement set
>, <Line: +        for (int termidx = 0; termidx < arity; termidx++) {
>, <Line: +            // Checking if there are already substitutions calculated for the
>, <Line: +            // current terms. If there are any, then we have to take the
>, <Line: +            // substituted terms instead of the original ones.
>, <Line: +            Term term1 = firstAtom.getTerm(termidx);
>, <Line: +            Term term2 = secondAtom.getTerm(termidx);
>, <Line: +            boolean changed = false;
>, <Line: +            // We have two cases, unifying 'simple' terms, and unifying function terms.
>, <Line: +            if (!(term1 instanceof Function) || !(term2 instanceof Function)) {
>, <Line: +                if (!mgu.compose(term1, term2))
>, <Line: +                    return null;
>, <Line: +                changed = true;
>, <Line: +            } 
>, <Line: +            else {
>, <Line: +                // if both of them are function terms then we need to do some
>, <Line: +                // check in the inner terms
>, <Line: +                Function fterm1 = (Function) term1;
>, <Line: +                Function fterm2 = (Function) term2;
>, <Line: +                if ((fterm1.getTerms().size() != fterm2.getTerms().size()) ||
>, <Line: +                        !fterm1.getFunctionSymbol().equals(fterm2.getFunctionSymbol())) {
>, <Line: +                    return null;
>, <Line: +                }
>, <Line: +                int innerarity = fterm1.getTerms().size();
>, <Line: +                for (int innertermidx = 0; innertermidx < innerarity; innertermidx++) {
>, <Line: +                    if (!mgu.compose(fterm1.getTerm(innertermidx), fterm2.getTerm(innertermidx)))
>, <Line: +                        return null;
>, <Line: +                    changed = true;
>, <Line: +                    // Applying the newly computed substitution to the 'replacement' of
>, <Line: +                    // the existing substitutions
>, <Line: +                    SubstitutionUtilities.applySubstitution(fterm1, mgu, innertermidx + 1);
>, <Line: +                    SubstitutionUtilities.applySubstitution(fterm2, mgu, innertermidx + 1);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            if (changed) {
>, <Line: +                // Applying the newly computed substitution to the 'replacement' of
>, <Line: +                // the existing substitutions
>, <Line: +                SubstitutionUtilities.applySubstitution(firstAtom, mgu, termidx + 1);
>, <Line: +                SubstitutionUtilities.applySubstitution(secondAtom, mgu, termidx + 1);
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return mgu;
>, <Line: +*/        
>]
[<Line: -/*
>, <Line: - * Note: The the unifier does not distinguish between undistinguished variables
>, <Line: - * i.e.when we have an atom A(#,#) which should be unified with B(b,c) the
>, <Line: - * unifier willreturn two thetas #/b, #/c. So far so good but this will lead to
>, <Line: - * problems whenapplying the thetas because there is no distinction between
>, <Line: - * #-variables, sothe first theta is applied to all #-variables and the rest is
>, <Line: - * ignored.In order to avoid problems one can enumerate the undistinguished
>, <Line: - * variables ie. A(#1,#2)
>, <Line: - */
>, <Line: -import it.unibz.krdb.obda.model.CQIE;
>, <Line: -    /**
>, <Line: -     * Unifies two atoms in a conjunctive query returning a new conjunctive
>, <Line: -     * query. To to this we calculate the MGU for atoms, duplicate the query q
>, <Line: -     * into q', remove i and j from q', apply the mgu to q', and
>, <Line: -     *
>, <Line: -     * @param q
>, <Line: -     * @param i
>, <Line: -     * @param j (j > i)
>, <Line: -     * @return null if the two atoms are not unifiable, else a new conjunctive
>, <Line: -     * query produced by the unification of j and i
>, <Line: -     * @throws Exception
>, <Line: -     */
>, <Line: -    public static CQIE unify(CQIE q, int i, int j) {
>, <Line: -        Function atom1 = q.getBody().get(i);
>, <Line: -        Function atom2 = q.getBody().get(j);
>, <Line: -        Substitution mgu = getMGU(atom1, atom2);
>, <Line: -        if (mgu == null)
>, <Line: -            return null;
>, <Line: -        CQIE unifiedQ = SubstitutionUtilities.applySubstitution(q, mgu);
>, <Line: -        unifiedQ.getBody().remove(i);
>, <Line: -        unifiedQ.getBody().remove(j - 1);
>, <Line: -        Function newatom = (Function) atom1.clone();
>, <Line: -        SubstitutionUtilities.applySubstitution(newatom, mgu);
>, <Line: -        unifiedQ.getBody().add(i, newatom);
>, <Line: -        return unifiedQ;
>, <Line: -    }
>, <Line: -     * IMPORTANT: handling of AnonymousVariables is questionable --
>, <Line: -     * much is left to UnifierUtilities.apply (and only one version handles them)
>]