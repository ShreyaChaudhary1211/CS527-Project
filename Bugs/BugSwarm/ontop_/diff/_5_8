[<Line: +package it.unibz.krdb.obda.owlrefplatform.core.queryevaluation;
>, <Line: +import it.unibz.krdb.obda.model.OBDAQueryModifiers;
>, <Line: +import java.sql.Types;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Set;
>, <Line: +import java.util.regex.Pattern;
>, <Line: +/**
>, <Line: + * Created by elem on 22/06/15.
>, <Line: + */
>, <Line: +public class MonetDBSQLDialectAdapter extends SQL99DialectAdapter {
>, <Line: +    private Pattern quotes = Pattern.compile("[\"`\\['].*[\"`\\]']");
>, <Line: +    @Override
>, <Line: +    public String strConcat(String[] strings) {
>, <Line: +        if (strings.length == 0)
>, <Line: +            throw new IllegalArgumentException("Cannot concatenate 0 strings");
>, <Line: +        if (strings.length == 1)
>, <Line: +            return strings[0];
>, <Line: +        StringBuilder sql = new StringBuilder();
>, <Line: +        sql.append(String.format("(%s", strings[0]));
>, <Line: +        for (int i = 1; i < strings.length; i++) {
>, <Line: +            sql.append(String.format(" || %s", strings[i]));
>, <Line: +        }
>, <Line: +        sql.append(")");
>, <Line: +        return sql.toString();
>, <Line: +    }
>, <Line: +    public String strReplace(String str, char oldchar, char newchar) {
>, <Line: +        return String.format("REPLACE(%s, '%s', '%s')", str, oldchar, newchar);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String strReplace(String str, String oldstr, String newstr) {
>, <Line: +        if(quotes.matcher(oldstr).matches() ) {
>, <Line: +            oldstr = oldstr.substring(1, oldstr.length() - 1); // remove the enclosing quotes
>, <Line: +        }
>, <Line: +        if(quotes.matcher(newstr).matches() ) {
>, <Line: +            newstr = newstr.substring(1, newstr.length() - 1);
>, <Line: +        }
>, <Line: +        return String.format("REPLACE(%s, '%s', '%s')", str, oldstr, newstr);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String sqlQualifiedColumn(String tablename, String columnname) {
>, <Line: +        // TODO: This should depend on whether the column name was quoted in the original sql query
>, <Line: +        return String.format("%s.\"%s\"", tablename, columnname);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +//	public String sqlTableName(String tablename, String viewname) {
>, <Line: +//		return String.format("\"%s\" %s", tablename, viewname);
>, <Line: +//	}
>, <Line: +	/*Now we use the table name given by the user,
>, <Line: +	  and we assume that it includes the quotes if needed*/
>, <Line: +    public String sqlTableName(String tablename, String viewname) {
>, <Line: +        return String.format("%s %s", tablename, viewname);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String sqlQuote(String name) {
>, <Line: +        //TODO: This should depend on quotes in the sql in the mappings
>, <Line: +        return String.format("\"%s\"", name);
>, <Line: +//		return name;
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * There is no standard for this part.
>, <Line: +     *
>, <Line: +     * Arbitrary default implementation proposed
>, <Line: +     * (may not work with many DB engines).
>, <Line: +     */
>, <Line: +    @Override
>, <Line: +    public String sqlSlice(long limit, long offset) {
>, <Line: +        if ((limit < 0) && (offset < 0)) {
>, <Line: +            return "";
>, <Line: +        }
>, <Line: +        else if ((limit >= 0) && (offset >= 0)) {
>, <Line: +            return String.format("LIMIT %d OFFSET %d", offset, limit);
>, <Line: +        }
>, <Line: +        else if (offset < 0) {
>, <Line: +            return String.format("LIMIT %d", limit);
>, <Line: +        }
>, <Line: +        // Else -> (limit < 0)
>, <Line: +        else {
>, <Line: +            return String.format("OFFSET %d", offset);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String sqlOrderBy(List<OBDAQueryModifiers.OrderCondition> conditions, String viewname) {
>, <Line: +        String sql = "ORDER BY ";
>, <Line: +        boolean needComma = false;
>, <Line: +        for (OBDAQueryModifiers.OrderCondition c : conditions) {
>, <Line: +            if (needComma) {
>, <Line: +                sql += ", ";
>, <Line: +            }
>, <Line: +            sql += sqlQualifiedColumn(viewname, c.getVariable().getName());
>, <Line: +            if (c.getDirection() == OBDAQueryModifiers.OrderCondition.ORDER_DESCENDING) {
>, <Line: +                sql += " DESC";
>, <Line: +            }
>, <Line: +            needComma = true;
>, <Line: +        }
>, <Line: +        return sql;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String sqlCast(String value, int type) {
>, <Line: +        String strType = null;
>, <Line: +        if (type == Types.VARCHAR) {
>, <Line: +            strType = "STRING";
>, <Line: +        } else {
>, <Line: +            throw new RuntimeException("Unsupported SQL type");
>, <Line: +        }
>, <Line: +        return "CAST(" + value + " AS " + strType + ")";
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String sqlRegex(String columnname, String pattern, boolean caseinSensitive, boolean multiLine, boolean dotAllMode) {
>, <Line: +        if(quotes.matcher(pattern).matches() ) {
>, <Line: +            pattern = pattern.substring(1, pattern.length() - 1); // remove the
>, <Line: +            // enclosing
>, <Line: +            // quotes
>, <Line: +        }
>, <Line: +        //we use % wildcards to search for a string that contains and not only match the pattern
>, <Line: +        if (caseinSensitive) {
>, <Line: +            return " LOWER(" + columnname + ") LIKE " + "'%"
>, <Line: +                    + pattern.toLowerCase() + "%'";
>, <Line: +        }
>, <Line: +        return columnname + " LIKE " + "'%" + pattern + "%'";
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String getDummyTable() {
>, <Line: +        // TODO: check whether this inherited implementation from JDBCUtilities is OK
>, <Line: +        return "SELECT 1";
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String getSQLLexicalFormString(String constant) {
>, <Line: +        return "'" + constant + "'";
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String getSQLLexicalFormBoolean(boolean value) {
>, <Line: +        // TODO: check whether this implementation inherited from JDBCUtility is correct
>, <Line: +        return value ? 	"TRUE" : "FALSE";
>, <Line: +    }
>, <Line: +    /***
>, <Line: +     * Given an XSD dateTime this method will generate a SQL TIMESTAMP value.
>, <Line: +     * The method will strip any fractional seconds found in the date time
>, <Line: +     * (since we haven't found a nice way to support them in all databases). It
>, <Line: +     * will also normalize the use of Z to the timezome +00:00 and last, if the
>, <Line: +     * database is H2, it will remove all timezone information, since this is
>, <Line: +     * not supported there.
>, <Line: +     *
>, <Line: +     */
>, <Line: +    @Override
>, <Line: +    public String getSQLLexicalFormDatetime(String v) {
>, <Line: +        // TODO: check whether this implementation inherited from JDBCUtility is correct
>, <Line: +        String datetime = v.replace('T', ' ');
>, <Line: +        int dotlocation = datetime.indexOf('.');
>, <Line: +        int zlocation = datetime.indexOf('Z');
>, <Line: +        int minuslocation = datetime.indexOf('-', 10); // added search from 10th pos, because we need to ignore minuses in date
>, <Line: +        int pluslocation = datetime.indexOf('+');
>, <Line: +        StringBuilder bf = new StringBuilder(datetime);
>, <Line: +        if (zlocation != -1) {
>, <Line: +			/*
>, <Line: +			 * replacing Z by +00:00
>, <Line: +			 */
>, <Line: +            bf.replace(zlocation, bf.length(), "+00:00");
>, <Line: +        }
>, <Line: +        if (dotlocation != -1) {
>, <Line: +			/*
>, <Line: +			 * Stripping the string from the presicion that is not supported by
>, <Line: +			 * SQL timestamps.
>, <Line: +			 */
>, <Line: +            // TODO we need to check which databases support fractional
>, <Line: +            // sections (e.g., oracle,db2, postgres)
>, <Line: +            // so that when supported, we use it.
>, <Line: +            int endlocation = Math.max(zlocation, Math.max(minuslocation, pluslocation));
>, <Line: +            if (endlocation == -1) {
>, <Line: +                endlocation = datetime.length();
>, <Line: +            }
>, <Line: +            bf.replace(dotlocation, endlocation, "");
>, <Line: +        }
>, <Line: +        bf.insert(0, "'");
>, <Line: +        bf.append("'");
>, <Line: +        return bf.toString();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String getSQLLexicalFormDatetimeStamp(String v) {
>, <Line: +        // TODO: check whether this implementation inherited from JDBCUtility is correct
>, <Line: +        String datetime = v.replace('T', ' ');
>, <Line: +        int dotlocation = datetime.indexOf('.');
>, <Line: +        int zlocation = datetime.indexOf('Z');
>, <Line: +        int minuslocation = datetime.indexOf('-', 10); // added search from 10th pos, because we need to ignore minuses in date
>, <Line: +        int pluslocation = datetime.indexOf('+');
>, <Line: +        StringBuilder bf = new StringBuilder(datetime);
>, <Line: +        if (zlocation != -1) {
>, <Line: +			/*
>, <Line: +			 * replacing Z by +00:00
>, <Line: +			 */
>, <Line: +            bf.replace(zlocation, bf.length(), "+00:00");
>, <Line: +        }
>, <Line: +        if (dotlocation != -1) {
>, <Line: +			/*
>, <Line: +			 * Stripping the string from the presicion that is not supported by
>, <Line: +			 * SQL timestamps.
>, <Line: +			 */
>, <Line: +            // TODO we need to check which databases support fractional
>, <Line: +            // sections (e.g., oracle,db2, postgres)
>, <Line: +            // so that when supported, we use it.
>, <Line: +            int endlocation = Math.max(zlocation, Math.max(minuslocation, pluslocation));
>, <Line: +            if (endlocation == -1) {
>, <Line: +                endlocation = datetime.length();
>, <Line: +            }
>, <Line: +            bf.replace(dotlocation, endlocation, "");
>, <Line: +        }
>, <Line: +        bf.insert(0, "'");
>, <Line: +        bf.append("'");
>, <Line: +        return bf.toString();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String nameTopVariable(String signatureVariableName, String proposedSuffix, Set<String> sqlVariableNames) {
>, <Line: +        return sqlQuote(signatureVariableName + proposedSuffix);
>, <Line: +    }
>, <Line: +}
>]
[]