[<Line: +/**
>, <Line: + * Copyright (c) 2015, Joyent, Inc. All rights reserved.
>, <Line: + */
>, <Line: +package com.joyent.manta.client;
>, <Line: +import com.joyent.manta.exception.MantaClientException;
>, <Line: +import com.joyent.manta.exception.MantaClientHttpResponseException;
>, <Line: +import com.joyent.manta.exception.MantaException;
>, <Line: +import com.joyent.manta.exception.MantaJobException;
>, <Line: +import java.io.IOException;
>, <Line: +import java.io.InputStream;
>, <Line: +import java.time.Duration;
>, <Line: +import java.time.temporal.ChronoUnit;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Objects;
>, <Line: +import java.util.UUID;
>, <Line: +import java.util.concurrent.CopyOnWriteArrayList;
>, <Line: +import java.util.stream.Collectors;
>, <Line: +import java.util.stream.Stream;
>, <Line: +/**
>, <Line: + * Class that provides a fluent interface for building jobs. This class
>, <Line: + * doesn't provide any new functionality from what is available in
>, <Line: + * {@link MantaClient}. However, it does provide a very easy way of
>, <Line: + * programmatically creating new jobs. The purpose of this class is not
>, <Line: + * to replicate all of the job functionality on {@link MantaClient}, but
>, <Line: + * rather to provide a subset of it in an easy to use API.
>, <Line: + *
>, <Line: + * @author <a href="https://github.com/dekobon">Elijah Zupancic</a>
>, <Line: + */
>, <Line: +@SuppressWarnings("checkstyle:finalclass")
>, <Line: +public class MantaJobBuilder {
>, <Line: +    /**
>, <Line: +     * Reference to the {@link MantaClient} used to execute jobs.
>, <Line: +     */
>, <Line: +    private final MantaClient client;
>, <Line: +    /**
>, <Line: +     * Package scope constructor used because we don't want consumers
>, <Line: +     * of the library directly creating instances of {@link MantaJobBuilder}
>, <Line: +     * because it will require closing the resource. Thus, to keep it simple
>, <Line: +     * we provide a method on {@link MantaClient#jobBuilder()} that allows
>, <Line: +     * for creating a {@link MantaJobBuilder}.
>, <Line: +     *
>, <Line: +     * @param client Reference to the {@link MantaClient} used to execute jobs
>, <Line: +     */
>, <Line: +    MantaJobBuilder(final MantaClient client) {
>, <Line: +        this.client = client;
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Create a new job with the specified name.
>, <Line: +     * @param name name of job
>, <Line: +     * @return a fluent interface providing job creation options
>, <Line: +     */
>, <Line: +    public Create newJob(final String name) {
>, <Line: +        return new Create(this, name);
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Inner class that provides methods used in the construction of a new job.
>, <Line: +     * This allows us to easily add inputs and phases to the job.
>, <Line: +     */
>, <Line: +    public static class Create {
>, <Line: +        /**
>, <Line: +         * Name of job.
>, <Line: +         */
>, <Line: +        private final String name;
>, <Line: +        /**
>, <Line: +         * Reference to {@link MantaJobBuilder} instance that created this instance.
>, <Line: +         */
>, <Line: +        private final MantaJobBuilder parent;
>, <Line: +        /**
>, <Line: +         * A list of the phases used in the job.
>, <Line: +         */
>, <Line: +        private final List<MantaJobPhase> phases = new CopyOnWriteArrayList<>();
>, <Line: +        /**
>, <Line: +         * A list of the inputs to be attached to the job.
>, <Line: +         */
>, <Line: +        private final List<String> inputs = new CopyOnWriteArrayList<>();
>, <Line: +        /**
>, <Line: +         * Creates a new instance of the fluent job creation class.
>, <Line: +         *
>, <Line: +         * @param parent reference to {@link MantaJobBuilder} instance that created this instance
>, <Line: +         * @param name name of the job
>, <Line: +         */
>, <Line: +        private Create(final MantaJobBuilder parent, final String name) {
>, <Line: +            this.parent = parent;
>, <Line: +            this.name = name;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Add a single phase to the job.
>, <Line: +         *
>, <Line: +         * @param phase phase to add
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addPhase(final MantaJobPhase phase) {
>, <Line: +            Objects.requireNonNull(phase, "Phase must be present");
>, <Line: +            phases.add(phase);
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Add multiple phases to the job.
>, <Line: +         *
>, <Line: +         * @param additionalPhases phases to add
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addPhases(final Iterable<MantaJobPhase> additionalPhases) {
>, <Line: +            Objects.requireNonNull(phases, "Phases must be present");
>, <Line: +            for (MantaJobPhase phase : additionalPhases) {
>, <Line: +                phases.add(phase);
>, <Line: +            }
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Add multiple phases to the job.
>, <Line: +         *
>, <Line: +         * @param additionalPhases phases to add
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addPhases(final Stream<MantaJobPhase> additionalPhases) {
>, <Line: +            Objects.requireNonNull(phases, "Phases must be present");
>, <Line: +            additionalPhases.forEach(phases::add);
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Add input to job.
>, <Line: +         *
>, <Line: +         * @param input path to Manta object representing the input.
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addInput(final String input) {
>, <Line: +            inputs.add(input);
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Adds multiple inputs to the job.
>, <Line: +         *
>, <Line: +         * @param additionalInputs multiple inputs to add
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addInputs(final Iterable<String> additionalInputs) {
>, <Line: +            for (String input : additionalInputs) {
>, <Line: +                inputs.add(input);
>, <Line: +            }
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Adds multiple inputs to the job.
>, <Line: +         *
>, <Line: +         * @param additionalInputs multiple inputs to add
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         */
>, <Line: +        public Create addInputs(final Stream<String> additionalInputs) {
>, <Line: +            additionalInputs.forEach(inputs::add);
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Validates the inputs already added and throws a {@link MantaJobException}
>, <Line: +         * if any of the inputs are inaccessible.
>, <Line: +         *
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         * @throws MantaJobException thrown if any of the inputs were invalid
>, <Line: +         */
>, <Line: +        public Create validateInputs() {
>, <Line: +            StringBuilder builder = new StringBuilder();
>, <Line: +            Map<String, Exception> generalExceptions = new HashMap<>();
>, <Line: +            Map<String, MantaClientHttpResponseException> mantaExceptions = new HashMap<>();
>, <Line: +            for (String input : inputs) {
>, <Line: +                try {
>, <Line: +                    MantaObject obj = parent.client.head(input);
>, <Line: +                    if (obj.isDirectory()) {
>, <Line: +                        throw new MantaException("Object is not a file, but is a directory");
>, <Line: +                    }
>, <Line: +                } catch (MantaClientHttpResponseException e) {
>, <Line: +                    mantaExceptions.put(input, e);
>, <Line: +                } catch (Exception e) {
>, <Line: +                    generalExceptions.put(input, e);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            if (!generalExceptions.isEmpty() || !mantaExceptions.isEmpty()) {
>, <Line: +                builder.append("Error with inputs:");
>, <Line: +                generalExceptions.entrySet().stream().forEach(entry -> {
>, <Line: +                        builder.append("\n")
>, <Line: +                               .append("[").append(entry.getKey()).append("] ")
>, <Line: +                               .append(entry.getValue().getMessage());
>, <Line: +                });
>, <Line: +                mantaExceptions.entrySet().stream().forEach(entry -> {
>, <Line: +                    builder.append("\n")
>, <Line: +                            .append("[").append(entry.getKey()).append("] ")
>, <Line: +                            .append("(").append(entry.getValue().getServerCode()).append(") ")
>, <Line: +                            .append(entry.getValue().getMessage());
>, <Line: +                });
>, <Line: +                throw new MantaJobException(builder.toString());
>, <Line: +            }
>, <Line: +            return this;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Run the created job by invoking the remote Manta API.
>, <Line: +         *
>, <Line: +         * @return reference to the create fluent builder
>, <Line: +         * @throws IOException thrown when we are unable to execute the job
>, <Line: +         */
>, <Line: +        public Run run() throws IOException {
>, <Line: +            final MantaJob job = new MantaJob(name, phases);
>, <Line: +            final UUID id = parent.client.createJob(job);
>, <Line: +            parent.client.addJobInputs(id, inputs.iterator());
>, <Line: +            parent.client.endJobInput(id);
>, <Line: +            return new Run(parent, id);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Inner class used when a job is at its running stage or it has finished
>, <Line: +     * running but we don't know if it has finished yet. This class provides
>, <Line: +     * methods that allow us to check on the state of the job or to wait until
>, <Line: +     * the job is done.
>, <Line: +     */
>, <Line: +    public static class Run {
>, <Line: +        /**
>, <Line: +         * Job ID.
>, <Line: +         */
>, <Line: +        private final UUID id;
>, <Line: +        /**
>, <Line: +         * Reference to {@link MantaJobBuilder} instance that created this instance.
>, <Line: +         */
>, <Line: +        private final MantaJobBuilder parent;
>, <Line: +        /**
>, <Line: +         * Default wait time between checks to the Manta API.
>, <Line: +         */
>, <Line: +        private static final Duration DEFAULT_TIME_BETWEEN_POLLS =
>, <Line: +                Duration.of(3L, ChronoUnit.SECONDS);
>, <Line: +        /**
>, <Line: +         * Default maximum times to check the Manta API to see if a job has finished.
>, <Line: +         */
>, <Line: +        private static final int DEFAULT_MAX_POLLS = 100;
>, <Line: +        /**
>, <Line: +         * Creates an instance of the inner class used for providing a fluent
>, <Line: +         * API for jobs after they have been started.
>, <Line: +         *
>, <Line: +         * @param parent reference to {@link MantaJobBuilder} instance that created this instance
>, <Line: +         * @param id job id
>, <Line: +         */
>, <Line: +        Run(final MantaJobBuilder parent, final UUID id) {
>, <Line: +            this.parent = parent;
>, <Line: +            this.id = id;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Cancel the job.
>, <Line: +         *
>, <Line: +         * @throws IOException thrown when there is a problem canceling a job over the network
>, <Line: +         */
>, <Line: +        public void cancel() throws IOException {
>, <Line: +            parent.client.cancelJob(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Check the Manta API to see if a Job is done.
>, <Line: +         * @return true if the job is done otherwise false
>, <Line: +         * @throws IOException thrown if there is a problem getting status over the network
>, <Line: +         */
>, <Line: +        public boolean isDone() throws IOException {
>, <Line: +            return getJob().getState().equals("done");
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Get the current job's state represented as a {@link MantaJob} object.
>, <Line: +         *
>, <Line: +         * @return object containing the job's state
>, <Line: +         * @throws IOException thrown when there is a problem getting the job info over the network
>, <Line: +         */
>, <Line: +        public MantaJob getJob() throws IOException {
>, <Line: +            return parent.client.getJob(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Wait for the job to finish. We wait for a pre-set amount of time then
>, <Line: +         * poll the remote API. If the job is finished we return.
>, <Line: +         *
>, <Line: +         * @return object providing a fluent interface for finished jobs
>, <Line: +         * @throws MantaJobException thrown if we have waited too long for a job to complete
>, <Line: +         * @throws IOException  thrown if there is a problem getting the job's status over the network
>, <Line: +         */
>, <Line: +        public Done waitUntilDone() throws IOException {
>, <Line: +            return waitUntilDone(DEFAULT_TIME_BETWEEN_POLLS, DEFAULT_MAX_POLLS);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Wait for the job to finish. We wait for the specified amount of time then
>, <Line: +         * poll the remote API the specified amount of times. If the job is finished we
>, <Line: +         * return.
>, <Line: +         *
>, <Line: +         * @param timeBetweenPolls time to wait between polls to the Manta API
>, <Line: +         * @param maxPolls maximum times to poll the Manta API before giving up
>, <Line: +         * @return object providing a fluent interface for finished jobs
>, <Line: +         * @throws MantaJobException thrown if we have waited too long for a job to complete
>, <Line: +         * @throws IOException  thrown if there is a problem getting the job's status over the network
>, <Line: +         */
>, <Line: +        public Done waitUntilDone(final Duration timeBetweenPolls, final int maxPolls)
>, <Line: +                throws IOException {
>, <Line: +            for (int i = 0; i < maxPolls; i++) {
>, <Line: +                if (isDone()) {
>, <Line: +                    return new Done(this.id, this.parent);
>, <Line: +                }
>, <Line: +                try {
>, <Line: +                    wait(timeBetweenPolls.toMillis());
>, <Line: +                } catch (InterruptedException e) {
>, <Line: +                    throw new MantaJobException(id, "Can't wait any longer for job to finish", e);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            throw new MantaJobException(id, "Job didn't complete in the expected amount of time");
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Go to the done phase of this job without checking to see if the job
>, <Line: +         * is done. Use this at your own risk.
>, <Line: +         *
>, <Line: +         * @return object providing a fluent interface for finished jobs
>, <Line: +         */
>, <Line: +        public Done done() {
>, <Line: +            return new Done(this.id, this.parent);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Inner class that provides methods that allow us to interact with a job
>, <Line: +     * that has finished. For example, this would allow us to get the outputs
>, <Line: +     * or the errors from a job.
>, <Line: +     */
>, <Line: +    public static class Done {
>, <Line: +        /**
>, <Line: +         * Job ID.
>, <Line: +         */
>, <Line: +        private final UUID id;
>, <Line: +        /**
>, <Line: +         * Reference to {@link MantaJobBuilder} instance that created this instance.
>, <Line: +         */
>, <Line: +        private final MantaJobBuilder parent;
>, <Line: +        /**
>, <Line: +         * Creates an instance of the inner class used for providing a fluent
>, <Line: +         * API for jobs after they have finished.
>, <Line: +         *
>, <Line: +         * @param parent reference to {@link MantaJobBuilder} instance that created this instance
>, <Line: +         * @param id job id
>, <Line: +         */
>, <Line: +        Done(final UUID id, final MantaJobBuilder parent) {
>, <Line: +            this.id = id;
>, <Line: +            this.parent = parent;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * <p>Returns a stream of {@link InputStream} implementations for each
>, <Line: +         * output returned from the Manta API for the job.</p>
>, <Line: +         *
>, <Line: +         * <p><strong>Make sure to close this stream when you are done with
>, <Line: +         * otherwise the HTTP socket will remain open.</strong></p>
>, <Line: +         * @return stream of each output's input stream
>, <Line: +         * @throws IOException thrown when we can't get a list of outputs over the network
>, <Line: +         */
>, <Line: +        public Stream<MantaObjectInputStream> outputAsStreams() throws IOException {
>, <Line: +            return parent.client.getJobOutputsAsStreams(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * <p>Returns a stream of strings containing all of the
>, <Line: +         * output returned from the Manta API for a job. Be careful, this method
>, <Line: +         * is not memory-efficient.</p>
>, <Line: +         *
>, <Line: +         * <p><strong>Make sure to close this stream when you are done with
>, <Line: +         * otherwise the HTTP socket will remain open.</strong></p>
>, <Line: +         * @return stream of each job output as a string
>, <Line: +         * @throws IOException thrown when we can't get a list of outputs over the network
>, <Line: +         */
>, <Line: +        public Stream<String> outputs() throws IOException {
>, <Line: +            return parent.client.getJobOutputsAsStrings(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * <p>Returns a list of failure details for each object in which a failure
>, <Line: +         * occurred.</p>
>, <Line: +         *
>, <Line: +         * <p><strong>Make sure to close this stream when you are done with
>, <Line: +         * otherwise the HTTP socket will remain open.</strong></p>
>, <Line: +         *
>, <Line: +         * @return a stream of job error objects
>, <Line: +         * @throws IOException thrown when we can't get a list of errors over the network
>, <Line: +         */
>, <Line: +        public Stream<MantaJobError> errors() throws IOException {
>, <Line: +            return parent.client.getJobErrors(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Get the current job's state represented as a {@link MantaJob} object.
>, <Line: +         *
>, <Line: +         * @return object containing the job's state
>, <Line: +         * @throws IOException thrown when there is a problem getting the job info over the network
>, <Line: +         */
>, <Line: +        public MantaJob getJob() throws IOException {
>, <Line: +            return parent.client.getJob(id);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Test to see if the job failed.
>, <Line: +         * @return true if any of the inputs failed, otherwise false
>, <Line: +         * @throws IOException thrown if we can't get the status over the network
>, <Line: +         */
>, <Line: +        public boolean failed() throws IOException {
>, <Line: +            final Number errors = getJob().getStats().get("errors");
>, <Line: +            if (errors != null) {
>, <Line: +                return errors.intValue() > 0;
>, <Line: +            } else {
>, <Line: +                throw new MantaClientException("Unable to get error stats");
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Test to see if the job was successful.
>, <Line: +         *
>, <Line: +         * @return true if non of the inputs had errors, otherwise false
>, <Line: +         * @throws IOException thrown if we can't get the status over the network
>, <Line: +         */
>, <Line: +        public boolean successful() throws IOException {
>, <Line: +            return !failed();
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Validate that all of the inputs completed without errors.
>, <Line: +         * If there was an error(s), we compile all of the errors into as
>, <Line: +         * a property on {@link MantaJobException}.
>, <Line: +         *
>, <Line: +         * @return reference to the current Done object
>, <Line: +         * @throws IOException thrown if we have trouble getting status over the network
>, <Line: +         * @throws MantaJobException thrown if there was a failure processing the job
>, <Line: +         */
>, <Line: +        public Done validateJobsSucceeded() throws IOException {
>, <Line: +            if (successful()) {
>, <Line: +                return this;
>, <Line: +            }
>, <Line: +            throw new MantaJobException(id,
>, <Line: +                    errors().collect(Collectors.toList()));
>, <Line: +        }
>, <Line: +    }
>, <Line: +}
>]
[]