[<Line: +import static melnorme.utilbox.core.CoreUtil.areEqual;
>, <Line: +import melnorme.lang.ide.core.text.TextSourceUtils;
>, <Line: +import melnorme.utilbox.misc.StringUtil;
>, <Line: +	public static class Mock_LangAutoEditsPreferencesAccess implements ILangAutoEditsPreferencesAccess {
>, <Line: +	protected void testEnterEdit(String textBeforeCursor, String expectIndent) {
>, <Line: +		testEnterEdit(textBeforeCursor, null, expectIndent);
>, <Line: +	protected void testEnterEdit(String textBeforeCursor, String textAfterCursor, String expectIndent) {
>, <Line: +		int indent = 0;
>, <Line: +		while(indent < 3) {
>, <Line: +			if(textAfterCursor == null) {
>, <Line: +				if(indent == 0) {
>, <Line: +					textAfterCursor = "";
>, <Line: +				}
>, <Line: +				if(indent == 1) {
>, <Line: +					textAfterCursor += NL + ")}" + NEUTRAL_SRC1; // This source after should have no effect
>, <Line: +				}
>, <Line: +				if(indent == 2) {
>, <Line: +					textAfterCursor += "blah)}]"; // This source after should have no effect
>, <Line: +				}
>, <Line: +			}
>, <Line: +			String[] before_Lines = textBeforeCursor.split("\\\\n");
>, <Line: +			String textBeforeCursor_mod = StringUtil.collToString(before_Lines, TABn(indent));
>, <Line: +			testEnterAutoEdit(textBeforeCursor_mod, textAfterCursor, expectIndent);
>, <Line: +			indent++;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	protected void testEnterAutoEdit(String textBefore, String textAfter, String expectedEdit) {
>, <Line: +		int caretOffset = textBefore.length();
>, <Line: +		testAutoEdit(textBefore, textAfter, NL+expectedEdit, caretOffset);
>, <Line: +	protected void testEnterEdit(String textBefore, String textAfter, String expInsert, String expInsertAfter) {
>, <Line: +		expInsert = NL + expInsert;
>, <Line: +		int caretOffset = textBefore.length() + expInsert.length();
>, <Line: +		testAutoEdit(textBefore, textAfter, expInsert+expInsertAfter, caretOffset);
>, <Line: +	protected void testAutoEdit(String textBefore, String textAfter, String expectedInsert, int caretOffset) {
>, <Line: +		testAutoEdit_____(textBefore, "", textAfter, expectedInsert, caretOffset, NL);
>, <Line: +	protected void testAutoEdit_____(String textBefore, String deletedText, String afterCursor, 
>, <Line: +			String expectedInsert, int caretOffset, String insertedText) {
>, <Line: +		String beforeCursor = textBefore + deletedText;
>, <Line: +		Document document = setupDocument(beforeCursor + afterCursor);
>, <Line: +		int keypressOffset = beforeCursor.length();
>, <Line: +		DocumentCommand docCommand = createDocumentCommand(keypressOffset, 0, insertedText);
>, <Line: +		if(docCommand.length == 0 && areEqual(docCommand.text, NL)) {
>, <Line: +			getAutoEditStrategy().lastKeyEvent.character = SWT.CR;
>, <Line: +		}
>, <Line: +		int replaceLength = deletedText.length();
>, <Line: +		if(caretOffset == textBefore.length()) {
>, <Line: +			caretOffset = -1;
>, <Line: +		}
>, <Line: +		checkCommand(docCommand, expectedInsert, textBefore.length(), replaceLength, caretOffset);
>, <Line: +		return setupDocument(textBefore + textAfter);
>, <Line: +	}
>, <Line: +	protected Document setupDocument(String contents) {
>, <Line: +		document.set(contents);
>, <Line: +	protected static String TABn(int indent) {
>, <Line: +		return TextSourceUtils.stringNTimes(TAB, indent);
>, <Line: +	}
>, <Line: +	protected static String expectInd(String indent) {
>, <Line: +		return indent;
>, <Line: +	}
>, <Line: +	protected static String expectInd(String nl, int indent) {
>, <Line: +		return nl+TABn(indent);
>, <Line: +	}
>, <Line: +	protected static String expectClose(int indent, String close) {
>, <Line: +		return NL+TABn(indent-1)+close;
>, <Line: +	}
>, <Line: +		testEnterEdit("void main(){}", "blah", ""); // balance 0 : 0
>, <Line: +		testEnterEdit("void main(){", NL+"}", TAB); // balance 0 : 1 (closed)
>, <Line: +		testEnterEdit("void main(){", "}", "");
>, <Line: +		String dNL = getDocument().getDefaultLineDelimiter();
>, <Line: +		// balance 0 : 1(unclosed)
>, <Line: +		testEnterEdit("void main{", ""                             , TAB, dNL+"}");
>, <Line: +		testEnterEdit("void main(",      NL+"func(){}"+NL+"blah();", TAB,  NL+")");
>, <Line: +		testEnterEdit("vo() main{", "  "+NL+"func(){}"+NL+"blah();", TAB,  NL+"}");
>, <Line: +		// balance 0 : 1(unclosed but don't close due to pending text)
>, <Line: +		testEnterEdit("void main(){", "func(){}"+NL+"blah();", TAB);
>, <Line: +		s = line("func{")+
>, <Line: +			TAB+"abc}"; // balance -1 : 0
>, <Line: +		testEnterEdit(s, "}"+NEUTRAL_SRC1, "");
>, <Line: +		s = line("func{{")+
>, <Line: +			TAB+"abc}}"; // balance -2 : 0
>, <Line: +		testEnterEdit(s, "}"+NEUTRAL_SRC1, "");
>, <Line: +		s = line(TAB+"func((")+
>, <Line: +			TAB+"abc))"; // balance -2 : 0	 '('
>, <Line: +		testEnterEdit(s, NEUTRAL_SRC1+")", TAB);
>, <Line: +		testEnterEdit("func("+NL + "\tblah", 
>, <Line: +			"\t");
>, <Line: +		/* ----------------- some boundary cases ----------------- */
>, <Line: +		testEnterEdit("", "", TABn(0));
>, <Line: +		testEnterEdit("", "}", TABn(0));
>, <Line: +		testEnterEdit("{", "", TABn(1), document.getDefaultLineDelimiter()+"}");
>, <Line: +		// test potential close
>, <Line: +		testEnterEdit("(", 
>, <Line: +			NL +")", TABn(1));
>, <Line: +		// test potential close
>, <Line: +		testEnterEdit("}(", 
>, <Line: +			NL +")", TABn(1));
>, <Line: +		// test potential close
>, <Line: +		testEnterEdit("{"+NL+"(", 
>, <Line: +			NL +")", TABn(1));
>, <Line: +		// test empty line   
>, <Line: +		testEnterEdit(line("func{")+"", "){"+NL+")", 
>, <Line: +			TABn(1));
>, <Line: +		/* -----------------  ----------------- */
>, <Line: +		testEnterEdit(
>, <Line: +			line("func(") + "abc{", 
>, <Line: +			NL+"}", TABn(1)); // test 0 : 1
>, <Line: +		testEnterEdit(
>, <Line: +			line("func{") + "}abc{", 
>, <Line: +			PENDING_WS1+NL+"}", TABn(1)); // test -1 : 1
>, <Line: +		testEnterEdit(
>, <Line: +			line("func{") + "\t\t ", // test all WhiteSpace 
>, <Line: +			PENDING_WS2+NL +")", "\t\t ");
>, <Line: +		// test another -1 : 1   
>, <Line: +		testEnterEdit(
>, <Line: +			line("func{")+ "}blah(", 
>, <Line: +			NL +")", TABn(1));
>, <Line: +		// Test deindentation due to postfix
>, <Line: +		testEnterEdit(
>, <Line: +			line("func{")+ "\tblah(", 
>, <Line: +			")", "\t");
>, <Line: +		// Test deindentation due to postfix - multiple
>, <Line: +		testEnterEdit(line("{ {func("), 
>, <Line: +			")}"+NL+"}", TABn(1));
>, <Line: +		testEnterEdit(line("{ {func("), 
>, <Line: +			")}"+NL    , TABn(1));
>, <Line: +		s = line("func({")+
>, <Line: +			"abc(";     // test potential close (go outside dominating block?)
>, <Line: +		testEnterEdit(s, 
>, <Line: +			NL+")"+ NEUTRAL_SRC1+"}", TABn(1));
>, <Line: +		s = line("func{")+
>, <Line: +			"abc(";     // test potential close (unclosed dominating block)
>, <Line: +		testEnterEdit(s, 
>, <Line: +			NL+")", TABn(1));
>, <Line: +		s = line("func{")+
>, <Line: +			"abc(";     // test potential close (pending text)
>, <Line: +		testEnterEdit(s, 
>, <Line: +			PENDING_TXT+NL+")", TABn(1));
>, <Line: +		s = line("func{")+
>, <Line: +			"}blah(";   // test close, -1 : 1, right=(_
>, <Line: +		testEnterEdit(s, 
>, <Line: +			"", TABn(1), expectClose(0+1, ")"));
>, <Line: +		s = line("func{")+
>, <Line: +			"}blah{{";  // test close, -1 : 2, right={{_
>, <Line: +		testEnterEdit(s, 
>, <Line: +			PENDING_WS2+NL, TABn(0+2), expectClose(0+2, "}"));
>, <Line: +		s = line("func{")+
>, <Line: +			"}}blah{";  // test close, -2 : 1, right={_..
>, <Line: +		testEnterEdit(s, 
>, <Line: +			NL+NEUTRAL_SRC1, TABn(1), expectClose(0+1, "}"));
>, <Line: +		s = line("func{")+
>, <Line: +			"}}blah{{"; // test close, -2 : 1, right= {{_..}     
>, <Line: +		testEnterEdit(s, 
>, <Line: +			NL+NEUTRAL_SRC1+"}", TABn(0+2), expectClose(0+2, "}"));
>, <Line: +		s = line("}}blah{")+
>, <Line: +			line("{func{")+
>, <Line: +			line(TABn(2) + NEUTRAL_SRC1)+
>, <Line: +			"}blah{"; // test close, -2 : 1, right=}} {{..}{_..}     
>, <Line: +		testEnterEdit(s, 
>, <Line: +			NL+NEUTRAL_SRC1+line("}"), TABn(1), expectClose(0+1, "}"));
>, <Line: +		s = line("func{{{")+
>, <Line: +			TAB+"abc}}}"; // test -3 : 0
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(0));
>, <Line: +		s = line(TABn(7) + "func({{{")+  // start block still has : 2 open block
>, <Line: +			TAB+"abc}}"; // test -2 : 0
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(0+7+2));
>, <Line: +		s = line("func")+
>, <Line: +			TAB+"abc}}}"; // test -3 : 0 with zero indent
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(0));
>, <Line: +		s = line("func")+
>, <Line: +			"abc}}}";     // test -3 : 0 with zero indent
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(0));
>, <Line: +		s = line("func{{{")+
>, <Line: +			line(TABn(4) + "func{()}")+ // test interim lines with irregular ident
>, <Line: +			TAB+"abc}}";  // -2 : 0
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(1)); 
>, <Line: +		s = line(TABn(2) +NEUTRAL_SRC1)+ // more lines
>, <Line: +			line(TABn(2) +"}}func{{{")+  // matching start block is -2 : 3
>, <Line: +			line(TABn(2) +NEUTRAL_SRC1)+ // more lines
>, <Line: +			line(TABn(2-2) + "func{()}")+ // interim lines with irregular ident (negative)
>, <Line: +			TABn(2) + TAB+"abc(blah{}) blah}}"; // -2 : 0
>, <Line: +		testEnterEdit(s, 
>, <Line: +			TABn(2+1));
>, <Line: +		testSmartIndent_withPartitioning$();
>, <Line: +	}
>, <Line: +	public void testSmartIndent_withPartitioning$() throws Exception {
>, <Line: +		assertContains(getDocument().getPartitionings(), SamplePartitionScanner.LANG_PARTITIONING);
>, <Line: +		final int indent = 1; // Needs to be greater than 1
>, <Line: +		String s;
>, <Line: +		s = line(TABn(indent) + "func()")+
>, <Line: +			"//"+TAB+"abc"; // test with line comment
>, <Line: +		testEnterEdit(s, NL +"})"+ NEUTRAL_SRC1, TABn(indent));
>, <Line: +		s = line(TABn(indent) + "func(")+
>, <Line: +			"//"+TAB+"abc)"; // test with line comment, with +1 indent
>, <Line: +		testEnterEdit(s, NL +")"+ NEUTRAL_SRC1, TABn(indent+1));
>, <Line: +		s = line(TABn(indent) + "func{")+
>, <Line: +			line(TABn(indent+1) + "blah}")+
>, <Line: +			"//"+TAB+"abc)"; // test with line comment, with -1 indent
>, <Line: +		testEnterEdit(s, NL +")"+ NEUTRAL_SRC1, TABn(indent));
>, <Line: +		s = line(TABn(indent) + "{func(")+
>, <Line: +			"//"+TAB+"abc"; // test with line comment, characters after
>, <Line: +		testEnterEdit(s, ")"+NL+ NEUTRAL_SRC1, TABn(indent+2));
>, <Line: +		s = line(TABn(indent) + "func({")+
>, <Line: +			"/**/"; 			// test with block comment, with +2 indent Close
>, <Line: +		testEnterEdit(s, NL +"blah"+ NEUTRAL_SRC1, TABn(indent+2), expectClose(indent+2, "}"));
>, <Line: +		s = line(TABn(indent) + "func(((")+
>, <Line: +			TABn(indent) + "// blah"; 		// test line comment with whitespace before, (This-Line)
>, <Line: +		testEnterEdit(s, NL +"}}}"+ NEUTRAL_SRC1, TABn(indent));
>, <Line: +		s = line(TABn(indent) + "func(((")+
>, <Line: +			TABn(indent) + "/**/"; 		// test block comment with whitespace before, (This-Line)
>, <Line: +		testEnterEdit(s, NL +"}}}"+ NEUTRAL_SRC1, TABn(indent));
>, <Line: +		s = line(TABn(indent) + "func(")+
>, <Line: +			"/* */"+TAB+"abc{{{"; // test block comment with characters after, (This-Line)
>, <Line: +		testEnterEdit(s, NL +"}}})"+ NEUTRAL_SRC1, TABn(0+3));
>, <Line: +		s = "//abc{"; 		// test line comment, no valid line before
>, <Line: +		testEnterEdit(s, NL +"})"+ NEUTRAL_SRC1, TABn(0));
>, <Line: +		s = "/*abc{*/"; 		// test block comment, no valid line before
>, <Line: +		testEnterEdit(s, NL +"})"+ NEUTRAL_SRC1, TABn(0));
>, <Line: +		s = line(TABn(indent) + "func((()))")+
>, <Line: +			"/**/"; 		// test block comment at EOF 
>, <Line: +		testEnterEdit(s, "", TABn(indent));
>, <Line: +		/* ------- These cases are tricky, might change in the future */
>, <Line: +		s = line(TABn(indent) + "{func(")+
>, <Line: +			"// foobar"; // test line comment, characters after that afect block balance
>, <Line: +		testEnterEdit(s, ")}"+NL+ NEUTRAL_SRC1, TABn(indent+2));
>, <Line: +		s = line(TABn(indent) + "{func(")+
>, <Line: +			"// foobar{"; // test line comment, characters after that afect block balance
>, <Line: +		testEnterEdit(s, ")"+NL+ NEUTRAL_SRC1, TABn(indent+2));
>, <Line: +		s = line(TABn(indent) + "(func{")+
>, <Line: +			TABn(indent) + "/* foobar"; // test edit inside block comment
>, <Line: +		testEnterEdit(s, NL+"})*/})"+ NEUTRAL_SRC1, TABn(indent));
>, <Line: +		s = line(TABn(indent) + "{func(")+
>, <Line: +			"/* foobar"; 		   // test edit inside block comment
>, <Line: +		testEnterEdit(s, NL+ ")}*/"+ NEUTRAL_SRC1, TABn(indent+2), expectClose(indent+2, ")"));
>, <Line: +		s = line(TABn(indent) + "{func}")+
>, <Line: +			TABn(indent) + "{func{/* foobar}"; // test edit inside block comment
>, <Line: +		testEnterEdit(s, NL+"}}*/}"+ NEUTRAL_SRC1, TABn(indent+2), expectClose(indent+2, "}"));
>, <Line: +	}
>, <Line: +		s = line("func")+
>, <Line: +			"abc{"; // test 0 : 1 (with syntax error)
>, <Line: +		testEnterEdit(s, NL +"})"+ NEUTRAL_SRC1, TABn(1));
>, <Line: +		s = line("func{")+
>, <Line: +			TAB+"{ab(c}"; // test 0 : 0 (corrected)
>, <Line: +		testEnterEdit(s, PENDING_WS1+NL+"}"+ NEUTRAL_SRCX, TABn(1+0));
>, <Line: +		s = line("func{")+
>, <Line: +			TAB+"{ab)c}"; // test 0 : 0 (corrected)
>, <Line: +		testEnterEdit(s, NL +"}"+ NEUTRAL_SRC3, TABn(1+0));
>, <Line: +		s = line("func{")+
>, <Line: +			TAB+"(ab{c)"; // test 0 : 2 (corrected)
>, <Line: +		testEnterEdit(s, NL +"}"+NEUTRAL_SRC1+"}", TABn(1+0+2));
>, <Line: +		s = line("func{")+
>, <Line: +			TAB+"(ab}c)"; // test -1 : 0 (corrected)
>, <Line: +		testEnterEdit(s, PENDING_WS2+NL +"}"+ NEUTRAL_SRCX, TABn(0));
>, <Line: +		s = line("func{")+
>, <Line: +			"}blah{)"; // test -1 : 1 (corrected)
>, <Line: +		testEnterEdit(s, NL +"}"+ NEUTRAL_SRC3, TABn(1));
>, <Line: +		s = line("func{")+
>, <Line: +			"}blah{)"; // test -1 : 1 with close, right={)_..   
>, <Line: +		testEnterEdit(s, NL+/*}*/ NEUTRAL_SRC1, TABn(1), expectClose(0+1, "}"));
>, <Line: +		s = line("func{")+
>, <Line: +			"}blah{)"; // test -1 : 1 with close, right={)_({..(}
>, <Line: +		testEnterEdit(s, NL+/*}*/ "({"+NEUTRAL_SRC1+"(}", TABn(1), expectClose(0+1, "}"));
>, <Line: +		s = line("func{")+
>, <Line: +			line(TABn(0+4) + "func{()}")+ // test interim lines with irregular ident
>, <Line: +			TABn(1) + "}blah("; // test close, -1 : 1, right=(_..} 
>, <Line: +		testEnterEdit(s, PENDING_WS2+NL+NEUTRAL_SRC1+"}", TABn(2), expectClose(0+2, ")"));
>, <Line: +		s = line("func{{){")+    // (corrected)
>, <Line: +			TAB+"abc}}(}"; // test -3 : 0 (corrected)
>, <Line: +		testEnterEdit(s, PENDING_TXT+NL+NEUTRAL_SRCX, TABn(0));
>, <Line: +		s = line("func{({")+    // (corrected on EOF)
>, <Line: +			TAB+"aaa}})"; // test -3 : 0
>, <Line: +		testEnterEdit(s, NL+NEUTRAL_SRC3, TABn(0));
>, <Line: +		s = line("func(")+    // decoy
>, <Line: +			line(TABn(0+7) + "{func{")+ // (corrected on '{' superblock )
>, <Line: +			"aaa})";    
>, <Line: +		testEnterEdit(s, NL+NEUTRAL_SRC1, TABn(0+7+1));
>, <Line: +		s = line("func}");
>, <Line: +		testEnterEdit(s, ""+ NEUTRAL_SRC1, TABn(0));
>, <Line: +		s = line(TABn(2) + "func}");
>, <Line: +		testEnterEdit(s, ""+ NEUTRAL_SRC1, TABn(0));
>, <Line: +		s = "void main() {";
>, <Line: +			TABn(indent) + "void main{} (";
>, <Line: +			TABn(indent) + "void main{({";
>, <Line: +			TABn(indent) + "void main{({"; // Less indent than expected
>, <Line: +		s = line("")+
>, <Line: +			TABn(indent) + "\t\t";  // Test all Whitespace
>, <Line: +			"";  // Test empty line
>, <Line: +			line(TABn(indent) + "void func{({")+
>, <Line: +			TABn(indent+1) + "void main()"; // test with 0 : 0 balance
>, <Line: +			TABn(indent) + "void main{{)(";
>, <Line: +		s = "void main() }";
>, <Line: +	/* -----------------  ----------------- */
>, <Line: +	@Test
>, <Line: +	public void testDeindent_onBraceKeypres() throws Exception { testDeindent_onBraceKeypres$(); }
>, <Line: +	public void testDeindent_onBraceKeypres$() throws Exception {
>, <Line: +		// No-op case
>, <Line: +		testAutoEdit_____(line("func() {" + TABn(1)), "", "---", ">", -1, ">");
>, <Line: +		// A basic case
>, <Line: +		testBraceKeyPress(
>, <Line: +			line("func() {"), 
>, <Line: +			TABn(1),
>, <Line: +			"}");
>, <Line: +		// Test no deletion happens if beforeCursor is not indent
>, <Line: +		testBraceKeyPress(
>, <Line: +			line("func() {") + "\tfoo", 
>, <Line: +			"",
>, <Line: +			"}");
>, <Line: +		// Test that ident of block start is used
>, <Line: +		testBraceKeyPress(
>, <Line: +			line(TABn(4) + "func{} {"), 
>, <Line: +			TABn(1),
>, <Line: +			TABn(4) + "}");
>, <Line: +	}
>, <Line: +	protected void testBraceKeyPress(String textBefore, String deletedText, String expectedInsert) {
>, <Line: +		testAutoEdit_____(textBefore, deletedText, "---", expectedInsert, -1, "}");
>, <Line: +	}
>]
[<Line: -import melnorme.lang.ide.core.text.format.LangAutoEditUtils;
>, <Line: -import melnorme.lang.ide.core.text.format.LangAutoEditStrategyExt.ILangAutoEditsPreferencesAccessExt;
>, <Line: -	public static class Mock_LangAutoEditsPreferencesAccess implements ILangAutoEditsPreferencesAccessExt {
>, <Line: -		@Override
>, <Line: -		public boolean closeBlocks() {
>, <Line: -			return true;
>, <Line: -		}
>, <Line: -	@Test
>, <Line: -	public void testSmartIndentBasic() {
>, <Line: -		testEnterAutoEdit("void main(){}", "blah", NL); // balance 0 : 0
>, <Line: -		testEnterAutoEdit("void main(){", NL+"}", NL+TAB); // balance 0 : 1 (closed)
>, <Line: -		testEnterAutoEdit("void main(){", "}",    NL+TAB);
>, <Line: -	}
>, <Line: -	@Test
>, <Line: -	public void testSmartIndentBasic2() {
>, <Line: -		String dNL = getDocument().getDefaultLineDelimiter();
>, <Line: -		// balance 0 : 1(unclosed)
>, <Line: -		testEnterAutoEdit("void main{", ""                             , NL+TAB, dNL+"}");
>, <Line: -		testEnterAutoEdit("void main(",      NL+"func(){}"+NL+"blah();", NL+TAB,  NL+")");
>, <Line: -		testEnterAutoEdit("vo() main{", "  "+NL+"func(){}"+NL+"blah();", NL+TAB,  NL+"}");
>, <Line: -		// balance 0 : 1(unclosed but don't close due to pending text)
>, <Line: -		testEnterAutoEdit("void main(){",       "func(){}"+NL+"blah();", NL+TAB);
>, <Line: -	@Test
>, <Line: -	public void testSmartIndentBasic3() {
>, <Line: -		String s;
>, <Line: -		s = line("func{")+
>, <Line: -			TAB+"abc}"; // balance -1 : 0
>, <Line: -		testEnterAutoEdit(s, "}"+NEUTRAL_SRC1, NL);
>, <Line: -		s = line("func{{")+
>, <Line: -			TAB+"abc}}"; // balance -2 : 0
>, <Line: -		testEnterAutoEdit(s, "}"+NEUTRAL_SRC1, NL);
>, <Line: -		s = line(TAB+"func((")+
>, <Line: -			TAB+"abc))"; // balance -2 : 0	 '('
>, <Line: -		testEnterAutoEdit(s, NEUTRAL_SRC1+")", NL+TAB);
>, <Line: -	protected final void testEnterAutoEdit(String sourceBefore, String sourceAfter, String expectedEdit) {
>, <Line: -		dotestEnterAutoEdit(sourceBefore, sourceAfter, expectedEdit, -1);
>, <Line: -	protected void testEnterAutoEdit(String textBefore, String textAfter, String expInsert, String expInsertAfter) {
>, <Line: -		dotestEnterAutoEdit(textBefore, textAfter, expInsert+expInsertAfter, expInsert.length());
>, <Line: -	protected void dotestEnterAutoEdit(String textBefore, String textAfter, String expectedInsert, int offsetDelta) {
>, <Line: -		Document document = setupDocument(textBefore, textAfter);
>, <Line: -		int keypressOffset = textBefore.length();
>, <Line: -		DocumentCommand docCommand = createDocumentCommand(keypressOffset, 0, NL);
>, <Line: -		int caretOffset = (offsetDelta == -1) ? -1 : textBefore.length() + offsetDelta;
>, <Line: -		int replaceLength = 0;
>, <Line: -		checkCommand(docCommand, expectedInsert, keypressOffset, replaceLength, caretOffset);
>, <Line: -		document.set(textBefore + textAfter);
>, <Line: -		int indent = 0;
>, <Line: -		s = mkline(indent, "func(")+
>, <Line: -			mklast(indent, "abc{"); // test 0 : 1
>, <Line: -		testEnterAutoEdit(s, NL +"})"+ NEUTRAL_SRC1, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}abc{"); // test -1 : 1
>, <Line: -		testEnterAutoEdit(s, PENDING_WS1+NL+"}"+ NEUTRAL_SRC1, expectInd(indent+1));
>, <Line: -		indent = 1;
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "\t\t "); // test all WhiteSpace   
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRCX, expectInd(indent+2)+" ");
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "\t\t "); // test all WhiteSpace with pending WhiteSpace   
>, <Line: -		testEnterAutoEdit(s, PENDING_WS2+NL+")"+ NEUTRAL_SRCX, expectInd(indent+2)+" ");
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah("); // test another -1 : 1   
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRCX, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func({")+
>, <Line: -			mklast(indent, "abc(");     // test potential close (go outside dominating block?)
>, <Line: -		testEnterAutoEdit(s, NL+")"+ NEUTRAL_SRC1+"}", expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "abc(");     // test potential close (unclosed dominating block)
>, <Line: -		testEnterAutoEdit(s, NL+")", expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "abc(");     // test potential close (pending text)
>, <Line: -		testEnterAutoEdit(s, PENDING_TXT+NL+")", expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah(");   // test close, -1 : 1, right=(_
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1, expectInd(indent+1), expectClose(indent+1, ")"));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah{{");  // test close, -1 : 2, right={{_
>, <Line: -		testEnterAutoEdit(s, PENDING_WS2+NL, expectInd(indent+2), expectClose(indent+2, "}"));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}}blah{");  // test close, -2 : 1, right={_..
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1, expectInd(indent+1), expectClose(indent+1, "}"));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}}blah{{"); // test close, -2 : 1, right= {{_..}     
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1+"}", expectInd(indent+2), expectClose(indent+2, "}"));
>, <Line: -		s = mkline(indent, "}}blah{")+
>, <Line: -			mkline(indent, "{func{")+
>, <Line: -			mkline(indent+2, NEUTRAL_SRC1)+
>, <Line: -			mklast(indent, "}blah{"); // test close, -2 : 1, right=}} {{..}{_..}     
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1+mkline(indent, "}"), expectInd(indent+1), expectClose(indent+1, "}"));
>, <Line: -		indent = 0;
>, <Line: -		s = mkline(indent, "func{{{")+
>, <Line: -			mklast(indent, TAB+"abc}}}"); // test -3 : 0
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRCX, expectInd(indent+0));
>, <Line: -		s = mkline(indent+7, "func({{{")+  // start block still has : 2 open block
>, <Line: -			mklast(indent  , TAB+"abc}}"); // test -2 : 0
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRCX, expectInd(indent+7+2));
>, <Line: -		indent = 0;
>, <Line: -		s = mkline(indent, "func")+
>, <Line: -			mklast(indent, TAB+"abc}}}"); // test -3 : 0 with zero indent
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRCX, expectInd(indent+0));
>, <Line: -		s = mkline(indent, "func")+
>, <Line: -			mklast(indent, "abc}}}");     // test -3 : 0 with zero indent
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRCX, expectInd(indent+0));
>, <Line: -		s = mkline(indent, "func{{{")+
>, <Line: -			mkline(indent+4, "func{()}")+ // test interim lines with irregular ident
>, <Line: -			mklast(indent, TAB+"abc}}");  // -2 : 0
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1, expectInd(indent+1)); 
>, <Line: -		indent = 2;
>, <Line: -		s = mkline(indent, NEUTRAL_SRC1)+ // more lines
>, <Line: -			mkline(indent, "}}func{{{")+  // matching start block is -2 : 3
>, <Line: -			mkline(indent, NEUTRAL_SRC1)+ // more lines
>, <Line: -			mkline(indent-2, "func{()}")+ // interim lines with irregular ident (negative)
>, <Line: -			mklast(indent, TAB+"abc(blah{}) blah}}"); // -2 : 0
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRCX, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(0, ""); // test empty line   
>, <Line: -		testEnterAutoEdit(s, "){"+NL+")", expectInd(0));
>, <Line: -	}
>, <Line: -	@Test
>, <Line: -	public void testSmartIdent_Boundary() throws Exception { testSmartIdent_Boundary$(); }
>, <Line: -	public void testSmartIdent_Boundary$() throws Exception {
>, <Line: -		String s;
>, <Line: -		s = "(";     // test potential close
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRC1+"}", expectInd(1));
>, <Line: -		s = "}(";     // test potential close
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRC1+"}", expectInd(1));
>, <Line: -		s = "{"+NL+"(";     // test potential close
>, <Line: -		testEnterAutoEdit(s, NL +"){", expectInd(1));
>, <Line: -	}
>, <Line: -	@Test
>, <Line: -	public void testSmartIndent_xPartitioning() throws Exception { testSmartIndent_xPartitioning$(); }
>, <Line: -	public void testSmartIndent_xPartitioning$() throws Exception {
>, <Line: -		assertContains(getDocument().getPartitionings(), SamplePartitionScanner.LANG_PARTITIONING);
>, <Line: -		int indent = 1; // Needs to be greater than 1
>, <Line: -		String s;
>, <Line: -		s = mkline(indent, "func()")+
>, <Line: -			mklast(0, "//"+TAB+"abc"); // test with line comment
>, <Line: -		testEnterAutoEdit(s, NL +"})"+ NEUTRAL_SRC1, expectInd(indent));
>, <Line: -		s = mkline(indent, "func(")+
>, <Line: -			mklast(0, "//"+TAB+"abc)"); // test with line comment, with +1 indent
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRC1, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mkline(indent+1, "blah}")+
>, <Line: -			mklast(0, "//"+TAB+"abc)"); // test with line comment, with -1 indent
>, <Line: -		testEnterAutoEdit(s, NL +")"+ NEUTRAL_SRC1, expectInd(indent));
>, <Line: -		s = mkline(indent, "{func(")+
>, <Line: -			mklast(0, "//"+TAB+"abc"); // test with line comment, characters after
>, <Line: -		testEnterAutoEdit(s, ")"+NL+ NEUTRAL_SRC1, expectInd(indent+2));
>, <Line: -		s = mkline(indent, "func({")+
>, <Line: -			mklast(0, "/**/"); 			// test with block comment, with +2 indent Close
>, <Line: -		testEnterAutoEdit(s, NL +"blah"+ NEUTRAL_SRC1, expectInd(indent+2), expectClose(indent+2, "}"));
>, <Line: -		s = mkline(indent, "func(((")+
>, <Line: -			mklast(indent, "// blah"); 		// test line comment with whitespace before, (This-Line)
>, <Line: -		testEnterAutoEdit(s, NL +"}}}"+ NEUTRAL_SRC1, expectInd(indent));
>, <Line: -		s = mkline(indent, "func(((")+
>, <Line: -			mklast(indent, "/**/"); 		// test block comment with whitespace before, (This-Line)
>, <Line: -		testEnterAutoEdit(s, NL +"}}}"+ NEUTRAL_SRC1, expectInd(indent));
>, <Line: -		s = mkline(indent, "func(")+
>, <Line: -			mklast(0     , "/* */"+TAB+"abc{{{"); // test block comment with characters after, (This-Line)
>, <Line: -		testEnterAutoEdit(s, NL +"}}})"+ NEUTRAL_SRC1, expectInd(0+3));
>, <Line: -		s = mklast(0, "//abc{"); 		// test line comment, no valid line before
>, <Line: -		testEnterAutoEdit(s, NL +"})"+ NEUTRAL_SRC1, expectInd(0));
>, <Line: -		s = mklast(0, "/*abc{*/"); 		// test block comment, no valid line before
>, <Line: -		testEnterAutoEdit(s, NL +"})"+ NEUTRAL_SRC1, expectInd(0));
>, <Line: -		s = mkline(indent, "func((()))")+
>, <Line: -			mklast(0, "/**/"); 		// test block comment at EOF 
>, <Line: -		testEnterAutoEdit(s, "", expectInd(indent));
>, <Line: -		/* ------- */
>, <Line: -		// we don't consider the after-edit text in the edit-line for block balance in any case
>, <Line: -		// if this changes, we need to review these two test cases
>, <Line: -		s = mkline(indent, "{func(")+
>, <Line: -			mklast(0, "// foobar"); // test line comment, characters after that afect block balance
>, <Line: -		testEnterAutoEdit(s, "afterEdit)}"+NL+ NEUTRAL_SRC1, expectInd(indent+2)/*, expectClose(indent+2, ")")*/);
>, <Line: -		s = mkline(indent, "{func(")+
>, <Line: -			mklast(0, "// foobar{"); // test line comment, characters after that afect block balance
>, <Line: -		testEnterAutoEdit(s, "afterEdit)"+NL+ NEUTRAL_SRC1, expectInd(indent+2)/*, expectClose(indent+2, ")")*/);
>, <Line: -		s = mkline(indent, "(func{")+
>, <Line: -			mklast(indent, "/* foobar"); // test edit inside block comment
>, <Line: -		testEnterAutoEdit(s, NL+"})*/})"+ NEUTRAL_SRC1, expectInd(indent));
>, <Line: -		s = mkline(indent, "{func(")+
>, <Line: -			mklast(0, "/* foobar"); 		   // test edit inside block comment
>, <Line: -		testEnterAutoEdit(s, NL+ ")}*/"+ NEUTRAL_SRC1, expectInd(indent+2), expectClose(indent+2, ")"));
>, <Line: -		s = mkline(indent, "{func}")+
>, <Line: -			mklast(indent, "{func{/* foobar}"); // test edit inside block comment
>, <Line: -		testEnterAutoEdit(s, NL+"}}*/}"+ NEUTRAL_SRC1, expectInd(indent+2), expectClose(indent+2, "}"));
>, <Line: -	}
>, <Line: -	protected String mkline(int indent, String string) {
>, <Line: -		return line(TABn(indent) + string);
>, <Line: -	}
>, <Line: -	protected String mklast(int indent, String string) {
>, <Line: -		return TABn(indent) + string;
>, <Line: -	}
>, <Line: -	protected static String TABn(int indent) {
>, <Line: -		return LangAutoEditUtils.stringNTimes(TAB, indent);
>, <Line: -	}
>, <Line: -	protected static String expectInd(int indent) {
>, <Line: -		return expectInd(NL, indent);
>, <Line: -	}
>, <Line: -	private static String expectInd(String nl, int indent) {
>, <Line: -		return nl+TABn(indent);
>, <Line: -	}
>, <Line: -	protected static String expectClose(int indent, String close) {
>, <Line: -		return NL+TABn(indent-1)+close;
>, <Line: -	}
>, <Line: -		int indent = 0;
>, <Line: -		s = mkline(indent, "func")+
>, <Line: -			mklast(indent, "abc{"); // test 0 : 1 (with syntax error)
>, <Line: -		testEnterAutoEdit(s, NL +"})"+ NEUTRAL_SRC1, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, TAB+"{ab(c}"); // test 0 : 0 (corrected)
>, <Line: -		testEnterAutoEdit(s, PENDING_WS1+NL+"}"+ NEUTRAL_SRCX, expectInd(1+indent));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, TAB+"{ab)c}"); // test 0 : 0 (corrected)
>, <Line: -		testEnterAutoEdit(s, NL +"}"+ NEUTRAL_SRC3, expectInd(1+indent));
>, <Line: -		indent = 1;
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, TAB+"(ab{c)"); // test 0 : 2 (corrected)
>, <Line: -		testEnterAutoEdit(s, NL +"}"+NEUTRAL_SRC1+"}", expectInd(1+indent+2));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, TAB+"(ab}c)"); // test -1 : 0 (corrected)
>, <Line: -		testEnterAutoEdit(s, PENDING_WS2+NL +"}"+ NEUTRAL_SRCX, expectInd(indent));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah{)"); // test -1 : 1 (corrected)
>, <Line: -		testEnterAutoEdit(s, NL +"}"+ NEUTRAL_SRC3, expectInd(indent+1));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah{)"); // test -1 : 1 with close, right={)_..   
>, <Line: -		testEnterAutoEdit(s, NL+/*}*/ NEUTRAL_SRC1, expectInd(indent+1), expectClose(indent+1, "}"));
>, <Line: -		s = mkline(indent, "func{")+
>, <Line: -			mklast(indent, "}blah{)"); // test -1 : 1 with close, right={)_({..(}
>, <Line: -		testEnterAutoEdit(s, NL+/*}*/ "({"+NEUTRAL_SRC1+"(}", expectInd(indent+1), expectClose(indent+1, "}"));
>, <Line: -		s = mkline(indent  , "func{")+
>, <Line: -			mkline(indent+4, "func{()}")+ // test interim lines with irregular ident
>, <Line: -			mklast(indent+1, "}blah("); // test close, -1 : 1, right=(_..} 
>, <Line: -		testEnterAutoEdit(s, PENDING_WS2+NL+NEUTRAL_SRC1+"}", expectInd(indent+2), expectClose(indent+2, ")"));
>, <Line: -		s = mkline(indent, "func{{){")+    // (corrected)
>, <Line: -			mklast(indent, TAB+"abc}}(}"); // test -3 : 0 (corrected)
>, <Line: -		testEnterAutoEdit(s, PENDING_TXT+NL+NEUTRAL_SRCX, expectInd(indent+0));
>, <Line: -		s = mkline(indent, "func{({")+    // (corrected on EOF)
>, <Line: -			mklast(indent, TAB+"aaa}})"); // test -3 : 0
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC3, expectInd(indent+0));
>, <Line: -		s = mkline(indent, "func(")+    // decoy
>, <Line: -			mkline(indent+7, "{func{")+ // (corrected on '{' superblock )
>, <Line: -			mklast(indent, "aaa})");    
>, <Line: -		testEnterAutoEdit(s, NL+NEUTRAL_SRC1, expectInd(indent+7+1));
>, <Line: -		s = mkline(0, "func}");
>, <Line: -		testEnterAutoEdit(s, ""+ NEUTRAL_SRC1, expectInd(0));
>, <Line: -		s = mkline(2, "func}");
>, <Line: -		testEnterAutoEdit(s, ""+ NEUTRAL_SRC1, expectInd(0));
>, <Line: -		s = mklast(0, "void main() {");
>, <Line: -			mklast(indent, "void main{} (");
>, <Line: -			mklast(indent, "void main{({");
>, <Line: -			mklast(indent, "void main{({"); // Less indent than expected
>, <Line: -		s = mkline(0, "")+
>, <Line: -			mklast(indent, "\t\t");  // Test all Whitespace
>, <Line: -			mklast(0, "");  // Test empty line
>, <Line: -			mkline(indent+0, "void func{({")+
>, <Line: -			mklast(indent+1, "void main()"); // test with 0 : 0 balance
>, <Line: -			mklast(indent, "void main{{)(");
>, <Line: -		s = mklast(0, "void main() }");
>]