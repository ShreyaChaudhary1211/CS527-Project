[<Line: +import org.eclipse.core.runtime.IStatus;
>, <Line: +import org.eclipse.core.runtime.Status;
>, <Line: +import org.eclipse.core.runtime.jobs.Job;
>, <Line: +import org.eclipse.swt.widgets.Display;
>, <Line: +	public boolean runInAsynchronousJob = false;
>, <Line: +	public AbstractUIOperation(String operationName, boolean runInAsynchronousJob) {
>, <Line: +		super(operationName);
>, <Line: +		this.runInAsynchronousJob = runInAsynchronousJob;
>, <Line: +	}
>, <Line: +	public void executeAndHandleAsynchronouslyInJob() {
>, <Line: +		runInAsynchronousJob = true;
>, <Line: +		super.executeAndHandle();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Run this UI operation. There are two phases/tasks to it:
>, <Line: +	 * The first one is some work being done in a background thread - {@link #doBackgroundComputation(IProgressMonitor)}.
>, <Line: +	 * The second one, {@link #handleComputationResult()} is executed after the background works completes, 
>, <Line: +	 * and always runs in the UI thread.
>, <Line: +	 */
>, <Line: +		if(!isBackgroundComputationNecessary()) {
>, <Line: +			// No need for background computation
>, <Line: +			handleComputationResult();
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		runInBackgroundExecutor();
>, <Line: +	protected boolean isBackgroundComputationNecessary() throws CoreException, CommonException, OperationCancellation {
>, <Line: +		return true;
>, <Line: +	protected void runInBackgroundExecutor() throws CoreException, CommonException, OperationCancellation {
>, <Line: +		if(runInAsynchronousJob) {
>, <Line: +			runAsynchronouslyInBackgroundJob();
>, <Line: +		} else {
>, <Line: +			runInProgressServiceExecutor();
>, <Line: +		}
>, <Line: +	protected void runInProgressServiceExecutor() throws CoreException, CommonException, OperationCancellation {
>, <Line: +		new ProgressServiceExecutor(this::runBackgroundComputation).execute();
>, <Line: +		handleComputationResult();
>, <Line: +	}
>, <Line: +	protected void runBackgroundComputation(IProgressMonitor monitor) 
>, <Line: +	/* -----------------  ----------------- */
>, <Line: +	protected void runAsynchronouslyInBackgroundJob() {
>, <Line: +		Display display = Display.getCurrent();
>, <Line: +		new Job(getOperationName()) {
>, <Line: +			@Override
>, <Line: +			protected IStatus run(IProgressMonitor monitor) {
>, <Line: +				try {
>, <Line: +					runBackgroundComputation(monitor);
>, <Line: +					display.asyncExec(() -> handleComputationResult_handled());
>, <Line: +				} catch(CoreException ce) {
>, <Line: +					display.asyncExec(() -> handleError(ce));
>, <Line: +				} catch(CommonException ce) {
>, <Line: +					display.asyncExec(() -> handleError(ce));
>, <Line: +				} catch(OperationCancellation e) {
>, <Line: +					return Status.CANCEL_STATUS;
>, <Line: +				}
>, <Line: +				return Status.OK_STATUS;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		.schedule();
>, <Line: +	}
>, <Line: +	protected void handleComputationResult_handled()  {
>, <Line: +		try {
>, <Line: +			handleComputationResult();
>, <Line: +		} catch(CoreException ce) {
>, <Line: +			handleError(ce);
>, <Line: +		} catch(CommonException ce) {
>, <Line: +			handleError(ce);
>, <Line: +		} catch(OperationCancellation e) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +	}
>]
[<Line: -	protected ProgressServiceExecutor opExecutor = new ProgressServiceExecutor(this::doBackgroundComputation_prepare);
>, <Line: -		performBackgroundComputation();
>, <Line: -		handleComputationResult();
>, <Line: -	protected void performBackgroundComputation() throws CoreException, CommonException, OperationCancellation {
>, <Line: -		performBackgroundComputation(opExecutor);
>, <Line: -	protected void performBackgroundComputation(ProgressServiceExecutor opExecutor)
>, <Line: -			throws CoreException, CommonException, OperationCancellation {
>, <Line: -		opExecutor.execute();
>, <Line: -	protected void doBackgroundComputation_prepare(IProgressMonitor monitor) 
>]