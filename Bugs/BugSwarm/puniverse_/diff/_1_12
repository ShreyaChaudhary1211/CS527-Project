[<Line: +/*
>, <Line: + * This is an example implementation made for the sake fo the Reactive Streams project
>, <Line: + */
>, <Line: +package co.paralleluniverse.strands.channels.reactivestreams;
>, <Line: +import org.reactivestreams.Publisher;
>, <Line: +import org.reactivestreams.Subscriber;
>, <Line: +import org.reactivestreams.Subscription;
>, <Line: +/**
>, <Line: + * Implementors must override {@code newSubscription} + {@code ThreadlessSubscription.supply(Subscriber, long)}.
>, <Line: + */
>, <Line: +public abstract class ThreadlessPublisher<T> implements Publisher<T> {
>, <Line: +    @Override
>, <Line: +    public void subscribe(Subscriber<? super T> s) {
>, <Line: +        newSubscription(s).start();
>, <Line: +    }
>, <Line: +    protected abstract ThreadlessSubscription newSubscription(Subscriber<? super T> s);
>, <Line: +    protected abstract class ThreadlessSubscription implements Subscription {
>, <Line: +        private final Subscriber<? super T> sr;
>, <Line: +        private boolean recursive; // @akarnokd: not really required
>, <Line: +        private long pending;
>, <Line: +        private boolean done;
>, <Line: +        public ThreadlessSubscription(Subscriber<? super T> subscriber) {
>, <Line: +            this.sr = new WrappedSubscriber<>(subscriber);
>, <Line: +        }
>, <Line: +        private void start() {
>, <Line: +            sr.onSubscribe(this);
>, <Line: +            supply();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public final void request(long n) {
>, <Line: +            if (n <= 0) {
>, <Line: +                sr.onError(new IllegalArgumentException("Requested number must be positive but was " + n + " (rule 3.9)"));
>, <Line: +                return;
>, <Line: +            }
>, <Line: +            // boolean recursive = pending == 0; // @akarnokd: if (pending == n)
>, <Line: +            pending += n;
>, <Line: +            if (pending < 0)
>, <Line: +                pending = Long.MAX_VALUE;
>, <Line: +            if (!recursive)
>, <Line: +                supply();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public void cancel() {
>, <Line: +            done = true;
>, <Line: +        }
>, <Line: +        private void supply() {
>, <Line: +            while (!done & pending > 0)
>, <Line: +                pending -= supply(sr, pending);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Needs to supply up to n elements by calling {@code onNext}.
>, <Line: +         * May freely call {@code onComplete} or {@code onError} as appropriate.
>, <Line: +         *
>, <Line: +         * @return the number of elements actually supplied
>, <Line: +         */
>, <Line: +        protected abstract long supply(Subscriber<? super T> subscriber, long n);
>, <Line: +        private class WrappedSubscriber<R> implements Subscriber<R> {
>, <Line: +            private final Subscriber<R> sr;
>, <Line: +            public WrappedSubscriber(Subscriber<R> sr) {
>, <Line: +                this.sr = sr;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void onSubscribe(Subscription s) {
>, <Line: +                recursive = true;
>, <Line: +                sr.onSubscribe(s);
>, <Line: +                recursive = false;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void onNext(R element) {
>, <Line: +                recursive = true;
>, <Line: +                if (!done)
>, <Line: +                    sr.onNext(element);
>, <Line: +                recursive = false;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void onError(Throwable t) {
>, <Line: +                if (!done) {
>, <Line: +                    done = true;
>, <Line: +                    sr.onError(t);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void onComplete() {
>, <Line: +                if (!done) {
>, <Line: +                    done = true;
>, <Line: +                    sr.onComplete();
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +}
>]
[]