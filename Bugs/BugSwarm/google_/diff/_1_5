[<Line: +    NodeTraversal.traverseRoots(compiler, this, externs, root);
>, <Line: +    (new NodeTraversal(compiler, this)).traverseAtScope(scope);
>, <Line: +    if (containingScope.isGlobal()) {
>, <Line: +        if (blockStack.get(i).root == containingScope.getRootNode()) {
>, <Line: +    NodeTraversal outOfBandTraversal = new NodeTraversal(compiler, this);
>, <Line: +    Node n = t.getScope().getRootNode();
>, <Line: +    BasicBlock parent = blockStack.isEmpty() ? null : peek(blockStack);
>, <Line: +    blockStack.add(new BasicBlock(parent, n));
>, <Line: +    pop(blockStack);
>, <Line: +        } else if (scope != ref.scope) {
>, <Line: +          if (ref.getSymbol().getScope() != ref.scope) {
>, <Line: +     * @return The one and only assignment. Returns if there are 0 or 2+
>, <Line: +    Reference(Node nameNode, NodeTraversal t,
>, <Line: +        BasicBlock basicBlock) {
>, <Line: +        this.isLoop = pType == Token.DO ||
>, <Line: +            pType == Token.WHILE ||
>, <Line: +            pType == Token.FOR;
>]
[<Line: -    NodeTraversal t = new NodeTraversal(compiler, this, new Es6SyntacticScopeCreator(compiler));
>, <Line: -    t.traverseRoots(externs, root);
>, <Line: -    (new NodeTraversal(compiler, this, new Es6SyntacticScopeCreator(compiler)))
>, <Line: -        .traverseAtScope(scope);
>, <Line: -    if (containingScope.getClosestHoistScope().isGlobal()) {
>, <Line: -      Node function = NodeUtil.getEnclosingFunction(containingScope.getRootNode());
>, <Line: -        if (blockStack.get(i).root == function) {
>, <Line: -    NodeTraversal outOfBandTraversal = new NodeTraversal(compiler, this,
>, <Line: -        new Es6SyntacticScopeCreator(compiler));
>, <Line: -    if (t.inGlobalScope() || t.getScopeRoot().isFunction()) {
>, <Line: -      Node n = t.getScope().getRootNode();
>, <Line: -      BasicBlock parent = blockStack.isEmpty() ? null : peek(blockStack);
>, <Line: -      blockStack.add(new BasicBlock(parent, n));
>, <Line: -    }
>, <Line: -    if (t.inGlobalScope() || t.getScopeRoot().isFunction()) {
>, <Line: -      pop(blockStack);
>, <Line: -    }
>, <Line: -    // TODO(user): figure out why t.inGlobalScope() does not work here
>, <Line: -        } else if (scope != ref.scope.getClosestHoistScope()) {
>, <Line: -          Scope declScope = ref.getSymbol().getScope();
>, <Line: -          Scope refScope = ref.scope;
>, <Line: -          if ((declScope.getRootNode().isFunction() && declScope == refScope)) {
>, <Line: -            // reference is a function parameter
>, <Line: -            return true;
>, <Line: -          } else if (declScope != refScope.getClosestHoistScope()) {
>, <Line: -     * @return The one and only assignment. Returns null if there are 0 or 2+
>, <Line: -    Reference(Node nameNode, NodeTraversal t, BasicBlock basicBlock) {
>, <Line: -        this.isLoop = pType == Token.DO
>, <Line: -                   || pType == Token.WHILE
>, <Line: -                   || pType == Token.FOR;
>]