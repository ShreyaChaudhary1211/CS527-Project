[<Line: +import static com.google.common.truth.Truth.assertThat;
>, <Line: +import static com.google.testing.compile.CompilationSubject.assertThat;
>, <Line: +import static com.google.testing.compile.Compiler.javac;
>, <Line: +import com.google.testing.compile.Compilation;
>, <Line: +import com.google.testing.compile.CompilationRule;
>, <Line: +import com.google.testing.compile.JavaFileObjects;
>, <Line: +import java.util.Map;
>, <Line: +import javax.annotation.processing.SupportedAnnotationTypes;
>, <Line: +import org.junit.Before;
>, <Line: +import org.junit.Rule;
>, <Line: +  @Rule public final CompilationRule compilationRule = new CompilationRule();
>, <Line: +  private Types typeUtils;
>, <Line: +  private Elements elementUtils;
>, <Line: +  @Before
>, <Line: +  public void setUp() {
>, <Line: +    typeUtils = compilationRule.getTypes();
>, <Line: +    elementUtils = compilationRule.getElements();
>, <Line: +  private static class MultipleBounds<K extends List<V> & Comparable<K>, V> {}
>, <Line: +  private static class Erasure<T> {
>, <Line: +    int intNo;
>, <Line: +    boolean booleanNo;
>, <Line: +    int[] intArrayNo;
>, <Line: +    String stringNo;
>, <Line: +    String[] stringArrayNo;
>, <Line: +    @SuppressWarnings("rawtypes")
>, <Line: +    List rawListNo;
>, <Line: +    List<?> listOfQueryNo;
>, <Line: +    List<? extends Object> listOfQueryExtendsObjectNo;
>, <Line: +    Map<?, ?> mapQueryToQueryNo;
>, <Line: +    List<String> listOfStringYes;
>, <Line: +    List<? extends String> listOfQueryExtendsStringYes;
>, <Line: +    List<? super String> listOfQuerySuperStringYes;
>, <Line: +    List<T> listOfTypeVarYes;
>, <Line: +    List<? extends T> listOfQueryExtendsTypeVarYes;
>, <Line: +    List<? super T> listOfQuerySuperTypeVarYes;
>, <Line: +  private abstract static class Wildcards {
>, <Line: +    abstract <T extends V, U extends T, V> Map<? extends T, ? super U> one();
>, <Line: +    abstract <T extends V, U extends T, V> Map<? extends T, ? super U> two();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * This test shows why we need to have TypeMirrorSet. The mirror of java.lang.Object obtained
>, <Line: +   * from {@link Elements#getTypeElement Elements.getTypeElement("java.lang.Object")} does not
>, <Line: +   * compare equal to the mirror of the return type of Object.clone(), even though that is also
>, <Line: +   * java.lang.Object and {@link Types#isSameType} considers them the same.
>, <Line: +   *
>, <Line: +   * <p>There's no requirement that this test must pass and if it starts failing or doesn't work in
>, <Line: +   * another test environment then we can delete it. The specification of
>, <Line: +   * {@link TypeMirror#equals} explicitly says that it cannot be used for type equality, so even
>, <Line: +   * if this particular case stops being a problem (which means this test would fail), we would
>, <Line: +   * need TypeMirrorSet for complete correctness.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testQuirkyTypeMirrors() {
>, <Line: +    TypeMirror objectMirror = objectMirror();
>, <Line: +    TypeMirror cloneReturnTypeMirror = cloneReturnTypeMirror();
>, <Line: +    assertThat(objectMirror).isNotEqualTo(cloneReturnTypeMirror);
>, <Line: +    assertThat(typeUtils.isSameType(objectMirror, cloneReturnTypeMirror)).isTrue();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testTypeMirrorSet() {
>, <Line: +    // Test the TypeMirrorSet methods. Resist the temptation to rewrite these in terms of
>, <Line: +    // Truth operations! For example, don't change assertThat(set.size()).isEqualTo(0) into
>, <Line: +    // assertThat(set).isEmpty(), because then we wouldn't be testing size().
>, <Line: +    TypeMirror objectMirror = objectMirror();
>, <Line: +    TypeMirror otherObjectMirror = cloneReturnTypeMirror();
>, <Line: +    Set<TypeMirror> set = new TypeMirrorSet();
>, <Line: +    assertThat(set.size()).isEqualTo(0);
>, <Line: +    assertThat(set.isEmpty()).isTrue();
>, <Line: +    boolean added = set.add(objectMirror);
>, <Line: +    assertThat(added).isTrue();
>, <Line: +    assertThat(set.size()).isEqualTo(1);
>, <Line: +    Set<TypeMirror> otherSet = typeMirrorSet(otherObjectMirror);
>, <Line: +    assertThat(otherSet).isEqualTo(set);
>, <Line: +    assertThat(set).isEqualTo(otherSet);
>, <Line: +    assertThat(otherSet.hashCode()).isEqualTo(set.hashCode());
>, <Line: +    assertThat(set.add(otherObjectMirror)).isFalse();
>, <Line: +    assertThat(set.contains(otherObjectMirror)).isTrue();
>, <Line: +    assertThat(set.contains(null)).isFalse();
>, <Line: +    assertThat(set.contains((Object) "foo")).isFalse();
>, <Line: +    assertThat(set.remove(null)).isFalse();
>, <Line: +    assertThat(set.remove((Object) "foo")).isFalse();
>, <Line: +    TypeElement list = typeElementOf(java.util.List.class);
>, <Line: +    TypeMirror listOfObjectMirror = typeUtils.getDeclaredType(list, objectMirror);
>, <Line: +    TypeMirror listOfOtherObjectMirror = typeUtils.getDeclaredType(list, otherObjectMirror);
>, <Line: +    assertThat(listOfObjectMirror.equals(listOfOtherObjectMirror)).isFalse();
>, <Line: +    assertThat(typeUtils.isSameType(listOfObjectMirror, listOfOtherObjectMirror)).isTrue();
>, <Line: +    added = set.add(listOfObjectMirror);
>, <Line: +    assertThat(added).isTrue();
>, <Line: +    assertThat(set.size()).isEqualTo(2);
>, <Line: +    assertThat(set.add(listOfOtherObjectMirror)).isFalse();
>, <Line: +    assertThat(set.contains(listOfOtherObjectMirror)).isTrue();
>, <Line: +    boolean removed = set.remove(listOfOtherObjectMirror);
>, <Line: +    assertThat(removed).isTrue();
>, <Line: +    assertThat(set.contains(listOfObjectMirror)).isFalse();
>, <Line: +    set.removeAll(otherSet);
>, <Line: +    assertThat(set.isEmpty()).isTrue();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testTypeMirrorSetWildcardCapture() {
>, <Line: +    // TODO(emcmanus): this test should really be in MoreTypesTest.
>, <Line: +    // This test checks the assumption made by MoreTypes that you can find the
>, <Line: +    // upper bounds of a TypeVariable tv like this:
>, <Line: +    //   TypeParameterElement tpe = (TypeParameterElement) tv.asElement();
>, <Line: +    //   List<? extends TypeMirror> bounds = tpe.getBounds();
>, <Line: +    // There was some doubt as to whether this would be true in exotic cases involving
>, <Line: +    // wildcard capture, but apparently it is.
>, <Line: +    // The methods one and two here have identical signatures:
>, <Line: +    //   abstract <T extends V, U extends T, V> Map<? extends T, ? super U> name();
>, <Line: +    // Their return types should be considered equal by TypeMirrorSet. The capture of
>, <Line: +    // each return type is different from the original return type, but the two captures
>, <Line: +    // should compare equal to each other. We also add various other types like ? super U
>, <Line: +    // to the set to ensure that the implied calls to the equals and hashCode visitors
>, <Line: +    // don't cause a ClassCastException for TypeParameterElement.
>, <Line: +    TypeElement wildcardsElement = typeElementOf(Wildcards.class);
>, <Line: +    List<? extends ExecutableElement> methods =
>, <Line: +        ElementFilter.methodsIn(wildcardsElement.getEnclosedElements());
>, <Line: +    assertThat(methods).hasSize(2);
>, <Line: +    ExecutableElement one = methods.get(0);
>, <Line: +    ExecutableElement two = methods.get(1);
>, <Line: +    assertThat(one.getSimpleName().toString()).isEqualTo("one");
>, <Line: +    assertThat(two.getSimpleName().toString()).isEqualTo("two");
>, <Line: +    TypeMirrorSet typeMirrorSet = new TypeMirrorSet();
>, <Line: +    assertThat(typeMirrorSet.add(one.getReturnType())).isTrue();
>, <Line: +    assertThat(typeMirrorSet.add(two.getReturnType())).isFalse();
>, <Line: +    DeclaredType captureOne = (DeclaredType) typeUtils.capture(one.getReturnType());
>, <Line: +    assertThat(typeMirrorSet.add(captureOne)).isTrue();
>, <Line: +    DeclaredType captureTwo = (DeclaredType) typeUtils.capture(two.getReturnType());
>, <Line: +    assertThat(typeMirrorSet.add(captureTwo)).isFalse();
>, <Line: +    // Reminder: captureOne is Map<?#123 extends T, ?#456 super U>
>, <Line: +    TypeVariable extendsT = (TypeVariable) captureOne.getTypeArguments().get(0);
>, <Line: +    assertThat(typeMirrorSet.add(extendsT)).isTrue();
>, <Line: +    assertThat(typeMirrorSet.add(extendsT.getLowerBound())).isTrue();  // NoType
>, <Line: +    for (TypeMirror bound : ((TypeParameterElement) extendsT.asElement()).getBounds()) {
>, <Line: +      assertThat(typeMirrorSet.add(bound)).isTrue();
>, <Line: +    }
>, <Line: +    TypeVariable superU = (TypeVariable) captureOne.getTypeArguments().get(1);
>, <Line: +    assertThat(typeMirrorSet.add(superU)).isTrue();
>, <Line: +    assertThat(typeMirrorSet.add(superU.getLowerBound())).isTrue();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testPackageNameOfString() {
>, <Line: +    assertThat(TypeSimplifier.packageNameOf(typeElementOf(java.lang.String.class)))
>, <Line: +        .isEqualTo("java.lang");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testPackageNameOfMapEntry() {
>, <Line: +    assertThat(TypeSimplifier.packageNameOf(typeElementOf(java.util.Map.Entry.class)))
>, <Line: +        .isEqualTo("java.util");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportsForNoTypes() {
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", typeMirrorSet(), baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport()).isEmpty();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportsForImplicitlyImportedTypes() {
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeMirrorOf(java.lang.String.class),
>, <Line: +        typeMirrorOf(javax.management.MBeanServer.class),  // Same package, so no import.
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.INT),
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.BOOLEAN)
>, <Line: +    );
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "javax.management", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport()).isEmpty();
>, <Line: +  @Test
>, <Line: +  public void testImportsForPlainTypes() {
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.INT),
>, <Line: +        typeMirrorOf(java.lang.String.class),
>, <Line: +        typeMirrorOf(java.net.Proxy.class),
>, <Line: +        typeMirrorOf(java.net.Proxy.Type.class),
>, <Line: +        typeMirrorOf(java.util.regex.Pattern.class),
>, <Line: +        typeMirrorOf(javax.management.MBeanServer.class));
>, <Line: +    List<String> expectedImports = ImmutableList.of(
>, <Line: +        "java.net.Proxy",
>, <Line: +        "java.util.regex.Pattern",
>, <Line: +        "javax.management.MBeanServer"
>, <Line: +    );
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport()).containsExactlyElementsIn(expectedImports).inOrder();
>, <Line: +    assertThat(typeSimplifier.simplify(typeMirrorOf(java.net.Proxy.class)))
>, <Line: +        .isEqualTo("Proxy");
>, <Line: +    assertThat(typeSimplifier.simplify(typeMirrorOf(java.net.Proxy.Type.class)))
>, <Line: +        .isEqualTo("Proxy.Type");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportsForComplicatedTypes() {
>, <Line: +    TypeElement list = typeElementOf(java.util.List.class);
>, <Line: +    TypeElement map = typeElementOf(java.util.Map.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.INT),
>, <Line: +        typeMirrorOf(java.util.regex.Pattern.class),
>, <Line: +        typeUtils.getDeclaredType(list,  // List<Timer>
>, <Line: +            typeMirrorOf(java.util.Timer.class)),
>, <Line: +        typeUtils.getDeclaredType(map,   // Map<? extends Timer, ? super BigInteger>
>, <Line: +            typeUtils.getWildcardType(typeMirrorOf(java.util.Timer.class), null),
>, <Line: +            typeUtils.getWildcardType(null, typeMirrorOf(java.math.BigInteger.class))));
>, <Line: +    // Timer is referenced twice but should obviously only be imported once.
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport())
>, <Line: +        .containsExactly(
>, <Line: +            "java.math.BigInteger",
>, <Line: +            "java.util.List",
>, <Line: +            "java.util.Map",
>, <Line: +            "java.util.Timer",
>, <Line: +            "java.util.regex.Pattern")
>, <Line: +        .inOrder();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportsForArrayTypes() {
>, <Line: +    TypeElement list = typeElementOf(java.util.List.class);
>, <Line: +    TypeElement set = typeElementOf(java.util.Set.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.INT)),
>, <Line: +        typeUtils.getArrayType(typeMirrorOf(java.util.regex.Pattern.class)),
>, <Line: +        typeUtils.getArrayType(          // Set<Matcher[]>[]
>, <Line: +            typeUtils.getDeclaredType(set,
>, <Line: +                typeUtils.getArrayType(typeMirrorOf(java.util.regex.Matcher.class)))),
>, <Line: +        typeUtils.getDeclaredType(list,  // List<Timer[]>
>, <Line: +            typeUtils.getArrayType(typeMirrorOf(java.util.Timer.class))));
>, <Line: +    // Timer is referenced twice but should obviously only be imported once.
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport())
>, <Line: +        .containsExactly(
>, <Line: +            "java.util.List",
>, <Line: +            "java.util.Set",
>, <Line: +            "java.util.Timer",
>, <Line: +            "java.util.regex.Matcher",
>, <Line: +            "java.util.regex.Pattern")
>, <Line: +        .inOrder();
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportNestedType() {
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(typeMirrorOf(java.net.Proxy.Type.class));
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport())
>, <Line: +        .containsExactly("java.net.Proxy");
>, <Line: +    assertThat(typeSimplifier.simplify(typeMirrorOf(java.net.Proxy.Type.class)))
>, <Line: +        .isEqualTo("Proxy.Type");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testImportsForAmbiguousNames() {
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.INT),
>, <Line: +        typeMirrorOf(java.awt.List.class),
>, <Line: +        typeMirrorOf(java.lang.String.class),
>, <Line: +        typeMirrorOf(java.util.List.class),
>, <Line: +        typeMirrorOf(java.util.Map.class)
>, <Line: +    );
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport())
>, <Line: +        .containsExactly("java.util.Map");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyJavaLangString() {
>, <Line: +    TypeMirror string = typeMirrorOf(java.lang.String.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(string);
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.simplify(string)).isEqualTo("String");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyJavaLangThreadState() {
>, <Line: +    TypeMirror threadState = typeMirrorOf(java.lang.Thread.State.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(threadState);
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.simplify(threadState)).isEqualTo("Thread.State");
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyAmbiguousNames() {
>, <Line: +    TypeMirror javaAwtList = typeMirrorOf(java.awt.List.class);
>, <Line: +    TypeMirror javaUtilList = typeMirrorOf(java.util.List.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(javaAwtList, javaUtilList);
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.simplify(javaAwtList)).isEqualTo(javaAwtList.toString());
>, <Line: +    assertThat(typeSimplifier.simplify(javaUtilList)).isEqualTo(javaUtilList.toString());
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyJavaLangNamesake() {
>, <Line: +    TypeMirror javaLangType = typeMirrorOf(java.lang.RuntimePermission.class);
>, <Line: +    TypeMirror notJavaLangType = typeMirrorOf(
>, <Line: +        com.google.auto.value.processor.testclasses.RuntimePermission.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(javaLangType, notJavaLangType);
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.simplify(javaLangType)).isEqualTo(javaLangType.toString());
>, <Line: +    assertThat(typeSimplifier.simplify(notJavaLangType)).isEqualTo(notJavaLangType.toString());
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyComplicatedTypes() {
>, <Line: +    // This test constructs a set of types and feeds them to TypeSimplifier. Then it verifies that
>, <Line: +    // the resultant rewrites of those types are what we would expect.
>, <Line: +    TypeElement list = typeElementOf(java.util.List.class);
>, <Line: +    TypeElement map = typeElementOf(java.util.Map.class);
>, <Line: +    TypeMirror string = typeMirrorOf(java.lang.String.class);
>, <Line: +    TypeMirror integer = typeMirrorOf(java.lang.Integer.class);
>, <Line: +    TypeMirror pattern = typeMirrorOf(java.util.regex.Pattern.class);
>, <Line: +    TypeMirror timer = typeMirrorOf(java.util.Timer.class);
>, <Line: +    TypeMirror bigInteger = typeMirrorOf(java.math.BigInteger.class);
>, <Line: +    Set<TypeMirror> types = typeMirrorSet(
>, <Line: +        typeUtils.getPrimitiveType(TypeKind.INT),
>, <Line: +        typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.BYTE)),
>, <Line: +        pattern,
>, <Line: +        typeUtils.getArrayType(pattern),
>, <Line: +        typeUtils.getArrayType(typeUtils.getArrayType(pattern)),
>, <Line: +        typeUtils.getDeclaredType(list, typeUtils.getWildcardType(null, null)),
>, <Line: +        typeUtils.getDeclaredType(list, timer),
>, <Line: +        typeUtils.getDeclaredType(map, string, integer),
>, <Line: +        typeUtils.getDeclaredType(map,
>, <Line: +            typeUtils.getWildcardType(timer, null), typeUtils.getWildcardType(null, bigInteger)));
>, <Line: +    Set<String> expectedSimplifications = ImmutableSet.of(
>, <Line: +        "int",
>, <Line: +        "byte[]",
>, <Line: +        "Pattern",
>, <Line: +        "Pattern[]",
>, <Line: +        "Pattern[][]",
>, <Line: +        "List<?>",
>, <Line: +        "List<Timer>",
>, <Line: +        "Map<String, Integer>",
>, <Line: +        "Map<? extends Timer, ? super BigInteger>"
>, <Line: +    );
>, <Line: +    TypeSimplifier typeSimplifier =
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: +    Set<String> actualSimplifications = new HashSet<String>();
>, <Line: +    for (TypeMirror type : types) {
>, <Line: +      actualSimplifications.add(typeSimplifier.simplify(type));
>, <Line: +    }
>, <Line: +    assertThat(actualSimplifications).isEqualTo(expectedSimplifications);
>, <Line: +  }
>, <Line: +  @Test
>, <Line: +  public void testSimplifyMultipleBounds() {
>, <Line: +    TypeElement multipleBoundsElement = typeElementOf(MultipleBounds.class);
>, <Line: +    TypeMirror multipleBoundsMirror = multipleBoundsElement.asType();
>, <Line: +    TypeSimplifier typeSimplifier = new TypeSimplifier(typeUtils, "",
>, <Line: +        typeMirrorSet(multipleBoundsMirror), baseWithoutContainedTypes());
>, <Line: +    assertThat(typeSimplifier.typesToImport())
>, <Line: +        .contains("java.util.List");
>, <Line: +    assertThat(typeSimplifier.simplify(multipleBoundsMirror))
>, <Line: +        .isEqualTo("TypeSimplifierTest.MultipleBounds<K, V>");
>, <Line: +    assertThat(typeSimplifier.formalTypeParametersString(multipleBoundsElement))
>, <Line: +        .isEqualTo("<K extends List<V> & Comparable<K>, V>");
>, <Line: +  }
>, <Line: +  // Test TypeSimplifier.isCastingUnchecked. We do this by examining the fields of the Erasure
>, <Line: +  // class. A field whose name ends with Yes has a type where
>, <Line: +  // isCastingUnchecked should return true, and one whose name ends with No has a type where
>, <Line: +  // isCastingUnchecked should return false.
>, <Line: +  @Test
>, <Line: +  public void testIsCastingUnchecked() {
>, <Line: +    TypeElement erasureClass = typeElementOf(Erasure.class);
>, <Line: +    List<VariableElement> fields = ElementFilter.fieldsIn(erasureClass.getEnclosedElements());
>, <Line: +    assertThat(fields).isNotEmpty();
>, <Line: +    for (VariableElement field : fields) {
>, <Line: +      String fieldName = field.getSimpleName().toString();
>, <Line: +      boolean expectUnchecked;
>, <Line: +      if (fieldName.endsWith("Yes")) {
>, <Line: +        expectUnchecked = true;
>, <Line: +      } else if (fieldName.endsWith("No")) {
>, <Line: +        expectUnchecked = false;
>, <Line: +      } else {
>, <Line: +        throw new AssertionError("Fields in Erasure class must end with Yes or No: " + fieldName);
>, <Line: +      }
>, <Line: +      TypeMirror fieldType = field.asType();
>, <Line: +      boolean actualUnchecked = TypeSimplifier.isCastingUnchecked(fieldType);
>, <Line: +      assertThat(actualUnchecked)
>, <Line: +          .named("Unchecked-cast status for " + fieldType)
>, <Line: +          .isEqualTo(expectUnchecked);
>, <Line: +  }
>, <Line: +  private static Set<TypeMirror> typeMirrorSet(TypeMirror... typeMirrors) {
>, <Line: +    Set<TypeMirror> set = new TypeMirrorSet();
>, <Line: +    for (TypeMirror typeMirror : typeMirrors) {
>, <Line: +      assertThat(set.add(typeMirror)).isTrue();
>, <Line: +    return set;
>, <Line: +  }
>, <Line: +  private TypeMirror objectMirror() {
>, <Line: +    return typeMirrorOf(Object.class);
>, <Line: +  }
>, <Line: +  private TypeMirror cloneReturnTypeMirror() {
>, <Line: +    TypeElement object = typeElementOf(Object.class);
>, <Line: +    ExecutableElement clone = null;
>, <Line: +    for (Element element : object.getEnclosedElements()) {
>, <Line: +      if (element.getSimpleName().contentEquals("clone")) {
>, <Line: +        clone = (ExecutableElement) element;
>, <Line: +        break;
>, <Line: +    return clone.getReturnType();
>, <Line: +  }
>, <Line: +  private TypeElement typeElementOf(Class<?> c) {
>, <Line: +    return elementUtils.getTypeElement(c.getCanonicalName());
>, <Line: +  }
>, <Line: +  private TypeMirror typeMirrorOf(Class<?> c) {
>, <Line: +    return typeElementOf(c).asType();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Returns a "base type" for TypeSimplifier that does not contain any nested types. The point
>, <Line: +   * being that every {@code TypeSimplifier} has a base type that the class being generated is
>, <Line: +   * going to extend, and if that class has nested types they will be in scope, and therefore a
>, <Line: +   * possible source of ambiguity.
>, <Line: +   */
>, <Line: +  private TypeMirror baseWithoutContainedTypes() {
>, <Line: +    return typeMirrorOf(Object.class);
>, <Line: +  }
>, <Line: +  // This test checks that we correctly throw MissingTypeException if there is an ErrorType anywhere
>, <Line: +  // inside a type we are asked to simplify. There's no way to get an ErrorType from typeUtils or
>, <Line: +  // elementUtils, so we need to fire up the compiler with an erroneous source file and use an
>, <Line: +  // annotation processor to capture the resulting ErrorType. Then we can run tests within that
>, <Line: +  // annotation processor, and propagate any failures out of this test.
>, <Line: +  @Test
>, <Line: +  public void testErrorTypes() {
>, <Line: +    JavaFileObject source = JavaFileObjects.forSourceString(
>, <Line: +        "ExtendsUndefinedType", "class ExtendsUndefinedType extends UndefinedParent {}");
>, <Line: +    Compilation compilation = javac()
>, <Line: +        .withProcessors(new ErrorTestProcessor())
>, <Line: +        .compile(source);
>, <Line: +    assertThat(compilation).failed();
>, <Line: +    assertThat(compilation).hadErrorContaining("UndefinedParent");
>, <Line: +    assertThat(compilation).hadErrorCount(1);
>, <Line: +  }
>, <Line: +  @SupportedAnnotationTypes("*")
>, <Line: +  private static class ErrorTestProcessor extends AbstractProcessor {
>, <Line: +    Types typeUtils;
>, <Line: +    Elements elementUtils;
>, <Line: +    @Override
>, <Line: +    public boolean process(
>, <Line: +        Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
>, <Line: +      if (roundEnv.processingOver()) {
>, <Line: +        typeUtils = processingEnv.getTypeUtils();
>, <Line: +        elementUtils = processingEnv.getElementUtils();
>, <Line: +        test();
>, <Line: +      return false;
>, <Line: +    private void test() {
>, <Line: +      TypeElement extendsUndefinedType = elementUtils.getTypeElement("ExtendsUndefinedType");
>, <Line: +      ErrorType errorType = (ErrorType) extendsUndefinedType.getSuperclass();
>, <Line: +      TypeElement list = elementUtils.getTypeElement("java.util.List");
>, <Line: +      TypeMirror listOfError = typeUtils.getDeclaredType(list, errorType);
>, <Line: +      TypeMirror queryExtendsError = typeUtils.getWildcardType(errorType, null);
>, <Line: +      TypeMirror listOfQueryExtendsError = typeUtils.getDeclaredType(list, queryExtendsError);
>, <Line: +      TypeMirror querySuperError = typeUtils.getWildcardType(null, errorType);
>, <Line: +      TypeMirror listOfQuerySuperError = typeUtils.getDeclaredType(list, querySuperError);
>, <Line: +      TypeMirror arrayOfError = typeUtils.getArrayType(errorType);
>, <Line: +      testErrorType(errorType);
>, <Line: +      testErrorType(listOfError);
>, <Line: +      testErrorType(listOfQueryExtendsError);
>, <Line: +      testErrorType(listOfQuerySuperError);
>, <Line: +      testErrorType(arrayOfError);
>, <Line: +    }
>, <Line: +    @SuppressWarnings("MissingFail")  // error message gets converted into assertion failure
>, <Line: +    private void testErrorType(TypeMirror typeWithError) {
>, <Line: +      TypeMirror javaLangObject = elementUtils.getTypeElement("java.lang.Object").asType();
>, <Line: +      try {
>, <Line: +        new TypeSimplifier(typeUtils, "foo.bar", ImmutableSet.of(typeWithError), javaLangObject);
>, <Line: +        processingEnv.getMessager().printMessage(
>, <Line: +            Diagnostic.Kind.ERROR, "Expected exception for type: " + typeWithError);
>, <Line: +      } catch (MissingTypeException expected) {
>, <Line: +    @Override
>, <Line: +    public SourceVersion getSupportedSourceVersion() {
>, <Line: +      return SourceVersion.latestSupported();
>]
[<Line: -import static org.junit.Assert.assertEquals;
>, <Line: -import static org.junit.Assert.assertFalse;
>, <Line: -import static org.junit.Assert.assertTrue;
>, <Line: -import static org.junit.Assert.fail;
>, <Line: -import com.google.common.collect.ImmutableMap;
>, <Line: -import com.google.common.io.Files;
>, <Line: -import java.io.File;
>, <Line: -import java.io.IOException;
>, <Line: -import java.io.PrintWriter;
>, <Line: -import java.io.StringWriter;
>, <Line: -import java.lang.reflect.InvocationTargetException;
>, <Line: -import java.lang.reflect.Method;
>, <Line: -import java.nio.charset.Charset;
>, <Line: -import java.util.ArrayList;
>, <Line: -import java.util.Iterator;
>, <Line: -import javax.tools.DiagnosticCollector;
>, <Line: -import javax.tools.JavaCompiler;
>, <Line: -import javax.tools.JavaFileObject.Kind;
>, <Line: -import javax.tools.StandardJavaFileManager;
>, <Line: -import javax.tools.StandardLocation;
>, <Line: -import javax.tools.ToolProvider;
>, <Line: -  private static final ImmutableMap<String, String> CLASS_TO_SOURCE = ImmutableMap.of(
>, <Line: -      "Test",
>, <Line: -          "public class Test {}\n",
>, <Line: -      "MultipleBounds",
>, <Line: -          "import java.util.List;\n"
>, <Line: -          + "public class MultipleBounds<K extends List<V> & Comparable<K>, V> {}\n",
>, <Line: -      "Erasure",
>, <Line: -          "import java.util.List;\n"
>, <Line: -          + "import java.util.Map;\n"
>, <Line: -          + "@SuppressWarnings(\"rawtypes\")"
>, <Line: -          + "public class Erasure<T> {\n"
>, <Line: -          + "  int intNo; boolean booleanNo; int[] intArrayNo; String stringNo;\n"
>, <Line: -          + "  String[] stringArrayNo; List rawListNo; List<?> listOfQueryNo;\n"
>, <Line: -          + "  List<? extends Object> listOfQueryExtendsObjectNo;\n"
>, <Line: -          + "  Map<?, ?> mapQueryToQueryNo;\n"
>, <Line: -          + "\n"
>, <Line: -          + "  List<String> listOfStringYes; List<? extends String> listOfQueryExtendsStringYes;\n"
>, <Line: -          + "  List<? super String> listOfQuerySuperStringYes; List<T> listOfTypeVarYes;\n"
>, <Line: -          + "  List<? extends T> listOfQueryExtendsTypeVarYes;\n"
>, <Line: -          + "  List<? super T> listOfQuerySuperTypeVarYes;\n"
>, <Line: -          + "}\n",
>, <Line: -      "Wildcards",
>, <Line: -          "import java.util.Map;\n"
>, <Line: -          + "public abstract class Wildcards {\n"
>, <Line: -          + "  abstract <T extends V, U extends T, V> Map<? extends T, ? super U> one();\n"
>, <Line: -          + "  abstract <T extends V, U extends T, V> Map<? extends T, ? super U> two();\n"
>, <Line: -          + "}\n"
>, <Line: -  );
>, <Line: -  private static final ImmutableMap<String, String> ERROR_CLASS_TO_SOURCE = ImmutableMap.of(
>, <Line: -      "ExtendsUndefinedType",
>, <Line: -          "public class ExtendsUndefinedType extends MissingType {}\n"
>, <Line: -  );
>, <Line: -  // This test is a bit unusual. The reason is that TypeSimplifier relies on interfaces such as
>, <Line: -  // Types, TypeMirror, and TypeElement whose implementations are provided by the annotation
>, <Line: -  // processing environment. While we could make fake or mock implementations of those interfaces,
>, <Line: -  // the resulting test would be very verbose and would not obviously be testing the right thing.
>, <Line: -  // Instead, we run the compiler with a simple annotation-processing environment that allows us
>, <Line: -  // to capture the real implementations of these interfaces. Since those implementations are not
>, <Line: -  // necessarily valid when the compiler has exited, we run all our test cases from within our
>, <Line: -  // annotation processor, converting test failures into compiler errors. Then testTypeSimplifier()
>, <Line: -  // passes if there were no compiler errors, and otherwise fails with a message that is a
>, <Line: -  // concatenation of all the individual failures.
>, <Line: -  // TODO(emcmanus): Use compile-testing to make all this unnecessary.
>, <Line: -  @Test
>, <Line: -  public void testTypeSimplifier() throws Exception {
>, <Line: -    doTestTypeSimplifierWithSources(new MainTestProcessor(), CLASS_TO_SOURCE);
>, <Line: -  }
>, <Line: -  @Test
>, <Line: -  public void testTypeSimplifierErrorTypes() throws IOException {
>, <Line: -    doTestTypeSimplifierWithSources(new ErrorTestProcessor(), ERROR_CLASS_TO_SOURCE);
>, <Line: -  }
>, <Line: -  private void doTestTypeSimplifierWithSources(
>, <Line: -      AbstractTestProcessor testProcessor, ImmutableMap<String, String> classToSource)
>, <Line: -      throws IOException {
>, <Line: -    File tmpDir = Files.createTempDir();
>, <Line: -    for (String className : classToSource.keySet()) {
>, <Line: -      File java = new File(tmpDir, className + ".java");
>, <Line: -      Files.write(classToSource.get(className), java, Charset.forName("UTF-8"));
>, <Line: -    }
>, <Line: -    try {
>, <Line: -      doTestTypeSimplifier(testProcessor, tmpDir, classToSource);
>, <Line: -    } finally {
>, <Line: -      for (String className : classToSource.keySet()) {
>, <Line: -        File java = new File(tmpDir, className + ".java");
>, <Line: -        assertTrue(java.delete());
>, <Line: -        new File(tmpDir, className + ".class").delete();
>, <Line: -      }
>, <Line: -      assertTrue(tmpDir.delete());
>, <Line: -    }
>, <Line: -  private void doTestTypeSimplifier(
>, <Line: -      AbstractTestProcessor testProcessor, File tmpDir, ImmutableMap<String, String> classToSource)
>, <Line: -      throws IOException {
>, <Line: -    JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
>, <Line: -    DiagnosticCollector<JavaFileObject> diagnosticCollector =
>, <Line: -        new DiagnosticCollector<JavaFileObject>();
>, <Line: -    StandardJavaFileManager fileManager =
>, <Line: -        javac.getStandardFileManager(diagnosticCollector, null, null);
>, <Line: -    StringWriter compilerOut = new StringWriter();
>, <Line: -    List<String> options = ImmutableList.of(
>, <Line: -        "-sourcepath", tmpDir.getPath(),
>, <Line: -        "-d", tmpDir.getPath(),
>, <Line: -        "-Xlint");
>, <Line: -    javac.getTask(compilerOut, fileManager, diagnosticCollector, options, null, null);
>, <Line: -    // This doesn't compile anything but communicates the paths to the JavaFileManager.
>, <Line: -    ImmutableList.Builder<JavaFileObject> javaFilesBuilder = ImmutableList.builder();
>, <Line: -    for (String className : classToSource.keySet()) {
>, <Line: -      JavaFileObject sourceFile = fileManager.getJavaFileForInput(
>, <Line: -          StandardLocation.SOURCE_PATH, className, Kind.SOURCE);
>, <Line: -      javaFilesBuilder.add(sourceFile);
>, <Line: -    }
>, <Line: -    // Compile the empty source file to trigger the annotation processor.
>, <Line: -    // (Annotation processors are somewhat misnamed because they run even on classes with no
>, <Line: -    // annotations.)
>, <Line: -    JavaCompiler.CompilationTask javacTask = javac.getTask(
>, <Line: -        compilerOut, fileManager, diagnosticCollector, options,
>, <Line: -        classToSource.keySet(), javaFilesBuilder.build());
>, <Line: -    javacTask.setProcessors(ImmutableList.of(testProcessor));
>, <Line: -    javacTask.call();
>, <Line: -    List<Diagnostic<? extends JavaFileObject>> diagnostics =
>, <Line: -        new ArrayList<Diagnostic<? extends JavaFileObject>>(diagnosticCollector.getDiagnostics());
>, <Line: -    // In the ErrorTestProcessor case, the code being compiled contains a deliberate reference to an
>, <Line: -    // undefined type, so that we can capture an instance of ErrorType. (Synthesizing one ourselves
>, <Line: -    // leads to ClassCastException inside javac.) So remove any errors for that from the output, and
>, <Line: -    // only fail if there were other errors.
>, <Line: -    for (Iterator<Diagnostic<? extends JavaFileObject>> it = diagnostics.iterator();
>, <Line: -         it.hasNext(); ) {
>, <Line: -      Diagnostic<? extends JavaFileObject> diagnostic = it.next();
>, <Line: -      if (diagnostic.getSource() != null
>, <Line: -          && diagnostic.getSource().getName().contains("ExtendsUndefinedType")) {
>, <Line: -        it.remove();
>, <Line: -      }
>, <Line: -    }
>, <Line: -    // In the ErrorTestProcessor case, compilerOut.toString() will include the error for
>, <Line: -    // ExtendsUndefinedType, which can safely be ignored, as well as stack traces for any failing
>, <Line: -    // assertion.
>, <Line: -    assertEquals(compilerOut.toString() + diagnosticCollector.getDiagnostics(),
>, <Line: -        ImmutableList.of(), diagnostics);
>, <Line: -  // A type which is deliberately ambiguous with Map.Entry. Used to perform an ambiguity test below.
>, <Line: -  static final class Entry {}
>, <Line: -  private abstract static class AbstractTestProcessor extends AbstractProcessor {
>, <Line: -    private boolean testsRan;
>, <Line: -    Types typeUtil;
>, <Line: -    @Override
>, <Line: -    public Set<String> getSupportedAnnotationTypes() {
>, <Line: -      return ImmutableSet.of("*");
>, <Line: -    }
>, <Line: -    @Override
>, <Line: -    public final SourceVersion getSupportedSourceVersion() {
>, <Line: -      return SourceVersion.latest();
>, <Line: -    }
>, <Line: -    @Override
>, <Line: -    public final boolean process(
>, <Line: -        Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
>, <Line: -      if (!testsRan) {
>, <Line: -        testsRan = true;
>, <Line: -        typeUtil = processingEnv.getTypeUtils();
>, <Line: -        runTests();
>, <Line: -      }
>, <Line: -      return false;
>, <Line: -    }
>, <Line: -    private void runTests() {
>, <Line: -      for (Method method : getClass().getMethods()) {
>, <Line: -        if (method.isAnnotationPresent(Test.class)) {
>, <Line: -          try {
>, <Line: -            method.invoke(this);
>, <Line: -          } catch (Exception e) {
>, <Line: -            Throwable cause = (e instanceof InvocationTargetException) ? e.getCause() : e;
>, <Line: -            StringWriter stringWriter = new StringWriter();
>, <Line: -            cause.printStackTrace(new PrintWriter(stringWriter));
>, <Line: -            processingEnv.getMessager().printMessage(
>, <Line: -                Diagnostic.Kind.ERROR, stringWriter.toString());
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    TypeElement typeElementOf(String name) {
>, <Line: -      return processingEnv.getElementUtils().getTypeElement(name);
>, <Line: -    }
>, <Line: -    TypeMirror typeMirrorOf(String name) {
>, <Line: -      return typeElementOf(name).asType();
>, <Line: -    }
>, <Line: -    TypeMirror baseWithoutContainedTypes() {
>, <Line: -      return typeMirrorOf("java.lang.Object");
>, <Line: -    }
>, <Line: -    TypeMirror baseDeclaresEntry() {
>, <Line: -      return typeMirrorOf("java.util.Map");
>, <Line: -    }
>, <Line: -  private static class MainTestProcessor extends AbstractTestProcessor {
>, <Line: -    private Set<TypeMirror> typeMirrorSet(TypeMirror... typeMirrors) {
>, <Line: -      Set<TypeMirror> set = new TypeMirrorSet();
>, <Line: -      for (TypeMirror typeMirror : typeMirrors) {
>, <Line: -        assertTrue(set.add(typeMirror));
>, <Line: -      }
>, <Line: -      return set;
>, <Line: -    }
>, <Line: -    private TypeMirror objectMirror() {
>, <Line: -      return typeMirrorOf("java.lang.Object");
>, <Line: -    }
>, <Line: -    private TypeMirror cloneReturnTypeMirror() {
>, <Line: -      TypeElement object = typeElementOf("java.lang.Object");
>, <Line: -      ExecutableElement clone = null;
>, <Line: -      for (Element element : object.getEnclosedElements()) {
>, <Line: -        if (element.getSimpleName().contentEquals("clone")) {
>, <Line: -          clone = (ExecutableElement) element;
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return clone.getReturnType();
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This test shows why we need to have TypeMirrorSet. The mirror of java.lang.Object obtained
>, <Line: -     * from {@link Elements#getTypeElement Elements.getTypeElement("java.lang.Object")} does not
>, <Line: -     * compare equal to the mirror of the return type of Object.clone(), even though that is also
>, <Line: -     * java.lang.Object and {@link Types#isSameType} considers them the same.
>, <Line: -     *
>, <Line: -     * <p>There's no requirement that this test pass and if it starts failing or doesn't work in
>, <Line: -     * another test environment then we can delete it. The specification of
>, <Line: -     * {@link TypeMirror#equals} explicitly says that it cannot be used for type equality, so even
>, <Line: -     * if this particular case stops being a problem (which means this test would fail), we would
>, <Line: -     * need TypeMirrorSet for complete correctness.
>, <Line: -     */
>, <Line: -    @Test
>, <Line: -    public void testQuirkyTypeMirrors() {
>, <Line: -      TypeMirror objectMirror = objectMirror();
>, <Line: -      TypeMirror cloneReturnTypeMirror = cloneReturnTypeMirror();
>, <Line: -      assertFalse(objectMirror.equals(cloneReturnTypeMirror));
>, <Line: -      assertTrue(typeUtil.isSameType(objectMirror, cloneReturnTypeMirror));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testTypeMirrorSet() {
>, <Line: -      TypeMirror objectMirror = objectMirror();
>, <Line: -      TypeMirror otherObjectMirror = cloneReturnTypeMirror();
>, <Line: -      Set<TypeMirror> set = new TypeMirrorSet();
>, <Line: -      assertEquals(0, set.size());
>, <Line: -      assertTrue(set.isEmpty());
>, <Line: -      boolean added = set.add(objectMirror);
>, <Line: -      assertTrue(added);
>, <Line: -      assertEquals(1, set.size());
>, <Line: -      Set<TypeMirror> otherSet = typeMirrorSet(otherObjectMirror);
>, <Line: -      assertEquals(set, otherSet);
>, <Line: -      assertEquals(otherSet, set);
>, <Line: -      assertEquals(set.hashCode(), otherSet.hashCode());
>, <Line: -      assertFalse(set.add(otherObjectMirror));
>, <Line: -      assertTrue(set.contains(otherObjectMirror));
>, <Line: -      assertFalse(set.contains(null));
>, <Line: -      assertFalse(set.contains((Object) "foo"));
>, <Line: -      assertFalse(set.remove(null));
>, <Line: -      assertFalse(set.remove((Object) "foo"));
>, <Line: -      TypeElement list = typeElementOf("java.util.List");
>, <Line: -      TypeMirror listOfObjectMirror = typeUtil.getDeclaredType(list, objectMirror);
>, <Line: -      TypeMirror listOfOtherObjectMirror = typeUtil.getDeclaredType(list, otherObjectMirror);
>, <Line: -      assertFalse(listOfObjectMirror.equals(listOfOtherObjectMirror));
>, <Line: -      assertTrue(typeUtil.isSameType(listOfObjectMirror, listOfOtherObjectMirror));
>, <Line: -      added = set.add(listOfObjectMirror);
>, <Line: -      assertTrue(added);
>, <Line: -      assertEquals(2, set.size());
>, <Line: -      assertFalse(set.add(listOfOtherObjectMirror));
>, <Line: -      assertTrue(set.contains(listOfOtherObjectMirror));
>, <Line: -      boolean removed = set.remove(listOfOtherObjectMirror);
>, <Line: -      assertTrue(removed);
>, <Line: -      assertFalse(set.contains(listOfObjectMirror));
>, <Line: -      set.removeAll(otherSet);
>, <Line: -      assertTrue(set.isEmpty());
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testTypeMirrorSetWildcardCapture() {
>, <Line: -      // TODO(emcmanus): this test should really be in MoreTypesTest.
>, <Line: -      // This test checks the assumption made by MoreTypes that you can find the
>, <Line: -      // upper bounds of a TypeVariable tv like this:
>, <Line: -      //   TypeParameterElement tpe = (TypeParameterElement) tv.asElement();
>, <Line: -      //   List<? extends TypeMirror> bounds = tpe.getBounds();
>, <Line: -      // There was some doubt as to whether this would be true in exotic cases involving
>, <Line: -      // wildcard capture, but apparently it is.
>, <Line: -      // The methods one and two here have identical signatures:
>, <Line: -      //   abstract <T extends V, U extends T, V> Map<? extends T, ? super U> name();
>, <Line: -      // Their return types should be considered equal by TypeMirrorSet. The capture of
>, <Line: -      // each return type is different from the original return type, but the two captures
>, <Line: -      // should compare equal to each other. We also add various other types like ? super U
>, <Line: -      // to the set to ensure that the implied calls to the equals and hashCode visitors
>, <Line: -      // don't cause a ClassCastException for TypeParameterElement.
>, <Line: -      TypeElement wildcardsElement = typeElementOf("Wildcards");
>, <Line: -      List<? extends ExecutableElement> methods =
>, <Line: -          ElementFilter.methodsIn(wildcardsElement.getEnclosedElements());
>, <Line: -      assertEquals(2, methods.size());
>, <Line: -      ExecutableElement one = methods.get(0);
>, <Line: -      ExecutableElement two = methods.get(1);
>, <Line: -      assertEquals("one", one.getSimpleName().toString());
>, <Line: -      assertEquals("two", two.getSimpleName().toString());
>, <Line: -      TypeMirrorSet typeMirrorSet = new TypeMirrorSet();
>, <Line: -      assertTrue(typeMirrorSet.add(one.getReturnType()));
>, <Line: -      assertFalse(typeMirrorSet.add(two.getReturnType()));
>, <Line: -      DeclaredType captureOne = (DeclaredType) typeUtil.capture(one.getReturnType());
>, <Line: -      assertTrue(typeMirrorSet.add(captureOne));
>, <Line: -      DeclaredType captureTwo = (DeclaredType) typeUtil.capture(two.getReturnType());
>, <Line: -      assertFalse(typeMirrorSet.add(captureTwo));
>, <Line: -      // Reminder: captureOne is Map<?#123 extends T, ?#456 super U>
>, <Line: -      TypeVariable extendsT = (TypeVariable) captureOne.getTypeArguments().get(0);
>, <Line: -      assertTrue(typeMirrorSet.add(extendsT));
>, <Line: -      assertTrue(typeMirrorSet.add(extendsT.getLowerBound()));  // NoType
>, <Line: -      for (TypeMirror bound : ((TypeParameterElement) extendsT.asElement()).getBounds()) {
>, <Line: -        assertTrue(typeMirrorSet.add(bound));
>, <Line: -      }
>, <Line: -      TypeVariable superU = (TypeVariable) captureOne.getTypeArguments().get(1);
>, <Line: -      assertTrue(typeMirrorSet.add(superU));
>, <Line: -      assertTrue(typeMirrorSet.add(superU.getLowerBound()));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testPackageNameOfString() {
>, <Line: -      assertEquals("java.lang", TypeSimplifier.packageNameOf(typeElementOf("java.lang.String")));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testPackageNameOfMapEntry() {
>, <Line: -      assertEquals("java.util", TypeSimplifier.packageNameOf(typeElementOf("java.util.Map.Entry")));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testPackageNameOfDefaultPackage() {
>, <Line: -      String aClassName = CLASS_TO_SOURCE.keySet().iterator().next();
>, <Line: -      assertEquals("", TypeSimplifier.packageNameOf(typeElementOf(aClassName)));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testImportsForNoTypes() {
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", typeMirrorSet(), baseWithoutContainedTypes());
>, <Line: -      assertEquals(ImmutableSet.of(), typeSimplifier.typesToImport());
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testImportsForImplicitlyImportedTypes() {
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeMirrorOf("java.lang.String"),
>, <Line: -          typeMirrorOf("javax.management.MBeanServer"),  // Same package, so no import.
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.BOOLEAN)
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "javax.management", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(ImmutableSet.of(), typeSimplifier.typesToImport());
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testImportsForPlainTypes() {
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeMirrorOf("java.lang.String"),
>, <Line: -          typeMirrorOf("java.net.Proxy"),
>, <Line: -          typeMirrorOf("java.net.Proxy.Type"),
>, <Line: -          typeMirrorOf("java.util.regex.Pattern"),
>, <Line: -          typeMirrorOf("javax.management.MBeanServer"));
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.net.Proxy",
>, <Line: -          "java.util.regex.Pattern",
>, <Line: -          "javax.management.MBeanServer"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -      assertEquals("Proxy", typeSimplifier.simplify(typeMirrorOf("java.net.Proxy")));
>, <Line: -      assertEquals("Proxy.Type", typeSimplifier.simplify(typeMirrorOf("java.net.Proxy.Type")));
>, <Line: -    @Test
>, <Line: -    public void testImportsForComplicatedTypes() {
>, <Line: -      TypeElement list = typeElementOf("java.util.List");
>, <Line: -      TypeElement map = typeElementOf("java.util.Map");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeMirrorOf("java.util.regex.Pattern"),
>, <Line: -          typeUtil.getDeclaredType(list,  // List<Timer>
>, <Line: -              typeMirrorOf("java.util.Timer")),
>, <Line: -          typeUtil.getDeclaredType(map,   // Map<? extends Timer, ? super BigInteger>
>, <Line: -              typeUtil.getWildcardType(typeMirrorOf("java.util.Timer"), null),
>, <Line: -              typeUtil.getWildcardType(null, typeMirrorOf("java.math.BigInteger"))));
>, <Line: -      // Timer is referenced twice but should obviously only be imported once.
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.math.BigInteger",
>, <Line: -          "java.util.List",
>, <Line: -          "java.util.Map",
>, <Line: -          "java.util.Timer",
>, <Line: -          "java.util.regex.Pattern"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -    @Test
>, <Line: -    public void testImportsForArrayTypes() {
>, <Line: -      TypeElement list = typeElementOf("java.util.List");
>, <Line: -      TypeElement set = typeElementOf("java.util.Set");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeUtil.getArrayType(typeUtil.getPrimitiveType(TypeKind.INT)),
>, <Line: -          typeUtil.getArrayType(typeMirrorOf("java.util.regex.Pattern")),
>, <Line: -          typeUtil.getArrayType(          // Set<Matcher[]>[]
>, <Line: -              typeUtil.getDeclaredType(set,
>, <Line: -                  typeUtil.getArrayType(typeMirrorOf("java.util.regex.Matcher")))),
>, <Line: -          typeUtil.getDeclaredType(list,  // List<Timer[]>
>, <Line: -              typeUtil.getArrayType(typeMirrorOf("java.util.Timer"))));
>, <Line: -      // Timer is referenced twice but should obviously only be imported once.
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.util.List",
>, <Line: -          "java.util.Set",
>, <Line: -          "java.util.Timer",
>, <Line: -          "java.util.regex.Matcher",
>, <Line: -          "java.util.regex.Pattern"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testImportsForDefaultPackage() {
>, <Line: -      Set<TypeMirror> types = typeMirrorSet();
>, <Line: -      for (String className : CLASS_TO_SOURCE.keySet()) {
>, <Line: -        assertTrue(types.add(typeMirrorOf(className)));
>, <Line: -        // These are all in the default package so they don't need to be imported.
>, <Line: -        // But MultipleBounds references java.util.List so that will be imported.
>, <Line: -      types.addAll(typeMirrorSet(
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeMirrorOf("java.lang.String"),
>, <Line: -          typeMirrorOf("java.net.Proxy"),
>, <Line: -          typeMirrorOf("java.net.Proxy.Type"),
>, <Line: -          typeMirrorOf("java.util.regex.Pattern"),
>, <Line: -          typeMirrorOf("javax.management.MBeanServer")));
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.net.Proxy",
>, <Line: -          "java.util.List",
>, <Line: -          "java.util.regex.Pattern",
>, <Line: -          "javax.management.MBeanServer"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -      assertEquals("Proxy", typeSimplifier.simplify(typeMirrorOf("java.net.Proxy")));
>, <Line: -      assertEquals("Proxy.Type", typeSimplifier.simplify(typeMirrorOf("java.net.Proxy.Type")));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testImportNestedType() {
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(typeMirrorOf("java.net.Proxy.Type"));
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.net.Proxy"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -      assertEquals("Proxy.Type", typeSimplifier.simplify(typeMirrorOf("java.net.Proxy.Type")));
>, <Line: -    @Test
>, <Line: -    public void testImportsForAmbiguousNames() {
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeMirrorOf("java.awt.List"),
>, <Line: -          typeMirrorOf("java.lang.String"),
>, <Line: -          typeMirrorOf("java.util.List"),
>, <Line: -          typeMirrorOf("java.util.Map")
>, <Line: -      );
>, <Line: -      List<String> expectedImports = ImmutableList.of(
>, <Line: -          "java.util.Map"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(expectedImports, typeSimplifier.typesToImport().asList());
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyJavaLangString() {
>, <Line: -      TypeMirror string = typeMirrorOf("java.lang.String");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(string);
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals("String", typeSimplifier.simplify(string));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyJavaLangThreadState() {
>, <Line: -      TypeMirror threadState = typeMirrorOf("java.lang.Thread.State");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(threadState);
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals("Thread.State", typeSimplifier.simplify(threadState));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyAmbiguousNames() {
>, <Line: -      TypeMirror javaAwtList = typeMirrorOf("java.awt.List");
>, <Line: -      TypeMirror javaUtilList = typeMirrorOf("java.util.List");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(javaAwtList, javaUtilList);
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(javaAwtList.toString(), typeSimplifier.simplify(javaAwtList));
>, <Line: -      assertEquals(javaUtilList.toString(), typeSimplifier.simplify(javaUtilList));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyJavaLangNamesake() {
>, <Line: -      TypeMirror javaLangType = typeMirrorOf("java.lang.RuntimePermission");
>, <Line: -      TypeMirror notJavaLangType = typeMirrorOf(
>, <Line: -          com.google.auto.value.processor.testclasses.RuntimePermission.class.getName());
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(javaLangType, notJavaLangType);
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      assertEquals(javaLangType.toString(), typeSimplifier.simplify(javaLangType));
>, <Line: -      assertEquals(notJavaLangType.toString(), typeSimplifier.simplify(notJavaLangType));
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyComplicatedTypes() {
>, <Line: -      TypeElement list = typeElementOf("java.util.List");
>, <Line: -      TypeElement map = typeElementOf("java.util.Map");
>, <Line: -      TypeMirror string = typeMirrorOf("java.lang.String");
>, <Line: -      TypeMirror integer = typeMirrorOf("java.lang.Integer");
>, <Line: -      TypeMirror pattern = typeMirrorOf("java.util.regex.Pattern");
>, <Line: -      TypeMirror timer = typeMirrorOf("java.util.Timer");
>, <Line: -      TypeMirror bigInteger = typeMirrorOf("java.math.BigInteger");
>, <Line: -      Set<TypeMirror> types = typeMirrorSet(
>, <Line: -          typeUtil.getPrimitiveType(TypeKind.INT),
>, <Line: -          typeUtil.getArrayType(typeUtil.getPrimitiveType(TypeKind.BYTE)),
>, <Line: -          pattern,
>, <Line: -          typeUtil.getArrayType(pattern),
>, <Line: -          typeUtil.getArrayType(typeUtil.getArrayType(pattern)),
>, <Line: -          typeUtil.getDeclaredType(list, typeUtil.getWildcardType(null, null)),
>, <Line: -          typeUtil.getDeclaredType(list, timer),
>, <Line: -          typeUtil.getDeclaredType(map, string, integer),
>, <Line: -          typeUtil.getDeclaredType(map,
>, <Line: -              typeUtil.getWildcardType(timer, null), typeUtil.getWildcardType(null, bigInteger)));
>, <Line: -      Set<String> expectedSimplifications = ImmutableSet.of(
>, <Line: -          "int",
>, <Line: -          "byte[]",
>, <Line: -          "Pattern",
>, <Line: -          "Pattern[]",
>, <Line: -          "Pattern[][]",
>, <Line: -          "List<?>",
>, <Line: -          "List<Timer>",
>, <Line: -          "Map<String, Integer>",
>, <Line: -          "Map<? extends Timer, ? super BigInteger>"
>, <Line: -      );
>, <Line: -      TypeSimplifier typeSimplifier =
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", types, baseWithoutContainedTypes());
>, <Line: -      Set<String> actualSimplifications = new HashSet<String>();
>, <Line: -      for (TypeMirror type : types) {
>, <Line: -        actualSimplifications.add(typeSimplifier.simplify(type));
>, <Line: -      assertEquals(expectedSimplifications, actualSimplifications);
>, <Line: -    }
>, <Line: -    @Test
>, <Line: -    public void testSimplifyMultipleBounds() {
>, <Line: -      TypeElement multipleBoundsElement = typeElementOf("MultipleBounds");
>, <Line: -      TypeMirror multipleBoundsMirror = multipleBoundsElement.asType();
>, <Line: -      TypeSimplifier typeSimplifier = new TypeSimplifier(typeUtil, "",
>, <Line: -          typeMirrorSet(multipleBoundsMirror), baseWithoutContainedTypes());
>, <Line: -      assertEquals(ImmutableSet.of("java.util.List"), typeSimplifier.typesToImport());
>, <Line: -      assertEquals("MultipleBounds<K, V>", typeSimplifier.simplify(multipleBoundsMirror));
>, <Line: -      assertEquals("<K extends List<V> & Comparable<K>, V>",
>, <Line: -          typeSimplifier.formalTypeParametersString(multipleBoundsElement));
>, <Line: -    // Test TypeSimplifier.isCastingUnchecked. We do this by examining the fields of the Erasure
>, <Line: -    // class that is defined in CLASS_TO_SOURCE. A field whose name ends with Yes has a type where
>, <Line: -    // isCastingUnchecked should return true, and one whose name ends with No has a type where
>, <Line: -    // isCastingUnchecked should return false.
>, <Line: -    @Test
>, <Line: -    public void testIsCastingUnchecked() {
>, <Line: -      TypeElement erasureClass = typeElementOf("Erasure");
>, <Line: -      List<VariableElement> fields = ElementFilter.fieldsIn(erasureClass.getEnclosedElements());
>, <Line: -      for (VariableElement field : fields) {
>, <Line: -        String fieldName = field.getSimpleName().toString();
>, <Line: -        boolean expectUnchecked;
>, <Line: -        if (fieldName.endsWith("Yes")) {
>, <Line: -          expectUnchecked = true;
>, <Line: -        } else if (fieldName.endsWith("No")) {
>, <Line: -          expectUnchecked = false;
>, <Line: -        } else {
>, <Line: -          throw new AssertionError("Fields in Erasure class must end with Yes or No: " + fieldName);
>, <Line: -        }
>, <Line: -        TypeMirror fieldType = field.asType();
>, <Line: -        boolean actualUnchecked = TypeSimplifier.isCastingUnchecked(fieldType);
>, <Line: -        assertEquals("Unchecked-cast status for " + fieldType, expectUnchecked, actualUnchecked);
>, <Line: -  }
>, <Line: -  private static class ErrorTestProcessor extends AbstractTestProcessor {
>, <Line: -    public void testErrorTypes() {
>, <Line: -      TypeElement extendsUndefinedType =
>, <Line: -          processingEnv.getElementUtils().getTypeElement("ExtendsUndefinedType");
>, <Line: -      ErrorType errorType = (ErrorType) extendsUndefinedType.getSuperclass();
>, <Line: -      TypeMirror javaLangObject = typeMirrorOf("java.lang.Object");
>, <Line: -      TypeElement list = typeElementOf("java.util.List");
>, <Line: -      TypeMirror listOfError = typeUtil.getDeclaredType(list, errorType);
>, <Line: -      TypeMirror queryExtendsError = typeUtil.getWildcardType(errorType, null);
>, <Line: -      TypeMirror listOfQueryExtendsError = typeUtil.getDeclaredType(list, queryExtendsError);
>, <Line: -      TypeMirror querySuperError = typeUtil.getWildcardType(null, errorType);
>, <Line: -      TypeMirror listOfQuerySuperError = typeUtil.getDeclaredType(list, querySuperError);
>, <Line: -      TypeMirror arrayOfError = typeUtil.getArrayType(errorType);
>, <Line: -      TypeMirror[] typesWithErrors = {
>, <Line: -          errorType, listOfError, listOfQueryExtendsError, listOfQuerySuperError, arrayOfError
>, <Line: -      };
>, <Line: -      for (TypeMirror typeWithError : typesWithErrors) {
>, <Line: -        try {
>, <Line: -          new TypeSimplifier(typeUtil, "foo.bar", ImmutableSet.of(typeWithError), javaLangObject);
>, <Line: -          fail("Expected exception for type: " + typeWithError);
>, <Line: -        } catch (MissingTypeException expected) {
>, <Line: -        }
>, <Line: -      }
>]