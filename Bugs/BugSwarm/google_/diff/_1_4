[<Line: +      collectAliasCandidates(t, referenceMap);
>, <Line: +      doInlinesForScope(t, referenceMap);
>, <Line: +        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
>, <Line: +      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
>, <Line: +        Var v = it.next();
>]
[<Line: -import com.google.common.collect.ImmutableList;
>, <Line: -      if (NodeUtil.isFunctionBlock(t.getScopeRoot())
>, <Line: -          || t.inGlobalScope()
>, <Line: -          // Since the catch variable is scoped to the catch block, this special
>, <Line: -          // case is needed to inline a catch alias
>, <Line: -          || NodeUtil.isTryCatchNodeContainer(t.getScopeRoot())) {
>, <Line: -        collectAliasCandidates(t, referenceMap);
>, <Line: -        doInlinesForScope(t, referenceMap);
>, <Line: -      }
>, <Line: -        for (Iterator<Var> it = t.getScope().getClosestHoistScope().getFunctionVars();
>, <Line: -              it.hasNext();) {
>, <Line: -      // TODO(user): fix removing from Iterator issue so we don't have to copy to a List
>, <Line: -      List<Var> vars = ImmutableList.copyOf(t.getScope().getFunctionVars());
>, <Line: -      for (Var v : vars) {
>, <Line: -      if (!NodeUtil.isBlockScopedDeclaration(decl.getNode())) {
>, <Line: -        decl.getScope().getClosestHoistScope().undeclare(decl.getSymbol());
>, <Line: -      }
>]