[<Line: +"""
>, <Line: +    verktyg.http.accept
>, <Line: +    ~~~~~~~~~~~~~~~~~~~
>, <Line: +    :copyright:
>, <Line: +        (c) 2015 Ben Mather
>, <Line: +    :license:
>, <Line: +        BSD, see LICENSE for more details.
>, <Line: +"""
>, <Line: +import re
>, <Line: +import functools
>, <Line: +from verktyg.datastructures import ImmutableDict
>, <Line: +from verktyg.exceptions import NotAcceptable
>, <Line: +_token_re_str = r'''
>, <Line: +    (?:
>, <Line: +        [a-zA-Z0-9]+
>, <Line: +        (?:
>, <Line: +            - [a-zA-Z0-9]+
>, <Line: +        )*
>, <Line: +    )
>, <Line: +'''
>, <Line: +# TODO
>, <Line: +_value_re = re.compile(
>, <Line: +    r'''
>, <Line: +        ^
>, <Line: +        ''' + _token_re_str + ''' | \*
>, <Line: +        $
>, <Line: +    ''', re.VERBOSE
>, <Line: +)
>, <Line: +# TODO
>, <Line: +_content_type_value_re = re.compile(
>, <Line: +    r'''
>, <Line: +        ^
>, <Line: +        (?: ''' + _token_re_str + ''' | \*)
>, <Line: +        /
>, <Line: +        (?:
>, <Line: +            (?:
>, <Line: +                (?:''' + _token_re_str + ''' \.)?
>, <Line: +                ''' + _token_re_str + '''
>, <Line: +                (?: \+ ''' + _token_re_str + ''')?
>, <Line: +            ) | \*
>, <Line: +        )
>, <Line: +    ''', re.VERBOSE
>, <Line: +)
>, <Line: +# TODO better name
>, <Line: +class _Value(object):
>, <Line: +    """Base class for a value that the server to be proposed during content
>, <Line: +    negotiation.
>, <Line: +    """
>, <Line: +    match_type = None
>, <Line: +    def __init__(self, value, *, qs=None):
>, <Line: +        self.value = value
>, <Line: +        self.qs = qs
>, <Line: +    def _acceptability_for_option(self, option):
>, <Line: +        if option.value == '*':
>, <Line: +            exact_match = False
>, <Line: +        elif self.value == option.value:
>, <Line: +            exact_match = True
>, <Line: +        else:
>, <Line: +            raise NotAcceptable()
>, <Line: +        return self.match_type(
>, <Line: +            self, exact_match=exact_match,
>, <Line: +            q=option.q, qs=self.qs
>, <Line: +        )
>, <Line: +    def acceptability(self, accept):
>, <Line: +        best_match = None
>, <Line: +        for option in accept:
>, <Line: +            try:
>, <Line: +                match = self._acceptability_for_option(option)
>, <Line: +            except NotAcceptable:
>, <Line: +                pass
>, <Line: +            else:
>, <Line: +                if best_match is None or match > best_match:
>, <Line: +                    best_match = match
>, <Line: +        if best_match is None:
>, <Line: +            raise NotAcceptable()
>, <Line: +        return best_match
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def to_header(self):
>, <Line: +        """Returns a string suitable for use in the corresponding header
>, <Line: +        """
>, <Line: +        return self.value
>, <Line: +class _Range(object):
>, <Line: +    def __init__(self, value, q=1.0, params=None):
>, <Line: +        self._validate_value(value)
>, <Line: +        self.value = value
>, <Line: +        self.q = max(min(float(q), 1.0), 0.0)
>, <Line: +        if params is None:
>, <Line: +            params = {}
>, <Line: +        for param in params.items():
>, <Line: +            self._validate_param(*param)
>, <Line: +        self.params = ImmutableDict(params)
>, <Line: +    def _validate_value(self, value):
>, <Line: +        if _value_re.match(value) is None:
>, <Line: +            raise ValueError("Invalid value: %r" % value)
>, <Line: +    def _validate_param(self, key, value):
>, <Line: +        return
>, <Line: +    def to_header(self):
>, <Line: +        header = self.value
>, <Line: +        if self.q != 1:
>, <Line: +            header += ';q=%s' % self.q
>, <Line: +        for param in self.params.items():
>, <Line: +            # TODO escaping?
>, <Line: +            header += ';%s=%s' % param
>, <Line: +        return header
>, <Line: +class _Accept(object):
>, <Line: +    range_type = None
>, <Line: +    def __init__(self, options):
>, <Line: +        self._options = []
>, <Line: +        for option in options:
>, <Line: +            if isinstance(option, str):
>, <Line: +                option = (option,)
>, <Line: +            self._options.append(self.range_type(*option))
>, <Line: +    def __iter__(self):
>, <Line: +        return iter(self._options)
>, <Line: +    def __contains__(self, value):
>, <Line: +        try:
>, <Line: +            value.acceptability(self)
>, <Line: +        except NotAcceptable:
>, <Line: +            return False
>, <Line: +        else:
>, <Line: +            return True
>, <Line: +    def __getitem__(self, value):
>, <Line: +        try:
>, <Line: +            return value.acceptability(self)
>, <Line: +        except NotAcceptable as e:
>, <Line: +            raise KeyError() from e
>, <Line: +    def __repr__(self):
>, <Line: +        raise NotImplementedError()
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def to_header(self):
>, <Line: +        """Return an equivalent string suitable for use as an `Accept` header.
>, <Line: +        """
>, <Line: +        return ','.join(option.to_header() for option in self)
>, <Line: +@functools.total_ordering
>, <Line: +class _Acceptibility(object):
>, <Line: +    def __init__(self, value, *, match_quality, q, qs=None):
>, <Line: +        self._value = value
>, <Line: +        self._match_quality = match_quality
>, <Line: +        self._q = q
>, <Line: +        self._qs = qs
>, <Line: +    @property
>, <Line: +    def exact_match(self):
>, <Line: +        return bool(self._match_quality)
>, <Line: +    @property
>, <Line: +    def quality(self):
>, <Line: +        if self._qs is not None:
>, <Line: +            return self._q * self._qs
>, <Line: +        return self._q
>, <Line: +    def __eq__(self, other):
>, <Line: +        if other is None:
>, <Line: +            return False
>, <Line: +        if self._match_quality != other._match_quality:
>, <Line: +            return False
>, <Line: +        if self.quality != other.quality:
>, <Line: +            return False
>, <Line: +        return True
>, <Line: +    def __gt__(self, other):
>, <Line: +        if other is None:
>, <Line: +            return True
>, <Line: +        if self._match_quality > other._match_quality:
>, <Line: +            return True
>, <Line: +        if self.quality > other.quality:
>, <Line: +            return True
>, <Line: +        return False
>, <Line: +class _ContentTypeRange(_Range):
>, <Line: +    def _validate_value(self, value):
>, <Line: +        if _content_type_value_re.match(value) is None:
>, <Line: +            raise ValueError("Invalid value: %r" % value)
>, <Line: +    @property
>, <Line: +    def type(self):
>, <Line: +        type, _ = self.value.split('/')
>, <Line: +        return type
>, <Line: +    @property
>, <Line: +    def subtype(self):
>, <Line: +        _, subtype = self.value.split('/')
>, <Line: +        return subtype
>, <Line: +class ContentTypeAccept(_Accept):
>, <Line: +    range_type = _ContentTypeRange
>, <Line: +class ContentTypeAcceptibility(_Acceptibility):
>, <Line: +    def __init__(
>, <Line: +                self, content_type, *,
>, <Line: +                type_matches, subtype_matches,
>, <Line: +                q, qs=None
>, <Line: +            ):
>, <Line: +        super(ContentTypeAcceptibility, self).__init__(
>, <Line: +            content_type, match_quality=(
>, <Line: +                type_matches, subtype_matches
>, <Line: +            ),
>, <Line: +            q=q, qs=qs
>, <Line: +        )
>, <Line: +    @property
>, <Line: +    def content_type(self):
>, <Line: +        return self._value
>, <Line: +    @property
>, <Line: +    def type_matches(self):
>, <Line: +        return self._match_quality[0]
>, <Line: +    @property
>, <Line: +    def subtype_matches(self):
>, <Line: +        return self._match_quality[1]
>, <Line: +    @property
>, <Line: +    def exact_match(self):
>, <Line: +        return self._match_quality[0] and self._match_quality[1]
>, <Line: +class ContentType(_Value):
>, <Line: +    match_type = ContentTypeAcceptibility
>, <Line: +    @property
>, <Line: +    def type(self):
>, <Line: +        type, _ = self.value.split('/')
>, <Line: +        return type
>, <Line: +    @property
>, <Line: +    def subtype(self):
>, <Line: +        _, subtype = self.value.split('/')
>, <Line: +        return subtype
>, <Line: +    def _acceptability_for_option(self, option):
>, <Line: +        if option.type == self.type:
>, <Line: +            type_matches = True
>, <Line: +        elif option.type == '*':
>, <Line: +            type_matches = False
>, <Line: +        else:
>, <Line: +            raise NotAcceptable()
>, <Line: +        if option.subtype == self.subtype:
>, <Line: +            subtype_matches = True
>, <Line: +        elif option.subtype == '*':
>, <Line: +            subtype_matches = False
>, <Line: +        else:
>, <Line: +            raise NotAcceptable()
>, <Line: +        return self.match_type(
>, <Line: +            self, type_matches=type_matches, subtype_matches=subtype_matches,
>, <Line: +            qs=self.qs, q=option.q
>, <Line: +        )
>, <Line: +    def to_header(self):
>, <Line: +        """Returns a string suitable for use as a `Content-Type` header.
>, <Line: +        """
>, <Line: +        return "%s/%s" % (self.type, self.subtype)
>, <Line: +def _split_accept_string(string):
>, <Line: +    for accept_range in string.split(','):
>, <Line: +        accept, *str_params = accept_range.split(';')
>, <Line: +        params = {}
>, <Line: +        for param in str_params:
>, <Line: +            try:
>, <Line: +                key, value = param.split('=', 1)
>, <Line: +            except ValueError as e:
>, <Line: +                raise ValueError("invalid parameter: %r" % param) from e
>, <Line: +            key, value = key.strip(), value.strip()
>, <Line: +            params[key] = value
>, <Line: +        q = params.pop('q', '1.0')
>, <Line: +        yield accept.strip(), q, params
>, <Line: +def parse_accept_header(string):
>, <Line: +    """Creates a new `ContentTypeAccept` object from an `Accept` header string.
>, <Line: +    """
>, <Line: +    return ContentTypeAccept(_split_accept_string(string))
>, <Line: +def parse_content_type_header(string, qs=None):
>, <Line: +    """Creates a new `ContentType` object from a mime type string.
>, <Line: +    """
>, <Line: +    return ContentType(string, qs=qs)
>, <Line: +class _LanguageRange(_Range):
>, <Line: +    def _validate_param(self, key, value):
>, <Line: +        raise ValueError("Accept-Language header does not take parameters")
>, <Line: +class LanguageAccept(_Accept):
>, <Line: +    range_type = _LanguageRange
>, <Line: +class LanguageAcceptibility(_Acceptibility):
>, <Line: +    def __init__(
>, <Line: +                self, content_type, *,
>, <Line: +                specificity, tail,
>, <Line: +                q, qs=None
>, <Line: +            ):
>, <Line: +        super(LanguageAcceptibility, self).__init__(
>, <Line: +            content_type, match_quality=(-tail, specificity), q=q, qs=qs
>, <Line: +        )
>, <Line: +    @property
>, <Line: +    def language(self):
>, <Line: +        return self._value
>, <Line: +    @property
>, <Line: +    def specificity(self):
>, <Line: +        return self._match_quality[1]
>, <Line: +    @property
>, <Line: +    def tail(self):
>, <Line: +        return -self._match_quality[0]
>, <Line: +    @property
>, <Line: +    def exact_match(self):
>, <Line: +        return not self.tail
>, <Line: +class Language(_Value):
>, <Line: +    match_type = LanguageAcceptibility
>, <Line: +    def _acceptability_for_option(self, option):
>, <Line: +        if self.value == option.value:
>, <Line: +            specificity = len(list(option.value.split('-')))
>, <Line: +            tail = 0
>, <Line: +        elif self.value.startswith('%s-' % option.value):
>, <Line: +            specificity = len(list(option.value.split('-')))
>, <Line: +            tail = len(list(self.value.split('-'))) - specificity
>, <Line: +        elif option.value == '*':
>, <Line: +            specificity = 0
>, <Line: +            tail = len(list(self.value.split('-')))
>, <Line: +        else:
>, <Line: +            raise NotAcceptable()
>, <Line: +        return self.match_type(
>, <Line: +            self, specificity=specificity, tail=tail,
>, <Line: +            qs=self.qs, q=option.q
>, <Line: +        )
>, <Line: +def parse_accept_language_header(string):
>, <Line: +    return LanguageAccept(_split_accept_string(string))
>, <Line: +def parse_language_header(string):
>, <Line: +    return Language(string)
>, <Line: +class _CharsetRange(_Range):
>, <Line: +    def _validate_param(self, key, value):
>, <Line: +        raise ValueError("Accept-Charset header does not take parameters")
>, <Line: +class CharsetAccept(_Accept):
>, <Line: +    range_type = _CharsetRange
>, <Line: +class CharsetAcceptibility(_Acceptibility):
>, <Line: +    def __init__(self, value, *, exact_match, q, qs=None):
>, <Line: +        super(CharsetAcceptibility, self).__init__(
>, <Line: +            value, match_quality=exact_match, q=q, qs=qs
>, <Line: +        )
>, <Line: +    @property
>, <Line: +    def charset(self):
>, <Line: +        return self._value
>, <Line: +    @property
>, <Line: +    def exact_match(self):
>, <Line: +        return self._match_quality
>, <Line: +class Charset(_Value):
>, <Line: +    match_type = CharsetAcceptibility
>, <Line: +def parse_accept_charset_header(string):
>, <Line: +    return CharsetAccept(_split_accept_string(string))
>, <Line: +def parse_charset_header(string):
>, <Line: +    return Charset(string)
>, <Line: +__all__ = [
>, <Line: +    'ContentType', 'ContentTypeAccept',
>, <Line: +    'parse_content_type_header', 'parse_accept_header',
>, <Line: +    'Language', 'LanguageAccept',
>, <Line: +    'parse_language_header', 'parse_accept_language_header',
>, <Line: +    'Charset', 'CharsetAccept',
>, <Line: +    'parse_charset_header', 'parse_accept_charset_header',
>, <Line: +]
>]
[]