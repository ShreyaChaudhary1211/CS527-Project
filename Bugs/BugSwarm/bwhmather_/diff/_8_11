[<Line: +"""
>, <Line: +    verktyg.http.cache_control
>, <Line: +    ~~~~~~~~~~~~~~~~~~~~~~~~~~
>, <Line: +    :copyright:
>, <Line: +        (c) 2015 Ben Mather, based on Werkzeug, see AUTHORS for more details.
>, <Line: +    :license:
>, <Line: +        BSD, see LICENSE for more details.
>, <Line: +"""
>, <Line: +import re
>, <Line: +from hashlib import md5
>, <Line: +from verktyg import datastructures
>, <Line: +from verktyg.http.basic import (
>, <Line: +    is_byte_range_valid, parse_date, dump_header, parse_dict_header, http_date,
>, <Line: +)
>, <Line: +_etag_re = re.compile(r'([Ww]/)?(?:"(.*?)"|(.*?))(?:\s*,\s*|$)')
>, <Line: +class IfRange(object):
>, <Line: +    """Very simple object that represents the `If-Range` header in parsed
>, <Line: +    form.  It will either have neither a etag or date or one of either but
>, <Line: +    never both.
>, <Line: +    """
>, <Line: +    def __init__(self, etag=None, date=None):
>, <Line: +        #: The etag parsed and unquoted.  Ranges always operate on strong
>, <Line: +        #: etags so the weakness information is not necessary.
>, <Line: +        self.etag = etag
>, <Line: +        #: The date in parsed format or `None`.
>, <Line: +        self.date = date
>, <Line: +    def to_header(self):
>, <Line: +        """Converts the object back into an HTTP header."""
>, <Line: +        if self.date is not None:
>, <Line: +            return http_date(self.date)
>, <Line: +        if self.etag is not None:
>, <Line: +            return quote_etag(self.etag)
>, <Line: +        return ''
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: +def parse_if_range_header(value):
>, <Line: +    """Parses an if-range header which can be an etag or a date.  Returns
>, <Line: +    a :class:`~IfRange` object.
>, <Line: +    """
>, <Line: +    if not value:
>, <Line: +        return IfRange()
>, <Line: +    date = parse_date(value)
>, <Line: +    if date is not None:
>, <Line: +        return IfRange(date=date)
>, <Line: +    # drop weakness information
>, <Line: +    return IfRange(unquote_etag(value)[0])
>, <Line: +class Range(object):
>, <Line: +    """Represents a range header.  All the methods are only supporting bytes
>, <Line: +    as unit.  It does store multiple ranges but :meth:`range_for_length` will
>, <Line: +    only work if only one range is provided.
>, <Line: +    """
>, <Line: +    def __init__(self, units, ranges):
>, <Line: +        #: The units of this range.  Usually "bytes".
>, <Line: +        self.units = units
>, <Line: +        #: A list of ``(begin, end)`` tuples for the range header provided.
>, <Line: +        #: The ranges are non-inclusive.
>, <Line: +        self.ranges = ranges
>, <Line: +    def range_for_length(self, length):
>, <Line: +        """If the range is for bytes, the length is not None and there is
>, <Line: +        exactly one range and it is satisfiable it returns a ``(start, stop)``
>, <Line: +        tuple, otherwise `None`.
>, <Line: +        """
>, <Line: +        if self.units != 'bytes' or length is None or len(self.ranges) != 1:
>, <Line: +            return None
>, <Line: +        start, end = self.ranges[0]
>, <Line: +        if end is None:
>, <Line: +            end = length
>, <Line: +            if start < 0:
>, <Line: +                start += length
>, <Line: +        if is_byte_range_valid(start, end, length):
>, <Line: +            return start, min(end, length)
>, <Line: +    def make_content_range(self, length):
>, <Line: +        """Creates a :class:`~verktyg.datastructures.ContentRange` object
>, <Line: +        from the current range and given content length.
>, <Line: +        """
>, <Line: +        rng = self.range_for_length(length)
>, <Line: +        if rng is not None:
>, <Line: +            return ContentRange(self.units, rng[0], rng[1], length)
>, <Line: +    def to_header(self):
>, <Line: +        """Converts the object back into an HTTP header."""
>, <Line: +        ranges = []
>, <Line: +        for begin, end in self.ranges:
>, <Line: +            if end is None:
>, <Line: +                ranges.append(begin >= 0 and '%s-' % begin or str(begin))
>, <Line: +            else:
>, <Line: +                ranges.append('%s-%s' % (begin, end - 1))
>, <Line: +        return '%s=%s' % (self.units, ','.join(ranges))
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: +def parse_range_header(value, make_inclusive=True):
>, <Line: +    """Parses a range header into a :class:`~Range`
>, <Line: +    object.  If the header is missing or malformed `None` is returned.
>, <Line: +    `ranges` is a list of ``(start, stop)`` tuples where the ranges are
>, <Line: +    non-inclusive.
>, <Line: +    """
>, <Line: +    if not value or '=' not in value:
>, <Line: +        return None
>, <Line: +    ranges = []
>, <Line: +    last_end = 0
>, <Line: +    units, rng = value.split('=', 1)
>, <Line: +    units = units.strip().lower()
>, <Line: +    for item in rng.split(','):
>, <Line: +        item = item.strip()
>, <Line: +        if '-' not in item:
>, <Line: +            return None
>, <Line: +        if item.startswith('-'):
>, <Line: +            if last_end < 0:
>, <Line: +                return None
>, <Line: +            begin = int(item)
>, <Line: +            end = None
>, <Line: +            last_end = -1
>, <Line: +        elif '-' in item:
>, <Line: +            begin, end = item.split('-', 1)
>, <Line: +            begin = int(begin)
>, <Line: +            if begin < last_end or last_end < 0:
>, <Line: +                return None
>, <Line: +            if end:
>, <Line: +                end = int(end) + 1
>, <Line: +                if begin >= end:
>, <Line: +                    return None
>, <Line: +            else:
>, <Line: +                end = None
>, <Line: +            last_end = end
>, <Line: +        ranges.append((begin, end))
>, <Line: +    return Range(units, ranges)
>, <Line: +class ContentRange(object):
>, <Line: +    """Represents the content range header.
>, <Line: +    """
>, <Line: +    def __init__(self, units, start, stop, length=None, on_update=None):
>, <Line: +        assert is_byte_range_valid(start, stop, length), \
>, <Line: +            'Bad range provided'
>, <Line: +        self.on_update = on_update
>, <Line: +        self.set(start, stop, length, units)
>, <Line: +    def _callback_property(name):
>, <Line: +        def fget(self):
>, <Line: +            return getattr(self, name)
>, <Line: +        def fset(self, value):
>, <Line: +            setattr(self, name, value)
>, <Line: +            if self.on_update is not None:
>, <Line: +                self.on_update(self)
>, <Line: +        return property(fget, fset)
>, <Line: +    #: The units to use, usually "bytes"
>, <Line: +    units = _callback_property('_units')
>, <Line: +    #: The start point of the range or `None`.
>, <Line: +    start = _callback_property('_start')
>, <Line: +    #: The stop point of the range (non-inclusive) or `None`.  Can only be
>, <Line: +    #: `None` if also start is `None`.
>, <Line: +    stop = _callback_property('_stop')
>, <Line: +    #: The length of the range or `None`.
>, <Line: +    length = _callback_property('_length')
>, <Line: +    def set(self, start, stop, length=None, units='bytes'):
>, <Line: +        """Simple method to update the ranges."""
>, <Line: +        assert is_byte_range_valid(start, stop, length), \
>, <Line: +            'Bad range provided'
>, <Line: +        self._units = units
>, <Line: +        self._start = start
>, <Line: +        self._stop = stop
>, <Line: +        self._length = length
>, <Line: +        if self.on_update is not None:
>, <Line: +            self.on_update(self)
>, <Line: +    def unset(self):
>, <Line: +        """Sets the units to `None` which indicates that the header should
>, <Line: +        no longer be used.
>, <Line: +        """
>, <Line: +        self.set(None, None, units=None)
>, <Line: +    def to_header(self):
>, <Line: +        if self.units is None:
>, <Line: +            return ''
>, <Line: +        if self.length is None:
>, <Line: +            length = '*'
>, <Line: +        else:
>, <Line: +            length = self.length
>, <Line: +        if self.start is None:
>, <Line: +            return '%s */%s' % (self.units, length)
>, <Line: +        return '%s %s-%s/%s' % (
>, <Line: +            self.units,
>, <Line: +            self.start,
>, <Line: +            self.stop - 1,
>, <Line: +            length
>, <Line: +        )
>, <Line: +    def __nonzero__(self):
>, <Line: +        return self.units is not None
>, <Line: +    __bool__ = __nonzero__
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: +def parse_content_range_header(value, on_update=None):
>, <Line: +    """Parses a range header into a
>, <Line: +    :class:`~ContentRange` object or `None` if
>, <Line: +    parsing is not possible.
>, <Line: +    :param value:
>, <Line: +        A content range header to be parsed.
>, <Line: +    :param on_update:
>, <Line: +        An optional callable that is called every time a value on the
>, <Line: +        :class:`~ContentRange` object is changed.
>, <Line: +    """
>, <Line: +    if value is None:
>, <Line: +        return None
>, <Line: +    try:
>, <Line: +        units, rangedef = (value or '').strip().split(None, 1)
>, <Line: +    except ValueError:
>, <Line: +        return None
>, <Line: +    if '/' not in rangedef:
>, <Line: +        return None
>, <Line: +    rng, length = rangedef.split('/', 1)
>, <Line: +    if length == '*':
>, <Line: +        length = None
>, <Line: +    elif length.isdigit():
>, <Line: +        length = int(length)
>, <Line: +    else:
>, <Line: +        return None
>, <Line: +    if rng == '*':
>, <Line: +        return ContentRange(units, None, None, length, on_update=on_update)
>, <Line: +    elif '-' not in rng:
>, <Line: +        return None
>, <Line: +    start, stop = rng.split('-', 1)
>, <Line: +    try:
>, <Line: +        start = int(start)
>, <Line: +        stop = int(stop) + 1
>, <Line: +    except ValueError:
>, <Line: +        return None
>, <Line: +    if is_byte_range_valid(start, stop, length):
>, <Line: +        return ContentRange(units, start, stop, length, on_update=on_update)
>, <Line: +def cache_property(key, empty, type):
>, <Line: +    """Return a new property object for a cache header.  Useful if you
>, <Line: +    want to add support for a cache extension in a subclass."""
>, <Line: +    return property(lambda x: x._get_cache_value(key, empty, type),
>, <Line: +                    lambda x, v: x._set_cache_value(key, v, type),
>, <Line: +                    lambda x: x._del_cache_value(key),
>, <Line: +                    'accessor for %r' % key)
>, <Line: +class _CacheControl(datastructures.UpdateDictMixin, dict):
>, <Line: +    """Subclass of a dict that stores values for a Cache-Control header.  It
>, <Line: +    has accessors for all the cache-control directives specified in RFC 2616.
>, <Line: +    The class does not differentiate between request and response directives.
>, <Line: +    Because the cache-control directives in the HTTP header use dashes the
>, <Line: +    python descriptors use underscores for that.
>, <Line: +    To get a header of the :class:`CacheControl` object again you can convert
>, <Line: +    the object into a string or call the :meth:`to_header` method.  If you plan
>, <Line: +    to subclass it and add your own items have a look at the sourcecode for
>, <Line: +    that class.
>, <Line: +    """
>, <Line: +    no_cache = cache_property('no-cache', '*', None)
>, <Line: +    no_store = cache_property('no-store', None, bool)
>, <Line: +    max_age = cache_property('max-age', -1, int)
>, <Line: +    no_transform = cache_property('no-transform', None, None)
>, <Line: +    def __init__(self, values=(), on_update=None):
>, <Line: +        dict.__init__(self, values or ())
>, <Line: +        self.on_update = on_update
>, <Line: +        self.provided = values is not None
>, <Line: +    def _get_cache_value(self, key, empty, type):
>, <Line: +        """Used internally by the accessor properties."""
>, <Line: +        if type is bool:
>, <Line: +            return key in self
>, <Line: +        if key in self:
>, <Line: +            value = self[key]
>, <Line: +            if value is None:
>, <Line: +                return empty
>, <Line: +            elif type is not None:
>, <Line: +                try:
>, <Line: +                    value = type(value)
>, <Line: +                except ValueError:
>, <Line: +                    pass
>, <Line: +            return value
>, <Line: +    def _set_cache_value(self, key, value, type):
>, <Line: +        """Used internally by the accessor properties."""
>, <Line: +        if type is bool:
>, <Line: +            if value:
>, <Line: +                self[key] = None
>, <Line: +            else:
>, <Line: +                self.pop(key, None)
>, <Line: +        else:
>, <Line: +            if value is None:
>, <Line: +                self.pop(key)
>, <Line: +            elif value is True:
>, <Line: +                self[key] = None
>, <Line: +            else:
>, <Line: +                self[key] = value
>, <Line: +    def _del_cache_value(self, key):
>, <Line: +        """Used internally by the accessor properties."""
>, <Line: +        if key in self:
>, <Line: +            del self[key]
>, <Line: +    def to_header(self):
>, <Line: +        """Convert the stored values into a cache control header."""
>, <Line: +        return dump_header(self)
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %s>' % (
>, <Line: +            self.__class__.__name__,
>, <Line: +            " ".join(
>, <Line: +                "%s=%r" % (k, v) for k, v in sorted(self.items())
>, <Line: +            ),
>, <Line: +        )
>, <Line: +class RequestCacheControl(datastructures.ImmutableDictMixin, _CacheControl):
>, <Line: +    """A cache control for requests.  This is immutable and gives access
>, <Line: +    to all the request-relevant cache control headers.
>, <Line: +    To get a header of the :class:`RequestCacheControl` object again you can
>, <Line: +    convert the object into a string or call the :meth:`to_header` method.  If
>, <Line: +    you plan to subclass it and add your own items have a look at the
>, <Line: +    sourcecode for that class.
>, <Line: +    """
>, <Line: +    max_stale = cache_property('max-stale', '*', int)
>, <Line: +    min_fresh = cache_property('min-fresh', '*', int)
>, <Line: +    no_transform = cache_property('no-transform', None, None)
>, <Line: +    only_if_cached = cache_property('only-if-cached', None, bool)
>, <Line: +class ResponseCacheControl(_CacheControl):
>, <Line: +    """A cache control for responses.  Unlike :class:`RequestCacheControl`
>, <Line: +    this is mutable and gives access to response-relevant cache control
>, <Line: +    headers.
>, <Line: +    To get a header of the :class:`ResponseCacheControl` object again you can
>, <Line: +    convert the object into a string or call the :meth:`to_header` method.  If
>, <Line: +    you plan to subclass it and add your own items have a look at the
>, <Line: +    sourcecode for that class.
>, <Line: +    """
>, <Line: +    public = cache_property('public', None, bool)
>, <Line: +    private = cache_property('private', '*', None)
>, <Line: +    must_revalidate = cache_property('must-revalidate', None, bool)
>, <Line: +    proxy_revalidate = cache_property('proxy-revalidate', None, bool)
>, <Line: +    s_maxage = cache_property('s-maxage', None, None)
>, <Line: +# attach cache_property to the _CacheControl as staticmethod
>, <Line: +# so that others can reuse it.
>, <Line: +_CacheControl.cache_property = staticmethod(cache_property)
>, <Line: +def parse_cache_control_header(value, on_update=None, cls=None):
>, <Line: +    """Parse a cache control header.  The RFC differs between response and
>, <Line: +    request cache control, this method does not.  It's your responsibility
>, <Line: +    to not use the wrong control statements.
>, <Line: +    :param value:
>, <Line: +        A cache control header to be parsed.
>, <Line: +    :param on_update:
>, <Line: +        An optional callable that is called every time a value on the
>, <Line: +        :class:`~verktyg.CacheControl` object is changed.
>, <Line: +    :param cls:
>, <Line: +        The class for the returned object.  By default
>, <Line: +        :class:`~verktyg.RequestCacheControl` is used.
>, <Line: +    :return:
>, <Line: +        A `cls` object.
>, <Line: +    """
>, <Line: +    if cls is None:
>, <Line: +        cls = RequestCacheControl
>, <Line: +    if not value:
>, <Line: +        return cls(None, on_update)
>, <Line: +    return cls(parse_dict_header(value), on_update)
>, <Line: +def quote_etag(etag, weak=False):
>, <Line: +    """Quote an etag.
>, <Line: +    :param etag:
>, <Line: +        The etag to quote.
>, <Line: +    :param weak:
>, <Line: +        Set to `True` to tag it "weak".
>, <Line: +    """
>, <Line: +    if '"' in etag:
>, <Line: +        raise ValueError('invalid etag')
>, <Line: +    etag = '"%s"' % etag
>, <Line: +    if weak:
>, <Line: +        etag = 'w/' + etag
>, <Line: +    return etag
>, <Line: +def unquote_etag(etag):
>, <Line: +    """Unquote a single etag:
>, <Line: +    >>> unquote_etag('w/"bar"')
>, <Line: +    ('bar', True)
>, <Line: +    >>> unquote_etag('"bar"')
>, <Line: +    ('bar', False)
>, <Line: +    :param etag:
>, <Line: +        The etag identifier to unquote.
>, <Line: +    :return:
>, <Line: +        An ``(etag, weak)`` tuple.
>, <Line: +    """
>, <Line: +    if not etag:
>, <Line: +        return None, None
>, <Line: +    etag = etag.strip()
>, <Line: +    weak = False
>, <Line: +    if etag[:2] in ('w/', 'W/'):
>, <Line: +        weak = True
>, <Line: +        etag = etag[2:]
>, <Line: +    if etag[:1] == etag[-1:] == '"':
>, <Line: +        etag = etag[1:-1]
>, <Line: +    return etag, weak
>, <Line: +class ETags(object):
>, <Line: +    """A set that can be used to check if one etag is present in a collection
>, <Line: +    of etags.
>, <Line: +    """
>, <Line: +    def __init__(self, strong_etags=None, weak_etags=None, star_tag=False):
>, <Line: +        self._strong = frozenset(not star_tag and strong_etags or ())
>, <Line: +        self._weak = frozenset(weak_etags or ())
>, <Line: +        self.star_tag = star_tag
>, <Line: +    def as_set(self, include_weak=False):
>, <Line: +        """Convert the `ETags` object into a python set.  Per default all the
>, <Line: +        weak etags are not part of this set."""
>, <Line: +        rv = set(self._strong)
>, <Line: +        if include_weak:
>, <Line: +            rv.update(self._weak)
>, <Line: +        return rv
>, <Line: +    def is_weak(self, etag):
>, <Line: +        """Check if an etag is weak."""
>, <Line: +        return etag in self._weak
>, <Line: +    def contains_weak(self, etag):
>, <Line: +        """Check if an etag is part of the set including weak and strong tags.
>, <Line: +        """
>, <Line: +        return self.is_weak(etag) or self.contains(etag)
>, <Line: +    def contains(self, etag):
>, <Line: +        """Check if an etag is part of the set ignoring weak tags.
>, <Line: +        It is also possible to use the ``in`` operator.
>, <Line: +        """
>, <Line: +        if self.star_tag:
>, <Line: +            return True
>, <Line: +        return etag in self._strong
>, <Line: +    def contains_raw(self, etag):
>, <Line: +        """When passed a quoted tag it will check if this tag is part of the
>, <Line: +        set.  If the tag is weak it is checked against weak and strong tags,
>, <Line: +        otherwise strong only."""
>, <Line: +        etag, weak = unquote_etag(etag)
>, <Line: +        if weak:
>, <Line: +            return self.contains_weak(etag)
>, <Line: +        return self.contains(etag)
>, <Line: +    def to_header(self):
>, <Line: +        """Convert the etags set into a HTTP header string."""
>, <Line: +        if self.star_tag:
>, <Line: +            return '*'
>, <Line: +        return ', '.join(
>, <Line: +            ['"%s"' % x for x in self._strong] +
>, <Line: +            ['w/"%s"' % x for x in self._weak]
>, <Line: +        )
>, <Line: +    def __call__(self, etag=None, data=None, include_weak=False):
>, <Line: +        if [etag, data].count(None) != 1:
>, <Line: +            raise TypeError('either tag or data required, but at least one')
>, <Line: +        if etag is None:
>, <Line: +            etag = generate_etag(data)
>, <Line: +        if include_weak:
>, <Line: +            if etag in self._weak:
>, <Line: +                return True
>, <Line: +        return etag in self._strong
>, <Line: +    def __bool__(self):
>, <Line: +        return bool(self.star_tag or self._strong or self._weak)
>, <Line: +    __nonzero__ = __bool__
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __iter__(self):
>, <Line: +        return iter(self._strong)
>, <Line: +    def __contains__(self, etag):
>, <Line: +        return self.contains(etag)
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: +def parse_etags(value):
>, <Line: +    """Parse an etag header.
>, <Line: +    :param value:
>, <Line: +        The tag header to parse
>, <Line: +    :return:
>, <Line: +        An :class:`~ETags` object.
>, <Line: +    """
>, <Line: +    if not value:
>, <Line: +        return ETags()
>, <Line: +    strong = []
>, <Line: +    weak = []
>, <Line: +    end = len(value)
>, <Line: +    pos = 0
>, <Line: +    while pos < end:
>, <Line: +        match = _etag_re.match(value, pos)
>, <Line: +        if match is None:
>, <Line: +            break
>, <Line: +        is_weak, quoted, raw = match.groups()
>, <Line: +        if raw == '*':
>, <Line: +            return ETags(star_tag=True)
>, <Line: +        elif quoted:
>, <Line: +            raw = quoted
>, <Line: +        if is_weak:
>, <Line: +            weak.append(raw)
>, <Line: +        else:
>, <Line: +            strong.append(raw)
>, <Line: +        pos = match.end()
>, <Line: +    return ETags(strong, weak)
>, <Line: +def generate_etag(data):
>, <Line: +    """Generate an etag for some data."""
>, <Line: +    return md5(data).hexdigest()
>, <Line: +def is_resource_modified(environ, etag=None, data=None, last_modified=None):
>, <Line: +    """Convenience method for conditional requests.
>, <Line: +    :param environ:
>, <Line: +        The WSGI environment of the request to be checked.
>, <Line: +    :param etag:
>, <Line: +        The etag for the response for comparison.
>, <Line: +    :param data:
>, <Line: +        Or alternatively the data of the response to automatically generate an
>, <Line: +        etag using :func:`generate_etag`.
>, <Line: +    :param last_modified:
>, <Line: +        An optional date of the last modification.
>, <Line: +    :return:
>, <Line: +        `True` if the resource was modified, otherwise `False`.
>, <Line: +    """
>, <Line: +    if etag is None and data is not None:
>, <Line: +        etag = generate_etag(data)
>, <Line: +    elif data is not None:
>, <Line: +        raise TypeError('both data and etag given')
>, <Line: +    if environ['REQUEST_METHOD'] not in ('GET', 'HEAD'):
>, <Line: +        return False
>, <Line: +    unmodified = False
>, <Line: +    if isinstance(last_modified, str):
>, <Line: +        last_modified = parse_date(last_modified)
>, <Line: +    # ensure that microsecond is zero because the HTTP spec does not transmit
>, <Line: +    # that either and we might have some false positives.  See issue #39
>, <Line: +    if last_modified is not None:
>, <Line: +        last_modified = last_modified.replace(microsecond=0)
>, <Line: +    modified_since = parse_date(environ.get('HTTP_IF_MODIFIED_SINCE'))
>, <Line: +    if modified_since and last_modified and last_modified <= modified_since:
>, <Line: +        unmodified = True
>, <Line: +    if etag:
>, <Line: +        if_none_match = parse_etags(environ.get('HTTP_IF_NONE_MATCH'))
>, <Line: +        if if_none_match:
>, <Line: +            unmodified = if_none_match.contains_raw(etag)
>, <Line: +    return not unmodified
>]
[]