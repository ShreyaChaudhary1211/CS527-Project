[<Line: +"""
>, <Line: +    verktyg.http.auth
>, <Line: +    ~~~~~~~~~~~~~~~~~
>, <Line: +    :copyright:
>, <Line: +        (c) 2015 Ben Mather, based on Werkzeug, see AUTHORS for more details.
>, <Line: +    :license:
>, <Line: +        BSD, see LICENSE for more details.
>, <Line: +"""
>, <Line: +import base64
>, <Line: +from verktyg import datastructures
>, <Line: +from verktyg.http.basic import (
>, <Line: +    wsgi_to_bytes, bytes_to_wsgi, parse_dict_header,
>, <Line: +    dump_header, quote_header_value, parse_set_header,
>, <Line: +)
>, <Line: +class Authorization(datastructures.ImmutableDictMixin, dict):
>, <Line: +    """Represents an `Authorization` header sent by the client.  You should
>, <Line: +    not create this kind of object yourself but use it when it's returned by
>, <Line: +    the `parse_authorization_header` function.
>, <Line: +    This object is a dict subclass and can be altered by setting dict items
>, <Line: +    but it should be considered immutable as it's returned by the client and
>, <Line: +    not meant for modifications.
>, <Line: +    """
>, <Line: +    def __init__(self, auth_type, data=None):
>, <Line: +        dict.__init__(self, data or {})
>, <Line: +        self.type = auth_type
>, <Line: +    username = property(lambda x: x.get('username'), doc='''
>, <Line: +        The username transmitted.  This is set for both basic and digest
>, <Line: +        auth all the time.''')
>, <Line: +    password = property(lambda x: x.get('password'), doc='''
>, <Line: +        When the authentication type is basic this is the password
>, <Line: +        transmitted by the client, else `None`.''')
>, <Line: +    realm = property(lambda x: x.get('realm'), doc='''
>, <Line: +        This is the server realm sent back for HTTP digest auth.''')
>, <Line: +    nonce = property(lambda x: x.get('nonce'), doc='''
>, <Line: +        The nonce the server sent for digest auth, sent back by the client.
>, <Line: +        A nonce should be unique for every 401 response for HTTP digest
>, <Line: +        auth.''')
>, <Line: +    uri = property(lambda x: x.get('uri'), doc='''
>, <Line: +        The URI from Request-URI of the Request-Line; duplicated because
>, <Line: +        proxies are allowed to change the Request-Line in transit.  HTTP
>, <Line: +        digest auth only.''')
>, <Line: +    nc = property(lambda x: x.get('nc'), doc='''
>, <Line: +        The nonce count value transmitted by clients if a qop-header is
>, <Line: +        also transmitted.  HTTP digest auth only.''')
>, <Line: +    cnonce = property(lambda x: x.get('cnonce'), doc='''
>, <Line: +        If the server sent a qop-header in the ``WWW-Authenticate``
>, <Line: +        header, the client has to provide this value for HTTP digest auth.
>, <Line: +        See the RFC for more details.''')
>, <Line: +    response = property(lambda x: x.get('response'), doc='''
>, <Line: +        A string of 32 hex digits computed as defined in RFC 2617, which
>, <Line: +        proves that the user knows a password.  Digest auth only.''')
>, <Line: +    opaque = property(lambda x: x.get('opaque'), doc='''
>, <Line: +        The opaque header from the server returned unchanged by the client.
>, <Line: +        It is recommended that this string be base64 or hexadecimal data.
>, <Line: +        Digest auth only.''')
>, <Line: +    @property
>, <Line: +    def qop(self):
>, <Line: +        """Indicates what "quality of protection" the client has applied to
>, <Line: +        the message for HTTP digest auth."""
>, <Line: +        def on_update(header_set):
>, <Line: +            if not header_set and 'qop' in self:
>, <Line: +                del self['qop']
>, <Line: +            elif header_set:
>, <Line: +                self['qop'] = header_set.to_header()
>, <Line: +        return parse_set_header(self.get('qop'), on_update)
>, <Line: +def parse_authorization_header(value):
>, <Line: +    """Parse an HTTP basic/digest authorization header transmitted by the web
>, <Line: +    browser.  The return value is either `None` if the header was invalid or
>, <Line: +    not given, otherwise an :class:`~Authorization`
>, <Line: +    object.
>, <Line: +    :param value:
>, <Line: +        The authorization header to parse.
>, <Line: +    :return:
>, <Line: +        A:class:`~Authorization` object or `None`.
>, <Line: +    """
>, <Line: +    if not value:
>, <Line: +        return
>, <Line: +    value = wsgi_to_bytes(value)
>, <Line: +    try:
>, <Line: +        auth_type, auth_info = value.split(None, 1)
>, <Line: +        auth_type = auth_type.lower()
>, <Line: +    except ValueError:
>, <Line: +        return
>, <Line: +    if auth_type == b'basic':
>, <Line: +        try:
>, <Line: +            username, password = base64.b64decode(auth_info).split(b':', 1)
>, <Line: +        except Exception:
>, <Line: +            return
>, <Line: +        return Authorization('basic', {'username':  bytes_to_wsgi(username),
>, <Line: +                                       'password': bytes_to_wsgi(password)})
>, <Line: +    elif auth_type == b'digest':
>, <Line: +        auth_map = parse_dict_header(auth_info)
>, <Line: +        for key in 'username', 'realm', 'nonce', 'uri', 'response':
>, <Line: +            if key not in auth_map:
>, <Line: +                return
>, <Line: +        if 'qop' in auth_map:
>, <Line: +            if not auth_map.get('nc') or not auth_map.get('cnonce'):
>, <Line: +                return
>, <Line: +        return Authorization('digest', auth_map)
>, <Line: +def auth_property(name, doc=None):
>, <Line: +    """A static helper function for subclasses to add extra authentication
>, <Line: +    system properties onto a class::
>, <Line: +        class FooAuthenticate(WWWAuthenticate):
>, <Line: +            special_realm = auth_property('special_realm')
>, <Line: +    For more information have a look at the sourcecode to see how the
>, <Line: +    regular properties (:attr:`realm` etc.) are implemented.
>, <Line: +    """
>, <Line: +    def _set_value(self, value):
>, <Line: +        if value is None:
>, <Line: +            self.pop(name, None)
>, <Line: +        else:
>, <Line: +            self[name] = str(value)
>, <Line: +    return property(lambda x: x.get(name), _set_value, doc=doc)
>, <Line: +class WWWAuthenticate(datastructures.UpdateDictMixin, dict):
>, <Line: +    """Provides simple access to `WWW-Authenticate` headers."""
>, <Line: +    #: list of keys that require quoting in the generated header
>, <Line: +    _require_quoting = frozenset(['domain', 'nonce', 'opaque', 'realm', 'qop'])
>, <Line: +    def __init__(self, auth_type=None, values=None, on_update=None):
>, <Line: +        dict.__init__(self, values or ())
>, <Line: +        if auth_type:
>, <Line: +            self['__auth_type__'] = auth_type
>, <Line: +        self.on_update = on_update
>, <Line: +    def set_basic(self, realm='authentication required'):
>, <Line: +        """Clear the auth info and enable basic auth."""
>, <Line: +        dict.clear(self)
>, <Line: +        dict.update(self, {'__auth_type__': 'basic', 'realm': realm})
>, <Line: +        if self.on_update:
>, <Line: +            self.on_update(self)
>, <Line: +    def set_digest(self, realm, nonce, qop=('auth',), opaque=None,
>, <Line: +                   algorithm=None, stale=False):
>, <Line: +        """Clear the auth info and enable digest auth."""
>, <Line: +        d = {
>, <Line: +            '__auth_type__':    'digest',
>, <Line: +            'realm':            realm,
>, <Line: +            'nonce':            nonce,
>, <Line: +            'qop':              dump_header(qop)
>, <Line: +        }
>, <Line: +        if stale:
>, <Line: +            d['stale'] = 'TRUE'
>, <Line: +        if opaque is not None:
>, <Line: +            d['opaque'] = opaque
>, <Line: +        if algorithm is not None:
>, <Line: +            d['algorithm'] = algorithm
>, <Line: +        dict.clear(self)
>, <Line: +        dict.update(self, d)
>, <Line: +        if self.on_update:
>, <Line: +            self.on_update(self)
>, <Line: +    def to_header(self):
>, <Line: +        """Convert the stored values into a WWW-Authenticate header."""
>, <Line: +        d = dict(self)
>, <Line: +        auth_type = d.pop('__auth_type__', None) or 'basic'
>, <Line: +        return '%s %s' % (auth_type.title(), ', '.join([
>, <Line: +            '%s=%s' % (key, quote_header_value(
>, <Line: +                value, allow_token=key not in self._require_quoting
>, <Line: +            ))
>, <Line: +            for key, value in d.items()
>, <Line: +        ]))
>, <Line: +    def __str__(self):
>, <Line: +        return self.to_header()
>, <Line: +    def __repr__(self):
>, <Line: +        return '<%s %r>' % (
>, <Line: +            self.__class__.__name__,
>, <Line: +            self.to_header()
>, <Line: +        )
>, <Line: +    def _set_property(name, doc=None):
>, <Line: +        def fget(self):
>, <Line: +            def on_update(header_set):
>, <Line: +                if not header_set and name in self:
>, <Line: +                    del self[name]
>, <Line: +                elif header_set:
>, <Line: +                    self[name] = header_set.to_header()
>, <Line: +            return parse_set_header(self.get(name), on_update)
>, <Line: +        return property(fget, doc=doc)
>, <Line: +    type = auth_property('__auth_type__', doc='''
>, <Line: +        The type of the auth mechanism.  HTTP currently specifies
>, <Line: +        `Basic` and `Digest`.''')
>, <Line: +    realm = auth_property('realm', doc='''
>, <Line: +        A string to be displayed to users so they know which username and
>, <Line: +        password to use.  This string should contain at least the name of
>, <Line: +        the host performing the authentication and might additionally
>, <Line: +        indicate the collection of users who might have access.''')
>, <Line: +    domain = _set_property('domain', doc='''
>, <Line: +        A list of URIs that define the protection space.  If a URI is an
>, <Line: +        absolute path, it is relative to the canonical root URL of the
>, <Line: +        server being accessed.''')
>, <Line: +    nonce = auth_property('nonce', doc='''
>, <Line: +        A server-specified data string which should be uniquely generated
>, <Line: +        each time a 401 response is made.  It is recommended that this
>, <Line: +        string be base64 or hexadecimal data.''')
>, <Line: +    opaque = auth_property('opaque', doc='''
>, <Line: +        A string of data, specified by the server, which should be returned
>, <Line: +        by the client unchanged in the Authorization header of subsequent
>, <Line: +        requests with URIs in the same protection space.  It is recommended
>, <Line: +        that this string be base64 or hexadecimal data.''')
>, <Line: +    algorithm = auth_property('algorithm', doc='''
>, <Line: +        A string indicating a pair of algorithms used to produce the digest
>, <Line: +        and a checksum.  If this is not present it is assumed to be "MD5".
>, <Line: +        If the algorithm is not understood, the challenge should be ignored
>, <Line: +        (and a different one used, if there is more than one).''')
>, <Line: +    qop = _set_property('qop', doc='''
>, <Line: +        A set of quality-of-privacy directives such as auth and auth-int.''')
>, <Line: +    def _get_stale(self):
>, <Line: +        val = self.get('stale')
>, <Line: +        if val is not None:
>, <Line: +            return val.lower() == 'true'
>, <Line: +    def _set_stale(self, value):
>, <Line: +        if value is None:
>, <Line: +            self.pop('stale', None)
>, <Line: +        else:
>, <Line: +            self['stale'] = value and 'TRUE' or 'FALSE'
>, <Line: +    stale = property(_get_stale, _set_stale, doc='''
>, <Line: +        A flag, indicating that the previous request from the client was
>, <Line: +        rejected because the nonce value was stale.''')
>, <Line: +    del _get_stale, _set_stale
>, <Line: +    del _set_property
>, <Line: +# make auth_property a staticmethod so that subclasses of
>, <Line: +# `WWWAuthenticate` can use it for new properties.
>, <Line: +WWWAuthenticate.auth_property = staticmethod(auth_property)
>, <Line: +def parse_www_authenticate_header(value, on_update=None):
>, <Line: +    """Parse an HTTP WWW-Authenticate header into a
>, <Line: +    :class:`~WWWAuthenticate` object.
>, <Line: +    :param value:
>, <Line: +        A WWW-Authenticate header to parse.
>, <Line: +    :param on_update:
>, <Line: +        An optional callable that is called every time a value on the
>, <Line: +        :class:`~WWWAuthenticate` object is changed.
>, <Line: +    :return:
>, <Line: +        A:class:`~WWWAuthenticate` object.
>, <Line: +    """
>, <Line: +    if not value:
>, <Line: +        return WWWAuthenticate(on_update=on_update)
>, <Line: +    try:
>, <Line: +        auth_type, auth_info = value.split(None, 1)
>, <Line: +        auth_type = auth_type.lower()
>, <Line: +    except (ValueError, AttributeError):
>, <Line: +        return WWWAuthenticate(value.strip().lower(), on_update=on_update)
>, <Line: +    return WWWAuthenticate(
>, <Line: +        auth_type, parse_dict_header(auth_info), on_update
>, <Line: +    )
>]
[]