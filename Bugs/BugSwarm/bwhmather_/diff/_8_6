[]
[<Line: -"""
>, <Line: -    verktyg.http
>, <Line: -    ~~~~~~~~~~~~
>, <Line: -    This covers some of the more HTTP centric features of WSGI, some other
>, <Line: -    utilities such as cookie handling are documented in the `verktyg.utils`
>, <Line: -    module.
>, <Line: -    :copyright:
>, <Line: -        (c) 2015 Ben Mather, based on Werkzeug, see AUTHORS for more details.
>, <Line: -    :license:
>, <Line: -        BSD, see LICENSE for more details.
>, <Line: -"""
>, <Line: -import re
>, <Line: -import sys
>, <Line: -import codecs
>, <Line: -from time import time, gmtime
>, <Line: -from email.utils import parsedate_tz
>, <Line: -from urllib.request import parse_http_list as _parse_list_header
>, <Line: -from datetime import datetime, timedelta
>, <Line: -from hashlib import md5
>, <Line: -import base64
>, <Line: -from werkzeug._internal import (
>, <Line: -    _cookie_quote, _make_cookie_domain, _cookie_parse_impl,
>, <Line: -    _missing, _empty_stream,
>, <Line: -)
>, <Line: -from werkzeug._compat import to_unicode, to_bytes, make_literal_wrapper
>, <Line: -from werkzeug.urls import iri_to_uri
>, <Line: -from verktyg import datastructures
>, <Line: -from verktyg.datastructures import is_immutable
>, <Line: -from verktyg import exceptions
>, <Line: -_cookie_charset = 'latin1'
>, <Line: -# for explanation of "media-range", etc. see Sections 5.3.{1,2} of RFC 7231
>, <Line: -_accept_re = re.compile(
>, <Line: -    r'''(                       # media-range capturing-parenthesis
>, <Line: -              [^\s;,]+              # type/subtype
>, <Line: -              (?:[ \t]*;[ \t]*      # ";"
>, <Line: -                (?:                 # parameter non-capturing-parenthesis
>, <Line: -                  [^\s;,q][^\s;,]*  # token that doesn't start with "q"
>, <Line: -                |                   # or
>, <Line: -                  q[^\s;,=][^\s;,]* # token that is more than just "q"
>, <Line: -                )
>, <Line: -              )*                    # zero or more parameters
>, <Line: -            )                       # end of media-range
>, <Line: -            (?:[ \t]*;[ \t]*q=      # weight is a "q" parameter
>, <Line: -              (\d*(?:\.\d+)?)       # qvalue capturing-parentheses
>, <Line: -              [^,]*                 # "extension" accept params: who cares?
>, <Line: -            )?                      # accept params are optional
>, <Line: -        ''', re.VERBOSE)
>, <Line: -_locale_delim_re = re.compile(r'[_-]')
>, <Line: -_token_chars = frozenset("!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>, <Line: -                         '^_`abcdefghijklmnopqrstuvwxyz|~')
>, <Line: -_etag_re = re.compile(r'([Ww]/)?(?:"(.*?)"|(.*?))(?:\s*,\s*|$)')
>, <Line: -_unsafe_header_chars = set('()<>@,;:\"/[]?={} \t')
>, <Line: -_quoted_string_re = r'"[^"\\]*(?:\\.[^"\\]*)*"'
>, <Line: -_option_header_piece_re = re.compile(
>, <Line: -    r';\s*(%s|[^\s;=]+)\s*(?:=\s*(%s|[^;]+))?\s*' %
>, <Line: -    (_quoted_string_re, _quoted_string_re)
>, <Line: -)
>, <Line: -_entity_headers = frozenset([
>, <Line: -    'allow', 'content-encoding', 'content-language', 'content-length',
>, <Line: -    'content-location', 'content-md5', 'content-range', 'content-type',
>, <Line: -    'expires', 'last-modified'
>, <Line: -])
>, <Line: -_hop_by_hop_headers = frozenset([
>, <Line: -    'connection', 'keep-alive', 'proxy-authenticate',
>, <Line: -    'proxy-authorization', 'te', 'trailer', 'transfer-encoding',
>, <Line: -    'upgrade'
>, <Line: -])
>, <Line: -# reexport status codes.  Original definition is in in exceptions to avoid
>, <Line: -# circular dependency
>, <Line: -HTTP_STATUS_CODES = exceptions.HTTP_STATUS_CODES
>, <Line: -def wsgi_to_bytes(data):
>, <Line: -    """coerce wsgi unicode represented bytes to real ones
>, <Line: -    """
>, <Line: -    if isinstance(data, bytes):
>, <Line: -        return data
>, <Line: -    return data.encode('latin1')  # XXX: utf8 fallback?
>, <Line: -def bytes_to_wsgi(data):
>, <Line: -    assert isinstance(data, bytes), 'data must be bytes'
>, <Line: -    if isinstance(data, str):
>, <Line: -        return data
>, <Line: -    else:
>, <Line: -        return data.decode('latin1')
>, <Line: -def quote_header_value(value, extra_chars='', allow_token=True):
>, <Line: -    """Quote a header value if necessary.
>, <Line: -    :param value:
>, <Line: -        The value to quote.
>, <Line: -    :param extra_chars:
>, <Line: -        A list of extra characters to skip quoting.
>, <Line: -    :param allow_token:
>, <Line: -        If this is enabled token values are returned unchanged.
>, <Line: -    """
>, <Line: -    if isinstance(value, bytes):
>, <Line: -        value = bytes_to_wsgi(value)
>, <Line: -    value = str(value)
>, <Line: -    if allow_token:
>, <Line: -        token_chars = _token_chars | set(extra_chars)
>, <Line: -        if set(value).issubset(token_chars):
>, <Line: -            return value
>, <Line: -    return '"%s"' % value.replace('\\', '\\\\').replace('"', '\\"')
>, <Line: -def unquote_header_value(value, is_filename=False):
>, <Line: -    r"""Unquotes a header value.  (Reversal of :func:`quote_header_value`).
>, <Line: -    This does not use the real unquoting but what browsers are actually
>, <Line: -    using for quoting.
>, <Line: -    :param value:
>, <Line: -        The header value to unquote.
>, <Line: -    """
>, <Line: -    if value and value[0] == value[-1] == '"':
>, <Line: -        # this is not the real unquoting, but fixing this so that the
>, <Line: -        # RFC is met will result in bugs with internet explorer and
>, <Line: -        # probably some other browsers as well.  IE for example is
>, <Line: -        # uploading files with "C:\foo\bar.txt" as filename
>, <Line: -        value = value[1:-1]
>, <Line: -        # if this is a filename and the starting characters look like
>, <Line: -        # a UNC path, then just return the value without quotes.  Using the
>, <Line: -        # replace sequence below on a UNC path has the effect of turning
>, <Line: -        # the leading double slash into a single slash and then
>, <Line: -        # _fix_ie_filename() doesn't work correctly.  See #458.
>, <Line: -        if not is_filename or value[:2] != '\\\\':
>, <Line: -            return value.replace('\\\\', '\\').replace('\\"', '"')
>, <Line: -    return value
>, <Line: -def _options_header_vkw(value, kw):
>, <Line: -    return dump_options_header(
>, <Line: -        value, dict((k.replace('_', '-'), v) for k, v in kw.items())
>, <Line: -    )
>, <Line: -def unicodify_header_value(value):
>, <Line: -    if isinstance(value, bytes):
>, <Line: -        value = value.decode('latin-1')
>, <Line: -    if not isinstance(value, str):
>, <Line: -        value = str(value)
>, <Line: -    return value
>, <Line: -class Headers(object):
>, <Line: -    """An object that stores some headers.  It has a dict-like interface
>, <Line: -    but is ordered and can store the same keys multiple times.
>, <Line: -    This data structure is useful if you want a nicer way to handle WSGI
>, <Line: -    headers which are stored as tuples in a list.
>, <Line: -    From Werkzeug 0.3 onwards, the :exc:`KeyError` raised by this class is
>, <Line: -    also a subclass of the :class:`~exceptions.BadRequest` HTTP exception
>, <Line: -    and will render a page for a ``400 BAD REQUEST`` if caught in a
>, <Line: -    catch-all for HTTP exceptions.
>, <Line: -    Headers is mostly compatible with the Python
>, <Line: -    :class:`wsgiref.headers.Headers` class, with the exception of
>, <Line: -    `__getitem__`.  :mod:`wsgiref` will return `None` for
>, <Line: -    ``headers['missing']``, whereas :class:`Headers` will raise a
>, <Line: -    :class:`KeyError`.
>, <Line: -    To create a new :class:`Headers` object pass it a list or dict of headers
>, <Line: -    which are used as default values.  This does not reuse the list passed
>, <Line: -    to the constructor for internal usage.
>, <Line: -    :param defaults:
>, <Line: -        The list of default values for the :class:`Headers`.
>, <Line: -    """
>, <Line: -    def __init__(self, defaults=None):
>, <Line: -        self._list = []
>, <Line: -        if defaults is not None:
>, <Line: -            if isinstance(defaults, (list, Headers)):
>, <Line: -                self._list.extend(defaults)
>, <Line: -            else:
>, <Line: -                self.extend(defaults)
>, <Line: -    def __getitem__(self, key, _get_mode=False):
>, <Line: -        if not _get_mode:
>, <Line: -            if isinstance(key, int):
>, <Line: -                return self._list[key]
>, <Line: -            elif isinstance(key, slice):
>, <Line: -                return self.__class__(self._list[key])
>, <Line: -        if not isinstance(key, str):
>, <Line: -            raise exceptions.BadRequestKeyError(key)
>, <Line: -        ikey = key.lower()
>, <Line: -        for k, v in self._list:
>, <Line: -            if k.lower() == ikey:
>, <Line: -                return v
>, <Line: -        # micro optimization: if we are in get mode we will catch that
>, <Line: -        # exception one stack level down so we can raise a standard
>, <Line: -        # key error instead of our special one.
>, <Line: -        if _get_mode:
>, <Line: -            raise KeyError()
>, <Line: -        raise exceptions.BadRequestKeyError(key)
>, <Line: -    def __eq__(self, other):
>, <Line: -        return other.__class__ is self.__class__ and \
>, <Line: -            set(other._list) == set(self._list)
>, <Line: -    def __ne__(self, other):
>, <Line: -        return not self.__eq__(other)
>, <Line: -    def get(self, key, default=None, type=None, as_bytes=False):
>, <Line: -        """Return the default value if the requested data doesn't exist.
>, <Line: -        If `type` is provided and is a callable it should convert the value,
>, <Line: -        return it or raise a :exc:`ValueError` if that is not possible.  In
>, <Line: -        this case the function will return the default as if the value was not
>, <Line: -        found:
>, <Line: -        >>> d = Headers([('Content-Length', '42')])
>, <Line: -        >>> d.get('Content-Length', type=int)
>, <Line: -        42
>, <Line: -        If a headers object is bound you must not add unicode strings
>, <Line: -        because no encoding takes place.
>, <Line: -        :param key:
>, <Line: -            The key to be looked up.
>, <Line: -        :param default:
>, <Line: -            The default value to be returned if the key can't be looked up.  If
>, <Line: -            not further specified `None` is returned.
>, <Line: -        :param type:
>, <Line: -            A callable that is used to cast the value in the :class:`Headers`.
>, <Line: -            If a :exc:`ValueError` is raised by this callable the default value
>, <Line: -            is returned.
>, <Line: -        :param as_bytes:
>, <Line: -            Return bytes instead of unicode strings.
>, <Line: -        """
>, <Line: -        try:
>, <Line: -            rv = self.__getitem__(key, _get_mode=True)
>, <Line: -        except KeyError:
>, <Line: -            return default
>, <Line: -        if as_bytes:
>, <Line: -            rv = rv.encode('latin1')
>, <Line: -        if type is None:
>, <Line: -            return rv
>, <Line: -        try:
>, <Line: -            return type(rv)
>, <Line: -        except ValueError:
>, <Line: -            return default
>, <Line: -    def getlist(self, key, type=None, as_bytes=False):
>, <Line: -        """Return the list of items for a given key. If that key is not in the
>, <Line: -        :class:`Headers`, the return value will be an empty list.  Just as
>, <Line: -        :meth:`get` :meth:`getlist` accepts a `type` parameter.  All items will
>, <Line: -        be converted with the callable defined there.
>, <Line: -        :param key:
>, <Line: -            The key to be looked up.
>, <Line: -        :param type:
>, <Line: -            A callable that is used to cast the value in the :class:`Headers`.
>, <Line: -            If a :exc:`ValueError` is raised by this callable the value will be
>, <Line: -            removed from the list.
>, <Line: -        :param as_bytes:
>, <Line: -            Return bytes instead of unicode strings.
>, <Line: -        :return:
>, <Line: -            A :class:`list` of all the values for the key.
>, <Line: -        """
>, <Line: -        ikey = key.lower()
>, <Line: -        result = []
>, <Line: -        for k, v in self:
>, <Line: -            if k.lower() == ikey:
>, <Line: -                if as_bytes:
>, <Line: -                    v = v.encode('latin1')
>, <Line: -                if type is not None:
>, <Line: -                    try:
>, <Line: -                        v = type(v)
>, <Line: -                    except ValueError:
>, <Line: -                        continue
>, <Line: -                result.append(v)
>, <Line: -        return result
>, <Line: -    def get_all(self, name):
>, <Line: -        """Return a list of all the values for the named field.
>, <Line: -        This method is compatible with the :mod:`wsgiref`
>, <Line: -        :meth:`~wsgiref.headers.Headers.get_all` method.
>, <Line: -        """
>, <Line: -        return self.getlist(name)
>, <Line: -    def items(self, lower=False):
>, <Line: -        for key, value in self:
>, <Line: -            if lower:
>, <Line: -                key = key.lower()
>, <Line: -            yield key, value
>, <Line: -    def keys(self, lower=False):
>, <Line: -        for key, _ in self.items(lower):
>, <Line: -            yield key
>, <Line: -    def values(self):
>, <Line: -        for _, value in self.items():
>, <Line: -            yield value
>, <Line: -    def extend(self, iterable):
>, <Line: -        """Extend the headers with a dict or an iterable yielding keys and
>, <Line: -        values.
>, <Line: -        """
>, <Line: -        if isinstance(iterable, dict):
>, <Line: -            for key, value in iterable.items():
>, <Line: -                if isinstance(value, (tuple, list)):
>, <Line: -                    for v in value:
>, <Line: -                        self.add(key, v)
>, <Line: -                else:
>, <Line: -                    self.add(key, value)
>, <Line: -        else:
>, <Line: -            for key, value in iterable:
>, <Line: -                self.add(key, value)
>, <Line: -    def __delitem__(self, key, _index_operation=True):
>, <Line: -        if _index_operation and isinstance(key, (int, slice)):
>, <Line: -            del self._list[key]
>, <Line: -            return
>, <Line: -        key = key.lower()
>, <Line: -        new = []
>, <Line: -        for k, v in self._list:
>, <Line: -            if k.lower() != key:
>, <Line: -                new.append((k, v))
>, <Line: -        self._list[:] = new
>, <Line: -    def remove(self, key):
>, <Line: -        """Remove a key.
>, <Line: -        :param key:
>, <Line: -            The key to be removed.
>, <Line: -        """
>, <Line: -        return self.__delitem__(key, _index_operation=False)
>, <Line: -    def pop(self, key=None, default=_missing):
>, <Line: -        """Removes and returns a key or index.
>, <Line: -        :param key:
>, <Line: -            The key to be popped.  If this is an integer the item at that
>, <Line: -            position is removed, if it's a string the value for that key is.
>, <Line: -            If the key is omitted or `None` the last item is removed.
>, <Line: -        :return:
>, <Line: -            An item.
>, <Line: -        """
>, <Line: -        if key is None:
>, <Line: -            return self._list.pop()
>, <Line: -        if isinstance(key, int):
>, <Line: -            return self._list.pop(key)
>, <Line: -        try:
>, <Line: -            rv = self[key]
>, <Line: -            self.remove(key)
>, <Line: -        except KeyError:
>, <Line: -            if default is not _missing:
>, <Line: -                return default
>, <Line: -            raise
>, <Line: -        return rv
>, <Line: -    def popitem(self):
>, <Line: -        """Removes a key or index and returns a (key, value) item."""
>, <Line: -        return self.pop()
>, <Line: -    def __contains__(self, key):
>, <Line: -        """Check if a key is present."""
>, <Line: -        try:
>, <Line: -            self.__getitem__(key, _get_mode=True)
>, <Line: -        except KeyError:
>, <Line: -            return False
>, <Line: -        return True
>, <Line: -    has_key = __contains__
>, <Line: -    def __iter__(self):
>, <Line: -        """Yield ``(key, value)`` tuples."""
>, <Line: -        return iter(self._list)
>, <Line: -    def __len__(self):
>, <Line: -        return len(self._list)
>, <Line: -    def add(self, _key, _value, **kw):
>, <Line: -        """Add a new header tuple to the list.
>, <Line: -        Keyword arguments can specify additional parameters for the header
>, <Line: -        value, with underscores converted to dashes::
>, <Line: -        >>> d = Headers()
>, <Line: -        >>> d.add('Content-Type', 'text/plain')
>, <Line: -        >>> d.add('Content-Disposition', 'attachment', filename='foo.png')
>, <Line: -        The keyword argument dumping uses :func:`dump_options_header`
>, <Line: -        behind the scenes.
>, <Line: -        """
>, <Line: -        if kw:
>, <Line: -            _value = _options_header_vkw(_value, kw)
>, <Line: -        _value = unicodify_header_value(_value)
>, <Line: -        self._validate_value(_value)
>, <Line: -        self._list.append((_key, _value))
>, <Line: -    def _validate_value(self, value):
>, <Line: -        if not isinstance(value, str):
>, <Line: -            raise TypeError('Value should be unicode.')
>, <Line: -        if u'\n' in value or u'\r' in value:
>, <Line: -            raise ValueError('Detected newline in header value.  This is '
>, <Line: -                             'a potential security problem')
>, <Line: -    def add_header(self, _key, _value, **_kw):
>, <Line: -        """Add a new header tuple to the list.
>, <Line: -        An alias for :meth:`add` for compatibility with the :mod:`wsgiref`
>, <Line: -        :meth:`~wsgiref.headers.Headers.add_header` method.
>, <Line: -        """
>, <Line: -        self.add(_key, _value, **_kw)
>, <Line: -    def clear(self):
>, <Line: -        """Clears all headers."""
>, <Line: -        del self._list[:]
>, <Line: -    def set(self, _key, _value, **kw):
>, <Line: -        """Remove all header tuples for `key` and add a new one.  The newly
>, <Line: -        added key either appears at the end of the list if there was no
>, <Line: -        entry or replaces the first one.
>, <Line: -        Keyword arguments can specify additional parameters for the header
>, <Line: -        value, with underscores converted to dashes.  See :meth:`add` for
>, <Line: -        more information.
>, <Line: -        :param key:
>, <Line: -            The key to be inserted.
>, <Line: -        :param value:
>, <Line: -            The value to be inserted.
>, <Line: -        """
>, <Line: -        if kw:
>, <Line: -            _value = _options_header_vkw(_value, kw)
>, <Line: -        _value = unicodify_header_value(_value)
>, <Line: -        self._validate_value(_value)
>, <Line: -        if not self._list:
>, <Line: -            self._list.append((_key, _value))
>, <Line: -            return
>, <Line: -        listiter = iter(self._list)
>, <Line: -        ikey = _key.lower()
>, <Line: -        for idx, (old_key, old_value) in enumerate(listiter):
>, <Line: -            if old_key.lower() == ikey:
>, <Line: -                # replace first ocurrence
>, <Line: -                self._list[idx] = (_key, _value)
>, <Line: -                break
>, <Line: -        else:
>, <Line: -            self._list.append((_key, _value))
>, <Line: -            return
>, <Line: -        self._list[idx + 1:] = [t for t in listiter if t[0].lower() != ikey]
>, <Line: -    def setdefault(self, key, value):
>, <Line: -        """Returns the value for the key if it is in the dict, otherwise it
>, <Line: -        returns `default` and sets that value for `key`.
>, <Line: -        :param key:
>, <Line: -            The key to be looked up.
>, <Line: -        :param default:
>, <Line: -            The default value to be returned if the key is not in the dict.  If
>, <Line: -            not further specified it's `None`.
>, <Line: -        """
>, <Line: -        if key in self:
>, <Line: -            return self[key]
>, <Line: -        self.set(key, value)
>, <Line: -        return value
>, <Line: -    def __setitem__(self, key, value):
>, <Line: -        """Like :meth:`set` but also supports index/slice based setting."""
>, <Line: -        if isinstance(key, (slice, int)):
>, <Line: -            if isinstance(key, int):
>, <Line: -                value = [value]
>, <Line: -            value = [(k, unicodify_header_value(v)) for (k, v) in value]
>, <Line: -            [self._validate_value(v) for (k, v) in value]
>, <Line: -            if isinstance(key, int):
>, <Line: -                self._list[key] = value[0]
>, <Line: -            else:
>, <Line: -                self._list[key] = value
>, <Line: -        else:
>, <Line: -            self.set(key, value)
>, <Line: -    def to_list(self, charset='iso-8859-1'):
>, <Line: -        """Convert the headers into a list suitable for WSGI."""
>, <Line: -        from warnings import warn
>, <Line: -        warn(DeprecationWarning('Method removed, use to_wsgi_list instead'),
>, <Line: -             stacklevel=2)
>, <Line: -        return self.to_wsgi_list()
>, <Line: -    def to_wsgi_list(self):
>, <Line: -        """Convert the headers into a list suitable for WSGI.
>, <Line: -        The values are byte strings in Python 2 converted to latin1 and unicode
>, <Line: -        strings in Python 3 for the WSGI server to encode.
>, <Line: -        :return: list
>, <Line: -        """
>, <Line: -        return list(self)
>, <Line: -    def copy(self):
>, <Line: -        return self.__class__(self._list)
>, <Line: -    def __copy__(self):
>, <Line: -        return self.copy()
>, <Line: -    def __str__(self):
>, <Line: -        """Returns formatted headers suitable for HTTP transmission."""
>, <Line: -        strs = []
>, <Line: -        for key, value in self.to_wsgi_list():
>, <Line: -            strs.append('%s: %s' % (key, value))
>, <Line: -        strs.append('\r\n')
>, <Line: -        return '\r\n'.join(strs)
>, <Line: -    def __repr__(self):
>, <Line: -        return '%s(%r)' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            list(self)
>, <Line: -        )
>, <Line: -class ImmutableHeadersMixin(object):
>, <Line: -    """Makes a :class:`Headers` immutable.  We do not mark them as
>, <Line: -    hashable though since the only usecase for this datastructure
>, <Line: -    in Werkzeug is a view on a mutable structure.
>, <Line: -    :private:
>, <Line: -    """
>, <Line: -    def __delitem__(self, key):
>, <Line: -        is_immutable(self)
>, <Line: -    def __setitem__(self, key, value):
>, <Line: -        is_immutable(self)
>, <Line: -    set = __setitem__
>, <Line: -    def add(self, item):
>, <Line: -        is_immutable(self)
>, <Line: -    remove = add_header = add
>, <Line: -    def extend(self, iterable):
>, <Line: -        is_immutable(self)
>, <Line: -    def insert(self, pos, value):
>, <Line: -        is_immutable(self)
>, <Line: -    def pop(self, index=-1):
>, <Line: -        is_immutable(self)
>, <Line: -    def popitem(self):
>, <Line: -        is_immutable(self)
>, <Line: -    def setdefault(self, key, default):
>, <Line: -        is_immutable(self)
>, <Line: -def dump_options_header(header, options):
>, <Line: -    """The reverse function to :func:`parse_options_header`.
>, <Line: -    :param header:
>, <Line: -        The header to dump.
>, <Line: -    :param options:
>, <Line: -        A dict of options to append.
>, <Line: -    """
>, <Line: -    segments = []
>, <Line: -    if header is not None:
>, <Line: -        segments.append(header)
>, <Line: -    for key, value in options.items():
>, <Line: -        if value is None:
>, <Line: -            segments.append(key)
>, <Line: -        else:
>, <Line: -            segments.append('%s=%s' % (key, quote_header_value(value)))
>, <Line: -    return '; '.join(segments)
>, <Line: -def dump_header(iterable, allow_token=True):
>, <Line: -    """Dump an HTTP header again.  This is the reversal of
>, <Line: -    :func:`parse_list_header`, :func:`parse_set_header` and
>, <Line: -    :func:`parse_dict_header`.  This also quotes strings that include an
>, <Line: -    equals sign unless you pass it as dict of key, value pairs.
>, <Line: -    >>> dump_header({'foo': 'bar baz'})
>, <Line: -    'foo="bar baz"'
>, <Line: -    >>> dump_header(('foo', 'bar baz'))
>, <Line: -    'foo, "bar baz"'
>, <Line: -    :param iterable:
>, <Line: -        The iterable or dict of values to quote.
>, <Line: -    :param allow_token:
>, <Line: -        If set to `False` tokens as values are disallowed.
>, <Line: -        See :func:`quote_header_value` for more details.
>, <Line: -    """
>, <Line: -    if isinstance(iterable, dict):
>, <Line: -        items = []
>, <Line: -        for key, value in iterable.items():
>, <Line: -            if value is None:
>, <Line: -                items.append(key)
>, <Line: -            else:
>, <Line: -                items.append('%s=%s' % (
>, <Line: -                    key,
>, <Line: -                    quote_header_value(value, allow_token=allow_token)
>, <Line: -                ))
>, <Line: -    else:
>, <Line: -        items = [quote_header_value(x, allow_token=allow_token)
>, <Line: -                 for x in iterable]
>, <Line: -    return ', '.join(items)
>, <Line: -def parse_list_header(value):
>, <Line: -    """Parse lists as described by RFC 2068 Section 2.
>, <Line: -    In particular, parse comma-separated lists where the elements of
>, <Line: -    the list may include quoted-strings.  A quoted-string could
>, <Line: -    contain a comma.  A non-quoted string could have quotes in the
>, <Line: -    middle.  Quotes are removed automatically after parsing.
>, <Line: -    It basically works like :func:`parse_set_header` just that items
>, <Line: -    may appear multiple times and case sensitivity is preserved.
>, <Line: -    The return value is a standard :class:`list`:
>, <Line: -    >>> parse_list_header('token, "quoted value"')
>, <Line: -    ['token', 'quoted value']
>, <Line: -    To create a header from the :class:`list` again, use the
>, <Line: -    :func:`dump_header` function.
>, <Line: -    :param value:
>, <Line: -        A string with a list header.
>, <Line: -    :return:
>, <Line: -        :class:`list`
>, <Line: -    """
>, <Line: -    result = []
>, <Line: -    for item in _parse_list_header(value):
>, <Line: -        if item[:1] == item[-1:] == '"':
>, <Line: -            item = unquote_header_value(item[1:-1])
>, <Line: -        result.append(item)
>, <Line: -    return result
>, <Line: -def parse_dict_header(value, cls=dict):
>, <Line: -    """Parse lists of key, value pairs as described by RFC 2068 Section 2 and
>, <Line: -    convert them into a python dict (or any other mapping object created from
>, <Line: -    the type with a dict like interface provided by the `cls` arugment):
>, <Line: -    >>> d = parse_dict_header('foo="is a fish", bar="as well"')
>, <Line: -    >>> type(d) is dict
>, <Line: -    True
>, <Line: -    >>> sorted(d.items())
>, <Line: -    [('bar', 'as well'), ('foo', 'is a fish')]
>, <Line: -    If there is no value for a key it will be `None`:
>, <Line: -    >>> parse_dict_header('key_without_value')
>, <Line: -    {'key_without_value': None}
>, <Line: -    To create a header from the :class:`dict` again, use the
>, <Line: -    :func:`dump_header` function.
>, <Line: -    :param value:
>, <Line: -        A string with a dict header.
>, <Line: -    :param cls:
>, <Line: -        Callable to use for storage of parsed results.
>, <Line: -    :return:
>, <Line: -        An instance of `cls`
>, <Line: -    """
>, <Line: -    result = cls()
>, <Line: -    if not isinstance(value, str):
>, <Line: -        # XXX: validate
>, <Line: -        value = bytes_to_wsgi(value)
>, <Line: -    for item in _parse_list_header(value):
>, <Line: -        if '=' not in item:
>, <Line: -            result[item] = None
>, <Line: -            continue
>, <Line: -        name, value = item.split('=', 1)
>, <Line: -        if value[:1] == value[-1:] == '"':
>, <Line: -            value = unquote_header_value(value[1:-1])
>, <Line: -        result[name] = value
>, <Line: -    return result
>, <Line: -def parse_options_header(value):
>, <Line: -    """Parse a ``Content-Type`` like header into a tuple with the content
>, <Line: -    type and the options:
>, <Line: -    >>> parse_options_header('text/html; charset=utf8')
>, <Line: -    ('text/html', {'charset': 'utf8'})
>, <Line: -    This should not be used to parse ``Cache-Control`` like headers that use
>, <Line: -    a slightly different format.  For these headers use the
>, <Line: -    :func:`parse_dict_header` function.
>, <Line: -    :param value:
>, <Line: -        The header to parse.
>, <Line: -    :return:
>, <Line: -        (str, options)
>, <Line: -    """
>, <Line: -    def _tokenize(string):
>, <Line: -        for match in _option_header_piece_re.finditer(string):
>, <Line: -            key, value = match.groups()
>, <Line: -            key = unquote_header_value(key)
>, <Line: -            if value is not None:
>, <Line: -                value = unquote_header_value(value, key == 'filename')
>, <Line: -            yield key, value
>, <Line: -    if not value:
>, <Line: -        return '', {}
>, <Line: -    parts = _tokenize(';' + value)
>, <Line: -    name = next(parts)[0]
>, <Line: -    extra = dict(parts)
>, <Line: -    return name, extra
>, <Line: -class Accept(datastructures.ImmutableList):
>, <Line: -    """An :class:`Accept` object is just a list subclass for lists of
>, <Line: -    ``(value, quality)`` tuples.  It is automatically sorted by quality.
>, <Line: -    All :class:`Accept` objects work similar to a list but provide extra
>, <Line: -    functionality for working with the data.  Containment checks are
>, <Line: -    normalized to the rules of that header:
>, <Line: -    >>> a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])
>, <Line: -    >>> a.best
>, <Line: -    'ISO-8859-1'
>, <Line: -    >>> 'iso-8859-1' in a
>, <Line: -    True
>, <Line: -    >>> 'UTF8' in a
>, <Line: -    True
>, <Line: -    >>> 'utf7' in a
>, <Line: -    False
>, <Line: -    To get the quality for an item you can use normal item lookup:
>, <Line: -    >>> print a['utf-8']
>, <Line: -    0.7
>, <Line: -    >>> a['utf7']
>, <Line: -    0
>, <Line: -    """
>, <Line: -    def __init__(self, values=()):
>, <Line: -        if values is None:
>, <Line: -            list.__init__(self)
>, <Line: -            self.provided = False
>, <Line: -        elif isinstance(values, Accept):
>, <Line: -            self.provided = values.provided
>, <Line: -            list.__init__(self, values)
>, <Line: -        else:
>, <Line: -            self.provided = True
>, <Line: -            values = [(a, b) for b, a in values]
>, <Line: -            values.sort()
>, <Line: -            values.reverse()
>, <Line: -            list.__init__(self, [(a, b) for b, a in values])
>, <Line: -    def _value_matches(self, value, item):
>, <Line: -        """Check if a value matches a given accept item."""
>, <Line: -        return item == '*' or item.lower() == value.lower()
>, <Line: -    def __getitem__(self, key):
>, <Line: -        """Besides index lookup (getting item n) you can also pass it a string
>, <Line: -        to get the quality for the item.  If the item is not in the list, the
>, <Line: -        returned quality is ``0``.
>, <Line: -        """
>, <Line: -        if isinstance(key, str):
>, <Line: -            return self.quality(key)
>, <Line: -        return list.__getitem__(self, key)
>, <Line: -    def quality(self, key):
>, <Line: -        """Returns the quality of the key.
>, <Line: -        """
>, <Line: -        for item, quality in self:
>, <Line: -            if self._value_matches(key, item):
>, <Line: -                return quality
>, <Line: -        return 0
>, <Line: -    def __contains__(self, value):
>, <Line: -        for item, quality in self:
>, <Line: -            if self._value_matches(value, item):
>, <Line: -                return True
>, <Line: -        return False
>, <Line: -    def __repr__(self):
>, <Line: -        return '%s([%s])' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            ', '.join('(%r, %s)' % (x, y) for x, y in self)
>, <Line: -        )
>, <Line: -    def index(self, key):
>, <Line: -        """Get the position of an entry or raise :exc:`ValueError`.
>, <Line: -        :param key:
>, <Line: -            The key to be looked up.
>, <Line: -        """
>, <Line: -        if isinstance(key, str):
>, <Line: -            for idx, (item, quality) in enumerate(self):
>, <Line: -                if self._value_matches(key, item):
>, <Line: -                    return idx
>, <Line: -            raise ValueError(key)
>, <Line: -        return list.index(self, key)
>, <Line: -    def find(self, key):
>, <Line: -        """Get the position of an entry or return -1.
>, <Line: -        :param key:
>, <Line: -            The key to be looked up.
>, <Line: -        """
>, <Line: -        try:
>, <Line: -            return self.index(key)
>, <Line: -        except ValueError:
>, <Line: -            return -1
>, <Line: -    def values(self):
>, <Line: -        """Iterate over all values."""
>, <Line: -        for item in self:
>, <Line: -            yield item[0]
>, <Line: -    def to_header(self):
>, <Line: -        """Convert the header set into an HTTP header string."""
>, <Line: -        result = []
>, <Line: -        for value, quality in self:
>, <Line: -            if quality != 1:
>, <Line: -                value = '%s;q=%s' % (value, quality)
>, <Line: -            result.append(value)
>, <Line: -        return ','.join(result)
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def best_match(self, matches, default=None):
>, <Line: -        """Returns the best match from a list of possible matches based
>, <Line: -        on the quality of the client.  If two items have the same quality,
>, <Line: -        the one is returned that comes first.
>, <Line: -        :param matches:
>, <Line: -            A list of matches to check for
>, <Line: -        :param default:
>, <Line: -            The value that is returned if none match
>, <Line: -        """
>, <Line: -        best_quality = -1
>, <Line: -        result = default
>, <Line: -        for server_item in matches:
>, <Line: -            for client_item, quality in self:
>, <Line: -                if quality <= best_quality:
>, <Line: -                    break
>, <Line: -                if self._value_matches(server_item, client_item) \
>, <Line: -                   and quality > 0:
>, <Line: -                    best_quality = quality
>, <Line: -                    result = server_item
>, <Line: -        return result
>, <Line: -    @property
>, <Line: -    def best(self):
>, <Line: -        """The best match as value."""
>, <Line: -        if self:
>, <Line: -            return self[0][0]
>, <Line: -class MIMEAccept(Accept):
>, <Line: -    """Like :class:`Accept` but with special methods and behavior for
>, <Line: -    mimetypes.
>, <Line: -    """
>, <Line: -    def _value_matches(self, value, item):
>, <Line: -        def _normalize(x):
>, <Line: -            x = x.lower()
>, <Line: -            return x == '*' and ('*', '*') or x.split('/', 1)
>, <Line: -        # this is from the application which is trusted.  to avoid developer
>, <Line: -        # frustration we actually check these for valid values
>, <Line: -        if '/' not in value:
>, <Line: -            raise ValueError('invalid mimetype %r' % value)
>, <Line: -        value_type, value_subtype = _normalize(value)
>, <Line: -        if value_type == '*' and value_subtype != '*':
>, <Line: -            raise ValueError('invalid mimetype %r' % value)
>, <Line: -        if '/' not in item:
>, <Line: -            return False
>, <Line: -        item_type, item_subtype = _normalize(item)
>, <Line: -        if item_type == '*' and item_subtype != '*':
>, <Line: -            return False
>, <Line: -        return (
>, <Line: -            (item_type == item_subtype == '*' or
>, <Line: -             value_type == value_subtype == '*') or
>, <Line: -            (item_type == value_type and (item_subtype == '*' or
>, <Line: -                                          value_subtype == '*' or
>, <Line: -                                          item_subtype == value_subtype))
>, <Line: -        )
>, <Line: -    @property
>, <Line: -    def accept_html(self):
>, <Line: -        """True if this object accepts HTML."""
>, <Line: -        return (
>, <Line: -            'text/html' in self or
>, <Line: -            'application/xhtml+xml' in self or
>, <Line: -            self.accept_xhtml
>, <Line: -        )
>, <Line: -    @property
>, <Line: -    def accept_xhtml(self):
>, <Line: -        """True if this object accepts XHTML."""
>, <Line: -        return (
>, <Line: -            'application/xhtml+xml' in self or
>, <Line: -            'application/xml' in self
>, <Line: -        )
>, <Line: -    @property
>, <Line: -    def accept_json(self):
>, <Line: -        """True if this object accepts JSON."""
>, <Line: -        return 'application/json' in self
>, <Line: -class LanguageAccept(Accept):
>, <Line: -    """Like :class:`Accept` but with normalization for languages."""
>, <Line: -    def _value_matches(self, value, item):
>, <Line: -        def _normalize(language):
>, <Line: -            return _locale_delim_re.split(language.lower())
>, <Line: -        return item == '*' or _normalize(value) == _normalize(item)
>, <Line: -class CharsetAccept(Accept):
>, <Line: -    """Like :class:`Accept` but with normalization for charsets."""
>, <Line: -    def _value_matches(self, value, item):
>, <Line: -        def _normalize(name):
>, <Line: -            try:
>, <Line: -                return codecs.lookup(name).name
>, <Line: -            except LookupError:
>, <Line: -                return name.lower()
>, <Line: -        return item == '*' or _normalize(value) == _normalize(item)
>, <Line: -def parse_accept_header(value, cls=None):
>, <Line: -    """Parses an HTTP Accept-* header.  This does not implement a complete
>, <Line: -    valid algorithm but one that supports at least value and quality
>, <Line: -    extraction.
>, <Line: -    Returns a new :class:`Accept` object (basically a list of
>, <Line: -    ``(value, quality)`` tuples sorted by the quality with some additional
>, <Line: -    accessor methods).
>, <Line: -    The second parameter can be a subclass of :class:`Accept` that is created
>, <Line: -    with the parsed values and returned.
>, <Line: -    :param value:
>, <Line: -        The accept header string to be parsed.
>, <Line: -    :param cls:
>, <Line: -        The wrapper class for the return value (can be :class:`Accept` or a
>, <Line: -        subclass thereof)
>, <Line: -    :return:
>, <Line: -        An instance of `cls`.
>, <Line: -    """
>, <Line: -    if cls is None:
>, <Line: -        cls = Accept
>, <Line: -    if not value:
>, <Line: -        return cls(None)
>, <Line: -    result = []
>, <Line: -    for match in _accept_re.finditer(value):
>, <Line: -        quality = match.group(2)
>, <Line: -        if not quality:
>, <Line: -            quality = 1
>, <Line: -        else:
>, <Line: -            quality = max(min(float(quality), 1), 0)
>, <Line: -        result.append((match.group(1), quality))
>, <Line: -    return cls(result)
>, <Line: -def cache_property(key, empty, type):
>, <Line: -    """Return a new property object for a cache header.  Useful if you
>, <Line: -    want to add support for a cache extension in a subclass."""
>, <Line: -    return property(lambda x: x._get_cache_value(key, empty, type),
>, <Line: -                    lambda x, v: x._set_cache_value(key, v, type),
>, <Line: -                    lambda x: x._del_cache_value(key),
>, <Line: -                    'accessor for %r' % key)
>, <Line: -class _CacheControl(datastructures.UpdateDictMixin, dict):
>, <Line: -    """Subclass of a dict that stores values for a Cache-Control header.  It
>, <Line: -    has accessors for all the cache-control directives specified in RFC 2616.
>, <Line: -    The class does not differentiate between request and response directives.
>, <Line: -    Because the cache-control directives in the HTTP header use dashes the
>, <Line: -    python descriptors use underscores for that.
>, <Line: -    To get a header of the :class:`CacheControl` object again you can convert
>, <Line: -    the object into a string or call the :meth:`to_header` method.  If you plan
>, <Line: -    to subclass it and add your own items have a look at the sourcecode for
>, <Line: -    that class.
>, <Line: -    """
>, <Line: -    no_cache = cache_property('no-cache', '*', None)
>, <Line: -    no_store = cache_property('no-store', None, bool)
>, <Line: -    max_age = cache_property('max-age', -1, int)
>, <Line: -    no_transform = cache_property('no-transform', None, None)
>, <Line: -    def __init__(self, values=(), on_update=None):
>, <Line: -        dict.__init__(self, values or ())
>, <Line: -        self.on_update = on_update
>, <Line: -        self.provided = values is not None
>, <Line: -    def _get_cache_value(self, key, empty, type):
>, <Line: -        """Used internally by the accessor properties."""
>, <Line: -        if type is bool:
>, <Line: -            return key in self
>, <Line: -        if key in self:
>, <Line: -            value = self[key]
>, <Line: -            if value is None:
>, <Line: -                return empty
>, <Line: -            elif type is not None:
>, <Line: -                try:
>, <Line: -                    value = type(value)
>, <Line: -                except ValueError:
>, <Line: -                    pass
>, <Line: -            return value
>, <Line: -    def _set_cache_value(self, key, value, type):
>, <Line: -        """Used internally by the accessor properties."""
>, <Line: -        if type is bool:
>, <Line: -            if value:
>, <Line: -                self[key] = None
>, <Line: -            else:
>, <Line: -                self.pop(key, None)
>, <Line: -        else:
>, <Line: -            if value is None:
>, <Line: -                self.pop(key)
>, <Line: -            elif value is True:
>, <Line: -                self[key] = None
>, <Line: -            else:
>, <Line: -                self[key] = value
>, <Line: -    def _del_cache_value(self, key):
>, <Line: -        """Used internally by the accessor properties."""
>, <Line: -        if key in self:
>, <Line: -            del self[key]
>, <Line: -    def to_header(self):
>, <Line: -        """Convert the stored values into a cache control header."""
>, <Line: -        return dump_header(self)
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %s>' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            " ".join(
>, <Line: -                "%s=%r" % (k, v) for k, v in sorted(self.items())
>, <Line: -            ),
>, <Line: -        )
>, <Line: -class RequestCacheControl(datastructures.ImmutableDictMixin, _CacheControl):
>, <Line: -    """A cache control for requests.  This is immutable and gives access
>, <Line: -    to all the request-relevant cache control headers.
>, <Line: -    To get a header of the :class:`RequestCacheControl` object again you can
>, <Line: -    convert the object into a string or call the :meth:`to_header` method.  If
>, <Line: -    you plan to subclass it and add your own items have a look at the
>, <Line: -    sourcecode for that class.
>, <Line: -    """
>, <Line: -    max_stale = cache_property('max-stale', '*', int)
>, <Line: -    min_fresh = cache_property('min-fresh', '*', int)
>, <Line: -    no_transform = cache_property('no-transform', None, None)
>, <Line: -    only_if_cached = cache_property('only-if-cached', None, bool)
>, <Line: -class ResponseCacheControl(_CacheControl):
>, <Line: -    """A cache control for responses.  Unlike :class:`RequestCacheControl`
>, <Line: -    this is mutable and gives access to response-relevant cache control
>, <Line: -    headers.
>, <Line: -    To get a header of the :class:`ResponseCacheControl` object again you can
>, <Line: -    convert the object into a string or call the :meth:`to_header` method.  If
>, <Line: -    you plan to subclass it and add your own items have a look at the
>, <Line: -    sourcecode for that class.
>, <Line: -    """
>, <Line: -    public = cache_property('public', None, bool)
>, <Line: -    private = cache_property('private', '*', None)
>, <Line: -    must_revalidate = cache_property('must-revalidate', None, bool)
>, <Line: -    proxy_revalidate = cache_property('proxy-revalidate', None, bool)
>, <Line: -    s_maxage = cache_property('s-maxage', None, None)
>, <Line: -# attach cache_property to the _CacheControl as staticmethod
>, <Line: -# so that others can reuse it.
>, <Line: -_CacheControl.cache_property = staticmethod(cache_property)
>, <Line: -def parse_cache_control_header(value, on_update=None, cls=None):
>, <Line: -    """Parse a cache control header.  The RFC differs between response and
>, <Line: -    request cache control, this method does not.  It's your responsibility
>, <Line: -    to not use the wrong control statements.
>, <Line: -    :param value:
>, <Line: -        A cache control header to be parsed.
>, <Line: -    :param on_update:
>, <Line: -        An optional callable that is called every time a value on the
>, <Line: -        :class:`~verktyg.CacheControl` object is changed.
>, <Line: -    :param cls:
>, <Line: -        The class for the returned object.  By default
>, <Line: -        :class:`~verktyg.RequestCacheControl` is used.
>, <Line: -    :return:
>, <Line: -        A `cls` object.
>, <Line: -    """
>, <Line: -    if cls is None:
>, <Line: -        cls = RequestCacheControl
>, <Line: -    if not value:
>, <Line: -        return cls(None, on_update)
>, <Line: -    return cls(parse_dict_header(value), on_update)
>, <Line: -class HeaderSet(object):
>, <Line: -    """Similar to the :class:`ETags` class this implements a set-like
>, <Line: -    structure. Unlike :class:`ETags` this is case insensitive and used for
>, <Line: -    vary, allow, and content-language headers.
>, <Line: -    If not constructed using the :func:`parse_set_header` function the
>, <Line: -    instantiation works like this:
>, <Line: -    >>> hs = HeaderSet(['foo', 'bar', 'baz'])
>, <Line: -    >>> hs
>, <Line: -    HeaderSet(['foo', 'bar', 'baz'])
>, <Line: -    """
>, <Line: -    def __init__(self, headers=None, on_update=None):
>, <Line: -        self._headers = list(headers or ())
>, <Line: -        self._set = set([x.lower() for x in self._headers])
>, <Line: -        self.on_update = on_update
>, <Line: -    def add(self, header):
>, <Line: -        """Add a new header to the set."""
>, <Line: -        self.update((header,))
>, <Line: -    def remove(self, header):
>, <Line: -        """Remove a header from the set.  This raises an :exc:`KeyError` if the
>, <Line: -        header is not in the set.
>, <Line: -        :param header:
>, <Line: -            The header to be removed.
>, <Line: -        """
>, <Line: -        key = header.lower()
>, <Line: -        if key not in self._set:
>, <Line: -            raise KeyError(header)
>, <Line: -        self._set.remove(key)
>, <Line: -        for idx, key in enumerate(self._headers):
>, <Line: -            if key.lower() == header:
>, <Line: -                del self._headers[idx]
>, <Line: -                break
>, <Line: -        if self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def update(self, iterable):
>, <Line: -        """Add all the headers from the iterable to the set.
>, <Line: -        :param iterable:
>, <Line: -            Updates the set with the items from the iterable.
>, <Line: -        """
>, <Line: -        inserted_any = False
>, <Line: -        for header in iterable:
>, <Line: -            key = header.lower()
>, <Line: -            if key not in self._set:
>, <Line: -                self._headers.append(header)
>, <Line: -                self._set.add(key)
>, <Line: -                inserted_any = True
>, <Line: -        if inserted_any and self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def discard(self, header):
>, <Line: -        """Like :meth:`remove` but ignores errors.
>, <Line: -        :param header:
>, <Line: -            The header to be discarded.
>, <Line: -        """
>, <Line: -        try:
>, <Line: -            return self.remove(header)
>, <Line: -        except KeyError:
>, <Line: -            pass
>, <Line: -    def find(self, header):
>, <Line: -        """Return the index of the header in the set or return -1 if not found.
>, <Line: -        :param header:
>, <Line: -            The header to be looked up.
>, <Line: -        """
>, <Line: -        header = header.lower()
>, <Line: -        for idx, item in enumerate(self._headers):
>, <Line: -            if item.lower() == header:
>, <Line: -                return idx
>, <Line: -        return -1
>, <Line: -    def index(self, header):
>, <Line: -        """Return the index of the header in the set or raise an
>, <Line: -        :exc:`IndexError`.
>, <Line: -        :param header:
>, <Line: -            The header to be looked up.
>, <Line: -        """
>, <Line: -        rv = self.find(header)
>, <Line: -        if rv < 0:
>, <Line: -            raise IndexError(header)
>, <Line: -        return rv
>, <Line: -    def clear(self):
>, <Line: -        """Clear the set."""
>, <Line: -        self._set.clear()
>, <Line: -        del self._headers[:]
>, <Line: -        if self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def as_set(self, preserve_casing=False):
>, <Line: -        """Return the set as real python set type.  When calling this, all
>, <Line: -        the items are converted to lowercase and the ordering is lost.
>, <Line: -        :param preserve_casing:
>, <Line: -            If set to `True` the items in the set returned will have the
>, <Line: -            original case like in the :class:`HeaderSet`, otherwise they will
>, <Line: -            be lowercase.
>, <Line: -        """
>, <Line: -        if preserve_casing:
>, <Line: -            return set(self._headers)
>, <Line: -        return set(self._set)
>, <Line: -    def to_header(self):
>, <Line: -        """Convert the header set into an HTTP header string."""
>, <Line: -        return ', '.join(map(quote_header_value, self._headers))
>, <Line: -    def __getitem__(self, idx):
>, <Line: -        return self._headers[idx]
>, <Line: -    def __delitem__(self, idx):
>, <Line: -        rv = self._headers.pop(idx)
>, <Line: -        self._set.remove(rv.lower())
>, <Line: -        if self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def __setitem__(self, idx, value):
>, <Line: -        old = self._headers[idx]
>, <Line: -        self._set.remove(old.lower())
>, <Line: -        self._headers[idx] = value
>, <Line: -        self._set.add(value.lower())
>, <Line: -        if self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def __contains__(self, header):
>, <Line: -        return header.lower() in self._set
>, <Line: -    def __len__(self):
>, <Line: -        return len(self._set)
>, <Line: -    def __iter__(self):
>, <Line: -        return iter(self._headers)
>, <Line: -    def __nonzero__(self):
>, <Line: -        return bool(self._set)
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '%s(%r)' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            self._headers
>, <Line: -        )
>, <Line: -def parse_set_header(value, on_update=None):
>, <Line: -    """Parse a set-like header and return a
>, <Line: -    :class:`~HeaderSet` object:
>, <Line: -    >>> hs = parse_set_header('token, "quoted value"')
>, <Line: -    The return value is an object that treats the items case-insensitively
>, <Line: -    and keeps the order of the items:
>, <Line: -    >>> 'TOKEN' in hs
>, <Line: -    True
>, <Line: -    >>> hs.index('quoted value')
>, <Line: -    1
>, <Line: -    >>> hs
>, <Line: -    HeaderSet(['token', 'quoted value'])
>, <Line: -    To create a header from the :class:`HeaderSet` again, use the
>, <Line: -    :func:`dump_header` function.
>, <Line: -    :param value:
>, <Line: -        A set header to be parsed.
>, <Line: -    :param on_update:
>, <Line: -        An optional callable that is called every time a value on the
>, <Line: -        :class:`~HeaderSet` object is changed.
>, <Line: -    :return:
>, <Line: -        A:class:`~HeaderSet`
>, <Line: -    """
>, <Line: -    if not value:
>, <Line: -        return HeaderSet(None, on_update)
>, <Line: -    return HeaderSet(parse_list_header(value), on_update)
>, <Line: -class Authorization(datastructures.ImmutableDictMixin, dict):
>, <Line: -    """Represents an `Authorization` header sent by the client.  You should
>, <Line: -    not create this kind of object yourself but use it when it's returned by
>, <Line: -    the `parse_authorization_header` function.
>, <Line: -    This object is a dict subclass and can be altered by setting dict items
>, <Line: -    but it should be considered immutable as it's returned by the client and
>, <Line: -    not meant for modifications.
>, <Line: -    """
>, <Line: -    def __init__(self, auth_type, data=None):
>, <Line: -        dict.__init__(self, data or {})
>, <Line: -        self.type = auth_type
>, <Line: -    username = property(lambda x: x.get('username'), doc='''
>, <Line: -        The username transmitted.  This is set for both basic and digest
>, <Line: -        auth all the time.''')
>, <Line: -    password = property(lambda x: x.get('password'), doc='''
>, <Line: -        When the authentication type is basic this is the password
>, <Line: -        transmitted by the client, else `None`.''')
>, <Line: -    realm = property(lambda x: x.get('realm'), doc='''
>, <Line: -        This is the server realm sent back for HTTP digest auth.''')
>, <Line: -    nonce = property(lambda x: x.get('nonce'), doc='''
>, <Line: -        The nonce the server sent for digest auth, sent back by the client.
>, <Line: -        A nonce should be unique for every 401 response for HTTP digest
>, <Line: -        auth.''')
>, <Line: -    uri = property(lambda x: x.get('uri'), doc='''
>, <Line: -        The URI from Request-URI of the Request-Line; duplicated because
>, <Line: -        proxies are allowed to change the Request-Line in transit.  HTTP
>, <Line: -        digest auth only.''')
>, <Line: -    nc = property(lambda x: x.get('nc'), doc='''
>, <Line: -        The nonce count value transmitted by clients if a qop-header is
>, <Line: -        also transmitted.  HTTP digest auth only.''')
>, <Line: -    cnonce = property(lambda x: x.get('cnonce'), doc='''
>, <Line: -        If the server sent a qop-header in the ``WWW-Authenticate``
>, <Line: -        header, the client has to provide this value for HTTP digest auth.
>, <Line: -        See the RFC for more details.''')
>, <Line: -    response = property(lambda x: x.get('response'), doc='''
>, <Line: -        A string of 32 hex digits computed as defined in RFC 2617, which
>, <Line: -        proves that the user knows a password.  Digest auth only.''')
>, <Line: -    opaque = property(lambda x: x.get('opaque'), doc='''
>, <Line: -        The opaque header from the server returned unchanged by the client.
>, <Line: -        It is recommended that this string be base64 or hexadecimal data.
>, <Line: -        Digest auth only.''')
>, <Line: -    @property
>, <Line: -    def qop(self):
>, <Line: -        """Indicates what "quality of protection" the client has applied to
>, <Line: -        the message for HTTP digest auth."""
>, <Line: -        def on_update(header_set):
>, <Line: -            if not header_set and 'qop' in self:
>, <Line: -                del self['qop']
>, <Line: -            elif header_set:
>, <Line: -                self['qop'] = header_set.to_header()
>, <Line: -        return parse_set_header(self.get('qop'), on_update)
>, <Line: -def parse_authorization_header(value):
>, <Line: -    """Parse an HTTP basic/digest authorization header transmitted by the web
>, <Line: -    browser.  The return value is either `None` if the header was invalid or
>, <Line: -    not given, otherwise an :class:`~Authorization`
>, <Line: -    object.
>, <Line: -    :param value:
>, <Line: -        The authorization header to parse.
>, <Line: -    :return:
>, <Line: -        A:class:`~Authorization` object or `None`.
>, <Line: -    """
>, <Line: -    if not value:
>, <Line: -        return
>, <Line: -    value = wsgi_to_bytes(value)
>, <Line: -    try:
>, <Line: -        auth_type, auth_info = value.split(None, 1)
>, <Line: -        auth_type = auth_type.lower()
>, <Line: -    except ValueError:
>, <Line: -        return
>, <Line: -    if auth_type == b'basic':
>, <Line: -        try:
>, <Line: -            username, password = base64.b64decode(auth_info).split(b':', 1)
>, <Line: -        except Exception:
>, <Line: -            return
>, <Line: -        return Authorization('basic', {'username':  bytes_to_wsgi(username),
>, <Line: -                                       'password': bytes_to_wsgi(password)})
>, <Line: -    elif auth_type == b'digest':
>, <Line: -        auth_map = parse_dict_header(auth_info)
>, <Line: -        for key in 'username', 'realm', 'nonce', 'uri', 'response':
>, <Line: -            if key not in auth_map:
>, <Line: -                return
>, <Line: -        if 'qop' in auth_map:
>, <Line: -            if not auth_map.get('nc') or not auth_map.get('cnonce'):
>, <Line: -                return
>, <Line: -        return Authorization('digest', auth_map)
>, <Line: -def auth_property(name, doc=None):
>, <Line: -    """A static helper function for subclasses to add extra authentication
>, <Line: -    system properties onto a class::
>, <Line: -        class FooAuthenticate(WWWAuthenticate):
>, <Line: -            special_realm = auth_property('special_realm')
>, <Line: -    For more information have a look at the sourcecode to see how the
>, <Line: -    regular properties (:attr:`realm` etc.) are implemented.
>, <Line: -    """
>, <Line: -    def _set_value(self, value):
>, <Line: -        if value is None:
>, <Line: -            self.pop(name, None)
>, <Line: -        else:
>, <Line: -            self[name] = str(value)
>, <Line: -    return property(lambda x: x.get(name), _set_value, doc=doc)
>, <Line: -class WWWAuthenticate(datastructures.UpdateDictMixin, dict):
>, <Line: -    """Provides simple access to `WWW-Authenticate` headers."""
>, <Line: -    #: list of keys that require quoting in the generated header
>, <Line: -    _require_quoting = frozenset(['domain', 'nonce', 'opaque', 'realm', 'qop'])
>, <Line: -    def __init__(self, auth_type=None, values=None, on_update=None):
>, <Line: -        dict.__init__(self, values or ())
>, <Line: -        if auth_type:
>, <Line: -            self['__auth_type__'] = auth_type
>, <Line: -        self.on_update = on_update
>, <Line: -    def set_basic(self, realm='authentication required'):
>, <Line: -        """Clear the auth info and enable basic auth."""
>, <Line: -        dict.clear(self)
>, <Line: -        dict.update(self, {'__auth_type__': 'basic', 'realm': realm})
>, <Line: -        if self.on_update:
>, <Line: -            self.on_update(self)
>, <Line: -    def set_digest(self, realm, nonce, qop=('auth',), opaque=None,
>, <Line: -                   algorithm=None, stale=False):
>, <Line: -        """Clear the auth info and enable digest auth."""
>, <Line: -        d = {
>, <Line: -            '__auth_type__':    'digest',
>, <Line: -            'realm':            realm,
>, <Line: -            'nonce':            nonce,
>, <Line: -            'qop':              dump_header(qop)
>, <Line: -        }
>, <Line: -        if stale:
>, <Line: -            d['stale'] = 'TRUE'
>, <Line: -        if opaque is not None:
>, <Line: -            d['opaque'] = opaque
>, <Line: -        if algorithm is not None:
>, <Line: -            d['algorithm'] = algorithm
>, <Line: -        dict.clear(self)
>, <Line: -        dict.update(self, d)
>, <Line: -        if self.on_update:
>, <Line: -            self.on_update(self)
>, <Line: -    def to_header(self):
>, <Line: -        """Convert the stored values into a WWW-Authenticate header."""
>, <Line: -        d = dict(self)
>, <Line: -        auth_type = d.pop('__auth_type__', None) or 'basic'
>, <Line: -        return '%s %s' % (auth_type.title(), ', '.join([
>, <Line: -            '%s=%s' % (key, quote_header_value(
>, <Line: -                value, allow_token=key not in self._require_quoting
>, <Line: -            ))
>, <Line: -            for key, value in d.items()
>, <Line: -        ]))
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %r>' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            self.to_header()
>, <Line: -        )
>, <Line: -    def _set_property(name, doc=None):
>, <Line: -        def fget(self):
>, <Line: -            def on_update(header_set):
>, <Line: -                if not header_set and name in self:
>, <Line: -                    del self[name]
>, <Line: -                elif header_set:
>, <Line: -                    self[name] = header_set.to_header()
>, <Line: -            return parse_set_header(self.get(name), on_update)
>, <Line: -        return property(fget, doc=doc)
>, <Line: -    type = auth_property('__auth_type__', doc='''
>, <Line: -        The type of the auth mechanism.  HTTP currently specifies
>, <Line: -        `Basic` and `Digest`.''')
>, <Line: -    realm = auth_property('realm', doc='''
>, <Line: -        A string to be displayed to users so they know which username and
>, <Line: -        password to use.  This string should contain at least the name of
>, <Line: -        the host performing the authentication and might additionally
>, <Line: -        indicate the collection of users who might have access.''')
>, <Line: -    domain = _set_property('domain', doc='''
>, <Line: -        A list of URIs that define the protection space.  If a URI is an
>, <Line: -        absolute path, it is relative to the canonical root URL of the
>, <Line: -        server being accessed.''')
>, <Line: -    nonce = auth_property('nonce', doc='''
>, <Line: -        A server-specified data string which should be uniquely generated
>, <Line: -        each time a 401 response is made.  It is recommended that this
>, <Line: -        string be base64 or hexadecimal data.''')
>, <Line: -    opaque = auth_property('opaque', doc='''
>, <Line: -        A string of data, specified by the server, which should be returned
>, <Line: -        by the client unchanged in the Authorization header of subsequent
>, <Line: -        requests with URIs in the same protection space.  It is recommended
>, <Line: -        that this string be base64 or hexadecimal data.''')
>, <Line: -    algorithm = auth_property('algorithm', doc='''
>, <Line: -        A string indicating a pair of algorithms used to produce the digest
>, <Line: -        and a checksum.  If this is not present it is assumed to be "MD5".
>, <Line: -        If the algorithm is not understood, the challenge should be ignored
>, <Line: -        (and a different one used, if there is more than one).''')
>, <Line: -    qop = _set_property('qop', doc='''
>, <Line: -        A set of quality-of-privacy directives such as auth and auth-int.''')
>, <Line: -    def _get_stale(self):
>, <Line: -        val = self.get('stale')
>, <Line: -        if val is not None:
>, <Line: -            return val.lower() == 'true'
>, <Line: -    def _set_stale(self, value):
>, <Line: -        if value is None:
>, <Line: -            self.pop('stale', None)
>, <Line: -        else:
>, <Line: -            self['stale'] = value and 'TRUE' or 'FALSE'
>, <Line: -    stale = property(_get_stale, _set_stale, doc='''
>, <Line: -        A flag, indicating that the previous request from the client was
>, <Line: -        rejected because the nonce value was stale.''')
>, <Line: -    del _get_stale, _set_stale
>, <Line: -    del _set_property
>, <Line: -# make auth_property a staticmethod so that subclasses of
>, <Line: -# `WWWAuthenticate` can use it for new properties.
>, <Line: -WWWAuthenticate.auth_property = staticmethod(auth_property)
>, <Line: -def parse_www_authenticate_header(value, on_update=None):
>, <Line: -    """Parse an HTTP WWW-Authenticate header into a
>, <Line: -    :class:`~WWWAuthenticate` object.
>, <Line: -    :param value:
>, <Line: -        A WWW-Authenticate header to parse.
>, <Line: -    :param on_update:
>, <Line: -        An optional callable that is called every time a value on the
>, <Line: -        :class:`~WWWAuthenticate` object is changed.
>, <Line: -    :return:
>, <Line: -        A:class:`~WWWAuthenticate` object.
>, <Line: -    """
>, <Line: -    if not value:
>, <Line: -        return WWWAuthenticate(on_update=on_update)
>, <Line: -    try:
>, <Line: -        auth_type, auth_info = value.split(None, 1)
>, <Line: -        auth_type = auth_type.lower()
>, <Line: -    except (ValueError, AttributeError):
>, <Line: -        return WWWAuthenticate(value.strip().lower(), on_update=on_update)
>, <Line: -    return WWWAuthenticate(auth_type, parse_dict_header(auth_info),
>, <Line: -                           on_update)
>, <Line: -class IfRange(object):
>, <Line: -    """Very simple object that represents the `If-Range` header in parsed
>, <Line: -    form.  It will either have neither a etag or date or one of either but
>, <Line: -    never both.
>, <Line: -    """
>, <Line: -    def __init__(self, etag=None, date=None):
>, <Line: -        #: The etag parsed and unquoted.  Ranges always operate on strong
>, <Line: -        #: etags so the weakness information is not necessary.
>, <Line: -        self.etag = etag
>, <Line: -        #: The date in parsed format or `None`.
>, <Line: -        self.date = date
>, <Line: -    def to_header(self):
>, <Line: -        """Converts the object back into an HTTP header."""
>, <Line: -        if self.date is not None:
>, <Line: -            return http_date(self.date)
>, <Line: -        if self.etag is not None:
>, <Line: -            return quote_etag(self.etag)
>, <Line: -        return ''
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: -def parse_if_range_header(value):
>, <Line: -    """Parses an if-range header which can be an etag or a date.  Returns
>, <Line: -    a :class:`~IfRange` object.
>, <Line: -    """
>, <Line: -    if not value:
>, <Line: -        return IfRange()
>, <Line: -    date = parse_date(value)
>, <Line: -    if date is not None:
>, <Line: -        return IfRange(date=date)
>, <Line: -    # drop weakness information
>, <Line: -    return IfRange(unquote_etag(value)[0])
>, <Line: -class Range(object):
>, <Line: -    """Represents a range header.  All the methods are only supporting bytes
>, <Line: -    as unit.  It does store multiple ranges but :meth:`range_for_length` will
>, <Line: -    only work if only one range is provided.
>, <Line: -    """
>, <Line: -    def __init__(self, units, ranges):
>, <Line: -        #: The units of this range.  Usually "bytes".
>, <Line: -        self.units = units
>, <Line: -        #: A list of ``(begin, end)`` tuples for the range header provided.
>, <Line: -        #: The ranges are non-inclusive.
>, <Line: -        self.ranges = ranges
>, <Line: -    def range_for_length(self, length):
>, <Line: -        """If the range is for bytes, the length is not None and there is
>, <Line: -        exactly one range and it is satisfiable it returns a ``(start, stop)``
>, <Line: -        tuple, otherwise `None`.
>, <Line: -        """
>, <Line: -        if self.units != 'bytes' or length is None or len(self.ranges) != 1:
>, <Line: -            return None
>, <Line: -        start, end = self.ranges[0]
>, <Line: -        if end is None:
>, <Line: -            end = length
>, <Line: -            if start < 0:
>, <Line: -                start += length
>, <Line: -        if is_byte_range_valid(start, end, length):
>, <Line: -            return start, min(end, length)
>, <Line: -    def make_content_range(self, length):
>, <Line: -        """Creates a :class:`~verktyg.datastructures.ContentRange` object
>, <Line: -        from the current range and given content length.
>, <Line: -        """
>, <Line: -        rng = self.range_for_length(length)
>, <Line: -        if rng is not None:
>, <Line: -            return ContentRange(self.units, rng[0], rng[1], length)
>, <Line: -    def to_header(self):
>, <Line: -        """Converts the object back into an HTTP header."""
>, <Line: -        ranges = []
>, <Line: -        for begin, end in self.ranges:
>, <Line: -            if end is None:
>, <Line: -                ranges.append(begin >= 0 and '%s-' % begin or str(begin))
>, <Line: -            else:
>, <Line: -                ranges.append('%s-%s' % (begin, end - 1))
>, <Line: -        return '%s=%s' % (self.units, ','.join(ranges))
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: -def parse_range_header(value, make_inclusive=True):
>, <Line: -    """Parses a range header into a :class:`~Range`
>, <Line: -    object.  If the header is missing or malformed `None` is returned.
>, <Line: -    `ranges` is a list of ``(start, stop)`` tuples where the ranges are
>, <Line: -    non-inclusive.
>, <Line: -    """
>, <Line: -    if not value or '=' not in value:
>, <Line: -        return None
>, <Line: -    ranges = []
>, <Line: -    last_end = 0
>, <Line: -    units, rng = value.split('=', 1)
>, <Line: -    units = units.strip().lower()
>, <Line: -    for item in rng.split(','):
>, <Line: -        item = item.strip()
>, <Line: -        if '-' not in item:
>, <Line: -            return None
>, <Line: -        if item.startswith('-'):
>, <Line: -            if last_end < 0:
>, <Line: -                return None
>, <Line: -            begin = int(item)
>, <Line: -            end = None
>, <Line: -            last_end = -1
>, <Line: -        elif '-' in item:
>, <Line: -            begin, end = item.split('-', 1)
>, <Line: -            begin = int(begin)
>, <Line: -            if begin < last_end or last_end < 0:
>, <Line: -                return None
>, <Line: -            if end:
>, <Line: -                end = int(end) + 1
>, <Line: -                if begin >= end:
>, <Line: -                    return None
>, <Line: -            else:
>, <Line: -                end = None
>, <Line: -            last_end = end
>, <Line: -        ranges.append((begin, end))
>, <Line: -    return Range(units, ranges)
>, <Line: -class ContentRange(object):
>, <Line: -    """Represents the content range header.
>, <Line: -    """
>, <Line: -    def __init__(self, units, start, stop, length=None, on_update=None):
>, <Line: -        assert is_byte_range_valid(start, stop, length), \
>, <Line: -            'Bad range provided'
>, <Line: -        self.on_update = on_update
>, <Line: -        self.set(start, stop, length, units)
>, <Line: -    def _callback_property(name):
>, <Line: -        def fget(self):
>, <Line: -            return getattr(self, name)
>, <Line: -        def fset(self, value):
>, <Line: -            setattr(self, name, value)
>, <Line: -            if self.on_update is not None:
>, <Line: -                self.on_update(self)
>, <Line: -        return property(fget, fset)
>, <Line: -    #: The units to use, usually "bytes"
>, <Line: -    units = _callback_property('_units')
>, <Line: -    #: The start point of the range or `None`.
>, <Line: -    start = _callback_property('_start')
>, <Line: -    #: The stop point of the range (non-inclusive) or `None`.  Can only be
>, <Line: -    #: `None` if also start is `None`.
>, <Line: -    stop = _callback_property('_stop')
>, <Line: -    #: The length of the range or `None`.
>, <Line: -    length = _callback_property('_length')
>, <Line: -    def set(self, start, stop, length=None, units='bytes'):
>, <Line: -        """Simple method to update the ranges."""
>, <Line: -        assert is_byte_range_valid(start, stop, length), \
>, <Line: -            'Bad range provided'
>, <Line: -        self._units = units
>, <Line: -        self._start = start
>, <Line: -        self._stop = stop
>, <Line: -        self._length = length
>, <Line: -        if self.on_update is not None:
>, <Line: -            self.on_update(self)
>, <Line: -    def unset(self):
>, <Line: -        """Sets the units to `None` which indicates that the header should
>, <Line: -        no longer be used.
>, <Line: -        """
>, <Line: -        self.set(None, None, units=None)
>, <Line: -    def to_header(self):
>, <Line: -        if self.units is None:
>, <Line: -            return ''
>, <Line: -        if self.length is None:
>, <Line: -            length = '*'
>, <Line: -        else:
>, <Line: -            length = self.length
>, <Line: -        if self.start is None:
>, <Line: -            return '%s */%s' % (self.units, length)
>, <Line: -        return '%s %s-%s/%s' % (
>, <Line: -            self.units,
>, <Line: -            self.start,
>, <Line: -            self.stop - 1,
>, <Line: -            length
>, <Line: -        )
>, <Line: -    def __nonzero__(self):
>, <Line: -        return self.units is not None
>, <Line: -    __bool__ = __nonzero__
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: -def parse_content_range_header(value, on_update=None):
>, <Line: -    """Parses a range header into a
>, <Line: -    :class:`~ContentRange` object or `None` if
>, <Line: -    parsing is not possible.
>, <Line: -    :param value:
>, <Line: -        A content range header to be parsed.
>, <Line: -    :param on_update:
>, <Line: -        An optional callable that is called every time a value on the
>, <Line: -        :class:`~ContentRange` object is changed.
>, <Line: -    """
>, <Line: -    if value is None:
>, <Line: -        return None
>, <Line: -    try:
>, <Line: -        units, rangedef = (value or '').strip().split(None, 1)
>, <Line: -    except ValueError:
>, <Line: -        return None
>, <Line: -    if '/' not in rangedef:
>, <Line: -        return None
>, <Line: -    rng, length = rangedef.split('/', 1)
>, <Line: -    if length == '*':
>, <Line: -        length = None
>, <Line: -    elif length.isdigit():
>, <Line: -        length = int(length)
>, <Line: -    else:
>, <Line: -        return None
>, <Line: -    if rng == '*':
>, <Line: -        return ContentRange(units, None, None, length, on_update=on_update)
>, <Line: -    elif '-' not in rng:
>, <Line: -        return None
>, <Line: -    start, stop = rng.split('-', 1)
>, <Line: -    try:
>, <Line: -        start = int(start)
>, <Line: -        stop = int(stop) + 1
>, <Line: -    except ValueError:
>, <Line: -        return None
>, <Line: -    if is_byte_range_valid(start, stop, length):
>, <Line: -        return ContentRange(units, start, stop, length, on_update=on_update)
>, <Line: -def quote_etag(etag, weak=False):
>, <Line: -    """Quote an etag.
>, <Line: -    :param etag:
>, <Line: -        The etag to quote.
>, <Line: -    :param weak:
>, <Line: -        Set to `True` to tag it "weak".
>, <Line: -    """
>, <Line: -    if '"' in etag:
>, <Line: -        raise ValueError('invalid etag')
>, <Line: -    etag = '"%s"' % etag
>, <Line: -    if weak:
>, <Line: -        etag = 'w/' + etag
>, <Line: -    return etag
>, <Line: -def unquote_etag(etag):
>, <Line: -    """Unquote a single etag:
>, <Line: -    >>> unquote_etag('w/"bar"')
>, <Line: -    ('bar', True)
>, <Line: -    >>> unquote_etag('"bar"')
>, <Line: -    ('bar', False)
>, <Line: -    :param etag:
>, <Line: -        The etag identifier to unquote.
>, <Line: -    :return:
>, <Line: -        An ``(etag, weak)`` tuple.
>, <Line: -    """
>, <Line: -    if not etag:
>, <Line: -        return None, None
>, <Line: -    etag = etag.strip()
>, <Line: -    weak = False
>, <Line: -    if etag[:2] in ('w/', 'W/'):
>, <Line: -        weak = True
>, <Line: -        etag = etag[2:]
>, <Line: -    if etag[:1] == etag[-1:] == '"':
>, <Line: -        etag = etag[1:-1]
>, <Line: -    return etag, weak
>, <Line: -class ETags(object):
>, <Line: -    """A set that can be used to check if one etag is present in a collection
>, <Line: -    of etags.
>, <Line: -    """
>, <Line: -    def __init__(self, strong_etags=None, weak_etags=None, star_tag=False):
>, <Line: -        self._strong = frozenset(not star_tag and strong_etags or ())
>, <Line: -        self._weak = frozenset(weak_etags or ())
>, <Line: -        self.star_tag = star_tag
>, <Line: -    def as_set(self, include_weak=False):
>, <Line: -        """Convert the `ETags` object into a python set.  Per default all the
>, <Line: -        weak etags are not part of this set."""
>, <Line: -        rv = set(self._strong)
>, <Line: -        if include_weak:
>, <Line: -            rv.update(self._weak)
>, <Line: -        return rv
>, <Line: -    def is_weak(self, etag):
>, <Line: -        """Check if an etag is weak."""
>, <Line: -        return etag in self._weak
>, <Line: -    def contains_weak(self, etag):
>, <Line: -        """Check if an etag is part of the set including weak and strong tags.
>, <Line: -        """
>, <Line: -        return self.is_weak(etag) or self.contains(etag)
>, <Line: -    def contains(self, etag):
>, <Line: -        """Check if an etag is part of the set ignoring weak tags.
>, <Line: -        It is also possible to use the ``in`` operator.
>, <Line: -        """
>, <Line: -        if self.star_tag:
>, <Line: -            return True
>, <Line: -        return etag in self._strong
>, <Line: -    def contains_raw(self, etag):
>, <Line: -        """When passed a quoted tag it will check if this tag is part of the
>, <Line: -        set.  If the tag is weak it is checked against weak and strong tags,
>, <Line: -        otherwise strong only."""
>, <Line: -        etag, weak = unquote_etag(etag)
>, <Line: -        if weak:
>, <Line: -            return self.contains_weak(etag)
>, <Line: -        return self.contains(etag)
>, <Line: -    def to_header(self):
>, <Line: -        """Convert the etags set into a HTTP header string."""
>, <Line: -        if self.star_tag:
>, <Line: -            return '*'
>, <Line: -        return ', '.join(
>, <Line: -            ['"%s"' % x for x in self._strong] +
>, <Line: -            ['w/"%s"' % x for x in self._weak]
>, <Line: -        )
>, <Line: -    def __call__(self, etag=None, data=None, include_weak=False):
>, <Line: -        if [etag, data].count(None) != 1:
>, <Line: -            raise TypeError('either tag or data required, but at least one')
>, <Line: -        if etag is None:
>, <Line: -            etag = generate_etag(data)
>, <Line: -        if include_weak:
>, <Line: -            if etag in self._weak:
>, <Line: -                return True
>, <Line: -        return etag in self._strong
>, <Line: -    def __bool__(self):
>, <Line: -        return bool(self.star_tag or self._strong or self._weak)
>, <Line: -    __nonzero__ = __bool__
>, <Line: -    def __str__(self):
>, <Line: -        return self.to_header()
>, <Line: -    def __iter__(self):
>, <Line: -        return iter(self._strong)
>, <Line: -    def __contains__(self, etag):
>, <Line: -        return self.contains(etag)
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s %r>' % (self.__class__.__name__, str(self))
>, <Line: -def parse_etags(value):
>, <Line: -    """Parse an etag header.
>, <Line: -    :param value:
>, <Line: -        The tag header to parse
>, <Line: -    :return:
>, <Line: -        An :class:`~ETags` object.
>, <Line: -    """
>, <Line: -    if not value:
>, <Line: -        return ETags()
>, <Line: -    strong = []
>, <Line: -    weak = []
>, <Line: -    end = len(value)
>, <Line: -    pos = 0
>, <Line: -    while pos < end:
>, <Line: -        match = _etag_re.match(value, pos)
>, <Line: -        if match is None:
>, <Line: -            break
>, <Line: -        is_weak, quoted, raw = match.groups()
>, <Line: -        if raw == '*':
>, <Line: -            return ETags(star_tag=True)
>, <Line: -        elif quoted:
>, <Line: -            raw = quoted
>, <Line: -        if is_weak:
>, <Line: -            weak.append(raw)
>, <Line: -        else:
>, <Line: -            strong.append(raw)
>, <Line: -        pos = match.end()
>, <Line: -    return ETags(strong, weak)
>, <Line: -def generate_etag(data):
>, <Line: -    """Generate an etag for some data."""
>, <Line: -    return md5(data).hexdigest()
>, <Line: -def parse_date(value):
>, <Line: -    """Parse one of the following date formats into a datetime object:
>, <Line: -    .. sourcecode:: text
>, <Line: -        Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
>, <Line: -        Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
>, <Line: -        Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
>, <Line: -    If parsing fails the return value is `None`.
>, <Line: -    :param value:
>, <Line: -        A string with a supported date format.
>, <Line: -    :return:
>, <Line: -        A :class:`datetime.datetime` object.
>, <Line: -    """
>, <Line: -    if value:
>, <Line: -        t = parsedate_tz(value.strip())
>, <Line: -        if t is not None:
>, <Line: -            try:
>, <Line: -                year = t[0]
>, <Line: -                # unfortunately that function does not tell us if two digit
>, <Line: -                # years were part of the string, or if they were prefixed
>, <Line: -                # with two zeroes.  So what we do is to assume that 69-99
>, <Line: -                # refer to 1900, and everything below to 2000
>, <Line: -                if year >= 0 and year <= 68:
>, <Line: -                    year += 2000
>, <Line: -                elif year >= 69 and year <= 99:
>, <Line: -                    year += 1900
>, <Line: -                return datetime(*((year,) + t[1:7])) - \
>, <Line: -                    timedelta(seconds=t[-1] or 0)
>, <Line: -            except (ValueError, OverflowError):
>, <Line: -                return None
>, <Line: -def _dump_date(d, delim):
>, <Line: -    """Used for `http_date` and `cookie_date`."""
>, <Line: -    if d is None:
>, <Line: -        d = gmtime()
>, <Line: -    elif isinstance(d, datetime):
>, <Line: -        d = d.utctimetuple()
>, <Line: -    elif isinstance(d, (int, float)):
>, <Line: -        d = gmtime(d)
>, <Line: -    return '%s, %02d%s%s%s%s %02d:%02d:%02d GMT' % (
>, <Line: -        ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')[d.tm_wday],
>, <Line: -        d.tm_mday, delim,
>, <Line: -        ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
>, <Line: -         'Oct', 'Nov', 'Dec')[d.tm_mon - 1],
>, <Line: -        delim, str(d.tm_year), d.tm_hour, d.tm_min, d.tm_sec
>, <Line: -    )
>, <Line: -def cookie_date(expires=None):
>, <Line: -    """Formats the time to ensure compatibility with Netscape's cookie
>, <Line: -    standard.
>, <Line: -    Accepts a floating point number expressed in seconds since the epoch in, a
>, <Line: -    datetime object or a timetuple.  All times in UTC.  The :func:`parse_date`
>, <Line: -    function can be used to parse such a date.
>, <Line: -    Outputs a string in the format ``Wdy, DD-Mon-YYYY HH:MM:SS GMT``.
>, <Line: -    :param expires:
>, <Line: -        If provided that date is used, otherwise the current.
>, <Line: -    """
>, <Line: -    return _dump_date(expires, '-')
>, <Line: -def http_date(timestamp=None):
>, <Line: -    """Formats the time to match the RFC1123 date format.
>, <Line: -    Accepts a floating point number expressed in seconds since the epoch in, a
>, <Line: -    datetime object or a timetuple.  All times in UTC.  The :func:`parse_date`
>, <Line: -    function can be used to parse such a date.
>, <Line: -    Outputs a string in the format ``Wdy, DD Mon YYYY HH:MM:SS GMT``.
>, <Line: -    :param timestamp:
>, <Line: -        If provided that date is used, otherwise the current.
>, <Line: -    """
>, <Line: -    return _dump_date(timestamp, ' ')
>, <Line: -def is_resource_modified(environ, etag=None, data=None, last_modified=None):
>, <Line: -    """Convenience method for conditional requests.
>, <Line: -    :param environ:
>, <Line: -        The WSGI environment of the request to be checked.
>, <Line: -    :param etag:
>, <Line: -        The etag for the response for comparison.
>, <Line: -    :param data:
>, <Line: -        Or alternatively the data of the response to automatically generate an
>, <Line: -        etag using :func:`generate_etag`.
>, <Line: -    :param last_modified:
>, <Line: -        An optional date of the last modification.
>, <Line: -    :return:
>, <Line: -        `True` if the resource was modified, otherwise `False`.
>, <Line: -    """
>, <Line: -    if etag is None and data is not None:
>, <Line: -        etag = generate_etag(data)
>, <Line: -    elif data is not None:
>, <Line: -        raise TypeError('both data and etag given')
>, <Line: -    if environ['REQUEST_METHOD'] not in ('GET', 'HEAD'):
>, <Line: -        return False
>, <Line: -    unmodified = False
>, <Line: -    if isinstance(last_modified, str):
>, <Line: -        last_modified = parse_date(last_modified)
>, <Line: -    # ensure that microsecond is zero because the HTTP spec does not transmit
>, <Line: -    # that either and we might have some false positives.  See issue #39
>, <Line: -    if last_modified is not None:
>, <Line: -        last_modified = last_modified.replace(microsecond=0)
>, <Line: -    modified_since = parse_date(environ.get('HTTP_IF_MODIFIED_SINCE'))
>, <Line: -    if modified_since and last_modified and last_modified <= modified_since:
>, <Line: -        unmodified = True
>, <Line: -    if etag:
>, <Line: -        if_none_match = parse_etags(environ.get('HTTP_IF_NONE_MATCH'))
>, <Line: -        if if_none_match:
>, <Line: -            unmodified = if_none_match.contains_raw(etag)
>, <Line: -    return not unmodified
>, <Line: -def remove_entity_headers(headers, allowed=('expires', 'content-location')):
>, <Line: -    """Remove all entity headers from a list or :class:`Headers` object.  This
>, <Line: -    operation works in-place.  `Expires` and `Content-Location` headers are
>, <Line: -    by default not removed.  The reason for this is :rfc:`2616` section
>, <Line: -    10.3.5 which specifies some entity headers that should be sent.
>, <Line: -    :param headers:
>, <Line: -        A list or :class:`Headers` object.
>, <Line: -    :param allowed:
>, <Line: -        A list of headers that should still be allowed even though they are
>, <Line: -        entity headers.
>, <Line: -    """
>, <Line: -    allowed = set(x.lower() for x in allowed)
>, <Line: -    headers[:] = [(key, value) for key, value in headers if
>, <Line: -                  not is_entity_header(key) or key.lower() in allowed]
>, <Line: -def remove_hop_by_hop_headers(headers):
>, <Line: -    """Remove all HTTP/1.1 "Hop-by-Hop" headers from a list or
>, <Line: -    :class:`Headers` object.  This operation works in-place.
>, <Line: -    :param headers:
>, <Line: -        A list or :class:`Headers` object.
>, <Line: -    """
>, <Line: -    headers[:] = [(key, value) for key, value in headers if
>, <Line: -                  not is_hop_by_hop_header(key)]
>, <Line: -def is_entity_header(header):
>, <Line: -    """Check if a header is an entity header.
>, <Line: -    :param header:
>, <Line: -        The header to test.
>, <Line: -    :return:
>, <Line: -        `True` if it's an entity header, `False` otherwise.
>, <Line: -    """
>, <Line: -    return header.lower() in _entity_headers
>, <Line: -def is_hop_by_hop_header(header):
>, <Line: -    """Check if a header is an HTTP/1.1 "Hop-by-Hop" header.
>, <Line: -    :param header:
>, <Line: -        The header to test.
>, <Line: -    :return:
>, <Line: -        `True` if it's an entity header, `False` otherwise.
>, <Line: -    """
>, <Line: -    return header.lower() in _hop_by_hop_headers
>, <Line: -def parse_cookie(header, charset='utf-8', errors='replace', cls=None):
>, <Line: -    """Parse a cookie.  Either from a string or WSGI environ.
>, <Line: -    Per default encoding errors are ignored.  If you want a different behavior
>, <Line: -    you can set `errors` to ``'replace'`` or ``'strict'``.  In strict mode a
>, <Line: -    :exc:`HTTPUnicodeError` is raised.
>, <Line: -    :param header:
>, <Line: -        The header to be used to parse the cookie.  Alternatively this can be a
>, <Line: -        WSGI environment.
>, <Line: -    :param charset:
>, <Line: -        The charset for the cookie values.
>, <Line: -    :param errors:
>, <Line: -        The error behavior for the charset decoding.
>, <Line: -    :param cls:
>, <Line: -        An optional dict class to use.  If this is not specified or `None` the
>, <Line: -        default :class:`TypeConversionDict` is used.
>, <Line: -    """
>, <Line: -    if isinstance(header, dict):
>, <Line: -        header = header.get('HTTP_COOKIE', '')
>, <Line: -    elif header is None:
>, <Line: -        header = ''
>, <Line: -    # If the value is an unicode string it's mangled through latin1.  This
>, <Line: -    # is done because on PEP 3333 on Python 3 all headers are assumed latin1
>, <Line: -    # which however is incorrect for cookies, which are sent in page encoding.
>, <Line: -    # As a result we
>, <Line: -    if isinstance(header, str):
>, <Line: -        header = header.encode('latin1', 'replace')
>, <Line: -    if cls is None:
>, <Line: -        cls = datastructures.TypeConversionDict
>, <Line: -    def _parse_pairs():
>, <Line: -        for key, val in _cookie_parse_impl(header):
>, <Line: -            key = to_unicode(key, charset, errors, allow_none_charset=True)
>, <Line: -            val = to_unicode(val, charset, errors, allow_none_charset=True)
>, <Line: -            yield key, val
>, <Line: -    return cls(_parse_pairs())
>, <Line: -def dump_cookie(key, value='', max_age=None, expires=None, path='/',
>, <Line: -                domain=None, secure=False, httponly=False,
>, <Line: -                charset='utf-8', sync_expires=True):
>, <Line: -    """Creates a new Set-Cookie header without the ``Set-Cookie`` prefix
>, <Line: -    The parameters are the same as in the cookie Morsel object in the
>, <Line: -    Python standard library but it accepts unicode data, too.
>, <Line: -    On Python 3 the return value of this function will be a unicode
>, <Line: -    string, on Python 2 it will be a native string.  In both cases the
>, <Line: -    return value is usually restricted to ascii as the vast majority of
>, <Line: -    values are properly escaped, but that is no guarantee.  If a unicode
>, <Line: -    string is returned it's tunneled through latin1 as required by
>, <Line: -    PEP 3333.
>, <Line: -    The return value is not ASCII safe if the key contains unicode
>, <Line: -    characters.  This is technically against the specification but
>, <Line: -    happens in the wild.  It's strongly recommended to not use
>, <Line: -    non-ASCII values for the keys.
>, <Line: -    :param max_age:
>, <Line: -        Should be a number of seconds, or `None` (default) if the cookie should
>, <Line: -        last only as long as the client's browser session.  Additionally
>, <Line: -        `timedelta` objects are accepted, too.
>, <Line: -    :param expires:
>, <Line: -        Should be a `datetime` object or unix timestamp.
>, <Line: -    :param path:
>, <Line: -        Limits the cookie to a given path, per default it will span the whole
>, <Line: -        domain.
>, <Line: -    :param domain:
>, <Line: -        Use this if you want to set a cross-domain cookie. For example,
>, <Line: -        ``domain=".example.com"`` will set a cookie that is readable by the
>, <Line: -        domain ``www.example.com``, ``foo.example.com`` etc. Otherwise, a
>, <Line: -        cookie will only be readable by the domain that set it.
>, <Line: -    :param secure:
>, <Line: -        The cookie will only be available via HTTPS.
>, <Line: -    :param httponly:
>, <Line: -        Disallow JavaScript to access the cookie.  This is an extension to the
>, <Line: -        cookie standard and probably not supported by all browsers.
>, <Line: -    :param charset:
>, <Line: -        The encoding for unicode values.
>, <Line: -    :param sync_expires:
>, <Line: -        Automatically set expires if max_age is defined but expires not.
>, <Line: -    """
>, <Line: -    key = to_bytes(key, charset)
>, <Line: -    value = to_bytes(value, charset)
>, <Line: -    if path is not None:
>, <Line: -        path = iri_to_uri(path, charset)
>, <Line: -    domain = _make_cookie_domain(domain)
>, <Line: -    if isinstance(max_age, timedelta):
>, <Line: -        max_age = (max_age.days * 60 * 60 * 24) + max_age.seconds
>, <Line: -    if expires is not None:
>, <Line: -        if not isinstance(expires, str):
>, <Line: -            expires = cookie_date(expires)
>, <Line: -    elif max_age is not None and sync_expires:
>, <Line: -        expires = to_bytes(cookie_date(time() + max_age))
>, <Line: -    buf = [key + b'=' + _cookie_quote(value)]
>, <Line: -    # XXX: In theory all of these parameters that are not marked with `None`
>, <Line: -    # should be quoted.  Because stdlib did not quote it before I did not
>, <Line: -    # want to introduce quoting there now.
>, <Line: -    for k, v, q in ((b'Domain', domain, True),
>, <Line: -                    (b'Expires', expires, False,),
>, <Line: -                    (b'Max-Age', max_age, False),
>, <Line: -                    (b'Secure', secure, None),
>, <Line: -                    (b'HttpOnly', httponly, None),
>, <Line: -                    (b'Path', path, False)):
>, <Line: -        if q is None:
>, <Line: -            if v:
>, <Line: -                buf.append(k)
>, <Line: -            continue
>, <Line: -        if v is None:
>, <Line: -            continue
>, <Line: -        tmp = bytearray(k)
>, <Line: -        if not isinstance(v, (bytes, bytearray)):
>, <Line: -            v = to_bytes(str(v), charset)
>, <Line: -        if q:
>, <Line: -            v = _cookie_quote(v)
>, <Line: -        tmp += b'=' + v
>, <Line: -        buf.append(bytes(tmp))
>, <Line: -    # The return value will be an incorrectly encoded latin1 header on
>, <Line: -    # Python 3 for consistency with the headers object and a bytestring
>, <Line: -    # on Python 2 because that's how the API makes more sense.
>, <Line: -    rv = b'; '.join(buf)
>, <Line: -    rv = rv.decode('latin1')
>, <Line: -    return rv
>, <Line: -def is_byte_range_valid(start, stop, length):
>, <Line: -    """Checks if a given byte content range is valid for the given length.
>, <Line: -    """
>, <Line: -    if (start is None) != (stop is None):
>, <Line: -        return False
>, <Line: -    elif start is None:
>, <Line: -        return length is None or length >= 0
>, <Line: -    elif length is None:
>, <Line: -        return 0 <= start < stop
>, <Line: -    elif start >= stop:
>, <Line: -        return False
>, <Line: -    return 0 <= start < length
>, <Line: -class FileStorage(object):
>, <Line: -    """The :class:`FileStorage` class is a thin wrapper over incoming files.
>, <Line: -    It is used by the request object to represent uploaded files.  All the
>, <Line: -    attributes of the wrapper stream are proxied by the file storage so
>, <Line: -    it's possible to do ``storage.read()`` instead of the long form
>, <Line: -    ``storage.stream.read()``.
>, <Line: -    """
>, <Line: -    def __init__(self, stream=None, filename=None, name=None,
>, <Line: -                 content_type=None, content_length=None,
>, <Line: -                 headers=None):
>, <Line: -        self.name = name
>, <Line: -        self.stream = stream or _empty_stream
>, <Line: -        # if no filename is provided we can attempt to get the filename
>, <Line: -        # from the stream object passed.  There we have to be careful to
>, <Line: -        # skip things like <fdopen>, <stderr> etc.  Python marks these
>, <Line: -        # special filenames with angular brackets.
>, <Line: -        if filename is None:
>, <Line: -            filename = getattr(stream, 'name', None)
>, <Line: -            s = make_literal_wrapper(filename)
>, <Line: -            if filename and filename[0] == s('<') and filename[-1] == s('>'):
>, <Line: -                filename = None
>, <Line: -            # On Python 3 we want to make sure the filename is always unicode.
>, <Line: -            # This might not be if the name attribute is bytes due to the
>, <Line: -            # file being opened from the bytes API.
>, <Line: -            if isinstance(filename, bytes):
>, <Line: -                filename = filename.decode(sys.getfilesystemencoding(),
>, <Line: -                                           'replace')
>, <Line: -        self.filename = filename
>, <Line: -        if headers is None:
>, <Line: -            headers = Headers()
>, <Line: -        self.headers = headers
>, <Line: -        if content_type is not None:
>, <Line: -            headers['Content-Type'] = content_type
>, <Line: -        if content_length is not None:
>, <Line: -            headers['Content-Length'] = str(content_length)
>, <Line: -    def _parse_content_type(self):
>, <Line: -        if not hasattr(self, '_parsed_content_type'):
>, <Line: -            self._parsed_content_type = \
>, <Line: -                parse_options_header(self.content_type)
>, <Line: -    @property
>, <Line: -    def content_type(self):
>, <Line: -        """The content-type sent in the header.  Usually not available"""
>, <Line: -        return self.headers.get('content-type')
>, <Line: -    @property
>, <Line: -    def content_length(self):
>, <Line: -        """The content-length sent in the header.  Usually not available"""
>, <Line: -        return int(self.headers.get('content-length') or 0)
>, <Line: -    @property
>, <Line: -    def mimetype(self):
>, <Line: -        """Like :attr:`content_type`, but without parameters (eg, without
>, <Line: -        charset, type etc.) and always lowercase.  For example if the content
>, <Line: -        type is ``text/HTML; charset=utf-8`` the mimetype would be
>, <Line: -        ``'text/html'``.
>, <Line: -        """
>, <Line: -        self._parse_content_type()
>, <Line: -        return self._parsed_content_type[0].lower()
>, <Line: -    @property
>, <Line: -    def mimetype_params(self):
>, <Line: -        """The mimetype parameters as dict.  For example if the content
>, <Line: -        type is ``text/html; charset=utf-8`` the params would be
>, <Line: -        ``{'charset': 'utf-8'}``.
>, <Line: -        """
>, <Line: -        self._parse_content_type()
>, <Line: -        return self._parsed_content_type[1]
>, <Line: -    def save(self, dst, buffer_size=16384):
>, <Line: -        """Save the file to a destination path or file object.  If the
>, <Line: -        destination is a file object you have to close it yourself after the
>, <Line: -        call.  The buffer size is the number of bytes held in memory during
>, <Line: -        the copy process.  It defaults to 16KB.
>, <Line: -        For secure file saving also have a look at :func:`secure_filename`.
>, <Line: -        :param dst:
>, <Line: -            A filename or open file object the uploaded file is saved to.
>, <Line: -        :param buffer_size:
>, <Line: -            The size of the buffer.  This works the same as the `length`
>, <Line: -            parameter of :func:`shutil.copyfileobj`.
>, <Line: -        """
>, <Line: -        from shutil import copyfileobj
>, <Line: -        close_dst = False
>, <Line: -        if isinstance(dst, str):
>, <Line: -            dst = open(dst, 'wb')
>, <Line: -            close_dst = True
>, <Line: -        try:
>, <Line: -            copyfileobj(self.stream, dst, buffer_size)
>, <Line: -        finally:
>, <Line: -            if close_dst:
>, <Line: -                dst.close()
>, <Line: -    def close(self):
>, <Line: -        """Close the underlying file if possible."""
>, <Line: -        try:
>, <Line: -            self.stream.close()
>, <Line: -        except Exception:
>, <Line: -            pass
>, <Line: -    def __nonzero__(self):
>, <Line: -        return bool(self.filename)
>, <Line: -    __bool__ = __nonzero__
>, <Line: -    def __getattr__(self, name):
>, <Line: -        return getattr(self.stream, name)
>, <Line: -    def __iter__(self):
>, <Line: -        return iter(self.readline, '')
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s: %r (%r)>' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            self.filename,
>, <Line: -            self.content_type
>, <Line: -        )
>]