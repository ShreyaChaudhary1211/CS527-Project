[<Line: +"""
>, <Line: +    verktyg.http.cookies
>, <Line: +    ~~~~~~~~~~~~~~~~~~~~
>, <Line: +    :copyright:
>, <Line: +        (c) 2015 Ben Mather, based on Werkzeug, see AUTHORS for more details.
>, <Line: +    :license:
>, <Line: +        BSD, see LICENSE for more details.
>, <Line: +"""
>, <Line: +import re
>, <Line: +import string
>, <Line: +from itertools import chain
>, <Line: +from time import time
>, <Line: +from datetime import timedelta
>, <Line: +from werkzeug._compat import to_unicode, to_bytes, iter_bytes
>, <Line: +from werkzeug._internal import _encode_idna
>, <Line: +from werkzeug.urls import iri_to_uri
>, <Line: +from verktyg import datastructures
>, <Line: +from verktyg.http.basic import _dump_date
>, <Line: +_cookie_params = {
>, <Line: +    b'expires', b'path', b'comment', b'max-age',
>, <Line: +    b'secure', b'httponly', b'version',
>, <Line: +}
>, <Line: +_legal_cookie_chars = (
>, <Line: +    string.ascii_letters + string.digits + u"!#$%&'*+-.^_`|~:").encode('ascii')
>, <Line: +_cookie_quoting_map = {
>, <Line: +    b',': b'\\054',
>, <Line: +    b';': b'\\073',
>, <Line: +    b'"': b'\\"',
>, <Line: +    b'\\': b'\\\\',
>, <Line: +}
>, <Line: +for _i in chain(range(32), range(127, 256)):
>, <Line: +    _cookie_quoting_map[_i.to_bytes(1, 'big')] = (
>, <Line: +        '\\%03o' % _i
>, <Line: +    ).encode('latin1')
>, <Line: +_octal_re = re.compile(b'\\\\[0-3][0-7][0-7]')
>, <Line: +_quote_re = re.compile(b'[\\\\].')
>, <Line: +_legal_cookie_chars_re = b'[\w\d!#%&\'~_`><@,:/\$\*\+\-\.\^\|\)\(\?\}\{\=]'
>, <Line: +_cookie_re = re.compile(b"""(?x)
>, <Line: +    (?P<key>[^=]+)
>, <Line: +    \s*=\s*
>, <Line: +    (?P<val>
>, <Line: +        "(?:[^\\\\"]|\\\\.)*" |
>, <Line: +         (?:.*?)
>, <Line: +    )
>, <Line: +    \s*;
>, <Line: +""")
>, <Line: +def _cookie_quote(b):
>, <Line: +    buf = bytearray()
>, <Line: +    all_legal = True
>, <Line: +    _lookup = _cookie_quoting_map.get
>, <Line: +    _push = buf.extend
>, <Line: +    for char in iter_bytes(b):
>, <Line: +        if char not in _legal_cookie_chars:
>, <Line: +            all_legal = False
>, <Line: +            char = _lookup(char, char)
>, <Line: +        _push(char)
>, <Line: +    if all_legal:
>, <Line: +        return bytes(buf)
>, <Line: +    return bytes(b'"' + buf + b'"')
>, <Line: +def _cookie_unquote(b):
>, <Line: +    if len(b) < 2:
>, <Line: +        return b
>, <Line: +    if b[:1] != b'"' or b[-1:] != b'"':
>, <Line: +        return b
>, <Line: +    b = b[1:-1]
>, <Line: +    i = 0
>, <Line: +    n = len(b)
>, <Line: +    rv = bytearray()
>, <Line: +    _push = rv.extend
>, <Line: +    while 0 <= i < n:
>, <Line: +        o_match = _octal_re.search(b, i)
>, <Line: +        q_match = _quote_re.search(b, i)
>, <Line: +        if not o_match and not q_match:
>, <Line: +            rv.extend(b[i:])
>, <Line: +            break
>, <Line: +        j = k = -1
>, <Line: +        if o_match:
>, <Line: +            j = o_match.start(0)
>, <Line: +        if q_match:
>, <Line: +            k = q_match.start(0)
>, <Line: +        if q_match and (not o_match or k < j):
>, <Line: +            _push(b[i:k])
>, <Line: +            _push(b[k + 1:k + 2])
>, <Line: +            i = k + 2
>, <Line: +        else:
>, <Line: +            _push(b[i:j])
>, <Line: +            rv.append(int(b[j + 1:j + 4], 8))
>, <Line: +            i = j + 4
>, <Line: +    return bytes(rv)
>, <Line: +def _make_cookie_domain(domain):
>, <Line: +    if domain is None:
>, <Line: +        return None
>, <Line: +    domain = _encode_idna(domain)
>, <Line: +    if b':' in domain:
>, <Line: +        domain = domain.split(b':', 1)[0]
>, <Line: +    if b'.' in domain:
>, <Line: +        return domain
>, <Line: +    raise ValueError(
>, <Line: +        'Setting \'domain\' for a cookie on a server running locally (ex: '
>, <Line: +        'localhost) is not supported by complying browsers. You should '
>, <Line: +        'have something like: \'127.0.0.1 localhost dev.localhost\' on '
>, <Line: +        'your hosts file and then point your server to run on '
>, <Line: +        '\'dev.localhost\' and also set \'domain\' for \'dev.localhost\''
>, <Line: +    )
>, <Line: +def _cookie_parse_impl(b):
>, <Line: +    """Lowlevel cookie parsing facility that operates on bytes."""
>, <Line: +    i = 0
>, <Line: +    n = len(b)
>, <Line: +    while i < n:
>, <Line: +        match = _cookie_re.search(b + b';', i)
>, <Line: +        if not match:
>, <Line: +            break
>, <Line: +        key = match.group('key').strip()
>, <Line: +        value = match.group('val')
>, <Line: +        i = match.end(0)
>, <Line: +        # Ignore parameters.  We have no interest in them.
>, <Line: +        if key.lower() not in _cookie_params:
>, <Line: +            yield _cookie_unquote(key), _cookie_unquote(value)
>, <Line: +def cookie_date(expires=None):
>, <Line: +    """Formats the time to ensure compatibility with Netscape's cookie
>, <Line: +    standard.
>, <Line: +    Accepts a floating point number expressed in seconds since the epoch in, a
>, <Line: +    datetime object or a timetuple.  All times in UTC.  The :func:`parse_date`
>, <Line: +    function can be used to parse such a date.
>, <Line: +    Outputs a string in the format ``Wdy, DD-Mon-YYYY HH:MM:SS GMT``.
>, <Line: +    :param expires:
>, <Line: +        If provided that date is used, otherwise the current.
>, <Line: +    """
>, <Line: +    return _dump_date(expires, '-')
>, <Line: +def parse_cookie(header, charset='utf-8', errors='replace', cls=None):
>, <Line: +    """Parse a cookie.  Either from a string or WSGI environ.
>, <Line: +    Per default encoding errors are ignored.  If you want a different behavior
>, <Line: +    you can set `errors` to ``'replace'`` or ``'strict'``.  In strict mode a
>, <Line: +    :exc:`HTTPUnicodeError` is raised.
>, <Line: +    :param header:
>, <Line: +        The header to be used to parse the cookie.  Alternatively this can be a
>, <Line: +        WSGI environment.
>, <Line: +    :param charset:
>, <Line: +        The charset for the cookie values.
>, <Line: +    :param errors:
>, <Line: +        The error behavior for the charset decoding.
>, <Line: +    :param cls:
>, <Line: +        An optional dict class to use.  If this is not specified or `None` the
>, <Line: +        default :class:`TypeConversionDict` is used.
>, <Line: +    """
>, <Line: +    if isinstance(header, dict):
>, <Line: +        header = header.get('HTTP_COOKIE', '')
>, <Line: +    elif header is None:
>, <Line: +        header = ''
>, <Line: +    # If the value is an unicode string it's mangled through latin1.  This
>, <Line: +    # is done because on PEP 3333 on Python 3 all headers are assumed latin1
>, <Line: +    # which however is incorrect for cookies, which are sent in page encoding.
>, <Line: +    # As a result we
>, <Line: +    if isinstance(header, str):
>, <Line: +        header = header.encode('latin1', 'replace')
>, <Line: +    if cls is None:
>, <Line: +        cls = datastructures.TypeConversionDict
>, <Line: +    def _parse_pairs():
>, <Line: +        for key, val in _cookie_parse_impl(header):
>, <Line: +            key = to_unicode(key, charset, errors, allow_none_charset=True)
>, <Line: +            val = to_unicode(val, charset, errors, allow_none_charset=True)
>, <Line: +            yield key, val
>, <Line: +    return cls(_parse_pairs())
>, <Line: +def dump_cookie(key, value='', max_age=None, expires=None, path='/',
>, <Line: +                domain=None, secure=False, httponly=False,
>, <Line: +                charset='utf-8', sync_expires=True):
>, <Line: +    """Creates a new Set-Cookie header without the ``Set-Cookie`` prefix
>, <Line: +    The parameters are the same as in the cookie Morsel object in the
>, <Line: +    Python standard library but it accepts unicode data, too.
>, <Line: +    On Python 3 the return value of this function will be a unicode
>, <Line: +    string, on Python 2 it will be a native string.  In both cases the
>, <Line: +    return value is usually restricted to ascii as the vast majority of
>, <Line: +    values are properly escaped, but that is no guarantee.  If a unicode
>, <Line: +    string is returned it's tunneled through latin1 as required by
>, <Line: +    PEP 3333.
>, <Line: +    The return value is not ASCII safe if the key contains unicode
>, <Line: +    characters.  This is technically against the specification but
>, <Line: +    happens in the wild.  It's strongly recommended to not use
>, <Line: +    non-ASCII values for the keys.
>, <Line: +    :param max_age:
>, <Line: +        Should be a number of seconds, or `None` (default) if the cookie should
>, <Line: +        last only as long as the client's browser session.  Additionally
>, <Line: +        `timedelta` objects are accepted, too.
>, <Line: +    :param expires:
>, <Line: +        Should be a `datetime` object or unix timestamp.
>, <Line: +    :param path:
>, <Line: +        Limits the cookie to a given path, per default it will span the whole
>, <Line: +        domain.
>, <Line: +    :param domain:
>, <Line: +        Use this if you want to set a cross-domain cookie. For example,
>, <Line: +        ``domain=".example.com"`` will set a cookie that is readable by the
>, <Line: +        domain ``www.example.com``, ``foo.example.com`` etc. Otherwise, a
>, <Line: +        cookie will only be readable by the domain that set it.
>, <Line: +    :param secure:
>, <Line: +        The cookie will only be available via HTTPS.
>, <Line: +    :param httponly:
>, <Line: +        Disallow JavaScript to access the cookie.  This is an extension to the
>, <Line: +        cookie standard and probably not supported by all browsers.
>, <Line: +    :param charset:
>, <Line: +        The encoding for unicode values.
>, <Line: +    :param sync_expires:
>, <Line: +        Automatically set expires if max_age is defined but expires not.
>, <Line: +    """
>, <Line: +    key = to_bytes(key, charset)
>, <Line: +    value = to_bytes(value, charset)
>, <Line: +    if path is not None:
>, <Line: +        path = iri_to_uri(path, charset)
>, <Line: +    domain = _make_cookie_domain(domain)
>, <Line: +    if isinstance(max_age, timedelta):
>, <Line: +        max_age = (max_age.days * 60 * 60 * 24) + max_age.seconds
>, <Line: +    if expires is not None:
>, <Line: +        if not isinstance(expires, str):
>, <Line: +            expires = cookie_date(expires)
>, <Line: +    elif max_age is not None and sync_expires:
>, <Line: +        expires = to_bytes(cookie_date(time() + max_age))
>, <Line: +    buf = [key + b'=' + _cookie_quote(value)]
>, <Line: +    # XXX: In theory all of these parameters that are not marked with `None`
>, <Line: +    # should be quoted.  Because stdlib did not quote it before I did not
>, <Line: +    # want to introduce quoting there now.
>, <Line: +    for k, v, q in ((b'Domain', domain, True),
>, <Line: +                    (b'Expires', expires, False,),
>, <Line: +                    (b'Max-Age', max_age, False),
>, <Line: +                    (b'Secure', secure, None),
>, <Line: +                    (b'HttpOnly', httponly, None),
>, <Line: +                    (b'Path', path, False)):
>, <Line: +        if q is None:
>, <Line: +            if v:
>, <Line: +                buf.append(k)
>, <Line: +            continue
>, <Line: +        if v is None:
>, <Line: +            continue
>, <Line: +        tmp = bytearray(k)
>, <Line: +        if not isinstance(v, (bytes, bytearray)):
>, <Line: +            v = to_bytes(str(v), charset)
>, <Line: +        if q:
>, <Line: +            v = _cookie_quote(v)
>, <Line: +        tmp += b'=' + v
>, <Line: +        buf.append(bytes(tmp))
>, <Line: +    # The return value will be an incorrectly encoded latin1 header on
>, <Line: +    # Python 3 for consistency with the headers object and a bytestring
>, <Line: +    # on Python 2 because that's how the API makes more sense.
>, <Line: +    rv = b'; '.join(buf)
>, <Line: +    rv = rv.decode('latin1')
>, <Line: +    return rv
>]
[]