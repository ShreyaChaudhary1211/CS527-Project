[<Line: +from html import escape
>]
[<Line: -from html.entities import name2codepoint
>, <Line: -class HTMLBuilder(object):
>, <Line: -    """Helper object for HTML generation.
>, <Line: -    Per default there are two instances of that class.  The `html` one, and
>, <Line: -    the `xhtml` one for those two dialects.  The class uses keyword parameters
>, <Line: -    and positional parameters to generate small snippets of HTML.
>, <Line: -    Keyword parameters are converted to XML/SGML attributes, positional
>, <Line: -    arguments are used as children.  Because Python accepts positional
>, <Line: -    arguments before keyword arguments it's a good idea to use a list with the
>, <Line: -    star-syntax for some children:
>, <Line: -    >>> html.p(
>, <Line: -    ...     class_='foo', *[
>, <Line: -    ...         html.a('foo', href='foo.html'),
>, <Line: -    ...         ' ',
>, <Line: -    ...         html.a('bar', href='bar.html'),
>, <Line: -    ...     ]
>, <Line: -    ... )
>, <Line: -    u'<p class="foo"><a href="foo.html">foo</a> <a href="bar.html">bar</a></p>'
>, <Line: -    This class works around some browser limitations and can not be used for
>, <Line: -    arbitrary SGML/XML generation.  For that purpose lxml and similar
>, <Line: -    libraries exist.
>, <Line: -    Calling the builder escapes the string passed:
>, <Line: -    >>> html.p(html("<foo>"))
>, <Line: -    u'<p>&lt;foo&gt;</p>'
>, <Line: -    """
>, <Line: -    _entity_re = re.compile(r'&([^;]+);')
>, <Line: -    _entities = name2codepoint.copy()
>, <Line: -    _entities['apos'] = 39
>, <Line: -    _empty_elements = set([
>, <Line: -        'area', 'base', 'basefont', 'br', 'col', 'command', 'embed', 'frame',
>, <Line: -        'hr', 'img', 'input', 'keygen', 'isindex', 'link', 'meta', 'param',
>, <Line: -        'source', 'wbr'
>, <Line: -    ])
>, <Line: -    _boolean_attributes = set([
>, <Line: -        'selected', 'checked', 'compact', 'declare', 'defer', 'disabled',
>, <Line: -        'ismap', 'multiple', 'nohref', 'noresize', 'noshade', 'nowrap'
>, <Line: -    ])
>, <Line: -    _plaintext_elements = set(['textarea'])
>, <Line: -    _c_like_cdata = set(['script', 'style'])
>, <Line: -    def __init__(self, dialect):
>, <Line: -        self._dialect = dialect
>, <Line: -    def __call__(self, s):
>, <Line: -        return escape(s)
>, <Line: -    def __getattr__(self, tag):
>, <Line: -        if tag[:2] == '__':
>, <Line: -            raise AttributeError(tag)
>, <Line: -        def proxy(*children, **arguments):
>, <Line: -            buffer = '<' + tag
>, <Line: -            for key, value in arguments.items():
>, <Line: -                if value is None:
>, <Line: -                    continue
>, <Line: -                if key[-1] == '_':
>, <Line: -                    key = key[:-1]
>, <Line: -                if key in self._boolean_attributes:
>, <Line: -                    if not value:
>, <Line: -                        continue
>, <Line: -                    if self._dialect == 'xhtml':
>, <Line: -                        value = '="' + key + '"'
>, <Line: -                    else:
>, <Line: -                        value = ''
>, <Line: -                else:
>, <Line: -                    value = '="' + escape(value) + '"'
>, <Line: -                buffer += ' ' + key + value
>, <Line: -            if not children and tag in self._empty_elements:
>, <Line: -                if self._dialect == 'xhtml':
>, <Line: -                    buffer += ' />'
>, <Line: -                else:
>, <Line: -                    buffer += '>'
>, <Line: -                return buffer
>, <Line: -            buffer += '>'
>, <Line: -            children_as_string = ''.join([
>, <Line: -                str(x) for x in children
>, <Line: -                if x is not None
>, <Line: -            ])
>, <Line: -            if children_as_string:
>, <Line: -                if tag in self._plaintext_elements:
>, <Line: -                    children_as_string = escape(children_as_string)
>, <Line: -                elif tag in self._c_like_cdata and self._dialect == 'xhtml':
>, <Line: -                    children_as_string = (
>, <Line: -                        '/*<![CDATA[*/' + children_as_string + '/*]]>*/'
>, <Line: -                    )
>, <Line: -            buffer += children_as_string + '</' + tag + '>'
>, <Line: -            return buffer
>, <Line: -        return proxy
>, <Line: -    def __repr__(self):
>, <Line: -        return '<%s for %r>' % (
>, <Line: -            self.__class__.__name__,
>, <Line: -            self._dialect
>, <Line: -        )
>, <Line: -html = HTMLBuilder('html')
>, <Line: -xhtml = HTMLBuilder('xhtml')
>, <Line: -def escape(s):
>, <Line: -    """Replace special characters "&", "<", ">" and (") to HTML-safe sequences.
>, <Line: -    There is a special handling for `None` which escapes to an empty string.
>, <Line: -    :param s:
>, <Line: -        The string to escape.
>, <Line: -    """
>, <Line: -    if s is None:
>, <Line: -        return ''
>, <Line: -    elif hasattr(s, '__html__'):
>, <Line: -        return str(s.__html__())
>, <Line: -    elif not isinstance(s, str):
>, <Line: -        s = str(s)
>, <Line: -    s = s.replace('&', '&amp;').replace('<', '&lt;') \
>, <Line: -        .replace('>', '&gt;').replace('"', "&quot;")
>, <Line: -    return s
>, <Line: -def unescape(s):
>, <Line: -    """The reverse function of `escape`.  This unescapes all the HTML
>, <Line: -    entities, not only the XML entities inserted by `escape`.
>, <Line: -    :param s:
>, <Line: -        The string to unescape.
>, <Line: -    """
>, <Line: -    def handle_match(m):
>, <Line: -        name = m.group(1)
>, <Line: -        if name in HTMLBuilder._entities:
>, <Line: -            return chr(HTMLBuilder._entities[name])
>, <Line: -        try:
>, <Line: -            if name[:2] in ('#x', '#X'):
>, <Line: -                return chr(int(name[2:], 16))
>, <Line: -            elif name.startswith('#'):
>, <Line: -                return chr(int(name[1:]))
>, <Line: -        except ValueError:
>, <Line: -            pass
>, <Line: -        return u''
>, <Line: -    return _entity_re.sub(handle_match, s)
>]