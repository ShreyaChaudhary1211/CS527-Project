[<Line: +package org.mp4parser.muxer.builder;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.OriginalFormatBox;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.SampleDescriptionBox;
>, <Line: +import org.mp4parser.boxes.sampleentry.AudioSampleEntry;
>, <Line: +import org.mp4parser.muxer.Movie;
>, <Line: +import org.mp4parser.muxer.Track;
>, <Line: +import org.mp4parser.tools.Path;
>, <Line: +import java.util.Arrays;
>, <Line: +import java.util.Iterator;
>, <Line: +import java.util.LinkedList;
>, <Line: +import java.util.List;
>, <Line: +import static org.mp4parser.tools.Mp4Math.lcm;
>, <Line: +     * @param movie                      this movie is the reference
>, <Line: +     * @param referenceTrack             used for audio tracks to find similar boundaries of segments.
>, <Line: +        if (frma != null) {
>, <Line: +    /**
>, <Line: +     * Calculates the timestamp of all tracks' sync samples.
>, <Line: +     *
>, <Line: +     * @param movie <code>track</code> is located in this movie
>, <Line: +     * @param track get this track's samples timestamps
>, <Line: +     * @return a list of timestamps
>, <Line: +     */
>, <Line: +    public static List<long[]> getSyncSamplesTimestamps(Movie movie, Track track) {
>, <Line: +        List<long[]> times = new LinkedList<long[]>();
>, <Line: +        for (Track currentTrack : movie.getTracks()) {
>, <Line: +            if (currentTrack.getHandler().equals(track.getHandler())) {
>, <Line: +                long[] currentTrackSyncSamples = currentTrack.getSyncSamples();
>, <Line: +                if (currentTrackSyncSamples != null && currentTrackSyncSamples.length > 0) {
>, <Line: +                    final long[] currentTrackTimes = getTimes(currentTrack, movie);
>, <Line: +                    times.add(currentTrackTimes);
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return times;
>, <Line: +    }
>, <Line: +    private static long[] getTimes(Track track, Movie m) {
>, <Line: +        long[] syncSamples = track.getSyncSamples();
>, <Line: +        long[] syncSampleTimes = new long[syncSamples.length];
>, <Line: +        int currentSample = 1;  // first syncsample is 1
>, <Line: +        long currentDuration = 0;
>, <Line: +        int currentSyncSampleIndex = 0;
>, <Line: +        final long scalingFactor = calculateTracktimesScalingFactor(m, track);
>, <Line: +        while (currentSample <= syncSamples[syncSamples.length - 1]) {
>, <Line: +            if (currentSample == syncSamples[currentSyncSampleIndex]) {
>, <Line: +                syncSampleTimes[currentSyncSampleIndex++] = currentDuration * scalingFactor;
>, <Line: +            }
>, <Line: +            currentDuration += track.getSampleDurations()[-1 + currentSample++];
>, <Line: +        }
>, <Line: +        return syncSampleTimes;
>, <Line: +    }
>, <Line: +    private static long calculateTracktimesScalingFactor(Movie m, Track track) {
>, <Line: +        long timeScale = 1;
>, <Line: +        for (Track track1 : m.getTracks()) {
>, <Line: +            if (track1.getHandler().equals(track.getHandler())) {
>, <Line: +                if (track1.getTrackMetaData().getTimescale() != track.getTrackMetaData().getTimescale()) {
>, <Line: +                    timeScale = lcm(timeScale, track1.getTrackMetaData().getTimescale());
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return timeScale;
>, <Line: +    }
>]
[<Line: -package com.googlecode.mp4parser.authoring.builder;
>, <Line: -import com.coremedia.iso.boxes.OriginalFormatBox;
>, <Line: -import com.coremedia.iso.boxes.SampleDescriptionBox;
>, <Line: -import com.coremedia.iso.boxes.sampleentry.AudioSampleEntry;
>, <Line: -import com.googlecode.mp4parser.authoring.Movie;
>, <Line: -import com.googlecode.mp4parser.authoring.Track;
>, <Line: -import com.googlecode.mp4parser.util.Path;
>, <Line: -import java.util.*;
>, <Line: -import static com.googlecode.mp4parser.util.Math.lcm;
>, <Line: -     * @param movie this movie is the reference
>, <Line: -     * @param referenceTrack used for audio tracks to find similar boundaries of segments.
>, <Line: -        if (frma!=null) {
>, <Line: -    /**
>, <Line: -     * Calculates the timestamp of all tracks' sync samples.
>, <Line: -     *
>, <Line: -     * @param movie <code>track</code> is located in this movie
>, <Line: -     * @param track get this track's samples timestamps
>, <Line: -     * @return a list of timestamps
>, <Line: -     */
>, <Line: -    public static List<long[]> getSyncSamplesTimestamps(Movie movie, Track track) {
>, <Line: -        List<long[]> times = new LinkedList<long[]>();
>, <Line: -        for (Track currentTrack : movie.getTracks()) {
>, <Line: -            if (currentTrack.getHandler().equals(track.getHandler())) {
>, <Line: -                long[] currentTrackSyncSamples = currentTrack.getSyncSamples();
>, <Line: -                if (currentTrackSyncSamples != null && currentTrackSyncSamples.length > 0) {
>, <Line: -                    final long[] currentTrackTimes = getTimes(currentTrack, movie);
>, <Line: -                    times.add(currentTrackTimes);
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return times;
>, <Line: -    }
>, <Line: -    private static long[] getTimes(Track track, Movie m) {
>, <Line: -        long[] syncSamples = track.getSyncSamples();
>, <Line: -        long[] syncSampleTimes = new long[syncSamples.length];
>, <Line: -        int currentSample = 1;  // first syncsample is 1
>, <Line: -        long currentDuration = 0;
>, <Line: -        int currentSyncSampleIndex = 0;
>, <Line: -        final long scalingFactor = calculateTracktimesScalingFactor(m, track);
>, <Line: -        while (currentSample <= syncSamples[syncSamples.length - 1]) {
>, <Line: -            if (currentSample == syncSamples[currentSyncSampleIndex]) {
>, <Line: -                syncSampleTimes[currentSyncSampleIndex++] = currentDuration * scalingFactor;
>, <Line: -            }
>, <Line: -            currentDuration += track.getSampleDurations()[-1 + currentSample++];
>, <Line: -        }
>, <Line: -        return syncSampleTimes;
>, <Line: -    }
>, <Line: -    private static long calculateTracktimesScalingFactor(Movie m, Track track) {
>, <Line: -        long timeScale = 1;
>, <Line: -        for (Track track1 : m.getTracks()) {
>, <Line: -            if (track1.getHandler().equals(track.getHandler())) {
>, <Line: -                if (track1.getTrackMetaData().getTimescale() != track.getTrackMetaData().getTimescale()) {
>, <Line: -                    timeScale = lcm(timeScale, track1.getTrackMetaData().getTimescale());
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return timeScale;
>, <Line: -    }
>]