[<Line: +package org.mp4parser.streaming.output.mp4;
>, <Line: +import org.mp4parser.Box;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.*;
>, <Line: +import org.mp4parser.streaming.StreamingSample;
>, <Line: +import org.mp4parser.streaming.StreamingTrack;
>, <Line: +import org.mp4parser.streaming.extensions.CompositionTimeSampleExtension;
>, <Line: +import org.mp4parser.streaming.extensions.CompositionTimeTrackExtension;
>, <Line: +import org.mp4parser.streaming.extensions.SampleFlagsSampleExtension;
>, <Line: +import org.mp4parser.streaming.extensions.TrackIdTrackExtension;
>, <Line: +import org.mp4parser.streaming.output.SampleSink;
>, <Line: +import org.mp4parser.tools.Mp4Arrays;
>, <Line: +import org.mp4parser.tools.Mp4Math;
>, <Line: +import org.mp4parser.tools.Path;
>, <Line: +import java.io.IOException;
>, <Line: +import java.nio.ByteBuffer;
>, <Line: +import java.nio.channels.WritableByteChannel;
>, <Line: +import java.util.*;
>, <Line: +import java.util.concurrent.ConcurrentHashMap;
>, <Line: +import java.util.concurrent.CountDownLatch;
>, <Line: +import java.util.logging.Level;
>, <Line: +import java.util.logging.Logger;
>, <Line: +import static org.mp4parser.tools.CastUtils.l2i;
>, <Line: +/**
>, <Line: + * Creates an MP4 file with ftyp, mdat+, moov order.
>, <Line: + * A very special property of this variant is that it written sequentially. You can start transferring the
>, <Line: + * data while the <code>sink</code> receives it. (in contrast to typical implementations which need random
>, <Line: + * access to write length fields at the beginning of the file)
>, <Line: + */
>, <Line: +public class StandardMp4Writer extends DefaultBoxes implements SampleSink {
>, <Line: +    public static final Object OBJ = new Object();
>, <Line: +    private static final Logger LOG = Logger.getLogger(FragmentedMp4Writer.class.getName());
>, <Line: +    protected final WritableByteChannel sink;
>, <Line: +    protected List<StreamingTrack> source;
>, <Line: +    protected Date creationTime = new Date();
>, <Line: +    protected Map<StreamingTrack, CountDownLatch> congestionControl = new ConcurrentHashMap<StreamingTrack, CountDownLatch>();
>, <Line: +    /**
>, <Line: +     * Contains the start time of the next segment in line that will be created.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextChunkCreateStartTime = new ConcurrentHashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Contains the start time of the next segment in line that will be written.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextChunkWriteStartTime = new ConcurrentHashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Contains the next sample's start time.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextSampleStartTime = new HashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Buffers the samples per track until there are enough samples to form a Segment.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, List<StreamingSample>> sampleBuffers = new HashMap<StreamingTrack, List<StreamingSample>>();
>, <Line: +    protected Map<StreamingTrack, TrackBox> trackBoxes = new HashMap<StreamingTrack, TrackBox>();
>, <Line: +    /**
>, <Line: +     * Buffers segements until it's time for a segment to be written.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Queue<ChunkContainer>> chunkBuffers = new ConcurrentHashMap<StreamingTrack, Queue<ChunkContainer>>();
>, <Line: +    protected Map<StreamingTrack, Long> chunkNumbers = new HashMap<StreamingTrack, Long>();
>, <Line: +    protected Map<StreamingTrack, Long> sampleNumbers = new HashMap<StreamingTrack, Long>();
>, <Line: +    long bytesWritten = 0;
>, <Line: +    volatile boolean headerWritten = false;
>, <Line: +    public StandardMp4Writer(List<StreamingTrack> source, WritableByteChannel sink) {
>, <Line: +        this.source = new ArrayList<StreamingTrack>(source);
>, <Line: +        this.sink = sink;
>, <Line: +        HashSet<Long> trackIds = new HashSet<Long>();
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            streamingTrack.setSampleSink(this);
>, <Line: +            chunkNumbers.put(streamingTrack, 1L);
>, <Line: +            sampleNumbers.put(streamingTrack, 1L);
>, <Line: +            nextSampleStartTime.put(streamingTrack, 0L);
>, <Line: +            nextChunkCreateStartTime.put(streamingTrack, 0L);
>, <Line: +            nextChunkWriteStartTime.put(streamingTrack, 0L);
>, <Line: +            congestionControl.put(streamingTrack, new CountDownLatch(0));
>, <Line: +            sampleBuffers.put(streamingTrack, new ArrayList<StreamingSample>());
>, <Line: +            chunkBuffers.put(streamingTrack, new LinkedList<ChunkContainer>());
>, <Line: +            if (streamingTrack.getTrackExtension(TrackIdTrackExtension.class) != null) {
>, <Line: +                TrackIdTrackExtension trackIdTrackExtension = streamingTrack.getTrackExtension(TrackIdTrackExtension.class);
>, <Line: +                assert trackIdTrackExtension != null;
>, <Line: +                if (trackIds.contains(trackIdTrackExtension.getTrackId())) {
>, <Line: +                    throw new RuntimeException("There may not be two tracks with the same trackID within one file");
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            if (streamingTrack.getTrackExtension(TrackIdTrackExtension.class) == null) {
>, <Line: +                long maxTrackId = 0;
>, <Line: +                for (Long trackId : trackIds) {
>, <Line: +                    maxTrackId = Math.max(trackId, maxTrackId);
>, <Line: +                }
>, <Line: +                TrackIdTrackExtension tiExt = new TrackIdTrackExtension(maxTrackId + 1);
>, <Line: +                trackIds.add(tiExt.getTrackId());
>, <Line: +                streamingTrack.addTrackExtension(tiExt);
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    public void close() throws IOException {
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            writeChunkContainer(createChunkContainer(streamingTrack));
>, <Line: +            streamingTrack.close();
>, <Line: +        }
>, <Line: +        write(sink, createMoov());
>, <Line: +    }
>, <Line: +    protected Box createMoov() {
>, <Line: +        MovieBox movieBox = new MovieBox();
>, <Line: +        movieBox.addBox(createMvhd());
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            movieBox.addBox(trackBoxes.get(streamingTrack));
>, <Line: +        }
>, <Line: +        // metadata here
>, <Line: +        return movieBox;
>, <Line: +    }
>, <Line: +    private void sortTracks() {
>, <Line: +        Collections.sort(source, new Comparator<StreamingTrack>() {
>, <Line: +            public int compare(StreamingTrack o1, StreamingTrack o2) {
>, <Line: +                // compare times and account for timestamps!
>, <Line: +                long a = nextChunkWriteStartTime.get(o1) * o2.getTimescale();
>, <Line: +                long b = nextChunkWriteStartTime.get(o2) * o1.getTimescale();
>, <Line: +                double d = Math.signum(a - b);
>, <Line: +                return (int) d;
>, <Line: +            }
>, <Line: +        });
>, <Line: +    }
>, <Line: +    protected Box createMvhd() {
>, <Line: +        MovieHeaderBox mvhd = new MovieHeaderBox();
>, <Line: +        mvhd.setVersion(1);
>, <Line: +        mvhd.setCreationTime(creationTime);
>, <Line: +        mvhd.setModificationTime(creationTime);
>, <Line: +        long[] timescales = new long[0];
>, <Line: +        long maxTrackId = 0;
>, <Line: +        double duration = 0;
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            duration = Math.max((double) nextSampleStartTime.get(streamingTrack) / streamingTrack.getTimescale(), duration);
>, <Line: +            timescales = Mp4Arrays.copyOfAndAppend(timescales, streamingTrack.getTimescale());
>, <Line: +            maxTrackId = Math.max(streamingTrack.getTrackExtension(TrackIdTrackExtension.class).getTrackId(), maxTrackId);
>, <Line: +        }
>, <Line: +        mvhd.setTimescale(Mp4Math.lcm(timescales));
>, <Line: +        mvhd.setDuration((long) (Mp4Math.lcm(timescales) * duration));
>, <Line: +        // find the next available trackId
>, <Line: +        mvhd.setNextTrackId(maxTrackId + 1);
>, <Line: +        return mvhd;
>, <Line: +    }
>, <Line: +    protected void write(WritableByteChannel out, Box... boxes) throws IOException {
>, <Line: +        for (Box box1 : boxes) {
>, <Line: +            box1.getBox(out);
>, <Line: +            bytesWritten += box1.getSize();
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Tests if the currently received samples for a given track
>, <Line: +     * are already a 'chunk' as we want to have it. The next
>, <Line: +     * sample will not be part of the chunk
>, <Line: +     * will be added to the fragment buffer later.
>, <Line: +     *
>, <Line: +     * @param streamingTrack track to test
>, <Line: +     * @param next           the lastest samples
>, <Line: +     * @return true if a chunk is to b e created.
>, <Line: +     */
>, <Line: +    protected boolean isChunkReady(StreamingTrack streamingTrack, StreamingSample next) {
>, <Line: +        long ts = nextSampleStartTime.get(streamingTrack);
>, <Line: +        long cfst = nextChunkCreateStartTime.get(streamingTrack);
>, <Line: +        return (ts >= cfst + 2 * streamingTrack.getTimescale());
>, <Line: +        // chunk interleave of 2 seconds
>, <Line: +    }
>, <Line: +    protected void writeChunkContainer(ChunkContainer chunkContainer) throws IOException {
>, <Line: +        TrackBox tb = trackBoxes.get(chunkContainer.streamingTrack);
>, <Line: +        ChunkOffsetBox stco = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]/stco[0]");
>, <Line: +        assert stco != null;
>, <Line: +        stco.setChunkOffsets(Mp4Arrays.copyOfAndAppend(stco.getChunkOffsets(), bytesWritten + 8));
>, <Line: +        write(sink, chunkContainer.mdat);
>, <Line: +    }
>, <Line: +    public void acceptSample(StreamingSample streamingSample, StreamingTrack streamingTrack) throws IOException {
>, <Line: +        TrackBox tb = trackBoxes.get(streamingTrack);
>, <Line: +        if (tb == null) {
>, <Line: +            tb = new TrackBox();
>, <Line: +            tb.addBox(createTkhd(streamingTrack));
>, <Line: +            tb.addBox(createMdia(streamingTrack));
>, <Line: +            trackBoxes.put(streamingTrack, tb);
>, <Line: +        }
>, <Line: +        // We might want to do that when the chunk is created to save memory copy
>, <Line: +        synchronized (OBJ) {
>, <Line: +            // need to synchronized here - I don't want two headers written under any circumstances
>, <Line: +            if (!headerWritten) {
>, <Line: +                boolean allTracksAtLeastOneSample = true;
>, <Line: +                for (StreamingTrack track : source) {
>, <Line: +                    allTracksAtLeastOneSample &= (nextSampleStartTime.get(track) > 0 || track == streamingTrack);
>, <Line: +                }
>, <Line: +                if (allTracksAtLeastOneSample) {
>, <Line: +                    write(sink, createFtyp());
>, <Line: +                    headerWritten = true;
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        try {
>, <Line: +            CountDownLatch cdl = congestionControl.get(streamingTrack);
>, <Line: +            if (cdl.getCount() > 0) {
>, <Line: +                cdl.await();
>, <Line: +            }
>, <Line: +        } catch (InterruptedException e) {
>, <Line: +            // don't care just move on
>, <Line: +        }
>, <Line: +        if (isChunkReady(streamingTrack, streamingSample)) {
>, <Line: +            ChunkContainer chunkContainer = createChunkContainer(streamingTrack);
>, <Line: +            //System.err.println("Creating fragment for " + streamingTrack);
>, <Line: +            sampleBuffers.get(streamingTrack).clear();
>, <Line: +            nextChunkCreateStartTime.put(streamingTrack, nextChunkCreateStartTime.get(streamingTrack) + chunkContainer.duration);
>, <Line: +            Queue<ChunkContainer> chunkQueue = chunkBuffers.get(streamingTrack);
>, <Line: +            chunkQueue.add(chunkContainer);
>, <Line: +            synchronized (OBJ) {
>, <Line: +                if (headerWritten && this.source.get(0) == streamingTrack) {
>, <Line: +                    Queue<ChunkContainer> tracksFragmentQueue;
>, <Line: +                    StreamingTrack currentStreamingTrack;
>, <Line: +                    // This will write AT LEAST the currently created fragment and possibly a few more
>, <Line: +                    while (!(tracksFragmentQueue = chunkBuffers.get(
>, <Line: +                            (currentStreamingTrack = this.source.get(0))
>, <Line: +                    )).isEmpty()) {
>, <Line: +                        ChunkContainer currentFragmentContainer = tracksFragmentQueue.remove();
>, <Line: +                        writeChunkContainer(currentFragmentContainer);
>, <Line: +                        congestionControl.get(currentStreamingTrack).countDown();
>, <Line: +                        long ts = nextChunkWriteStartTime.get(currentStreamingTrack) + currentFragmentContainer.duration;
>, <Line: +                        nextChunkWriteStartTime.put(currentStreamingTrack, ts);
>, <Line: +                        if (LOG.isLoggable(Level.FINE)) {
>, <Line: +                            LOG.fine(currentStreamingTrack + " advanced to " + (double) ts / currentStreamingTrack.getTimescale());
>, <Line: +                        }
>, <Line: +                        sortTracks();
>, <Line: +                    }
>, <Line: +                } else {
>, <Line: +                    if (chunkQueue.size() > 10) {
>, <Line: +                        // if there are more than 10 fragments in the queue we don't want more samples of this track
>, <Line: +                        // System.err.println("Stopping " + streamingTrack);
>, <Line: +                        congestionControl.put(streamingTrack, new CountDownLatch(chunkQueue.size()));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        sampleBuffers.get(streamingTrack).add(streamingSample);
>, <Line: +        nextSampleStartTime.put(streamingTrack, nextSampleStartTime.get(streamingTrack) + streamingSample.getDuration());
>, <Line: +    }
>, <Line: +    private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
>, <Line: +        List<StreamingSample> samples = sampleBuffers.get(streamingTrack);
>, <Line: +        long chunkNumber = chunkNumbers.get(streamingTrack);
>, <Line: +        chunkNumbers.put(streamingTrack, chunkNumber + 1);
>, <Line: +        ChunkContainer cc = new ChunkContainer();
>, <Line: +        cc.streamingTrack = streamingTrack;
>, <Line: +        cc.mdat = new Mdat(samples);
>, <Line: +        cc.duration = nextSampleStartTime.get(streamingTrack) - nextChunkCreateStartTime.get(streamingTrack);
>, <Line: +        TrackBox tb = trackBoxes.get(streamingTrack);
>, <Line: +        SampleTableBox stbl = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]");
>, <Line: +        assert stbl != null;
>, <Line: +        SampleToChunkBox stsc = Path.getPath(stbl, "stsc[0]");
>, <Line: +        assert stsc != null;
>, <Line: +        if (stsc.getEntries().isEmpty()) {
>, <Line: +            List<SampleToChunkBox.Entry> entries = new ArrayList<SampleToChunkBox.Entry>();
>, <Line: +            stsc.setEntries(entries);
>, <Line: +            entries.add(new SampleToChunkBox.Entry(chunkNumber, samples.size(), 1));
>, <Line: +        } else {
>, <Line: +            SampleToChunkBox.Entry e = stsc.getEntries().get(stsc.getEntries().size() - 1);
>, <Line: +            if (e.getSamplesPerChunk() != samples.size()) {
>, <Line: +                stsc.getEntries().add(new SampleToChunkBox.Entry(chunkNumber, samples.size(), 1));
>, <Line: +            }
>, <Line: +        }
>, <Line: +        long sampleNumber = sampleNumbers.get(streamingTrack);
>, <Line: +        SampleSizeBox stsz = Path.getPath(stbl, "stsz[0]");
>, <Line: +        TimeToSampleBox stts = Path.getPath(stbl, "stts[0]");
>, <Line: +        SyncSampleBox stss = Path.getPath(stbl, "stss[0]");
>, <Line: +        CompositionTimeToSample ctts = Path.getPath(stbl, "ctts[0]");
>, <Line: +        if (streamingTrack.getTrackExtension(CompositionTimeTrackExtension.class) != null) {
>, <Line: +            if (ctts == null) {
>, <Line: +                ctts = new CompositionTimeToSample();
>, <Line: +                ctts.setEntries(new ArrayList<CompositionTimeToSample.Entry>());
>, <Line: +                ArrayList<Box> bs = new ArrayList<Box>(stbl.getBoxes());
>, <Line: +                bs.add(bs.indexOf(stts), ctts);
>, <Line: +            }
>, <Line: +        }
>, <Line: +        long[] sampleSizes = new long[samples.size()];
>, <Line: +        int i = 0;
>, <Line: +        for (StreamingSample sample : samples) {
>, <Line: +            sampleSizes[i++] = sample.getContent().limit();
>, <Line: +            if (ctts != null) {
>, <Line: +                ctts.getEntries().add(
>, <Line: +                        new CompositionTimeToSample.Entry(1, l2i(sample.getSampleExtension(CompositionTimeSampleExtension.class).getCompositionTimeOffset())));
>, <Line: +            }
>, <Line: +            assert stts != null;
>, <Line: +            if (stts.getEntries().isEmpty()) {
>, <Line: +                ArrayList<TimeToSampleBox.Entry> entries = new ArrayList<TimeToSampleBox.Entry>(stts.getEntries());
>, <Line: +                entries.add(new TimeToSampleBox.Entry(1, sample.getDuration()));
>, <Line: +                stts.setEntries(entries);
>, <Line: +            } else {
>, <Line: +                TimeToSampleBox.Entry sttsEntry = stts.getEntries().get(stts.getEntries().size() - 1);
>, <Line: +                if (sttsEntry.getDelta() == sample.getDuration()) {
>, <Line: +                    sttsEntry.setCount(sttsEntry.getCount() + 1);
>, <Line: +                } else {
>, <Line: +                    stts.getEntries().add(new TimeToSampleBox.Entry(1, sample.getDuration()));
>, <Line: +                }
>, <Line: +            }
>, <Line: +            SampleFlagsSampleExtension sampleFlagsSampleExtension = sample.getSampleExtension(SampleFlagsSampleExtension.class);
>, <Line: +            if (sampleFlagsSampleExtension != null && sampleFlagsSampleExtension.isSyncSample()) {
>, <Line: +                if (stss == null) {
>, <Line: +                    stss = new SyncSampleBox();
>, <Line: +                    stbl.addBox(stss);
>, <Line: +                }
>, <Line: +                stss.setSampleNumber(Mp4Arrays.copyOfAndAppend(stss.getSampleNumber(), sampleNumber));
>, <Line: +            }
>, <Line: +            sampleNumber++;
>, <Line: +        }
>, <Line: +        assert stsz != null;
>, <Line: +        stsz.setSampleSizes(Mp4Arrays.copyOfAndAppend(stsz.getSampleSizes(), sampleSizes));
>, <Line: +        sampleNumbers.put(streamingTrack, sampleNumber);
>, <Line: +        samples.clear();
>, <Line: +        System.err.println("CC created. mdat size: " + cc.mdat.size);
>, <Line: +        return cc;
>, <Line: +    }
>, <Line: +    protected Box createMdhd(StreamingTrack streamingTrack) {
>, <Line: +        MediaHeaderBox mdhd = new MediaHeaderBox();
>, <Line: +        mdhd.setCreationTime(creationTime);
>, <Line: +        mdhd.setModificationTime(creationTime);
>, <Line: +        mdhd.setDuration(nextSampleStartTime.get(streamingTrack));
>, <Line: +        mdhd.setTimescale(streamingTrack.getTimescale());
>, <Line: +        mdhd.setLanguage(streamingTrack.getLanguage());
>, <Line: +        return mdhd;
>, <Line: +    }
>, <Line: +    private class Mdat implements Box {
>, <Line: +        ArrayList<StreamingSample> samples;
>, <Line: +        long size;
>, <Line: +        public Mdat(List<StreamingSample> samples) {
>, <Line: +            this.samples = new ArrayList<StreamingSample>(samples);
>, <Line: +            size = 8;
>, <Line: +            for (StreamingSample sample : samples) {
>, <Line: +                size += sample.getContent().limit();
>, <Line: +            }
>, <Line: +        }
>, <Line: +        public String getType() {
>, <Line: +            return "mdat";
>, <Line: +        }
>, <Line: +        public long getSize() {
>, <Line: +            return size;
>, <Line: +        }
>, <Line: +        public void getBox(WritableByteChannel writableByteChannel) throws IOException {
>, <Line: +            writableByteChannel.write(ByteBuffer.wrap(new byte[]{
>, <Line: +                    (byte) ((size & 0xff000000) >> 24),
>, <Line: +                    (byte) ((size & 0xff0000) >> 16),
>, <Line: +                    (byte) ((size & 0xff00) >> 8),
>, <Line: +                    (byte) ((size & 0xff)),
>, <Line: +                    109, 100, 97, 116, // mdat
>, <Line: +            }));
>, <Line: +            for (StreamingSample sample : samples) {
>, <Line: +                writableByteChannel.write((ByteBuffer) sample.getContent().rewind());
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    private class ChunkContainer {
>, <Line: +        Mdat mdat;
>, <Line: +        StreamingTrack streamingTrack;
>, <Line: +        long duration;
>, <Line: +    }
>, <Line: +}
>]
[]