[]
[<Line: -package com.googlecode.mp4parser;
>, <Line: -import java.io.File;
>, <Line: -import java.io.IOException;
>, <Line: -import java.io.RandomAccessFile;
>, <Line: -import java.nio.ByteBuffer;
>, <Line: -import java.nio.channels.WritableByteChannel;
>, <Line: -import static com.googlecode.mp4parser.util.CastUtils.l2i;
>, <Line: -/**
>, <Line: - * A {@link DataSource} implementation that relies on direct reads from a {@link RandomAccessFile}.
>, <Line: - * It should be slower than {@link FileDataSourceImpl} but does not incur the implicit file locks of
>, <Line: - * memory mapped I/O on some JVMs. This implementation allows for a more controlled deletion of files
>, <Line: - * and might be preferred when working with temporary files.
>, <Line: - * @see <a href="http://bugs.java.com/view_bug.do?bug_id=4724038">JDK-4724038 : (fs) Add unmap method to MappedByteBuffer</a>
>, <Line: - * @see <a href="http://bugs.java.com/view_bug.do?bug_id=6359560">JDK-6359560 : (fs) File.deleteOnExit() doesn't work when MappedByteBuffer exists (win)</a>
>, <Line: - */
>, <Line: -public class DirectFileReadDataSource implements DataSource {
>, <Line: -    private static final int TRANSFER_SIZE = 8192;
>, <Line: -    private RandomAccessFile raf;
>, <Line: -    private String filename;
>, <Line: -    public DirectFileReadDataSource(File f) throws IOException {
>, <Line: -        this.raf = new RandomAccessFile(f, "r");
>, <Line: -        this.filename = f.getName();
>, <Line: -    }
>, <Line: -    public int read(ByteBuffer byteBuffer) throws IOException {
>, <Line: -        int len = byteBuffer.remaining();
>, <Line: -        int totalRead = 0;
>, <Line: -        int bytesRead = 0;
>, <Line: -        byte[] buf = new byte[TRANSFER_SIZE];
>, <Line: -        while (totalRead < len) {
>, <Line: -            int bytesToRead = Math.min((len - totalRead), TRANSFER_SIZE);
>, <Line: -            bytesRead = raf.read(buf, 0, bytesToRead);
>, <Line: -            if (bytesRead < 0) {
>, <Line: -                break;
>, <Line: -            } else {
>, <Line: -                totalRead += bytesRead;
>, <Line: -            }
>, <Line: -            byteBuffer.put(buf, 0, bytesRead);
>, <Line: -        }
>, <Line: -        return ((bytesRead < 0) && (totalRead == 0)) ? -1 : totalRead;
>, <Line: -    }
>, <Line: -    public int readAllInOnce(ByteBuffer byteBuffer) throws IOException {
>, <Line: -        byte[] buf = new byte[byteBuffer.remaining()];
>, <Line: -        int read = raf.read(buf);
>, <Line: -        byteBuffer.put(buf, 0, read);
>, <Line: -        return read;
>, <Line: -    }
>, <Line: -    public long size() throws IOException {
>, <Line: -        return raf.length();
>, <Line: -    }
>, <Line: -    public long position() throws IOException {
>, <Line: -        return raf.getFilePointer();
>, <Line: -    }
>, <Line: -    public void position(long nuPos) throws IOException {
>, <Line: -        raf.seek(nuPos);
>, <Line: -    }
>, <Line: -    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {
>, <Line: -        return target.write(map(position, count));
>, <Line: -    }
>, <Line: -    public ByteBuffer map(long startPosition, long size) throws IOException {
>, <Line: -        raf.seek(startPosition);
>, <Line: -        byte[] payload = new byte[l2i(size)];
>, <Line: -        raf.readFully(payload);
>, <Line: -        return ByteBuffer.wrap(payload);
>, <Line: -    }
>, <Line: -    public void close() throws IOException {
>, <Line: -        raf.close();
>, <Line: -    }
>, <Line: -    @Override
>, <Line: -    public String toString() {
>, <Line: -        return filename;
>, <Line: -    }
>, <Line: -}
>]