[<Line: +package org.mp4parser.tools;
>, <Line: +import org.mp4parser.Box;
>, <Line: +import org.mp4parser.Container;
>, <Line: +import org.mp4parser.ParsableBox;
>, <Line: +import org.mp4parser.support.AbstractContainerBox;
>, <Line: +    private Path() {
>, <Line: +    public static <T extends Box> T getPath(Box parsableBox, String path) {
>, <Line: +        List<T> all = getPaths(parsableBox, path, true);
>, <Line: +    public static <T extends Box> T getPath(Container container, String path) {
>, <Line: +    public static <T extends Box> T getPath(AbstractContainerBox containerBox, String path) {
>, <Line: +    private static <T extends Box> List<T> getPaths(ParsableBox parsableBox, String path, boolean singleResult) {
>, <Line: +        return getPaths((Object) parsableBox, path, singleResult);
>, <Line: +    private static <T extends Box> List<T> getPaths(Object thing, String path, boolean singleResult) {
>, <Line: +            throw new RuntimeException("Cannot start at / - only relative path expression into the structure are allowed");
>, <Line: +            if (thing instanceof ParsableBox) {
>, <Line: +                    throw new RuntimeException(".. notation no longer allowed");
>, <Line: +    public static boolean isContained(Container ref, Box box, String path) {
>, <Line: +        return getPaths(ref, path).contains(box);
>]
[<Line: -package com.googlecode.mp4parser.util;
>, <Line: -import com.coremedia.iso.boxes.Box;
>, <Line: -import com.coremedia.iso.boxes.Container;
>, <Line: -import com.googlecode.mp4parser.AbstractContainerBox;
>, <Line: -    private Path() {
>, <Line: -    }
>, <Line: -    public static String createPath(Box box) {
>, <Line: -        return createPath(box, "");
>, <Line: -    }
>, <Line: -    private static String createPath(Box box, String path) {
>, <Line: -        Container parent = box.getParent();
>, <Line: -        int index = 0;
>, <Line: -        List<Box> siblings = parent.getBoxes();
>, <Line: -        for (Box sibling : siblings) {
>, <Line: -            if (sibling.getType().equals(box.getType())) {
>, <Line: -                if (sibling == box) {
>, <Line: -                    break;
>, <Line: -                }
>, <Line: -                index++;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        path = String.format("/%s[%d]", box.getType(), index) + path;
>, <Line: -        if (parent instanceof Box) {
>, <Line: -            return createPath((Box) parent, path);
>, <Line: -        } else {
>, <Line: -            return path;
>, <Line: -        }
>, <Line: -    public static <T extends Box> T getPath(Box box, String path) {
>, <Line: -        List<T> all = getPaths(box, path, true);
>, <Line: -    public static <T extends Box> T  getPath(Container container, String path) {
>, <Line: -    public static <T extends Box> T  getPath(AbstractContainerBox containerBox, String path) {
>, <Line: -    private static <T extends Box> List<T>  getPaths(Box box, String path, boolean singleResult) {
>, <Line: -        return getPaths((Object) box, path, singleResult);
>, <Line: -    private static <T extends Box> List<T>  getPaths(Object thing, String path, boolean singleResult) {
>, <Line: -            path = path.substring(1);
>, <Line: -            while (thing instanceof Box) {
>, <Line: -                thing = ((Box) thing).getParent();
>, <Line: -            }
>, <Line: -            if (thing instanceof Box) {
>, <Line: -                    if (thing instanceof Box) {
>, <Line: -                        return Path.getPaths(((Box) thing).getParent(), later, singleResult);
>, <Line: -                    } else {
>, <Line: -                        return Collections.emptyList();
>, <Line: -                    }
>, <Line: -    public static boolean isContained(Box box, String path) {
>, <Line: -        assert path.startsWith("/") : "Absolute path required";
>, <Line: -        return getPaths(box, path).contains(box);
>]