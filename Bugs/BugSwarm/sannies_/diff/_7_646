[<Line: +package org.mp4parser.streaming.output.mp4;
>, <Line: +import org.mp4parser.Box;
>, <Line: +import org.mp4parser.IsoFile;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.*;
>, <Line: +import org.mp4parser.streaming.StreamingSample;
>, <Line: +import org.mp4parser.streaming.StreamingTrack;
>, <Line: +import org.mp4parser.streaming.extensions.*;
>, <Line: +import org.mp4parser.streaming.output.SampleSink;
>, <Line: +import org.mp4parser.tools.IsoTypeWriter;
>, <Line: +import org.mp4parser.tools.Mp4Arrays;
>, <Line: +import org.mp4parser.tools.Mp4Math;
>, <Line: +import java.io.IOException;
>, <Line: +import java.nio.ByteBuffer;
>, <Line: +import java.nio.channels.WritableByteChannel;
>, <Line: +import java.util.*;
>, <Line: +import java.util.concurrent.ConcurrentHashMap;
>, <Line: +import java.util.concurrent.CountDownLatch;
>, <Line: +import java.util.logging.Level;
>, <Line: +import java.util.logging.Logger;
>, <Line: +import static org.mp4parser.tools.CastUtils.l2i;
>, <Line: +/**
>, <Line: + * Creates a fragmented MP4 file consisting of a header [ftyp, moov], any number of fragments
>, <Line: + * [moof, mdat]+ and a footer [mfra].
>, <Line: + * The MultiTrackFragmentedMp4Writer is a passive component. It will only be active if one of the
>, <Line: + * source tracks pushes a sample via {@link #acceptSample(StreamingSample, StreamingTrack)}.
>, <Line: + * It has to be closed ({@link #close()}) actively to trigger the write of remaining buffered
>, <Line: + * samples and the footer.
>, <Line: + */
>, <Line: +public class FragmentedMp4Writer extends DefaultBoxes implements SampleSink {
>, <Line: +    public static final Object OBJ = new Object();
>, <Line: +    private static final Logger LOG = Logger.getLogger(FragmentedMp4Writer.class.getName());
>, <Line: +    protected final WritableByteChannel sink;
>, <Line: +    protected List<StreamingTrack> source;
>, <Line: +    protected Date creationTime;
>, <Line: +    protected long sequenceNumber = 1;
>, <Line: +    protected Map<StreamingTrack, CountDownLatch> congestionControl = new ConcurrentHashMap<StreamingTrack, CountDownLatch>();
>, <Line: +    /**
>, <Line: +     * Contains the start time of the next segment in line that will be created.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextFragmentCreateStartTime = new ConcurrentHashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Contains the start time of the next segment in line that will be written.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextFragmentWriteStartTime = new ConcurrentHashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Contains the next sample's start time.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Long> nextSampleStartTime = new HashMap<StreamingTrack, Long>();
>, <Line: +    /**
>, <Line: +     * Buffers the samples per track until there are enough samples to form a Segment.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, List<StreamingSample>> sampleBuffers = new HashMap<StreamingTrack, List<StreamingSample>>();
>, <Line: +    /**
>, <Line: +     * Buffers segements until it's time for a segment to be written.
>, <Line: +     */
>, <Line: +    protected Map<StreamingTrack, Queue<FragmentContainer>> fragmentBuffers = new ConcurrentHashMap<StreamingTrack, Queue<FragmentContainer>>();
>, <Line: +    protected Map<StreamingTrack, long[]> tfraOffsets = new HashMap<StreamingTrack, long[]>();
>, <Line: +    protected Map<StreamingTrack, long[]> tfraTimes = new HashMap<StreamingTrack, long[]>();
>, <Line: +    long bytesWritten = 0;
>, <Line: +    volatile boolean headerWritten = false;
>, <Line: +    public FragmentedMp4Writer(List<StreamingTrack> source, WritableByteChannel sink) throws IOException {
>, <Line: +        this.source = new LinkedList<StreamingTrack>(source);
>, <Line: +        this.sink = sink;
>, <Line: +        this.creationTime = new Date();
>, <Line: +        HashSet<Long> trackIds = new HashSet<Long>();
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            // this connects sample source with sample sink
>, <Line: +            streamingTrack.setSampleSink(this);
>, <Line: +            sampleBuffers.put(streamingTrack, new ArrayList<StreamingSample>());
>, <Line: +            fragmentBuffers.put(streamingTrack, new LinkedList<FragmentContainer>());
>, <Line: +            nextFragmentCreateStartTime.put(streamingTrack, 0L);
>, <Line: +            nextFragmentWriteStartTime.put(streamingTrack, 0L);
>, <Line: +            nextSampleStartTime.put(streamingTrack, 0L);
>, <Line: +            congestionControl.put(streamingTrack, new CountDownLatch(0));
>, <Line: +            if (streamingTrack.getTrackExtension(TrackIdTrackExtension.class) != null) {
>, <Line: +                TrackIdTrackExtension trackIdTrackExtension = streamingTrack.getTrackExtension(TrackIdTrackExtension.class);
>, <Line: +                assert trackIdTrackExtension != null;
>, <Line: +                if (trackIds.contains(trackIdTrackExtension.getTrackId())) {
>, <Line: +                    throw new IOException("There may not be two tracks with the same trackID within one file");
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            if (streamingTrack.getTrackExtension(TrackIdTrackExtension.class) == null) {
>, <Line: +                long maxTrackId = 0;
>, <Line: +                for (Long trackId : trackIds) {
>, <Line: +                    maxTrackId = Math.max(trackId, maxTrackId);
>, <Line: +                }
>, <Line: +                TrackIdTrackExtension tiExt = new TrackIdTrackExtension(maxTrackId + 1);
>, <Line: +                trackIds.add(tiExt.getTrackId());
>, <Line: +                streamingTrack.addTrackExtension(tiExt);
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Writes the remaining samples to file (even though the typical condition for wrapping up
>, <Line: +     * a segment have not yet been met) and writes the MovieFragmentRandomAccessBox.
>, <Line: +     * It does not close the sink!
>, <Line: +     *
>, <Line: +     * @throws IOException if writing to the underlying data sink fails
>, <Line: +     * @see MovieFragmentRandomAccessBox
>, <Line: +     */
>, <Line: +    public synchronized void close() throws IOException {
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            writeFragment(createFragment(streamingTrack, sampleBuffers.get(streamingTrack)));
>, <Line: +            streamingTrack.close();
>, <Line: +        }
>, <Line: +        writeFooter(createFooter());
>, <Line: +    }
>, <Line: +    protected void write(WritableByteChannel out, Box... boxes) throws IOException {
>, <Line: +        for (Box box1 : boxes) {
>, <Line: +            box1.getBox(out);
>, <Line: +            bytesWritten += box1.getSize();
>, <Line: +        }
>, <Line: +    }
>, <Line: +    protected Box createMdhd(StreamingTrack streamingTrack) {
>, <Line: +        MediaHeaderBox mdhd = new MediaHeaderBox();
>, <Line: +        mdhd.setCreationTime(creationTime);
>, <Line: +        mdhd.setModificationTime(creationTime);
>, <Line: +        mdhd.setDuration(0);//no duration in moov for fragmented movies
>, <Line: +        mdhd.setTimescale(streamingTrack.getTimescale());
>, <Line: +        mdhd.setLanguage(streamingTrack.getLanguage());
>, <Line: +        return mdhd;
>, <Line: +    }
>, <Line: +    protected Box createMvex() {
>, <Line: +        MovieExtendsBox mvex = new MovieExtendsBox();
>, <Line: +        final MovieExtendsHeaderBox mved = new MovieExtendsHeaderBox();
>, <Line: +        mved.setVersion(1);
>, <Line: +        mved.setFragmentDuration(0);
>, <Line: +        mvex.addBox(mved);
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            mvex.addBox(createTrex(streamingTrack));
>, <Line: +        }
>, <Line: +        return mvex;
>, <Line: +    }
>, <Line: +    protected Box createTrex(StreamingTrack streamingTrack) {
>, <Line: +        TrackExtendsBox trex = new TrackExtendsBox();
>, <Line: +        trex.setTrackId(streamingTrack.getTrackExtension(TrackIdTrackExtension.class).getTrackId());
>, <Line: +        trex.setDefaultSampleDescriptionIndex(1);
>, <Line: +        trex.setDefaultSampleDuration(0);
>, <Line: +        trex.setDefaultSampleSize(0);
>, <Line: +        SampleFlags sf = new SampleFlags();
>, <Line: +        trex.setDefaultSampleFlags(sf);
>, <Line: +        return trex;
>, <Line: +    }
>, <Line: +    protected Box createMvhd() {
>, <Line: +        MovieHeaderBox mvhd = new MovieHeaderBox();
>, <Line: +        mvhd.setVersion(1);
>, <Line: +        mvhd.setCreationTime(creationTime);
>, <Line: +        mvhd.setModificationTime(creationTime);
>, <Line: +        mvhd.setDuration(0);//no duration in moov for fragmented movies
>, <Line: +        long[] timescales = new long[0];
>, <Line: +        long maxTrackId = 0;
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            timescales = Mp4Arrays.copyOfAndAppend(timescales, streamingTrack.getTimescale());
>, <Line: +            maxTrackId = Math.max(streamingTrack.getTrackExtension(TrackIdTrackExtension.class).getTrackId(), maxTrackId);
>, <Line: +        }
>, <Line: +        mvhd.setTimescale(Mp4Math.lcm(timescales));
>, <Line: +        // find the next available trackId
>, <Line: +        mvhd.setNextTrackId(maxTrackId + 1);
>, <Line: +        return mvhd;
>, <Line: +    }
>, <Line: +    protected Box createMoov() {
>, <Line: +        MovieBox movieBox = new MovieBox();
>, <Line: +        movieBox.addBox(createMvhd());
>, <Line: +        for (StreamingTrack streamingTrack : source) {
>, <Line: +            movieBox.addBox(createTrak(streamingTrack));
>, <Line: +        }
>, <Line: +        movieBox.addBox(createMvex());
>, <Line: +        // metadata here
>, <Line: +        return movieBox;
>, <Line: +    }
>, <Line: +    protected Box[] createHeader() {
>, <Line: +        return new Box[]{createFtyp(), createMoov()};
>, <Line: +    }
>, <Line: +    private void sortTracks() {
>, <Line: +        Collections.sort(source, new Comparator<StreamingTrack>() {
>, <Line: +            public int compare(StreamingTrack o1, StreamingTrack o2) {
>, <Line: +                // compare times and account for timestamps!
>, <Line: +                long a = nextFragmentWriteStartTime.get(o1) * o2.getTimescale();
>, <Line: +                long b = nextFragmentWriteStartTime.get(o2) * o1.getTimescale();
>, <Line: +                double d = Math.signum(a - b);
>, <Line: +                return (int) d;
>, <Line: +            }
>, <Line: +        });
>, <Line: +    }
>, <Line: +    public void acceptSample(StreamingSample streamingSample, StreamingTrack streamingTrack) throws IOException {
>, <Line: +        synchronized (OBJ) {
>, <Line: +            // need to synchronized here - I don't want two headers written under any circumstances
>, <Line: +            if (!headerWritten) {
>, <Line: +                boolean allTracksAtLeastOneSample = true;
>, <Line: +                for (StreamingTrack track : source) {
>, <Line: +                    allTracksAtLeastOneSample &= (nextSampleStartTime.get(track) > 0 || track == streamingTrack);
>, <Line: +                }
>, <Line: +                if (allTracksAtLeastOneSample) {
>, <Line: +                    writeHeader(createHeader());
>, <Line: +                    headerWritten = true;
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        try {
>, <Line: +            CountDownLatch cdl = congestionControl.get(streamingTrack);
>, <Line: +            if (cdl.getCount() > 0) {
>, <Line: +                cdl.await();
>, <Line: +            }
>, <Line: +        } catch (InterruptedException e) {
>, <Line: +            // don't care just move on
>, <Line: +        }
>, <Line: +        if (isFragmentReady(streamingTrack, streamingSample)) {
>, <Line: +            FragmentContainer fragmentContainer = createFragmentContainer(streamingTrack);
>, <Line: +            //System.err.println("Creating fragment for " + streamingTrack);
>, <Line: +            sampleBuffers.get(streamingTrack).clear();
>, <Line: +            nextFragmentCreateStartTime.put(streamingTrack, nextFragmentCreateStartTime.get(streamingTrack) + fragmentContainer.duration);
>, <Line: +            Queue<FragmentContainer> fragmentQueue = fragmentBuffers.get(streamingTrack);
>, <Line: +            fragmentQueue.add(fragmentContainer);
>, <Line: +            synchronized (OBJ) {
>, <Line: +                if (headerWritten && this.source.get(0) == streamingTrack) {
>, <Line: +                    Queue<FragmentContainer> tracksFragmentQueue;
>, <Line: +                    StreamingTrack currentStreamingTrack;
>, <Line: +                    // This will write AT LEAST the currently created fragment and possibly a few more
>, <Line: +                    while (!(tracksFragmentQueue = fragmentBuffers.get(
>, <Line: +                            (currentStreamingTrack = this.source.get(0))
>, <Line: +                    )).isEmpty()) {
>, <Line: +                        FragmentContainer currentFragmentContainer = tracksFragmentQueue.remove();
>, <Line: +                        writeFragment(currentFragmentContainer.fragmentContent);
>, <Line: +                        congestionControl.get(currentStreamingTrack).countDown();
>, <Line: +                        long ts = nextFragmentWriteStartTime.get(currentStreamingTrack) + currentFragmentContainer.duration;
>, <Line: +                        nextFragmentWriteStartTime.put(currentStreamingTrack, ts);
>, <Line: +                        if (LOG.isLoggable(Level.FINE)) {
>, <Line: +                            LOG.fine(currentStreamingTrack + " advanced to " + (double) ts / currentStreamingTrack.getTimescale());
>, <Line: +                        }
>, <Line: +                        sortTracks();
>, <Line: +                    }
>, <Line: +                } else {
>, <Line: +                    if (fragmentQueue.size() > 10) {
>, <Line: +                        // if there are more than 10 fragments in the queue we don't want more samples of this track
>, <Line: +                        // System.err.println("Stopping " + streamingTrack);
>, <Line: +                        congestionControl.put(streamingTrack, new CountDownLatch(fragmentQueue.size()));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        sampleBuffers.get(streamingTrack).add(streamingSample);
>, <Line: +        nextSampleStartTime.put(streamingTrack, nextSampleStartTime.get(streamingTrack) + streamingSample.getDuration());
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Tests if the currently received samples for a given track
>, <Line: +     * form a valid fragment taking the latest received sample into
>, <Line: +     * account. The next sample is not part of the segment and
>, <Line: +     * will be added to the fragment buffer later.
>, <Line: +     *
>, <Line: +     * @param streamingTrack track to test
>, <Line: +     * @param next           the lastest samples
>, <Line: +     * @return true if a fragment has been created.
>, <Line: +     */
>, <Line: +    protected boolean isFragmentReady(StreamingTrack streamingTrack, StreamingSample next) {
>, <Line: +        long ts = nextSampleStartTime.get(streamingTrack);
>, <Line: +        long cfst = nextFragmentCreateStartTime.get(streamingTrack);
>, <Line: +        if ((ts > cfst + 3 * streamingTrack.getTimescale())) {
>, <Line: +            // mininum fragment length == 3 seconds
>, <Line: +            SampleFlagsSampleExtension sfExt = next.getSampleExtension(SampleFlagsSampleExtension.class);
>, <Line: +            if (sfExt == null || sfExt.isSyncSample()) {
>, <Line: +                //System.err.println(streamingTrack + " ready at " + ts);
>, <Line: +                // the next sample needs to be a sync sample
>, <Line: +                // when there is no SampleFlagsSampleExtension we assume syncSample == true
>, <Line: +                return true;
>, <Line: +            }
>, <Line: +        }
>, <Line: +        return false;
>, <Line: +    }
>, <Line: +    protected Box[] createFragment(StreamingTrack streamingTrack, List<StreamingSample> samples) {
>, <Line: +        nextFragmentCreateStartTime.get(streamingTrack);
>, <Line: +        tfraOffsets.put(streamingTrack, Mp4Arrays.copyOfAndAppend(tfraOffsets.get(streamingTrack), bytesWritten));
>, <Line: +        tfraTimes.put(streamingTrack, Mp4Arrays.copyOfAndAppend(tfraTimes.get(streamingTrack), nextFragmentCreateStartTime.get(streamingTrack)));
>, <Line: +        LOG.finest("Container created");
>, <Line: +        Box moof = createMoof(streamingTrack, samples);
>, <Line: +        LOG.finest("moof created");
>, <Line: +        Box mdat = createMdat(samples);
>, <Line: +        LOG.finest("mdat created");
>, <Line: +        if (LOG.isLoggable(Level.FINE)) {
>, <Line: +            double duration = nextSampleStartTime.get(streamingTrack) - nextFragmentCreateStartTime.get(streamingTrack);
>, <Line: +            LOG.fine("created fragment for " + streamingTrack + " of " + (duration / streamingTrack.getTimescale()) + " seconds");
>, <Line: +        }
>, <Line: +        return new Box[]{moof, mdat};
>, <Line: +    }
>, <Line: +    private FragmentContainer createFragmentContainer(StreamingTrack streamingTrack) {
>, <Line: +        FragmentContainer fragmentContainer = new FragmentContainer();
>, <Line: +        List<StreamingSample> samples = new ArrayList<StreamingSample>(sampleBuffers.get(streamingTrack));
>, <Line: +        fragmentContainer.fragmentContent = createFragment(streamingTrack, samples);
>, <Line: +        fragmentContainer.duration = nextSampleStartTime.get(streamingTrack) - nextFragmentCreateStartTime.get(streamingTrack);
>, <Line: +        return fragmentContainer;
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Writes the given boxes. It's called as soon as the MultiTrackFragmentedMp4Writer
>, <Line: +     * received a sample from each source as this is the first point in time where the
>, <Line: +     * MultiTrackFragmentedMp4Writer can be sure that all config data is available from
>, <Line: +     * the sources.
>, <Line: +     * It typically writes a ftyp/moov pair but will write what ever
>, <Line: +     * the boxes argument contains
>, <Line: +     *
>, <Line: +     * @param boxes any number of boxes that form the header
>, <Line: +     * @throws IOException when writing to the sink fails.
>, <Line: +     * @see FileTypeBox
>, <Line: +     * @see ProgressiveDownloadInformationBox
>, <Line: +     * @see MovieBox
>, <Line: +     * @see SegmentIndexBox
>, <Line: +     */
>, <Line: +    protected void writeHeader(Box... boxes) throws IOException {
>, <Line: +        write(sink, boxes);
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Writes the given boxes. It's called as soon as a fragment is created.
>, <Line: +     * It typically write a single moof/mdat pair but will write what ever
>, <Line: +     * the boxes argument contains
>, <Line: +     *
>, <Line: +     * @param boxes any number of boxes that form fragment
>, <Line: +     * @throws IOException when writing to the sink fails.
>, <Line: +     * @see MovieFragmentBox
>, <Line: +     * @see MediaDataBox
>, <Line: +     * @see SegmentTypeBox
>, <Line: +     * @see SegmentIndexBox
>, <Line: +     */
>, <Line: +    protected void writeFragment(Box... boxes) throws IOException {
>, <Line: +        write(sink, boxes);
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Writes the given boxes. It's called as last write operation. Typically the only
>, <Line: +     * box written is the MovieFragmentRandomAccessBox.
>, <Line: +     *
>, <Line: +     * @param boxes any number of boxes to conclude the file.
>, <Line: +     * @throws IOException when writing to the sink fails.
>, <Line: +     * @see MovieFragmentRandomAccessBox
>, <Line: +     */
>, <Line: +    protected void writeFooter(Box... boxes) throws IOException {
>, <Line: +        write(sink, boxes);
>, <Line: +    }
>, <Line: +    private Box createMoof(StreamingTrack streamingTrack, List<StreamingSample> samples) {
>, <Line: +        MovieFragmentBox moof = new MovieFragmentBox();
>, <Line: +        createMfhd(sequenceNumber, moof);
>, <Line: +        createTraf(streamingTrack, moof, samples);
>, <Line: +        TrackRunBox firstTrun = moof.getTrackRunBoxes().get(0);
>, <Line: +        firstTrun.setDataOffset(1); // dummy to make size correct
>, <Line: +        firstTrun.setDataOffset((int) (8 + moof.getSize())); // mdat header + moof size
>, <Line: +        return moof;
>, <Line: +    }
>, <Line: +    protected void createTfhd(StreamingTrack streamingTrack, TrackFragmentBox parent) {
>, <Line: +        TrackFragmentHeaderBox tfhd = new TrackFragmentHeaderBox();
>, <Line: +        SampleFlags sf = new SampleFlags();
>, <Line: +        DefaultSampleFlagsTrackExtension defaultSampleFlagsTrackExtension = streamingTrack.getTrackExtension(DefaultSampleFlagsTrackExtension.class);
>, <Line: +        // I don't like the idea of using sampleflags in trex as it breaks the "self-contained" property of a fragment
>, <Line: +        if (defaultSampleFlagsTrackExtension != null) {
>, <Line: +            sf.setIsLeading(defaultSampleFlagsTrackExtension.getIsLeading());
>, <Line: +            sf.setSampleIsDependedOn(defaultSampleFlagsTrackExtension.getSampleIsDependedOn());
>, <Line: +            sf.setSampleDependsOn(defaultSampleFlagsTrackExtension.getSampleDependsOn());
>, <Line: +            sf.setSampleHasRedundancy(defaultSampleFlagsTrackExtension.getSampleHasRedundancy());
>, <Line: +            sf.setSampleIsDifferenceSample(defaultSampleFlagsTrackExtension.isSampleIsNonSyncSample());
>, <Line: +            sf.setSamplePaddingValue(defaultSampleFlagsTrackExtension.getSamplePaddingValue());
>, <Line: +            sf.setSampleDegradationPriority(defaultSampleFlagsTrackExtension.getSampleDegradationPriority());
>, <Line: +        }
>, <Line: +        tfhd.setDefaultSampleFlags(sf);
>, <Line: +        tfhd.setBaseDataOffset(-1);
>, <Line: +        tfhd.setTrackId(streamingTrack.getTrackExtension(TrackIdTrackExtension.class).getTrackId());
>, <Line: +        tfhd.setDefaultBaseIsMoof(true);
>, <Line: +        parent.addBox(tfhd);
>, <Line: +    }
>, <Line: +    protected void createTfdt(StreamingTrack streamingTrack, TrackFragmentBox parent) {
>, <Line: +        TrackFragmentBaseMediaDecodeTimeBox tfdt = new TrackFragmentBaseMediaDecodeTimeBox();
>, <Line: +        tfdt.setVersion(1);
>, <Line: +        tfdt.setBaseMediaDecodeTime(nextFragmentCreateStartTime.get(streamingTrack));
>, <Line: +        parent.addBox(tfdt);
>, <Line: +    }
>, <Line: +    protected void createTrun(StreamingTrack streamingTrack, TrackFragmentBox parent, List<StreamingSample> samples) {
>, <Line: +        TrackRunBox trun = new TrackRunBox();
>, <Line: +        trun.setVersion(1);
>, <Line: +        trun.setSampleDurationPresent(true);
>, <Line: +        trun.setSampleSizePresent(true);
>, <Line: +        List<TrackRunBox.Entry> entries = new ArrayList<TrackRunBox.Entry>(samples.size());
>, <Line: +        trun.setSampleCompositionTimeOffsetPresent(streamingTrack.getTrackExtension(CompositionTimeTrackExtension.class) != null);
>, <Line: +        DefaultSampleFlagsTrackExtension defaultSampleFlagsTrackExtension = streamingTrack.getTrackExtension(DefaultSampleFlagsTrackExtension.class);
>, <Line: +        trun.setSampleFlagsPresent(defaultSampleFlagsTrackExtension == null);
>, <Line: +        for (StreamingSample streamingSample : samples) {
>, <Line: +            TrackRunBox.Entry entry = new TrackRunBox.Entry();
>, <Line: +            entry.setSampleSize(streamingSample.getContent().remaining());
>, <Line: +            if (defaultSampleFlagsTrackExtension == null) {
>, <Line: +                SampleFlagsSampleExtension sampleFlagsSampleExtension = streamingSample.getSampleExtension(SampleFlagsSampleExtension.class);
>, <Line: +                assert sampleFlagsSampleExtension != null : "SampleDependencySampleExtension missing even though SampleDependencyTrackExtension was present";
>, <Line: +                SampleFlags sflags = new SampleFlags();
>, <Line: +                sflags.setIsLeading(sampleFlagsSampleExtension.getIsLeading());
>, <Line: +                sflags.setSampleIsDependedOn(sampleFlagsSampleExtension.getSampleIsDependedOn());
>, <Line: +                sflags.setSampleDependsOn(sampleFlagsSampleExtension.getSampleDependsOn());
>, <Line: +                sflags.setSampleHasRedundancy(sampleFlagsSampleExtension.getSampleHasRedundancy());
>, <Line: +                sflags.setSampleIsDifferenceSample(sampleFlagsSampleExtension.isSampleIsNonSyncSample());
>, <Line: +                sflags.setSamplePaddingValue(sampleFlagsSampleExtension.getSamplePaddingValue());
>, <Line: +                sflags.setSampleDegradationPriority(sampleFlagsSampleExtension.getSampleDegradationPriority());
>, <Line: +                entry.setSampleFlags(sflags);
>, <Line: +            }
>, <Line: +            entry.setSampleDuration(streamingSample.getDuration());
>, <Line: +            if (trun.isSampleCompositionTimeOffsetPresent()) {
>, <Line: +                CompositionTimeSampleExtension compositionTimeSampleExtension = streamingSample.getSampleExtension(CompositionTimeSampleExtension.class);
>, <Line: +                assert compositionTimeSampleExtension != null : "CompositionTimeSampleExtension missing even though CompositionTimeTrackExtension was present";
>, <Line: +                entry.setSampleCompositionTimeOffset(l2i(compositionTimeSampleExtension.getCompositionTimeOffset()));
>, <Line: +            }
>, <Line: +            entries.add(entry);
>, <Line: +        }
>, <Line: +        trun.setEntries(entries);
>, <Line: +        parent.addBox(trun);
>, <Line: +    }
>, <Line: +    private void createTraf(StreamingTrack streamingTrack, MovieFragmentBox moof, List<StreamingSample> samples) {
>, <Line: +        TrackFragmentBox traf = new TrackFragmentBox();
>, <Line: +        moof.addBox(traf);
>, <Line: +        createTfhd(streamingTrack, traf);
>, <Line: +        createTfdt(streamingTrack, traf);
>, <Line: +        createTrun(streamingTrack, traf, samples);
>, <Line: +        if (streamingTrack.getTrackExtension(CencEncryptTrackExtension.class) != null) {
>, <Line: +            //     createSaiz(getTrackExtension(source, CencEncryptTrackExtension.class), sequenceNumber, traf);
>, <Line: +            //     createSenc(getTrackExtension(source, CencEncryptTrackExtension.class), sequenceNumber, traf);
>, <Line: +            //     createSaio(getTrackExtension(source, CencEncryptTrackExtension.class), sequenceNumber, traf);
>, <Line: +        }
>, <Line: +  /*      Map<String, List<GroupEntry>> groupEntryFamilies = new HashMap<String, List<GroupEntry>>();
>, <Line: +        for (Map.Entry<GroupEntry, long[]> sg : track.getSampleGroups().entrySet()) {
>, <Line: +            String type = sg.getKey().getType();
>, <Line: +            List<GroupEntry> groupEntries = groupEntryFamilies.get(type);
>, <Line: +            if (groupEntries == null) {
>, <Line: +                groupEntries = new ArrayList<GroupEntry>();
>, <Line: +                groupEntryFamilies.put(type, groupEntries);
>, <Line: +            }
>, <Line: +            groupEntries.add(sg.getKey());
>, <Line: +        }
>, <Line: +        for (Map.Entry<String, List<GroupEntry>> sg : groupEntryFamilies.entrySet()) {
>, <Line: +            SampleGroupDescriptionBox sgpd = new SampleGroupDescriptionBox();
>, <Line: +            String type = sg.getKey();
>, <Line: +            sgpd.setGroupEntries(sg.getValue());
>, <Line: +            SampleToGroupBox sbgp = new SampleToGroupBox();
>, <Line: +            sbgp.setGroupingType(type);
>, <Line: +            SampleToGroupBox.Entry last = null;
>, <Line: +            for (int i = l2i(startSample - 1); i < l2i(endSample - 1); i++) {
>, <Line: +                int index = 0;
>, <Line: +                for (int j = 0; j < sg.getValue().size(); j++) {
>, <Line: +                    GroupEntry groupEntry = sg.getValue().get(j);
>, <Line: +                    long[] sampleNums = track.getSampleGroups().get(groupEntry);
>, <Line: +                    if (Arrays.binarySearch(sampleNums, i) >= 0) {
>, <Line: +                        index = j + 1;
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                if (last == null || last.getGroupDescriptionIndex() != index) {
>, <Line: +                    last = new SampleToGroupBox.Entry(1, index);
>, <Line: +                    sbgp.getEntries().add(last);
>, <Line: +                } else {
>, <Line: +                    last.setSampleCount(last.getSampleCount() + 1);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            traf.addBox(sgpd);
>, <Line: +            traf.addBox(sbgp);
>, <Line: +        }*/
>, <Line: +    }
>, <Line: +    protected Box[] createFooter() {
>, <Line: +        MovieFragmentRandomAccessBox mfra = new MovieFragmentRandomAccessBox();
>, <Line: +        for (StreamingTrack track : source) {
>, <Line: +            mfra.addBox(createTfra(track));
>, <Line: +        }
>, <Line: +        MovieFragmentRandomAccessOffsetBox mfro = new MovieFragmentRandomAccessOffsetBox();
>, <Line: +        mfra.addBox(mfro);
>, <Line: +        mfro.setMfraSize(mfra.getSize());
>, <Line: +        return new Box[]{mfra};
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Creates a 'tfra' - track fragment random access box for the given track with the isoFile.
>, <Line: +     * The tfra contains a map of random access points with time as key and offset within the isofile
>, <Line: +     * as value.
>, <Line: +     *
>, <Line: +     * @param track the concerned track
>, <Line: +     * @return a track fragment random access box.
>, <Line: +     */
>, <Line: +    protected Box createTfra(StreamingTrack track) {
>, <Line: +        TrackFragmentRandomAccessBox tfra = new TrackFragmentRandomAccessBox();
>, <Line: +        tfra.setVersion(1); // use long offsets and times
>, <Line: +        long[] offsets = tfraOffsets.get(track);
>, <Line: +        long[] times = tfraTimes.get(track);
>, <Line: +        List<TrackFragmentRandomAccessBox.Entry> entries = new ArrayList<TrackFragmentRandomAccessBox.Entry>(times.length);
>, <Line: +        for (int i = 0; i < times.length; i++) {
>, <Line: +            entries.add(new TrackFragmentRandomAccessBox.Entry(times[i], offsets[i], 1, 1, 1));
>, <Line: +        }
>, <Line: +        tfra.setEntries(entries);
>, <Line: +        tfra.setTrackId(track.getTrackExtension(TrackIdTrackExtension.class).getTrackId());
>, <Line: +        return tfra;
>, <Line: +    }
>, <Line: +    private void createMfhd(long sequenceNumber, MovieFragmentBox moof) {
>, <Line: +        MovieFragmentHeaderBox mfhd = new MovieFragmentHeaderBox();
>, <Line: +        mfhd.setSequenceNumber(sequenceNumber);
>, <Line: +        moof.addBox(mfhd);
>, <Line: +    }
>, <Line: +    private Box createMdat(final List<StreamingSample> samples) {
>, <Line: +        return new Box() {
>, <Line: +            public String getType() {
>, <Line: +                return "mdat";
>, <Line: +            }
>, <Line: +            public long getSize() {
>, <Line: +                long l = 8;
>, <Line: +                for (StreamingSample streamingSample : samples) {
>, <Line: +                    l += streamingSample.getContent().limit();
>, <Line: +                }
>, <Line: +                return l;
>, <Line: +            }
>, <Line: +            public void getBox(WritableByteChannel writableByteChannel) throws IOException {
>, <Line: +                long l = 8;
>, <Line: +                for (StreamingSample streamingSample : samples) {
>, <Line: +                    ByteBuffer sampleContent = streamingSample.getContent();
>, <Line: +                    l += sampleContent.limit();
>, <Line: +                }
>, <Line: +                ByteBuffer bb = ByteBuffer.allocate(8);
>, <Line: +                IsoTypeWriter.writeUInt32(bb, l);
>, <Line: +                bb.put(IsoFile.fourCCtoBytes(getType()));
>, <Line: +                writableByteChannel.write((ByteBuffer) bb.rewind());
>, <Line: +                for (StreamingSample streamingSample : samples) {
>, <Line: +                    writableByteChannel.write((ByteBuffer) streamingSample.getContent().rewind());
>, <Line: +                }
>, <Line: +            }
>, <Line: +        };
>, <Line: +    }
>, <Line: +    public class FragmentContainer {
>, <Line: +        Box[] fragmentContent;
>, <Line: +        long duration;
>, <Line: +    }
>, <Line: +}
>]
[]