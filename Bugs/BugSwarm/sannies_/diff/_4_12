[<Line: +import org.mp4parser.streaming.input.h264.spspps.PictureParameterSet;
>, <Line: +import org.mp4parser.streaming.input.h264.spspps.SeqParameterSet;
>, <Line: +import org.mp4parser.streaming.input.h264.spspps.SliceHeader;
>, <Line: +import java.nio.ByteBuffer;
>, <Line: +public abstract class H264NalConsumingTrack extends AbstractH264Track {
>, <Line: +    LinkedHashMap<Integer, ByteBuffer> spsIdToSpsBytes = new LinkedHashMap<Integer, ByteBuffer>();
>, <Line: +    LinkedHashMap<Integer, ByteBuffer> ppsIdToPpsBytes = new LinkedHashMap<Integer, ByteBuffer>();
>, <Line: +    List<ByteBuffer> buffered = new ArrayList<ByteBuffer>();
>, <Line: +    H264NalUnitHeader sliceNalUnitHeader;
>, <Line: +    public static H264NalUnitHeader getNalUnitHeader(ByteBuffer nal) {
>, <Line: +        int type = nal.get(0);
>, <Line: +    protected void consumeNal(ByteBuffer nal) throws IOException {
>, <Line: +                sliceNalUnitHeader = nalUnitHeader;
>, <Line: +                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
>, <Line: +                    buffered.clear();
>, <Line: +                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
>, <Line: +                    buffered.clear();
>, <Line: +                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
>, <Line: +                    buffered.clear();
>, <Line: +                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
>, <Line: +                    buffered.clear();
>, <Line: +                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
>, <Line: +                    buffered.clear();
>, <Line: +    protected void pushSample(StreamingSample ss, boolean all, boolean force) throws IOException {
>, <Line: +        if (ss != null) {
>, <Line: +            decFrameBuffer.add(ss);
>, <Line: +        }
>, <Line: +                pushSample(null, false, true);
>, <Line: +            if ((decFrameBuffer.size() - 1 > max_dec_frame_buffering) || force) {
>, <Line: +                StreamingSample first = decFrameBuffer.remove(0);
>, <Line: +                PictureOrderCountType0SampleExtension poct0se = first.getSampleExtension(PictureOrderCountType0SampleExtension.class);
>, <Line: +                if (poct0se == null) {
>, <Line: +                    sampleSink.acceptSample(first, this);
>, <Line: +                } else {
>, <Line: +                    int delay = 0;
>, <Line: +                    for (StreamingSample streamingSample : decFrameBuffer) {
>, <Line: +                        if (poct0se.getPoc() > streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
>, <Line: +                            delay++;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    for (StreamingSample streamingSample : decFrameBuffer2) {
>, <Line: +                        if (poct0se.getPoc() < streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
>, <Line: +                            delay--;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    decFrameBuffer2.add(first);
>, <Line: +                    if (decFrameBuffer2.size() > max_dec_frame_buffering) {
>, <Line: +                        decFrameBuffer2.remove(0).removeSampleExtension(PictureOrderCountType0SampleExtension.class);
>, <Line: +                    }
>, <Line: +                    first.addSampleExtension(CompositionTimeSampleExtension.create(delay * frametick));
>, <Line: +                    //System.err.println("Adding sample");
>, <Line: +                    sampleSink.acceptSample(first, this);
>, <Line: +    protected SampleFlagsSampleExtension createSampleFlagsSampleExtension(H264NalUnitHeader nu, SliceHeader sliceHeader) {
>, <Line: +        sampleFlagsSampleExtension.setSampleIsNonSyncSample(H264NalUnitTypes.CODED_SLICE_IDR != nu.nal_unit_type);
>, <Line: +        return sampleFlagsSampleExtension;
>, <Line: +    }
>, <Line: +    protected PictureOrderCountType0SampleExtension createPictureOrderCountType0SampleExtension(SliceHeader sliceHeader) {
>, <Line: +            return new PictureOrderCountType0SampleExtension(
>, <Line: +                    null);
>, <Line: +/*            decFrameBuffer.add(ssi);
>, <Line: +            }*/
>, <Line: +            throw new RuntimeException("pic_order_cnt_type == 1 needs to be implemented");
>, <Line: +            return null; // no ctts
>, <Line: +        }
>, <Line: +        throw new RuntimeException("I don't know sliceHeader.sps.pic_order_cnt_type of " + sliceHeader.sps.pic_order_cnt_type);
>, <Line: +    }
>, <Line: +    protected StreamingSample createSample(List<ByteBuffer> nals, SliceHeader sliceHeader, H264NalUnitHeader nu) throws IOException {
>, <Line: +        LOG.finer("Create Sample");
>, <Line: +        configure();
>, <Line: +        if (timescale == 0 || frametick == 0) {
>, <Line: +            throw new IOException("Frame Rate needs to be configured either by hand or by SPS before samples can be created");
>, <Line: +        StreamingSample ss = new StreamingSampleImpl(
>, <Line: +                nals,
>, <Line: +                frametick);
>, <Line: +        ss.addSampleExtension(createSampleFlagsSampleExtension(nu, sliceHeader));
>, <Line: +        ss.addSampleExtension(createPictureOrderCountType0SampleExtension(sliceHeader));
>, <Line: +        return ss;
>, <Line: +        if (!configured) {
>, <Line: +            avcConfigurationBox.setSequenceParameterSets(new ArrayList<ByteBuffer>(spsIdToSpsBytes.values()));
>, <Line: +            avcConfigurationBox.setPictureParameterSets(new ArrayList<ByteBuffer>(ppsIdToPpsBytes.values()));
>, <Line: +            if (sps.pic_order_cnt_type == 0) {
>, <Line: +                this.addTrackExtension(new CompositionTimeTrackExtension());
>, <Line: +            } else if (sps.pic_order_cnt_type == 1) {
>, <Line: +                throw new RuntimeException("Have not yet imlemented pic_order_cnt_type 1");
>, <Line: +            }
>, <Line: +    protected void handlePPS(ByteBuffer nal) {
>, <Line: +        nal.position(1);
>, <Line: +        PictureParameterSet _pictureParameterSet = null;
>, <Line: +        try {
>, <Line: +            _pictureParameterSet = PictureParameterSet.read(nal);
>, <Line: +            currentPictureParameterSet = _pictureParameterSet;
>, <Line: +            ByteBuffer oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
>, <Line: +            if (oldPpsSameId != null && !oldPpsSameId.equals(nal)) {
>, <Line: +                throw new RuntimeException("OMG - I got two SPS with same ID but different settings! (AVC3 is the solution)");
>, <Line: +            } else {
>, <Line: +                ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, nal);
>, <Line: +                ppsIdToPps.put(_pictureParameterSet.pic_parameter_set_id, _pictureParameterSet);
>, <Line: +            }
>, <Line: +        } catch (IOException e) {
>, <Line: +            throw new RuntimeException("That's surprising to get IOException when working on ByteArrayInputStream", e);
>, <Line: +    protected void handleSPS(ByteBuffer data) {
>, <Line: +        data.position(1);
>, <Line: +        try {
>, <Line: +            SeqParameterSet _seqParameterSet = SeqParameterSet.read(data);
>, <Line: +            currentSeqParameterSet = _seqParameterSet;
>, <Line: +            ByteBuffer oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
>, <Line: +            if (oldSpsSameId != null && !oldSpsSameId.equals(data)) {
>, <Line: +                throw new RuntimeException("OMG - I got two SPS with same ID but different settings!");
>, <Line: +            } else {
>, <Line: +                spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
>, <Line: +                spsIdToSps.put(_seqParameterSet.seq_parameter_set_id, _seqParameterSet);
>, <Line: +                spsForConfig.add(_seqParameterSet);
>, <Line: +            }
>, <Line: +        } catch (IOException e) {
>, <Line: +            throw new RuntimeException("That's surprising to get IOException when working on ByteArrayInputStream", e);
>, <Line: +    public void close() throws IOException {
>, <Line: +    }
>, <Line: +        public FirstVclNalDetector(ByteBuffer nal, int nal_ref_idc, int nal_unit_type) {
>, <Line: +            SliceHeader sh = new SliceHeader(nal, spsIdToSps, ppsIdToPps, nal_unit_type == 5);
>]
[<Line: -import org.mp4parser.muxer.tracks.CleanInputStream;
>, <Line: -import org.mp4parser.muxer.tracks.h264.H264NalUnitHeader;
>, <Line: -import org.mp4parser.muxer.tracks.h264.H264NalUnitTypes;
>, <Line: -import org.mp4parser.muxer.tracks.h264.SliceHeader;
>, <Line: -import org.mp4parser.muxer.tracks.h264.parsing.model.PictureParameterSet;
>, <Line: -import org.mp4parser.muxer.tracks.h264.parsing.model.SeqParameterSet;
>, <Line: -import org.mp4parser.streaming.input.AbstractStreamingTrack;
>, <Line: -import java.io.ByteArrayInputStream;
>, <Line: -import java.io.InputStream;
>, <Line: -import java.util.Arrays;
>, <Line: -public abstract class H264NalConsumingTrack extends AbstractStreamingTrack {
>, <Line: -    LinkedHashMap<Integer, byte[]> spsIdToSpsBytes = new LinkedHashMap<Integer, byte[]>();
>, <Line: -    LinkedHashMap<Integer, byte[]> ppsIdToPpsBytes = new LinkedHashMap<Integer, byte[]>();
>, <Line: -    List<byte[]> buffered = new ArrayList<byte[]>();
>, <Line: -    public static H264NalUnitHeader getNalUnitHeader(byte[] nal) {
>, <Line: -        int type = nal[0];
>, <Line: -    protected void consumeNal(byte[] nal) throws IOException {
>, <Line: -                    createSample(buffered, fvnd.sliceHeader);
>, <Line: -                    createSample(buffered, fvnd.sliceHeader);
>, <Line: -                    createSample(buffered, fvnd.sliceHeader);
>, <Line: -                    createSample(buffered, fvnd.sliceHeader);
>, <Line: -                    createSample(buffered, fvnd.sliceHeader);
>, <Line: -    protected void drainDecPictureBuffer(boolean all) throws IOException {
>, <Line: -                drainDecPictureBuffer(false);
>, <Line: -            StreamingSample first = decFrameBuffer.remove(0);
>, <Line: -            PictureOrderCountType0SampleExtension poct0se = first.getSampleExtension(PictureOrderCountType0SampleExtension.class);
>, <Line: -            int delay = 0;
>, <Line: -            for (StreamingSample streamingSample : decFrameBuffer) {
>, <Line: -                if (poct0se.getPoc() > streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
>, <Line: -                    delay++;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            for (StreamingSample streamingSample : decFrameBuffer2) {
>, <Line: -                if (poct0se.getPoc() < streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
>, <Line: -                    delay--;
>, <Line: -            decFrameBuffer2.add(first);
>, <Line: -            if (decFrameBuffer2.size() > max_dec_frame_buffering) {
>, <Line: -                decFrameBuffer2.remove(0).removeSampleExtension(PictureOrderCountType0SampleExtension.class);
>, <Line: -            }
>, <Line: -            first.addSampleExtension(CompositionTimeSampleExtension.create(delay * frametick));
>, <Line: -            //System.err.println("Adding sample");
>, <Line: -            sampleSink.acceptSample(first, this);
>, <Line: -    protected StreamingSample createSample(List<byte[]> buffered, SliceHeader sliceHeader) throws IOException {
>, <Line: -        LOG.finer("Create Sample");
>, <Line: -        configure();
>, <Line: -        if (timescale == 0 || frametick == 0) {
>, <Line: -            throw new IOException("Frame Rate needs to be configured either by hand or by SPS before samples can be created");
>, <Line: -        }
>, <Line: -        boolean idrPicFlag = false;
>, <Line: -        H264NalUnitHeader nu = null;
>, <Line: -        byte[] slice = null;
>, <Line: -        buffered_loop:
>, <Line: -        for (byte[] nal : buffered) {
>, <Line: -            H264NalUnitHeader _nu = getNalUnitHeader(nal);
>, <Line: -            switch (_nu.nal_unit_type) {
>, <Line: -                case H264NalUnitTypes.CODED_SLICE_IDR:
>, <Line: -                    idrPicFlag = true;
>, <Line: -                case H264NalUnitTypes.CODED_SLICE_NON_IDR:
>, <Line: -                case H264NalUnitTypes.CODED_SLICE_DATA_PART_A:
>, <Line: -                case H264NalUnitTypes.CODED_SLICE_DATA_PART_B:
>, <Line: -                case H264NalUnitTypes.CODED_SLICE_DATA_PART_C:
>, <Line: -                    nu = _nu;
>, <Line: -                    slice = nal;
>, <Line: -                    break buffered_loop;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        if (nu == null) {
>, <Line: -            LOG.warning("Sample without Slice");
>, <Line: -            return null;
>, <Line: -        }
>, <Line: -        assert slice != null;
>, <Line: -        sampleFlagsSampleExtension.setSampleIsNonSyncSample(!idrPicFlag);
>, <Line: -        StreamingSampleImpl ssi = new StreamingSampleImpl(buffered, frametick);
>, <Line: -        ssi.addSampleExtension(sampleFlagsSampleExtension);
>, <Line: -            ssi.addSampleExtension(new PictureOrderCountType0SampleExtension(
>, <Line: -                    null));
>, <Line: -            decFrameBuffer.add(ssi);
>, <Line: -            }
>, <Line: -                /*if (seiMessage != null && seiMessage.clock_timestamp_flag) {
>, <Line: -                    offset = seiMessage.n_frames - frameNrInGop;
>, <Line: -                } else if (seiMessage != null && seiMessage.removal_delay_flag) {
>, <Line: -                    offset = seiMessage.dpb_removal_delay / 2;
>, <Line: -                }
>, <Line: -                if (seiMessage == null) {
>, <Line: -                    LOG.warning("CTS timing in ctts box is most likely not OK");
>, <Line: -                }*/
>, <Line: -            throw new IOException("pic_order_cnt_type == 1 needs to be implemented");
>, <Line: -            sampleSink.acceptSample(ssi, this);
>, <Line: -        buffered.clear();
>, <Line: -        return ssi;
>, <Line: -        if (configured) {
>, <Line: -            return;
>, <Line: -        } else {
>, <Line: -            avcConfigurationBox.setSequenceParameterSets(new ArrayList<byte[]>(spsIdToSpsBytes.values()));
>, <Line: -            avcConfigurationBox.setPictureParameterSets(new ArrayList<byte[]>(ppsIdToPpsBytes.values()));
>, <Line: -    private void handlePPS(byte[] data) throws IOException {
>, <Line: -        InputStream is = new ByteArrayInputStream(data, 1, data.length - 1);
>, <Line: -        PictureParameterSet _pictureParameterSet = PictureParameterSet.read(is);
>, <Line: -        currentPictureParameterSet = _pictureParameterSet;
>, <Line: -        byte[] oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
>, <Line: -        if (oldPpsSameId != null && !Arrays.equals(oldPpsSameId, data)) {
>, <Line: -            throw new IOException("OMG - I got two SPS with same ID but different settings! (AVC3 is the solution)");
>, <Line: -        } else {
>, <Line: -            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, data);
>, <Line: -            ppsIdToPps.put(_pictureParameterSet.pic_parameter_set_id, _pictureParameterSet);
>, <Line: -    private void handleSPS(byte[] data) throws IOException {
>, <Line: -        InputStream spsInputStream = new CleanInputStream(new ByteArrayInputStream(data, 1, data.length - 1));
>, <Line: -        SeqParameterSet _seqParameterSet = SeqParameterSet.read(spsInputStream);
>, <Line: -        currentSeqParameterSet = _seqParameterSet;
>, <Line: -        byte[] oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
>, <Line: -        if (oldSpsSameId != null && !Arrays.equals(oldSpsSameId, data)) {
>, <Line: -            throw new IOException("OMG - I got two SPS with same ID but different settings!");
>, <Line: -        } else {
>, <Line: -            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
>, <Line: -            spsIdToSps.put(_seqParameterSet.seq_parameter_set_id, _seqParameterSet);
>, <Line: -            spsForConfig.add(_seqParameterSet);
>, <Line: -        public FirstVclNalDetector(byte[] nal, int nal_ref_idc, int nal_unit_type) {
>, <Line: -            InputStream bs = new CleanInputStream(new ByteArrayInputStream(nal));
>, <Line: -            SliceHeader sh = new SliceHeader(bs, spsIdToSps, ppsIdToPps, nal_unit_type == 5);
>]