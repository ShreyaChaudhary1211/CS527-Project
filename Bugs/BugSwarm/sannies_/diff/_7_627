[<Line: +package org.mp4parser.streaming.input.h264;
>, <Line: +import org.mp4parser.streaming.extensions.TrackIdTrackExtension;
>, <Line: +import java.io.BufferedInputStream;
>, <Line: +import java.io.ByteArrayOutputStream;
>, <Line: +import java.io.IOException;
>, <Line: +import java.io.InputStream;
>, <Line: +import java.nio.ByteBuffer;
>, <Line: +import java.util.Arrays;
>, <Line: +import java.util.concurrent.Callable;
>, <Line: +import java.util.logging.Level;
>, <Line: +import java.util.logging.Logger;
>, <Line: +/**
>, <Line: + * Reads H264 data from an Annex B InputStream.
>, <Line: + */
>, <Line: +public class H264AnnexBTrack extends H264NalConsumingTrack implements Callable<Void> {
>, <Line: +    private InputStream inputStream;
>, <Line: +    public H264AnnexBTrack(InputStream inputStream) throws IOException {
>, <Line: +        assert inputStream != null;
>, <Line: +        this.inputStream = new BufferedInputStream(inputStream);
>, <Line: +    }
>, <Line: +    public Void call() throws IOException, InterruptedException {
>, <Line: +        byte[] nal;
>, <Line: +        NalStreamTokenizer st = new NalStreamTokenizer(inputStream);
>, <Line: +        while ((nal = st.getNext()) != null) {
>, <Line: +            //System.err.println("NAL before consume");
>, <Line: +            consumeNal(ByteBuffer.wrap(nal));
>, <Line: +            //System.err.println("NAL after consume");
>, <Line: +        }
>, <Line: +        pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), true, true);
>, <Line: +        return null;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String toString() {
>, <Line: +        TrackIdTrackExtension trackIdTrackExtension = this.getTrackExtension(TrackIdTrackExtension.class);
>, <Line: +        if (trackIdTrackExtension != null) {
>, <Line: +            return "H264AnnexBTrack{trackId=" + trackIdTrackExtension.getTrackId() + "}";
>, <Line: +        } else {
>, <Line: +            return "H264AnnexBTrack{}";
>, <Line: +        }
>, <Line: +    }
>, <Line: +    public static class NalStreamTokenizer {
>, <Line: +        private static final Logger LOG = Logger.getLogger(NalStreamTokenizer.class.getName());
>, <Line: +        MyByteArrayOutputStream next = new MyByteArrayOutputStream();
>, <Line: +        int pattern = 0;
>, <Line: +        private InputStream inputStream;
>, <Line: +        public NalStreamTokenizer(InputStream inputStream) {
>, <Line: +            this.inputStream = inputStream;
>, <Line: +        }
>, <Line: +        public byte[] getNext() throws IOException {
>, <Line: +            //System.err.println("getNext() called");
>, <Line: +            if (LOG.isLoggable(Level.FINEST)) {
>, <Line: +                LOG.finest("getNext() called");
>, <Line: +            }
>, <Line: +            int c;
>, <Line: +            while ((c = inputStream.read()) != -1) {
>, <Line: +                if (!(pattern == 2 && c == 3)) {
>, <Line: +                    next.write(c);
>, <Line: +                    if (pattern == 0 && c == 0) {
>, <Line: +                        pattern = 1;
>, <Line: +                    } else if (pattern == 1 && c == 0) {
>, <Line: +                        pattern = 2;
>, <Line: +                    } else if (pattern == 2 && c == 0) {
>, <Line: +                        byte[] s = next.toByteArrayLess3();
>, <Line: +                        next.reset();
>, <Line: +                        if (s != null) {
>, <Line: +                            return s;
>, <Line: +                        }
>, <Line: +                    } else if (pattern == 2 && c == 1) {
>, <Line: +                        byte[] s = next.toByteArrayLess3();
>, <Line: +                        next.reset();
>, <Line: +                        pattern = 0;
>, <Line: +                        if (s != null) {
>, <Line: +                            return s;
>, <Line: +                        }
>, <Line: +                    } else if (pattern != 0) {
>, <Line: +                        pattern = 0;
>, <Line: +                    }
>, <Line: +                } else {
>, <Line: +                    pattern = 0;
>, <Line: +                }
>, <Line: +            }
>, <Line: +            byte[] s = next.toByteArray();
>, <Line: +            next.reset();
>, <Line: +            if (s.length > 0) {
>, <Line: +                return s;
>, <Line: +            } else {
>, <Line: +                return null;
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    static class MyByteArrayOutputStream extends ByteArrayOutputStream {
>, <Line: +        public byte[] toByteArrayLess3() {
>, <Line: +            if (count > 3) {
>, <Line: +                return Arrays.copyOf(buf, count - 3 > 0 ? count - 3 : 0);
>, <Line: +            } else {
>, <Line: +                return null;
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +}
>]
[]