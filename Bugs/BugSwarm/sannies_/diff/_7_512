[<Line: +package org.mp4parser.muxer.tracks.h264;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.CompositionTimeToSample;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.SampleDependencyTypeBox;
>, <Line: +import org.mp4parser.boxes.iso14496.part12.SampleDescriptionBox;
>, <Line: +import org.mp4parser.boxes.iso14496.part15.AvcConfigurationBox;
>, <Line: +import org.mp4parser.boxes.sampleentry.VisualSampleEntry;
>, <Line: +import org.mp4parser.muxer.DataSource;
>, <Line: +import org.mp4parser.muxer.FileDataSourceImpl;
>, <Line: +import org.mp4parser.muxer.Sample;
>, <Line: +import org.mp4parser.muxer.tracks.AbstractH26XTrack;
>, <Line: +import org.mp4parser.muxer.tracks.h264.parsing.model.PictureParameterSet;
>, <Line: +import org.mp4parser.muxer.tracks.h264.parsing.model.SeqParameterSet;
>, <Line: +import org.mp4parser.tools.Mp4Arrays;
>, <Line: +import org.mp4parser.tools.RangeStartMap;
>, <Line: +    Map<Integer, ByteBuffer> spsIdToSpsBytes = new HashMap<Integer, ByteBuffer>();
>, <Line: +    Map<Integer, ByteBuffer> ppsIdToPpsBytes = new HashMap<Integer, ByteBuffer>();
>, <Line: +    RangeStartMap<Integer, ByteBuffer> seqParameterRangeMap = new RangeStartMap<Integer, ByteBuffer>();
>, <Line: +    RangeStartMap<Integer, ByteBuffer> pictureParameterRangeMap = new RangeStartMap<Integer, ByteBuffer>();
>, <Line: +    int frameNrInGop = 0;
>, <Line: +    int[] pictureOrderCounts = new int[0];
>, <Line: +    int prevPicOrderCntLsb = 0;
>, <Line: +    int prevPicOrderCntMsb = 0;
>, <Line: +    long psize = 0;
>, <Line: +    long pcount = 0;
>, <Line: +    long bsize = 0;
>, <Line: +    long bcount = 0;
>, <Line: +    long isize = 0;
>, <Line: +    long icount = 0;
>, <Line: +    private List<Sample> samples;
>, <Line: +    public static void main(String[] args) throws IOException {
>, <Line: +        new H264TrackImpl(new FileDataSourceImpl("C:\\dev\\mp4parser\\tos.264"));
>, <Line: +    }
>, <Line: +    public static H264NalUnitHeader getNalUnitHeader(ByteBuffer nal) {
>, <Line: +        H264NalUnitHeader nalUnitHeader = new H264NalUnitHeader();
>, <Line: +        int type = nal.get(0);
>, <Line: +        nalUnitHeader.nal_ref_idc = (type >> 5) & 3;
>, <Line: +        nalUnitHeader.nal_unit_type = type & 0x1f;
>, <Line: +        return nalUnitHeader;
>, <Line: +    }
>, <Line: +/*        System.err.println("psize: " + psize + "(" + pcount + ")");
>, <Line: +        System.err.println("bsize: " + bsize + "(" + bcount + ")");
>, <Line: +        System.err.println("isize: " + isize + "(" + icount + ")");*/
>, <Line: +        avcConfigurationBox.setSequenceParameterSets(new ArrayList<ByteBuffer>(spsIdToSpsBytes.values()));
>, <Line: +        avcConfigurationBox.setPictureParameterSets(new ArrayList<ByteBuffer>(ppsIdToPpsBytes.values()));
>, <Line: +            int frame_num;
>, <Line: +            int pic_parameter_set_id;
>, <Line: +            boolean field_pic_flag;
>, <Line: +            boolean bottom_field_flag;
>, <Line: +            int nal_ref_idc;
>, <Line: +            int pic_order_cnt_type;
>, <Line: +            int delta_pic_order_cnt_bottom;
>, <Line: +            int pic_order_cnt_lsb;
>, <Line: +            int delta_pic_order_cnt_0;
>, <Line: +            int delta_pic_order_cnt_1;
>, <Line: +            boolean idrPicFlag;
>, <Line: +            int idr_pic_id;
>, <Line: +                        LOG.finest("Wrapping up cause of first vcl nal is found");
>, <Line: +                        LOG.finest("Wrapping up cause of SEI after vcl marks new sample");
>, <Line: +                        LOG.finest("Wrapping up cause of AU after vcl marks new sample");
>, <Line: +                        LOG.finest("Wrapping up cause of SPS after vcl marks new sample");
>, <Line: +                        LOG.finest("Wrapping up cause of PPS after vcl marks new sample");
>, <Line: +    long getSize(List<ByteBuffer> buffered) {
>, <Line: +        long i = 0;
>, <Line: +        for (ByteBuffer byteBuffer : buffered) {
>, <Line: +            i += byteBuffer.remaining();
>, <Line: +        }
>, <Line: +        return i;
>, <Line: +    }
>, <Line: +        ByteBuffer slice = null;
>, <Line: +                    slice = nal;
>, <Line: +        assert slice != null;
>, <Line: +        InputStream bs = cleanBuffer(new ByteBufferBackedInputStream(slice));
>, <Line: +        if ((sh.slice_type == SliceHeader.SliceType.I) || (sh.slice_type == SliceHeader.SliceType.SI)) {
>, <Line: +            isize += getSize(buffered);
>, <Line: +            icount++;
>, <Line: +        } else if ((sh.slice_type == SliceHeader.SliceType.P) || (sh.slice_type == SliceHeader.SliceType.SP)) {
>, <Line: +            psize += getSize(buffered);
>, <Line: +            pcount++;
>, <Line: +        } else if ((sh.slice_type == SliceHeader.SliceType.B)) {
>, <Line: +            bsize += getSize(buffered);
>, <Line: +            bcount++;
>, <Line: +            throw new RuntimeException("_sdjlfd");
>, <Line: +        if (nu.nal_ref_idc == 0) {
>, <Line: +            sampleDependency.setSampleIsDependedOn(2);
>, <Line: +        } else {
>, <Line: +            sampleDependency.setSampleIsDependedOn(1);
>, <Line: +        }
>, <Line: +        if ((sh.slice_type == SliceHeader.SliceType.I) || (sh.slice_type == SliceHeader.SliceType.SI)) {
>, <Line: +            int picOrderCntMsb;
>, <Line: +        ByteBuffer oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
>, <Line: +        data.rewind();
>, <Line: +        if (oldPpsSameId != null && !oldPpsSameId.equals(data)) {
>, <Line: +                pictureParameterRangeMap.put(samples.size(), data);
>, <Line: +            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, data);
>, <Line: +        data.rewind();
>, <Line: +        ByteBuffer oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
>, <Line: +        if (oldSpsSameId != null && !oldSpsSameId.equals(data)) {
>, <Line: +                seqParameterRangeMap.put(samples.size(), data);
>, <Line: +            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
>]
[<Line: -package com.googlecode.mp4parser.authoring.tracks.h264;
>, <Line: -import com.coremedia.iso.boxes.CompositionTimeToSample;
>, <Line: -import com.coremedia.iso.boxes.SampleDependencyTypeBox;
>, <Line: -import com.coremedia.iso.boxes.SampleDescriptionBox;
>, <Line: -import com.coremedia.iso.boxes.sampleentry.VisualSampleEntry;
>, <Line: -import com.googlecode.mp4parser.DataSource;
>, <Line: -import com.googlecode.mp4parser.authoring.Sample;
>, <Line: -import com.googlecode.mp4parser.authoring.tracks.AbstractH26XTrack;
>, <Line: -import com.googlecode.mp4parser.h264.model.PictureParameterSet;
>, <Line: -import com.googlecode.mp4parser.h264.model.SeqParameterSet;
>, <Line: -import com.googlecode.mp4parser.h264.read.CAVLCReader;
>, <Line: -import com.googlecode.mp4parser.util.Mp4Arrays;
>, <Line: -import com.googlecode.mp4parser.util.RangeStartMap;
>, <Line: -import com.mp4parser.iso14496.part15.AvcConfigurationBox;
>, <Line: -import java.io.ByteArrayInputStream;
>, <Line: -    Map<Integer, byte[]> spsIdToSpsBytes = new HashMap<Integer, byte[]>();
>, <Line: -    Map<Integer, byte[]> ppsIdToPpsBytes = new HashMap<Integer, byte[]>();
>, <Line: -    private List<Sample> samples;
>, <Line: -    RangeStartMap<Integer, byte[]> seqParameterRangeMap = new RangeStartMap<Integer, byte[]>();
>, <Line: -    RangeStartMap<Integer, byte[]> pictureParameterRangeMap = new RangeStartMap<Integer, byte[]>();
>, <Line: -    int frameNrInGop = 0;
>, <Line: -    int[] pictureOrderCounts = new int[0];
>, <Line: -        avcConfigurationBox.setSequenceParameterSets(new ArrayList<byte[]>(spsIdToSpsBytes.values()));
>, <Line: -        avcConfigurationBox.setPictureParameterSets(new ArrayList<byte[]>(ppsIdToPpsBytes.values()));
>, <Line: -            int frame_num;
>, <Line: -            int pic_parameter_set_id;
>, <Line: -            boolean field_pic_flag;
>, <Line: -            boolean bottom_field_flag;
>, <Line: -            int nal_ref_idc;
>, <Line: -            int pic_order_cnt_type;
>, <Line: -            int delta_pic_order_cnt_bottom;
>, <Line: -            int pic_order_cnt_lsb;
>, <Line: -            int delta_pic_order_cnt_0;
>, <Line: -            int delta_pic_order_cnt_1;
>, <Line: -            boolean idrPicFlag;
>, <Line: -            int idr_pic_id;
>, <Line: -                        LOG.finer("Wrapping up cause of first vcl nal is found");
>, <Line: -                        LOG.finer("Wrapping up cause of SEI after vcl marks new sample");
>, <Line: -                        LOG.finer("Wrapping up cause of AU after vcl marks new sample");
>, <Line: -                        LOG.finer("Wrapping up cause of SPS after vcl marks new sample");
>, <Line: -                        LOG.finer("Wrapping up cause of PPS after vcl marks new sample");
>, <Line: -    int prevPicOrderCntLsb = 0;
>, <Line: -    int prevPicOrderCntMsb = 0;
>, <Line: -        InputStream bs = cleanBuffer(new ByteBufferBackedInputStream(buffered.get(buffered.size() - 1)));
>, <Line: -        if (nu.nal_ref_idc== 0) {
>, <Line: -            sampleDependency.setSampleIsDependentOn(2);
>, <Line: -            sampleDependency.setSampleIsDependentOn(1);
>, <Line: -        if ((sh.slice_type == SliceHeader.SliceType.I) || (sh.slice_type == SliceHeader.SliceType.SI) ) {
>, <Line: -        int offset = 0;
>, <Line: -            int picOrderCntMsb = 0;
>, <Line: -    private int calcPoc(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
>, <Line: -        if (sh.sps.pic_order_cnt_type == 0) {
>, <Line: -            return calcPOC0(nu, sh);
>, <Line: -        } else if (sh.sps.pic_order_cnt_type == 1) {
>, <Line: -            return calcPOC1(absFrameNum, nu, sh);
>, <Line: -        } else {
>, <Line: -            return calcPOC2(absFrameNum, nu, sh);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    private int calcPOC2(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
>, <Line: -        if (nu.nal_ref_idc == 0)
>, <Line: -            return 2 * absFrameNum - 1;
>, <Line: -        else
>, <Line: -            return 2 * absFrameNum;
>, <Line: -    }
>, <Line: -    private int calcPOC1(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
>, <Line: -        if (sh.sps.num_ref_frames_in_pic_order_cnt_cycle == 0)
>, <Line: -            absFrameNum = 0;
>, <Line: -        if (nu.nal_ref_idc == 0 && absFrameNum > 0)
>, <Line: -            absFrameNum = absFrameNum - 1;
>, <Line: -        int expectedDeltaPerPicOrderCntCycle = 0;
>, <Line: -        for (int i = 0; i < sh.sps.num_ref_frames_in_pic_order_cnt_cycle; i++)
>, <Line: -            expectedDeltaPerPicOrderCntCycle += sh.sps.offsetForRefFrame[i];
>, <Line: -        int expectedPicOrderCnt;
>, <Line: -        if (absFrameNum > 0) {
>, <Line: -            int picOrderCntCycleCnt = (absFrameNum - 1) / sh.sps.num_ref_frames_in_pic_order_cnt_cycle;
>, <Line: -            int frameNumInPicOrderCntCycle = (absFrameNum - 1) % sh.sps.num_ref_frames_in_pic_order_cnt_cycle;
>, <Line: -            expectedPicOrderCnt = picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
>, <Line: -            for (int i = 0; i <= frameNumInPicOrderCntCycle; i++)
>, <Line: -                expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offsetForRefFrame[i];
>, <Line: -        } else {
>, <Line: -            expectedPicOrderCnt = 0;
>, <Line: -        }
>, <Line: -        if (nu.nal_ref_idc == 0)
>, <Line: -            expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offset_for_non_ref_pic;
>, <Line: -        return expectedPicOrderCnt + sh.delta_pic_order_cnt_0;
>, <Line: -    }
>, <Line: -    private int calcPOC0(H264NalUnitHeader nu, SliceHeader sh) {
>, <Line: -        int pocCntLsb = sh.pic_order_cnt_lsb;
>, <Line: -        int maxPicOrderCntLsb = 1 << (sh.sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
>, <Line: -        // TODO prevPicOrderCntMsb should be wrapped!!
>, <Line: -        int picOrderCntMsb;
>, <Line: -        if ((pocCntLsb < prevPicOrderCntLsb) && ((prevPicOrderCntLsb - pocCntLsb) >= (maxPicOrderCntLsb / 2)))
>, <Line: -            picOrderCntMsb = prevPicOrderCntMsb + maxPicOrderCntLsb;
>, <Line: -        else if ((pocCntLsb > prevPicOrderCntLsb) && ((pocCntLsb - prevPicOrderCntLsb) > (maxPicOrderCntLsb / 2)))
>, <Line: -            picOrderCntMsb = prevPicOrderCntMsb - maxPicOrderCntLsb;
>, <Line: -        else
>, <Line: -            picOrderCntMsb = prevPicOrderCntMsb;
>, <Line: -        if (nu.nal_ref_idc != 0) {
>, <Line: -            prevPicOrderCntMsb = picOrderCntMsb;
>, <Line: -            prevPicOrderCntLsb = pocCntLsb;
>, <Line: -        }
>, <Line: -        return picOrderCntMsb + pocCntLsb;
>, <Line: -    }
>, <Line: -        byte[] ppsBytes = toArray((ByteBuffer) data.rewind());
>, <Line: -        byte[] oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
>, <Line: -        if (oldPpsSameId != null && !Arrays.equals(oldPpsSameId, ppsBytes)) {
>, <Line: -                pictureParameterRangeMap.put(samples.size(), ppsBytes);
>, <Line: -            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, ppsBytes);
>, <Line: -        byte[] spsBytes = toArray((ByteBuffer) data.rewind());
>, <Line: -        byte[] oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
>, <Line: -        if (oldSpsSameId != null && !Arrays.equals(oldSpsSameId, spsBytes)) {
>, <Line: -                seqParameterRangeMap.put(samples.size(), spsBytes);
>, <Line: -            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, spsBytes);
>, <Line: -    public class SEIMessage {
>, <Line: -        int payloadType = 0;
>, <Line: -        int payloadSize = 0;
>, <Line: -        boolean removal_delay_flag;
>, <Line: -        int cpb_removal_delay;
>, <Line: -        int dpb_removal_delay;
>, <Line: -        boolean clock_timestamp_flag;
>, <Line: -        int pic_struct;
>, <Line: -        int ct_type;
>, <Line: -        int nuit_field_based_flag;
>, <Line: -        int counting_type;
>, <Line: -        int full_timestamp_flag;
>, <Line: -        int discontinuity_flag;
>, <Line: -        int cnt_dropped_flag;
>, <Line: -        int n_frames;
>, <Line: -        int seconds_value;
>, <Line: -        int minutes_value;
>, <Line: -        int hours_value;
>, <Line: -        int time_offset_length;
>, <Line: -        int time_offset;
>, <Line: -        SeqParameterSet sps;
>, <Line: -        public SEIMessage(InputStream is, SeqParameterSet sps) throws IOException {
>, <Line: -            this.sps = sps;
>, <Line: -            is.read();
>, <Line: -            int datasize = is.available();
>, <Line: -            int read = 0;
>, <Line: -            while (read < datasize) {
>, <Line: -                payloadType = 0;
>, <Line: -                payloadSize = 0;
>, <Line: -                int last_payload_type_bytes = is.read();
>, <Line: -                read++;
>, <Line: -                while (last_payload_type_bytes == 0xff) {
>, <Line: -                    payloadType += last_payload_type_bytes;
>, <Line: -                    last_payload_type_bytes = is.read();
>, <Line: -                    read++;
>, <Line: -                }
>, <Line: -                payloadType += last_payload_type_bytes;
>, <Line: -                int last_payload_size_bytes = is.read();
>, <Line: -                read++;
>, <Line: -                while (last_payload_size_bytes == 0xff) {
>, <Line: -                    payloadSize += last_payload_size_bytes;
>, <Line: -                    last_payload_size_bytes = is.read();
>, <Line: -                    read++;
>, <Line: -                }
>, <Line: -                payloadSize += last_payload_size_bytes;
>, <Line: -                if (datasize - read >= payloadSize) {
>, <Line: -                    if (payloadType == 1) { // pic_timing is what we are interested in!
>, <Line: -                        if (sps.vuiParams != null && (sps.vuiParams.nalHRDParams != null || sps.vuiParams.vclHRDParams != null || sps.vuiParams.pic_struct_present_flag)) {
>, <Line: -                            byte[] data = new byte[payloadSize];
>, <Line: -                            is.read(data);
>, <Line: -                            read += payloadSize;
>, <Line: -                            CAVLCReader reader = new CAVLCReader(new ByteArrayInputStream(data));
>, <Line: -                            if (sps.vuiParams.nalHRDParams != null || sps.vuiParams.vclHRDParams != null) {
>, <Line: -                                removal_delay_flag = true;
>, <Line: -                                cpb_removal_delay = reader.readU(sps.vuiParams.nalHRDParams.cpb_removal_delay_length_minus1 + 1, "SEI: cpb_removal_delay");
>, <Line: -                                dpb_removal_delay = reader.readU(sps.vuiParams.nalHRDParams.dpb_output_delay_length_minus1 + 1, "SEI: dpb_removal_delay");
>, <Line: -                            } else {
>, <Line: -                                removal_delay_flag = false;
>, <Line: -                            }
>, <Line: -                            if (sps.vuiParams.pic_struct_present_flag) {
>, <Line: -                                pic_struct = reader.readU(4, "SEI: pic_struct");
>, <Line: -                                int numClockTS;
>, <Line: -                                switch (pic_struct) {
>, <Line: -                                    case 0:
>, <Line: -                                    case 1:
>, <Line: -                                    case 2:
>, <Line: -                                    default:
>, <Line: -                                        numClockTS = 1;
>, <Line: -                                        break;
>, <Line: -                                    case 3:
>, <Line: -                                    case 4:
>, <Line: -                                    case 7:
>, <Line: -                                        numClockTS = 2;
>, <Line: -                                        break;
>, <Line: -                                    case 5:
>, <Line: -                                    case 6:
>, <Line: -                                    case 8:
>, <Line: -                                        numClockTS = 3;
>, <Line: -                                        break;
>, <Line: -                                }
>, <Line: -                                for (int i = 0; i < numClockTS; i++) {
>, <Line: -                                    clock_timestamp_flag = reader.readBool("pic_timing SEI: clock_timestamp_flag[" + i + "]");
>, <Line: -                                    if (clock_timestamp_flag) {
>, <Line: -                                        ct_type = reader.readU(2, "pic_timing SEI: ct_type");
>, <Line: -                                        nuit_field_based_flag = reader.readU(1, "pic_timing SEI: nuit_field_based_flag");
>, <Line: -                                        counting_type = reader.readU(5, "pic_timing SEI: counting_type");
>, <Line: -                                        full_timestamp_flag = reader.readU(1, "pic_timing SEI: full_timestamp_flag");
>, <Line: -                                        discontinuity_flag = reader.readU(1, "pic_timing SEI: discontinuity_flag");
>, <Line: -                                        cnt_dropped_flag = reader.readU(1, "pic_timing SEI: cnt_dropped_flag");
>, <Line: -                                        n_frames = reader.readU(8, "pic_timing SEI: n_frames");
>, <Line: -                                        if (full_timestamp_flag == 1) {
>, <Line: -                                            seconds_value = reader.readU(6, "pic_timing SEI: seconds_value");
>, <Line: -                                            minutes_value = reader.readU(6, "pic_timing SEI: minutes_value");
>, <Line: -                                            hours_value = reader.readU(5, "pic_timing SEI: hours_value");
>, <Line: -                                        } else {
>, <Line: -                                            if (reader.readBool("pic_timing SEI: seconds_flag")) {
>, <Line: -                                                seconds_value = reader.readU(6, "pic_timing SEI: seconds_value");
>, <Line: -                                                if (reader.readBool("pic_timing SEI: minutes_flag")) {
>, <Line: -                                                    minutes_value = reader.readU(6, "pic_timing SEI: minutes_value");
>, <Line: -                                                    if (reader.readBool("pic_timing SEI: hours_flag")) {
>, <Line: -                                                        hours_value = reader.readU(5, "pic_timing SEI: hours_value");
>, <Line: -                                                    }
>, <Line: -                                                }
>, <Line: -                                            }
>, <Line: -                                        }
>, <Line: -                                        if (true) {
>, <Line: -                                            if (sps.vuiParams.nalHRDParams != null) {
>, <Line: -                                                time_offset_length = sps.vuiParams.nalHRDParams.time_offset_length;
>, <Line: -                                            } else if (sps.vuiParams.vclHRDParams != null) {
>, <Line: -                                                time_offset_length = sps.vuiParams.vclHRDParams.time_offset_length;
>, <Line: -                                            } else {
>, <Line: -                                                time_offset_length = 24;
>, <Line: -                                            }
>, <Line: -                                            time_offset = reader.readU(24, "pic_timing SEI: time_offset");
>, <Line: -                                        }
>, <Line: -                                    }
>, <Line: -                                }
>, <Line: -                            }
>, <Line: -                        } else {
>, <Line: -                            for (int i = 0; i < payloadSize; i++) {
>, <Line: -                                is.read();
>, <Line: -                                read++;
>, <Line: -                            }
>, <Line: -                        }
>, <Line: -                    } else {
>, <Line: -                        for (int i = 0; i < payloadSize; i++) {
>, <Line: -                            is.read();
>, <Line: -                            read++;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                } else {
>, <Line: -                    read = datasize;
>, <Line: -                }
>, <Line: -                LOG.fine(this.toString());
>, <Line: -            }
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public String toString() {
>, <Line: -            String out = "SEIMessage{" +
>, <Line: -                    "payloadType=" + payloadType +
>, <Line: -                    ", payloadSize=" + payloadSize;
>, <Line: -            if (payloadType == 1) {
>, <Line: -                if (sps.vuiParams.nalHRDParams != null || sps.vuiParams.vclHRDParams != null) {
>, <Line: -                    out += ", cpb_removal_delay=" + cpb_removal_delay +
>, <Line: -                            ", dpb_removal_delay=" + dpb_removal_delay;
>, <Line: -                }
>, <Line: -                if (sps.vuiParams.pic_struct_present_flag) {
>, <Line: -                    out += ", pic_struct=" + pic_struct;
>, <Line: -                    if (clock_timestamp_flag) {
>, <Line: -                        out += ", ct_type=" + ct_type +
>, <Line: -                                ", nuit_field_based_flag=" + nuit_field_based_flag +
>, <Line: -                                ", counting_type=" + counting_type +
>, <Line: -                                ", full_timestamp_flag=" + full_timestamp_flag +
>, <Line: -                                ", discontinuity_flag=" + discontinuity_flag +
>, <Line: -                                ", cnt_dropped_flag=" + cnt_dropped_flag +
>, <Line: -                                ", n_frames=" + n_frames +
>, <Line: -                                ", seconds_value=" + seconds_value +
>, <Line: -                                ", minutes_value=" + minutes_value +
>, <Line: -                                ", hours_value=" + hours_value +
>, <Line: -                                ", time_offset_length=" + time_offset_length +
>, <Line: -                                ", time_offset=" + time_offset;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            out += '}';
>, <Line: -            return out;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    public static H264NalUnitHeader getNalUnitHeader(ByteBuffer nal) {
>, <Line: -        H264NalUnitHeader nalUnitHeader = new H264NalUnitHeader();
>, <Line: -        int type = nal.get(0);
>, <Line: -        nalUnitHeader.nal_ref_idc = (type >> 5) & 3;
>, <Line: -        nalUnitHeader.nal_unit_type = type & 0x1f;
>, <Line: -        return nalUnitHeader;
>, <Line: -    }
>]