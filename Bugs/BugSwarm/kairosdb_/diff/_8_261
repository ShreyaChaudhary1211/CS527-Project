[<Line: +		'lodash',
>, <Line: +	],
>, <Line: +	function (_) {
>, <Line: +		'use strict';
>, <Line: +		function InfluxSeries(options) {
>, <Line: +			this.seriesList = options.seriesList;
>, <Line: +			this.alias = options.alias;
>, <Line: +			this.groupByField = options.groupByField;
>, <Line: +			this.annotation = options.annotation;
>, <Line: +		}
>, <Line: +		var p = InfluxSeries.prototype;
>, <Line: +		p.getTimeSeries = function () {
>, <Line: +			var output = [];
>, <Line: +			var self = this;
>, <Line: +			var i;
>, <Line: +			_.each(self.seriesList, function (series) {
>, <Line: +				var seriesName;
>, <Line: +				var timeCol = series.columns.indexOf('time');
>, <Line: +				var valueCol = 1;
>, <Line: +				var groupByCol = -1;
>, <Line: +				if (self.groupByField) {
>, <Line: +					groupByCol = series.columns.indexOf(self.groupByField);
>, <Line: +				}
>, <Line: +				// find value column
>, <Line: +				_.each(series.columns, function (column, index) {
>, <Line: +					if (column !== 'time' && column !== 'sequence_number' && column !== self.groupByField) {
>, <Line: +						valueCol = index;
>, <Line: +					}
>, <Line: +				});
>, <Line: +				var groups = {};
>, <Line: +				if (self.groupByField) {
>, <Line: +					groups = _.groupBy(series.points, function (point) {
>, <Line: +						return point[groupByCol];
>, <Line: +					});
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					groups[series.columns[valueCol]] = series.points;
>, <Line: +				}
>, <Line: +				_.each(groups, function (groupPoints, key) {
>, <Line: +					var datapoints = [];
>, <Line: +					for (i = 0; i < groupPoints.length; i++) {
>, <Line: +						var metricValue = isNaN(groupPoints[i][valueCol]) ? null : groupPoints[i][valueCol];
>, <Line: +						datapoints[i] = [metricValue, groupPoints[i][timeCol]];
>, <Line: +					}
>, <Line: +					seriesName = series.name + '.' + key;
>, <Line: +					if (self.alias) {
>, <Line: +						seriesName = self.createNameForSeries(series.name, key);
>, <Line: +					}
>, <Line: +					output.push({target: seriesName, datapoints: datapoints});
>, <Line: +				});
>, <Line: +			});
>, <Line: +			return output;
>, <Line: +		};
>, <Line: +		p.getAnnotations = function () {
>, <Line: +			var list = [];
>, <Line: +			var self = this;
>, <Line: +			_.each(this.seriesList, function (series) {
>, <Line: +				var titleCol = null;
>, <Line: +				var timeCol = null;
>, <Line: +				var tagsCol = null;
>, <Line: +				var textCol = null;
>, <Line: +				_.each(series.columns, function (column, index) {
>, <Line: +					if (column === 'time') {
>, <Line: +						timeCol = index;
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					if (column === 'sequence_number') {
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					if (!titleCol) {
>, <Line: +						titleCol = index;
>, <Line: +					}
>, <Line: +					if (column === self.annotation.titleColumn) {
>, <Line: +						titleCol = index;
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					if (column === self.annotation.tagsColumn) {
>, <Line: +						tagsCol = index;
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					if (column === self.annotation.textColumn) {
>, <Line: +						textCol = index;
>, <Line: +						return;
>, <Line: +					}
>, <Line: +				});
>, <Line: +				_.each(series.points, function (point) {
>, <Line: +					var data = {
>, <Line: +						annotation: self.annotation,
>, <Line: +						time: point[timeCol],
>, <Line: +						title: point[titleCol],
>, <Line: +						tags: point[tagsCol],
>, <Line: +						text: point[textCol]
>, <Line: +					};
>, <Line: +					if (tagsCol) {
>, <Line: +						data.tags = point[tagsCol];
>, <Line: +					}
>, <Line: +					list.push(data);
>, <Line: +				});
>, <Line: +			});
>, <Line: +			return list;
>, <Line: +		};
>, <Line: +		p.createNameForSeries = function (seriesName, groupByColValue) {
>, <Line: +			var regex = /\$(\w+)/g;
>, <Line: +			var segments = seriesName.split('.');
>, <Line: +			return this.alias.replace(regex, function (match, group) {
>, <Line: +				if (group === 's') {
>, <Line: +					return seriesName;
>, <Line: +				}
>, <Line: +				else if (group === 'g') {
>, <Line: +					return groupByColValue;
>, <Line: +				}
>, <Line: +				var index = parseInt(group);
>, <Line: +				if (_.isNumber(index) && index < segments.length) {
>, <Line: +					return segments[index];
>, <Line: +				}
>, <Line: +				return match;
>, <Line: +			});
>, <Line: +		};
>, <Line: +		return InfluxSeries;
>, <Line: +	});
>]
[<Line: -  'lodash',
>, <Line: -],
>, <Line: -function (_) {
>, <Line: -  'use strict';
>, <Line: -  function InfluxSeries(options) {
>, <Line: -    this.seriesList = options.seriesList;
>, <Line: -    this.alias = options.alias;
>, <Line: -    this.groupByField = options.groupByField;
>, <Line: -    this.annotation = options.annotation;
>, <Line: -  }
>, <Line: -  var p = InfluxSeries.prototype;
>, <Line: -  p.getTimeSeries = function() {
>, <Line: -    var output = [];
>, <Line: -    var self = this;
>, <Line: -    var i;
>, <Line: -    _.each(self.seriesList, function(series) {
>, <Line: -      var seriesName;
>, <Line: -      var timeCol = series.columns.indexOf('time');
>, <Line: -      var valueCol = 1;
>, <Line: -      var groupByCol = -1;
>, <Line: -      if (self.groupByField) {
>, <Line: -        groupByCol = series.columns.indexOf(self.groupByField);
>, <Line: -      }
>, <Line: -      // find value column
>, <Line: -      _.each(series.columns, function(column, index) {
>, <Line: -        if (column !== 'time' && column !== 'sequence_number' && column !== self.groupByField) {
>, <Line: -          valueCol = index;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      var groups = {};
>, <Line: -      if (self.groupByField) {
>, <Line: -        groups = _.groupBy(series.points, function (point) {
>, <Line: -          return point[groupByCol];
>, <Line: -        });
>, <Line: -      }
>, <Line: -      else {
>, <Line: -        groups[series.columns[valueCol]] = series.points;
>, <Line: -      }
>, <Line: -      _.each(groups, function(groupPoints, key) {
>, <Line: -        var datapoints = [];
>, <Line: -        for (i = 0; i < groupPoints.length; i++) {
>, <Line: -          var metricValue = isNaN(groupPoints[i][valueCol]) ? null : groupPoints[i][valueCol];
>, <Line: -          datapoints[i] = [metricValue, groupPoints[i][timeCol]];
>, <Line: -        }
>, <Line: -        seriesName = series.name + '.' + key;
>, <Line: -        if (self.alias) {
>, <Line: -          seriesName = self.createNameForSeries(series.name, key);
>, <Line: -        }
>, <Line: -        output.push({ target: seriesName, datapoints: datapoints });
>, <Line: -      });
>, <Line: -    });
>, <Line: -    return output;
>, <Line: -  };
>, <Line: -  p.getAnnotations = function () {
>, <Line: -    var list = [];
>, <Line: -    var self = this;
>, <Line: -    _.each(this.seriesList, function (series) {
>, <Line: -      var titleCol = null;
>, <Line: -      var timeCol = null;
>, <Line: -      var tagsCol = null;
>, <Line: -      var textCol = null;
>, <Line: -      _.each(series.columns, function(column, index) {
>, <Line: -        if (column === 'time') { timeCol = index; return; }
>, <Line: -        if (column === 'sequence_number') { return; }
>, <Line: -        if (!titleCol) { titleCol = index; }
>, <Line: -        if (column === self.annotation.titleColumn) { titleCol = index; return; }
>, <Line: -        if (column === self.annotation.tagsColumn) { tagsCol = index; return; }
>, <Line: -        if (column === self.annotation.textColumn) { textCol = index; return; }
>, <Line: -      });
>, <Line: -      _.each(series.points, function (point) {
>, <Line: -        var data = {
>, <Line: -          annotation: self.annotation,
>, <Line: -          time: point[timeCol],
>, <Line: -          title: point[titleCol],
>, <Line: -          tags: point[tagsCol],
>, <Line: -          text: point[textCol]
>, <Line: -        };
>, <Line: -        if (tagsCol) {
>, <Line: -          data.tags = point[tagsCol];
>, <Line: -        }
>, <Line: -        list.push(data);
>, <Line: -      });
>, <Line: -    });
>, <Line: -    return list;
>, <Line: -  };
>, <Line: -  p.createNameForSeries = function(seriesName, groupByColValue) {
>, <Line: -    var regex = /\$(\w+)/g;
>, <Line: -    var segments = seriesName.split('.');
>, <Line: -    return this.alias.replace(regex, function(match, group) {
>, <Line: -      if (group === 's') {
>, <Line: -        return seriesName;
>, <Line: -      }
>, <Line: -      else if (group === 'g') {
>, <Line: -        return groupByColValue;
>, <Line: -      }
>, <Line: -      var index = parseInt(group);
>, <Line: -      if (_.isNumber(index) && index < segments.length) {
>, <Line: -        return segments[index];
>, <Line: -      }
>, <Line: -      return match;
>, <Line: -    });
>, <Line: -  };
>, <Line: -  return InfluxSeries;
>, <Line: -});
>]