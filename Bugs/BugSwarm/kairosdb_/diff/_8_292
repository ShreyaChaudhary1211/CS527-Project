[<Line: +(function (window, angular, undefined) {
>, <Line: +	'use strict';
>, <Line: +	var $sanitizeMinErr = angular.$$minErr('$sanitize');
>, <Line: +	/**
>, <Line: +	 * @ngdoc module
>, <Line: +	 * @name ngSanitize
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * # ngSanitize
>, <Line: +	 *
>, <Line: +	 * The `ngSanitize` module provides functionality to sanitize HTML.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * <div doc-module-components="ngSanitize"></div>
>, <Line: +	 *
>, <Line: +	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
>, <Line: +	 */
>, <Line: +	/*
>, <Line: +	 * HTML Parser By Misko Hevery (misko@hevery.com)
>, <Line: +	 * based on:  HTML Parser By John Resig (ejohn.org)
>, <Line: +	 * Original code by Erik Arvidsson, Mozilla Public License
>, <Line: +	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
>, <Line: +	 *
>, <Line: +	 * // Use like so:
>, <Line: +	 * htmlParser(htmlString, {
>, <Line: +	 *     start: function(tag, attrs, unary) {},
>, <Line: +	 *     end: function(tag) {},
>, <Line: +	 *     chars: function(text) {},
>, <Line: +	 *     comment: function(text) {}
>, <Line: +	 * });
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $sanitize
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
>, <Line: +	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
>, <Line: +	 *   it into the returned string, however, since our parser is more strict than a typical browser
>, <Line: +	 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
>, <Line: +	 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
>, <Line: +	 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
>, <Line: +	 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
>, <Line: +	 *
>, <Line: +	 * @param {string} html HTML input.
>, <Line: +	 * @returns {string} Sanitized HTML.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="sanitizeExample" deps="angular-sanitize.js">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('sanitizeExample', ['ngSanitize'])
>, <Line: +	 .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
>, <Line: +	 <table>
>, <Line: +	 <tr>
>, <Line: +	 <td>Directive</td>
>, <Line: +	 <td>How</td>
>, <Line: +	 <td>Source</td>
>, <Line: +	 <td>Rendered</td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="bind-html-with-sanitize">
>, <Line: +	 <td>ng-bind-html</td>
>, <Line: +	 <td>Automatically uses $sanitize</td>
>, <Line: +	 <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
>, <Line: +	 <td><div ng-bind-html="snippet"></div></td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="bind-html-with-trust">
>, <Line: +	 <td>ng-bind-html</td>
>, <Line: +	 <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
>, <Line: +	 <td>
>, <Line: +	 <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
>, <Line: +	 &lt;/div&gt;</pre>
>, <Line: +	 </td>
>, <Line: +	 <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="bind-default">
>, <Line: +	 <td>ng-bind</td>
>, <Line: +	 <td>Automatically escapes</td>
>, <Line: +	 <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
>, <Line: +	 <td><div ng-bind="snippet"></div></td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should sanitize the html snippet by default', function() {
>, <Line: +	 it('should inline raw snippet if bound to a trusted value', function() {
>, <Line: +	 it('should escape snippet without any filter', function() {
>, <Line: +	 it('should update', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function $SanitizeProvider() {
>, <Line: +		this.$get = ['$$sanitizeUri', function ($$sanitizeUri) {
>, <Line: +			return function (html) {
>, <Line: +				var buf = [];
>, <Line: +				htmlParser(html, htmlSanitizeWriter(buf, function (uri, isImage) {
>, <Line: +					return !/^unsafe/.test($$sanitizeUri(uri, isImage));
>, <Line: +				}));
>, <Line: +				return buf.join('');
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	function sanitizeText(chars) {
>, <Line: +		var buf = [];
>, <Line: +		var writer = htmlSanitizeWriter(buf, angular.noop);
>, <Line: +		writer.chars(chars);
>, <Line: +		return buf.join('');
>, <Line: +	}
>, <Line: +	var START_TAG_REGEXP =
>, <Line: +			/^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
>, <Line: +		END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
>, <Line: +		ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
>, <Line: +		BEGIN_TAG_REGEXP = /^</,
>, <Line: +		BEGING_END_TAGE_REGEXP = /^<\//,
>, <Line: +		COMMENT_REGEXP = /<!--(.*?)-->/g,
>, <Line: +		DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
>, <Line: +		CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
>, <Line: +		SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
>, <Line: +	// Match everything outside of normal chars and " (quote character)
>, <Line: +		NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
>, <Line: +	var voidElements = makeMap("area,br,col,hr,img,wbr");
>, <Line: +	var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
>, <Line: +		optionalEndTagInlineElements = makeMap("rp,rt"),
>, <Line: +		optionalEndTagElements = angular.extend({},
>, <Line: +			optionalEndTagInlineElements,
>, <Line: +			optionalEndTagBlockElements);
>, <Line: +	var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
>, <Line: +		"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
>, <Line: +		"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
>, <Line: +	var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
>, <Line: +		"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
>, <Line: +		"samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
>, <Line: +	var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," +
>, <Line: +		"desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," +
>, <Line: +		"line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," +
>, <Line: +		"stop,svg,switch,text,title,tspan,use");
>, <Line: +	var specialElements = makeMap("script,style");
>, <Line: +	var validElements = angular.extend({},
>, <Line: +		voidElements,
>, <Line: +		blockElements,
>, <Line: +		inlineElements,
>, <Line: +		optionalEndTagElements,
>, <Line: +		svgElements);
>, <Line: +	var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
>, <Line: +	var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
>, <Line: +		'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
>, <Line: +		'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
>, <Line: +		'scope,scrolling,shape,size,span,start,summary,target,title,type,' +
>, <Line: +		'valign,value,vspace,width');
>, <Line: +	var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
>, <Line: +		'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +
>, <Line: +		'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +
>, <Line: +		'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +
>, <Line: +		'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +
>, <Line: +		'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +
>, <Line: +		'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +
>, <Line: +		'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +
>, <Line: +		'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +
>, <Line: +		'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +
>, <Line: +		'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +
>, <Line: +		'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +
>, <Line: +		'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +
>, <Line: +		'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +
>, <Line: +		'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +
>, <Line: +		'zoomAndPan');
>, <Line: +	var validAttrs = angular.extend({},
>, <Line: +		uriAttrs,
>, <Line: +		svgAttrs,
>, <Line: +		htmlAttrs);
>, <Line: +	function makeMap(str) {
>, <Line: +		var obj = {}, items = str.split(','), i;
>, <Line: +		for (i = 0; i < items.length; i++) obj[items[i]] = true;
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @example
>, <Line: +	 * htmlParser(htmlString, {
>, <Line: +	 *
>, <Line: +	 * @param {string} html string
>, <Line: +	 * @param {object} handler
>, <Line: +	 */
>, <Line: +	function htmlParser(html, handler) {
>, <Line: +		if (typeof html !== 'string') {
>, <Line: +			if (html === null || typeof html === 'undefined') {
>, <Line: +				html = '';
>, <Line: +			} else {
>, <Line: +				html = '' + html;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		var index, chars, match, stack = [], last = html, text;
>, <Line: +		stack.last = function () {
>, <Line: +			return stack[stack.length - 1];
>, <Line: +		};
>, <Line: +		while (html) {
>, <Line: +			text = '';
>, <Line: +			chars = true;
>, <Line: +			// Make sure we're not in a script or style element
>, <Line: +			if (!stack.last() || !specialElements[stack.last()]) {
>, <Line: +				// Comment
>, <Line: +				if (html.indexOf("<!--") === 0) {
>, <Line: +					// comments containing -- are not allowed unless they terminate the comment
>, <Line: +					index = html.indexOf("--", 4);
>, <Line: +					if (index >= 0 && html.lastIndexOf("-->", index) === index) {
>, <Line: +						if (handler.comment) handler.comment(html.substring(4, index));
>, <Line: +						html = html.substring(index + 3);
>, <Line: +						chars = false;
>, <Line: +					}
>, <Line: +					// DOCTYPE
>, <Line: +				} else if (DOCTYPE_REGEXP.test(html)) {
>, <Line: +					match = html.match(DOCTYPE_REGEXP);
>, <Line: +					if (match) {
>, <Line: +						html = html.replace(match[0], '');
>, <Line: +						chars = false;
>, <Line: +					}
>, <Line: +					// end tag
>, <Line: +				} else if (BEGING_END_TAGE_REGEXP.test(html)) {
>, <Line: +					match = html.match(END_TAG_REGEXP);
>, <Line: +					if (match) {
>, <Line: +						html = html.substring(match[0].length);
>, <Line: +						match[0].replace(END_TAG_REGEXP, parseEndTag);
>, <Line: +						chars = false;
>, <Line: +					}
>, <Line: +					// start tag
>, <Line: +				} else if (BEGIN_TAG_REGEXP.test(html)) {
>, <Line: +					match = html.match(START_TAG_REGEXP);
>, <Line: +					if (match) {
>, <Line: +						// We only have a valid start-tag if there is a '>'.
>, <Line: +						if (match[4]) {
>, <Line: +							html = html.substring(match[0].length);
>, <Line: +							match[0].replace(START_TAG_REGEXP, parseStartTag);
>, <Line: +						}
>, <Line: +						chars = false;
>, <Line: +					} else {
>, <Line: +						// no ending tag found --- this piece should be encoded as an entity.
>, <Line: +						text += '<';
>, <Line: +						html = html.substring(1);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (chars) {
>, <Line: +					index = html.indexOf("<");
>, <Line: +					text += index < 0 ? html : html.substring(0, index);
>, <Line: +					html = index < 0 ? "" : html.substring(index);
>, <Line: +					if (handler.chars) handler.chars(decodeEntities(text));
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
>, <Line: +					function (all, text) {
>, <Line: +						text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
>, <Line: +						if (handler.chars) handler.chars(decodeEntities(text));
>, <Line: +						return "";
>, <Line: +					});
>, <Line: +				parseEndTag("", stack.last());
>, <Line: +			}
>, <Line: +			if (html == last) {
>, <Line: +				throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
>, <Line: +					"of html: {0}", html);
>, <Line: +			}
>, <Line: +			last = html;
>, <Line: +		}
>, <Line: +		// Clean up any remaining tags
>, <Line: +		parseEndTag();
>, <Line: +		function parseStartTag(tag, tagName, rest, unary) {
>, <Line: +			tagName = angular.lowercase(tagName);
>, <Line: +			if (blockElements[tagName]) {
>, <Line: +				while (stack.last() && inlineElements[stack.last()]) {
>, <Line: +					parseEndTag("", stack.last());
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (optionalEndTagElements[tagName] && stack.last() == tagName) {
>, <Line: +				parseEndTag("", tagName);
>, <Line: +			}
>, <Line: +			unary = voidElements[tagName] || !!unary;
>, <Line: +			if (!unary)
>, <Line: +				stack.push(tagName);
>, <Line: +			var attrs = {};
>, <Line: +			rest.replace(ATTR_REGEXP,
>, <Line: +				function (match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
>, <Line: +					var value = doubleQuotedValue
>, <Line: +						|| singleQuotedValue
>, <Line: +						|| unquotedValue
>, <Line: +						|| '';
>, <Line: +					attrs[name] = decodeEntities(value);
>, <Line: +				});
>, <Line: +			if (handler.start) handler.start(tagName, attrs, unary);
>, <Line: +		}
>, <Line: +		function parseEndTag(tag, tagName) {
>, <Line: +			var pos = 0, i;
>, <Line: +			tagName = angular.lowercase(tagName);
>, <Line: +			if (tagName)
>, <Line: +			// Find the closest opened tag of the same type
>, <Line: +				for (pos = stack.length - 1; pos >= 0; pos--)
>, <Line: +					if (stack[pos] == tagName)
>, <Line: +						break;
>, <Line: +			if (pos >= 0) {
>, <Line: +				// Close all the open elements, up the stack
>, <Line: +				for (i = stack.length - 1; i >= pos; i--)
>, <Line: +					if (handler.end) handler.end(stack[i]);
>, <Line: +				// Remove the open elements from the stack
>, <Line: +				stack.length = pos;
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	var hiddenPre = document.createElement("pre");
>, <Line: +	var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
>, <Line: +	/**
>, <Line: +	 * decodes all entities into regular string
>, <Line: +	 * @param value
>, <Line: +	 * @returns {string} A string with decoded entities.
>, <Line: +	 */
>, <Line: +	function decodeEntities(value) {
>, <Line: +		if (!value) {
>, <Line: +			return '';
>, <Line: +		}
>, <Line: +		// Note: IE8 does not preserve spaces at the start/end of innerHTML
>, <Line: +		// so we must capture them and reattach them afterward
>, <Line: +		var parts = spaceRe.exec(value);
>, <Line: +		var spaceBefore = parts[1];
>, <Line: +		var spaceAfter = parts[3];
>, <Line: +		var content = parts[2];
>, <Line: +		if (content) {
>, <Line: +			hiddenPre.innerHTML = content.replace(/</g, "&lt;");
>, <Line: +			// innerText depends on styling as it doesn't display hidden elements.
>, <Line: +			// Therefore, it's better to use textContent not to cause unnecessary
>, <Line: +			// reflows. However, IE<9 don't support textContent so the innerText
>, <Line: +			// fallback is necessary.
>, <Line: +			content = 'textContent' in hiddenPre ?
>, <Line: +				hiddenPre.textContent : hiddenPre.innerText;
>, <Line: +		}
>, <Line: +		return spaceBefore + content + spaceAfter;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Escapes all potentially dangerous characters, so that the
>, <Line: +	 * resulting string can be safely inserted into attribute or
>, <Line: +	 * element text.
>, <Line: +	 * @param value
>, <Line: +	 * @returns {string} escaped text
>, <Line: +	 */
>, <Line: +	function encodeEntities(value) {
>, <Line: +		return value.
>, <Line: +			replace(/&/g, '&amp;').
>, <Line: +			replace(SURROGATE_PAIR_REGEXP, function (value) {
>, <Line: +				var hi = value.charCodeAt(0);
>, <Line: +				var low = value.charCodeAt(1);
>, <Line: +				return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
>, <Line: +			}).
>, <Line: +			replace(NON_ALPHANUMERIC_REGEXP, function (value) {
>, <Line: +				return '&#' + value.charCodeAt(0) + ';';
>, <Line: +			}).
>, <Line: +			replace(/</g, '&lt;').
>, <Line: +			replace(/>/g, '&gt;');
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * create an HTML/XML writer which writes to buffer
>, <Line: +	 * @param {Array} buf use buf.jain('') to get out sanitized html string
>, <Line: +	 * @returns {object} in the form of {
>, <Line: +	 */
>, <Line: +	function htmlSanitizeWriter(buf, uriValidator) {
>, <Line: +		var ignore = false;
>, <Line: +		var out = angular.bind(buf, buf.push);
>, <Line: +		return {
>, <Line: +			start: function (tag, attrs, unary) {
>, <Line: +				tag = angular.lowercase(tag);
>, <Line: +				if (!ignore && specialElements[tag]) {
>, <Line: +					ignore = tag;
>, <Line: +				}
>, <Line: +				if (!ignore && validElements[tag] === true) {
>, <Line: +					out('<');
>, <Line: +					out(tag);
>, <Line: +					angular.forEach(attrs, function (value, key) {
>, <Line: +						var lkey = angular.lowercase(key);
>, <Line: +						var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
>, <Line: +						if (validAttrs[lkey] === true &&
>, <Line: +							(uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
>, <Line: +							out(' ');
>, <Line: +							out(key);
>, <Line: +							out('="');
>, <Line: +							out(encodeEntities(value));
>, <Line: +							out('"');
>, <Line: +						}
>, <Line: +					});
>, <Line: +					out(unary ? '/>' : '>');
>, <Line: +				}
>, <Line: +			},
>, <Line: +			end: function (tag) {
>, <Line: +				tag = angular.lowercase(tag);
>, <Line: +				if (!ignore && validElements[tag] === true) {
>, <Line: +					out('</');
>, <Line: +					out(tag);
>, <Line: +					out('>');
>, <Line: +				}
>, <Line: +				if (tag == ignore) {
>, <Line: +					ignore = false;
>, <Line: +				}
>, <Line: +			},
>, <Line: +			chars: function (chars) {
>, <Line: +				if (!ignore) {
>, <Line: +					out(encodeEntities(chars));
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>, <Line: +	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
>, <Line: +	/* global sanitizeText: false */
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name linky
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
>, <Line: +	 * plain email address links.
>, <Line: +	 *
>, <Line: +	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
>, <Line: +	 *
>, <Line: +	 * @param {string} text Input text.
>, <Line: +	 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
>, <Line: +	 * @returns {string} Html-linkified text.
>, <Line: +	 *
>, <Line: +	 * @usage
>, <Line: +	 <span ng-bind-html="linky_expression | linky"></span>
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="linkyExample" deps="angular-sanitize.js">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('linkyExample', ['ngSanitize'])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
>, <Line: +	 <table>
>, <Line: +	 <tr>
>, <Line: +	 <td>Filter</td>
>, <Line: +	 <td>Source</td>
>, <Line: +	 <td>Rendered</td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="linky-filter">
>, <Line: +	 <td>linky filter</td>
>, <Line: +	 <td>
>, <Line: +	 <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
>, <Line: +	 </td>
>, <Line: +	 <td>
>, <Line: +	 <div ng-bind-html="snippet | linky"></div>
>, <Line: +	 </td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="linky-target">
>, <Line: +	 <td>linky target</td>
>, <Line: +	 <td>
>, <Line: +	 <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
>, <Line: +	 </td>
>, <Line: +	 <td>
>, <Line: +	 <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
>, <Line: +	 </td>
>, <Line: +	 </tr>
>, <Line: +	 <tr id="escaped-html">
>, <Line: +	 <td>no filter</td>
>, <Line: +	 <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
>, <Line: +	 <td><div ng-bind="snippet"></div></td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should linkify the snippet with urls', function() {
>, <Line: +	 it('should not linkify snippet without the linky filter', function() {
>, <Line: +	 it('should update', function() {
>, <Line: +	 it('should work with the target property', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	angular.module('ngSanitize').filter('linky', ['$sanitize', function ($sanitize) {
>, <Line: +		var LINKY_URL_REGEXP =
>, <Line: +				/((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/,
>, <Line: +			MAILTO_REGEXP = /^mailto:/;
>, <Line: +		return function (text, target) {
>, <Line: +			if (!text) return text;
>, <Line: +			var match;
>, <Line: +			var raw = text;
>, <Line: +			var html = [];
>, <Line: +			var url;
>, <Line: +			var i;
>, <Line: +			while ((match = raw.match(LINKY_URL_REGEXP))) {
>, <Line: +				// We can not end in these as they are sometimes found at the end of the sentence
>, <Line: +				url = match[0];
>, <Line: +				// if we did not match ftp/http/mailto then assume mailto
>, <Line: +				if (match[2] == match[3]) url = 'mailto:' + url;
>, <Line: +				i = match.index;
>, <Line: +				addText(raw.substr(0, i));
>, <Line: +				addLink(url, match[0].replace(MAILTO_REGEXP, ''));
>, <Line: +				raw = raw.substring(i + match[0].length);
>, <Line: +			}
>, <Line: +			addText(raw);
>, <Line: +			return $sanitize(html.join(''));
>, <Line: +			function addText(text) {
>, <Line: +				if (!text) {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				html.push(sanitizeText(text));
>, <Line: +			}
>, <Line: +			function addLink(url, text) {
>, <Line: +				html.push('<a ');
>, <Line: +				if (angular.isDefined(target)) {
>, <Line: +					html.push('target="',
>, <Line: +						target,
>, <Line: +						'" ');
>, <Line: +				}
>, <Line: +				html.push('href="',
>, <Line: +					url.replace('"', '&quot;'),
>, <Line: +					'">');
>, <Line: +				addText(text);
>, <Line: +				html.push('</a>');
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}]);
>]
[<Line: -(function(window, angular, undefined) {'use strict';
>, <Line: -var $sanitizeMinErr = angular.$$minErr('$sanitize');
>, <Line: -/**
>, <Line: - * @ngdoc module
>, <Line: - * @name ngSanitize
>, <Line: - * @description
>, <Line: - *
>, <Line: - * # ngSanitize
>, <Line: - *
>, <Line: - * The `ngSanitize` module provides functionality to sanitize HTML.
>, <Line: - *
>, <Line: - *
>, <Line: - * <div doc-module-components="ngSanitize"></div>
>, <Line: - *
>, <Line: - * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
>, <Line: - */
>, <Line: -/*
>, <Line: - * HTML Parser By Misko Hevery (misko@hevery.com)
>, <Line: - * based on:  HTML Parser By John Resig (ejohn.org)
>, <Line: - * Original code by Erik Arvidsson, Mozilla Public License
>, <Line: - * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
>, <Line: - *
>, <Line: - * // Use like so:
>, <Line: - * htmlParser(htmlString, {
>, <Line: - *     start: function(tag, attrs, unary) {},
>, <Line: - *     end: function(tag) {},
>, <Line: - *     chars: function(text) {},
>, <Line: - *     comment: function(text) {}
>, <Line: - * });
>, <Line: - *
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $sanitize
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
>, <Line: - *   then serialized back to properly escaped html string. This means that no unsafe input can make
>, <Line: - *   it into the returned string, however, since our parser is more strict than a typical browser
>, <Line: - *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
>, <Line: - *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
>, <Line: - *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
>, <Line: - *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
>, <Line: - *
>, <Line: - * @param {string} html HTML input.
>, <Line: - * @returns {string} Sanitized HTML.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="sanitizeExample" deps="angular-sanitize.js">
>, <Line: -   <file name="index.html">
>, <Line: -     <script>
>, <Line: -         angular.module('sanitizeExample', ['ngSanitize'])
>, <Line: -           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
>, <Line: -     </script>
>, <Line: -     <div ng-controller="ExampleController">
>, <Line: -        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
>, <Line: -       <table>
>, <Line: -         <tr>
>, <Line: -           <td>Directive</td>
>, <Line: -           <td>How</td>
>, <Line: -           <td>Source</td>
>, <Line: -           <td>Rendered</td>
>, <Line: -         </tr>
>, <Line: -         <tr id="bind-html-with-sanitize">
>, <Line: -           <td>ng-bind-html</td>
>, <Line: -           <td>Automatically uses $sanitize</td>
>, <Line: -           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
>, <Line: -           <td><div ng-bind-html="snippet"></div></td>
>, <Line: -         </tr>
>, <Line: -         <tr id="bind-html-with-trust">
>, <Line: -           <td>ng-bind-html</td>
>, <Line: -           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
>, <Line: -           <td>
>, <Line: -           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
>, <Line: -&lt;/div&gt;</pre>
>, <Line: -           </td>
>, <Line: -           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
>, <Line: -         </tr>
>, <Line: -         <tr id="bind-default">
>, <Line: -           <td>ng-bind</td>
>, <Line: -           <td>Automatically escapes</td>
>, <Line: -           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
>, <Line: -           <td><div ng-bind="snippet"></div></td>
>, <Line: -         </tr>
>, <Line: -       </table>
>, <Line: -       </div>
>, <Line: -   </file>
>, <Line: -   <file name="protractor.js" type="protractor">
>, <Line: -     it('should sanitize the html snippet by default', function() {
>, <Line: -     it('should inline raw snippet if bound to a trusted value', function() {
>, <Line: -     it('should escape snippet without any filter', function() {
>, <Line: -     it('should update', function() {
>, <Line: -   </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -function $SanitizeProvider() {
>, <Line: -  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
>, <Line: -    return function(html) {
>, <Line: -      var buf = [];
>, <Line: -      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
>, <Line: -        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
>, <Line: -      }));
>, <Line: -      return buf.join('');
>, <Line: -    };
>, <Line: -  }];
>, <Line: -}
>, <Line: -function sanitizeText(chars) {
>, <Line: -  var buf = [];
>, <Line: -  var writer = htmlSanitizeWriter(buf, angular.noop);
>, <Line: -  writer.chars(chars);
>, <Line: -  return buf.join('');
>, <Line: -}
>, <Line: -var START_TAG_REGEXP =
>, <Line: -       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
>, <Line: -  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
>, <Line: -  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
>, <Line: -  BEGIN_TAG_REGEXP = /^</,
>, <Line: -  BEGING_END_TAGE_REGEXP = /^<\//,
>, <Line: -  COMMENT_REGEXP = /<!--(.*?)-->/g,
>, <Line: -  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
>, <Line: -  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
>, <Line: -  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
>, <Line: -  // Match everything outside of normal chars and " (quote character)
>, <Line: -  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
>, <Line: -var voidElements = makeMap("area,br,col,hr,img,wbr");
>, <Line: -var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
>, <Line: -    optionalEndTagInlineElements = makeMap("rp,rt"),
>, <Line: -    optionalEndTagElements = angular.extend({},
>, <Line: -                                            optionalEndTagInlineElements,
>, <Line: -                                            optionalEndTagBlockElements);
>, <Line: -var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
>, <Line: -        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
>, <Line: -        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
>, <Line: -var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
>, <Line: -        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
>, <Line: -        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
>, <Line: -var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," +
>, <Line: -        "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," +
>, <Line: -        "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," +
>, <Line: -        "stop,svg,switch,text,title,tspan,use");
>, <Line: -var specialElements = makeMap("script,style");
>, <Line: -var validElements = angular.extend({},
>, <Line: -                                   voidElements,
>, <Line: -                                   blockElements,
>, <Line: -                                   inlineElements,
>, <Line: -                                   optionalEndTagElements,
>, <Line: -                                   svgElements);
>, <Line: -var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
>, <Line: -var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
>, <Line: -    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
>, <Line: -    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
>, <Line: -    'scope,scrolling,shape,size,span,start,summary,target,title,type,' +
>, <Line: -    'valign,value,vspace,width');
>, <Line: -var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
>, <Line: -    'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +
>, <Line: -    'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +
>, <Line: -    'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +
>, <Line: -    'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +
>, <Line: -    'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +
>, <Line: -    'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +
>, <Line: -    'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +
>, <Line: -    'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +
>, <Line: -    'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +
>, <Line: -    'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +
>, <Line: -    'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +
>, <Line: -    'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +
>, <Line: -    'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +
>, <Line: -    'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +
>, <Line: -    'zoomAndPan');
>, <Line: -var validAttrs = angular.extend({},
>, <Line: -                                uriAttrs,
>, <Line: -                                svgAttrs,
>, <Line: -                                htmlAttrs);
>, <Line: -function makeMap(str) {
>, <Line: -  var obj = {}, items = str.split(','), i;
>, <Line: -  for (i = 0; i < items.length; i++) obj[items[i]] = true;
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @example
>, <Line: - * htmlParser(htmlString, {
>, <Line: - *
>, <Line: - * @param {string} html string
>, <Line: - * @param {object} handler
>, <Line: - */
>, <Line: -function htmlParser(html, handler) {
>, <Line: -  if (typeof html !== 'string') {
>, <Line: -    if (html === null || typeof html === 'undefined') {
>, <Line: -      html = '';
>, <Line: -    } else {
>, <Line: -      html = '' + html;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  var index, chars, match, stack = [], last = html, text;
>, <Line: -  stack.last = function() { return stack[ stack.length - 1 ]; };
>, <Line: -  while (html) {
>, <Line: -    text = '';
>, <Line: -    chars = true;
>, <Line: -    // Make sure we're not in a script or style element
>, <Line: -    if (!stack.last() || !specialElements[ stack.last() ]) {
>, <Line: -      // Comment
>, <Line: -      if (html.indexOf("<!--") === 0) {
>, <Line: -        // comments containing -- are not allowed unless they terminate the comment
>, <Line: -        index = html.indexOf("--", 4);
>, <Line: -        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
>, <Line: -          if (handler.comment) handler.comment(html.substring(4, index));
>, <Line: -          html = html.substring(index + 3);
>, <Line: -          chars = false;
>, <Line: -        }
>, <Line: -      // DOCTYPE
>, <Line: -      } else if (DOCTYPE_REGEXP.test(html)) {
>, <Line: -        match = html.match(DOCTYPE_REGEXP);
>, <Line: -        if (match) {
>, <Line: -          html = html.replace(match[0], '');
>, <Line: -          chars = false;
>, <Line: -        }
>, <Line: -      // end tag
>, <Line: -      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
>, <Line: -        match = html.match(END_TAG_REGEXP);
>, <Line: -        if (match) {
>, <Line: -          html = html.substring(match[0].length);
>, <Line: -          match[0].replace(END_TAG_REGEXP, parseEndTag);
>, <Line: -          chars = false;
>, <Line: -        }
>, <Line: -      // start tag
>, <Line: -      } else if (BEGIN_TAG_REGEXP.test(html)) {
>, <Line: -        match = html.match(START_TAG_REGEXP);
>, <Line: -        if (match) {
>, <Line: -          // We only have a valid start-tag if there is a '>'.
>, <Line: -          if (match[4]) {
>, <Line: -            html = html.substring(match[0].length);
>, <Line: -            match[0].replace(START_TAG_REGEXP, parseStartTag);
>, <Line: -          }
>, <Line: -          chars = false;
>, <Line: -        } else {
>, <Line: -          // no ending tag found --- this piece should be encoded as an entity.
>, <Line: -          text += '<';
>, <Line: -          html = html.substring(1);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (chars) {
>, <Line: -        index = html.indexOf("<");
>, <Line: -        text += index < 0 ? html : html.substring(0, index);
>, <Line: -        html = index < 0 ? "" : html.substring(index);
>, <Line: -        if (handler.chars) handler.chars(decodeEntities(text));
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
>, <Line: -        function(all, text) {
>, <Line: -          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
>, <Line: -          if (handler.chars) handler.chars(decodeEntities(text));
>, <Line: -          return "";
>, <Line: -      });
>, <Line: -      parseEndTag("", stack.last());
>, <Line: -    }
>, <Line: -    if (html == last) {
>, <Line: -      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
>, <Line: -                                        "of html: {0}", html);
>, <Line: -    }
>, <Line: -    last = html;
>, <Line: -  }
>, <Line: -  // Clean up any remaining tags
>, <Line: -  parseEndTag();
>, <Line: -  function parseStartTag(tag, tagName, rest, unary) {
>, <Line: -    tagName = angular.lowercase(tagName);
>, <Line: -    if (blockElements[ tagName ]) {
>, <Line: -      while (stack.last() && inlineElements[ stack.last() ]) {
>, <Line: -        parseEndTag("", stack.last());
>, <Line: -      }
>, <Line: -    }
>, <Line: -    if (optionalEndTagElements[ tagName ] && stack.last() == tagName) {
>, <Line: -      parseEndTag("", tagName);
>, <Line: -    }
>, <Line: -    unary = voidElements[ tagName ] || !!unary;
>, <Line: -    if (!unary)
>, <Line: -      stack.push(tagName);
>, <Line: -    var attrs = {};
>, <Line: -    rest.replace(ATTR_REGEXP,
>, <Line: -      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
>, <Line: -        var value = doubleQuotedValue
>, <Line: -          || singleQuotedValue
>, <Line: -          || unquotedValue
>, <Line: -          || '';
>, <Line: -        attrs[name] = decodeEntities(value);
>, <Line: -    });
>, <Line: -    if (handler.start) handler.start(tagName, attrs, unary);
>, <Line: -  }
>, <Line: -  function parseEndTag(tag, tagName) {
>, <Line: -    var pos = 0, i;
>, <Line: -    tagName = angular.lowercase(tagName);
>, <Line: -    if (tagName)
>, <Line: -      // Find the closest opened tag of the same type
>, <Line: -      for (pos = stack.length - 1; pos >= 0; pos--)
>, <Line: -        if (stack[ pos ] == tagName)
>, <Line: -          break;
>, <Line: -    if (pos >= 0) {
>, <Line: -      // Close all the open elements, up the stack
>, <Line: -      for (i = stack.length - 1; i >= pos; i--)
>, <Line: -        if (handler.end) handler.end(stack[ i ]);
>, <Line: -      // Remove the open elements from the stack
>, <Line: -      stack.length = pos;
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>, <Line: -var hiddenPre=document.createElement("pre");
>, <Line: -var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
>, <Line: -/**
>, <Line: - * decodes all entities into regular string
>, <Line: - * @param value
>, <Line: - * @returns {string} A string with decoded entities.
>, <Line: - */
>, <Line: -function decodeEntities(value) {
>, <Line: -  if (!value) { return ''; }
>, <Line: -  // Note: IE8 does not preserve spaces at the start/end of innerHTML
>, <Line: -  // so we must capture them and reattach them afterward
>, <Line: -  var parts = spaceRe.exec(value);
>, <Line: -  var spaceBefore = parts[1];
>, <Line: -  var spaceAfter = parts[3];
>, <Line: -  var content = parts[2];
>, <Line: -  if (content) {
>, <Line: -    hiddenPre.innerHTML=content.replace(/</g,"&lt;");
>, <Line: -    // innerText depends on styling as it doesn't display hidden elements.
>, <Line: -    // Therefore, it's better to use textContent not to cause unnecessary
>, <Line: -    // reflows. However, IE<9 don't support textContent so the innerText
>, <Line: -    // fallback is necessary.
>, <Line: -    content = 'textContent' in hiddenPre ?
>, <Line: -      hiddenPre.textContent : hiddenPre.innerText;
>, <Line: -  }
>, <Line: -  return spaceBefore + content + spaceAfter;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Escapes all potentially dangerous characters, so that the
>, <Line: - * resulting string can be safely inserted into attribute or
>, <Line: - * element text.
>, <Line: - * @param value
>, <Line: - * @returns {string} escaped text
>, <Line: - */
>, <Line: -function encodeEntities(value) {
>, <Line: -  return value.
>, <Line: -    replace(/&/g, '&amp;').
>, <Line: -    replace(SURROGATE_PAIR_REGEXP, function(value) {
>, <Line: -      var hi = value.charCodeAt(0);
>, <Line: -      var low = value.charCodeAt(1);
>, <Line: -      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
>, <Line: -    }).
>, <Line: -    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
>, <Line: -      return '&#' + value.charCodeAt(0) + ';';
>, <Line: -    }).
>, <Line: -    replace(/</g, '&lt;').
>, <Line: -    replace(/>/g, '&gt;');
>, <Line: -}
>, <Line: -/**
>, <Line: - * create an HTML/XML writer which writes to buffer
>, <Line: - * @param {Array} buf use buf.jain('') to get out sanitized html string
>, <Line: - * @returns {object} in the form of {
>, <Line: - */
>, <Line: -function htmlSanitizeWriter(buf, uriValidator) {
>, <Line: -  var ignore = false;
>, <Line: -  var out = angular.bind(buf, buf.push);
>, <Line: -  return {
>, <Line: -    start: function(tag, attrs, unary) {
>, <Line: -      tag = angular.lowercase(tag);
>, <Line: -      if (!ignore && specialElements[tag]) {
>, <Line: -        ignore = tag;
>, <Line: -      }
>, <Line: -      if (!ignore && validElements[tag] === true) {
>, <Line: -        out('<');
>, <Line: -        out(tag);
>, <Line: -        angular.forEach(attrs, function(value, key) {
>, <Line: -          var lkey=angular.lowercase(key);
>, <Line: -          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
>, <Line: -          if (validAttrs[lkey] === true &&
>, <Line: -            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
>, <Line: -            out(' ');
>, <Line: -            out(key);
>, <Line: -            out('="');
>, <Line: -            out(encodeEntities(value));
>, <Line: -            out('"');
>, <Line: -          }
>, <Line: -        });
>, <Line: -        out(unary ? '/>' : '>');
>, <Line: -      }
>, <Line: -    },
>, <Line: -    end: function(tag) {
>, <Line: -        tag = angular.lowercase(tag);
>, <Line: -        if (!ignore && validElements[tag] === true) {
>, <Line: -          out('</');
>, <Line: -          out(tag);
>, <Line: -          out('>');
>, <Line: -        }
>, <Line: -        if (tag == ignore) {
>, <Line: -          ignore = false;
>, <Line: -        }
>, <Line: -      },
>, <Line: -    chars: function(chars) {
>, <Line: -        if (!ignore) {
>, <Line: -          out(encodeEntities(chars));
>, <Line: -        }
>, <Line: -      }
>, <Line: -  };
>, <Line: -}
>, <Line: -angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
>, <Line: -/* global sanitizeText: false */
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name linky
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
>, <Line: - * plain email address links.
>, <Line: - *
>, <Line: - * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
>, <Line: - *
>, <Line: - * @param {string} text Input text.
>, <Line: - * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
>, <Line: - * @returns {string} Html-linkified text.
>, <Line: - *
>, <Line: - * @usage
>, <Line: -   <span ng-bind-html="linky_expression | linky"></span>
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="linkyExample" deps="angular-sanitize.js">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('linkyExample', ['ngSanitize'])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
>, <Line: -       <table>
>, <Line: -         <tr>
>, <Line: -           <td>Filter</td>
>, <Line: -           <td>Source</td>
>, <Line: -           <td>Rendered</td>
>, <Line: -         </tr>
>, <Line: -         <tr id="linky-filter">
>, <Line: -           <td>linky filter</td>
>, <Line: -           <td>
>, <Line: -             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
>, <Line: -           </td>
>, <Line: -           <td>
>, <Line: -             <div ng-bind-html="snippet | linky"></div>
>, <Line: -           </td>
>, <Line: -         </tr>
>, <Line: -         <tr id="linky-target">
>, <Line: -          <td>linky target</td>
>, <Line: -          <td>
>, <Line: -            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
>, <Line: -          </td>
>, <Line: -          <td>
>, <Line: -            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
>, <Line: -          </td>
>, <Line: -         </tr>
>, <Line: -         <tr id="escaped-html">
>, <Line: -           <td>no filter</td>
>, <Line: -           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
>, <Line: -           <td><div ng-bind="snippet"></div></td>
>, <Line: -         </tr>
>, <Line: -       </table>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should linkify the snippet with urls', function() {
>, <Line: -       it('should not linkify snippet without the linky filter', function() {
>, <Line: -       it('should update', function() {
>, <Line: -       it('should work with the target property', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
>, <Line: -  var LINKY_URL_REGEXP =
>, <Line: -        /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/,
>, <Line: -      MAILTO_REGEXP = /^mailto:/;
>, <Line: -  return function(text, target) {
>, <Line: -    if (!text) return text;
>, <Line: -    var match;
>, <Line: -    var raw = text;
>, <Line: -    var html = [];
>, <Line: -    var url;
>, <Line: -    var i;
>, <Line: -    while ((match = raw.match(LINKY_URL_REGEXP))) {
>, <Line: -      // We can not end in these as they are sometimes found at the end of the sentence
>, <Line: -      url = match[0];
>, <Line: -      // if we did not match ftp/http/mailto then assume mailto
>, <Line: -      if (match[2] == match[3]) url = 'mailto:' + url;
>, <Line: -      i = match.index;
>, <Line: -      addText(raw.substr(0, i));
>, <Line: -      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
>, <Line: -      raw = raw.substring(i + match[0].length);
>, <Line: -    }
>, <Line: -    addText(raw);
>, <Line: -    return $sanitize(html.join(''));
>, <Line: -    function addText(text) {
>, <Line: -      if (!text) {
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      html.push(sanitizeText(text));
>, <Line: -    }
>, <Line: -    function addLink(url, text) {
>, <Line: -      html.push('<a ');
>, <Line: -      if (angular.isDefined(target)) {
>, <Line: -        html.push('target="',
>, <Line: -                  target,
>, <Line: -                  '" ');
>, <Line: -      }
>, <Line: -      html.push('href="',
>, <Line: -                url.replace('"', '&quot;'),
>, <Line: -                '">');
>, <Line: -      addText(text);
>, <Line: -      html.push('</a>');
>, <Line: -    }
>, <Line: -  };
>, <Line: -}]);
>]