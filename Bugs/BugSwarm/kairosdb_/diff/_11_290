[<Line: +(function (window, angular, undefined) {
>, <Line: +	'use strict';
>, <Line: +	/**
>, <Line: +	 * @ngdoc object
>, <Line: +	 * @name angular.mock
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Namespace from 'angular-mocks.js' which contains testing related code.
>, <Line: +	 */
>, <Line: +	angular.mock = {};
>, <Line: +	/**
>, <Line: +	 * ! This is a private undocumented service !
>, <Line: +	 *
>, <Line: +	 * @name $browser
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * This service is a mock implementation of {@link ng.$browser}. It provides fake
>, <Line: +	 * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,
>, <Line: +	 * cookies, etc...
>, <Line: +	 *
>, <Line: +	 * The api of this service is the same as that of the real {@link ng.$browser $browser}, except
>, <Line: +	 * that there are several helper methods available which can be used in tests.
>, <Line: +	 */
>, <Line: +	angular.mock.$BrowserProvider = function () {
>, <Line: +		this.$get = function () {
>, <Line: +			return new angular.mock.$Browser();
>, <Line: +		};
>, <Line: +	};
>, <Line: +	angular.mock.$Browser = function () {
>, <Line: +		var self = this;
>, <Line: +		this.isMock = true;
>, <Line: +		self.$$url = "http://server/";
>, <Line: +		self.$$lastUrl = self.$$url; // used by url polling fn
>, <Line: +		self.pollFns = [];
>, <Line: +		// TODO(vojta): remove this temporary api
>, <Line: +		self.$$completeOutstandingRequest = angular.noop;
>, <Line: +		self.$$incOutstandingRequestCount = angular.noop;
>, <Line: +		// register url polling fn
>, <Line: +		self.onUrlChange = function (listener) {
>, <Line: +			self.pollFns.push(
>, <Line: +				function () {
>, <Line: +					if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
>, <Line: +						self.$$lastUrl = self.$$url;
>, <Line: +						self.$$lastState = self.$$state;
>, <Line: +						listener(self.$$url, self.$$state);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			);
>, <Line: +			return listener;
>, <Line: +		};
>, <Line: +		self.$$checkUrlChange = angular.noop;
>, <Line: +		self.cookieHash = {};
>, <Line: +		self.lastCookieHash = {};
>, <Line: +		self.deferredFns = [];
>, <Line: +		self.deferredNextId = 0;
>, <Line: +		self.defer = function (fn, delay) {
>, <Line: +			delay = delay || 0;
>, <Line: +			self.deferredFns.push({
>, <Line: +				time: (self.defer.now + delay),
>, <Line: +				fn: fn,
>, <Line: +				id: self.deferredNextId
>, <Line: +			});
>, <Line: +			self.deferredFns.sort(function (a, b) {
>, <Line: +				return a.time - b.time;
>, <Line: +			});
>, <Line: +			return self.deferredNextId++;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @name $browser#defer.now
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Current milliseconds mock time.
>, <Line: +		 */
>, <Line: +		self.defer.now = 0;
>, <Line: +		self.defer.cancel = function (deferId) {
>, <Line: +			var fnIndex;
>, <Line: +			angular.forEach(self.deferredFns, function (fn, index) {
>, <Line: +				if (fn.id === deferId) fnIndex = index;
>, <Line: +			});
>, <Line: +			if (fnIndex !== undefined) {
>, <Line: +				self.deferredFns.splice(fnIndex, 1);
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @name $browser#defer.flush
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Flushes all pending requests and executes the defer callbacks.
>, <Line: +		 *
>, <Line: +		 * @param {number=} number of milliseconds to flush. See {@link #defer.now}
>, <Line: +		 */
>, <Line: +		self.defer.flush = function (delay) {
>, <Line: +			if (angular.isDefined(delay)) {
>, <Line: +				self.defer.now += delay;
>, <Line: +			} else {
>, <Line: +				if (self.deferredFns.length) {
>, <Line: +					self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
>, <Line: +				} else {
>, <Line: +					throw new Error('No deferred tasks to be flushed');
>, <Line: +				}
>, <Line: +			}
>, <Line: +			while (self.deferredFns.length && self.deferredFns[0].time <= self.defer.now) {
>, <Line: +				self.deferredFns.shift().fn();
>, <Line: +			}
>, <Line: +		};
>, <Line: +		self.$$baseHref = '/';
>, <Line: +		self.baseHref = function () {
>, <Line: +			return this.$$baseHref;
>, <Line: +		};
>, <Line: +	};
>, <Line: +	angular.mock.$Browser.prototype = {
>, <Line: +		/**
>, <Line: +		 * @name $browser#poll
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * run all fns in pollFns
>, <Line: +		 */
>, <Line: +		poll: function poll() {
>, <Line: +			angular.forEach(this.pollFns, function (pollFn) {
>, <Line: +				pollFn();
>, <Line: +			});
>, <Line: +		},
>, <Line: +		addPollFn: function (pollFn) {
>, <Line: +			this.pollFns.push(pollFn);
>, <Line: +			return pollFn;
>, <Line: +		},
>, <Line: +		url: function (url, replace, state) {
>, <Line: +			if (angular.isUndefined(state)) {
>, <Line: +				state = null;
>, <Line: +			}
>, <Line: +			if (url) {
>, <Line: +				this.$$url = url;
>, <Line: +				// Native pushState serializes & copies the object; simulate it.
>, <Line: +				this.$$state = angular.copy(state);
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +			return this.$$url;
>, <Line: +		},
>, <Line: +		state: function () {
>, <Line: +			return this.$$state;
>, <Line: +		},
>, <Line: +		cookies: function (name, value) {
>, <Line: +			if (name) {
>, <Line: +				if (angular.isUndefined(value)) {
>, <Line: +					delete this.cookieHash[name];
>, <Line: +				} else {
>, <Line: +					if (angular.isString(value) &&       //strings only
>, <Line: +						value.length <= 4096) {          //strict cookie storage limits
>, <Line: +						this.cookieHash[name] = value;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				if (!angular.equals(this.cookieHash, this.lastCookieHash)) {
>, <Line: +					this.lastCookieHash = angular.copy(this.cookieHash);
>, <Line: +					this.cookieHash = angular.copy(this.cookieHash);
>, <Line: +				}
>, <Line: +				return this.cookieHash;
>, <Line: +			}
>, <Line: +		},
>, <Line: +		notifyWhenNoOutstandingRequests: function (fn) {
>, <Line: +			fn();
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $exceptionHandlerProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors
>, <Line: +	 * passed to the `$exceptionHandler`.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $exceptionHandler
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed
>, <Line: +	 * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration
>, <Line: +	 * information.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   describe('$exceptionHandlerProvider', function() {
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	angular.mock.$ExceptionHandlerProvider = function () {
>, <Line: +		var handler;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $exceptionHandlerProvider#mode
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the logging mode.
>, <Line: +		 *
>, <Line: +		 * @param {string} mode Mode of operation, defaults to `rethrow`.
>, <Line: +		 *
>, <Line: +		 *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there
>, <Line: +		 *                is a bug in the application or test, so this mock will make these tests fail.
>, <Line: +		 *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`
>, <Line: +		 *            mode stores an array of errors in `$exceptionHandler.errors`, to allow later
>, <Line: +		 *            assertion of them. See {@link ngMock.$log#assertEmpty assertEmpty()} and
>, <Line: +		 *            {@link ngMock.$log#reset reset()}
>, <Line: +		 */
>, <Line: +		this.mode = function (mode) {
>, <Line: +			switch (mode) {
>, <Line: +				case 'rethrow':
>, <Line: +					handler = function (e) {
>, <Line: +						throw e;
>, <Line: +					};
>, <Line: +					break;
>, <Line: +				case 'log':
>, <Line: +					var errors = [];
>, <Line: +					handler = function (e) {
>, <Line: +						if (arguments.length == 1) {
>, <Line: +							errors.push(e);
>, <Line: +						} else {
>, <Line: +							errors.push([].slice.call(arguments, 0));
>, <Line: +						}
>, <Line: +					};
>, <Line: +					handler.errors = errors;
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					throw new Error("Unknown mode '" + mode + "', only 'log'/'rethrow' modes are allowed!");
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			return handler;
>, <Line: +		};
>, <Line: +		this.mode('rethrow');
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $log
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays
>, <Line: +	 * (one array per logging level). These arrays are exposed as `logs` property of each of the
>, <Line: +	 * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	angular.mock.$LogProvider = function () {
>, <Line: +		var debug = true;
>, <Line: +		function concat(array1, array2, index) {
>, <Line: +			return array1.concat(Array.prototype.slice.call(array2, index));
>, <Line: +		}
>, <Line: +		this.debugEnabled = function (flag) {
>, <Line: +			if (angular.isDefined(flag)) {
>, <Line: +				debug = flag;
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return debug;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			var $log = {
>, <Line: +				log: function () {
>, <Line: +					$log.log.logs.push(concat([], arguments, 0));
>, <Line: +				},
>, <Line: +				warn: function () {
>, <Line: +					$log.warn.logs.push(concat([], arguments, 0));
>, <Line: +				},
>, <Line: +				info: function () {
>, <Line: +					$log.info.logs.push(concat([], arguments, 0));
>, <Line: +				},
>, <Line: +				error: function () {
>, <Line: +					$log.error.logs.push(concat([], arguments, 0));
>, <Line: +				},
>, <Line: +				debug: function () {
>, <Line: +					if (debug) {
>, <Line: +						$log.debug.logs.push(concat([], arguments, 0));
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $log#reset
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Reset all of the logging arrays to empty.
>, <Line: +			 */
>, <Line: +			$log.reset = function () {
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $log#log.logs
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Array of messages logged using {@link ng.$log#log `log()`}.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * ```js
>, <Line: +				 * $log.log('Some Log');
>, <Line: +				 * var first = $log.log.logs.unshift();
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				$log.log.logs = [];
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $log#info.logs
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Array of messages logged using {@link ng.$log#info `info()`}.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * ```js
>, <Line: +				 * $log.info('Some Info');
>, <Line: +				 * var first = $log.info.logs.unshift();
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				$log.info.logs = [];
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $log#warn.logs
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Array of messages logged using {@link ng.$log#warn `warn()`}.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * ```js
>, <Line: +				 * $log.warn('Some Warning');
>, <Line: +				 * var first = $log.warn.logs.unshift();
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				$log.warn.logs = [];
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $log#error.logs
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Array of messages logged using {@link ng.$log#error `error()`}.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * ```js
>, <Line: +				 * $log.error('Some Error');
>, <Line: +				 * var first = $log.error.logs.unshift();
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				$log.error.logs = [];
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $log#debug.logs
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Array of messages logged using {@link ng.$log#debug `debug()`}.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * ```js
>, <Line: +				 * $log.debug('Some Error');
>, <Line: +				 * var first = $log.debug.logs.unshift();
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				$log.debug.logs = [];
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $log#assertEmpty
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Assert that all of the logging methods have no logged messages. If any messages are present,
>, <Line: +			 * an exception is thrown.
>, <Line: +			 */
>, <Line: +			$log.assertEmpty = function () {
>, <Line: +				var errors = [];
>, <Line: +				angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function (logLevel) {
>, <Line: +					angular.forEach($log[logLevel].logs, function (log) {
>, <Line: +						angular.forEach(log, function (logItem) {
>, <Line: +							errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\n' +
>, <Line: +								(logItem.stack || ''));
>, <Line: +						});
>, <Line: +					});
>, <Line: +				});
>, <Line: +				if (errors.length) {
>, <Line: +					errors.unshift("Expected $log to be empty! Either a message was logged unexpectedly, or " +
>, <Line: +						"an expected log message was not checked and removed:");
>, <Line: +					errors.push('');
>, <Line: +					throw new Error(errors.join('\n---------\n'));
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$log.reset();
>, <Line: +			return $log;
>, <Line: +		};
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $interval
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Mock implementation of the $interval service.
>, <Line: +	 *
>, <Line: +	 * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to
>, <Line: +	 * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
>, <Line: +	 * time.
>, <Line: +	 *
>, <Line: +	 * @param {function()} fn A function that should be called repeatedly.
>, <Line: +	 * @param {number} delay Number of milliseconds between each function call.
>, <Line: +	 * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
>, <Line: +	 *   indefinitely.
>, <Line: +	 * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: +	 *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: +	 * @returns {promise} A promise which will be notified on each iteration.
>, <Line: +	 */
>, <Line: +	angular.mock.$IntervalProvider = function () {
>, <Line: +		this.$get = ['$browser', '$rootScope', '$q', '$$q',
>, <Line: +			function ($browser, $rootScope, $q, $$q) {
>, <Line: +				var repeatFns = [],
>, <Line: +					nextRepeatId = 0,
>, <Line: +					now = 0;
>, <Line: +				var $interval = function (fn, delay, count, invokeApply) {
>, <Line: +					var iteration = 0,
>, <Line: +						skipApply = (angular.isDefined(invokeApply) && !invokeApply),
>, <Line: +						deferred = (skipApply ? $$q : $q).defer(),
>, <Line: +						promise = deferred.promise;
>, <Line: +					count = (angular.isDefined(count)) ? count : 0;
>, <Line: +					promise.then(null, null, fn);
>, <Line: +					promise.$$intervalId = nextRepeatId;
>, <Line: +					function tick() {
>, <Line: +						deferred.notify(iteration++);
>, <Line: +						if (count > 0 && iteration >= count) {
>, <Line: +							var fnIndex;
>, <Line: +							deferred.resolve(iteration);
>, <Line: +							angular.forEach(repeatFns, function (fn, index) {
>, <Line: +								if (fn.id === promise.$$intervalId) fnIndex = index;
>, <Line: +							});
>, <Line: +							if (fnIndex !== undefined) {
>, <Line: +								repeatFns.splice(fnIndex, 1);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (skipApply) {
>, <Line: +							$browser.defer.flush();
>, <Line: +						} else {
>, <Line: +							$rootScope.$apply();
>, <Line: +						}
>, <Line: +					}
>, <Line: +					repeatFns.push({
>, <Line: +						nextTime: (now + delay),
>, <Line: +						delay: delay,
>, <Line: +						fn: tick,
>, <Line: +						id: nextRepeatId,
>, <Line: +						deferred: deferred
>, <Line: +					});
>, <Line: +					repeatFns.sort(function (a, b) {
>, <Line: +						return a.nextTime - b.nextTime;
>, <Line: +					});
>, <Line: +					nextRepeatId++;
>, <Line: +					return promise;
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $interval#cancel
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Cancels a task associated with the `promise`.
>, <Line: +				 *
>, <Line: +				 * @param {promise} promise A promise from calling the `$interval` function.
>, <Line: +				 * @returns {boolean} Returns `true` if the task was successfully cancelled.
>, <Line: +				 */
>, <Line: +				$interval.cancel = function (promise) {
>, <Line: +					if (!promise) return false;
>, <Line: +					var fnIndex;
>, <Line: +					angular.forEach(repeatFns, function (fn, index) {
>, <Line: +						if (fn.id === promise.$$intervalId) fnIndex = index;
>, <Line: +					});
>, <Line: +					if (fnIndex !== undefined) {
>, <Line: +						repeatFns[fnIndex].deferred.reject('canceled');
>, <Line: +						repeatFns.splice(fnIndex, 1);
>, <Line: +						return true;
>, <Line: +					}
>, <Line: +					return false;
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $interval#flush
>, <Line: +				 * @description
>, <Line: +				 *
>, <Line: +				 * Runs interval tasks scheduled to be run in the next `millis` milliseconds.
>, <Line: +				 *
>, <Line: +				 * @param {number=} millis maximum timeout amount to flush up until.
>, <Line: +				 *
>, <Line: +				 * @return {number} The amount of time moved forward.
>, <Line: +				 */
>, <Line: +				$interval.flush = function (millis) {
>, <Line: +					now += millis;
>, <Line: +					while (repeatFns.length && repeatFns[0].nextTime <= now) {
>, <Line: +						var task = repeatFns[0];
>, <Line: +						task.fn();
>, <Line: +						task.nextTime += task.delay;
>, <Line: +						repeatFns.sort(function (a, b) {
>, <Line: +							return a.nextTime - b.nextTime;
>, <Line: +						});
>, <Line: +					}
>, <Line: +					return millis;
>, <Line: +				};
>, <Line: +				return $interval;
>, <Line: +			}];
>, <Line: +	};
>, <Line: +	/* jshint -W101 */
>, <Line: +	/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!
>, <Line: +	 * This directive should go inside the anonymous function but a bug in JSHint means that it would
>, <Line: +	 * not be enacted early enough to prevent the warning.
>, <Line: +	 */
>, <Line: +	var R_ISO8061_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
>, <Line: +	function jsonStringToDate(string) {
>, <Line: +		var match;
>, <Line: +		if (match = string.match(R_ISO8061_STR)) {
>, <Line: +			var date = new Date(0),
>, <Line: +				tzHour = 0,
>, <Line: +				tzMin = 0;
>, <Line: +			if (match[9]) {
>, <Line: +				tzHour = int(match[9] + match[10]);
>, <Line: +				tzMin = int(match[9] + match[11]);
>, <Line: +			}
>, <Line: +			date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
>, <Line: +			date.setUTCHours(int(match[4] || 0) - tzHour,
>, <Line: +				int(match[5] || 0) - tzMin,
>, <Line: +				int(match[6] || 0),
>, <Line: +				int(match[7] || 0));
>, <Line: +			return date;
>, <Line: +		}
>, <Line: +		return string;
>, <Line: +	}
>, <Line: +	function int(str) {
>, <Line: +		return parseInt(str, 10);
>, <Line: +	}
>, <Line: +	function padNumber(num, digits, trim) {
>, <Line: +		var neg = '';
>, <Line: +		if (num < 0) {
>, <Line: +			neg = '-';
>, <Line: +			num = -num;
>, <Line: +		}
>, <Line: +		num = '' + num;
>, <Line: +		while (num.length < digits) num = '0' + num;
>, <Line: +		if (trim)
>, <Line: +			num = num.substr(num.length - digits);
>, <Line: +		return neg + num;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name angular.mock.TzDate
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.
>, <Line: +	 *
>, <Line: +	 * Mock of the Date type which has its timezone specified via constructor arg.
>, <Line: +	 *
>, <Line: +	 * The main purpose is to create Date-like instances with timezone fixed to the specified timezone
>, <Line: +	 * offset, so that we can test code that depends on local timezone settings without dependency on
>, <Line: +	 * the time zone settings of the machine where the code is running.
>, <Line: +	 *
>, <Line: +	 * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)
>, <Line: +	 * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * !!!! WARNING !!!!!
>, <Line: +	 * This is not a complete Date object so only methods that were implemented can be called safely.
>, <Line: +	 * To make matters worse, TzDate instances inherit stuff from Date via a prototype.
>, <Line: +	 *
>, <Line: +	 * We do our best to intercept calls to "unimplemented" methods, but since the list of methods is
>, <Line: +	 * incomplete we might be missing some non-standard methods. This can result in errors like:
>, <Line: +	 * "Date.prototype.foo called on incompatible Object".
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');
>, <Line: +	 * newYearInBratislava.getTimezoneOffset() => -60;
>, <Line: +	 * newYearInBratislava.getFullYear() => 2010;
>, <Line: +	 * newYearInBratislava.getMonth() => 0;
>, <Line: +	 * newYearInBratislava.getDate() => 1;
>, <Line: +	 * newYearInBratislava.getHours() => 0;
>, <Line: +	 * newYearInBratislava.getMinutes() => 0;
>, <Line: +	 * newYearInBratislava.getSeconds() => 0;
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	angular.mock.TzDate = function (offset, timestamp) {
>, <Line: +		var self = new Date(0);
>, <Line: +		if (angular.isString(timestamp)) {
>, <Line: +			var tsStr = timestamp;
>, <Line: +			self.origDate = jsonStringToDate(timestamp);
>, <Line: +			timestamp = self.origDate.getTime();
>, <Line: +			if (isNaN(timestamp))
>, <Line: +				throw {
>, <Line: +					name: "Illegal Argument",
>, <Line: +					message: "Arg '" + tsStr + "' passed into TzDate constructor is not a valid date string"
>, <Line: +				};
>, <Line: +		} else {
>, <Line: +			self.origDate = new Date(timestamp);
>, <Line: +		}
>, <Line: +		var localOffset = new Date(timestamp).getTimezoneOffset();
>, <Line: +		self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
>, <Line: +		self.date = new Date(timestamp + self.offsetDiff);
>, <Line: +		self.getTime = function () {
>, <Line: +			return self.date.getTime() - self.offsetDiff;
>, <Line: +		};
>, <Line: +		self.toLocaleDateString = function () {
>, <Line: +			return self.date.toLocaleDateString();
>, <Line: +		};
>, <Line: +		self.getFullYear = function () {
>, <Line: +			return self.date.getFullYear();
>, <Line: +		};
>, <Line: +		self.getMonth = function () {
>, <Line: +			return self.date.getMonth();
>, <Line: +		};
>, <Line: +		self.getDate = function () {
>, <Line: +			return self.date.getDate();
>, <Line: +		};
>, <Line: +		self.getHours = function () {
>, <Line: +			return self.date.getHours();
>, <Line: +		};
>, <Line: +		self.getMinutes = function () {
>, <Line: +			return self.date.getMinutes();
>, <Line: +		};
>, <Line: +		self.getSeconds = function () {
>, <Line: +			return self.date.getSeconds();
>, <Line: +		};
>, <Line: +		self.getMilliseconds = function () {
>, <Line: +			return self.date.getMilliseconds();
>, <Line: +		};
>, <Line: +		self.getTimezoneOffset = function () {
>, <Line: +			return offset * 60;
>, <Line: +		};
>, <Line: +		self.getUTCFullYear = function () {
>, <Line: +			return self.origDate.getUTCFullYear();
>, <Line: +		};
>, <Line: +		self.getUTCMonth = function () {
>, <Line: +			return self.origDate.getUTCMonth();
>, <Line: +		};
>, <Line: +		self.getUTCDate = function () {
>, <Line: +			return self.origDate.getUTCDate();
>, <Line: +		};
>, <Line: +		self.getUTCHours = function () {
>, <Line: +			return self.origDate.getUTCHours();
>, <Line: +		};
>, <Line: +		self.getUTCMinutes = function () {
>, <Line: +			return self.origDate.getUTCMinutes();
>, <Line: +		};
>, <Line: +		self.getUTCSeconds = function () {
>, <Line: +			return self.origDate.getUTCSeconds();
>, <Line: +		};
>, <Line: +		self.getUTCMilliseconds = function () {
>, <Line: +			return self.origDate.getUTCMilliseconds();
>, <Line: +		};
>, <Line: +		self.getDay = function () {
>, <Line: +			return self.date.getDay();
>, <Line: +		};
>, <Line: +		// provide this method only on browsers that already have it
>, <Line: +		if (self.toISOString) {
>, <Line: +			self.toISOString = function () {
>, <Line: +				return padNumber(self.origDate.getUTCFullYear(), 4) + '-' +
>, <Line: +					padNumber(self.origDate.getUTCMonth() + 1, 2) + '-' +
>, <Line: +					padNumber(self.origDate.getUTCDate(), 2) + 'T' +
>, <Line: +					padNumber(self.origDate.getUTCHours(), 2) + ':' +
>, <Line: +					padNumber(self.origDate.getUTCMinutes(), 2) + ':' +
>, <Line: +					padNumber(self.origDate.getUTCSeconds(), 2) + '.' +
>, <Line: +					padNumber(self.origDate.getUTCMilliseconds(), 3) + 'Z';
>, <Line: +			};
>, <Line: +		}
>, <Line: +		//hide all methods not implemented in this mock that the Date prototype exposes
>, <Line: +		var unimplementedMethods = ['getUTCDay',
>, <Line: +			'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',
>, <Line: +			'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',
>, <Line: +			'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',
>, <Line: +			'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',
>, <Line: +			'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];
>, <Line: +		angular.forEach(unimplementedMethods, function (methodName) {
>, <Line: +			self[methodName] = function () {
>, <Line: +				throw new Error("Method '" + methodName + "' is not implemented in the TzDate mock");
>, <Line: +			};
>, <Line: +		});
>, <Line: +		return self;
>, <Line: +	};
>, <Line: +	angular.mock.TzDate.prototype = Date.prototype;
>, <Line: +	/* jshint +W101 */
>, <Line: +	angular.mock.animate = angular.module('ngAnimateMock', ['ng'])
>, <Line: +		.config(['$provide', function ($provide) {
>, <Line: +			var reflowQueue = [];
>, <Line: +			$provide.value('$$animateReflow', function (fn) {
>, <Line: +				var index = reflowQueue.length;
>, <Line: +				reflowQueue.push(fn);
>, <Line: +				return function cancel() {
>, <Line: +					reflowQueue.splice(index, 1);
>, <Line: +				};
>, <Line: +			});
>, <Line: +			$provide.decorator('$animate', ['$delegate', '$$asyncCallback', '$timeout', '$browser',
>, <Line: +				function ($delegate, $$asyncCallback, $timeout, $browser) {
>, <Line: +					var animate = {
>, <Line: +						queue: [],
>, <Line: +						cancel: $delegate.cancel,
>, <Line: +						enabled: $delegate.enabled,
>, <Line: +						triggerCallbackEvents: function () {
>, <Line: +							$$asyncCallback.flush();
>, <Line: +						},
>, <Line: +						triggerCallbackPromise: function () {
>, <Line: +							$timeout.flush(0);
>, <Line: +						},
>, <Line: +						triggerCallbacks: function () {
>, <Line: +							this.triggerCallbackEvents();
>, <Line: +							this.triggerCallbackPromise();
>, <Line: +						},
>, <Line: +						triggerReflow: function () {
>, <Line: +							angular.forEach(reflowQueue, function (fn) {
>, <Line: +								fn();
>, <Line: +							});
>, <Line: +							reflowQueue = [];
>, <Line: +						}
>, <Line: +					};
>, <Line: +					angular.forEach(
>, <Line: +						['animate', 'enter', 'leave', 'move', 'addClass', 'removeClass', 'setClass'], function (method) {
>, <Line: +							animate[method] = function () {
>, <Line: +								animate.queue.push({
>, <Line: +									event: method,
>, <Line: +									element: arguments[0],
>, <Line: +									options: arguments[arguments.length - 1],
>, <Line: +									args: arguments
>, <Line: +								});
>, <Line: +								return $delegate[method].apply($delegate, arguments);
>, <Line: +							};
>, <Line: +						});
>, <Line: +					return animate;
>, <Line: +				}]);
>, <Line: +		}]);
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.mock.dump
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * *NOTE*: this is not an injectable instance, just a globally available function.
>, <Line: +	 *
>, <Line: +	 * Method for serializing common angular objects (scope, elements, etc..) into strings, useful for
>, <Line: +	 * debugging.
>, <Line: +	 *
>, <Line: +	 * This method is also available on window, where it can be used to display objects on debug
>, <Line: +	 * console.
>, <Line: +	 *
>, <Line: +	 * @param {*} object - any object to turn into string.
>, <Line: +	 * @return {string} a serialized string of the argument
>, <Line: +	 */
>, <Line: +	angular.mock.dump = function (object) {
>, <Line: +		return serialize(object);
>, <Line: +		function serialize(object) {
>, <Line: +			var out;
>, <Line: +			if (angular.isElement(object)) {
>, <Line: +				object = angular.element(object);
>, <Line: +				out = angular.element('<div></div>');
>, <Line: +				angular.forEach(object, function (element) {
>, <Line: +					out.append(angular.element(element).clone());
>, <Line: +				});
>, <Line: +				out = out.html();
>, <Line: +			} else if (angular.isArray(object)) {
>, <Line: +				out = [];
>, <Line: +				angular.forEach(object, function (o) {
>, <Line: +					out.push(serialize(o));
>, <Line: +				});
>, <Line: +				out = '[ ' + out.join(', ') + ' ]';
>, <Line: +			} else if (angular.isObject(object)) {
>, <Line: +				if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {
>, <Line: +					out = serializeScope(object);
>, <Line: +				} else if (object instanceof Error) {
>, <Line: +					out = object.stack || ('' + object.name + ': ' + object.message);
>, <Line: +				} else {
>, <Line: +					// TODO(i): this prevents methods being logged,
>, <Line: +					// we should have a better way to serialize objects
>, <Line: +					out = angular.toJson(object, true);
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				out = String(object);
>, <Line: +			}
>, <Line: +			return out;
>, <Line: +		}
>, <Line: +		function serializeScope(scope, offset) {
>, <Line: +			offset = offset || '  ';
>, <Line: +			var log = [offset + 'Scope(' + scope.$id + '): {'];
>, <Line: +			for (var key in scope) {
>, <Line: +				if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\$|this)/)) {
>, <Line: +					log.push('  ' + key + ': ' + angular.toJson(scope[key]));
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var child = scope.$$childHead;
>, <Line: +			while (child) {
>, <Line: +				log.push(serializeScope(child, offset + '  '));
>, <Line: +				child = child.$$nextSibling;
>, <Line: +			}
>, <Line: +			log.push('}');
>, <Line: +			return log.join('\n' + offset);
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $httpBackend
>, <Line: +	 * @description
>, <Line: +	 * Fake HTTP backend implementation suitable for unit testing applications that use the
>, <Line: +	 * {@link ng.$http $http service}.
>, <Line: +	 *
>, <Line: +	 * *Note*: For fake HTTP backend implementation suitable for end-to-end testing or backend-less
>, <Line: +	 * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.
>, <Line: +	 *
>, <Line: +	 * During unit testing, we want our unit tests to run quickly and have no external dependencies so
>, <Line: +	 * we don’t want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or
>, <Line: +	 * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is
>, <Line: +	 * to verify whether a certain request has been sent or not, or alternatively just let the
>, <Line: +	 * application make requests, respond with pre-trained responses and assert that the end result is
>, <Line: +	 * what we expect it to be.
>, <Line: +	 *
>, <Line: +	 * This mock implementation can be used to respond with static or dynamic responses via the
>, <Line: +	 * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).
>, <Line: +	 *
>, <Line: +	 * When an Angular application needs some data from a server, it calls the $http service, which
>, <Line: +	 * sends the request to a real server using $httpBackend service. With dependency injection, it is
>, <Line: +	 * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify
>, <Line: +	 * the requests and respond with some testing data without sending a request to a real server.
>, <Line: +	 *
>, <Line: +	 * There are two ways to specify what test data should be returned as http responses by the mock
>, <Line: +	 * backend when the code under test makes http requests:
>, <Line: +	 *
>, <Line: +	 * - `$httpBackend.expect` - specifies a request expectation
>, <Line: +	 * - `$httpBackend.when` - specifies a backend definition
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # Request Expectations vs Backend Definitions
>, <Line: +	 *
>, <Line: +	 * Request expectations provide a way to make assertions about requests made by the application and
>, <Line: +	 * to define responses for those requests. The test will fail if the expected requests are not made
>, <Line: +	 * or they are made in the wrong order.
>, <Line: +	 *
>, <Line: +	 * Backend definitions allow you to define a fake backend for your application which doesn't assert
>, <Line: +	 * if a particular request was made or not, it just returns a trained response if a request is made.
>, <Line: +	 * The test will pass whether or not the request gets made during testing.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * <table class="table">
>, <Line: +	 *   <tr><th width="220px"></th><th>Request expectations</th><th>Backend definitions</th></tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Syntax</th>
>, <Line: +	 *     <td>.expect(...).respond(...)</td>
>, <Line: +	 *     <td>.when(...).respond(...)</td>
>, <Line: +	 *   </tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Typical usage</th>
>, <Line: +	 *     <td>strict unit tests</td>
>, <Line: +	 *     <td>loose (black-box) unit testing</td>
>, <Line: +	 *   </tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Fulfills multiple requests</th>
>, <Line: +	 *     <td>NO</td>
>, <Line: +	 *     <td>YES</td>
>, <Line: +	 *   </tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Order of requests matters</th>
>, <Line: +	 *     <td>YES</td>
>, <Line: +	 *     <td>NO</td>
>, <Line: +	 *   </tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Request required</th>
>, <Line: +	 *     <td>YES</td>
>, <Line: +	 *     <td>NO</td>
>, <Line: +	 *   </tr>
>, <Line: +	 *   <tr>
>, <Line: +	 *     <th>Response required</th>
>, <Line: +	 *     <td>optional (see below)</td>
>, <Line: +	 *     <td>YES</td>
>, <Line: +	 *   </tr>
>, <Line: +	 * </table>
>, <Line: +	 *
>, <Line: +	 * In cases where both backend definitions and request expectations are specified during unit
>, <Line: +	 * testing, the request expectations are evaluated first.
>, <Line: +	 *
>, <Line: +	 * If a request expectation has no response specified, the algorithm will search your backend
>, <Line: +	 * definitions for an appropriate response.
>, <Line: +	 *
>, <Line: +	 * If a request didn't match any expectation or if the expectation doesn't have the response
>, <Line: +	 * defined, the backend definitions are evaluated in sequential order to see if any of them match
>, <Line: +	 * the request. The response from the first matched definition is returned.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # Flushing HTTP requests
>, <Line: +	 *
>, <Line: +	 * The $httpBackend used in production always responds to requests asynchronously. If we preserved
>, <Line: +	 * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,
>, <Line: +	 * to follow and to maintain. But neither can the testing mock respond synchronously; that would
>, <Line: +	 * change the execution of the code under test. For this reason, the mock $httpBackend has a
>, <Line: +	 * `flush()` method, which allows the test to explicitly flush pending requests. This preserves
>, <Line: +	 * the async api of the backend, while allowing the test to execute synchronously.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # Unit testing with mock $httpBackend
>, <Line: +	 * The following code shows how to setup and use the mock backend when unit testing a controller.
>, <Line: +	 * First we create the controller under test:
>, <Line: +	 *
>, <Line: +	 ```js
>, <Line: +	 // The module code
>, <Line: +	 angular
>, <Line: +	 .module('MyApp', [])
>, <Line: +	 .controller('MyController', MyController);
>, <Line: +	 // The controller code
>, <Line: +	 function MyController($scope, $http) {
>, <Line: +	 ```
>, <Line: +	 *
>, <Line: +	 * Now we setup the mock backend and create the test specs:
>, <Line: +	 *
>, <Line: +	 ```js
>, <Line: +	 // testing controller
>, <Line: +	 describe('MyController', function() {
>, <Line: +	 ```
>, <Line: +	 */
>, <Line: +	angular.mock.$HttpBackendProvider = function () {
>, <Line: +		this.$get = ['$rootScope', createHttpBackendMock];
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * General factory function for $httpBackend mock.
>, <Line: +	 * Returns instance for unit testing (when no arguments specified):
>, <Line: +	 *   - passing through is disabled
>, <Line: +	 *   - auto flushing is disabled
>, <Line: +	 *
>, <Line: +	 * Returns instance for e2e testing (when `$delegate` and `$browser` specified):
>, <Line: +	 *   - passing through (delegating request to real backend) is enabled
>, <Line: +	 *   - auto flushing is enabled
>, <Line: +	 *
>, <Line: +	 * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)
>, <Line: +	 * @param {Object=} $browser Auto-flushing enabled if specified
>, <Line: +	 * @return {Object} Instance of $httpBackend mock
>, <Line: +	 */
>, <Line: +	function createHttpBackendMock($rootScope, $delegate, $browser) {
>, <Line: +		var definitions = [],
>, <Line: +			expectations = [],
>, <Line: +			responses = [],
>, <Line: +			responsesPush = angular.bind(responses, responses.push),
>, <Line: +			copy = angular.copy;
>, <Line: +		function createResponse(status, data, headers, statusText) {
>, <Line: +			if (angular.isFunction(status)) return status;
>, <Line: +			return function () {
>, <Line: +				return angular.isNumber(status)
>, <Line: +					? [status, data, headers, statusText]
>, <Line: +					: [200, status, data];
>, <Line: +			};
>, <Line: +		}
>, <Line: +		// TODO(vojta): change params to: method, url, data, headers, callback
>, <Line: +		function $httpBackend(method, url, data, callback, headers, timeout, withCredentials) {
>, <Line: +			var xhr = new MockXhr(),
>, <Line: +				expectation = expectations[0],
>, <Line: +				wasExpected = false;
>, <Line: +			function prettyPrint(data) {
>, <Line: +				return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)
>, <Line: +					? data
>, <Line: +					: angular.toJson(data);
>, <Line: +			}
>, <Line: +			function wrapResponse(wrapped) {
>, <Line: +				if (!$browser && timeout && timeout.then) timeout.then(handleTimeout);
>, <Line: +				return handleResponse;
>, <Line: +				function handleResponse() {
>, <Line: +					var response = wrapped.response(method, url, data, headers);
>, <Line: +					xhr.$$respHeaders = response[2];
>, <Line: +					callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),
>, <Line: +						copy(response[3] || ''));
>, <Line: +				}
>, <Line: +				function handleTimeout() {
>, <Line: +					for (var i = 0, ii = responses.length; i < ii; i++) {
>, <Line: +						if (responses[i] === handleResponse) {
>, <Line: +							responses.splice(i, 1);
>, <Line: +							callback(-1, undefined, '');
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (expectation && expectation.match(method, url)) {
>, <Line: +				if (!expectation.matchData(data))
>, <Line: +					throw new Error('Expected ' + expectation + ' with different data\n' +
>, <Line: +						'EXPECTED: ' + prettyPrint(expectation.data) + '\nGOT:      ' + data);
>, <Line: +				if (!expectation.matchHeaders(headers))
>, <Line: +					throw new Error('Expected ' + expectation + ' with different headers\n' +
>, <Line: +						'EXPECTED: ' + prettyPrint(expectation.headers) + '\nGOT:      ' +
>, <Line: +						prettyPrint(headers));
>, <Line: +				expectations.shift();
>, <Line: +				if (expectation.response) {
>, <Line: +					responses.push(wrapResponse(expectation));
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				wasExpected = true;
>, <Line: +			}
>, <Line: +			var i = -1, definition;
>, <Line: +			while ((definition = definitions[++i])) {
>, <Line: +				if (definition.match(method, url, data, headers || {})) {
>, <Line: +					if (definition.response) {
>, <Line: +						// if $browser specified, we do auto flush all requests
>, <Line: +						($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
>, <Line: +					} else if (definition.passThrough) {
>, <Line: +						$delegate(method, url, data, callback, headers, timeout, withCredentials);
>, <Line: +					} else throw new Error('No response defined !');
>, <Line: +					return;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			throw wasExpected ?
>, <Line: +				new Error('No response defined !') :
>, <Line: +				new Error('Unexpected request: ' + method + ' ' + url + '\n' +
>, <Line: +					(expectation ? 'Expected ' + expectation : 'No more request expected'));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#when
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition.
>, <Line: +		 *
>, <Line: +		 * @param {string} method HTTP method.
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: +		 *   data string and returns true if the data is as expected.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: +		 *   object and returns true if the headers match the current definition.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that controls how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 *
>, <Line: +		 *  - respond –
>, <Line: +		 *      `{function([status,] data[, headers, statusText])
>, <Line: +		 *    – The respond method takes a set of static data to be returned or a function that can
>, <Line: +		 *    return an array containing response status (number), response data (string), response
>, <Line: +		 *    headers (Object), and the text for the status (string). The respond method returns the
>, <Line: +		 *    `requestHandler` object for possible overrides.
>, <Line: +		 */
>, <Line: +		$httpBackend.when = function (method, url, data, headers) {
>, <Line: +			var definition = new MockHttpExpectation(method, url, data, headers),
>, <Line: +				chain = {
>, <Line: +					respond: function (status, data, headers, statusText) {
>, <Line: +						definition.passThrough = undefined;
>, <Line: +						definition.response = createResponse(status, data, headers, statusText);
>, <Line: +						return chain;
>, <Line: +					}
>, <Line: +				};
>, <Line: +			if ($browser) {
>, <Line: +				chain.passThrough = function () {
>, <Line: +					definition.response = undefined;
>, <Line: +					definition.passThrough = true;
>, <Line: +					return chain;
>, <Line: +				};
>, <Line: +			}
>, <Line: +			definitions.push(definition);
>, <Line: +			return chain;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenGET
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for GET requests. For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenHEAD
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for HEAD requests. For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenDELETE
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for DELETE requests. For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenPOST
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for POST requests. For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: +		 *   data string and returns true if the data is as expected.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenPUT
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for PUT requests.  For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: +		 *   data string and returns true if the data is as expected.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#whenJSONP
>, <Line: +		 * @description
>, <Line: +		 * Creates a new backend definition for JSONP requests. For more info see `when()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		createShortMethods('when');
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expect
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation.
>, <Line: +		 *
>, <Line: +		 * @param {string} method HTTP method.
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: +		 *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: +		 *  is in JSON format.
>, <Line: +		 * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: +		 *   object and returns true if the headers match the current expectation.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *  request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *  order to change how a matched request is handled.
>, <Line: +		 *
>, <Line: +		 *  - respond –
>, <Line: +		 *    `{function([status,] data[, headers, statusText])
>, <Line: +		 *    – The respond method takes a set of static data to be returned or a function that can
>, <Line: +		 *    return an array containing response status (number), response data (string), response
>, <Line: +		 *    headers (Object), and the text for the status (string). The respond method returns the
>, <Line: +		 *    `requestHandler` object for possible overrides.
>, <Line: +		 */
>, <Line: +		$httpBackend.expect = function (method, url, data, headers) {
>, <Line: +			var expectation = new MockHttpExpectation(method, url, data, headers),
>, <Line: +				chain = {
>, <Line: +					respond: function (status, data, headers, statusText) {
>, <Line: +						expectation.response = createResponse(status, data, headers, statusText);
>, <Line: +						return chain;
>, <Line: +					}
>, <Line: +				};
>, <Line: +			expectations.push(expectation);
>, <Line: +			return chain;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectGET
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for GET requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 * order to change how a matched request is handled. See #expect for more info.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectHEAD
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for HEAD requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectDELETE
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for DELETE requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectPOST
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for POST requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: +		 *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: +		 *  is in JSON format.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectPUT
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for PUT requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: +		 *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: +		 *  is in JSON format.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectPATCH
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for PATCH requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: +		 *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: +		 *  is in JSON format.
>, <Line: +		 * @param {Object=} headers HTTP headers.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#expectJSONP
>, <Line: +		 * @description
>, <Line: +		 * Creates a new request expectation for JSONP requests. For more info see `expect()`.
>, <Line: +		 *
>, <Line: +		 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +		 *   and returns true if the url match the current definition.
>, <Line: +		 * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: +		 *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: +		 *   order to change how a matched request is handled.
>, <Line: +		 */
>, <Line: +		createShortMethods('expect');
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#flush
>, <Line: +		 * @description
>, <Line: +		 * Flushes all pending requests using the trained responses.
>, <Line: +		 *
>, <Line: +		 * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,
>, <Line: +		 *   all pending requests will be flushed. If there are no pending requests when the flush method
>, <Line: +		 *   is called an exception is thrown (as this typically a sign of programming error).
>, <Line: +		 */
>, <Line: +		$httpBackend.flush = function (count, digest) {
>, <Line: +			if (digest !== false) $rootScope.$digest();
>, <Line: +			if (!responses.length) throw new Error('No pending request to flush !');
>, <Line: +			if (angular.isDefined(count) && count !== null) {
>, <Line: +				while (count--) {
>, <Line: +					if (!responses.length) throw new Error('No more pending request to flush !');
>, <Line: +					responses.shift()();
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				while (responses.length) {
>, <Line: +					responses.shift()();
>, <Line: +				}
>, <Line: +			}
>, <Line: +			$httpBackend.verifyNoOutstandingExpectation(digest);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#verifyNoOutstandingExpectation
>, <Line: +		 * @description
>, <Line: +		 * Verifies that all of the requests defined via the `expect` api were made. If any of the
>, <Line: +		 * requests were not made, verifyNoOutstandingExpectation throws an exception.
>, <Line: +		 *
>, <Line: +		 * Typically, you would call this method following each test case that asserts requests using an
>, <Line: +		 * "afterEach" clause.
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 *   afterEach($httpBackend.verifyNoOutstandingExpectation);
>, <Line: +		 * ```
>, <Line: +		 */
>, <Line: +		$httpBackend.verifyNoOutstandingExpectation = function (digest) {
>, <Line: +			if (digest !== false) $rootScope.$digest();
>, <Line: +			if (expectations.length) {
>, <Line: +				throw new Error('Unsatisfied requests: ' + expectations.join(', '));
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#verifyNoOutstandingRequest
>, <Line: +		 * @description
>, <Line: +		 * Verifies that there are no outstanding requests that need to be flushed.
>, <Line: +		 *
>, <Line: +		 * Typically, you would call this method following each test case that asserts requests using an
>, <Line: +		 * "afterEach" clause.
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 *   afterEach($httpBackend.verifyNoOutstandingRequest);
>, <Line: +		 * ```
>, <Line: +		 */
>, <Line: +		$httpBackend.verifyNoOutstandingRequest = function () {
>, <Line: +			if (responses.length) {
>, <Line: +				throw new Error('Unflushed requests: ' + responses.length);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpBackend#resetExpectations
>, <Line: +		 * @description
>, <Line: +		 * Resets all request expectations, but preserves all backend definitions. Typically, you would
>, <Line: +		 * call resetExpectations during a multiple-phase test when you want to reuse the same instance of
>, <Line: +		 * $httpBackend mock.
>, <Line: +		 */
>, <Line: +		$httpBackend.resetExpectations = function () {
>, <Line: +			expectations.length = 0;
>, <Line: +			responses.length = 0;
>, <Line: +		};
>, <Line: +		return $httpBackend;
>, <Line: +		function createShortMethods(prefix) {
>, <Line: +			angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function (method) {
>, <Line: +				$httpBackend[prefix + method] = function (url, headers) {
>, <Line: +					return $httpBackend[prefix](method, url, undefined, headers);
>, <Line: +				};
>, <Line: +			});
>, <Line: +			angular.forEach(['PUT', 'POST', 'PATCH'], function (method) {
>, <Line: +				$httpBackend[prefix + method] = function (url, data, headers) {
>, <Line: +					return $httpBackend[prefix](method, url, data, headers);
>, <Line: +				};
>, <Line: +			});
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function MockHttpExpectation(method, url, data, headers) {
>, <Line: +		this.data = data;
>, <Line: +		this.headers = headers;
>, <Line: +		this.match = function (m, u, d, h) {
>, <Line: +			if (method != m) return false;
>, <Line: +			if (!this.matchUrl(u)) return false;
>, <Line: +			if (angular.isDefined(d) && !this.matchData(d)) return false;
>, <Line: +			if (angular.isDefined(h) && !this.matchHeaders(h)) return false;
>, <Line: +			return true;
>, <Line: +		};
>, <Line: +		this.matchUrl = function (u) {
>, <Line: +			if (!url) return true;
>, <Line: +			if (angular.isFunction(url.test)) return url.test(u);
>, <Line: +			if (angular.isFunction(url)) return url(u);
>, <Line: +			return url == u;
>, <Line: +		};
>, <Line: +		this.matchHeaders = function (h) {
>, <Line: +			if (angular.isUndefined(headers)) return true;
>, <Line: +			if (angular.isFunction(headers)) return headers(h);
>, <Line: +			return angular.equals(headers, h);
>, <Line: +		};
>, <Line: +		this.matchData = function (d) {
>, <Line: +			if (angular.isUndefined(data)) return true;
>, <Line: +			if (data && angular.isFunction(data.test)) return data.test(d);
>, <Line: +			if (data && angular.isFunction(data)) return data(d);
>, <Line: +			if (data && !angular.isString(data)) {
>, <Line: +				return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
>, <Line: +			}
>, <Line: +			return data == d;
>, <Line: +		};
>, <Line: +		this.toString = function () {
>, <Line: +			return method + ' ' + url;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function createMockXhr() {
>, <Line: +		return new MockXhr();
>, <Line: +	}
>, <Line: +	function MockXhr() {
>, <Line: +		// hack for testing $http, $httpBackend
>, <Line: +		MockXhr.$$lastInstance = this;
>, <Line: +		this.open = function (method, url, async) {
>, <Line: +			this.$$method = method;
>, <Line: +			this.$$url = url;
>, <Line: +			this.$$async = async;
>, <Line: +			this.$$reqHeaders = {};
>, <Line: +			this.$$respHeaders = {};
>, <Line: +		};
>, <Line: +		this.send = function (data) {
>, <Line: +			this.$$data = data;
>, <Line: +		};
>, <Line: +		this.setRequestHeader = function (key, value) {
>, <Line: +			this.$$reqHeaders[key] = value;
>, <Line: +		};
>, <Line: +		this.getResponseHeader = function (name) {
>, <Line: +			// the lookup must be case insensitive,
>, <Line: +			// that's why we try two quick lookups first and full scan last
>, <Line: +			var header = this.$$respHeaders[name];
>, <Line: +			if (header) return header;
>, <Line: +			name = angular.lowercase(name);
>, <Line: +			header = this.$$respHeaders[name];
>, <Line: +			if (header) return header;
>, <Line: +			header = undefined;
>, <Line: +			angular.forEach(this.$$respHeaders, function (headerVal, headerName) {
>, <Line: +				if (!header && angular.lowercase(headerName) == name) header = headerVal;
>, <Line: +			});
>, <Line: +			return header;
>, <Line: +		};
>, <Line: +		this.getAllResponseHeaders = function () {
>, <Line: +			var lines = [];
>, <Line: +			angular.forEach(this.$$respHeaders, function (value, key) {
>, <Line: +				lines.push(key + ': ' + value);
>, <Line: +			});
>, <Line: +			return lines.join('\n');
>, <Line: +		};
>, <Line: +		this.abort = angular.noop;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $timeout
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * This service is just a simple decorator for {@link ng.$timeout $timeout} service
>, <Line: +	 * that adds a "flush" and "verifyNoPendingTasks" methods.
>, <Line: +	 */
>, <Line: +	angular.mock.$TimeoutDecorator = ['$delegate', '$browser', function ($delegate, $browser) {
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $timeout#flush
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * Flushes the queue of pending tasks.
>, <Line: +		 *
>, <Line: +		 * @param {number=} delay maximum timeout amount to flush up until
>, <Line: +		 */
>, <Line: +		$delegate.flush = function (delay) {
>, <Line: +			$browser.defer.flush(delay);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $timeout#verifyNoPendingTasks
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * Verifies that there are no pending tasks that need to be flushed.
>, <Line: +		 */
>, <Line: +		$delegate.verifyNoPendingTasks = function () {
>, <Line: +			if ($browser.deferredFns.length) {
>, <Line: +				throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +
>, <Line: +					formatPendingTasksAsString($browser.deferredFns));
>, <Line: +			}
>, <Line: +		};
>, <Line: +		function formatPendingTasksAsString(tasks) {
>, <Line: +			var result = [];
>, <Line: +			angular.forEach(tasks, function (task) {
>, <Line: +				result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');
>, <Line: +			});
>, <Line: +			return result.join(', ');
>, <Line: +		}
>, <Line: +		return $delegate;
>, <Line: +	}];
>, <Line: +	angular.mock.$RAFDecorator = ['$delegate', function ($delegate) {
>, <Line: +		var queue = [];
>, <Line: +		var rafFn = function (fn) {
>, <Line: +			var index = queue.length;
>, <Line: +			queue.push(fn);
>, <Line: +			return function () {
>, <Line: +				queue.splice(index, 1);
>, <Line: +			};
>, <Line: +		};
>, <Line: +		rafFn.supported = $delegate.supported;
>, <Line: +		rafFn.flush = function () {
>, <Line: +			if (queue.length === 0) {
>, <Line: +				throw new Error('No rAF callbacks present');
>, <Line: +			}
>, <Line: +			var length = queue.length;
>, <Line: +			for (var i = 0; i < length; i++) {
>, <Line: +				queue[i]();
>, <Line: +			}
>, <Line: +			queue = [];
>, <Line: +		};
>, <Line: +		return rafFn;
>, <Line: +	}];
>, <Line: +	angular.mock.$AsyncCallbackDecorator = ['$delegate', function ($delegate) {
>, <Line: +		var callbacks = [];
>, <Line: +		var addFn = function (fn) {
>, <Line: +			callbacks.push(fn);
>, <Line: +		};
>, <Line: +		addFn.flush = function () {
>, <Line: +			angular.forEach(callbacks, function (fn) {
>, <Line: +				fn();
>, <Line: +			});
>, <Line: +			callbacks = [];
>, <Line: +		};
>, <Line: +		return addFn;
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	angular.mock.$RootElementProvider = function () {
>, <Line: +		this.$get = function () {
>, <Line: +			return angular.element('<div ng-app></div>');
>, <Line: +		};
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc module
>, <Line: +	 * @name ngMock
>, <Line: +	 * @packageName angular-mocks
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * # ngMock
>, <Line: +	 *
>, <Line: +	 * The `ngMock` module provides support to inject and mock Angular services into unit tests.
>, <Line: +	 * In addition, ngMock also extends various core ng services such that they can be
>, <Line: +	 * inspected and controlled in a synchronous manner within test code.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * <div doc-module-components="ngMock"></div>
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	angular.module('ngMock', ['ng']).provider({
>, <Line: +		$browser: angular.mock.$BrowserProvider,
>, <Line: +		$exceptionHandler: angular.mock.$ExceptionHandlerProvider,
>, <Line: +		$log: angular.mock.$LogProvider,
>, <Line: +		$interval: angular.mock.$IntervalProvider,
>, <Line: +		$httpBackend: angular.mock.$HttpBackendProvider,
>, <Line: +		$rootElement: angular.mock.$RootElementProvider
>, <Line: +	}).config(['$provide', function ($provide) {
>, <Line: +		$provide.decorator('$timeout', angular.mock.$TimeoutDecorator);
>, <Line: +		$provide.decorator('$$rAF', angular.mock.$RAFDecorator);
>, <Line: +		$provide.decorator('$$asyncCallback', angular.mock.$AsyncCallbackDecorator);
>, <Line: +		$provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);
>, <Line: +	}]);
>, <Line: +	/**
>, <Line: +	 * @ngdoc module
>, <Line: +	 * @name ngMockE2E
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @packageName angular-mocks
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.
>, <Line: +	 * Currently there is only one mock present in this module -
>, <Line: +	 * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.
>, <Line: +	 */
>, <Line: +	angular.module('ngMockE2E', ['ng']).config(['$provide', function ($provide) {
>, <Line: +		$provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);
>, <Line: +	}]);
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $httpBackend
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of
>, <Line: +	 * applications that use the {@link ng.$http $http service}.
>, <Line: +	 *
>, <Line: +	 * *Note*: For fake http backend implementation suitable for unit testing please see
>, <Line: +	 * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.
>, <Line: +	 *
>, <Line: +	 * This implementation can be used to respond with static or dynamic responses via the `when` api
>, <Line: +	 * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the
>, <Line: +	 * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch
>, <Line: +	 * templates from a webserver).
>, <Line: +	 *
>, <Line: +	 * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application
>, <Line: +	 * is being developed with the real backend api replaced with a mock, it is often desirable for
>, <Line: +	 * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch
>, <Line: +	 * templates or static files from the webserver). To configure the backend with this behavior
>, <Line: +	 * use the `passThrough` request handler of `when` instead of `respond`.
>, <Line: +	 *
>, <Line: +	 * Additionally, we don't want to manually have to flush mocked out requests like we do during unit
>, <Line: +	 * testing. For this reason the e2e $httpBackend flushes mocked out requests
>, <Line: +	 * automatically, closely simulating the behavior of the XMLHttpRequest object.
>, <Line: +	 *
>, <Line: +	 * To setup the application to run with this http backend, you have to create a module that depends
>, <Line: +	 * on the `ngMockE2E` and your application modules and defines the fake backend:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);
>, <Line: +	 *   myAppDev.run(function($httpBackend) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Afterwards, bootstrap your app with this new module.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#when
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition.
>, <Line: +	 *
>, <Line: +	 * @param {string} method HTTP method.
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(string|RegExp)=} data HTTP request body.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: +	 *   object and returns true if the headers match the current definition.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 *
>, <Line: +	 *  - respond –
>, <Line: +	 *    `{function([status,] data[, headers, statusText])
>, <Line: +	 *    – The respond method takes a set of static data to be returned or a function that can return
>, <Line: +	 *    an array containing response status (number), response data (string), response headers
>, <Line: +	 *    (Object), and the text for the status (string).
>, <Line: +	 *  - passThrough – `{function()}` – Any request matching a backend definition with
>, <Line: +	 *    `passThrough` handler will be passed through to the real backend (an XHR request will be made
>, <Line: +	 *    to the server.)
>, <Line: +	 *  - Both methods return the `requestHandler` object for possible overrides.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenGET
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for GET requests. For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenHEAD
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for HEAD requests. For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenDELETE
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for DELETE requests. For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenPOST
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for POST requests. For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(string|RegExp)=} data HTTP request body.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenPUT
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for PUT requests.  For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(string|RegExp)=} data HTTP request body.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenPATCH
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for PATCH requests.  For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @param {(string|RegExp)=} data HTTP request body.
>, <Line: +	 * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $httpBackend#whenJSONP
>, <Line: +	 * @module ngMockE2E
>, <Line: +	 * @description
>, <Line: +	 * Creates a new backend definition for JSONP requests. For more info see `when()`.
>, <Line: +	 *
>, <Line: +	 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: +	 *   and returns true if the url match the current definition.
>, <Line: +	 * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: +	 *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: +	 *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: +	 */
>, <Line: +	angular.mock.e2e = {};
>, <Line: +	angular.mock.e2e.$httpBackendDecorator =
>, <Line: +		['$rootScope', '$delegate', '$browser', createHttpBackendMock];
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name $rootScope.Scope
>, <Line: +	 * @module ngMock
>, <Line: +	 * @description
>, <Line: +	 * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These
>, <Line: +	 * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when
>, <Line: +	 * `ngMock` module is loaded.
>, <Line: +	 *
>, <Line: +	 * In addition to all the regular `Scope` methods, the following helper methods are available:
>, <Line: +	 */
>, <Line: +	angular.mock.$RootScopeDecorator = function ($delegate) {
>, <Line: +		var $rootScopePrototype = Object.getPrototypeOf($delegate);
>, <Line: +		$rootScopePrototype.$countChildScopes = countChildScopes;
>, <Line: +		$rootScopePrototype.$countWatchers = countWatchers;
>, <Line: +		return $delegate;
>, <Line: +		// ------------------------------------------------------------------------------------------ //
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $rootScope.Scope#$countChildScopes
>, <Line: +		 * @module ngMock
>, <Line: +		 * @description
>, <Line: +		 * Counts all the direct and indirect child scopes of the current scope.
>, <Line: +		 *
>, <Line: +		 * The current scope is excluded from the count. The count includes all isolate child scopes.
>, <Line: +		 *
>, <Line: +		 * @returns {number} Total number of child scopes.
>, <Line: +		 */
>, <Line: +		function countChildScopes() {
>, <Line: +			// jshint validthis: true
>, <Line: +			var count = 0; // exclude the current scope
>, <Line: +			var pendingChildHeads = [this.$$childHead];
>, <Line: +			var currentScope;
>, <Line: +			while (pendingChildHeads.length) {
>, <Line: +				currentScope = pendingChildHeads.shift();
>, <Line: +				while (currentScope) {
>, <Line: +					count += 1;
>, <Line: +					pendingChildHeads.push(currentScope.$$childHead);
>, <Line: +					currentScope = currentScope.$$nextSibling;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return count;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $rootScope.Scope#$countWatchers
>, <Line: +		 * @module ngMock
>, <Line: +		 * @description
>, <Line: +		 * Counts all the watchers of direct and indirect child scopes of the current scope.
>, <Line: +		 *
>, <Line: +		 * The watchers of the current scope are included in the count and so are all the watchers of
>, <Line: +		 * isolate child scopes.
>, <Line: +		 *
>, <Line: +		 * @returns {number} Total number of watchers.
>, <Line: +		 */
>, <Line: +		function countWatchers() {
>, <Line: +			// jshint validthis: true
>, <Line: +			var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope
>, <Line: +			var pendingChildHeads = [this.$$childHead];
>, <Line: +			var currentScope;
>, <Line: +			while (pendingChildHeads.length) {
>, <Line: +				currentScope = pendingChildHeads.shift();
>, <Line: +				while (currentScope) {
>, <Line: +					count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
>, <Line: +					pendingChildHeads.push(currentScope.$$childHead);
>, <Line: +					currentScope = currentScope.$$nextSibling;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return count;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	if (window.jasmine || window.mocha) {
>, <Line: +		var currentSpec = null,
>, <Line: +			isSpecRunning = function () {
>, <Line: +				return !!currentSpec;
>, <Line: +			};
>, <Line: +		(window.beforeEach || window.setup)(function () {
>, <Line: +			currentSpec = this;
>, <Line: +		});
>, <Line: +		(window.afterEach || window.teardown)(function () {
>, <Line: +			var injector = currentSpec.$injector;
>, <Line: +			angular.forEach(currentSpec.$modules, function (module) {
>, <Line: +				if (module && module.$$hashKey) {
>, <Line: +					module.$$hashKey = undefined;
>, <Line: +				}
>, <Line: +			});
>, <Line: +			currentSpec.$injector = null;
>, <Line: +			currentSpec.$modules = null;
>, <Line: +			currentSpec = null;
>, <Line: +			if (injector) {
>, <Line: +				injector.get('$rootElement').off();
>, <Line: +				injector.get('$browser').pollFns.length = 0;
>, <Line: +			}
>, <Line: +			// clean up jquery's fragment cache
>, <Line: +			angular.forEach(angular.element.fragments, function (val, key) {
>, <Line: +				delete angular.element.fragments[key];
>, <Line: +			});
>, <Line: +			MockXhr.$$lastInstance = null;
>, <Line: +			angular.forEach(angular.callbacks, function (val, key) {
>, <Line: +				delete angular.callbacks[key];
>, <Line: +			});
>, <Line: +			angular.callbacks.counter = 0;
>, <Line: +		});
>, <Line: +		/**
>, <Line: +		 * @ngdoc function
>, <Line: +		 * @name angular.mock.module
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * *NOTE*: This function is also published on window for easy access.<br>
>, <Line: +		 * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
>, <Line: +		 *
>, <Line: +		 * This function registers a module configuration code. It collects the configuration information
>, <Line: +		 * which will be used when the injector is created by {@link angular.mock.inject inject}.
>, <Line: +		 *
>, <Line: +		 * See {@link angular.mock.inject inject} for usage example
>, <Line: +		 *
>, <Line: +		 * @param {...(string|Function|Object)} fns any number of modules which are represented as string
>, <Line: +		 *        aliases or as anonymous module initialization functions. The modules are used to
>, <Line: +		 *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an
>, <Line: +		 *        object literal is passed they will be registered as values in the module, the key being
>, <Line: +		 *        the module name and the value being what is returned.
>, <Line: +		 */
>, <Line: +		window.module = angular.mock.module = function () {
>, <Line: +			var moduleFns = Array.prototype.slice.call(arguments, 0);
>, <Line: +			return isSpecRunning() ? workFn() : workFn;
>, <Line: +			/////////////////////
>, <Line: +			function workFn() {
>, <Line: +				if (currentSpec.$injector) {
>, <Line: +					throw new Error('Injector already created, can not register a module!');
>, <Line: +				} else {
>, <Line: +					var modules = currentSpec.$modules || (currentSpec.$modules = []);
>, <Line: +					angular.forEach(moduleFns, function (module) {
>, <Line: +						if (angular.isObject(module) && !angular.isArray(module)) {
>, <Line: +							modules.push(function ($provide) {
>, <Line: +								angular.forEach(module, function (value, key) {
>, <Line: +									$provide.value(key, value);
>, <Line: +								});
>, <Line: +							});
>, <Line: +						} else {
>, <Line: +							modules.push(module);
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc function
>, <Line: +		 * @name angular.mock.inject
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * *NOTE*: This function is also published on window for easy access.<br>
>, <Line: +		 * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
>, <Line: +		 *
>, <Line: +		 * The inject function wraps a function into an injectable function. The inject() creates new
>, <Line: +		 * instance of {@link auto.$injector $injector} per test, which is then used for
>, <Line: +		 * resolving references.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ## Resolving References (Underscore Wrapping)
>, <Line: +		 * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this
>, <Line: +		 * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable
>, <Line: +		 * that is declared in the scope of the `describe()` block. Since we would, most likely, want
>, <Line: +		 * the variable to have the same name of the reference we have a problem, since the parameter
>, <Line: +		 * to the `inject()` function would hide the outer variable.
>, <Line: +		 *
>, <Line: +		 * To help with this, the injected parameters can, optionally, be enclosed with underscores.
>, <Line: +		 * These are ignored by the injector when the reference name is resolved.
>, <Line: +		 *
>, <Line: +		 * For example, the parameter `_myService_` would be resolved as the reference `myService`.
>, <Line: +		 * Since it is available in the function body as _myService_, we can then assign it to a variable
>, <Line: +		 * defined in an outer scope.
>, <Line: +		 *
>, <Line: +		 * ```
>, <Line: +		 * // Defined out reference variable outside
>, <Line: +		 * var myService;
>, <Line: +		 *
>, <Line: +		 * // Wrap the parameter in underscores
>, <Line: +		 * beforeEach( inject( function(_myService_){
>, <Line: +		 *
>, <Line: +		 * // Use myService in a series of tests.
>, <Line: +		 * it('makes use of myService', function() {
>, <Line: +		 *
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * See also {@link angular.mock.module angular.mock.module}
>, <Line: +		 *
>, <Line: +		 * ## Example
>, <Line: +		 * Example of what a typical jasmine tests looks like with the inject method.
>, <Line: +		 * ```js
>, <Line: +		 *
>, <Line: +		 *   angular.module('myApplicationModule', [])
>, <Line: +		 *       .value('mode', 'app')
>, <Line: +		 *       .value('version', 'v1.0.1');
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 *   describe('MyApp', function() {
>, <Line: +		 *
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {...Function} fns any number of functions which will be injected using the injector.
>, <Line: +		 */
>, <Line: +		var ErrorAddingDeclarationLocationStack = function (e, errorForStack) {
>, <Line: +			this.message = e.message;
>, <Line: +			this.name = e.name;
>, <Line: +			if (e.line) this.line = e.line;
>, <Line: +			if (e.sourceId) this.sourceId = e.sourceId;
>, <Line: +			if (e.stack && errorForStack)
>, <Line: +				this.stack = e.stack + '\n' + errorForStack.stack;
>, <Line: +			if (e.stackArray) this.stackArray = e.stackArray;
>, <Line: +		};
>, <Line: +		ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;
>, <Line: +		window.inject = angular.mock.inject = function () {
>, <Line: +			var blockFns = Array.prototype.slice.call(arguments, 0);
>, <Line: +			var errorForStack = new Error('Declaration Location');
>, <Line: +			return isSpecRunning() ? workFn.call(currentSpec) : workFn;
>, <Line: +			/////////////////////
>, <Line: +			function workFn() {
>, <Line: +				var modules = currentSpec.$modules || [];
>, <Line: +				var strictDi = !!currentSpec.$injectorStrict;
>, <Line: +				modules.unshift('ngMock');
>, <Line: +				modules.unshift('ng');
>, <Line: +				var injector = currentSpec.$injector;
>, <Line: +				if (!injector) {
>, <Line: +					if (strictDi) {
>, <Line: +						// If strictDi is enabled, annotate the providerInjector blocks
>, <Line: +						angular.forEach(modules, function (moduleFn) {
>, <Line: +							if (typeof moduleFn === "function") {
>, <Line: +								angular.injector.$$annotate(moduleFn);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +					injector = currentSpec.$injector = angular.injector(modules, strictDi);
>, <Line: +					currentSpec.$injectorStrict = strictDi;
>, <Line: +				}
>, <Line: +				for (var i = 0, ii = blockFns.length; i < ii; i++) {
>, <Line: +					if (currentSpec.$injectorStrict) {
>, <Line: +						// If the injector is strict / strictDi, and the spec wants to inject using automatic
>, <Line: +						// annotation, then annotate the function here.
>, <Line: +						injector.annotate(blockFns[i]);
>, <Line: +					}
>, <Line: +					try {
>, <Line: +						/* jshint -W040 */
>, <Line: +						/* Jasmine explicitly provides a `this` object when calling functions */
>, <Line: +						injector.invoke(blockFns[i] || angular.noop, this);
>, <Line: +						/* jshint +W040 */
>, <Line: +					} catch (e) {
>, <Line: +						if (e.stack && errorForStack) {
>, <Line: +							throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
>, <Line: +						}
>, <Line: +						throw e;
>, <Line: +					} finally {
>, <Line: +						errorForStack = null;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +		angular.mock.inject.strictDi = function (value) {
>, <Line: +			value = arguments.length ? !!value : true;
>, <Line: +			return isSpecRunning() ? workFn() : workFn;
>, <Line: +			function workFn() {
>, <Line: +				if (value !== currentSpec.$injectorStrict) {
>, <Line: +					if (currentSpec.$injector) {
>, <Line: +						throw new Error('Injector already created, can not modify strict annotations');
>, <Line: +					} else {
>, <Line: +						currentSpec.$injectorStrict = value;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>]
[<Line: -(function(window, angular, undefined) {
>, <Line: -'use strict';
>, <Line: -/**
>, <Line: - * @ngdoc object
>, <Line: - * @name angular.mock
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Namespace from 'angular-mocks.js' which contains testing related code.
>, <Line: - */
>, <Line: -angular.mock = {};
>, <Line: -/**
>, <Line: - * ! This is a private undocumented service !
>, <Line: - *
>, <Line: - * @name $browser
>, <Line: - *
>, <Line: - * @description
>, <Line: - * This service is a mock implementation of {@link ng.$browser}. It provides fake
>, <Line: - * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,
>, <Line: - * cookies, etc...
>, <Line: - *
>, <Line: - * The api of this service is the same as that of the real {@link ng.$browser $browser}, except
>, <Line: - * that there are several helper methods available which can be used in tests.
>, <Line: - */
>, <Line: -angular.mock.$BrowserProvider = function() {
>, <Line: -  this.$get = function() {
>, <Line: -    return new angular.mock.$Browser();
>, <Line: -  };
>, <Line: -};
>, <Line: -angular.mock.$Browser = function() {
>, <Line: -  var self = this;
>, <Line: -  this.isMock = true;
>, <Line: -  self.$$url = "http://server/";
>, <Line: -  self.$$lastUrl = self.$$url; // used by url polling fn
>, <Line: -  self.pollFns = [];
>, <Line: -  // TODO(vojta): remove this temporary api
>, <Line: -  self.$$completeOutstandingRequest = angular.noop;
>, <Line: -  self.$$incOutstandingRequestCount = angular.noop;
>, <Line: -  // register url polling fn
>, <Line: -  self.onUrlChange = function(listener) {
>, <Line: -    self.pollFns.push(
>, <Line: -      function() {
>, <Line: -        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
>, <Line: -          self.$$lastUrl = self.$$url;
>, <Line: -          self.$$lastState = self.$$state;
>, <Line: -          listener(self.$$url, self.$$state);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    );
>, <Line: -    return listener;
>, <Line: -  };
>, <Line: -  self.$$checkUrlChange = angular.noop;
>, <Line: -  self.cookieHash = {};
>, <Line: -  self.lastCookieHash = {};
>, <Line: -  self.deferredFns = [];
>, <Line: -  self.deferredNextId = 0;
>, <Line: -  self.defer = function(fn, delay) {
>, <Line: -    delay = delay || 0;
>, <Line: -    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});
>, <Line: -    self.deferredFns.sort(function(a, b) { return a.time - b.time;});
>, <Line: -    return self.deferredNextId++;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @name $browser#defer.now
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Current milliseconds mock time.
>, <Line: -   */
>, <Line: -  self.defer.now = 0;
>, <Line: -  self.defer.cancel = function(deferId) {
>, <Line: -    var fnIndex;
>, <Line: -    angular.forEach(self.deferredFns, function(fn, index) {
>, <Line: -      if (fn.id === deferId) fnIndex = index;
>, <Line: -    });
>, <Line: -    if (fnIndex !== undefined) {
>, <Line: -      self.deferredFns.splice(fnIndex, 1);
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    return false;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @name $browser#defer.flush
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Flushes all pending requests and executes the defer callbacks.
>, <Line: -   *
>, <Line: -   * @param {number=} number of milliseconds to flush. See {@link #defer.now}
>, <Line: -   */
>, <Line: -  self.defer.flush = function(delay) {
>, <Line: -    if (angular.isDefined(delay)) {
>, <Line: -      self.defer.now += delay;
>, <Line: -    } else {
>, <Line: -      if (self.deferredFns.length) {
>, <Line: -        self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
>, <Line: -      } else {
>, <Line: -        throw new Error('No deferred tasks to be flushed');
>, <Line: -      }
>, <Line: -    }
>, <Line: -    while (self.deferredFns.length && self.deferredFns[0].time <= self.defer.now) {
>, <Line: -      self.deferredFns.shift().fn();
>, <Line: -    }
>, <Line: -  };
>, <Line: -  self.$$baseHref = '/';
>, <Line: -  self.baseHref = function() {
>, <Line: -    return this.$$baseHref;
>, <Line: -  };
>, <Line: -};
>, <Line: -angular.mock.$Browser.prototype = {
>, <Line: -/**
>, <Line: -  * @name $browser#poll
>, <Line: -  *
>, <Line: -  * @description
>, <Line: -  * run all fns in pollFns
>, <Line: -  */
>, <Line: -  poll: function poll() {
>, <Line: -    angular.forEach(this.pollFns, function(pollFn) {
>, <Line: -      pollFn();
>, <Line: -    });
>, <Line: -  },
>, <Line: -  addPollFn: function(pollFn) {
>, <Line: -    this.pollFns.push(pollFn);
>, <Line: -    return pollFn;
>, <Line: -  },
>, <Line: -  url: function(url, replace, state) {
>, <Line: -    if (angular.isUndefined(state)) {
>, <Line: -      state = null;
>, <Line: -    }
>, <Line: -    if (url) {
>, <Line: -      this.$$url = url;
>, <Line: -      // Native pushState serializes & copies the object; simulate it.
>, <Line: -      this.$$state = angular.copy(state);
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    return this.$$url;
>, <Line: -  },
>, <Line: -  state: function() {
>, <Line: -    return this.$$state;
>, <Line: -  },
>, <Line: -  cookies:  function(name, value) {
>, <Line: -    if (name) {
>, <Line: -      if (angular.isUndefined(value)) {
>, <Line: -        delete this.cookieHash[name];
>, <Line: -      } else {
>, <Line: -        if (angular.isString(value) &&       //strings only
>, <Line: -            value.length <= 4096) {          //strict cookie storage limits
>, <Line: -          this.cookieHash[name] = value;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      if (!angular.equals(this.cookieHash, this.lastCookieHash)) {
>, <Line: -        this.lastCookieHash = angular.copy(this.cookieHash);
>, <Line: -        this.cookieHash = angular.copy(this.cookieHash);
>, <Line: -      }
>, <Line: -      return this.cookieHash;
>, <Line: -    }
>, <Line: -  },
>, <Line: -  notifyWhenNoOutstandingRequests: function(fn) {
>, <Line: -    fn();
>, <Line: -  }
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $exceptionHandlerProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors
>, <Line: - * passed to the `$exceptionHandler`.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $exceptionHandler
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed
>, <Line: - * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration
>, <Line: - * information.
>, <Line: - *
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   describe('$exceptionHandlerProvider', function() {
>, <Line: - * ```
>, <Line: - */
>, <Line: -angular.mock.$ExceptionHandlerProvider = function() {
>, <Line: -  var handler;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $exceptionHandlerProvider#mode
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the logging mode.
>, <Line: -   *
>, <Line: -   * @param {string} mode Mode of operation, defaults to `rethrow`.
>, <Line: -   *
>, <Line: -   *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there
>, <Line: -   *                is a bug in the application or test, so this mock will make these tests fail.
>, <Line: -   *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`
>, <Line: -   *            mode stores an array of errors in `$exceptionHandler.errors`, to allow later
>, <Line: -   *            assertion of them. See {@link ngMock.$log#assertEmpty assertEmpty()} and
>, <Line: -   *            {@link ngMock.$log#reset reset()}
>, <Line: -   */
>, <Line: -  this.mode = function(mode) {
>, <Line: -    switch (mode) {
>, <Line: -      case 'rethrow':
>, <Line: -        handler = function(e) {
>, <Line: -          throw e;
>, <Line: -        };
>, <Line: -        break;
>, <Line: -      case 'log':
>, <Line: -        var errors = [];
>, <Line: -        handler = function(e) {
>, <Line: -          if (arguments.length == 1) {
>, <Line: -            errors.push(e);
>, <Line: -          } else {
>, <Line: -            errors.push([].slice.call(arguments, 0));
>, <Line: -          }
>, <Line: -        };
>, <Line: -        handler.errors = errors;
>, <Line: -        break;
>, <Line: -      default:
>, <Line: -        throw new Error("Unknown mode '" + mode + "', only 'log'/'rethrow' modes are allowed!");
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$get = function() {
>, <Line: -    return handler;
>, <Line: -  };
>, <Line: -  this.mode('rethrow');
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $log
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays
>, <Line: - * (one array per logging level). These arrays are exposed as `logs` property of each of the
>, <Line: - * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.
>, <Line: - *
>, <Line: - */
>, <Line: -angular.mock.$LogProvider = function() {
>, <Line: -  var debug = true;
>, <Line: -  function concat(array1, array2, index) {
>, <Line: -    return array1.concat(Array.prototype.slice.call(array2, index));
>, <Line: -  }
>, <Line: -  this.debugEnabled = function(flag) {
>, <Line: -    if (angular.isDefined(flag)) {
>, <Line: -      debug = flag;
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return debug;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$get = function() {
>, <Line: -    var $log = {
>, <Line: -      log: function() { $log.log.logs.push(concat([], arguments, 0)); },
>, <Line: -      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },
>, <Line: -      info: function() { $log.info.logs.push(concat([], arguments, 0)); },
>, <Line: -      error: function() { $log.error.logs.push(concat([], arguments, 0)); },
>, <Line: -      debug: function() {
>, <Line: -        if (debug) {
>, <Line: -          $log.debug.logs.push(concat([], arguments, 0));
>, <Line: -        }
>, <Line: -      }
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $log#reset
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Reset all of the logging arrays to empty.
>, <Line: -     */
>, <Line: -    $log.reset = function() {
>, <Line: -      /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $log#log.logs
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Array of messages logged using {@link ng.$log#log `log()`}.
>, <Line: -       *
>, <Line: -       * @example
>, <Line: -       * ```js
>, <Line: -       * $log.log('Some Log');
>, <Line: -       * var first = $log.log.logs.unshift();
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      $log.log.logs = [];
>, <Line: -      /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $log#info.logs
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Array of messages logged using {@link ng.$log#info `info()`}.
>, <Line: -       *
>, <Line: -       * @example
>, <Line: -       * ```js
>, <Line: -       * $log.info('Some Info');
>, <Line: -       * var first = $log.info.logs.unshift();
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      $log.info.logs = [];
>, <Line: -      /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $log#warn.logs
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Array of messages logged using {@link ng.$log#warn `warn()`}.
>, <Line: -       *
>, <Line: -       * @example
>, <Line: -       * ```js
>, <Line: -       * $log.warn('Some Warning');
>, <Line: -       * var first = $log.warn.logs.unshift();
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      $log.warn.logs = [];
>, <Line: -      /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $log#error.logs
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Array of messages logged using {@link ng.$log#error `error()`}.
>, <Line: -       *
>, <Line: -       * @example
>, <Line: -       * ```js
>, <Line: -       * $log.error('Some Error');
>, <Line: -       * var first = $log.error.logs.unshift();
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      $log.error.logs = [];
>, <Line: -        /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $log#debug.logs
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Array of messages logged using {@link ng.$log#debug `debug()`}.
>, <Line: -       *
>, <Line: -       * @example
>, <Line: -       * ```js
>, <Line: -       * $log.debug('Some Error');
>, <Line: -       * var first = $log.debug.logs.unshift();
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      $log.debug.logs = [];
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $log#assertEmpty
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Assert that all of the logging methods have no logged messages. If any messages are present,
>, <Line: -     * an exception is thrown.
>, <Line: -     */
>, <Line: -    $log.assertEmpty = function() {
>, <Line: -      var errors = [];
>, <Line: -      angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {
>, <Line: -        angular.forEach($log[logLevel].logs, function(log) {
>, <Line: -          angular.forEach(log, function(logItem) {
>, <Line: -            errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\n' +
>, <Line: -                        (logItem.stack || ''));
>, <Line: -          });
>, <Line: -        });
>, <Line: -      });
>, <Line: -      if (errors.length) {
>, <Line: -        errors.unshift("Expected $log to be empty! Either a message was logged unexpectedly, or " +
>, <Line: -          "an expected log message was not checked and removed:");
>, <Line: -        errors.push('');
>, <Line: -        throw new Error(errors.join('\n---------\n'));
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $log.reset();
>, <Line: -    return $log;
>, <Line: -  };
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $interval
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Mock implementation of the $interval service.
>, <Line: - *
>, <Line: - * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to
>, <Line: - * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
>, <Line: - * time.
>, <Line: - *
>, <Line: - * @param {function()} fn A function that should be called repeatedly.
>, <Line: - * @param {number} delay Number of milliseconds between each function call.
>, <Line: - * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
>, <Line: - *   indefinitely.
>, <Line: - * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: - *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: - * @returns {promise} A promise which will be notified on each iteration.
>, <Line: - */
>, <Line: -angular.mock.$IntervalProvider = function() {
>, <Line: -  this.$get = ['$browser', '$rootScope', '$q', '$$q',
>, <Line: -       function($browser,   $rootScope,   $q,   $$q) {
>, <Line: -    var repeatFns = [],
>, <Line: -        nextRepeatId = 0,
>, <Line: -        now = 0;
>, <Line: -    var $interval = function(fn, delay, count, invokeApply) {
>, <Line: -      var iteration = 0,
>, <Line: -          skipApply = (angular.isDefined(invokeApply) && !invokeApply),
>, <Line: -          deferred = (skipApply ? $$q : $q).defer(),
>, <Line: -          promise = deferred.promise;
>, <Line: -      count = (angular.isDefined(count)) ? count : 0;
>, <Line: -      promise.then(null, null, fn);
>, <Line: -      promise.$$intervalId = nextRepeatId;
>, <Line: -      function tick() {
>, <Line: -        deferred.notify(iteration++);
>, <Line: -        if (count > 0 && iteration >= count) {
>, <Line: -          var fnIndex;
>, <Line: -          deferred.resolve(iteration);
>, <Line: -          angular.forEach(repeatFns, function(fn, index) {
>, <Line: -            if (fn.id === promise.$$intervalId) fnIndex = index;
>, <Line: -          });
>, <Line: -          if (fnIndex !== undefined) {
>, <Line: -            repeatFns.splice(fnIndex, 1);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (skipApply) {
>, <Line: -          $browser.defer.flush();
>, <Line: -        } else {
>, <Line: -          $rootScope.$apply();
>, <Line: -        }
>, <Line: -      }
>, <Line: -      repeatFns.push({
>, <Line: -        nextTime:(now + delay),
>, <Line: -        delay: delay,
>, <Line: -        fn: tick,
>, <Line: -        id: nextRepeatId,
>, <Line: -        deferred: deferred
>, <Line: -      });
>, <Line: -      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});
>, <Line: -      nextRepeatId++;
>, <Line: -      return promise;
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $interval#cancel
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Cancels a task associated with the `promise`.
>, <Line: -     *
>, <Line: -     * @param {promise} promise A promise from calling the `$interval` function.
>, <Line: -     * @returns {boolean} Returns `true` if the task was successfully cancelled.
>, <Line: -     */
>, <Line: -    $interval.cancel = function(promise) {
>, <Line: -      if (!promise) return false;
>, <Line: -      var fnIndex;
>, <Line: -      angular.forEach(repeatFns, function(fn, index) {
>, <Line: -        if (fn.id === promise.$$intervalId) fnIndex = index;
>, <Line: -      });
>, <Line: -      if (fnIndex !== undefined) {
>, <Line: -        repeatFns[fnIndex].deferred.reject('canceled');
>, <Line: -        repeatFns.splice(fnIndex, 1);
>, <Line: -        return true;
>, <Line: -      }
>, <Line: -      return false;
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $interval#flush
>, <Line: -     * @description
>, <Line: -     *
>, <Line: -     * Runs interval tasks scheduled to be run in the next `millis` milliseconds.
>, <Line: -     *
>, <Line: -     * @param {number=} millis maximum timeout amount to flush up until.
>, <Line: -     *
>, <Line: -     * @return {number} The amount of time moved forward.
>, <Line: -     */
>, <Line: -    $interval.flush = function(millis) {
>, <Line: -      now += millis;
>, <Line: -      while (repeatFns.length && repeatFns[0].nextTime <= now) {
>, <Line: -        var task = repeatFns[0];
>, <Line: -        task.fn();
>, <Line: -        task.nextTime += task.delay;
>, <Line: -        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});
>, <Line: -      }
>, <Line: -      return millis;
>, <Line: -    };
>, <Line: -    return $interval;
>, <Line: -  }];
>, <Line: -};
>, <Line: -/* jshint -W101 */
>, <Line: -/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!
>, <Line: - * This directive should go inside the anonymous function but a bug in JSHint means that it would
>, <Line: - * not be enacted early enough to prevent the warning.
>, <Line: - */
>, <Line: -var R_ISO8061_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
>, <Line: -function jsonStringToDate(string) {
>, <Line: -  var match;
>, <Line: -  if (match = string.match(R_ISO8061_STR)) {
>, <Line: -    var date = new Date(0),
>, <Line: -        tzHour = 0,
>, <Line: -        tzMin  = 0;
>, <Line: -    if (match[9]) {
>, <Line: -      tzHour = int(match[9] + match[10]);
>, <Line: -      tzMin = int(match[9] + match[11]);
>, <Line: -    }
>, <Line: -    date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
>, <Line: -    date.setUTCHours(int(match[4] || 0) - tzHour,
>, <Line: -                     int(match[5] || 0) - tzMin,
>, <Line: -                     int(match[6] || 0),
>, <Line: -                     int(match[7] || 0));
>, <Line: -    return date;
>, <Line: -  }
>, <Line: -  return string;
>, <Line: -}
>, <Line: -function int(str) {
>, <Line: -  return parseInt(str, 10);
>, <Line: -}
>, <Line: -function padNumber(num, digits, trim) {
>, <Line: -  var neg = '';
>, <Line: -  if (num < 0) {
>, <Line: -    neg =  '-';
>, <Line: -    num = -num;
>, <Line: -  }
>, <Line: -  num = '' + num;
>, <Line: -  while (num.length < digits) num = '0' + num;
>, <Line: -  if (trim)
>, <Line: -    num = num.substr(num.length - digits);
>, <Line: -  return neg + num;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name angular.mock.TzDate
>, <Line: - * @description
>, <Line: - *
>, <Line: - * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.
>, <Line: - *
>, <Line: - * Mock of the Date type which has its timezone specified via constructor arg.
>, <Line: - *
>, <Line: - * The main purpose is to create Date-like instances with timezone fixed to the specified timezone
>, <Line: - * offset, so that we can test code that depends on local timezone settings without dependency on
>, <Line: - * the time zone settings of the machine where the code is running.
>, <Line: - *
>, <Line: - * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)
>, <Line: - * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*
>, <Line: - *
>, <Line: - * @example
>, <Line: - * !!!! WARNING !!!!!
>, <Line: - * This is not a complete Date object so only methods that were implemented can be called safely.
>, <Line: - * To make matters worse, TzDate instances inherit stuff from Date via a prototype.
>, <Line: - *
>, <Line: - * We do our best to intercept calls to "unimplemented" methods, but since the list of methods is
>, <Line: - * incomplete we might be missing some non-standard methods. This can result in errors like:
>, <Line: - * "Date.prototype.foo called on incompatible Object".
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');
>, <Line: - * newYearInBratislava.getTimezoneOffset() => -60;
>, <Line: - * newYearInBratislava.getFullYear() => 2010;
>, <Line: - * newYearInBratislava.getMonth() => 0;
>, <Line: - * newYearInBratislava.getDate() => 1;
>, <Line: - * newYearInBratislava.getHours() => 0;
>, <Line: - * newYearInBratislava.getMinutes() => 0;
>, <Line: - * newYearInBratislava.getSeconds() => 0;
>, <Line: - * ```
>, <Line: - *
>, <Line: - */
>, <Line: -angular.mock.TzDate = function(offset, timestamp) {
>, <Line: -  var self = new Date(0);
>, <Line: -  if (angular.isString(timestamp)) {
>, <Line: -    var tsStr = timestamp;
>, <Line: -    self.origDate = jsonStringToDate(timestamp);
>, <Line: -    timestamp = self.origDate.getTime();
>, <Line: -    if (isNaN(timestamp))
>, <Line: -      throw {
>, <Line: -        name: "Illegal Argument",
>, <Line: -        message: "Arg '" + tsStr + "' passed into TzDate constructor is not a valid date string"
>, <Line: -      };
>, <Line: -  } else {
>, <Line: -    self.origDate = new Date(timestamp);
>, <Line: -  }
>, <Line: -  var localOffset = new Date(timestamp).getTimezoneOffset();
>, <Line: -  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
>, <Line: -  self.date = new Date(timestamp + self.offsetDiff);
>, <Line: -  self.getTime = function() {
>, <Line: -    return self.date.getTime() - self.offsetDiff;
>, <Line: -  };
>, <Line: -  self.toLocaleDateString = function() {
>, <Line: -    return self.date.toLocaleDateString();
>, <Line: -  };
>, <Line: -  self.getFullYear = function() {
>, <Line: -    return self.date.getFullYear();
>, <Line: -  };
>, <Line: -  self.getMonth = function() {
>, <Line: -    return self.date.getMonth();
>, <Line: -  };
>, <Line: -  self.getDate = function() {
>, <Line: -    return self.date.getDate();
>, <Line: -  };
>, <Line: -  self.getHours = function() {
>, <Line: -    return self.date.getHours();
>, <Line: -  };
>, <Line: -  self.getMinutes = function() {
>, <Line: -    return self.date.getMinutes();
>, <Line: -  };
>, <Line: -  self.getSeconds = function() {
>, <Line: -    return self.date.getSeconds();
>, <Line: -  };
>, <Line: -  self.getMilliseconds = function() {
>, <Line: -    return self.date.getMilliseconds();
>, <Line: -  };
>, <Line: -  self.getTimezoneOffset = function() {
>, <Line: -    return offset * 60;
>, <Line: -  };
>, <Line: -  self.getUTCFullYear = function() {
>, <Line: -    return self.origDate.getUTCFullYear();
>, <Line: -  };
>, <Line: -  self.getUTCMonth = function() {
>, <Line: -    return self.origDate.getUTCMonth();
>, <Line: -  };
>, <Line: -  self.getUTCDate = function() {
>, <Line: -    return self.origDate.getUTCDate();
>, <Line: -  };
>, <Line: -  self.getUTCHours = function() {
>, <Line: -    return self.origDate.getUTCHours();
>, <Line: -  };
>, <Line: -  self.getUTCMinutes = function() {
>, <Line: -    return self.origDate.getUTCMinutes();
>, <Line: -  };
>, <Line: -  self.getUTCSeconds = function() {
>, <Line: -    return self.origDate.getUTCSeconds();
>, <Line: -  };
>, <Line: -  self.getUTCMilliseconds = function() {
>, <Line: -    return self.origDate.getUTCMilliseconds();
>, <Line: -  };
>, <Line: -  self.getDay = function() {
>, <Line: -    return self.date.getDay();
>, <Line: -  };
>, <Line: -  // provide this method only on browsers that already have it
>, <Line: -  if (self.toISOString) {
>, <Line: -    self.toISOString = function() {
>, <Line: -      return padNumber(self.origDate.getUTCFullYear(), 4) + '-' +
>, <Line: -            padNumber(self.origDate.getUTCMonth() + 1, 2) + '-' +
>, <Line: -            padNumber(self.origDate.getUTCDate(), 2) + 'T' +
>, <Line: -            padNumber(self.origDate.getUTCHours(), 2) + ':' +
>, <Line: -            padNumber(self.origDate.getUTCMinutes(), 2) + ':' +
>, <Line: -            padNumber(self.origDate.getUTCSeconds(), 2) + '.' +
>, <Line: -            padNumber(self.origDate.getUTCMilliseconds(), 3) + 'Z';
>, <Line: -    };
>, <Line: -  }
>, <Line: -  //hide all methods not implemented in this mock that the Date prototype exposes
>, <Line: -  var unimplementedMethods = ['getUTCDay',
>, <Line: -      'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',
>, <Line: -      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',
>, <Line: -      'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',
>, <Line: -      'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',
>, <Line: -      'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];
>, <Line: -  angular.forEach(unimplementedMethods, function(methodName) {
>, <Line: -    self[methodName] = function() {
>, <Line: -      throw new Error("Method '" + methodName + "' is not implemented in the TzDate mock");
>, <Line: -    };
>, <Line: -  });
>, <Line: -  return self;
>, <Line: -};
>, <Line: -angular.mock.TzDate.prototype = Date.prototype;
>, <Line: -/* jshint +W101 */
>, <Line: -angular.mock.animate = angular.module('ngAnimateMock', ['ng'])
>, <Line: -  .config(['$provide', function($provide) {
>, <Line: -    var reflowQueue = [];
>, <Line: -    $provide.value('$$animateReflow', function(fn) {
>, <Line: -      var index = reflowQueue.length;
>, <Line: -      reflowQueue.push(fn);
>, <Line: -      return function cancel() {
>, <Line: -        reflowQueue.splice(index, 1);
>, <Line: -      };
>, <Line: -    });
>, <Line: -    $provide.decorator('$animate', ['$delegate', '$$asyncCallback', '$timeout', '$browser',
>, <Line: -                            function($delegate,   $$asyncCallback,   $timeout,   $browser) {
>, <Line: -      var animate = {
>, <Line: -        queue: [],
>, <Line: -        cancel: $delegate.cancel,
>, <Line: -        enabled: $delegate.enabled,
>, <Line: -        triggerCallbackEvents: function() {
>, <Line: -          $$asyncCallback.flush();
>, <Line: -        },
>, <Line: -        triggerCallbackPromise: function() {
>, <Line: -          $timeout.flush(0);
>, <Line: -        },
>, <Line: -        triggerCallbacks: function() {
>, <Line: -          this.triggerCallbackEvents();
>, <Line: -          this.triggerCallbackPromise();
>, <Line: -        },
>, <Line: -        triggerReflow: function() {
>, <Line: -          angular.forEach(reflowQueue, function(fn) {
>, <Line: -            fn();
>, <Line: -          });
>, <Line: -          reflowQueue = [];
>, <Line: -        }
>, <Line: -      };
>, <Line: -      angular.forEach(
>, <Line: -        ['animate','enter','leave','move','addClass','removeClass','setClass'], function(method) {
>, <Line: -        animate[method] = function() {
>, <Line: -          animate.queue.push({
>, <Line: -            event: method,
>, <Line: -            element: arguments[0],
>, <Line: -            options: arguments[arguments.length - 1],
>, <Line: -            args: arguments
>, <Line: -          });
>, <Line: -          return $delegate[method].apply($delegate, arguments);
>, <Line: -        };
>, <Line: -      });
>, <Line: -      return animate;
>, <Line: -    }]);
>, <Line: -  }]);
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.mock.dump
>, <Line: - * @description
>, <Line: - *
>, <Line: - * *NOTE*: this is not an injectable instance, just a globally available function.
>, <Line: - *
>, <Line: - * Method for serializing common angular objects (scope, elements, etc..) into strings, useful for
>, <Line: - * debugging.
>, <Line: - *
>, <Line: - * This method is also available on window, where it can be used to display objects on debug
>, <Line: - * console.
>, <Line: - *
>, <Line: - * @param {*} object - any object to turn into string.
>, <Line: - * @return {string} a serialized string of the argument
>, <Line: - */
>, <Line: -angular.mock.dump = function(object) {
>, <Line: -  return serialize(object);
>, <Line: -  function serialize(object) {
>, <Line: -    var out;
>, <Line: -    if (angular.isElement(object)) {
>, <Line: -      object = angular.element(object);
>, <Line: -      out = angular.element('<div></div>');
>, <Line: -      angular.forEach(object, function(element) {
>, <Line: -        out.append(angular.element(element).clone());
>, <Line: -      });
>, <Line: -      out = out.html();
>, <Line: -    } else if (angular.isArray(object)) {
>, <Line: -      out = [];
>, <Line: -      angular.forEach(object, function(o) {
>, <Line: -        out.push(serialize(o));
>, <Line: -      });
>, <Line: -      out = '[ ' + out.join(', ') + ' ]';
>, <Line: -    } else if (angular.isObject(object)) {
>, <Line: -      if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {
>, <Line: -        out = serializeScope(object);
>, <Line: -      } else if (object instanceof Error) {
>, <Line: -        out = object.stack || ('' + object.name + ': ' + object.message);
>, <Line: -      } else {
>, <Line: -        // TODO(i): this prevents methods being logged,
>, <Line: -        // we should have a better way to serialize objects
>, <Line: -        out = angular.toJson(object, true);
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      out = String(object);
>, <Line: -    }
>, <Line: -    return out;
>, <Line: -  }
>, <Line: -  function serializeScope(scope, offset) {
>, <Line: -    offset = offset ||  '  ';
>, <Line: -    var log = [offset + 'Scope(' + scope.$id + '): {'];
>, <Line: -    for (var key in scope) {
>, <Line: -      if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\$|this)/)) {
>, <Line: -        log.push('  ' + key + ': ' + angular.toJson(scope[key]));
>, <Line: -      }
>, <Line: -    }
>, <Line: -    var child = scope.$$childHead;
>, <Line: -    while (child) {
>, <Line: -      log.push(serializeScope(child, offset + '  '));
>, <Line: -      child = child.$$nextSibling;
>, <Line: -    }
>, <Line: -    log.push('}');
>, <Line: -    return log.join('\n' + offset);
>, <Line: -  }
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $httpBackend
>, <Line: - * @description
>, <Line: - * Fake HTTP backend implementation suitable for unit testing applications that use the
>, <Line: - * {@link ng.$http $http service}.
>, <Line: - *
>, <Line: - * *Note*: For fake HTTP backend implementation suitable for end-to-end testing or backend-less
>, <Line: - * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.
>, <Line: - *
>, <Line: - * During unit testing, we want our unit tests to run quickly and have no external dependencies so
>, <Line: - * we don’t want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or
>, <Line: - * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is
>, <Line: - * to verify whether a certain request has been sent or not, or alternatively just let the
>, <Line: - * application make requests, respond with pre-trained responses and assert that the end result is
>, <Line: - * what we expect it to be.
>, <Line: - *
>, <Line: - * This mock implementation can be used to respond with static or dynamic responses via the
>, <Line: - * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).
>, <Line: - *
>, <Line: - * When an Angular application needs some data from a server, it calls the $http service, which
>, <Line: - * sends the request to a real server using $httpBackend service. With dependency injection, it is
>, <Line: - * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify
>, <Line: - * the requests and respond with some testing data without sending a request to a real server.
>, <Line: - *
>, <Line: - * There are two ways to specify what test data should be returned as http responses by the mock
>, <Line: - * backend when the code under test makes http requests:
>, <Line: - *
>, <Line: - * - `$httpBackend.expect` - specifies a request expectation
>, <Line: - * - `$httpBackend.when` - specifies a backend definition
>, <Line: - *
>, <Line: - *
>, <Line: - * # Request Expectations vs Backend Definitions
>, <Line: - *
>, <Line: - * Request expectations provide a way to make assertions about requests made by the application and
>, <Line: - * to define responses for those requests. The test will fail if the expected requests are not made
>, <Line: - * or they are made in the wrong order.
>, <Line: - *
>, <Line: - * Backend definitions allow you to define a fake backend for your application which doesn't assert
>, <Line: - * if a particular request was made or not, it just returns a trained response if a request is made.
>, <Line: - * The test will pass whether or not the request gets made during testing.
>, <Line: - *
>, <Line: - *
>, <Line: - * <table class="table">
>, <Line: - *   <tr><th width="220px"></th><th>Request expectations</th><th>Backend definitions</th></tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Syntax</th>
>, <Line: - *     <td>.expect(...).respond(...)</td>
>, <Line: - *     <td>.when(...).respond(...)</td>
>, <Line: - *   </tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Typical usage</th>
>, <Line: - *     <td>strict unit tests</td>
>, <Line: - *     <td>loose (black-box) unit testing</td>
>, <Line: - *   </tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Fulfills multiple requests</th>
>, <Line: - *     <td>NO</td>
>, <Line: - *     <td>YES</td>
>, <Line: - *   </tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Order of requests matters</th>
>, <Line: - *     <td>YES</td>
>, <Line: - *     <td>NO</td>
>, <Line: - *   </tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Request required</th>
>, <Line: - *     <td>YES</td>
>, <Line: - *     <td>NO</td>
>, <Line: - *   </tr>
>, <Line: - *   <tr>
>, <Line: - *     <th>Response required</th>
>, <Line: - *     <td>optional (see below)</td>
>, <Line: - *     <td>YES</td>
>, <Line: - *   </tr>
>, <Line: - * </table>
>, <Line: - *
>, <Line: - * In cases where both backend definitions and request expectations are specified during unit
>, <Line: - * testing, the request expectations are evaluated first.
>, <Line: - *
>, <Line: - * If a request expectation has no response specified, the algorithm will search your backend
>, <Line: - * definitions for an appropriate response.
>, <Line: - *
>, <Line: - * If a request didn't match any expectation or if the expectation doesn't have the response
>, <Line: - * defined, the backend definitions are evaluated in sequential order to see if any of them match
>, <Line: - * the request. The response from the first matched definition is returned.
>, <Line: - *
>, <Line: - *
>, <Line: - * # Flushing HTTP requests
>, <Line: - *
>, <Line: - * The $httpBackend used in production always responds to requests asynchronously. If we preserved
>, <Line: - * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,
>, <Line: - * to follow and to maintain. But neither can the testing mock respond synchronously; that would
>, <Line: - * change the execution of the code under test. For this reason, the mock $httpBackend has a
>, <Line: - * `flush()` method, which allows the test to explicitly flush pending requests. This preserves
>, <Line: - * the async api of the backend, while allowing the test to execute synchronously.
>, <Line: - *
>, <Line: - *
>, <Line: - * # Unit testing with mock $httpBackend
>, <Line: - * The following code shows how to setup and use the mock backend when unit testing a controller.
>, <Line: - * First we create the controller under test:
>, <Line: - *
>, <Line: -  ```js
>, <Line: -  // The module code
>, <Line: -  angular
>, <Line: -    .module('MyApp', [])
>, <Line: -    .controller('MyController', MyController);
>, <Line: -  // The controller code
>, <Line: -  function MyController($scope, $http) {
>, <Line: -  ```
>, <Line: - *
>, <Line: - * Now we setup the mock backend and create the test specs:
>, <Line: - *
>, <Line: -  ```js
>, <Line: -    // testing controller
>, <Line: -    describe('MyController', function() {
>, <Line: -   ```
>, <Line: - */
>, <Line: -angular.mock.$HttpBackendProvider = function() {
>, <Line: -  this.$get = ['$rootScope', createHttpBackendMock];
>, <Line: -};
>, <Line: -/**
>, <Line: - * General factory function for $httpBackend mock.
>, <Line: - * Returns instance for unit testing (when no arguments specified):
>, <Line: - *   - passing through is disabled
>, <Line: - *   - auto flushing is disabled
>, <Line: - *
>, <Line: - * Returns instance for e2e testing (when `$delegate` and `$browser` specified):
>, <Line: - *   - passing through (delegating request to real backend) is enabled
>, <Line: - *   - auto flushing is enabled
>, <Line: - *
>, <Line: - * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)
>, <Line: - * @param {Object=} $browser Auto-flushing enabled if specified
>, <Line: - * @return {Object} Instance of $httpBackend mock
>, <Line: - */
>, <Line: -function createHttpBackendMock($rootScope, $delegate, $browser) {
>, <Line: -  var definitions = [],
>, <Line: -      expectations = [],
>, <Line: -      responses = [],
>, <Line: -      responsesPush = angular.bind(responses, responses.push),
>, <Line: -      copy = angular.copy;
>, <Line: -  function createResponse(status, data, headers, statusText) {
>, <Line: -    if (angular.isFunction(status)) return status;
>, <Line: -    return function() {
>, <Line: -      return angular.isNumber(status)
>, <Line: -          ? [status, data, headers, statusText]
>, <Line: -          : [200, status, data];
>, <Line: -    };
>, <Line: -  }
>, <Line: -  // TODO(vojta): change params to: method, url, data, headers, callback
>, <Line: -  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials) {
>, <Line: -    var xhr = new MockXhr(),
>, <Line: -        expectation = expectations[0],
>, <Line: -        wasExpected = false;
>, <Line: -    function prettyPrint(data) {
>, <Line: -      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)
>, <Line: -          ? data
>, <Line: -          : angular.toJson(data);
>, <Line: -    }
>, <Line: -    function wrapResponse(wrapped) {
>, <Line: -      if (!$browser && timeout && timeout.then) timeout.then(handleTimeout);
>, <Line: -      return handleResponse;
>, <Line: -      function handleResponse() {
>, <Line: -        var response = wrapped.response(method, url, data, headers);
>, <Line: -        xhr.$$respHeaders = response[2];
>, <Line: -        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),
>, <Line: -                 copy(response[3] || ''));
>, <Line: -      }
>, <Line: -      function handleTimeout() {
>, <Line: -        for (var i = 0, ii = responses.length; i < ii; i++) {
>, <Line: -          if (responses[i] === handleResponse) {
>, <Line: -            responses.splice(i, 1);
>, <Line: -            callback(-1, undefined, '');
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    if (expectation && expectation.match(method, url)) {
>, <Line: -      if (!expectation.matchData(data))
>, <Line: -        throw new Error('Expected ' + expectation + ' with different data\n' +
>, <Line: -            'EXPECTED: ' + prettyPrint(expectation.data) + '\nGOT:      ' + data);
>, <Line: -      if (!expectation.matchHeaders(headers))
>, <Line: -        throw new Error('Expected ' + expectation + ' with different headers\n' +
>, <Line: -                        'EXPECTED: ' + prettyPrint(expectation.headers) + '\nGOT:      ' +
>, <Line: -                        prettyPrint(headers));
>, <Line: -      expectations.shift();
>, <Line: -      if (expectation.response) {
>, <Line: -        responses.push(wrapResponse(expectation));
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      wasExpected = true;
>, <Line: -    }
>, <Line: -    var i = -1, definition;
>, <Line: -    while ((definition = definitions[++i])) {
>, <Line: -      if (definition.match(method, url, data, headers || {})) {
>, <Line: -        if (definition.response) {
>, <Line: -          // if $browser specified, we do auto flush all requests
>, <Line: -          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
>, <Line: -        } else if (definition.passThrough) {
>, <Line: -          $delegate(method, url, data, callback, headers, timeout, withCredentials);
>, <Line: -        } else throw new Error('No response defined !');
>, <Line: -        return;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    throw wasExpected ?
>, <Line: -        new Error('No response defined !') :
>, <Line: -        new Error('Unexpected request: ' + method + ' ' + url + '\n' +
>, <Line: -                  (expectation ? 'Expected ' + expectation : 'No more request expected'));
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#when
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition.
>, <Line: -   *
>, <Line: -   * @param {string} method HTTP method.
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: -   *   data string and returns true if the data is as expected.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: -   *   object and returns true if the headers match the current definition.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   *
>, <Line: -   *  - respond –
>, <Line: -   *      `{function([status,] data[, headers, statusText])
>, <Line: -   *    – The respond method takes a set of static data to be returned or a function that can
>, <Line: -   *    return an array containing response status (number), response data (string), response
>, <Line: -   *    headers (Object), and the text for the status (string). The respond method returns the
>, <Line: -   *    `requestHandler` object for possible overrides.
>, <Line: -   */
>, <Line: -  $httpBackend.when = function(method, url, data, headers) {
>, <Line: -    var definition = new MockHttpExpectation(method, url, data, headers),
>, <Line: -        chain = {
>, <Line: -          respond: function(status, data, headers, statusText) {
>, <Line: -            definition.passThrough = undefined;
>, <Line: -            definition.response = createResponse(status, data, headers, statusText);
>, <Line: -            return chain;
>, <Line: -          }
>, <Line: -        };
>, <Line: -    if ($browser) {
>, <Line: -      chain.passThrough = function() {
>, <Line: -        definition.response = undefined;
>, <Line: -        definition.passThrough = true;
>, <Line: -        return chain;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    definitions.push(definition);
>, <Line: -    return chain;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenGET
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for GET requests. For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenHEAD
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for HEAD requests. For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenDELETE
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for DELETE requests. For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenPOST
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for POST requests. For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: -   *   data string and returns true if the data is as expected.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenPUT
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for PUT requests.  For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
>, <Line: -   *   data string and returns true if the data is as expected.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#whenJSONP
>, <Line: -   * @description
>, <Line: -   * Creates a new backend definition for JSONP requests. For more info see `when()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  createShortMethods('when');
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expect
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation.
>, <Line: -   *
>, <Line: -   * @param {string} method HTTP method.
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: -   *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: -   *  is in JSON format.
>, <Line: -   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: -   *   object and returns true if the headers match the current expectation.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *  request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *  order to change how a matched request is handled.
>, <Line: -   *
>, <Line: -   *  - respond –
>, <Line: -   *    `{function([status,] data[, headers, statusText])
>, <Line: -   *    – The respond method takes a set of static data to be returned or a function that can
>, <Line: -   *    return an array containing response status (number), response data (string), response
>, <Line: -   *    headers (Object), and the text for the status (string). The respond method returns the
>, <Line: -   *    `requestHandler` object for possible overrides.
>, <Line: -   */
>, <Line: -  $httpBackend.expect = function(method, url, data, headers) {
>, <Line: -    var expectation = new MockHttpExpectation(method, url, data, headers),
>, <Line: -        chain = {
>, <Line: -          respond: function(status, data, headers, statusText) {
>, <Line: -            expectation.response = createResponse(status, data, headers, statusText);
>, <Line: -            return chain;
>, <Line: -          }
>, <Line: -        };
>, <Line: -    expectations.push(expectation);
>, <Line: -    return chain;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectGET
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for GET requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   * request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   * order to change how a matched request is handled. See #expect for more info.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectHEAD
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for HEAD requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectDELETE
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for DELETE requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectPOST
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for POST requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: -   *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: -   *  is in JSON format.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectPUT
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for PUT requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: -   *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: -   *  is in JSON format.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectPATCH
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for PATCH requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
>, <Line: -   *  receives data string and returns true if the data is as expected, or Object if request body
>, <Line: -   *  is in JSON format.
>, <Line: -   * @param {Object=} headers HTTP headers.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#expectJSONP
>, <Line: -   * @description
>, <Line: -   * Creates a new request expectation for JSONP requests. For more info see `expect()`.
>, <Line: -   *
>, <Line: -   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: -   *   and returns true if the url match the current definition.
>, <Line: -   * @returns {requestHandler} Returns an object with `respond` method that control how a matched
>, <Line: -   *   request is handled. You can save this object for later use and invoke `respond` again in
>, <Line: -   *   order to change how a matched request is handled.
>, <Line: -   */
>, <Line: -  createShortMethods('expect');
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#flush
>, <Line: -   * @description
>, <Line: -   * Flushes all pending requests using the trained responses.
>, <Line: -   *
>, <Line: -   * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,
>, <Line: -   *   all pending requests will be flushed. If there are no pending requests when the flush method
>, <Line: -   *   is called an exception is thrown (as this typically a sign of programming error).
>, <Line: -   */
>, <Line: -  $httpBackend.flush = function(count, digest) {
>, <Line: -    if (digest !== false) $rootScope.$digest();
>, <Line: -    if (!responses.length) throw new Error('No pending request to flush !');
>, <Line: -    if (angular.isDefined(count) && count !== null) {
>, <Line: -      while (count--) {
>, <Line: -        if (!responses.length) throw new Error('No more pending request to flush !');
>, <Line: -        responses.shift()();
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      while (responses.length) {
>, <Line: -        responses.shift()();
>, <Line: -      }
>, <Line: -    }
>, <Line: -    $httpBackend.verifyNoOutstandingExpectation(digest);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#verifyNoOutstandingExpectation
>, <Line: -   * @description
>, <Line: -   * Verifies that all of the requests defined via the `expect` api were made. If any of the
>, <Line: -   * requests were not made, verifyNoOutstandingExpectation throws an exception.
>, <Line: -   *
>, <Line: -   * Typically, you would call this method following each test case that asserts requests using an
>, <Line: -   * "afterEach" clause.
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   *   afterEach($httpBackend.verifyNoOutstandingExpectation);
>, <Line: -   * ```
>, <Line: -   */
>, <Line: -  $httpBackend.verifyNoOutstandingExpectation = function(digest) {
>, <Line: -    if (digest !== false) $rootScope.$digest();
>, <Line: -    if (expectations.length) {
>, <Line: -      throw new Error('Unsatisfied requests: ' + expectations.join(', '));
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#verifyNoOutstandingRequest
>, <Line: -   * @description
>, <Line: -   * Verifies that there are no outstanding requests that need to be flushed.
>, <Line: -   *
>, <Line: -   * Typically, you would call this method following each test case that asserts requests using an
>, <Line: -   * "afterEach" clause.
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   *   afterEach($httpBackend.verifyNoOutstandingRequest);
>, <Line: -   * ```
>, <Line: -   */
>, <Line: -  $httpBackend.verifyNoOutstandingRequest = function() {
>, <Line: -    if (responses.length) {
>, <Line: -      throw new Error('Unflushed requests: ' + responses.length);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpBackend#resetExpectations
>, <Line: -   * @description
>, <Line: -   * Resets all request expectations, but preserves all backend definitions. Typically, you would
>, <Line: -   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of
>, <Line: -   * $httpBackend mock.
>, <Line: -   */
>, <Line: -  $httpBackend.resetExpectations = function() {
>, <Line: -    expectations.length = 0;
>, <Line: -    responses.length = 0;
>, <Line: -  };
>, <Line: -  return $httpBackend;
>, <Line: -  function createShortMethods(prefix) {
>, <Line: -    angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {
>, <Line: -     $httpBackend[prefix + method] = function(url, headers) {
>, <Line: -       return $httpBackend[prefix](method, url, undefined, headers);
>, <Line: -     };
>, <Line: -    });
>, <Line: -    angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {
>, <Line: -      $httpBackend[prefix + method] = function(url, data, headers) {
>, <Line: -        return $httpBackend[prefix](method, url, data, headers);
>, <Line: -      };
>, <Line: -    });
>, <Line: -  }
>, <Line: -}
>, <Line: -function MockHttpExpectation(method, url, data, headers) {
>, <Line: -  this.data = data;
>, <Line: -  this.headers = headers;
>, <Line: -  this.match = function(m, u, d, h) {
>, <Line: -    if (method != m) return false;
>, <Line: -    if (!this.matchUrl(u)) return false;
>, <Line: -    if (angular.isDefined(d) && !this.matchData(d)) return false;
>, <Line: -    if (angular.isDefined(h) && !this.matchHeaders(h)) return false;
>, <Line: -    return true;
>, <Line: -  };
>, <Line: -  this.matchUrl = function(u) {
>, <Line: -    if (!url) return true;
>, <Line: -    if (angular.isFunction(url.test)) return url.test(u);
>, <Line: -    if (angular.isFunction(url)) return url(u);
>, <Line: -    return url == u;
>, <Line: -  };
>, <Line: -  this.matchHeaders = function(h) {
>, <Line: -    if (angular.isUndefined(headers)) return true;
>, <Line: -    if (angular.isFunction(headers)) return headers(h);
>, <Line: -    return angular.equals(headers, h);
>, <Line: -  };
>, <Line: -  this.matchData = function(d) {
>, <Line: -    if (angular.isUndefined(data)) return true;
>, <Line: -    if (data && angular.isFunction(data.test)) return data.test(d);
>, <Line: -    if (data && angular.isFunction(data)) return data(d);
>, <Line: -    if (data && !angular.isString(data)) {
>, <Line: -      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
>, <Line: -    }
>, <Line: -    return data == d;
>, <Line: -  };
>, <Line: -  this.toString = function() {
>, <Line: -    return method + ' ' + url;
>, <Line: -  };
>, <Line: -}
>, <Line: -function createMockXhr() {
>, <Line: -  return new MockXhr();
>, <Line: -}
>, <Line: -function MockXhr() {
>, <Line: -  // hack for testing $http, $httpBackend
>, <Line: -  MockXhr.$$lastInstance = this;
>, <Line: -  this.open = function(method, url, async) {
>, <Line: -    this.$$method = method;
>, <Line: -    this.$$url = url;
>, <Line: -    this.$$async = async;
>, <Line: -    this.$$reqHeaders = {};
>, <Line: -    this.$$respHeaders = {};
>, <Line: -  };
>, <Line: -  this.send = function(data) {
>, <Line: -    this.$$data = data;
>, <Line: -  };
>, <Line: -  this.setRequestHeader = function(key, value) {
>, <Line: -    this.$$reqHeaders[key] = value;
>, <Line: -  };
>, <Line: -  this.getResponseHeader = function(name) {
>, <Line: -    // the lookup must be case insensitive,
>, <Line: -    // that's why we try two quick lookups first and full scan last
>, <Line: -    var header = this.$$respHeaders[name];
>, <Line: -    if (header) return header;
>, <Line: -    name = angular.lowercase(name);
>, <Line: -    header = this.$$respHeaders[name];
>, <Line: -    if (header) return header;
>, <Line: -    header = undefined;
>, <Line: -    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
>, <Line: -      if (!header && angular.lowercase(headerName) == name) header = headerVal;
>, <Line: -    });
>, <Line: -    return header;
>, <Line: -  };
>, <Line: -  this.getAllResponseHeaders = function() {
>, <Line: -    var lines = [];
>, <Line: -    angular.forEach(this.$$respHeaders, function(value, key) {
>, <Line: -      lines.push(key + ': ' + value);
>, <Line: -    });
>, <Line: -    return lines.join('\n');
>, <Line: -  };
>, <Line: -  this.abort = angular.noop;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $timeout
>, <Line: - * @description
>, <Line: - *
>, <Line: - * This service is just a simple decorator for {@link ng.$timeout $timeout} service
>, <Line: - * that adds a "flush" and "verifyNoPendingTasks" methods.
>, <Line: - */
>, <Line: -angular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $timeout#flush
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * Flushes the queue of pending tasks.
>, <Line: -   *
>, <Line: -   * @param {number=} delay maximum timeout amount to flush up until
>, <Line: -   */
>, <Line: -  $delegate.flush = function(delay) {
>, <Line: -    $browser.defer.flush(delay);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $timeout#verifyNoPendingTasks
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * Verifies that there are no pending tasks that need to be flushed.
>, <Line: -   */
>, <Line: -  $delegate.verifyNoPendingTasks = function() {
>, <Line: -    if ($browser.deferredFns.length) {
>, <Line: -      throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +
>, <Line: -          formatPendingTasksAsString($browser.deferredFns));
>, <Line: -    }
>, <Line: -  };
>, <Line: -  function formatPendingTasksAsString(tasks) {
>, <Line: -    var result = [];
>, <Line: -    angular.forEach(tasks, function(task) {
>, <Line: -      result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');
>, <Line: -    });
>, <Line: -    return result.join(', ');
>, <Line: -  }
>, <Line: -  return $delegate;
>, <Line: -}];
>, <Line: -angular.mock.$RAFDecorator = ['$delegate', function($delegate) {
>, <Line: -  var queue = [];
>, <Line: -  var rafFn = function(fn) {
>, <Line: -    var index = queue.length;
>, <Line: -    queue.push(fn);
>, <Line: -    return function() {
>, <Line: -      queue.splice(index, 1);
>, <Line: -    };
>, <Line: -  };
>, <Line: -  rafFn.supported = $delegate.supported;
>, <Line: -  rafFn.flush = function() {
>, <Line: -    if (queue.length === 0) {
>, <Line: -      throw new Error('No rAF callbacks present');
>, <Line: -    }
>, <Line: -    var length = queue.length;
>, <Line: -    for (var i = 0; i < length; i++) {
>, <Line: -      queue[i]();
>, <Line: -    }
>, <Line: -    queue = [];
>, <Line: -  };
>, <Line: -  return rafFn;
>, <Line: -}];
>, <Line: -angular.mock.$AsyncCallbackDecorator = ['$delegate', function($delegate) {
>, <Line: -  var callbacks = [];
>, <Line: -  var addFn = function(fn) {
>, <Line: -    callbacks.push(fn);
>, <Line: -  };
>, <Line: -  addFn.flush = function() {
>, <Line: -    angular.forEach(callbacks, function(fn) {
>, <Line: -      fn();
>, <Line: -    });
>, <Line: -    callbacks = [];
>, <Line: -  };
>, <Line: -  return addFn;
>, <Line: -}];
>, <Line: -/**
>, <Line: - *
>, <Line: - */
>, <Line: -angular.mock.$RootElementProvider = function() {
>, <Line: -  this.$get = function() {
>, <Line: -    return angular.element('<div ng-app></div>');
>, <Line: -  };
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc module
>, <Line: - * @name ngMock
>, <Line: - * @packageName angular-mocks
>, <Line: - * @description
>, <Line: - *
>, <Line: - * # ngMock
>, <Line: - *
>, <Line: - * The `ngMock` module provides support to inject and mock Angular services into unit tests.
>, <Line: - * In addition, ngMock also extends various core ng services such that they can be
>, <Line: - * inspected and controlled in a synchronous manner within test code.
>, <Line: - *
>, <Line: - *
>, <Line: - * <div doc-module-components="ngMock"></div>
>, <Line: - *
>, <Line: - */
>, <Line: -angular.module('ngMock', ['ng']).provider({
>, <Line: -  $browser: angular.mock.$BrowserProvider,
>, <Line: -  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
>, <Line: -  $log: angular.mock.$LogProvider,
>, <Line: -  $interval: angular.mock.$IntervalProvider,
>, <Line: -  $httpBackend: angular.mock.$HttpBackendProvider,
>, <Line: -  $rootElement: angular.mock.$RootElementProvider
>, <Line: -}).config(['$provide', function($provide) {
>, <Line: -  $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);
>, <Line: -  $provide.decorator('$$rAF', angular.mock.$RAFDecorator);
>, <Line: -  $provide.decorator('$$asyncCallback', angular.mock.$AsyncCallbackDecorator);
>, <Line: -  $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);
>, <Line: -}]);
>, <Line: -/**
>, <Line: - * @ngdoc module
>, <Line: - * @name ngMockE2E
>, <Line: - * @module ngMockE2E
>, <Line: - * @packageName angular-mocks
>, <Line: - * @description
>, <Line: - *
>, <Line: - * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.
>, <Line: - * Currently there is only one mock present in this module -
>, <Line: - * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.
>, <Line: - */
>, <Line: -angular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {
>, <Line: -  $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);
>, <Line: -}]);
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $httpBackend
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of
>, <Line: - * applications that use the {@link ng.$http $http service}.
>, <Line: - *
>, <Line: - * *Note*: For fake http backend implementation suitable for unit testing please see
>, <Line: - * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.
>, <Line: - *
>, <Line: - * This implementation can be used to respond with static or dynamic responses via the `when` api
>, <Line: - * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the
>, <Line: - * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch
>, <Line: - * templates from a webserver).
>, <Line: - *
>, <Line: - * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application
>, <Line: - * is being developed with the real backend api replaced with a mock, it is often desirable for
>, <Line: - * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch
>, <Line: - * templates or static files from the webserver). To configure the backend with this behavior
>, <Line: - * use the `passThrough` request handler of `when` instead of `respond`.
>, <Line: - *
>, <Line: - * Additionally, we don't want to manually have to flush mocked out requests like we do during unit
>, <Line: - * testing. For this reason the e2e $httpBackend flushes mocked out requests
>, <Line: - * automatically, closely simulating the behavior of the XMLHttpRequest object.
>, <Line: - *
>, <Line: - * To setup the application to run with this http backend, you have to create a module that depends
>, <Line: - * on the `ngMockE2E` and your application modules and defines the fake backend:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);
>, <Line: - *   myAppDev.run(function($httpBackend) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Afterwards, bootstrap your app with this new module.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#when
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition.
>, <Line: - *
>, <Line: - * @param {string} method HTTP method.
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(string|RegExp)=} data HTTP request body.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
>, <Line: - *   object and returns true if the headers match the current definition.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - *
>, <Line: - *  - respond –
>, <Line: - *    `{function([status,] data[, headers, statusText])
>, <Line: - *    – The respond method takes a set of static data to be returned or a function that can return
>, <Line: - *    an array containing response status (number), response data (string), response headers
>, <Line: - *    (Object), and the text for the status (string).
>, <Line: - *  - passThrough – `{function()}` – Any request matching a backend definition with
>, <Line: - *    `passThrough` handler will be passed through to the real backend (an XHR request will be made
>, <Line: - *    to the server.)
>, <Line: - *  - Both methods return the `requestHandler` object for possible overrides.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenGET
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for GET requests. For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenHEAD
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for HEAD requests. For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenDELETE
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for DELETE requests. For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenPOST
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for POST requests. For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(string|RegExp)=} data HTTP request body.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenPUT
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for PUT requests.  For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(string|RegExp)=} data HTTP request body.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenPATCH
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for PATCH requests.  For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @param {(string|RegExp)=} data HTTP request body.
>, <Line: - * @param {(Object|function(Object))=} headers HTTP headers.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $httpBackend#whenJSONP
>, <Line: - * @module ngMockE2E
>, <Line: - * @description
>, <Line: - * Creates a new backend definition for JSONP requests. For more info see `when()`.
>, <Line: - *
>, <Line: - * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
>, <Line: - *   and returns true if the url match the current definition.
>, <Line: - * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that
>, <Line: - *   control how a matched request is handled. You can save this object for later use and invoke
>, <Line: - *   `respond` or `passThrough` again in order to change how a matched request is handled.
>, <Line: - */
>, <Line: -angular.mock.e2e = {};
>, <Line: -angular.mock.e2e.$httpBackendDecorator =
>, <Line: -  ['$rootScope', '$delegate', '$browser', createHttpBackendMock];
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name $rootScope.Scope
>, <Line: - * @module ngMock
>, <Line: - * @description
>, <Line: - * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These
>, <Line: - * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when
>, <Line: - * `ngMock` module is loaded.
>, <Line: - *
>, <Line: - * In addition to all the regular `Scope` methods, the following helper methods are available:
>, <Line: - */
>, <Line: -angular.mock.$RootScopeDecorator = function($delegate) {
>, <Line: -  var $rootScopePrototype = Object.getPrototypeOf($delegate);
>, <Line: -  $rootScopePrototype.$countChildScopes = countChildScopes;
>, <Line: -  $rootScopePrototype.$countWatchers = countWatchers;
>, <Line: -  return $delegate;
>, <Line: -  // ------------------------------------------------------------------------------------------ //
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $rootScope.Scope#$countChildScopes
>, <Line: -   * @module ngMock
>, <Line: -   * @description
>, <Line: -   * Counts all the direct and indirect child scopes of the current scope.
>, <Line: -   *
>, <Line: -   * The current scope is excluded from the count. The count includes all isolate child scopes.
>, <Line: -   *
>, <Line: -   * @returns {number} Total number of child scopes.
>, <Line: -   */
>, <Line: -  function countChildScopes() {
>, <Line: -    // jshint validthis: true
>, <Line: -    var count = 0; // exclude the current scope
>, <Line: -    var pendingChildHeads = [this.$$childHead];
>, <Line: -    var currentScope;
>, <Line: -    while (pendingChildHeads.length) {
>, <Line: -      currentScope = pendingChildHeads.shift();
>, <Line: -      while (currentScope) {
>, <Line: -        count += 1;
>, <Line: -        pendingChildHeads.push(currentScope.$$childHead);
>, <Line: -        currentScope = currentScope.$$nextSibling;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return count;
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $rootScope.Scope#$countWatchers
>, <Line: -   * @module ngMock
>, <Line: -   * @description
>, <Line: -   * Counts all the watchers of direct and indirect child scopes of the current scope.
>, <Line: -   *
>, <Line: -   * The watchers of the current scope are included in the count and so are all the watchers of
>, <Line: -   * isolate child scopes.
>, <Line: -   *
>, <Line: -   * @returns {number} Total number of watchers.
>, <Line: -   */
>, <Line: -  function countWatchers() {
>, <Line: -    // jshint validthis: true
>, <Line: -    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope
>, <Line: -    var pendingChildHeads = [this.$$childHead];
>, <Line: -    var currentScope;
>, <Line: -    while (pendingChildHeads.length) {
>, <Line: -      currentScope = pendingChildHeads.shift();
>, <Line: -      while (currentScope) {
>, <Line: -        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
>, <Line: -        pendingChildHeads.push(currentScope.$$childHead);
>, <Line: -        currentScope = currentScope.$$nextSibling;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return count;
>, <Line: -  }
>, <Line: -};
>, <Line: -if (window.jasmine || window.mocha) {
>, <Line: -  var currentSpec = null,
>, <Line: -      isSpecRunning = function() {
>, <Line: -        return !!currentSpec;
>, <Line: -      };
>, <Line: -  (window.beforeEach || window.setup)(function() {
>, <Line: -    currentSpec = this;
>, <Line: -  });
>, <Line: -  (window.afterEach || window.teardown)(function() {
>, <Line: -    var injector = currentSpec.$injector;
>, <Line: -    angular.forEach(currentSpec.$modules, function(module) {
>, <Line: -      if (module && module.$$hashKey) {
>, <Line: -        module.$$hashKey = undefined;
>, <Line: -      }
>, <Line: -    });
>, <Line: -    currentSpec.$injector = null;
>, <Line: -    currentSpec.$modules = null;
>, <Line: -    currentSpec = null;
>, <Line: -    if (injector) {
>, <Line: -      injector.get('$rootElement').off();
>, <Line: -      injector.get('$browser').pollFns.length = 0;
>, <Line: -    }
>, <Line: -    // clean up jquery's fragment cache
>, <Line: -    angular.forEach(angular.element.fragments, function(val, key) {
>, <Line: -      delete angular.element.fragments[key];
>, <Line: -    });
>, <Line: -    MockXhr.$$lastInstance = null;
>, <Line: -    angular.forEach(angular.callbacks, function(val, key) {
>, <Line: -      delete angular.callbacks[key];
>, <Line: -    });
>, <Line: -    angular.callbacks.counter = 0;
>, <Line: -  });
>, <Line: -  /**
>, <Line: -   * @ngdoc function
>, <Line: -   * @name angular.mock.module
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * *NOTE*: This function is also published on window for easy access.<br>
>, <Line: -   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
>, <Line: -   *
>, <Line: -   * This function registers a module configuration code. It collects the configuration information
>, <Line: -   * which will be used when the injector is created by {@link angular.mock.inject inject}.
>, <Line: -   *
>, <Line: -   * See {@link angular.mock.inject inject} for usage example
>, <Line: -   *
>, <Line: -   * @param {...(string|Function|Object)} fns any number of modules which are represented as string
>, <Line: -   *        aliases or as anonymous module initialization functions. The modules are used to
>, <Line: -   *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an
>, <Line: -   *        object literal is passed they will be registered as values in the module, the key being
>, <Line: -   *        the module name and the value being what is returned.
>, <Line: -   */
>, <Line: -  window.module = angular.mock.module = function() {
>, <Line: -    var moduleFns = Array.prototype.slice.call(arguments, 0);
>, <Line: -    return isSpecRunning() ? workFn() : workFn;
>, <Line: -    /////////////////////
>, <Line: -    function workFn() {
>, <Line: -      if (currentSpec.$injector) {
>, <Line: -        throw new Error('Injector already created, can not register a module!');
>, <Line: -      } else {
>, <Line: -        var modules = currentSpec.$modules || (currentSpec.$modules = []);
>, <Line: -        angular.forEach(moduleFns, function(module) {
>, <Line: -          if (angular.isObject(module) && !angular.isArray(module)) {
>, <Line: -            modules.push(function($provide) {
>, <Line: -              angular.forEach(module, function(value, key) {
>, <Line: -                $provide.value(key, value);
>, <Line: -              });
>, <Line: -            });
>, <Line: -          } else {
>, <Line: -            modules.push(module);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc function
>, <Line: -   * @name angular.mock.inject
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * *NOTE*: This function is also published on window for easy access.<br>
>, <Line: -   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
>, <Line: -   *
>, <Line: -   * The inject function wraps a function into an injectable function. The inject() creates new
>, <Line: -   * instance of {@link auto.$injector $injector} per test, which is then used for
>, <Line: -   * resolving references.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ## Resolving References (Underscore Wrapping)
>, <Line: -   * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this
>, <Line: -   * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable
>, <Line: -   * that is declared in the scope of the `describe()` block. Since we would, most likely, want
>, <Line: -   * the variable to have the same name of the reference we have a problem, since the parameter
>, <Line: -   * to the `inject()` function would hide the outer variable.
>, <Line: -   *
>, <Line: -   * To help with this, the injected parameters can, optionally, be enclosed with underscores.
>, <Line: -   * These are ignored by the injector when the reference name is resolved.
>, <Line: -   *
>, <Line: -   * For example, the parameter `_myService_` would be resolved as the reference `myService`.
>, <Line: -   * Since it is available in the function body as _myService_, we can then assign it to a variable
>, <Line: -   * defined in an outer scope.
>, <Line: -   *
>, <Line: -   * ```
>, <Line: -   * // Defined out reference variable outside
>, <Line: -   * var myService;
>, <Line: -   *
>, <Line: -   * // Wrap the parameter in underscores
>, <Line: -   * beforeEach( inject( function(_myService_){
>, <Line: -   *
>, <Line: -   * // Use myService in a series of tests.
>, <Line: -   * it('makes use of myService', function() {
>, <Line: -   *
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * See also {@link angular.mock.module angular.mock.module}
>, <Line: -   *
>, <Line: -   * ## Example
>, <Line: -   * Example of what a typical jasmine tests looks like with the inject method.
>, <Line: -   * ```js
>, <Line: -   *
>, <Line: -   *   angular.module('myApplicationModule', [])
>, <Line: -   *       .value('mode', 'app')
>, <Line: -   *       .value('version', 'v1.0.1');
>, <Line: -   *
>, <Line: -   *
>, <Line: -   *   describe('MyApp', function() {
>, <Line: -   *
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {...Function} fns any number of functions which will be injected using the injector.
>, <Line: -   */
>, <Line: -  var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
>, <Line: -    this.message = e.message;
>, <Line: -    this.name = e.name;
>, <Line: -    if (e.line) this.line = e.line;
>, <Line: -    if (e.sourceId) this.sourceId = e.sourceId;
>, <Line: -    if (e.stack && errorForStack)
>, <Line: -      this.stack = e.stack + '\n' + errorForStack.stack;
>, <Line: -    if (e.stackArray) this.stackArray = e.stackArray;
>, <Line: -  };
>, <Line: -  ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;
>, <Line: -  window.inject = angular.mock.inject = function() {
>, <Line: -    var blockFns = Array.prototype.slice.call(arguments, 0);
>, <Line: -    var errorForStack = new Error('Declaration Location');
>, <Line: -    return isSpecRunning() ? workFn.call(currentSpec) : workFn;
>, <Line: -    /////////////////////
>, <Line: -    function workFn() {
>, <Line: -      var modules = currentSpec.$modules || [];
>, <Line: -      var strictDi = !!currentSpec.$injectorStrict;
>, <Line: -      modules.unshift('ngMock');
>, <Line: -      modules.unshift('ng');
>, <Line: -      var injector = currentSpec.$injector;
>, <Line: -      if (!injector) {
>, <Line: -        if (strictDi) {
>, <Line: -          // If strictDi is enabled, annotate the providerInjector blocks
>, <Line: -          angular.forEach(modules, function(moduleFn) {
>, <Line: -            if (typeof moduleFn === "function") {
>, <Line: -              angular.injector.$$annotate(moduleFn);
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -        injector = currentSpec.$injector = angular.injector(modules, strictDi);
>, <Line: -        currentSpec.$injectorStrict = strictDi;
>, <Line: -      }
>, <Line: -      for (var i = 0, ii = blockFns.length; i < ii; i++) {
>, <Line: -        if (currentSpec.$injectorStrict) {
>, <Line: -          // If the injector is strict / strictDi, and the spec wants to inject using automatic
>, <Line: -          // annotation, then annotate the function here.
>, <Line: -          injector.annotate(blockFns[i]);
>, <Line: -        }
>, <Line: -        try {
>, <Line: -          /* jshint -W040 *//* Jasmine explicitly provides a `this` object when calling functions */
>, <Line: -          injector.invoke(blockFns[i] || angular.noop, this);
>, <Line: -          /* jshint +W040 */
>, <Line: -        } catch (e) {
>, <Line: -          if (e.stack && errorForStack) {
>, <Line: -            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
>, <Line: -          }
>, <Line: -          throw e;
>, <Line: -        } finally {
>, <Line: -          errorForStack = null;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  angular.mock.inject.strictDi = function(value) {
>, <Line: -    value = arguments.length ? !!value : true;
>, <Line: -    return isSpecRunning() ? workFn() : workFn;
>, <Line: -    function workFn() {
>, <Line: -      if (value !== currentSpec.$injectorStrict) {
>, <Line: -        if (currentSpec.$injector) {
>, <Line: -          throw new Error('Injector already created, can not modify strict annotations');
>, <Line: -        } else {
>, <Line: -          currentSpec.$injectorStrict = value;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}
>]