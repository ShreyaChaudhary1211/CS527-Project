[<Line: + Copyright (c) 2007-2014 IOLA and Ole Laursen.
>, <Line: + Licensed under the MIT license.
>, <Line: + The plugin assumes the data is sorted on x (or y if stacking horizontally).
>, <Line: + For line charts, it is assumed that if a line has an undefined gap (from a
>, <Line: + null point), then the line above it should have the same gap - insert zeros
>, <Line: + instead of "null" if you want another behaviour. This also holds for the start
>, <Line: + and end of the chart. Note that stacking a mix of positive and negative values
>, <Line: + in most instances doesn't make sense (so it looks weird).
>, <Line: + Two or more series are stacked when their "stack" attribute is set to the same
>, <Line: + key (which can be any number or string or just "true"). To specify the default
>, <Line: + stack, you can set the stack option like this:
>, <Line: + series: {
>, <Line: + stack: null/false, true, or a key (number/string)
>, <Line: + }
>, <Line: + You can also specify it for a single series, like this:
>, <Line: + $.plot( $("#placeholder"), [{
>, <Line: + data: [ ... ],
>, <Line: + stack: true
>, <Line: + }])
>, <Line: + The stacking order is determined by the order of the data series in the array
>, <Line: + (later series end up on top of the previous).
>, <Line: + Internally, the plugin modifies the datapoints in each series, adding an
>, <Line: + offset to the y value. For line series, extra data points are inserted through
>, <Line: + interpolation. If there's a second y value, it's also adjusted (e.g for bar
>, <Line: + charts or filled areas).
>, <Line: + */
>, <Line: +	var options = {
>, <Line: +		series: {stack: null} // or number/string
>, <Line: +	};
>, <Line: +	function init(plot) {
>, <Line: +		function findMatchingSeries(s, allseries) {
>, <Line: +			var res = null;
>, <Line: +			for (var i = 0; i < allseries.length; ++i) {
>, <Line: +				if (s == allseries[i])
>, <Line: +					break;
>, <Line: +				if (allseries[i].stack == s.stack)
>, <Line: +					res = allseries[i];
>, <Line: +			}
>, <Line: +			return res;
>, <Line: +		}
>, <Line: +		function stackData(plot, s, datapoints) {
>, <Line: +			if (s.stack == null || s.stack === false)
>, <Line: +				return;
>, <Line: +			var other = findMatchingSeries(s, plot.getData());
>, <Line: +			if (!other)
>, <Line: +				return;
>, <Line: +			var ps = datapoints.pointsize,
>, <Line: +				points = datapoints.points,
>, <Line: +				otherps = other.datapoints.pointsize,
>, <Line: +				otherpoints = other.datapoints.points,
>, <Line: +				newpoints = [],
>, <Line: +				px, py, intery, qx, qy, bottom,
>, <Line: +				withlines = s.lines.show,
>, <Line: +				horizontal = s.bars.horizontal,
>, <Line: +				withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
>, <Line: +				withsteps = withlines && s.lines.steps,
>, <Line: +				fromgap = true,
>, <Line: +				keyOffset = horizontal ? 1 : 0,
>, <Line: +				accumulateOffset = horizontal ? 0 : 1,
>, <Line: +				i = 0, j = 0, l, m;
>, <Line: +			while (true) {
>, <Line: +				if (i >= points.length)
>, <Line: +					break;
>, <Line: +				l = newpoints.length;
>, <Line: +				if (points[i] == null) {
>, <Line: +					// copy gaps
>, <Line: +					for (m = 0; m < ps; ++m)
>, <Line: +						newpoints.push(points[i + m]);
>, <Line: +					i += ps;
>, <Line: +				}
>, <Line: +				else if (j >= otherpoints.length) {
>, <Line: +					// for lines, we can't use the rest of the points
>, <Line: +					if (!withlines) {
>, <Line: +						for (m = 0; m < ps; ++m)
>, <Line: +							newpoints.push(points[i + m]);
>, <Line: +					}
>, <Line: +					i += ps;
>, <Line: +				}
>, <Line: +				else if (otherpoints[j] == null) {
>, <Line: +					// oops, got a gap
>, <Line: +					for (m = 0; m < ps; ++m)
>, <Line: +						newpoints.push(null);
>, <Line: +					fromgap = true;
>, <Line: +					j += otherps;
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					// cases where we actually got two points
>, <Line: +					px = points[i + keyOffset];
>, <Line: +					py = points[i + accumulateOffset];
>, <Line: +					qx = otherpoints[j + keyOffset];
>, <Line: +					qy = otherpoints[j + accumulateOffset];
>, <Line: +					bottom = 0;
>, <Line: +					if (px == qx) {
>, <Line: +						for (m = 0; m < ps; ++m)
>, <Line: +							newpoints.push(points[i + m]);
>, <Line: +						newpoints[l + accumulateOffset] += qy;
>, <Line: +						bottom = qy;
>, <Line: +						i += ps;
>, <Line: +						j += otherps;
>, <Line: +					}
>, <Line: +					else if (px > qx) {
>, <Line: +						// we got past point below, might need to
>, <Line: +						// insert interpolated extra point
>, <Line: +						if (withlines && i > 0 && points[i - ps] != null) {
>, <Line: +							intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
>, <Line: +							newpoints.push(qx);
>, <Line: +							newpoints.push(intery + qy);
>, <Line: +							for (m = 2; m < ps; ++m)
>, <Line: +								newpoints.push(points[i + m]);
>, <Line: +							bottom = qy;
>, <Line: +						}
>, <Line: +						j += otherps;
>, <Line: +					}
>, <Line: +					else { // px < qx
>, <Line: +						if (fromgap && withlines) {
>, <Line: +							// if we come from a gap, we just skip this point
>, <Line: +							i += ps;
>, <Line: +							continue;
>, <Line: +						}
>, <Line: +						for (m = 0; m < ps; ++m)
>, <Line: +							newpoints.push(points[i + m]);
>, <Line: +						// we might be able to interpolate a point below,
>, <Line: +						// this can give us a better y
>, <Line: +						if (withlines && j > 0 && otherpoints[j - otherps] != null)
>, <Line: +							bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);
>, <Line: +						newpoints[l + accumulateOffset] += bottom;
>, <Line: +						i += ps;
>, <Line: +					}
>, <Line: +					fromgap = false;
>, <Line: +					if (l != newpoints.length && withbottom)
>, <Line: +						newpoints[l + 2] += bottom;
>, <Line: +				}
>, <Line: +				// maintain the line steps invariant
>, <Line: +				if (withsteps && l != newpoints.length && l > 0
>, <Line: +					&& newpoints[l] != null
>, <Line: +					&& newpoints[l] != newpoints[l - ps]
>, <Line: +					&& newpoints[l + 1] != newpoints[l - ps + 1]) {
>, <Line: +					for (m = 0; m < ps; ++m)
>, <Line: +						newpoints[l + ps + m] = newpoints[l + m];
>, <Line: +					newpoints[l + 1] = newpoints[l - ps + 1];
>, <Line: +				}
>, <Line: +			}
>, <Line: +			datapoints.points = newpoints;
>, <Line: +		}
>, <Line: +		plot.hooks.processDatapoints.push(stackData);
>, <Line: +	}
>, <Line: +	$.plot.plugins.push({
>, <Line: +		init: init,
>, <Line: +		options: options,
>, <Line: +		name: 'stack',
>, <Line: +		version: '1.2'
>, <Line: +	});
>]
[<Line: -Copyright (c) 2007-2014 IOLA and Ole Laursen.
>, <Line: -Licensed under the MIT license.
>, <Line: -The plugin assumes the data is sorted on x (or y if stacking horizontally).
>, <Line: -For line charts, it is assumed that if a line has an undefined gap (from a
>, <Line: -null point), then the line above it should have the same gap - insert zeros
>, <Line: -instead of "null" if you want another behaviour. This also holds for the start
>, <Line: -and end of the chart. Note that stacking a mix of positive and negative values
>, <Line: -in most instances doesn't make sense (so it looks weird).
>, <Line: -Two or more series are stacked when their "stack" attribute is set to the same
>, <Line: -key (which can be any number or string or just "true"). To specify the default
>, <Line: -stack, you can set the stack option like this:
>, <Line: -    series: {
>, <Line: -        stack: null/false, true, or a key (number/string)
>, <Line: -    }
>, <Line: -You can also specify it for a single series, like this:
>, <Line: -    $.plot( $("#placeholder"), [{
>, <Line: -        data: [ ... ],
>, <Line: -        stack: true
>, <Line: -    }])
>, <Line: -The stacking order is determined by the order of the data series in the array
>, <Line: -(later series end up on top of the previous).
>, <Line: -Internally, the plugin modifies the datapoints in each series, adding an
>, <Line: -offset to the y value. For line series, extra data points are inserted through
>, <Line: -interpolation. If there's a second y value, it's also adjusted (e.g for bar
>, <Line: -charts or filled areas).
>, <Line: -*/
>, <Line: -    var options = {
>, <Line: -        series: { stack: null } // or number/string
>, <Line: -    };
>, <Line: -    function init(plot) {
>, <Line: -        function findMatchingSeries(s, allseries) {
>, <Line: -            var res = null;
>, <Line: -            for (var i = 0; i < allseries.length; ++i) {
>, <Line: -                if (s == allseries[i])
>, <Line: -                    break;
>, <Line: -                if (allseries[i].stack == s.stack)
>, <Line: -                    res = allseries[i];
>, <Line: -            }
>, <Line: -            return res;
>, <Line: -        }
>, <Line: -        function stackData(plot, s, datapoints) {
>, <Line: -            if (s.stack == null || s.stack === false)
>, <Line: -                return;
>, <Line: -            var other = findMatchingSeries(s, plot.getData());
>, <Line: -            if (!other)
>, <Line: -                return;
>, <Line: -            var ps = datapoints.pointsize,
>, <Line: -                points = datapoints.points,
>, <Line: -                otherps = other.datapoints.pointsize,
>, <Line: -                otherpoints = other.datapoints.points,
>, <Line: -                newpoints = [],
>, <Line: -                px, py, intery, qx, qy, bottom,
>, <Line: -                withlines = s.lines.show,
>, <Line: -                horizontal = s.bars.horizontal,
>, <Line: -                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
>, <Line: -                withsteps = withlines && s.lines.steps,
>, <Line: -                fromgap = true,
>, <Line: -                keyOffset = horizontal ? 1 : 0,
>, <Line: -                accumulateOffset = horizontal ? 0 : 1,
>, <Line: -                i = 0, j = 0, l, m;
>, <Line: -            while (true) {
>, <Line: -                if (i >= points.length)
>, <Line: -                    break;
>, <Line: -                l = newpoints.length;
>, <Line: -                if (points[i] == null) {
>, <Line: -                    // copy gaps
>, <Line: -                    for (m = 0; m < ps; ++m)
>, <Line: -                        newpoints.push(points[i + m]);
>, <Line: -                    i += ps;
>, <Line: -                }
>, <Line: -                else if (j >= otherpoints.length) {
>, <Line: -                    // for lines, we can't use the rest of the points
>, <Line: -                    if (!withlines) {
>, <Line: -                        for (m = 0; m < ps; ++m)
>, <Line: -                            newpoints.push(points[i + m]);
>, <Line: -                    }
>, <Line: -                    i += ps;
>, <Line: -                }
>, <Line: -                else if (otherpoints[j] == null) {
>, <Line: -                    // oops, got a gap
>, <Line: -                    for (m = 0; m < ps; ++m)
>, <Line: -                        newpoints.push(null);
>, <Line: -                    fromgap = true;
>, <Line: -                    j += otherps;
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    // cases where we actually got two points
>, <Line: -                    px = points[i + keyOffset];
>, <Line: -                    py = points[i + accumulateOffset];
>, <Line: -                    qx = otherpoints[j + keyOffset];
>, <Line: -                    qy = otherpoints[j + accumulateOffset];
>, <Line: -                    bottom = 0;
>, <Line: -                    if (px == qx) {
>, <Line: -                        for (m = 0; m < ps; ++m)
>, <Line: -                            newpoints.push(points[i + m]);
>, <Line: -                        newpoints[l + accumulateOffset] += qy;
>, <Line: -                        bottom = qy;
>, <Line: -                        i += ps;
>, <Line: -                        j += otherps;
>, <Line: -                    }
>, <Line: -                    else if (px > qx) {
>, <Line: -                        // we got past point below, might need to
>, <Line: -                        // insert interpolated extra point
>, <Line: -                        if (withlines && i > 0 && points[i - ps] != null) {
>, <Line: -                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
>, <Line: -                            newpoints.push(qx);
>, <Line: -                            newpoints.push(intery + qy);
>, <Line: -                            for (m = 2; m < ps; ++m)
>, <Line: -                                newpoints.push(points[i + m]);
>, <Line: -                            bottom = qy;
>, <Line: -                        }
>, <Line: -                        j += otherps;
>, <Line: -                    }
>, <Line: -                    else { // px < qx
>, <Line: -                        if (fromgap && withlines) {
>, <Line: -                            // if we come from a gap, we just skip this point
>, <Line: -                            i += ps;
>, <Line: -                            continue;
>, <Line: -                        }
>, <Line: -                        for (m = 0; m < ps; ++m)
>, <Line: -                            newpoints.push(points[i + m]);
>, <Line: -                        // we might be able to interpolate a point below,
>, <Line: -                        // this can give us a better y
>, <Line: -                        if (withlines && j > 0 && otherpoints[j - otherps] != null)
>, <Line: -                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);
>, <Line: -                        newpoints[l + accumulateOffset] += bottom;
>, <Line: -                        i += ps;
>, <Line: -                    }
>, <Line: -                    fromgap = false;
>, <Line: -                    if (l != newpoints.length && withbottom)
>, <Line: -                        newpoints[l + 2] += bottom;
>, <Line: -                }
>, <Line: -                // maintain the line steps invariant
>, <Line: -                if (withsteps && l != newpoints.length && l > 0
>, <Line: -                    && newpoints[l] != null
>, <Line: -                    && newpoints[l] != newpoints[l - ps]
>, <Line: -                    && newpoints[l + 1] != newpoints[l - ps + 1]) {
>, <Line: -                    for (m = 0; m < ps; ++m)
>, <Line: -                        newpoints[l + ps + m] = newpoints[l + m];
>, <Line: -                    newpoints[l + 1] = newpoints[l - ps + 1];
>, <Line: -                }
>, <Line: -            }
>, <Line: -            datapoints.points = newpoints;
>, <Line: -        }
>, <Line: -        plot.hooks.processDatapoints.push(stackData);
>, <Line: -    }
>, <Line: -    $.plot.plugins.push({
>, <Line: -        init: init,
>, <Line: -        options: options,
>, <Line: -        name: 'stack',
>, <Line: -        version: '1.2'
>, <Line: -    });
>]