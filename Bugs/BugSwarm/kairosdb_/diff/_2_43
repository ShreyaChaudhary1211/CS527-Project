[<Line: +package org.kairosdb.core.processingstage;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.inject.Binding;
>, <Line: +import com.google.inject.Injector;
>, <Line: +import com.google.inject.Key;
>, <Line: +import org.kairosdb.core.annotation.FeatureComponent;
>, <Line: +import org.kairosdb.core.processingstage.metadata.FeatureProcessorMetadata;
>, <Line: +import org.kairosdb.core.processingstage.metadata.FeaturePropertyMetadata;
>, <Line: +import javax.validation.constraints.NotNull;
>, <Line: +import java.lang.reflect.InvocationTargetException;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Comparator;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import static org.kairosdb.core.annotation.AnnotationUtils.getPropertyMetadata;
>, <Line: +public abstract class GenericFeatureProcessorFactory<FEATURE> implements FeatureProcessingFactory<FEATURE>
>, <Line: +{
>, <Line: +    private Class<FEATURE> featureClass;
>, <Line: +    protected Map<String, Class<FEATURE>> featureProcessors = new HashMap<>();
>, <Line: +    protected List<FeatureProcessorMetadata> featureProcessorMetadata = new ArrayList<>();
>, <Line: +    protected Injector injector;
>, <Line: +    /**
>, <Line: +     * Constructor of a generic class to easily generate a feature processing factory.
>, <Line: +     *
>, <Line: +     * @param injector Guice {@link Injector} instance needed for binding
>, <Line: +     * @param featureClass feature processor class
>, <Line: +     */
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +    protected GenericFeatureProcessorFactory(@NotNull Injector injector, @NotNull Class<FEATURE> featureClass)
>, <Line: +            throws InvocationTargetException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException
>, <Line: +    {
>, <Line: +        this.injector = injector;
>, <Line: +        this.featureClass = featureClass;
>, <Line: +        Map<Key<?>, Binding<?>> bindings = injector.getAllBindings();
>, <Line: +        for (Key<?> key : bindings.keySet())
>, <Line: +        {
>, <Line: +            Class<?> bindingClass = key.getTypeLiteral().getRawType();
>, <Line: +            if (featureClass.isAssignableFrom(bindingClass))
>, <Line: +            {
>, <Line: +                FeatureComponent annotation = bindingClass.getAnnotation(FeatureComponent.class);
>, <Line: +                if (annotation == null)
>, <Line: +                    throw new IllegalStateException("Processor class " + bindingClass.getName() +
>, <Line: +                            " does not have required annotation " + FeatureComponent.class.getName());
>, <Line: +                featureProcessors.put(annotation.name(), (Class<FEATURE>) bindingClass);
>, <Line: +                List<FeaturePropertyMetadata> properties = getPropertyMetadata(bindingClass);
>, <Line: +                featureProcessorMetadata.add(new FeatureProcessorMetadata(annotation.name(), labelizeComponent(annotation), annotation.description(), properties));
>, <Line: +            }
>, <Line: +        }
>, <Line: +        featureProcessorMetadata.sort(Comparator.comparing(FeatureProcessorMetadata::getName));
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public Class<FEATURE> getFeature() { return featureClass; }
>, <Line: +    @Override
>, <Line: +    public ImmutableList<FeatureProcessorMetadata> getFeatureProcessorMetadata()
>, <Line: +    {
>, <Line: +        return new ImmutableList.Builder<FeatureProcessorMetadata>().addAll(featureProcessorMetadata).build();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public FEATURE createFeatureProcessor(String name)
>, <Line: +    {
>, <Line: +        Class<FEATURE> processClass = featureProcessors.get(name);
>, <Line: +        if (processClass == null)
>, <Line: +            return (null);
>, <Line: +        return (injector.getInstance(processClass));
>, <Line: +    }
>, <Line: +    private String labelizeComponent(FeatureComponent annotation)
>, <Line: +    {
>, <Line: +        if (!annotation.label().isEmpty())
>, <Line: +            return annotation.label();
>, <Line: +        StringBuilder label = new StringBuilder();
>, <Line: +        for (String word : annotation.name().toLowerCase().split("_"))
>, <Line: +        {
>, <Line: +            label.append(word.substring(0, 1).toUpperCase());
>, <Line: +            label.append(word.substring(1));
>, <Line: +            label.append(" ");
>, <Line: +        }
>, <Line: +        return label.toString().trim();
>, <Line: +    }
>, <Line: +}
>]
[]