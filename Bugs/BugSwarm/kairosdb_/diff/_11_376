[<Line: +////////////////////////////////////////////////////////////////////////////////////
>, <Line: +//
>, <Line: +//  prettycron.js
>, <Line: +//  Generates human-readable sentences from a schedule string in cron format
>, <Line: +//
>, <Line: +//  Based on an earlier version by Pehr Johansson
>, <Line: +//  http://dsysadm.blogspot.com.au/2012/09/human-readable-cron-expressions-using.html
>, <Line: +//
>, <Line: +////////////////////////////////////////////////////////////////////////////////////
>, <Line: +//  This program is free software: you can redistribute it and/or modify
>, <Line: +//  it under the terms of the GNU Lesser General Public License as published
>, <Line: +//  by the Free Software Foundation, either version 3 of the License, or
>, <Line: +//  (at your option) any later version.
>, <Line: +//
>, <Line: +//  This program is distributed in the hope that it will be useful,
>, <Line: +//  but WITHOUT ANY WARRANTY; without even the implied warranty of
>, <Line: +//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>, <Line: +//  GNU Lesser General Public License for more details.
>, <Line: +//
>, <Line: +//  You should have received a copy of the GNU Lesser General Public License
>, <Line: +//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
>, <Line: +////////////////////////////////////////////////////////////////////////////////////
>, <Line: +if ((!moment || !later) && (typeof require !== 'undefined')) {
>, <Line: +	var moment = require('moment');
>, <Line: +	var later = require('later');
>, <Line: +}
>, <Line: +(function () {
>, <Line: +	/*
>, <Line: +	 * For an array of numbers, e.g. a list of hours in a schedule,
>, <Line: +	 * return a string listing out all of the values (complete with
>, <Line: +	 * "and" plus ordinal text on the last item).
>, <Line: +	 */
>, <Line: +	var numberList = function (numbers) {
>, <Line: +		if (numbers.length < 2) {
>, <Line: +			return moment()._locale.ordinal(numbers);
>, <Line: +		}
>, <Line: +		var last_val = numbers.pop();
>, <Line: +		return numbers.join(', ') + ' and ' + moment()._locale.ordinal(last_val);
>, <Line: +	};
>, <Line: +	/*
>, <Line: +	 * Parse a number into day of week, or a month name;
>, <Line: +	 * used in dateList below.
>, <Line: +	 */
>, <Line: +	var numberToDateName = function (value, type) {
>, <Line: +		if (type == 'dow') {
>, <Line: +			return moment().day(value - 1).format('ddd');
>, <Line: +		} else if (type == 'mon') {
>, <Line: +			return moment().month(value - 1).format('MMM');
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/*
>, <Line: +	 * From an array of numbers corresponding to dates (given in type: either
>, <Line: +	 * days of the week, or months), return a string listing all the values.
>, <Line: +	 */
>, <Line: +	var dateList = function (numbers, type) {
>, <Line: +		if (numbers.length < 2) {
>, <Line: +			return numberToDateName('' + numbers[0], type);
>, <Line: +		}
>, <Line: +		var last_val = '' + numbers.pop();
>, <Line: +		var output_text = '';
>, <Line: +		for (var i = 0, value; value = numbers[i]; i++) {
>, <Line: +			if (output_text.length > 0) {
>, <Line: +				output_text += ', ';
>, <Line: +			}
>, <Line: +			output_text += numberToDateName(value, type);
>, <Line: +		}
>, <Line: +		return output_text + ' and ' + numberToDateName(last_val, type);
>, <Line: +	};
>, <Line: +	/*
>, <Line: +	 * Pad to equivalent of sprintf('%02d'). Both moment.js and later.js
>, <Line: +	 * have zero-fill functions, but alas, they're private.
>, <Line: +	 */
>, <Line: +	var zeroPad = function (x) {
>, <Line: +		return (x < 10) ? '0' + x : x;
>, <Line: +	};
>, <Line: +	//----------------
>, <Line: +	/*
>, <Line: +	 * Given a schedule from later.js (i.e. after parsing the cronspec),
>, <Line: +	 * generate a friendly sentence description.
>, <Line: +	 */
>, <Line: +	var scheduleToSentence = function (schedule) {
>, <Line: +		var output_text = 'Every ';
>, <Line: +		if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {
>, <Line: +			// If there are only one or two specified values for
>, <Line: +			// hour or minute, print them in HH:MM format
>, <Line: +			var hm = [];
>, <Line: +			for (var i = 0; i < schedule['h'].length; i++) {
>, <Line: +				for (var j = 0; j < schedule['m'].length; j++) {
>, <Line: +					hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (hm.length < 2) {
>, <Line: +				output_text = hm[0];
>, <Line: +			} else {
>, <Line: +				var last_val = hm.pop();
>, <Line: +				output_text = hm.join(', ') + ' and ' + last_val;
>, <Line: +			}
>, <Line: +			if (!schedule['d'] && !schedule['D']) {
>, <Line: +				output_text += ' every day';
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			// Otherwise, list out every specified hour/minute value.
>, <Line: +			if (schedule['h']) { // runs only at specific hours
>, <Line: +				if (schedule['m']) { // and only at specific minutes
>, <Line: +					output_text += numberList(schedule['m']) + ' minute past the ' + numberList(schedule['h']) + ' hour';
>, <Line: +				} else { // specific hours, but every minute
>, <Line: +					output_text += 'minute of ' + numberList(schedule['h']) + ' hour';
>, <Line: +				}
>, <Line: +			} else if (schedule['m']) { // every hour, but specific minutes
>, <Line: +				if (schedule['m'].length == 1 && schedule['m'][0] == 0) {
>, <Line: +					output_text += 'hour, on the hour';
>, <Line: +				} else {
>, <Line: +					output_text += numberList(schedule['m']) + ' minute past every hour';
>, <Line: +				}
>, <Line: +			} else { // cronspec has "*" for both hour and minute
>, <Line: +				output_text += 'minute';
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (schedule['D']) { // runs only on specific day(s) of month
>, <Line: +			output_text += ' on the ' + numberList(schedule['D']);
>, <Line: +			if (!schedule['M']) {
>, <Line: +				output_text += ' of every month';
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (schedule['d']) { // runs only on specific day(s) of week
>, <Line: +			if (schedule['D']) {
>, <Line: +				// if both day fields are specified, cron uses both; superuser.com/a/348372
>, <Line: +				output_text += ' and every ';
>, <Line: +			} else {
>, <Line: +				output_text += ' on ';
>, <Line: +			}
>, <Line: +			output_text += dateList(schedule['d'], 'dow');
>, <Line: +		}
>, <Line: +		if (schedule['M']) {
>, <Line: +			// runs only in specific months; put this output last
>, <Line: +			output_text += ' in ' + dateList(schedule['M'], 'mon');
>, <Line: +		}
>, <Line: +		return output_text;
>, <Line: +	};
>, <Line: +	//----------------
>, <Line: +	/*
>, <Line: +	 * Given a cronspec, return the human-readable string.
>, <Line: +	 */
>, <Line: +	var toString = function (cronspec, sixth) {
>, <Line: +		var schedule = later.parse.cron(cronspec, sixth);
>, <Line: +		return scheduleToSentence(schedule['schedules'][0]);
>, <Line: +	};
>, <Line: +	/*
>, <Line: +	 * Given a cronspec, return the next date for when it will next run.
>, <Line: +	 * (This is just a wrapper for later.js)
>, <Line: +	 */
>, <Line: +	var getNextDate = function (cronspec, sixth) {
>, <Line: +		var schedule = later.parse.cron(cronspec, sixth);
>, <Line: +		return later.schedule(schedule).next();
>, <Line: +	};
>, <Line: +	/*
>, <Line: +	 * Given a cronspec, return a friendly string for when it will next run.
>, <Line: +	 * (This is just a wrapper for later.js and moment.js)
>, <Line: +	 */
>, <Line: +	var getNext = function (cronspec, sixth) {
>, <Line: +		return moment(getNextDate(cronspec, sixth)).calendar();
>, <Line: +	};
>, <Line: +	//----------------
>, <Line: +	// attach ourselves to window in the browser, and to exports in Node,
>, <Line: +	// so our functions can always be called as prettyCron.toString()
>, <Line: +	var global_obj = (typeof exports !== "undefined" && exports !== null) ? exports : window.prettyCron = {};
>, <Line: +	global_obj.toString = toString;
>, <Line: +	global_obj.getNext = getNext;
>, <Line: +	global_obj.getNextDate = getNextDate;
>, <Line: +}).call(this);
>]
[]