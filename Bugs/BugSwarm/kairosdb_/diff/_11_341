[<Line: + Copyright (c) 2007-2014 IOLA and Ole Laursen.
>, <Line: + Licensed under the MIT license.
>, <Line: + */
>, <Line: +(function ($) {
>, <Line: +	$.color = {};
>, <Line: +	$.color.make = function (r, g, b, a) {
>, <Line: +		var o = {};
>, <Line: +		o.r = r || 0;
>, <Line: +		o.g = g || 0;
>, <Line: +		o.b = b || 0;
>, <Line: +		o.a = a != null ? a : 1;
>, <Line: +		o.add = function (c, d) {
>, <Line: +			for (var i = 0; i < c.length; ++i)o[c.charAt(i)] += d;
>, <Line: +			return o.normalize()
>, <Line: +		};
>, <Line: +		o.scale = function (c, f) {
>, <Line: +			for (var i = 0; i < c.length; ++i)o[c.charAt(i)] *= f;
>, <Line: +			return o.normalize()
>, <Line: +		};
>, <Line: +		o.toString = function () {
>, <Line: +			if (o.a >= 1) {
>, <Line: +				return "rgb(" + [o.r, o.g, o.b].join(",") + ")"
>, <Line: +			} else {
>, <Line: +				return "rgba(" + [o.r, o.g, o.b, o.a].join(",") + ")"
>, <Line: +			}
>, <Line: +		};
>, <Line: +		o.normalize = function () {
>, <Line: +			function clamp(min, value, max) {
>, <Line: +				return value < min ? min : value > max ? max : value
>, <Line: +			}
>, <Line: +			o.r = clamp(0, parseInt(o.r), 255);
>, <Line: +			o.g = clamp(0, parseInt(o.g), 255);
>, <Line: +			o.b = clamp(0, parseInt(o.b), 255);
>, <Line: +			o.a = clamp(0, o.a, 1);
>, <Line: +			return o
>, <Line: +		};
>, <Line: +		o.clone = function () {
>, <Line: +			return $.color.make(o.r, o.b, o.g, o.a)
>, <Line: +		};
>, <Line: +		return o.normalize()
>, <Line: +	};
>, <Line: +	$.color.extract = function (elem, css) {
>, <Line: +		var c;
>, <Line: +		do {
>, <Line: +			c = elem.css(css).toLowerCase();
>, <Line: +			if (c != "" && c != "transparent")break;
>, <Line: +			elem = elem.parent()
>, <Line: +		} while (elem.length && !$.nodeName(elem.get(0), "body"));
>, <Line: +		if (c == "rgba(0, 0, 0, 0)")c = "transparent";
>, <Line: +		return $.color.parse(c)
>, <Line: +	};
>, <Line: +	$.color.parse = function (str) {
>, <Line: +		var res, m = $.color.make;
>, <Line: +		if (res = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));
>, <Line: +		if (res = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));
>, <Line: +		if (res = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);
>, <Line: +		if (res = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));
>, <Line: +		if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));
>, <Line: +		if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));
>, <Line: +		var name = $.trim(str).toLowerCase();
>, <Line: +		if (name == "transparent")return m(255, 255, 255, 0); else {
>, <Line: +			res = lookupColors[name] || [0, 0, 0];
>, <Line: +			return m(res[0], res[1], res[2])
>, <Line: +		}
>, <Line: +	};
>, <Line: +	var lookupColors = {
>, <Line: +		aqua: [0, 255, 255],
>, <Line: +		azure: [240, 255, 255],
>, <Line: +		beige: [245, 245, 220],
>, <Line: +		black: [0, 0, 0],
>, <Line: +		blue: [0, 0, 255],
>, <Line: +		brown: [165, 42, 42],
>, <Line: +		cyan: [0, 255, 255],
>, <Line: +		darkblue: [0, 0, 139],
>, <Line: +		darkcyan: [0, 139, 139],
>, <Line: +		darkgrey: [169, 169, 169],
>, <Line: +		darkgreen: [0, 100, 0],
>, <Line: +		darkkhaki: [189, 183, 107],
>, <Line: +		darkmagenta: [139, 0, 139],
>, <Line: +		darkolivegreen: [85, 107, 47],
>, <Line: +		darkorange: [255, 140, 0],
>, <Line: +		darkorchid: [153, 50, 204],
>, <Line: +		darkred: [139, 0, 0],
>, <Line: +		darksalmon: [233, 150, 122],
>, <Line: +		darkviolet: [148, 0, 211],
>, <Line: +		fuchsia: [255, 0, 255],
>, <Line: +		gold: [255, 215, 0],
>, <Line: +		green: [0, 128, 0],
>, <Line: +		indigo: [75, 0, 130],
>, <Line: +		khaki: [240, 230, 140],
>, <Line: +		lightblue: [173, 216, 230],
>, <Line: +		lightcyan: [224, 255, 255],
>, <Line: +		lightgreen: [144, 238, 144],
>, <Line: +		lightgrey: [211, 211, 211],
>, <Line: +		lightpink: [255, 182, 193],
>, <Line: +		lightyellow: [255, 255, 224],
>, <Line: +		lime: [0, 255, 0],
>, <Line: +		magenta: [255, 0, 255],
>, <Line: +		maroon: [128, 0, 0],
>, <Line: +		navy: [0, 0, 128],
>, <Line: +		olive: [128, 128, 0],
>, <Line: +		orange: [255, 165, 0],
>, <Line: +		pink: [255, 192, 203],
>, <Line: +		purple: [128, 0, 128],
>, <Line: +		violet: [128, 0, 128],
>, <Line: +		red: [255, 0, 0],
>, <Line: +		silver: [192, 192, 192],
>, <Line: +		white: [255, 255, 255],
>, <Line: +		yellow: [255, 255, 0]
>, <Line: +	}
>, <Line: +})(jQuery);
>, <Line: +(function ($) {
>, <Line: +	// A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM
>, <Line: +	// operation produces the same effect as detach, i.e. removing the element
>, <Line: +	// without touching its jQuery data.
>, <Line: +	// Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.
>, <Line: +	if (!$.fn.detach) {
>, <Line: +		$.fn.detach = function () {
>, <Line: +			return this.each(function () {
>, <Line: +				if (this.parentNode) {
>, <Line: +					this.parentNode.removeChild(this);
>, <Line: +				}
>, <Line: +			});
>, <Line: +		};
>, <Line: +	}
>, <Line: +			$(element).css({
>, <Line: +				direction: "ltr",
>, <Line: +				position: "absolute",
>, <Line: +				left: 0,
>, <Line: +				top: 0
>, <Line: +			})
>, <Line: +	Canvas.prototype.resize = function (width, height) {
>, <Line: +	Canvas.prototype.clear = function () {
>, <Line: +	Canvas.prototype.render = function () {
>, <Line: +	Canvas.prototype.getTextLayer = function (classes) {
>, <Line: +	Canvas.prototype.getTextInfo = function (layer, text, font, angle, width) {
>, <Line: +	Canvas.prototype.addText = function (layer, x, y, text, font, angle, width, halign, valign) {
>, <Line: +	Canvas.prototype.removeText = function (layer, x, y, text, font, angle) {
>, <Line: +	function Plot(placeholder, data_, options_, plugins) {
>, <Line: +		// data is on the form:
>, <Line: +		//   [ series1, series2 ... ]
>, <Line: +		// where series is either just the data as [ [x1, y1], [x2, y2], ... ]
>, <Line: +		// or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }
>, <Line: +		var series = [],
>, <Line: +			options = {
>, <Line: +				// the color theme used for graphs
>, <Line: +				colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
>, <Line: +				legend: {
>, <Line: +					show: true,
>, <Line: +					noColumns: 1, // number of colums in legend table
>, <Line: +					labelFormatter: null, // fn: string -> string
>, <Line: +					labelBoxBorderColor: "#ccc", // border color for the little label boxes
>, <Line: +					container: null, // container (as jQuery object) to put legend in, null means default on top of graph
>, <Line: +					position: "ne", // position of default legend container within plot
>, <Line: +					margin: 5, // distance from grid edge to default legend container within plot
>, <Line: +					backgroundColor: null, // null means auto-detect
>, <Line: +					backgroundOpacity: 0.85, // set to 0 to avoid background
>, <Line: +					sorted: null    // default to no legend sorting
>, <Line: +				},
>, <Line: +				xaxis: {
>, <Line: +					show: null, // null = auto-detect, true = always, false = never
>, <Line: +					position: "bottom", // or "top"
>, <Line: +					mode: null, // null or "time"
>, <Line: +					font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
>, <Line: +					color: null, // base color, labels, ticks
>, <Line: +					tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
>, <Line: +					transform: null, // null or f: number -> number to transform axis
>, <Line: +					inverseTransform: null, // if transform is set, this should be the inverse function
>, <Line: +					min: null, // min. value to show, null means set automatically
>, <Line: +					max: null, // max. value to show, null means set automatically
>, <Line: +					autoscaleMargin: null, // margin in % to add if auto-setting min/max
>, <Line: +					ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
>, <Line: +					tickFormatter: null, // fn: number -> string
>, <Line: +					labelWidth: null, // size of tick labels in pixels
>, <Line: +					labelHeight: null,
>, <Line: +					reserveSpace: null, // whether to reserve space even if axis isn't shown
>, <Line: +					tickLength: null, // size in pixels of ticks, or "full" for whole line
>, <Line: +					alignTicksWithAxis: null, // axis number or null for no sync
>, <Line: +					tickDecimals: null, // no. of decimals, null means auto
>, <Line: +					tickSize: null, // number or [number, "unit"]
>, <Line: +					minTickSize: null // number or [number, "unit"]
>, <Line: +				},
>, <Line: +				yaxis: {
>, <Line: +					autoscaleMargin: 0.02,
>, <Line: +					position: "left" // or "right"
>, <Line: +				},
>, <Line: +				xaxes: [],
>, <Line: +				yaxes: [],
>, <Line: +				series: {
>, <Line: +					points: {
>, <Line: +						show: false,
>, <Line: +						radius: 3,
>, <Line: +						lineWidth: 2, // in pixels
>, <Line: +						fill: true,
>, <Line: +						fillColor: "#ffffff",
>, <Line: +						symbol: "circle" // or callback
>, <Line: +					},
>, <Line: +					lines: {
>, <Line: +						// we don't put in show: false so we can see
>, <Line: +						// whether lines were actively disabled
>, <Line: +						lineWidth: 2, // in pixels
>, <Line: +						fill: false,
>, <Line: +						fillColor: null,
>, <Line: +						steps: false
>, <Line: +						// Omit 'zero', so we can later default its value to
>, <Line: +						// match that of the 'fill' option.
>, <Line: +					},
>, <Line: +					bars: {
>, <Line: +						show: false,
>, <Line: +						lineWidth: 2, // in pixels
>, <Line: +						barWidth: 1, // in units of the x axis
>, <Line: +						fill: true,
>, <Line: +						fillColor: null,
>, <Line: +						align: "left", // "left", "right", or "center"
>, <Line: +						horizontal: false,
>, <Line: +						zero: true
>, <Line: +					},
>, <Line: +					shadowSize: 3,
>, <Line: +					highlightColor: null
>, <Line: +				},
>, <Line: +				grid: {
>, <Line: +					show: true,
>, <Line: +					aboveData: false,
>, <Line: +					color: "#545454", // primary color used for outline and labels
>, <Line: +					backgroundColor: null, // null for transparent, else color
>, <Line: +					borderColor: null, // set if different from the grid color
>, <Line: +					tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
>, <Line: +					margin: 0, // distance from the canvas edge to the grid
>, <Line: +					labelMargin: 5, // in pixels
>, <Line: +					axisMargin: 8, // in pixels
>, <Line: +					borderWidth: 2, // in pixels
>, <Line: +					minBorderMargin: null, // in pixels, null means taken from points radius
>, <Line: +					markings: null, // array of ranges or fn: axes -> array of ranges
>, <Line: +					markingsColor: "#f4f4f4",
>, <Line: +					markingsLineWidth: 2,
>, <Line: +					// interactive stuff
>, <Line: +					clickable: false,
>, <Line: +					hoverable: false,
>, <Line: +					autoHighlight: true, // highlight in case mouse is near
>, <Line: +					mouseActiveRadius: 10 // how far the mouse can be away to activate an item
>, <Line: +				},
>, <Line: +				interaction: {
>, <Line: +					redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow
>, <Line: +				},
>, <Line: +				hooks: {}
>, <Line: +			},
>, <Line: +			surface = null,     // the canvas for the plot itself
>, <Line: +			overlay = null,     // canvas for interactive stuff on top of plot
>, <Line: +			eventHolder = null, // jQuery object that events should be bound to
>, <Line: +			ctx = null, octx = null,
>, <Line: +			xaxes = [], yaxes = [],
>, <Line: +			plotOffset = {left: 0, right: 0, top: 0, bottom: 0},
>, <Line: +			plotWidth = 0, plotHeight = 0,
>, <Line: +			hooks = {
>, <Line: +				processOptions: [],
>, <Line: +				processRawData: [],
>, <Line: +				processDatapoints: [],
>, <Line: +				processOffset: [],
>, <Line: +				drawBackground: [],
>, <Line: +				drawSeries: [],
>, <Line: +				draw: [],
>, <Line: +				bindEvents: [],
>, <Line: +				drawOverlay: [],
>, <Line: +				shutdown: []
>, <Line: +			},
>, <Line: +			plot = this;
>, <Line: +		// public functions
>, <Line: +		plot.setData = setData;
>, <Line: +		plot.setupGrid = setupGrid;
>, <Line: +		plot.draw = draw;
>, <Line: +		plot.getPlaceholder = function () {
>, <Line: +			return placeholder;
>, <Line: +		};
>, <Line: +		plot.getCanvas = function () {
>, <Line: +			return surface.element;
>, <Line: +		};
>, <Line: +		plot.getPlotOffset = function () {
>, <Line: +			return plotOffset;
>, <Line: +		};
>, <Line: +		plot.width = function () {
>, <Line: +			return plotWidth;
>, <Line: +		};
>, <Line: +		plot.height = function () {
>, <Line: +			return plotHeight;
>, <Line: +		};
>, <Line: +		plot.offset = function () {
>, <Line: +			var o = eventHolder.offset();
>, <Line: +			o.left += plotOffset.left;
>, <Line: +			o.top += plotOffset.top;
>, <Line: +			return o;
>, <Line: +		};
>, <Line: +		plot.getData = function () {
>, <Line: +			return series;
>, <Line: +		};
>, <Line: +		plot.getAxes = function () {
>, <Line: +			var res = {}, i;
>, <Line: +			$.each(xaxes.concat(yaxes), function (_, axis) {
>, <Line: +				if (axis)
>, <Line: +					res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
>, <Line: +			});
>, <Line: +			return res;
>, <Line: +		};
>, <Line: +		plot.getXAxes = function () {
>, <Line: +			return xaxes;
>, <Line: +		};
>, <Line: +		plot.getYAxes = function () {
>, <Line: +			return yaxes;
>, <Line: +		};
>, <Line: +		plot.c2p = canvasToAxisCoords;
>, <Line: +		plot.p2c = axisToCanvasCoords;
>, <Line: +		plot.getOptions = function () {
>, <Line: +			return options;
>, <Line: +		};
>, <Line: +		plot.highlight = highlight;
>, <Line: +		plot.unhighlight = unhighlight;
>, <Line: +		plot.triggerRedrawOverlay = triggerRedrawOverlay;
>, <Line: +		plot.pointOffset = function (point) {
>, <Line: +			return {
>, <Line: +				left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
>, <Line: +				top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
>, <Line: +			};
>, <Line: +		};
>, <Line: +		plot.shutdown = shutdown;
>, <Line: +		plot.destroy = function () {
>, <Line: +			shutdown();
>, <Line: +			placeholder.removeData("plot").empty();
>, <Line: +			series = [];
>, <Line: +			options = null;
>, <Line: +			surface = null;
>, <Line: +			overlay = null;
>, <Line: +			eventHolder = null;
>, <Line: +			ctx = null;
>, <Line: +			octx = null;
>, <Line: +			xaxes = [];
>, <Line: +			yaxes = [];
>, <Line: +			hooks = null;
>, <Line: +			highlights = [];
>, <Line: +			plot = null;
>, <Line: +		};
>, <Line: +		plot.resize = function () {
>, <Line: +			var width = placeholder.width(),
>, <Line: +				height = placeholder.height();
>, <Line: +			surface.resize(width, height);
>, <Line: +			overlay.resize(width, height);
>, <Line: +		};
>, <Line: +		// public attributes
>, <Line: +		plot.hooks = hooks;
>, <Line: +		// initialize
>, <Line: +		initPlugins(plot);
>, <Line: +		parseOptions(options_);
>, <Line: +		setupCanvases();
>, <Line: +		setData(data_);
>, <Line: +		setupGrid();
>, <Line: +		draw();
>, <Line: +		bindEvents();
>, <Line: +		function executeHooks(hook, args) {
>, <Line: +			args = [plot].concat(args);
>, <Line: +			for (var i = 0; i < hook.length; ++i)
>, <Line: +				hook[i].apply(this, args);
>, <Line: +		}
>, <Line: +		function initPlugins() {
>, <Line: +			// References to key classes, allowing plugins to modify them
>, <Line: +			var classes = {
>, <Line: +				Canvas: Canvas
>, <Line: +			};
>, <Line: +			for (var i = 0; i < plugins.length; ++i) {
>, <Line: +				var p = plugins[i];
>, <Line: +				p.init(plot, classes);
>, <Line: +				if (p.options)
>, <Line: +					$.extend(true, options, p.options);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function parseOptions(opts) {
>, <Line: +			$.extend(true, options, opts);
>, <Line: +			// $.extend merges arrays, rather than replacing them.  When less
>, <Line: +			// colors are provided than the size of the default palette, we
>, <Line: +			// end up with those colors plus the remaining defaults, which is
>, <Line: +			// not expected behavior; avoid it by replacing them here.
>, <Line: +			if (opts && opts.colors) {
>, <Line: +				options.colors = opts.colors;
>, <Line: +			}
>, <Line: +			if (options.xaxis.color == null)
>, <Line: +				options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: +			if (options.yaxis.color == null)
>, <Line: +				options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: +			if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
>, <Line: +				options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
>, <Line: +			if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
>, <Line: +				options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
>, <Line: +			if (options.grid.borderColor == null)
>, <Line: +				options.grid.borderColor = options.grid.color;
>, <Line: +			if (options.grid.tickColor == null)
>, <Line: +				options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: +			// Fill in defaults for axis options, including any unspecified
>, <Line: +			// font-spec fields, if a font-spec was provided.
>, <Line: +			// If no x/y axis options were provided, create one of each anyway,
>, <Line: +			// since the rest of the code assumes that they exist.
>, <Line: +			var i, axisOptions, axisCount,
>, <Line: +				fontSize = placeholder.css("font-size"),
>, <Line: +				fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
>, <Line: +				fontDefaults = {
>, <Line: +					style: placeholder.css("font-style"),
>, <Line: +					size: Math.round(0.8 * fontSizeDefault),
>, <Line: +					variant: placeholder.css("font-variant"),
>, <Line: +					weight: placeholder.css("font-weight"),
>, <Line: +					family: placeholder.css("font-family")
>, <Line: +				};
>, <Line: +			axisCount = options.xaxes.length || 1;
>, <Line: +			for (i = 0; i < axisCount; ++i) {
>, <Line: +				axisOptions = options.xaxes[i];
>, <Line: +				if (axisOptions && !axisOptions.tickColor) {
>, <Line: +					axisOptions.tickColor = axisOptions.color;
>, <Line: +				}
>, <Line: +				axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
>, <Line: +				options.xaxes[i] = axisOptions;
>, <Line: +				if (axisOptions.font) {
>, <Line: +					axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
>, <Line: +					if (!axisOptions.font.color) {
>, <Line: +						axisOptions.font.color = axisOptions.color;
>, <Line: +					}
>, <Line: +					if (!axisOptions.font.lineHeight) {
>, <Line: +						axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			axisCount = options.yaxes.length || 1;
>, <Line: +			for (i = 0; i < axisCount; ++i) {
>, <Line: +				axisOptions = options.yaxes[i];
>, <Line: +				if (axisOptions && !axisOptions.tickColor) {
>, <Line: +					axisOptions.tickColor = axisOptions.color;
>, <Line: +				}
>, <Line: +				axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
>, <Line: +				options.yaxes[i] = axisOptions;
>, <Line: +				if (axisOptions.font) {
>, <Line: +					axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
>, <Line: +					if (!axisOptions.font.color) {
>, <Line: +						axisOptions.font.color = axisOptions.color;
>, <Line: +					}
>, <Line: +					if (!axisOptions.font.lineHeight) {
>, <Line: +						axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// backwards compatibility, to be removed in future
>, <Line: +			if (options.xaxis.noTicks && options.xaxis.ticks == null)
>, <Line: +				options.xaxis.ticks = options.xaxis.noTicks;
>, <Line: +			if (options.yaxis.noTicks && options.yaxis.ticks == null)
>, <Line: +				options.yaxis.ticks = options.yaxis.noTicks;
>, <Line: +			if (options.x2axis) {
>, <Line: +				options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
>, <Line: +				options.xaxes[1].position = "top";
>, <Line: +				// Override the inherit to allow the axis to auto-scale
>, <Line: +				if (options.x2axis.min == null) {
>, <Line: +					options.xaxes[1].min = null;
>, <Line: +				}
>, <Line: +				if (options.x2axis.max == null) {
>, <Line: +					options.xaxes[1].max = null;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (options.y2axis) {
>, <Line: +				options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
>, <Line: +				options.yaxes[1].position = "right";
>, <Line: +				// Override the inherit to allow the axis to auto-scale
>, <Line: +				if (options.y2axis.min == null) {
>, <Line: +					options.yaxes[1].min = null;
>, <Line: +				}
>, <Line: +				if (options.y2axis.max == null) {
>, <Line: +					options.yaxes[1].max = null;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (options.grid.coloredAreas)
>, <Line: +				options.grid.markings = options.grid.coloredAreas;
>, <Line: +			if (options.grid.coloredAreasColor)
>, <Line: +				options.grid.markingsColor = options.grid.coloredAreasColor;
>, <Line: +			if (options.lines)
>, <Line: +				$.extend(true, options.series.lines, options.lines);
>, <Line: +			if (options.points)
>, <Line: +				$.extend(true, options.series.points, options.points);
>, <Line: +			if (options.bars)
>, <Line: +				$.extend(true, options.series.bars, options.bars);
>, <Line: +			if (options.shadowSize != null)
>, <Line: +				options.series.shadowSize = options.shadowSize;
>, <Line: +			if (options.highlightColor != null)
>, <Line: +				options.series.highlightColor = options.highlightColor;
>, <Line: +			// save options on axes for future reference
>, <Line: +			for (i = 0; i < options.xaxes.length; ++i)
>, <Line: +				getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
>, <Line: +			for (i = 0; i < options.yaxes.length; ++i)
>, <Line: +				getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
>, <Line: +			// add hooks from options
>, <Line: +			for (var n in hooks)
>, <Line: +				if (options.hooks[n] && options.hooks[n].length)
>, <Line: +					hooks[n] = hooks[n].concat(options.hooks[n]);
>, <Line: +			executeHooks(hooks.processOptions, [options]);
>, <Line: +		}
>, <Line: +		function setData(d) {
>, <Line: +			series = parseData(d);
>, <Line: +			fillInSeriesOptions();
>, <Line: +			processData();
>, <Line: +		}
>, <Line: +		function parseData(d) {
>, <Line: +			var res = [];
>, <Line: +			for (var i = 0; i < d.length; ++i) {
>, <Line: +				var s = $.extend(true, {}, options.series);
>, <Line: +				if (d[i].data != null) {
>, <Line: +					s.data = d[i].data; // move the data instead of deep-copy
>, <Line: +					delete d[i].data;
>, <Line: +					$.extend(true, s, d[i]);
>, <Line: +					d[i].data = s.data;
>, <Line: +				}
>, <Line: +				else
>, <Line: +					s.data = d[i];
>, <Line: +				res.push(s);
>, <Line: +			}
>, <Line: +			return res;
>, <Line: +		}
>, <Line: +		function axisNumber(obj, coord) {
>, <Line: +			var a = obj[coord + "axis"];
>, <Line: +			if (typeof a == "object") // if we got a real axis, extract number
>, <Line: +				a = a.n;
>, <Line: +			if (typeof a != "number")
>, <Line: +				a = 1; // default to first axis
>, <Line: +			return a;
>, <Line: +		}
>, <Line: +		function allAxes() {
>, <Line: +			// return flat array without annoying null entries
>, <Line: +			return $.grep(xaxes.concat(yaxes), function (a) {
>, <Line: +				return a;
>, <Line: +			});
>, <Line: +		}
>, <Line: +		function canvasToAxisCoords(pos) {
>, <Line: +			// return an object with x/y corresponding to all used axes
>, <Line: +			var res = {}, i, axis;
>, <Line: +			for (i = 0; i < xaxes.length; ++i) {
>, <Line: +				axis = xaxes[i];
>, <Line: +				if (axis && axis.used)
>, <Line: +					res["x" + axis.n] = axis.c2p(pos.left);
>, <Line: +			}
>, <Line: +			for (i = 0; i < yaxes.length; ++i) {
>, <Line: +				axis = yaxes[i];
>, <Line: +				if (axis && axis.used)
>, <Line: +					res["y" + axis.n] = axis.c2p(pos.top);
>, <Line: +			}
>, <Line: +			if (res.x1 !== undefined)
>, <Line: +				res.x = res.x1;
>, <Line: +			if (res.y1 !== undefined)
>, <Line: +				res.y = res.y1;
>, <Line: +			return res;
>, <Line: +		}
>, <Line: +		function axisToCanvasCoords(pos) {
>, <Line: +			// get canvas coords from the first pair of x/y found in pos
>, <Line: +			var res = {}, i, axis, key;
>, <Line: +			for (i = 0; i < xaxes.length; ++i) {
>, <Line: +				axis = xaxes[i];
>, <Line: +				if (axis && axis.used) {
>, <Line: +					key = "x" + axis.n;
>, <Line: +					if (pos[key] == null && axis.n == 1)
>, <Line: +						key = "x";
>, <Line: +					if (pos[key] != null) {
>, <Line: +						res.left = axis.p2c(pos[key]);
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			for (i = 0; i < yaxes.length; ++i) {
>, <Line: +				axis = yaxes[i];
>, <Line: +				if (axis && axis.used) {
>, <Line: +					key = "y" + axis.n;
>, <Line: +					if (pos[key] == null && axis.n == 1)
>, <Line: +						key = "y";
>, <Line: +					if (pos[key] != null) {
>, <Line: +						res.top = axis.p2c(pos[key]);
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return res;
>, <Line: +		}
>, <Line: +		function getOrCreateAxis(axes, number) {
>, <Line: +			if (!axes[number - 1])
>, <Line: +				axes[number - 1] = {
>, <Line: +					n: number, // save the number for future reference
>, <Line: +					direction: axes == xaxes ? "x" : "y",
>, <Line: +					options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
>, <Line: +				};
>, <Line: +			return axes[number - 1];
>, <Line: +		}
>, <Line: +		function fillInSeriesOptions() {
>, <Line: +			var neededColors = series.length, maxIndex = -1, i;
>, <Line: +			// Subtract the number of series that already have fixed colors or
>, <Line: +			// color indexes from the number that we still need to generate.
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				var sc = series[i].color;
>, <Line: +				if (sc != null) {
>, <Line: +					neededColors--;
>, <Line: +					if (typeof sc == "number" && sc > maxIndex) {
>, <Line: +						maxIndex = sc;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// If any of the series have fixed color indexes, then we need to
>, <Line: +			// generate at least as many colors as the highest index.
>, <Line: +			if (neededColors <= maxIndex) {
>, <Line: +				neededColors = maxIndex + 1;
>, <Line: +			}
>, <Line: +			// Generate all the colors, using first the option colors and then
>, <Line: +			// variations on those colors once they're exhausted.
>, <Line: +			var c, colors = [], colorPool = options.colors,
>, <Line: +				colorPoolSize = colorPool.length, variation = 0;
>, <Line: +			for (i = 0; i < neededColors; i++) {
>, <Line: +				c = $.color.parse(colorPool[i % colorPoolSize] || "#666");
>, <Line: +				// Each time we exhaust the colors in the pool we adjust
>, <Line: +				// a scaling factor used to produce more variations on
>, <Line: +				// those colors. The factor alternates negative/positive
>, <Line: +				// to produce lighter/darker colors.
>, <Line: +				// Reset the variation after every few cycles, or else
>, <Line: +				// it will end up producing only white or black colors.
>, <Line: +				if (i % colorPoolSize == 0 && i) {
>, <Line: +					if (variation >= 0) {
>, <Line: +						if (variation < 0.5) {
>, <Line: +							variation = -variation - 0.2;
>, <Line: +						} else variation = 0;
>, <Line: +					} else variation = -variation;
>, <Line: +				}
>, <Line: +				colors[i] = c.scale('rgb', 1 + variation);
>, <Line: +			}
>, <Line: +			// Finalize the series options, filling in their colors
>, <Line: +			var colori = 0, s;
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				// assign colors
>, <Line: +				if (s.color == null) {
>, <Line: +					s.color = colors[colori].toString();
>, <Line: +					++colori;
>, <Line: +				}
>, <Line: +				else if (typeof s.color == "number")
>, <Line: +					s.color = colors[s.color].toString();
>, <Line: +				// turn on lines automatically in case nothing is set
>, <Line: +				if (s.lines.show == null) {
>, <Line: +					var v, show = true;
>, <Line: +					for (v in s)
>, <Line: +						if (s[v] && s[v].show) {
>, <Line: +							show = false;
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					if (show)
>, <Line: +						s.lines.show = true;
>, <Line: +				}
>, <Line: +				// If nothing was provided for lines.zero, default it to match
>, <Line: +				// lines.fill, since areas by default should extend to zero.
>, <Line: +				if (s.lines.zero == null) {
>, <Line: +					s.lines.zero = !!s.lines.fill;
>, <Line: +				}
>, <Line: +				// setup axes
>, <Line: +				s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
>, <Line: +				s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function processData() {
>, <Line: +			var topSentry = Number.POSITIVE_INFINITY,
>, <Line: +				bottomSentry = Number.NEGATIVE_INFINITY,
>, <Line: +				fakeInfinity = Number.MAX_VALUE,
>, <Line: +				i, j, k, m, length,
>, <Line: +				s, points, ps, x, y, axis, val, f, p,
>, <Line: +				data, format;
>, <Line: +			function updateAxis(axis, min, max) {
>, <Line: +				if (min < axis.datamin && min != -fakeInfinity)
>, <Line: +					axis.datamin = min;
>, <Line: +				if (max > axis.datamax && max != fakeInfinity)
>, <Line: +					axis.datamax = max;
>, <Line: +			}
>, <Line: +			$.each(allAxes(), function (_, axis) {
>, <Line: +				// init axis
>, <Line: +				axis.datamin = topSentry;
>, <Line: +				axis.datamax = bottomSentry;
>, <Line: +				axis.used = false;
>, <Line: +			});
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				s.datapoints = {points: []};
>, <Line: +				executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);
>, <Line: +			}
>, <Line: +			// first pass: clean and copy data
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				data = s.data;
>, <Line: +				format = s.datapoints.format;
>, <Line: +				if (!format) {
>, <Line: +					format = [];
>, <Line: +					// find out how to copy
>, <Line: +					format.push({x: true, number: true, required: true});
>, <Line: +					format.push({y: true, number: true, required: true});
>, <Line: +					if (s.bars.show || (s.lines.show && s.lines.fill)) {
>, <Line: +						var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
>, <Line: +						format.push({
>, <Line: +							y: true,
>, <Line: +							number: true,
>, <Line: +							required: false,
>, <Line: +							defaultValue: 0,
>, <Line: +							autoscale: autoscale
>, <Line: +						});
>, <Line: +						if (s.bars.horizontal) {
>, <Line: +							delete format[format.length - 1].y;
>, <Line: +							format[format.length - 1].x = true;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					s.datapoints.format = format;
>, <Line: +				}
>, <Line: +				if (s.datapoints.pointsize != null)
>, <Line: +					continue; // already filled in
>, <Line: +				s.datapoints.pointsize = format.length;
>, <Line: +				ps = s.datapoints.pointsize;
>, <Line: +				points = s.datapoints.points;
>, <Line: +				var insertSteps = s.lines.show && s.lines.steps;
>, <Line: +				s.xaxis.used = s.yaxis.used = true;
>, <Line: +				for (j = k = 0; j < data.length; ++j, k += ps) {
>, <Line: +					p = data[j];
>, <Line: +					var nullify = p == null;
>, <Line: +					if (!nullify) {
>, <Line: +						for (m = 0; m < ps; ++m) {
>, <Line: +							val = p[m];
>, <Line: +							f = format[m];
>, <Line: +							if (f) {
>, <Line: +								if (f.number && val != null) {
>, <Line: +									val = +val; // convert to number
>, <Line: +									if (isNaN(val))
>, <Line: +										val = null;
>, <Line: +									else if (val == Infinity)
>, <Line: +										val = fakeInfinity;
>, <Line: +									else if (val == -Infinity)
>, <Line: +										val = -fakeInfinity;
>, <Line: +								}
>, <Line: +								if (val == null) {
>, <Line: +									if (f.required)
>, <Line: +										nullify = true;
>, <Line: +									if (f.defaultValue != null)
>, <Line: +										val = f.defaultValue;
>, <Line: +								}
>, <Line: +							}
>, <Line: +							points[k + m] = val;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (nullify) {
>, <Line: +						for (m = 0; m < ps; ++m) {
>, <Line: +							val = points[k + m];
>, <Line: +							if (val != null) {
>, <Line: +								f = format[m];
>, <Line: +								// extract min/max info
>, <Line: +								if (f.autoscale !== false) {
>, <Line: +									if (f.x) {
>, <Line: +										updateAxis(s.xaxis, val, val);
>, <Line: +									}
>, <Line: +									if (f.y) {
>, <Line: +										updateAxis(s.yaxis, val, val);
>, <Line: +									}
>, <Line: +								}
>, <Line: +							}
>, <Line: +							points[k + m] = null;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						// a little bit of line specific stuff that
>, <Line: +						// perhaps shouldn't be here, but lacking
>, <Line: +						// better means...
>, <Line: +						if (insertSteps && k > 0
>, <Line: +							&& points[k - ps] != null
>, <Line: +							&& points[k - ps] != points[k]
>, <Line: +							&& points[k - ps + 1] != points[k + 1]) {
>, <Line: +							// copy the point to make room for a middle point
>, <Line: +							for (m = 0; m < ps; ++m)
>, <Line: +								points[k + ps + m] = points[k + m];
>, <Line: +							// middle point has same y
>, <Line: +							points[k + 1] = points[k - ps + 1];
>, <Line: +							// we've added a point, better reflect that
>, <Line: +							k += ps;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// give the hooks a chance to run
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				executeHooks(hooks.processDatapoints, [s, s.datapoints]);
>, <Line: +			}
>, <Line: +			// second pass: find datamax/datamin for auto-scaling
>, <Line: +			for (i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				points = s.datapoints.points;
>, <Line: +				ps = s.datapoints.pointsize;
>, <Line: +				format = s.datapoints.format;
>, <Line: +				var xmin = topSentry, ymin = topSentry,
>, <Line: +					xmax = bottomSentry, ymax = bottomSentry;
>, <Line: +				for (j = 0; j < points.length; j += ps) {
>, <Line: +					if (points[j] == null)
>, <Line: +						continue;
>, <Line: +					for (m = 0; m < ps; ++m) {
>, <Line: +						val = points[j + m];
>, <Line: +						f = format[m];
>, <Line: +						if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
>, <Line: +							continue;
>, <Line: +						if (f.x) {
>, <Line: +							if (val < xmin)
>, <Line: +								xmin = val;
>, <Line: +							if (val > xmax)
>, <Line: +								xmax = val;
>, <Line: +						}
>, <Line: +						if (f.y) {
>, <Line: +							if (val < ymin)
>, <Line: +								ymin = val;
>, <Line: +							if (val > ymax)
>, <Line: +								ymax = val;
>, <Line: +				}
>, <Line: +				if (s.bars.show) {
>, <Line: +					// make sure we got room for the bar on the dancing floor
>, <Line: +					var delta;
>, <Line: +					switch (s.bars.align) {
>, <Line: +						case "left":
>, <Line: +							delta = 0;
>, <Line: +							break;
>, <Line: +						case "right":
>, <Line: +							delta = -s.bars.barWidth;
>, <Line: +							break;
>, <Line: +						default:
>, <Line: +							delta = -s.bars.barWidth / 2;
>, <Line: +					}
>, <Line: +					if (s.bars.horizontal) {
>, <Line: +						ymin += delta;
>, <Line: +						ymax += delta + s.bars.barWidth;
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						xmin += delta;
>, <Line: +						xmax += delta + s.bars.barWidth;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				updateAxis(s.xaxis, xmin, xmax);
>, <Line: +				updateAxis(s.yaxis, ymin, ymax);
>, <Line: +			}
>, <Line: +			$.each(allAxes(), function (_, axis) {
>, <Line: +				if (axis.datamin == topSentry)
>, <Line: +					axis.datamin = null;
>, <Line: +				if (axis.datamax == bottomSentry)
>, <Line: +					axis.datamax = null;
>, <Line: +			});
>, <Line: +		}
>, <Line: +		function setupCanvases() {
>, <Line: +			// Make sure the placeholder is clear of everything except canvases
>, <Line: +			// from a previous plot in this container that we'll try to re-use.
>, <Line: +			placeholder.css("padding", 0) // padding messes up the positioning
>, <Line: +				.children().filter(function () {
>, <Line: +					return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
>, <Line: +				}).remove();
>, <Line: +			if (placeholder.css("position") == 'static')
>, <Line: +				placeholder.css("position", "relative"); // for positioning labels and overlay
>, <Line: +			surface = new Canvas("flot-base", placeholder);
>, <Line: +			overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features
>, <Line: +			ctx = surface.context;
>, <Line: +			octx = overlay.context;
>, <Line: +			// define which element we're listening for events on
>, <Line: +			eventHolder = $(overlay.element).unbind();
>, <Line: +			// If we're re-using a plot object, shut down the old one
>, <Line: +			var existing = placeholder.data("plot");
>, <Line: +			if (existing) {
>, <Line: +				existing.shutdown();
>, <Line: +				overlay.clear();
>, <Line: +			}
>, <Line: +			// save in case we get replotted
>, <Line: +			placeholder.data("plot", plot);
>, <Line: +		}
>, <Line: +		function bindEvents() {
>, <Line: +			// bind events
>, <Line: +			if (options.grid.hoverable) {
>, <Line: +				eventHolder.mousemove(onMouseMove);
>, <Line: +				// Use bind, rather than .mouseleave, because we officially
>, <Line: +				// still support jQuery 1.2.6, which doesn't define a shortcut
>, <Line: +				// for mouseenter or mouseleave.  This was a bug/oversight that
>, <Line: +				// was fixed somewhere around 1.3.x.  We can return to using
>, <Line: +				// .mouseleave when we drop support for 1.2.6.
>, <Line: +				eventHolder.bind("mouseleave", onMouseLeave);
>, <Line: +			}
>, <Line: +			if (options.grid.clickable)
>, <Line: +				eventHolder.click(onClick);
>, <Line: +			executeHooks(hooks.bindEvents, [eventHolder]);
>, <Line: +		}
>, <Line: +		function shutdown() {
>, <Line: +			if (redrawTimeout)
>, <Line: +				clearTimeout(redrawTimeout);
>, <Line: +			eventHolder.unbind("mousemove", onMouseMove);
>, <Line: +			eventHolder.unbind("mouseleave", onMouseLeave);
>, <Line: +			eventHolder.unbind("click", onClick);
>, <Line: +			executeHooks(hooks.shutdown, [eventHolder]);
>, <Line: +		}
>, <Line: +		function setTransformationHelpers(axis) {
>, <Line: +			// set helper functions on the axis, assumes plot area
>, <Line: +			// has been computed already
>, <Line: +			function identity(x) {
>, <Line: +				return x;
>, <Line: +			}
>, <Line: +			var s, m, t = axis.options.transform || identity,
>, <Line: +				it = axis.options.inverseTransform;
>, <Line: +			// precompute how much the axis is scaling a point
>, <Line: +			// in canvas space
>, <Line: +			if (axis.direction == "x") {
>, <Line: +				s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
>, <Line: +				m = Math.min(t(axis.max), t(axis.min));
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
>, <Line: +				s = -s;
>, <Line: +				m = Math.max(t(axis.max), t(axis.min));
>, <Line: +			}
>, <Line: +			// data point to canvas coordinate
>, <Line: +			if (t == identity) // slight optimization
>, <Line: +				axis.p2c = function (p) {
>, <Line: +					return (p - m) * s;
>, <Line: +				};
>, <Line: +			else
>, <Line: +				axis.p2c = function (p) {
>, <Line: +					return (t(p) - m) * s;
>, <Line: +				};
>, <Line: +			// canvas coordinate to data point
>, <Line: +			if (!it)
>, <Line: +				axis.c2p = function (c) {
>, <Line: +					return m + c / s;
>, <Line: +				};
>, <Line: +			else
>, <Line: +				axis.c2p = function (c) {
>, <Line: +					return it(m + c / s);
>, <Line: +				};
>, <Line: +		}
>, <Line: +		function measureTickLabels(axis) {
>, <Line: +			var opts = axis.options,
>, <Line: +				ticks = axis.ticks || [],
>, <Line: +				labelWidth = opts.labelWidth || 0,
>, <Line: +				labelHeight = opts.labelHeight || 0,
>, <Line: +				maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
>, <Line: +				legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
>, <Line: +				layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
>, <Line: +				font = opts.font || "flot-tick-label tickLabel";
>, <Line: +			for (var i = 0; i < ticks.length; ++i) {
>, <Line: +				var t = ticks[i];
>, <Line: +				if (!t.label)
>, <Line: +					continue;
>, <Line: +				var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);
>, <Line: +				/// Grafana fix, add +1 to label width
>, <Line: +				labelWidth = Math.max(labelWidth, info.width + 1);
>, <Line: +				labelHeight = Math.max(labelHeight, info.height);
>, <Line: +			}
>, <Line: +			axis.labelWidth = opts.labelWidth || labelWidth;
>, <Line: +			axis.labelHeight = opts.labelHeight || labelHeight;
>, <Line: +		}
>, <Line: +		function allocateAxisBoxFirstPhase(axis) {
>, <Line: +			// find the bounding box of the axis by looking at label
>, <Line: +			// widths/heights and ticks, make room by diminishing the
>, <Line: +			// plotOffset; this first phase only looks at one
>, <Line: +			// dimension per axis, the other dimension depends on the
>, <Line: +			// other axes so will have to wait
>, <Line: +			var lw = axis.labelWidth,
>, <Line: +				lh = axis.labelHeight,
>, <Line: +				pos = axis.options.position,
>, <Line: +				isXAxis = axis.direction === "x",
>, <Line: +				tickLength = axis.options.tickLength,
>, <Line: +				axisMargin = options.grid.axisMargin,
>, <Line: +				padding = options.grid.labelMargin,
>, <Line: +				innermost = true,
>, <Line: +				outermost = true,
>, <Line: +				first = true,
>, <Line: +				found = false;
>, <Line: +			// Determine the axis's position in its direction and on its side
>, <Line: +			$.each(isXAxis ? xaxes : yaxes, function (i, a) {
>, <Line: +				if (a && (a.show || a.reserveSpace)) {
>, <Line: +					if (a === axis) {
>, <Line: +						found = true;
>, <Line: +					} else if (a.options.position === pos) {
>, <Line: +						if (found) {
>, <Line: +							outermost = false;
>, <Line: +						} else {
>, <Line: +							innermost = false;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (!found) {
>, <Line: +						first = false;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			});
>, <Line: +			// The outermost axis on each side has no margin
>, <Line: +			if (outermost) {
>, <Line: +				axisMargin = 0;
>, <Line: +			}
>, <Line: +			// The ticks for the first axis in each direction stretch across
>, <Line: +			if (tickLength == null) {
>, <Line: +				tickLength = first ? "full" : 5;
>, <Line: +			}
>, <Line: +			if (!isNaN(+tickLength))
>, <Line: +				padding += +tickLength;
>, <Line: +			if (isXAxis) {
>, <Line: +				lh += padding;
>, <Line: +				if (pos == "bottom") {
>, <Line: +					plotOffset.bottom += lh + axisMargin;
>, <Line: +					axis.box = {
>, <Line: +						top: surface.height - plotOffset.bottom,
>, <Line: +						height: lh
>, <Line: +					};
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					axis.box = {top: plotOffset.top + axisMargin, height: lh};
>, <Line: +					plotOffset.top += lh + axisMargin;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				lw += padding;
>, <Line: +				if (pos == "left") {
>, <Line: +					axis.box = {left: plotOffset.left + axisMargin, width: lw};
>, <Line: +					plotOffset.left += lw + axisMargin;
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					plotOffset.right += lw + axisMargin;
>, <Line: +					axis.box = {
>, <Line: +						left: surface.width - plotOffset.right,
>, <Line: +						width: lw
>, <Line: +					};
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// save for future reference
>, <Line: +			axis.position = pos;
>, <Line: +			axis.tickLength = tickLength;
>, <Line: +			axis.box.padding = padding;
>, <Line: +			axis.innermost = innermost;
>, <Line: +		}
>, <Line: +		function allocateAxisBoxSecondPhase(axis) {
>, <Line: +			// now that all axis boxes have been placed in one
>, <Line: +			// dimension, we can set the remaining dimension coordinates
>, <Line: +			if (axis.direction == "x") {
>, <Line: +				axis.box.left = plotOffset.left - axis.labelWidth / 2;
>, <Line: +				axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				axis.box.top = plotOffset.top - axis.labelHeight / 2;
>, <Line: +				axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function adjustLayoutForThingsStickingOut() {
>, <Line: +			// possibly adjust plot offset to ensure everything stays
>, <Line: +			// inside the canvas and isn't clipped off
>, <Line: +			var minMargin = options.grid.minBorderMargin,
>, <Line: +				axis, i;
>, <Line: +			// check stuff from the plot (FIXME: this should just read
>, <Line: +			// a value from the series, otherwise it's impossible to
>, <Line: +			// customize)
>, <Line: +			if (minMargin == null) {
>, <Line: +				minMargin = 0;
>, <Line: +				for (i = 0; i < series.length; ++i)
>, <Line: +					minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));
>, <Line: +			}
>, <Line: +			var margins = {
>, <Line: +				left: minMargin,
>, <Line: +				right: minMargin,
>, <Line: +				top: minMargin,
>, <Line: +				bottom: minMargin
>, <Line: +			};
>, <Line: +			// check axis labels, note we don't check the actual
>, <Line: +			// labels but instead use the overall width/height to not
>, <Line: +			// jump as much around with replots
>, <Line: +			$.each(allAxes(), function (_, axis) {
>, <Line: +				if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
>, <Line: +					if (axis.direction === "x") {
>, <Line: +						margins.left = Math.max(margins.left, axis.labelWidth / 2);
>, <Line: +						margins.right = Math.max(margins.right, axis.labelWidth / 2);
>, <Line: +					} else {
>, <Line: +						margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
>, <Line: +						margins.top = Math.max(margins.top, axis.labelHeight / 2);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			});
>, <Line: +			plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
>, <Line: +			plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
>, <Line: +			plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
>, <Line: +			plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
>, <Line: +		}
>, <Line: +		function setupGrid() {
>, <Line: +			var i, axes = allAxes(), showGrid = options.grid.show;
>, <Line: +			// Initialize the plot's offset from the edge of the canvas
>, <Line: +			for (var a in plotOffset) {
>, <Line: +				var margin = options.grid.margin || 0;
>, <Line: +				plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
>, <Line: +			}
>, <Line: +			executeHooks(hooks.processOffset, [plotOffset]);
>, <Line: +			// If the grid is visible, add its border width to the offset
>, <Line: +			for (var a in plotOffset) {
>, <Line: +				if (typeof(options.grid.borderWidth) == "object") {
>, <Line: +					plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			$.each(axes, function (_, axis) {
>, <Line: +				var axisOpts = axis.options;
>, <Line: +				axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
>, <Line: +				axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
>, <Line: +				setRange(axis);
>, <Line: +			});
>, <Line: +			if (showGrid) {
>, <Line: +				var allocatedAxes = $.grep(axes, function (axis) {
>, <Line: +					return axis.show || axis.reserveSpace;
>, <Line: +				});
>, <Line: +				$.each(allocatedAxes, function (_, axis) {
>, <Line: +					// make the ticks
>, <Line: +					setupTickGeneration(axis);
>, <Line: +					setTicks(axis);
>, <Line: +					snapRangeToTicks(axis, axis.ticks);
>, <Line: +					// find labelWidth/Height for axis
>, <Line: +					measureTickLabels(axis);
>, <Line: +				});
>, <Line: +				// with all dimensions calculated, we can compute the
>, <Line: +				// axis bounding boxes, start from the outside
>, <Line: +				// (reverse order)
>, <Line: +				for (i = allocatedAxes.length - 1; i >= 0; --i)
>, <Line: +					allocateAxisBoxFirstPhase(allocatedAxes[i]);
>, <Line: +				// make sure we've got enough space for things that
>, <Line: +				// might stick out
>, <Line: +				adjustLayoutForThingsStickingOut();
>, <Line: +				$.each(allocatedAxes, function (_, axis) {
>, <Line: +					allocateAxisBoxSecondPhase(axis);
>, <Line: +				});
>, <Line: +			}
>, <Line: +			plotWidth = surface.width - plotOffset.left - plotOffset.right;
>, <Line: +			plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
>, <Line: +			// now we got the proper plot dimensions, we can compute the scaling
>, <Line: +			$.each(axes, function (_, axis) {
>, <Line: +				setTransformationHelpers(axis);
>, <Line: +			});
>, <Line: +			if (showGrid) {
>, <Line: +				drawAxisLabels();
>, <Line: +			}
>, <Line: +			insertLegend();
>, <Line: +		}
>, <Line: +		function setRange(axis) {
>, <Line: +			var opts = axis.options,
>, <Line: +				min = +(opts.min != null ? opts.min : axis.datamin),
>, <Line: +				max = +(opts.max != null ? opts.max : axis.datamax),
>, <Line: +				delta = max - min;
>, <Line: +			if (delta == 0.0) {
>, <Line: +				// degenerate case
>, <Line: +				var widen = max == 0 ? 1 : 0.01;
>, <Line: +				if (opts.min == null)
>, <Line: +					min -= widen;
>, <Line: +				// always widen max if we couldn't widen min to ensure we
>, <Line: +				// don't fall into min == max which doesn't work
>, <Line: +				if (opts.max == null || opts.min != null)
>, <Line: +					max += widen;
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				// consider autoscaling
>, <Line: +				var margin = opts.autoscaleMargin;
>, <Line: +				if (margin != null) {
>, <Line: +					if (opts.min == null) {
>, <Line: +						min -= delta * margin;
>, <Line: +						// make sure we don't go below zero if all values
>, <Line: +						// are positive
>, <Line: +						if (min < 0 && axis.datamin != null && axis.datamin >= 0)
>, <Line: +							min = 0;
>, <Line: +					}
>, <Line: +					if (opts.max == null) {
>, <Line: +						max += delta * margin;
>, <Line: +						if (max > 0 && axis.datamax != null && axis.datamax <= 0)
>, <Line: +							max = 0;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			axis.min = min;
>, <Line: +			axis.max = max;
>, <Line: +		}
>, <Line: +		function setupTickGeneration(axis) {
>, <Line: +			var opts = axis.options;
>, <Line: +			// estimate number of ticks
>, <Line: +			var noTicks;
>, <Line: +			if (typeof opts.ticks == "number" && opts.ticks > 0)
>, <Line: +				noTicks = opts.ticks;
>, <Line: +			else
>, <Line: +			// heuristic based on the model a*sqrt(x) fitted to
>, <Line: +			// some data points that seemed reasonable
>, <Line: +				noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);
>, <Line: +			var delta = (axis.max - axis.min) / noTicks,
>, <Line: +				dec = -Math.floor(Math.log(delta) / Math.LN10),
>, <Line: +				maxDec = opts.tickDecimals;
>, <Line: +			if (maxDec != null && dec > maxDec) {
>, <Line: +				dec = maxDec;
>, <Line: +			}
>, <Line: +			var magn = Math.pow(10, -dec),
>, <Line: +				norm = delta / magn, // norm is between 1.0 and 10.0
>, <Line: +				size;
>, <Line: +			if (norm < 1.5) {
>, <Line: +				size = 1;
>, <Line: +			} else if (norm < 3) {
>, <Line: +				size = 2;
>, <Line: +				// special case for 2.5, requires an extra decimal
>, <Line: +				if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
>, <Line: +					size = 2.5;
>, <Line: +					++dec;
>, <Line: +				}
>, <Line: +			} else if (norm < 7.5) {
>, <Line: +				size = 5;
>, <Line: +			} else {
>, <Line: +				size = 10;
>, <Line: +			}
>, <Line: +			size *= magn;
>, <Line: +			if (opts.minTickSize != null && size < opts.minTickSize) {
>, <Line: +				size = opts.minTickSize;
>, <Line: +			}
>, <Line: +			axis.delta = delta;
>, <Line: +			axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
>, <Line: +			axis.tickSize = opts.tickSize || size;
>, <Line: +			// grafana addition
>, <Line: +			axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);
>, <Line: +			// Time mode was moved to a plug-in in 0.8, and since so many people use it
>, <Line: +			// we'll add an especially friendly reminder to make sure they included it.
>, <Line: +			if (opts.mode == "time" && !axis.tickGenerator) {
>, <Line: +				throw new Error("Time mode requires the flot.time plugin.");
>, <Line: +			}
>, <Line: +			// Flot supports base-10 axes; any other mode else is handled by a plug-in,
>, <Line: +			// like flot.time.js.
>, <Line: +			if (!axis.tickGenerator) {
>, <Line: +				axis.tickGenerator = function (axis) {
>, <Line: +					var ticks = [],
>, <Line: +						start = floorInBase(axis.min, axis.tickSize),
>, <Line: +						i = 0,
>, <Line: +						v = Number.NaN,
>, <Line: +						prev;
>, <Line: +					do {
>, <Line: +						prev = v;
>, <Line: +						v = start + i * axis.tickSize;
>, <Line: +						ticks.push(v);
>, <Line: +						++i;
>, <Line: +					} while (v < axis.max && v != prev);
>, <Line: +					return ticks;
>, <Line: +				};
>, <Line: +				axis.tickFormatter = function (value, axis) {
>, <Line: +					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
>, <Line: +					var formatted = "" + Math.round(value * factor) / factor;
>, <Line: +					// If tickDecimals was specified, ensure that we have exactly that
>, <Line: +					// much precision; otherwise default to the value's own precision.
>, <Line: +					if (axis.tickDecimals != null) {
>, <Line: +						var decimal = formatted.indexOf(".");
>, <Line: +						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
>, <Line: +						if (precision < axis.tickDecimals) {
>, <Line: +							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					return formatted;
>, <Line: +				};
>, <Line: +			}
>, <Line: +			if ($.isFunction(opts.tickFormatter))
>, <Line: +				axis.tickFormatter = function (v, axis) {
>, <Line: +					return "" + opts.tickFormatter(v, axis);
>, <Line: +				};
>, <Line: +			if (opts.alignTicksWithAxis != null) {
>, <Line: +				var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
>, <Line: +				if (otherAxis && otherAxis.used && otherAxis != axis) {
>, <Line: +					// consider snapping min/max to outermost nice ticks
>, <Line: +					var niceTicks = axis.tickGenerator(axis);
>, <Line: +					if (niceTicks.length > 0) {
>, <Line: +						if (opts.min == null)
>, <Line: +							axis.min = Math.min(axis.min, niceTicks[0]);
>, <Line: +						if (opts.max == null && niceTicks.length > 1)
>, <Line: +							axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
>, <Line: +					}
>, <Line: +					axis.tickGenerator = function (axis) {
>, <Line: +						// copy ticks, scaled to this axis
>, <Line: +						var ticks = [], v, i;
>, <Line: +						for (i = 0; i < otherAxis.ticks.length; ++i) {
>, <Line: +							v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
>, <Line: +							v = axis.min + v * (axis.max - axis.min);
>, <Line: +							ticks.push(v);
>, <Line: +						}
>, <Line: +						return ticks;
>, <Line: +					};
>, <Line: +					// we might need an extra decimal since forced
>, <Line: +					// ticks don't necessarily fit naturally
>, <Line: +					if (!axis.mode && opts.tickDecimals == null) {
>, <Line: +						var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
>, <Line: +							ts = axis.tickGenerator(axis);
>, <Line: +						// only proceed if the tick interval rounded
>, <Line: +						// with an extra decimal doesn't give us a
>, <Line: +						// zero at end
>, <Line: +						if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
>, <Line: +							axis.tickDecimals = extraDec;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function setTicks(axis) {
>, <Line: +			var oticks = axis.options.ticks, ticks = [];
>, <Line: +			if (oticks == null || (typeof oticks == "number" && oticks > 0))
>, <Line: +				ticks = axis.tickGenerator(axis);
>, <Line: +			else if (oticks) {
>, <Line: +				if ($.isFunction(oticks))
>, <Line: +				// generate the ticks
>, <Line: +					ticks = oticks(axis);
>, <Line: +				else
>, <Line: +					ticks = oticks;
>, <Line: +			}
>, <Line: +			// clean up/labelify the supplied ticks, copy them over
>, <Line: +			var i, v;
>, <Line: +			axis.ticks = [];
>, <Line: +			for (i = 0; i < ticks.length; ++i) {
>, <Line: +				var label = null;
>, <Line: +				var t = ticks[i];
>, <Line: +				if (typeof t == "object") {
>, <Line: +					v = +t[0];
>, <Line: +					if (t.length > 1)
>, <Line: +						label = t[1];
>, <Line: +				}
>, <Line: +				else
>, <Line: +					v = +t;
>, <Line: +				if (label == null)
>, <Line: +					label = axis.tickFormatter(v, axis);
>, <Line: +				if (!isNaN(v))
>, <Line: +					axis.ticks.push({v: v, label: label});
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function snapRangeToTicks(axis, ticks) {
>, <Line: +			if (axis.options.autoscaleMargin && ticks.length > 0) {
>, <Line: +				// snap to ticks
>, <Line: +				if (axis.options.min == null)
>, <Line: +					axis.min = Math.min(axis.min, ticks[0].v);
>, <Line: +				if (axis.options.max == null && ticks.length > 1)
>, <Line: +					axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function draw() {
>, <Line: +			surface.clear();
>, <Line: +			executeHooks(hooks.drawBackground, [ctx]);
>, <Line: +			var grid = options.grid;
>, <Line: +			// draw background, if any
>, <Line: +			if (grid.show && grid.backgroundColor)
>, <Line: +				drawBackground();
>, <Line: +			if (grid.show && !grid.aboveData) {
>, <Line: +				drawGrid();
>, <Line: +			}
>, <Line: +			for (var i = 0; i < series.length; ++i) {
>, <Line: +				executeHooks(hooks.drawSeries, [ctx, series[i]]);
>, <Line: +				drawSeries(series[i]);
>, <Line: +			}
>, <Line: +			executeHooks(hooks.draw, [ctx]);
>, <Line: +			if (grid.show && grid.aboveData) {
>, <Line: +				drawGrid();
>, <Line: +			}
>, <Line: +			surface.render();
>, <Line: +			// A draw implies that either the axes or data have changed, so we
>, <Line: +			// should probably update the overlay highlights as well.
>, <Line: +			triggerRedrawOverlay();
>, <Line: +		}
>, <Line: +		function extractRange(ranges, coord) {
>, <Line: +			var axis, from, to, key, axes = allAxes();
>, <Line: +			for (var i = 0; i < axes.length; ++i) {
>, <Line: +				axis = axes[i];
>, <Line: +				if (axis.direction == coord) {
>, <Line: +					key = coord + axis.n + "axis";
>, <Line: +					if (!ranges[key] && axis.n == 1)
>, <Line: +						key = coord + "axis"; // support x1axis as xaxis
>, <Line: +					if (ranges[key]) {
>, <Line: +						from = ranges[key].from;
>, <Line: +						to = ranges[key].to;
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// backwards-compat stuff - to be removed in future
>, <Line: +			if (!ranges[key]) {
>, <Line: +				axis = coord == "x" ? xaxes[0] : yaxes[0];
>, <Line: +				from = ranges[coord + "1"];
>, <Line: +				to = ranges[coord + "2"];
>, <Line: +			}
>, <Line: +			// auto-reverse as an added bonus
>, <Line: +			if (from != null && to != null && from > to) {
>, <Line: +				var tmp = from;
>, <Line: +				from = to;
>, <Line: +				to = tmp;
>, <Line: +			}
>, <Line: +			return {from: from, to: to, axis: axis};
>, <Line: +		}
>, <Line: +		function drawBackground() {
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
>, <Line: +			ctx.fillRect(0, 0, plotWidth, plotHeight);
>, <Line: +			ctx.restore();
>, <Line: +		}
>, <Line: +		function drawGrid() {
>, <Line: +			var i, axes, bw, bc;
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			// draw markings
>, <Line: +			var markings = options.grid.markings;
>, <Line: +			if (markings) {
>, <Line: +				if ($.isFunction(markings)) {
>, <Line: +					axes = plot.getAxes();
>, <Line: +					// xmin etc. is backwards compatibility, to be
>, <Line: +					// removed in the future
>, <Line: +					axes.xmin = axes.xaxis.min;
>, <Line: +					axes.xmax = axes.xaxis.max;
>, <Line: +					axes.ymin = axes.yaxis.min;
>, <Line: +					axes.ymax = axes.yaxis.max;
>, <Line: +					markings = markings(axes);
>, <Line: +				}
>, <Line: +				for (i = 0; i < markings.length; ++i) {
>, <Line: +					var m = markings[i],
>, <Line: +						xrange = extractRange(m, "x"),
>, <Line: +						yrange = extractRange(m, "y");
>, <Line: +					// fill in missing
>, <Line: +					if (xrange.from == null)
>, <Line: +						xrange.from = xrange.axis.min;
>, <Line: +					if (xrange.to == null)
>, <Line: +						xrange.to = xrange.axis.max;
>, <Line: +					if (yrange.from == null)
>, <Line: +						yrange.from = yrange.axis.min;
>, <Line: +					if (yrange.to == null)
>, <Line: +						yrange.to = yrange.axis.max;
>, <Line: +					// clip
>, <Line: +					if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
>, <Line: +						yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
>, <Line: +						continue;
>, <Line: +					xrange.from = Math.max(xrange.from, xrange.axis.min);
>, <Line: +					xrange.to = Math.min(xrange.to, xrange.axis.max);
>, <Line: +					yrange.from = Math.max(yrange.from, yrange.axis.min);
>, <Line: +					yrange.to = Math.min(yrange.to, yrange.axis.max);
>, <Line: +					var xequal = xrange.from === xrange.to,
>, <Line: +						yequal = yrange.from === yrange.to;
>, <Line: +					if (xequal && yequal) {
>, <Line: +						continue;
>, <Line: +					}
>, <Line: +					// then draw
>, <Line: +					xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
>, <Line: +					xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
>, <Line: +					yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
>, <Line: +					yrange.to = Math.floor(yrange.axis.p2c(yrange.to));
>, <Line: +					if (xequal || yequal) {
>, <Line: +						var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
>, <Line: +							subPixel = lineWidth % 2 ? 0.5 : 0;
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.strokeStyle = m.color || options.grid.markingsColor;
>, <Line: +						ctx.lineWidth = lineWidth;
>, <Line: +						if (xequal) {
>, <Line: +							ctx.moveTo(xrange.to + subPixel, yrange.from);
>, <Line: +							ctx.lineTo(xrange.to + subPixel, yrange.to);
>, <Line: +						} else {
>, <Line: +							ctx.moveTo(xrange.from, yrange.to + subPixel);
>, <Line: +							ctx.lineTo(xrange.to, yrange.to + subPixel);
>, <Line: +						}
>, <Line: +						ctx.stroke();
>, <Line: +					} else {
>, <Line: +						ctx.fillStyle = m.color || options.grid.markingsColor;
>, <Line: +						ctx.fillRect(xrange.from, yrange.to,
>, <Line: +							xrange.to - xrange.from,
>, <Line: +							yrange.from - yrange.to);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// draw the ticks
>, <Line: +			axes = allAxes();
>, <Line: +			bw = options.grid.borderWidth;
>, <Line: +			for (var j = 0; j < axes.length; ++j) {
>, <Line: +				var axis = axes[j], box = axis.box,
>, <Line: +					t = axis.tickLength, x, y, xoff, yoff;
>, <Line: +				if (!axis.show || axis.ticks.length == 0)
>, <Line: +					continue;
>, <Line: +				ctx.lineWidth = 1;
>, <Line: +				// find the edges
>, <Line: +				if (axis.direction == "x") {
>, <Line: +					x = 0;
>, <Line: +					if (t == "full")
>, <Line: +						y = (axis.position == "top" ? 0 : plotHeight);
>, <Line: +					else
>, <Line: +						y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					y = 0;
>, <Line: +					if (t == "full")
>, <Line: +						x = (axis.position == "left" ? 0 : plotWidth);
>, <Line: +					else
>, <Line: +						x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
>, <Line: +				}
>, <Line: +				// draw tick bar
>, <Line: +				if (!axis.innermost) {
>, <Line: +					ctx.strokeStyle = axis.options.color;
>, <Line: +					ctx.beginPath();
>, <Line: +					xoff = yoff = 0;
>, <Line: +					if (axis.direction == "x")
>, <Line: +						xoff = plotWidth + 1;
>, <Line: +					else
>, <Line: +						yoff = plotHeight + 1;
>, <Line: +					if (ctx.lineWidth == 1) {
>, <Line: +						if (axis.direction == "x") {
>, <Line: +							y = Math.floor(y) + 0.5;
>, <Line: +						} else {
>, <Line: +							x = Math.floor(x) + 0.5;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					ctx.moveTo(x, y);
>, <Line: +					ctx.lineTo(x + xoff, y + yoff);
>, <Line: +					ctx.stroke();
>, <Line: +				}
>, <Line: +				// draw ticks
>, <Line: +				ctx.strokeStyle = axis.options.tickColor;
>, <Line: +				ctx.beginPath();
>, <Line: +				for (i = 0; i < axis.ticks.length; ++i) {
>, <Line: +					var v = axis.ticks[i].v;
>, <Line: +					xoff = yoff = 0;
>, <Line: +					if (isNaN(v) || v < axis.min || v > axis.max
>, <Line: +							// skip those lying on the axes if we got a border
>, <Line: +						|| (t == "full"
>, <Line: +						&& ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
>, <Line: +						&& (v == axis.min || v == axis.max)))
>, <Line: +						continue;
>, <Line: +					if (axis.direction == "x") {
>, <Line: +						x = axis.p2c(v);
>, <Line: +						yoff = t == "full" ? -plotHeight : t;
>, <Line: +						if (axis.position == "top")
>, <Line: +							yoff = -yoff;
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						y = axis.p2c(v);
>, <Line: +						xoff = t == "full" ? -plotWidth : t;
>, <Line: +						if (axis.position == "left")
>, <Line: +							xoff = -xoff;
>, <Line: +					}
>, <Line: +					if (ctx.lineWidth == 1) {
>, <Line: +						if (axis.direction == "x")
>, <Line: +							x = Math.floor(x) + 0.5;
>, <Line: +						else
>, <Line: +							y = Math.floor(y) + 0.5;
>, <Line: +					}
>, <Line: +					ctx.moveTo(x, y);
>, <Line: +					ctx.lineTo(x + xoff, y + yoff);
>, <Line: +				}
>, <Line: +				ctx.stroke();
>, <Line: +			}
>, <Line: +			// draw border
>, <Line: +			if (bw) {
>, <Line: +				// If either borderWidth or borderColor is an object, then draw the border
>, <Line: +				// line by line instead of as one rectangle
>, <Line: +				bc = options.grid.borderColor;
>, <Line: +				if (typeof bw == "object" || typeof bc == "object") {
>, <Line: +					if (typeof bw !== "object") {
>, <Line: +						bw = {top: bw, right: bw, bottom: bw, left: bw};
>, <Line: +					}
>, <Line: +					if (typeof bc !== "object") {
>, <Line: +						bc = {top: bc, right: bc, bottom: bc, left: bc};
>, <Line: +					}
>, <Line: +					if (bw.top > 0) {
>, <Line: +						ctx.strokeStyle = bc.top;
>, <Line: +						ctx.lineWidth = bw.top;
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.moveTo(0 - bw.left, 0 - bw.top / 2);
>, <Line: +						ctx.lineTo(plotWidth, 0 - bw.top / 2);
>, <Line: +						ctx.stroke();
>, <Line: +					}
>, <Line: +					if (bw.right > 0) {
>, <Line: +						ctx.strokeStyle = bc.right;
>, <Line: +						ctx.lineWidth = bw.right;
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
>, <Line: +						ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
>, <Line: +						ctx.stroke();
>, <Line: +					}
>, <Line: +					if (bw.bottom > 0) {
>, <Line: +						ctx.strokeStyle = bc.bottom;
>, <Line: +						ctx.lineWidth = bw.bottom;
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
>, <Line: +						ctx.lineTo(0, plotHeight + bw.bottom / 2);
>, <Line: +						ctx.stroke();
>, <Line: +					}
>, <Line: +					if (bw.left > 0) {
>, <Line: +						ctx.strokeStyle = bc.left;
>, <Line: +						ctx.lineWidth = bw.left;
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);
>, <Line: +						ctx.lineTo(0 - bw.left / 2, 0);
>, <Line: +						ctx.stroke();
>, <Line: +					}
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					ctx.lineWidth = bw;
>, <Line: +					ctx.strokeStyle = options.grid.borderColor;
>, <Line: +					ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			ctx.restore();
>, <Line: +		}
>, <Line: +		function drawAxisLabels() {
>, <Line: +			$.each(allAxes(), function (_, axis) {
>, <Line: +				var box = axis.box,
>, <Line: +					legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
>, <Line: +					layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
>, <Line: +					font = axis.options.font || "flot-tick-label tickLabel",
>, <Line: +					tick, x, y, halign, valign;
>, <Line: +				// Remove text before checking for axis.show and ticks.length;
>, <Line: +				// otherwise plugins, like flot-tickrotor, that draw their own
>, <Line: +				// tick labels will end up with both theirs and the defaults.
>, <Line: +				surface.removeText(layer);
>, <Line: +				if (!axis.show || axis.ticks.length == 0)
>, <Line: +					return;
>, <Line: +				for (var i = 0; i < axis.ticks.length; ++i) {
>, <Line: +					tick = axis.ticks[i];
>, <Line: +					if (!tick.label || tick.v < axis.min || tick.v > axis.max)
>, <Line: +						continue;
>, <Line: +					if (axis.direction == "x") {
>, <Line: +						halign = "center";
>, <Line: +						x = plotOffset.left + axis.p2c(tick.v);
>, <Line: +						if (axis.position == "bottom") {
>, <Line: +							y = box.top + box.padding;
>, <Line: +						} else {
>, <Line: +							y = box.top + box.height - box.padding;
>, <Line: +							valign = "bottom";
>, <Line: +						}
>, <Line: +					} else {
>, <Line: +						valign = "middle";
>, <Line: +						y = plotOffset.top + axis.p2c(tick.v);
>, <Line: +						if (axis.position == "left") {
>, <Line: +							x = box.left + box.width - box.padding;
>, <Line: +							halign = "right";
>, <Line: +						} else {
>, <Line: +							x = box.left + box.padding;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
>, <Line: +				}
>, <Line: +			});
>, <Line: +		}
>, <Line: +		function drawSeries(series) {
>, <Line: +			if (series.lines.show)
>, <Line: +				drawSeriesLines(series);
>, <Line: +			if (series.bars.show)
>, <Line: +				drawSeriesBars(series);
>, <Line: +			if (series.points.show)
>, <Line: +				drawSeriesPoints(series);
>, <Line: +		}
>, <Line: +		function drawSeriesLines(series) {
>, <Line: +			function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
>, <Line: +				var points = datapoints.points,
>, <Line: +					ps = datapoints.pointsize,
>, <Line: +					prevx = null, prevy = null;
>, <Line: +				ctx.beginPath();
>, <Line: +				for (var i = ps; i < points.length; i += ps) {
>, <Line: +					var x1 = points[i - ps], y1 = points[i - ps + 1],
>, <Line: +						x2 = points[i], y2 = points[i + 1];
>, <Line: +					if (x1 == null || x2 == null)
>, <Line: +						continue;
>, <Line: +					// clip with ymin
>, <Line: +					if (y1 <= y2 && y1 < axisy.min) {
>, <Line: +						if (y2 < axisy.min)
>, <Line: +							continue;   // line segment is outside
>, <Line: +						// compute new intersection point
>, <Line: +						x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y1 = axisy.min;
>, <Line: +					}
>, <Line: +					else if (y2 <= y1 && y2 < axisy.min) {
>, <Line: +						if (y1 < axisy.min)
>, <Line: +							continue;
>, <Line: +						x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y2 = axisy.min;
>, <Line: +					}
>, <Line: +					// clip with ymax
>, <Line: +					if (y1 >= y2 && y1 > axisy.max) {
>, <Line: +						if (y2 > axisy.max)
>, <Line: +							continue;
>, <Line: +						x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y1 = axisy.max;
>, <Line: +					}
>, <Line: +					else if (y2 >= y1 && y2 > axisy.max) {
>, <Line: +						if (y1 > axisy.max)
>, <Line: +							continue;
>, <Line: +						x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y2 = axisy.max;
>, <Line: +					}
>, <Line: +					// clip with xmin
>, <Line: +					if (x1 <= x2 && x1 < axisx.min) {
>, <Line: +						if (x2 < axisx.min)
>, <Line: +							continue;
>, <Line: +						y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x1 = axisx.min;
>, <Line: +					}
>, <Line: +					else if (x2 <= x1 && x2 < axisx.min) {
>, <Line: +						if (x1 < axisx.min)
>, <Line: +							continue;
>, <Line: +						y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x2 = axisx.min;
>, <Line: +					}
>, <Line: +					// clip with xmax
>, <Line: +					if (x1 >= x2 && x1 > axisx.max) {
>, <Line: +						if (x2 > axisx.max)
>, <Line: +							continue;
>, <Line: +						y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x1 = axisx.max;
>, <Line: +					}
>, <Line: +					else if (x2 >= x1 && x2 > axisx.max) {
>, <Line: +						if (x1 > axisx.max)
>, <Line: +							continue;
>, <Line: +						y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x2 = axisx.max;
>, <Line: +					}
>, <Line: +					if (x1 != prevx || y1 != prevy)
>, <Line: +						ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
>, <Line: +					prevx = x2;
>, <Line: +					prevy = y2;
>, <Line: +					ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
>, <Line: +				}
>, <Line: +				ctx.stroke();
>, <Line: +			}
>, <Line: +			function plotLineArea(datapoints, axisx, axisy) {
>, <Line: +				var points = datapoints.points,
>, <Line: +					ps = datapoints.pointsize,
>, <Line: +					bottom = Math.min(Math.max(0, axisy.min), axisy.max),
>, <Line: +					i = 0, top, areaOpen = false,
>, <Line: +					ypos = 1, segmentStart = 0, segmentEnd = 0;
>, <Line: +				// we process each segment in two turns, first forward
>, <Line: +				// direction to sketch out top, then once we hit the
>, <Line: +				// end we go backwards to sketch the bottom
>, <Line: +				while (true) {
>, <Line: +					if (ps > 0 && i > points.length + ps)
>, <Line: +						break;
>, <Line: +					i += ps; // ps is negative if going backwards
>, <Line: +					var x1 = points[i - ps],
>, <Line: +						y1 = points[i - ps + ypos],
>, <Line: +						x2 = points[i], y2 = points[i + ypos];
>, <Line: +					if (areaOpen) {
>, <Line: +						if (ps > 0 && x1 != null && x2 == null) {
>, <Line: +							// at turning point
>, <Line: +							segmentEnd = i;
>, <Line: +							ps = -ps;
>, <Line: +							ypos = 2;
>, <Line: +							continue;
>, <Line: +						}
>, <Line: +						if (ps < 0 && i == segmentStart + ps) {
>, <Line: +							// done with the reverse sweep
>, <Line: +							ctx.fill();
>, <Line: +							areaOpen = false;
>, <Line: +							ps = -ps;
>, <Line: +							ypos = 1;
>, <Line: +							i = segmentStart = segmentEnd + ps;
>, <Line: +							continue;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (x1 == null || x2 == null)
>, <Line: +						continue;
>, <Line: +					// clip x values
>, <Line: +					// clip with xmin
>, <Line: +					if (x1 <= x2 && x1 < axisx.min) {
>, <Line: +						if (x2 < axisx.min)
>, <Line: +							continue;
>, <Line: +						y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x1 = axisx.min;
>, <Line: +					}
>, <Line: +					else if (x2 <= x1 && x2 < axisx.min) {
>, <Line: +						if (x1 < axisx.min)
>, <Line: +							continue;
>, <Line: +						y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x2 = axisx.min;
>, <Line: +					}
>, <Line: +					// clip with xmax
>, <Line: +					if (x1 >= x2 && x1 > axisx.max) {
>, <Line: +						if (x2 > axisx.max)
>, <Line: +							continue;
>, <Line: +						y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x1 = axisx.max;
>, <Line: +					}
>, <Line: +					else if (x2 >= x1 && x2 > axisx.max) {
>, <Line: +						if (x1 > axisx.max)
>, <Line: +							continue;
>, <Line: +						y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: +						x2 = axisx.max;
>, <Line: +					}
>, <Line: +					if (!areaOpen) {
>, <Line: +						// open area
>, <Line: +						ctx.beginPath();
>, <Line: +						ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
>, <Line: +						areaOpen = true;
>, <Line: +					}
>, <Line: +					// now first check the case where both is outside
>, <Line: +					if (y1 >= axisy.max && y2 >= axisy.max) {
>, <Line: +						ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
>, <Line: +						ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
>, <Line: +						continue;
>, <Line: +					}
>, <Line: +					else if (y1 <= axisy.min && y2 <= axisy.min) {
>, <Line: +						ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
>, <Line: +						ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
>, <Line: +						continue;
>, <Line: +					}
>, <Line: +					// else it's a bit more complicated, there might
>, <Line: +					// be a flat maxed out rectangle first, then a
>, <Line: +					// triangular cutout or reverse; to find these
>, <Line: +					// keep track of the current x values
>, <Line: +					var x1old = x1, x2old = x2;
>, <Line: +					// clip the y values, without shortcutting, we
>, <Line: +					// go through all cases in turn
>, <Line: +					// clip with ymin
>, <Line: +					if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
>, <Line: +						x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y1 = axisy.min;
>, <Line: +					}
>, <Line: +					else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
>, <Line: +						x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y2 = axisy.min;
>, <Line: +					}
>, <Line: +					// clip with ymax
>, <Line: +					if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
>, <Line: +						x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y1 = axisy.max;
>, <Line: +					}
>, <Line: +					else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
>, <Line: +						x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: +						y2 = axisy.max;
>, <Line: +					}
>, <Line: +					// if the x value was changed we got a rectangle
>, <Line: +					// to fill
>, <Line: +					if (x1 != x1old) {
>, <Line: +						ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
>, <Line: +						// it goes to (x1, y1), but we fill that below
>, <Line: +					}
>, <Line: +					// fill triangular section, this sometimes result
>, <Line: +					// in redundant points if (x1, y1) hasn't changed
>, <Line: +					// from previous line to, but we just ignore that
>, <Line: +					ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
>, <Line: +					ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
>, <Line: +					// fill the other rectangle if it's there
>, <Line: +					if (x2 != x2old) {
>, <Line: +						ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
>, <Line: +						ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			ctx.lineJoin = "round";
>, <Line: +			var lw = series.lines.lineWidth,
>, <Line: +				sw = series.shadowSize;
>, <Line: +			// FIXME: consider another form of shadow when filling is turned on
>, <Line: +			if (lw > 0 && sw > 0) {
>, <Line: +				// draw shadow as a thick and thin line with transparency
>, <Line: +				ctx.lineWidth = sw;
>, <Line: +				ctx.strokeStyle = "rgba(0,0,0,0.1)";
>, <Line: +				// position shadow at angle from the mid of line
>, <Line: +				var angle = Math.PI / 18;
>, <Line: +				plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);
>, <Line: +				ctx.lineWidth = sw / 2;
>, <Line: +				plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);
>, <Line: +			}
>, <Line: +			ctx.lineWidth = lw;
>, <Line: +			ctx.strokeStyle = series.color;
>, <Line: +			var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
>, <Line: +			if (fillStyle) {
>, <Line: +				ctx.fillStyle = fillStyle;
>, <Line: +				plotLineArea(series.datapoints, series.xaxis, series.yaxis);
>, <Line: +			}
>, <Line: +			if (lw > 0)
>, <Line: +				plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
>, <Line: +			ctx.restore();
>, <Line: +		}
>, <Line: +		function drawSeriesPoints(series) {
>, <Line: +			function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
>, <Line: +				var points = datapoints.points, ps = datapoints.pointsize;
>, <Line: +				for (var i = 0; i < points.length; i += ps) {
>, <Line: +					var x = points[i], y = points[i + 1];
>, <Line: +					if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
>, <Line: +						continue;
>, <Line: +					ctx.beginPath();
>, <Line: +					x = axisx.p2c(x);
>, <Line: +					y = axisy.p2c(y) + offset;
>, <Line: +					if (symbol == "circle")
>, <Line: +						ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
>, <Line: +					else
>, <Line: +						symbol(ctx, x, y, radius, shadow);
>, <Line: +					ctx.closePath();
>, <Line: +					if (fillStyle) {
>, <Line: +						ctx.fillStyle = fillStyle;
>, <Line: +						ctx.fill();
>, <Line: +					}
>, <Line: +					ctx.stroke();
>, <Line: +				}
>, <Line: +			}
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			var lw = series.points.lineWidth,
>, <Line: +				sw = series.shadowSize,
>, <Line: +				radius = series.points.radius,
>, <Line: +				symbol = series.points.symbol;
>, <Line: +			// If the user sets the line width to 0, we change it to a very
>, <Line: +			// small value. A line width of 0 seems to force the default of 1.
>, <Line: +			// Doing the conditional here allows the shadow setting to still be
>, <Line: +			// optional even with a lineWidth of 0.
>, <Line: +			if (lw == 0)
>, <Line: +				lw = 0.0001;
>, <Line: +			if (lw > 0 && sw > 0) {
>, <Line: +				// draw shadow in two steps
>, <Line: +				var w = sw / 2;
>, <Line: +				ctx.lineWidth = w;
>, <Line: +				ctx.strokeStyle = "rgba(0,0,0,0.1)";
>, <Line: +				plotPoints(series.datapoints, radius, null, w + w / 2, true,
>, <Line: +					series.xaxis, series.yaxis, symbol);
>, <Line: +				ctx.strokeStyle = "rgba(0,0,0,0.2)";
>, <Line: +				plotPoints(series.datapoints, radius, null, w / 2, true,
>, <Line: +					series.xaxis, series.yaxis, symbol);
>, <Line: +			}
>, <Line: +			ctx.lineWidth = lw;
>, <Line: +			ctx.strokeStyle = series.color;
>, <Line: +			plotPoints(series.datapoints, radius,
>, <Line: +				getFillStyle(series.points, series.color), 0, false,
>, <Line: +				series.xaxis, series.yaxis, symbol);
>, <Line: +			ctx.restore();
>, <Line: +		}
>, <Line: +		function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
>, <Line: +			var left, right, bottom, top,
>, <Line: +				drawLeft, drawRight, drawTop, drawBottom,
>, <Line: +				tmp;
>, <Line: +			// in horizontal mode, we start the bar from the left
>, <Line: +			// instead of from the bottom so it appears to be
>, <Line: +			// horizontal rather than vertical
>, <Line: +			if (horizontal) {
>, <Line: +				drawBottom = drawRight = drawTop = true;
>, <Line: +				drawLeft = false;
>, <Line: +				left = b;
>, <Line: +				right = x;
>, <Line: +				top = y + barLeft;
>, <Line: +				bottom = y + barRight;
>, <Line: +				// account for negative bars
>, <Line: +				if (right < left) {
>, <Line: +					tmp = right;
>, <Line: +					right = left;
>, <Line: +					left = tmp;
>, <Line: +					drawLeft = true;
>, <Line: +					drawRight = false;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				drawLeft = drawRight = drawTop = true;
>, <Line: +				drawBottom = false;
>, <Line: +				left = x + barLeft;
>, <Line: +				right = x + barRight;
>, <Line: +				bottom = b;
>, <Line: +				top = y;
>, <Line: +				// account for negative bars
>, <Line: +				if (top < bottom) {
>, <Line: +					tmp = top;
>, <Line: +					top = bottom;
>, <Line: +					bottom = tmp;
>, <Line: +					drawBottom = true;
>, <Line: +					drawTop = false;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// clip
>, <Line: +			if (right < axisx.min || left > axisx.max ||
>, <Line: +				top < axisy.min || bottom > axisy.max)
>, <Line: +				return;
>, <Line: +			if (left < axisx.min) {
>, <Line: +				left = axisx.min;
>, <Line: +				drawLeft = false;
>, <Line: +			}
>, <Line: +			if (right > axisx.max) {
>, <Line: +				right = axisx.max;
>, <Line: +				drawRight = false;
>, <Line: +			}
>, <Line: +			if (bottom < axisy.min) {
>, <Line: +				bottom = axisy.min;
>, <Line: +				drawBottom = false;
>, <Line: +			}
>, <Line: +			if (top > axisy.max) {
>, <Line: +				top = axisy.max;
>, <Line: +				drawTop = false;
>, <Line: +			}
>, <Line: +			left = axisx.p2c(left);
>, <Line: +			bottom = axisy.p2c(bottom);
>, <Line: +			right = axisx.p2c(right);
>, <Line: +			top = axisy.p2c(top);
>, <Line: +			// fill the bar
>, <Line: +			if (fillStyleCallback) {
>, <Line: +				c.fillStyle = fillStyleCallback(bottom, top);
>, <Line: +				c.fillRect(left, top, right - left, bottom - top)
>, <Line: +			}
>, <Line: +			// draw outline
>, <Line: +			if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
>, <Line: +				c.beginPath();
>, <Line: +				// FIXME: inline moveTo is buggy with excanvas
>, <Line: +				c.moveTo(left, bottom);
>, <Line: +				if (drawLeft)
>, <Line: +					c.lineTo(left, top);
>, <Line: +				else
>, <Line: +					c.moveTo(left, top);
>, <Line: +				if (drawTop)
>, <Line: +					c.lineTo(right, top);
>, <Line: +				else
>, <Line: +					c.moveTo(right, top);
>, <Line: +				if (drawRight)
>, <Line: +					c.lineTo(right, bottom);
>, <Line: +				else
>, <Line: +					c.moveTo(right, bottom);
>, <Line: +				if (drawBottom)
>, <Line: +					c.lineTo(left, bottom);
>, <Line: +				else
>, <Line: +					c.moveTo(left, bottom);
>, <Line: +				c.stroke();
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function drawSeriesBars(series) {
>, <Line: +			function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
>, <Line: +				var points = datapoints.points, ps = datapoints.pointsize;
>, <Line: +				for (var i = 0; i < points.length; i += ps) {
>, <Line: +					if (points[i] == null)
>, <Line: +						continue;
>, <Line: +					drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			// FIXME: figure out a way to add shadows (for instance along the right edge)
>, <Line: +			ctx.lineWidth = series.bars.lineWidth;
>, <Line: +			ctx.strokeStyle = series.color;
>, <Line: +			var barLeft;
>, <Line: +			switch (series.bars.align) {
>, <Line: +				case "left":
>, <Line: +					barLeft = 0;
>, <Line: +					break;
>, <Line: +				case "right":
>, <Line: +					barLeft = -series.bars.barWidth;
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					barLeft = -series.bars.barWidth / 2;
>, <Line: +			}
>, <Line: +			var fillStyleCallback = series.bars.fill ? function (bottom, top) {
>, <Line: +				return getFillStyle(series.bars, series.color, bottom, top);
>, <Line: +			} : null;
>, <Line: +			plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
>, <Line: +			ctx.restore();
>, <Line: +		}
>, <Line: +		function getFillStyle(filloptions, seriesColor, bottom, top) {
>, <Line: +			var fill = filloptions.fill;
>, <Line: +			if (!fill)
>, <Line: +				return null;
>, <Line: +			if (filloptions.fillColor)
>, <Line: +				return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
>, <Line: +			var c = $.color.parse(seriesColor);
>, <Line: +			c.a = typeof fill == "number" ? fill : 0.4;
>, <Line: +			c.normalize();
>, <Line: +			return c.toString();
>, <Line: +		}
>, <Line: +		function insertLegend() {
>, <Line: +			if (options.legend.container != null) {
>, <Line: +				$(options.legend.container).html("");
>, <Line: +			} else {
>, <Line: +				placeholder.find(".legend").remove();
>, <Line: +			}
>, <Line: +			if (!options.legend.show) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			var fragments = [], entries = [], rowStarted = false,
>, <Line: +				lf = options.legend.labelFormatter, s, label;
>, <Line: +			// Build a list of legend entries, with each having a label and a color
>, <Line: +			for (var i = 0; i < series.length; ++i) {
>, <Line: +				s = series[i];
>, <Line: +				if (s.label) {
>, <Line: +					label = lf ? lf(s.label, s) : s.label;
>, <Line: +					if (label) {
>, <Line: +						entries.push({
>, <Line: +							label: label,
>, <Line: +							color: s.color
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// Sort the legend using either the default or a custom comparator
>, <Line: +			if (options.legend.sorted) {
>, <Line: +				if ($.isFunction(options.legend.sorted)) {
>, <Line: +					entries.sort(options.legend.sorted);
>, <Line: +				} else if (options.legend.sorted == "reverse") {
>, <Line: +					entries.reverse();
>, <Line: +				} else {
>, <Line: +					var ascending = options.legend.sorted != "descending";
>, <Line: +					entries.sort(function (a, b) {
>, <Line: +						return a.label == b.label ? 0 : (
>, <Line: +							(a.label < b.label) != ascending ? 1 : -1   // Logical XOR
>, <Line: +						);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// Generate markup for the list of entries, in their final order
>, <Line: +			for (var i = 0; i < entries.length; ++i) {
>, <Line: +				var entry = entries[i];
>, <Line: +				if (i % options.legend.noColumns == 0) {
>, <Line: +					if (rowStarted)
>, <Line: +						fragments.push('</tr>');
>, <Line: +					fragments.push('<tr>');
>, <Line: +					rowStarted = true;
>, <Line: +				}
>, <Line: +				fragments.push(
>, <Line: +					'<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
>, <Line: +					'<td class="legendLabel">' + entry.label + '</td>'
>, <Line: +				);
>, <Line: +			}
>, <Line: +			if (rowStarted)
>, <Line: +				fragments.push('</tr>');
>, <Line: +			if (fragments.length == 0)
>, <Line: +				return;
>, <Line: +			var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
>, <Line: +			if (options.legend.container != null)
>, <Line: +				$(options.legend.container).html(table);
>, <Line: +			else {
>, <Line: +				var pos = "",
>, <Line: +					p = options.legend.position,
>, <Line: +					m = options.legend.margin;
>, <Line: +				if (m[0] == null)
>, <Line: +					m = [m, m];
>, <Line: +				if (p.charAt(0) == "n")
>, <Line: +					pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
>, <Line: +				else if (p.charAt(0) == "s")
>, <Line: +					pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
>, <Line: +				if (p.charAt(1) == "e")
>, <Line: +					pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
>, <Line: +				else if (p.charAt(1) == "w")
>, <Line: +					pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
>, <Line: +				var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos + ';') + '</div>').appendTo(placeholder);
>, <Line: +				if (options.legend.backgroundOpacity != 0.0) {
>, <Line: +					// put in the transparent background
>, <Line: +					// separately to avoid blended labels and
>, <Line: +					// label boxes
>, <Line: +					var c = options.legend.backgroundColor;
>, <Line: +					if (c == null) {
>, <Line: +						c = options.grid.backgroundColor;
>, <Line: +						if (c && typeof c == "string")
>, <Line: +							c = $.color.parse(c);
>, <Line: +						else
>, <Line: +							c = $.color.extract(legend, 'background-color');
>, <Line: +						c.a = 1;
>, <Line: +						c = c.toString();
>, <Line: +					}
>, <Line: +					var div = legend.children();
>, <Line: +					$('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos + 'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// interactive features
>, <Line: +		var highlights = [],
>, <Line: +			redrawTimeout = null;
>, <Line: +		// returns the data item the mouse is over, or null if none is found
>, <Line: +		function findNearbyItem(mouseX, mouseY, seriesFilter) {
>, <Line: +			var maxDistance = options.grid.mouseActiveRadius,
>, <Line: +				smallestDistance = maxDistance * maxDistance + 1,
>, <Line: +				item = null, foundPoint = false, i, j, ps;
>, <Line: +			for (i = series.length - 1; i >= 0; --i) {
>, <Line: +				if (!seriesFilter(series[i]))
>, <Line: +					continue;
>, <Line: +				var s = series[i],
>, <Line: +					axisx = s.xaxis,
>, <Line: +					axisy = s.yaxis,
>, <Line: +					points = s.datapoints.points,
>, <Line: +					mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
>, <Line: +					my = axisy.c2p(mouseY),
>, <Line: +					maxx = maxDistance / axisx.scale,
>, <Line: +					maxy = maxDistance / axisy.scale;
>, <Line: +				ps = s.datapoints.pointsize;
>, <Line: +				// with inverse transforms, we can't use the maxx/maxy
>, <Line: +				// optimization, sadly
>, <Line: +				if (axisx.options.inverseTransform)
>, <Line: +					maxx = Number.MAX_VALUE;
>, <Line: +				if (axisy.options.inverseTransform)
>, <Line: +					maxy = Number.MAX_VALUE;
>, <Line: +				if (s.lines.show || s.points.show) {
>, <Line: +					for (j = 0; j < points.length; j += ps) {
>, <Line: +						var x = points[j], y = points[j + 1];
>, <Line: +						if (x == null)
>, <Line: +							continue;
>, <Line: +						// For points and lines, the cursor must be within a
>, <Line: +						// certain distance to the data point
>, <Line: +						if (x - mx > maxx || x - mx < -maxx ||
>, <Line: +							y - my > maxy || y - my < -maxy)
>, <Line: +							continue;
>, <Line: +						// We have to calculate distances in pixels, not in
>, <Line: +						// data units, because the scales of the axes may be different
>, <Line: +						var dx = Math.abs(axisx.p2c(x) - mouseX),
>, <Line: +							dy = Math.abs(axisy.p2c(y) - mouseY),
>, <Line: +							dist = dx * dx + dy * dy; // we save the sqrt
>, <Line: +						// use <= to ensure last point takes precedence
>, <Line: +						// (last generally means on top of)
>, <Line: +						if (dist < smallestDistance) {
>, <Line: +							smallestDistance = dist;
>, <Line: +							item = [i, j / ps];
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (s.bars.show && !item) { // no other point can be nearby
>, <Line: +					var barLeft, barRight;
>, <Line: +					switch (s.bars.align) {
>, <Line: +						case "left":
>, <Line: +							barLeft = 0;
>, <Line: +							break;
>, <Line: +						case "right":
>, <Line: +							barLeft = -s.bars.barWidth;
>, <Line: +							break;
>, <Line: +						default:
>, <Line: +							barLeft = -s.bars.barWidth / 2;
>, <Line: +					}
>, <Line: +					barRight = barLeft + s.bars.barWidth;
>, <Line: +					for (j = 0; j < points.length; j += ps) {
>, <Line: +						var x = points[j], y = points[j + 1], b = points[j + 2];
>, <Line: +						if (x == null)
>, <Line: +							continue;
>, <Line: +						// for a bar graph, the cursor must be inside the bar
>, <Line: +						if (series[i].bars.horizontal ?
>, <Line: +								(mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
>, <Line: +								my >= y + barLeft && my <= y + barRight) :
>, <Line: +								(mx >= x + barLeft && mx <= x + barRight &&
>, <Line: +								my >= Math.min(b, y) && my <= Math.max(b, y)))
>, <Line: +							item = [i, j / ps];
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (item) {
>, <Line: +				i = item[0];
>, <Line: +				j = item[1];
>, <Line: +				ps = series[i].datapoints.pointsize;
>, <Line: +				return {
>, <Line: +					datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
>, <Line: +					dataIndex: j,
>, <Line: +					series: series[i],
>, <Line: +					seriesIndex: i
>, <Line: +				};
>, <Line: +			}
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +		function onMouseMove(e) {
>, <Line: +			if (options.grid.hoverable)
>, <Line: +				triggerClickHoverEvent("plothover", e,
>, <Line: +					function (s) {
>, <Line: +						return s["hoverable"] != false;
>, <Line: +					});
>, <Line: +		}
>, <Line: +		function onMouseLeave(e) {
>, <Line: +			if (options.grid.hoverable)
>, <Line: +				triggerClickHoverEvent("plothover", e,
>, <Line: +					function (s) {
>, <Line: +						return false;
>, <Line: +					});
>, <Line: +		}
>, <Line: +		function onClick(e) {
>, <Line: +			triggerClickHoverEvent("plotclick", e,
>, <Line: +				function (s) {
>, <Line: +					return s["clickable"] != false;
>, <Line: +				});
>, <Line: +		}
>, <Line: +		// trigger click or hover event (they send the same parameters
>, <Line: +		// so we share their code)
>, <Line: +		function triggerClickHoverEvent(eventname, event, seriesFilter) {
>, <Line: +			var offset = eventHolder.offset(),
>, <Line: +				canvasX = event.pageX - offset.left - plotOffset.left,
>, <Line: +				canvasY = event.pageY - offset.top - plotOffset.top,
>, <Line: +				pos = canvasToAxisCoords({left: canvasX, top: canvasY});
>, <Line: +			pos.pageX = event.pageX;
>, <Line: +			pos.pageY = event.pageY;
>, <Line: +			var item = findNearbyItem(canvasX, canvasY, seriesFilter);
>, <Line: +			if (item) {
>, <Line: +				// fill in mouse pos for any listeners out there
>, <Line: +				item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
>, <Line: +				item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
>, <Line: +			}
>, <Line: +			if (options.grid.autoHighlight) {
>, <Line: +				// clear auto-highlights
>, <Line: +				for (var i = 0; i < highlights.length; ++i) {
>, <Line: +					var h = highlights[i];
>, <Line: +					if (h.auto == eventname && !(item && h.series == item.series &&
>, <Line: +						h.point[0] == item.datapoint[0] &&
>, <Line: +						h.point[1] == item.datapoint[1]))
>, <Line: +						unhighlight(h.series, h.point);
>, <Line: +				}
>, <Line: +				if (item)
>, <Line: +					highlight(item.series, item.datapoint, eventname);
>, <Line: +			}
>, <Line: +			placeholder.trigger(eventname, [pos, item]);
>, <Line: +		}
>, <Line: +		function triggerRedrawOverlay() {
>, <Line: +			var t = options.interaction.redrawOverlayInterval;
>, <Line: +			if (t == -1) {      // skip event queue
>, <Line: +				drawOverlay();
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			if (!redrawTimeout)
>, <Line: +				redrawTimeout = setTimeout(drawOverlay, t);
>, <Line: +		}
>, <Line: +		function drawOverlay() {
>, <Line: +			redrawTimeout = null;
>, <Line: +			// draw highlights
>, <Line: +			octx.save();
>, <Line: +			overlay.clear();
>, <Line: +			octx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			var i, hi;
>, <Line: +			for (i = 0; i < highlights.length; ++i) {
>, <Line: +				hi = highlights[i];
>, <Line: +				if (hi.series.bars.show)
>, <Line: +					drawBarHighlight(hi.series, hi.point);
>, <Line: +				else
>, <Line: +					drawPointHighlight(hi.series, hi.point);
>, <Line: +			}
>, <Line: +			octx.restore();
>, <Line: +			executeHooks(hooks.drawOverlay, [octx]);
>, <Line: +		}
>, <Line: +		function highlight(s, point, auto) {
>, <Line: +			if (typeof s == "number")
>, <Line: +				s = series[s];
>, <Line: +			if (typeof point == "number") {
>, <Line: +				var ps = s.datapoints.pointsize;
>, <Line: +				point = s.datapoints.points.slice(ps * point, ps * (point + 1));
>, <Line: +			}
>, <Line: +			var i = indexOfHighlight(s, point);
>, <Line: +			if (i == -1) {
>, <Line: +				highlights.push({series: s, point: point, auto: auto});
>, <Line: +				triggerRedrawOverlay();
>, <Line: +			}
>, <Line: +			else if (!auto)
>, <Line: +				highlights[i].auto = false;
>, <Line: +		}
>, <Line: +		function unhighlight(s, point) {
>, <Line: +			if (s == null && point == null) {
>, <Line: +				highlights = [];
>, <Line: +				triggerRedrawOverlay();
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			if (typeof s == "number")
>, <Line: +				s = series[s];
>, <Line: +			if (typeof point == "number") {
>, <Line: +				var ps = s.datapoints.pointsize;
>, <Line: +				point = s.datapoints.points.slice(ps * point, ps * (point + 1));
>, <Line: +			}
>, <Line: +			var i = indexOfHighlight(s, point);
>, <Line: +			if (i != -1) {
>, <Line: +				highlights.splice(i, 1);
>, <Line: +				triggerRedrawOverlay();
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function indexOfHighlight(s, p) {
>, <Line: +			for (var i = 0; i < highlights.length; ++i) {
>, <Line: +				var h = highlights[i];
>, <Line: +				if (h.series == s && h.point[0] == p[0]
>, <Line: +					&& h.point[1] == p[1])
>, <Line: +					return i;
>, <Line: +			}
>, <Line: +			return -1;
>, <Line: +		}
>, <Line: +		function drawPointHighlight(series, point) {
>, <Line: +			var x = point[0], y = point[1],
>, <Line: +				axisx = series.xaxis, axisy = series.yaxis,
>, <Line: +				highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();
>, <Line: +			if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
>, <Line: +				return;
>, <Line: +			var pointRadius = series.points.radius + series.points.lineWidth / 2;
>, <Line: +			octx.lineWidth = pointRadius;
>, <Line: +			octx.strokeStyle = highlightColor;
>, <Line: +			var radius = 1.5 * pointRadius;
>, <Line: +			x = axisx.p2c(x);
>, <Line: +			y = axisy.p2c(y);
>, <Line: +			octx.beginPath();
>, <Line: +			if (series.points.symbol == "circle")
>, <Line: +				octx.arc(x, y, radius, 0, 2 * Math.PI, false);
>, <Line: +			else
>, <Line: +				series.points.symbol(octx, x, y, radius, false);
>, <Line: +			octx.closePath();
>, <Line: +			octx.stroke();
>, <Line: +		}
>, <Line: +		function drawBarHighlight(series, point) {
>, <Line: +			var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
>, <Line: +				fillStyle = highlightColor,
>, <Line: +				barLeft;
>, <Line: +			switch (series.bars.align) {
>, <Line: +				case "left":
>, <Line: +					barLeft = 0;
>, <Line: +					break;
>, <Line: +				case "right":
>, <Line: +					barLeft = -series.bars.barWidth;
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					barLeft = -series.bars.barWidth / 2;
>, <Line: +			}
>, <Line: +			octx.lineWidth = series.bars.lineWidth;
>, <Line: +			octx.strokeStyle = highlightColor;
>, <Line: +			drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
>, <Line: +				function () {
>, <Line: +					return fillStyle;
>, <Line: +				}, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
>, <Line: +		}
>, <Line: +		function getColorOrGradient(spec, bottom, top, defaultColor) {
>, <Line: +			if (typeof spec == "string")
>, <Line: +				return spec;
>, <Line: +			else {
>, <Line: +				// assume this is a gradient spec; IE currently only
>, <Line: +				// supports a simple vertical gradient properly, so that's
>, <Line: +				// what we support too
>, <Line: +				var gradient = ctx.createLinearGradient(0, top, 0, bottom);
>, <Line: +				for (var i = 0, l = spec.colors.length; i < l; ++i) {
>, <Line: +					var c = spec.colors[i];
>, <Line: +					if (typeof c != "string") {
>, <Line: +						var co = $.color.parse(defaultColor);
>, <Line: +						if (c.brightness != null)
>, <Line: +							co = co.scale('rgb', c.brightness);
>, <Line: +						if (c.opacity != null)
>, <Line: +							co.a *= c.opacity;
>, <Line: +						c = co.toString();
>, <Line: +					}
>, <Line: +					gradient.addColorStop(i / (l - 1), c);
>, <Line: +				}
>, <Line: +				return gradient;
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// Add the plot function to the top level of the jQuery object
>, <Line: +	$.plot = function (placeholder, data, options) {
>, <Line: +		//var t0 = new Date();
>, <Line: +		var plot = new Plot($(placeholder), data, options, $.plot.plugins);
>, <Line: +		//(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
>, <Line: +		return plot;
>, <Line: +	};
>, <Line: +	$.plot.version = "0.8.3";
>, <Line: +	$.plot.plugins = [];
>, <Line: +	// Also add the plot function as a chainable property
>, <Line: +	$.fn.plot = function (data, options) {
>, <Line: +		return this.each(function () {
>, <Line: +			$.plot(this, data, options);
>, <Line: +		});
>, <Line: +	};
>, <Line: +	// round to nearby lower multiple of base
>, <Line: +	function floorInBase(n, base) {
>, <Line: +		return base * Math.floor(n / base);
>, <Line: +	}
>]
[<Line: -Copyright (c) 2007-2014 IOLA and Ole Laursen.
>, <Line: -Licensed under the MIT license.
>, <Line: -*/
>, <Line: -(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);
>, <Line: -(function($) {
>, <Line: -    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM
>, <Line: -    // operation produces the same effect as detach, i.e. removing the element
>, <Line: -    // without touching its jQuery data.
>, <Line: -    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.
>, <Line: -    if (!$.fn.detach) {
>, <Line: -        $.fn.detach = function() {
>, <Line: -            return this.each(function() {
>, <Line: -                if (this.parentNode) {
>, <Line: -                    this.parentNode.removeChild( this );
>, <Line: -                }
>, <Line: -            });
>, <Line: -        };
>, <Line: -    }
>, <Line: -			$(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })
>, <Line: -	Canvas.prototype.resize = function(width, height) {
>, <Line: -	Canvas.prototype.clear = function() {
>, <Line: -	Canvas.prototype.render = function() {
>, <Line: -	Canvas.prototype.getTextLayer = function(classes) {
>, <Line: -	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
>, <Line: -	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {
>, <Line: -	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
>, <Line: -    function Plot(placeholder, data_, options_, plugins) {
>, <Line: -        // data is on the form:
>, <Line: -        //   [ series1, series2 ... ]
>, <Line: -        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
>, <Line: -        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }
>, <Line: -        var series = [],
>, <Line: -            options = {
>, <Line: -                // the color theme used for graphs
>, <Line: -                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
>, <Line: -                legend: {
>, <Line: -                    show: true,
>, <Line: -                    noColumns: 1, // number of colums in legend table
>, <Line: -                    labelFormatter: null, // fn: string -> string
>, <Line: -                    labelBoxBorderColor: "#ccc", // border color for the little label boxes
>, <Line: -                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph
>, <Line: -                    position: "ne", // position of default legend container within plot
>, <Line: -                    margin: 5, // distance from grid edge to default legend container within plot
>, <Line: -                    backgroundColor: null, // null means auto-detect
>, <Line: -                    backgroundOpacity: 0.85, // set to 0 to avoid background
>, <Line: -                    sorted: null    // default to no legend sorting
>, <Line: -                },
>, <Line: -                xaxis: {
>, <Line: -                    show: null, // null = auto-detect, true = always, false = never
>, <Line: -                    position: "bottom", // or "top"
>, <Line: -                    mode: null, // null or "time"
>, <Line: -                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
>, <Line: -                    color: null, // base color, labels, ticks
>, <Line: -                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
>, <Line: -                    transform: null, // null or f: number -> number to transform axis
>, <Line: -                    inverseTransform: null, // if transform is set, this should be the inverse function
>, <Line: -                    min: null, // min. value to show, null means set automatically
>, <Line: -                    max: null, // max. value to show, null means set automatically
>, <Line: -                    autoscaleMargin: null, // margin in % to add if auto-setting min/max
>, <Line: -                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
>, <Line: -                    tickFormatter: null, // fn: number -> string
>, <Line: -                    labelWidth: null, // size of tick labels in pixels
>, <Line: -                    labelHeight: null,
>, <Line: -                    reserveSpace: null, // whether to reserve space even if axis isn't shown
>, <Line: -                    tickLength: null, // size in pixels of ticks, or "full" for whole line
>, <Line: -                    alignTicksWithAxis: null, // axis number or null for no sync
>, <Line: -                    tickDecimals: null, // no. of decimals, null means auto
>, <Line: -                    tickSize: null, // number or [number, "unit"]
>, <Line: -                    minTickSize: null // number or [number, "unit"]
>, <Line: -                },
>, <Line: -                yaxis: {
>, <Line: -                    autoscaleMargin: 0.02,
>, <Line: -                    position: "left" // or "right"
>, <Line: -                },
>, <Line: -                xaxes: [],
>, <Line: -                yaxes: [],
>, <Line: -                series: {
>, <Line: -                    points: {
>, <Line: -                        show: false,
>, <Line: -                        radius: 3,
>, <Line: -                        lineWidth: 2, // in pixels
>, <Line: -                        fill: true,
>, <Line: -                        fillColor: "#ffffff",
>, <Line: -                        symbol: "circle" // or callback
>, <Line: -                    },
>, <Line: -                    lines: {
>, <Line: -                        // we don't put in show: false so we can see
>, <Line: -                        // whether lines were actively disabled
>, <Line: -                        lineWidth: 2, // in pixels
>, <Line: -                        fill: false,
>, <Line: -                        fillColor: null,
>, <Line: -                        steps: false
>, <Line: -                        // Omit 'zero', so we can later default its value to
>, <Line: -                        // match that of the 'fill' option.
>, <Line: -                    },
>, <Line: -                    bars: {
>, <Line: -                        show: false,
>, <Line: -                        lineWidth: 2, // in pixels
>, <Line: -                        barWidth: 1, // in units of the x axis
>, <Line: -                        fill: true,
>, <Line: -                        fillColor: null,
>, <Line: -                        align: "left", // "left", "right", or "center"
>, <Line: -                        horizontal: false,
>, <Line: -                        zero: true
>, <Line: -                    },
>, <Line: -                    shadowSize: 3,
>, <Line: -                    highlightColor: null
>, <Line: -                },
>, <Line: -                grid: {
>, <Line: -                    show: true,
>, <Line: -                    aboveData: false,
>, <Line: -                    color: "#545454", // primary color used for outline and labels
>, <Line: -                    backgroundColor: null, // null for transparent, else color
>, <Line: -                    borderColor: null, // set if different from the grid color
>, <Line: -                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
>, <Line: -                    margin: 0, // distance from the canvas edge to the grid
>, <Line: -                    labelMargin: 5, // in pixels
>, <Line: -                    axisMargin: 8, // in pixels
>, <Line: -                    borderWidth: 2, // in pixels
>, <Line: -                    minBorderMargin: null, // in pixels, null means taken from points radius
>, <Line: -                    markings: null, // array of ranges or fn: axes -> array of ranges
>, <Line: -                    markingsColor: "#f4f4f4",
>, <Line: -                    markingsLineWidth: 2,
>, <Line: -                    // interactive stuff
>, <Line: -                    clickable: false,
>, <Line: -                    hoverable: false,
>, <Line: -                    autoHighlight: true, // highlight in case mouse is near
>, <Line: -                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item
>, <Line: -                },
>, <Line: -                interaction: {
>, <Line: -                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
>, <Line: -                },
>, <Line: -                hooks: {}
>, <Line: -            },
>, <Line: -        surface = null,     // the canvas for the plot itself
>, <Line: -        overlay = null,     // canvas for interactive stuff on top of plot
>, <Line: -        eventHolder = null, // jQuery object that events should be bound to
>, <Line: -        ctx = null, octx = null,
>, <Line: -        xaxes = [], yaxes = [],
>, <Line: -        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
>, <Line: -        plotWidth = 0, plotHeight = 0,
>, <Line: -        hooks = {
>, <Line: -            processOptions: [],
>, <Line: -            processRawData: [],
>, <Line: -            processDatapoints: [],
>, <Line: -            processOffset: [],
>, <Line: -            drawBackground: [],
>, <Line: -            drawSeries: [],
>, <Line: -            draw: [],
>, <Line: -            bindEvents: [],
>, <Line: -            drawOverlay: [],
>, <Line: -            shutdown: []
>, <Line: -        },
>, <Line: -        plot = this;
>, <Line: -        // public functions
>, <Line: -        plot.setData = setData;
>, <Line: -        plot.setupGrid = setupGrid;
>, <Line: -        plot.draw = draw;
>, <Line: -        plot.getPlaceholder = function() { return placeholder; };
>, <Line: -        plot.getCanvas = function() { return surface.element; };
>, <Line: -        plot.getPlotOffset = function() { return plotOffset; };
>, <Line: -        plot.width = function () { return plotWidth; };
>, <Line: -        plot.height = function () { return plotHeight; };
>, <Line: -        plot.offset = function () {
>, <Line: -            var o = eventHolder.offset();
>, <Line: -            o.left += plotOffset.left;
>, <Line: -            o.top += plotOffset.top;
>, <Line: -            return o;
>, <Line: -        };
>, <Line: -        plot.getData = function () { return series; };
>, <Line: -        plot.getAxes = function () {
>, <Line: -            var res = {}, i;
>, <Line: -            $.each(xaxes.concat(yaxes), function (_, axis) {
>, <Line: -                if (axis)
>, <Line: -                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
>, <Line: -            });
>, <Line: -            return res;
>, <Line: -        };
>, <Line: -        plot.getXAxes = function () { return xaxes; };
>, <Line: -        plot.getYAxes = function () { return yaxes; };
>, <Line: -        plot.c2p = canvasToAxisCoords;
>, <Line: -        plot.p2c = axisToCanvasCoords;
>, <Line: -        plot.getOptions = function () { return options; };
>, <Line: -        plot.highlight = highlight;
>, <Line: -        plot.unhighlight = unhighlight;
>, <Line: -        plot.triggerRedrawOverlay = triggerRedrawOverlay;
>, <Line: -        plot.pointOffset = function(point) {
>, <Line: -            return {
>, <Line: -                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
>, <Line: -                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
>, <Line: -            };
>, <Line: -        };
>, <Line: -        plot.shutdown = shutdown;
>, <Line: -        plot.destroy = function () {
>, <Line: -            shutdown();
>, <Line: -            placeholder.removeData("plot").empty();
>, <Line: -            series = [];
>, <Line: -            options = null;
>, <Line: -            surface = null;
>, <Line: -            overlay = null;
>, <Line: -            eventHolder = null;
>, <Line: -            ctx = null;
>, <Line: -            octx = null;
>, <Line: -            xaxes = [];
>, <Line: -            yaxes = [];
>, <Line: -            hooks = null;
>, <Line: -            highlights = [];
>, <Line: -            plot = null;
>, <Line: -        };
>, <Line: -        plot.resize = function () {
>, <Line: -        	var width = placeholder.width(),
>, <Line: -        		height = placeholder.height();
>, <Line: -            surface.resize(width, height);
>, <Line: -            overlay.resize(width, height);
>, <Line: -        };
>, <Line: -        // public attributes
>, <Line: -        plot.hooks = hooks;
>, <Line: -        // initialize
>, <Line: -        initPlugins(plot);
>, <Line: -        parseOptions(options_);
>, <Line: -        setupCanvases();
>, <Line: -        setData(data_);
>, <Line: -        setupGrid();
>, <Line: -        draw();
>, <Line: -        bindEvents();
>, <Line: -        function executeHooks(hook, args) {
>, <Line: -            args = [plot].concat(args);
>, <Line: -            for (var i = 0; i < hook.length; ++i)
>, <Line: -                hook[i].apply(this, args);
>, <Line: -        }
>, <Line: -        function initPlugins() {
>, <Line: -            // References to key classes, allowing plugins to modify them
>, <Line: -            var classes = {
>, <Line: -                Canvas: Canvas
>, <Line: -            };
>, <Line: -            for (var i = 0; i < plugins.length; ++i) {
>, <Line: -                var p = plugins[i];
>, <Line: -                p.init(plot, classes);
>, <Line: -                if (p.options)
>, <Line: -                    $.extend(true, options, p.options);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function parseOptions(opts) {
>, <Line: -            $.extend(true, options, opts);
>, <Line: -            // $.extend merges arrays, rather than replacing them.  When less
>, <Line: -            // colors are provided than the size of the default palette, we
>, <Line: -            // end up with those colors plus the remaining defaults, which is
>, <Line: -            // not expected behavior; avoid it by replacing them here.
>, <Line: -            if (opts && opts.colors) {
>, <Line: -            	options.colors = opts.colors;
>, <Line: -            }
>, <Line: -            if (options.xaxis.color == null)
>, <Line: -                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: -            if (options.yaxis.color == null)
>, <Line: -                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: -            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
>, <Line: -                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
>, <Line: -            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
>, <Line: -                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
>, <Line: -            if (options.grid.borderColor == null)
>, <Line: -                options.grid.borderColor = options.grid.color;
>, <Line: -            if (options.grid.tickColor == null)
>, <Line: -                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();
>, <Line: -            // Fill in defaults for axis options, including any unspecified
>, <Line: -            // font-spec fields, if a font-spec was provided.
>, <Line: -            // If no x/y axis options were provided, create one of each anyway,
>, <Line: -            // since the rest of the code assumes that they exist.
>, <Line: -            var i, axisOptions, axisCount,
>, <Line: -                fontSize = placeholder.css("font-size"),
>, <Line: -                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
>, <Line: -                fontDefaults = {
>, <Line: -                    style: placeholder.css("font-style"),
>, <Line: -                    size: Math.round(0.8 * fontSizeDefault),
>, <Line: -                    variant: placeholder.css("font-variant"),
>, <Line: -                    weight: placeholder.css("font-weight"),
>, <Line: -                    family: placeholder.css("font-family")
>, <Line: -                };
>, <Line: -            axisCount = options.xaxes.length || 1;
>, <Line: -            for (i = 0; i < axisCount; ++i) {
>, <Line: -                axisOptions = options.xaxes[i];
>, <Line: -                if (axisOptions && !axisOptions.tickColor) {
>, <Line: -                    axisOptions.tickColor = axisOptions.color;
>, <Line: -                }
>, <Line: -                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
>, <Line: -                options.xaxes[i] = axisOptions;
>, <Line: -                if (axisOptions.font) {
>, <Line: -                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
>, <Line: -                    if (!axisOptions.font.color) {
>, <Line: -                        axisOptions.font.color = axisOptions.color;
>, <Line: -                    }
>, <Line: -                    if (!axisOptions.font.lineHeight) {
>, <Line: -                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            axisCount = options.yaxes.length || 1;
>, <Line: -            for (i = 0; i < axisCount; ++i) {
>, <Line: -                axisOptions = options.yaxes[i];
>, <Line: -                if (axisOptions && !axisOptions.tickColor) {
>, <Line: -                    axisOptions.tickColor = axisOptions.color;
>, <Line: -                }
>, <Line: -                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
>, <Line: -                options.yaxes[i] = axisOptions;
>, <Line: -                if (axisOptions.font) {
>, <Line: -                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
>, <Line: -                    if (!axisOptions.font.color) {
>, <Line: -                        axisOptions.font.color = axisOptions.color;
>, <Line: -                    }
>, <Line: -                    if (!axisOptions.font.lineHeight) {
>, <Line: -                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // backwards compatibility, to be removed in future
>, <Line: -            if (options.xaxis.noTicks && options.xaxis.ticks == null)
>, <Line: -                options.xaxis.ticks = options.xaxis.noTicks;
>, <Line: -            if (options.yaxis.noTicks && options.yaxis.ticks == null)
>, <Line: -                options.yaxis.ticks = options.yaxis.noTicks;
>, <Line: -            if (options.x2axis) {
>, <Line: -                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
>, <Line: -                options.xaxes[1].position = "top";
>, <Line: -                // Override the inherit to allow the axis to auto-scale
>, <Line: -                if (options.x2axis.min == null) {
>, <Line: -                    options.xaxes[1].min = null;
>, <Line: -                }
>, <Line: -                if (options.x2axis.max == null) {
>, <Line: -                    options.xaxes[1].max = null;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            if (options.y2axis) {
>, <Line: -                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
>, <Line: -                options.yaxes[1].position = "right";
>, <Line: -                // Override the inherit to allow the axis to auto-scale
>, <Line: -                if (options.y2axis.min == null) {
>, <Line: -                    options.yaxes[1].min = null;
>, <Line: -                }
>, <Line: -                if (options.y2axis.max == null) {
>, <Line: -                    options.yaxes[1].max = null;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            if (options.grid.coloredAreas)
>, <Line: -                options.grid.markings = options.grid.coloredAreas;
>, <Line: -            if (options.grid.coloredAreasColor)
>, <Line: -                options.grid.markingsColor = options.grid.coloredAreasColor;
>, <Line: -            if (options.lines)
>, <Line: -                $.extend(true, options.series.lines, options.lines);
>, <Line: -            if (options.points)
>, <Line: -                $.extend(true, options.series.points, options.points);
>, <Line: -            if (options.bars)
>, <Line: -                $.extend(true, options.series.bars, options.bars);
>, <Line: -            if (options.shadowSize != null)
>, <Line: -                options.series.shadowSize = options.shadowSize;
>, <Line: -            if (options.highlightColor != null)
>, <Line: -                options.series.highlightColor = options.highlightColor;
>, <Line: -            // save options on axes for future reference
>, <Line: -            for (i = 0; i < options.xaxes.length; ++i)
>, <Line: -                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
>, <Line: -            for (i = 0; i < options.yaxes.length; ++i)
>, <Line: -                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
>, <Line: -            // add hooks from options
>, <Line: -            for (var n in hooks)
>, <Line: -                if (options.hooks[n] && options.hooks[n].length)
>, <Line: -                    hooks[n] = hooks[n].concat(options.hooks[n]);
>, <Line: -            executeHooks(hooks.processOptions, [options]);
>, <Line: -        }
>, <Line: -        function setData(d) {
>, <Line: -            series = parseData(d);
>, <Line: -            fillInSeriesOptions();
>, <Line: -            processData();
>, <Line: -        }
>, <Line: -        function parseData(d) {
>, <Line: -            var res = [];
>, <Line: -            for (var i = 0; i < d.length; ++i) {
>, <Line: -                var s = $.extend(true, {}, options.series);
>, <Line: -                if (d[i].data != null) {
>, <Line: -                    s.data = d[i].data; // move the data instead of deep-copy
>, <Line: -                    delete d[i].data;
>, <Line: -                    $.extend(true, s, d[i]);
>, <Line: -                    d[i].data = s.data;
>, <Line: -                }
>, <Line: -                else
>, <Line: -                    s.data = d[i];
>, <Line: -                res.push(s);
>, <Line: -            }
>, <Line: -            return res;
>, <Line: -        }
>, <Line: -        function axisNumber(obj, coord) {
>, <Line: -            var a = obj[coord + "axis"];
>, <Line: -            if (typeof a == "object") // if we got a real axis, extract number
>, <Line: -                a = a.n;
>, <Line: -            if (typeof a != "number")
>, <Line: -                a = 1; // default to first axis
>, <Line: -            return a;
>, <Line: -        }
>, <Line: -        function allAxes() {
>, <Line: -            // return flat array without annoying null entries
>, <Line: -            return $.grep(xaxes.concat(yaxes), function (a) { return a; });
>, <Line: -        }
>, <Line: -        function canvasToAxisCoords(pos) {
>, <Line: -            // return an object with x/y corresponding to all used axes
>, <Line: -            var res = {}, i, axis;
>, <Line: -            for (i = 0; i < xaxes.length; ++i) {
>, <Line: -                axis = xaxes[i];
>, <Line: -                if (axis && axis.used)
>, <Line: -                    res["x" + axis.n] = axis.c2p(pos.left);
>, <Line: -            }
>, <Line: -            for (i = 0; i < yaxes.length; ++i) {
>, <Line: -                axis = yaxes[i];
>, <Line: -                if (axis && axis.used)
>, <Line: -                    res["y" + axis.n] = axis.c2p(pos.top);
>, <Line: -            }
>, <Line: -            if (res.x1 !== undefined)
>, <Line: -                res.x = res.x1;
>, <Line: -            if (res.y1 !== undefined)
>, <Line: -                res.y = res.y1;
>, <Line: -            return res;
>, <Line: -        }
>, <Line: -        function axisToCanvasCoords(pos) {
>, <Line: -            // get canvas coords from the first pair of x/y found in pos
>, <Line: -            var res = {}, i, axis, key;
>, <Line: -            for (i = 0; i < xaxes.length; ++i) {
>, <Line: -                axis = xaxes[i];
>, <Line: -                if (axis && axis.used) {
>, <Line: -                    key = "x" + axis.n;
>, <Line: -                    if (pos[key] == null && axis.n == 1)
>, <Line: -                        key = "x";
>, <Line: -                    if (pos[key] != null) {
>, <Line: -                        res.left = axis.p2c(pos[key]);
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            for (i = 0; i < yaxes.length; ++i) {
>, <Line: -                axis = yaxes[i];
>, <Line: -                if (axis && axis.used) {
>, <Line: -                    key = "y" + axis.n;
>, <Line: -                    if (pos[key] == null && axis.n == 1)
>, <Line: -                        key = "y";
>, <Line: -                    if (pos[key] != null) {
>, <Line: -                        res.top = axis.p2c(pos[key]);
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            return res;
>, <Line: -        }
>, <Line: -        function getOrCreateAxis(axes, number) {
>, <Line: -            if (!axes[number - 1])
>, <Line: -                axes[number - 1] = {
>, <Line: -                    n: number, // save the number for future reference
>, <Line: -                    direction: axes == xaxes ? "x" : "y",
>, <Line: -                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
>, <Line: -                };
>, <Line: -            return axes[number - 1];
>, <Line: -        }
>, <Line: -        function fillInSeriesOptions() {
>, <Line: -            var neededColors = series.length, maxIndex = -1, i;
>, <Line: -            // Subtract the number of series that already have fixed colors or
>, <Line: -            // color indexes from the number that we still need to generate.
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                var sc = series[i].color;
>, <Line: -                if (sc != null) {
>, <Line: -                    neededColors--;
>, <Line: -                    if (typeof sc == "number" && sc > maxIndex) {
>, <Line: -                        maxIndex = sc;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // If any of the series have fixed color indexes, then we need to
>, <Line: -            // generate at least as many colors as the highest index.
>, <Line: -            if (neededColors <= maxIndex) {
>, <Line: -                neededColors = maxIndex + 1;
>, <Line: -            }
>, <Line: -            // Generate all the colors, using first the option colors and then
>, <Line: -            // variations on those colors once they're exhausted.
>, <Line: -            var c, colors = [], colorPool = options.colors,
>, <Line: -                colorPoolSize = colorPool.length, variation = 0;
>, <Line: -            for (i = 0; i < neededColors; i++) {
>, <Line: -                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");
>, <Line: -                // Each time we exhaust the colors in the pool we adjust
>, <Line: -                // a scaling factor used to produce more variations on
>, <Line: -                // those colors. The factor alternates negative/positive
>, <Line: -                // to produce lighter/darker colors.
>, <Line: -                // Reset the variation after every few cycles, or else
>, <Line: -                // it will end up producing only white or black colors.
>, <Line: -                if (i % colorPoolSize == 0 && i) {
>, <Line: -                    if (variation >= 0) {
>, <Line: -                        if (variation < 0.5) {
>, <Line: -                            variation = -variation - 0.2;
>, <Line: -                        } else variation = 0;
>, <Line: -                    } else variation = -variation;
>, <Line: -                }
>, <Line: -                colors[i] = c.scale('rgb', 1 + variation);
>, <Line: -            }
>, <Line: -            // Finalize the series options, filling in their colors
>, <Line: -            var colori = 0, s;
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                // assign colors
>, <Line: -                if (s.color == null) {
>, <Line: -                    s.color = colors[colori].toString();
>, <Line: -                    ++colori;
>, <Line: -                }
>, <Line: -                else if (typeof s.color == "number")
>, <Line: -                    s.color = colors[s.color].toString();
>, <Line: -                // turn on lines automatically in case nothing is set
>, <Line: -                if (s.lines.show == null) {
>, <Line: -                    var v, show = true;
>, <Line: -                    for (v in s)
>, <Line: -                        if (s[v] && s[v].show) {
>, <Line: -                            show = false;
>, <Line: -                            break;
>, <Line: -                        }
>, <Line: -                    if (show)
>, <Line: -                        s.lines.show = true;
>, <Line: -                }
>, <Line: -                // If nothing was provided for lines.zero, default it to match
>, <Line: -                // lines.fill, since areas by default should extend to zero.
>, <Line: -                if (s.lines.zero == null) {
>, <Line: -                    s.lines.zero = !!s.lines.fill;
>, <Line: -                }
>, <Line: -                // setup axes
>, <Line: -                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
>, <Line: -                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function processData() {
>, <Line: -            var topSentry = Number.POSITIVE_INFINITY,
>, <Line: -                bottomSentry = Number.NEGATIVE_INFINITY,
>, <Line: -                fakeInfinity = Number.MAX_VALUE,
>, <Line: -                i, j, k, m, length,
>, <Line: -                s, points, ps, x, y, axis, val, f, p,
>, <Line: -                data, format;
>, <Line: -            function updateAxis(axis, min, max) {
>, <Line: -                if (min < axis.datamin && min != -fakeInfinity)
>, <Line: -                    axis.datamin = min;
>, <Line: -                if (max > axis.datamax && max != fakeInfinity)
>, <Line: -                    axis.datamax = max;
>, <Line: -            }
>, <Line: -            $.each(allAxes(), function (_, axis) {
>, <Line: -                // init axis
>, <Line: -                axis.datamin = topSentry;
>, <Line: -                axis.datamax = bottomSentry;
>, <Line: -                axis.used = false;
>, <Line: -            });
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                s.datapoints = { points: [] };
>, <Line: -                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
>, <Line: -            }
>, <Line: -            // first pass: clean and copy data
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                data = s.data;
>, <Line: -                format = s.datapoints.format;
>, <Line: -                if (!format) {
>, <Line: -                    format = [];
>, <Line: -                    // find out how to copy
>, <Line: -                    format.push({ x: true, number: true, required: true });
>, <Line: -                    format.push({ y: true, number: true, required: true });
>, <Line: -                    if (s.bars.show || (s.lines.show && s.lines.fill)) {
>, <Line: -                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
>, <Line: -                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
>, <Line: -                        if (s.bars.horizontal) {
>, <Line: -                            delete format[format.length - 1].y;
>, <Line: -                            format[format.length - 1].x = true;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    s.datapoints.format = format;
>, <Line: -                }
>, <Line: -                if (s.datapoints.pointsize != null)
>, <Line: -                    continue; // already filled in
>, <Line: -                s.datapoints.pointsize = format.length;
>, <Line: -                ps = s.datapoints.pointsize;
>, <Line: -                points = s.datapoints.points;
>, <Line: -                var insertSteps = s.lines.show && s.lines.steps;
>, <Line: -                s.xaxis.used = s.yaxis.used = true;
>, <Line: -                for (j = k = 0; j < data.length; ++j, k += ps) {
>, <Line: -                    p = data[j];
>, <Line: -                    var nullify = p == null;
>, <Line: -                    if (!nullify) {
>, <Line: -                        for (m = 0; m < ps; ++m) {
>, <Line: -                            val = p[m];
>, <Line: -                            f = format[m];
>, <Line: -                            if (f) {
>, <Line: -                                if (f.number && val != null) {
>, <Line: -                                    val = +val; // convert to number
>, <Line: -                                    if (isNaN(val))
>, <Line: -                                        val = null;
>, <Line: -                                    else if (val == Infinity)
>, <Line: -                                        val = fakeInfinity;
>, <Line: -                                    else if (val == -Infinity)
>, <Line: -                                        val = -fakeInfinity;
>, <Line: -                                }
>, <Line: -                                if (val == null) {
>, <Line: -                                    if (f.required)
>, <Line: -                                        nullify = true;
>, <Line: -                                    if (f.defaultValue != null)
>, <Line: -                                        val = f.defaultValue;
>, <Line: -                                }
>, <Line: -                            }
>, <Line: -                            points[k + m] = val;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    if (nullify) {
>, <Line: -                        for (m = 0; m < ps; ++m) {
>, <Line: -                            val = points[k + m];
>, <Line: -                            if (val != null) {
>, <Line: -                                f = format[m];
>, <Line: -                                // extract min/max info
>, <Line: -                                if (f.autoscale !== false) {
>, <Line: -                                    if (f.x) {
>, <Line: -                                        updateAxis(s.xaxis, val, val);
>, <Line: -                                    }
>, <Line: -                                    if (f.y) {
>, <Line: -                                        updateAxis(s.yaxis, val, val);
>, <Line: -                                    }
>, <Line: -                                }
>, <Line: -                            }
>, <Line: -                            points[k + m] = null;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        // a little bit of line specific stuff that
>, <Line: -                        // perhaps shouldn't be here, but lacking
>, <Line: -                        // better means...
>, <Line: -                        if (insertSteps && k > 0
>, <Line: -                            && points[k - ps] != null
>, <Line: -                            && points[k - ps] != points[k]
>, <Line: -                            && points[k - ps + 1] != points[k + 1]) {
>, <Line: -                            // copy the point to make room for a middle point
>, <Line: -                            for (m = 0; m < ps; ++m)
>, <Line: -                                points[k + ps + m] = points[k + m];
>, <Line: -                            // middle point has same y
>, <Line: -                            points[k + 1] = points[k - ps + 1];
>, <Line: -                            // we've added a point, better reflect that
>, <Line: -                            k += ps;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // give the hooks a chance to run
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
>, <Line: -            }
>, <Line: -            // second pass: find datamax/datamin for auto-scaling
>, <Line: -            for (i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                points = s.datapoints.points;
>, <Line: -                ps = s.datapoints.pointsize;
>, <Line: -                format = s.datapoints.format;
>, <Line: -                var xmin = topSentry, ymin = topSentry,
>, <Line: -                    xmax = bottomSentry, ymax = bottomSentry;
>, <Line: -                for (j = 0; j < points.length; j += ps) {
>, <Line: -                    if (points[j] == null)
>, <Line: -                        continue;
>, <Line: -                    for (m = 0; m < ps; ++m) {
>, <Line: -                        val = points[j + m];
>, <Line: -                        f = format[m];
>, <Line: -                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
>, <Line: -                            continue;
>, <Line: -                        if (f.x) {
>, <Line: -                            if (val < xmin)
>, <Line: -                                xmin = val;
>, <Line: -                            if (val > xmax)
>, <Line: -                                xmax = val;
>, <Line: -                        }
>, <Line: -                        if (f.y) {
>, <Line: -                            if (val < ymin)
>, <Line: -                                ymin = val;
>, <Line: -                            if (val > ymax)
>, <Line: -                                ymax = val;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                if (s.bars.show) {
>, <Line: -                    // make sure we got room for the bar on the dancing floor
>, <Line: -                    var delta;
>, <Line: -                    switch (s.bars.align) {
>, <Line: -                        case "left":
>, <Line: -                            delta = 0;
>, <Line: -                            break;
>, <Line: -                        case "right":
>, <Line: -                            delta = -s.bars.barWidth;
>, <Line: -                            break;
>, <Line: -                        default:
>, <Line: -                            delta = -s.bars.barWidth / 2;
>, <Line: -                    }
>, <Line: -                    if (s.bars.horizontal) {
>, <Line: -                        ymin += delta;
>, <Line: -                        ymax += delta + s.bars.barWidth;
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        xmin += delta;
>, <Line: -                        xmax += delta + s.bars.barWidth;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                updateAxis(s.xaxis, xmin, xmax);
>, <Line: -                updateAxis(s.yaxis, ymin, ymax);
>, <Line: -            }
>, <Line: -            $.each(allAxes(), function (_, axis) {
>, <Line: -                if (axis.datamin == topSentry)
>, <Line: -                    axis.datamin = null;
>, <Line: -                if (axis.datamax == bottomSentry)
>, <Line: -                    axis.datamax = null;
>, <Line: -            });
>, <Line: -        }
>, <Line: -        function setupCanvases() {
>, <Line: -            // Make sure the placeholder is clear of everything except canvases
>, <Line: -            // from a previous plot in this container that we'll try to re-use.
>, <Line: -            placeholder.css("padding", 0) // padding messes up the positioning
>, <Line: -                .children().filter(function(){
>, <Line: -                    return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
>, <Line: -                }).remove();
>, <Line: -            if (placeholder.css("position") == 'static')
>, <Line: -                placeholder.css("position", "relative"); // for positioning labels and overlay
>, <Line: -            surface = new Canvas("flot-base", placeholder);
>, <Line: -            overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features
>, <Line: -            ctx = surface.context;
>, <Line: -            octx = overlay.context;
>, <Line: -            // define which element we're listening for events on
>, <Line: -            eventHolder = $(overlay.element).unbind();
>, <Line: -            // If we're re-using a plot object, shut down the old one
>, <Line: -            var existing = placeholder.data("plot");
>, <Line: -            if (existing) {
>, <Line: -                existing.shutdown();
>, <Line: -                overlay.clear();
>, <Line: -            }
>, <Line: -            // save in case we get replotted
>, <Line: -            placeholder.data("plot", plot);
>, <Line: -        }
>, <Line: -        function bindEvents() {
>, <Line: -            // bind events
>, <Line: -            if (options.grid.hoverable) {
>, <Line: -                eventHolder.mousemove(onMouseMove);
>, <Line: -                // Use bind, rather than .mouseleave, because we officially
>, <Line: -                // still support jQuery 1.2.6, which doesn't define a shortcut
>, <Line: -                // for mouseenter or mouseleave.  This was a bug/oversight that
>, <Line: -                // was fixed somewhere around 1.3.x.  We can return to using
>, <Line: -                // .mouseleave when we drop support for 1.2.6.
>, <Line: -                eventHolder.bind("mouseleave", onMouseLeave);
>, <Line: -            }
>, <Line: -            if (options.grid.clickable)
>, <Line: -                eventHolder.click(onClick);
>, <Line: -            executeHooks(hooks.bindEvents, [eventHolder]);
>, <Line: -        }
>, <Line: -        function shutdown() {
>, <Line: -            if (redrawTimeout)
>, <Line: -                clearTimeout(redrawTimeout);
>, <Line: -            eventHolder.unbind("mousemove", onMouseMove);
>, <Line: -            eventHolder.unbind("mouseleave", onMouseLeave);
>, <Line: -            eventHolder.unbind("click", onClick);
>, <Line: -            executeHooks(hooks.shutdown, [eventHolder]);
>, <Line: -        }
>, <Line: -        function setTransformationHelpers(axis) {
>, <Line: -            // set helper functions on the axis, assumes plot area
>, <Line: -            // has been computed already
>, <Line: -            function identity(x) { return x; }
>, <Line: -            var s, m, t = axis.options.transform || identity,
>, <Line: -                it = axis.options.inverseTransform;
>, <Line: -            // precompute how much the axis is scaling a point
>, <Line: -            // in canvas space
>, <Line: -            if (axis.direction == "x") {
>, <Line: -                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
>, <Line: -                m = Math.min(t(axis.max), t(axis.min));
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
>, <Line: -                s = -s;
>, <Line: -                m = Math.max(t(axis.max), t(axis.min));
>, <Line: -            }
>, <Line: -            // data point to canvas coordinate
>, <Line: -            if (t == identity) // slight optimization
>, <Line: -                axis.p2c = function (p) { return (p - m) * s; };
>, <Line: -            else
>, <Line: -                axis.p2c = function (p) { return (t(p) - m) * s; };
>, <Line: -            // canvas coordinate to data point
>, <Line: -            if (!it)
>, <Line: -                axis.c2p = function (c) { return m + c / s; };
>, <Line: -            else
>, <Line: -                axis.c2p = function (c) { return it(m + c / s); };
>, <Line: -        }
>, <Line: -        function measureTickLabels(axis) {
>, <Line: -            var opts = axis.options,
>, <Line: -                ticks = axis.ticks || [],
>, <Line: -                labelWidth = opts.labelWidth || 0,
>, <Line: -                labelHeight = opts.labelHeight || 0,
>, <Line: -                maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
>, <Line: -                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
>, <Line: -                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
>, <Line: -                font = opts.font || "flot-tick-label tickLabel";
>, <Line: -            for (var i = 0; i < ticks.length; ++i) {
>, <Line: -                var t = ticks[i];
>, <Line: -                if (!t.label)
>, <Line: -                    continue;
>, <Line: -                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);
>, <Line: -                /// Grafana fix, add +1 to label width
>, <Line: -                labelWidth = Math.max(labelWidth, info.width + 1);
>, <Line: -                labelHeight = Math.max(labelHeight, info.height);
>, <Line: -            }
>, <Line: -            axis.labelWidth = opts.labelWidth || labelWidth;
>, <Line: -            axis.labelHeight = opts.labelHeight || labelHeight;
>, <Line: -        }
>, <Line: -        function allocateAxisBoxFirstPhase(axis) {
>, <Line: -            // find the bounding box of the axis by looking at label
>, <Line: -            // widths/heights and ticks, make room by diminishing the
>, <Line: -            // plotOffset; this first phase only looks at one
>, <Line: -            // dimension per axis, the other dimension depends on the
>, <Line: -            // other axes so will have to wait
>, <Line: -            var lw = axis.labelWidth,
>, <Line: -                lh = axis.labelHeight,
>, <Line: -                pos = axis.options.position,
>, <Line: -                isXAxis = axis.direction === "x",
>, <Line: -                tickLength = axis.options.tickLength,
>, <Line: -                axisMargin = options.grid.axisMargin,
>, <Line: -                padding = options.grid.labelMargin,
>, <Line: -                innermost = true,
>, <Line: -                outermost = true,
>, <Line: -                first = true,
>, <Line: -                found = false;
>, <Line: -            // Determine the axis's position in its direction and on its side
>, <Line: -            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
>, <Line: -                if (a && (a.show || a.reserveSpace)) {
>, <Line: -                    if (a === axis) {
>, <Line: -                        found = true;
>, <Line: -                    } else if (a.options.position === pos) {
>, <Line: -                        if (found) {
>, <Line: -                            outermost = false;
>, <Line: -                        } else {
>, <Line: -                            innermost = false;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    if (!found) {
>, <Line: -                        first = false;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            });
>, <Line: -            // The outermost axis on each side has no margin
>, <Line: -            if (outermost) {
>, <Line: -                axisMargin = 0;
>, <Line: -            }
>, <Line: -            // The ticks for the first axis in each direction stretch across
>, <Line: -            if (tickLength == null) {
>, <Line: -                tickLength = first ? "full" : 5;
>, <Line: -            }
>, <Line: -            if (!isNaN(+tickLength))
>, <Line: -                padding += +tickLength;
>, <Line: -            if (isXAxis) {
>, <Line: -                lh += padding;
>, <Line: -                if (pos == "bottom") {
>, <Line: -                    plotOffset.bottom += lh + axisMargin;
>, <Line: -                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    axis.box = { top: plotOffset.top + axisMargin, height: lh };
>, <Line: -                    plotOffset.top += lh + axisMargin;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                lw += padding;
>, <Line: -                if (pos == "left") {
>, <Line: -                    axis.box = { left: plotOffset.left + axisMargin, width: lw };
>, <Line: -                    plotOffset.left += lw + axisMargin;
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    plotOffset.right += lw + axisMargin;
>, <Line: -                    axis.box = { left: surface.width - plotOffset.right, width: lw };
>, <Line: -                }
>, <Line: -            }
>, <Line: -             // save for future reference
>, <Line: -            axis.position = pos;
>, <Line: -            axis.tickLength = tickLength;
>, <Line: -            axis.box.padding = padding;
>, <Line: -            axis.innermost = innermost;
>, <Line: -        }
>, <Line: -        function allocateAxisBoxSecondPhase(axis) {
>, <Line: -            // now that all axis boxes have been placed in one
>, <Line: -            // dimension, we can set the remaining dimension coordinates
>, <Line: -            if (axis.direction == "x") {
>, <Line: -                axis.box.left = plotOffset.left - axis.labelWidth / 2;
>, <Line: -                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                axis.box.top = plotOffset.top - axis.labelHeight / 2;
>, <Line: -                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function adjustLayoutForThingsStickingOut() {
>, <Line: -            // possibly adjust plot offset to ensure everything stays
>, <Line: -            // inside the canvas and isn't clipped off
>, <Line: -            var minMargin = options.grid.minBorderMargin,
>, <Line: -                axis, i;
>, <Line: -            // check stuff from the plot (FIXME: this should just read
>, <Line: -            // a value from the series, otherwise it's impossible to
>, <Line: -            // customize)
>, <Line: -            if (minMargin == null) {
>, <Line: -                minMargin = 0;
>, <Line: -                for (i = 0; i < series.length; ++i)
>, <Line: -                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
>, <Line: -            }
>, <Line: -            var margins = {
>, <Line: -                left: minMargin,
>, <Line: -                right: minMargin,
>, <Line: -                top: minMargin,
>, <Line: -                bottom: minMargin
>, <Line: -            };
>, <Line: -            // check axis labels, note we don't check the actual
>, <Line: -            // labels but instead use the overall width/height to not
>, <Line: -            // jump as much around with replots
>, <Line: -            $.each(allAxes(), function (_, axis) {
>, <Line: -                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
>, <Line: -                    if (axis.direction === "x") {
>, <Line: -                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
>, <Line: -                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
>, <Line: -                    } else {
>, <Line: -                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
>, <Line: -                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            });
>, <Line: -            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
>, <Line: -            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
>, <Line: -            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
>, <Line: -            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
>, <Line: -        }
>, <Line: -        function setupGrid() {
>, <Line: -            var i, axes = allAxes(), showGrid = options.grid.show;
>, <Line: -            // Initialize the plot's offset from the edge of the canvas
>, <Line: -            for (var a in plotOffset) {
>, <Line: -                var margin = options.grid.margin || 0;
>, <Line: -                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
>, <Line: -            }
>, <Line: -            executeHooks(hooks.processOffset, [plotOffset]);
>, <Line: -            // If the grid is visible, add its border width to the offset
>, <Line: -            for (var a in plotOffset) {
>, <Line: -                if(typeof(options.grid.borderWidth) == "object") {
>, <Line: -                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            $.each(axes, function (_, axis) {
>, <Line: -                var axisOpts = axis.options;
>, <Line: -                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
>, <Line: -                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
>, <Line: -                setRange(axis);
>, <Line: -            });
>, <Line: -            if (showGrid) {
>, <Line: -                var allocatedAxes = $.grep(axes, function (axis) {
>, <Line: -                    return axis.show || axis.reserveSpace;
>, <Line: -                });
>, <Line: -                $.each(allocatedAxes, function (_, axis) {
>, <Line: -                    // make the ticks
>, <Line: -                    setupTickGeneration(axis);
>, <Line: -                    setTicks(axis);
>, <Line: -                    snapRangeToTicks(axis, axis.ticks);
>, <Line: -                    // find labelWidth/Height for axis
>, <Line: -                    measureTickLabels(axis);
>, <Line: -                });
>, <Line: -                // with all dimensions calculated, we can compute the
>, <Line: -                // axis bounding boxes, start from the outside
>, <Line: -                // (reverse order)
>, <Line: -                for (i = allocatedAxes.length - 1; i >= 0; --i)
>, <Line: -                    allocateAxisBoxFirstPhase(allocatedAxes[i]);
>, <Line: -                // make sure we've got enough space for things that
>, <Line: -                // might stick out
>, <Line: -                adjustLayoutForThingsStickingOut();
>, <Line: -                $.each(allocatedAxes, function (_, axis) {
>, <Line: -                    allocateAxisBoxSecondPhase(axis);
>, <Line: -                });
>, <Line: -            }
>, <Line: -            plotWidth = surface.width - plotOffset.left - plotOffset.right;
>, <Line: -            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
>, <Line: -            // now we got the proper plot dimensions, we can compute the scaling
>, <Line: -            $.each(axes, function (_, axis) {
>, <Line: -                setTransformationHelpers(axis);
>, <Line: -            });
>, <Line: -            if (showGrid) {
>, <Line: -                drawAxisLabels();
>, <Line: -            }
>, <Line: -            insertLegend();
>, <Line: -        }
>, <Line: -        function setRange(axis) {
>, <Line: -            var opts = axis.options,
>, <Line: -                min = +(opts.min != null ? opts.min : axis.datamin),
>, <Line: -                max = +(opts.max != null ? opts.max : axis.datamax),
>, <Line: -                delta = max - min;
>, <Line: -            if (delta == 0.0) {
>, <Line: -                // degenerate case
>, <Line: -                var widen = max == 0 ? 1 : 0.01;
>, <Line: -                if (opts.min == null)
>, <Line: -                    min -= widen;
>, <Line: -                // always widen max if we couldn't widen min to ensure we
>, <Line: -                // don't fall into min == max which doesn't work
>, <Line: -                if (opts.max == null || opts.min != null)
>, <Line: -                    max += widen;
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                // consider autoscaling
>, <Line: -                var margin = opts.autoscaleMargin;
>, <Line: -                if (margin != null) {
>, <Line: -                    if (opts.min == null) {
>, <Line: -                        min -= delta * margin;
>, <Line: -                        // make sure we don't go below zero if all values
>, <Line: -                        // are positive
>, <Line: -                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)
>, <Line: -                            min = 0;
>, <Line: -                    }
>, <Line: -                    if (opts.max == null) {
>, <Line: -                        max += delta * margin;
>, <Line: -                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)
>, <Line: -                            max = 0;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            axis.min = min;
>, <Line: -            axis.max = max;
>, <Line: -        }
>, <Line: -        function setupTickGeneration(axis) {
>, <Line: -            var opts = axis.options;
>, <Line: -            // estimate number of ticks
>, <Line: -            var noTicks;
>, <Line: -            if (typeof opts.ticks == "number" && opts.ticks > 0)
>, <Line: -                noTicks = opts.ticks;
>, <Line: -            else
>, <Line: -                // heuristic based on the model a*sqrt(x) fitted to
>, <Line: -                // some data points that seemed reasonable
>, <Line: -                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);
>, <Line: -            var delta = (axis.max - axis.min) / noTicks,
>, <Line: -                dec = -Math.floor(Math.log(delta) / Math.LN10),
>, <Line: -                maxDec = opts.tickDecimals;
>, <Line: -            if (maxDec != null && dec > maxDec) {
>, <Line: -                dec = maxDec;
>, <Line: -            }
>, <Line: -            var magn = Math.pow(10, -dec),
>, <Line: -                norm = delta / magn, // norm is between 1.0 and 10.0
>, <Line: -                size;
>, <Line: -            if (norm < 1.5) {
>, <Line: -                size = 1;
>, <Line: -            } else if (norm < 3) {
>, <Line: -                size = 2;
>, <Line: -                // special case for 2.5, requires an extra decimal
>, <Line: -                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
>, <Line: -                    size = 2.5;
>, <Line: -                    ++dec;
>, <Line: -                }
>, <Line: -            } else if (norm < 7.5) {
>, <Line: -                size = 5;
>, <Line: -            } else {
>, <Line: -                size = 10;
>, <Line: -            }
>, <Line: -            size *= magn;
>, <Line: -            if (opts.minTickSize != null && size < opts.minTickSize) {
>, <Line: -                size = opts.minTickSize;
>, <Line: -            }
>, <Line: -            axis.delta = delta;
>, <Line: -            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
>, <Line: -            axis.tickSize = opts.tickSize || size;
>, <Line: -            // grafana addition
>, <Line: -            axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);
>, <Line: -            // Time mode was moved to a plug-in in 0.8, and since so many people use it
>, <Line: -            // we'll add an especially friendly reminder to make sure they included it.
>, <Line: -            if (opts.mode == "time" && !axis.tickGenerator) {
>, <Line: -                throw new Error("Time mode requires the flot.time plugin.");
>, <Line: -            }
>, <Line: -            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
>, <Line: -            // like flot.time.js.
>, <Line: -            if (!axis.tickGenerator) {
>, <Line: -                axis.tickGenerator = function (axis) {
>, <Line: -                    var ticks = [],
>, <Line: -                        start = floorInBase(axis.min, axis.tickSize),
>, <Line: -                        i = 0,
>, <Line: -                        v = Number.NaN,
>, <Line: -                        prev;
>, <Line: -                    do {
>, <Line: -                        prev = v;
>, <Line: -                        v = start + i * axis.tickSize;
>, <Line: -                        ticks.push(v);
>, <Line: -                        ++i;
>, <Line: -                    } while (v < axis.max && v != prev);
>, <Line: -                    return ticks;
>, <Line: -                };
>, <Line: -				axis.tickFormatter = function (value, axis) {
>, <Line: -					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
>, <Line: -					var formatted = "" + Math.round(value * factor) / factor;
>, <Line: -					// If tickDecimals was specified, ensure that we have exactly that
>, <Line: -					// much precision; otherwise default to the value's own precision.
>, <Line: -					if (axis.tickDecimals != null) {
>, <Line: -						var decimal = formatted.indexOf(".");
>, <Line: -						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
>, <Line: -						if (precision < axis.tickDecimals) {
>, <Line: -							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
>, <Line: -                    return formatted;
>, <Line: -                };
>, <Line: -            }
>, <Line: -            if ($.isFunction(opts.tickFormatter))
>, <Line: -                axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };
>, <Line: -            if (opts.alignTicksWithAxis != null) {
>, <Line: -                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
>, <Line: -                if (otherAxis && otherAxis.used && otherAxis != axis) {
>, <Line: -                    // consider snapping min/max to outermost nice ticks
>, <Line: -                    var niceTicks = axis.tickGenerator(axis);
>, <Line: -                    if (niceTicks.length > 0) {
>, <Line: -                        if (opts.min == null)
>, <Line: -                            axis.min = Math.min(axis.min, niceTicks[0]);
>, <Line: -                        if (opts.max == null && niceTicks.length > 1)
>, <Line: -                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
>, <Line: -                    }
>, <Line: -                    axis.tickGenerator = function (axis) {
>, <Line: -                        // copy ticks, scaled to this axis
>, <Line: -                        var ticks = [], v, i;
>, <Line: -                        for (i = 0; i < otherAxis.ticks.length; ++i) {
>, <Line: -                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
>, <Line: -                            v = axis.min + v * (axis.max - axis.min);
>, <Line: -                            ticks.push(v);
>, <Line: -                        }
>, <Line: -                        return ticks;
>, <Line: -                    };
>, <Line: -                    // we might need an extra decimal since forced
>, <Line: -                    // ticks don't necessarily fit naturally
>, <Line: -                    if (!axis.mode && opts.tickDecimals == null) {
>, <Line: -                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
>, <Line: -                            ts = axis.tickGenerator(axis);
>, <Line: -                        // only proceed if the tick interval rounded
>, <Line: -                        // with an extra decimal doesn't give us a
>, <Line: -                        // zero at end
>, <Line: -                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
>, <Line: -                            axis.tickDecimals = extraDec;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function setTicks(axis) {
>, <Line: -            var oticks = axis.options.ticks, ticks = [];
>, <Line: -            if (oticks == null || (typeof oticks == "number" && oticks > 0))
>, <Line: -                ticks = axis.tickGenerator(axis);
>, <Line: -            else if (oticks) {
>, <Line: -                if ($.isFunction(oticks))
>, <Line: -                    // generate the ticks
>, <Line: -                    ticks = oticks(axis);
>, <Line: -                else
>, <Line: -                    ticks = oticks;
>, <Line: -            }
>, <Line: -            // clean up/labelify the supplied ticks, copy them over
>, <Line: -            var i, v;
>, <Line: -            axis.ticks = [];
>, <Line: -            for (i = 0; i < ticks.length; ++i) {
>, <Line: -                var label = null;
>, <Line: -                var t = ticks[i];
>, <Line: -                if (typeof t == "object") {
>, <Line: -                    v = +t[0];
>, <Line: -                    if (t.length > 1)
>, <Line: -                        label = t[1];
>, <Line: -                }
>, <Line: -                else
>, <Line: -                    v = +t;
>, <Line: -                if (label == null)
>, <Line: -                    label = axis.tickFormatter(v, axis);
>, <Line: -                if (!isNaN(v))
>, <Line: -                    axis.ticks.push({ v: v, label: label });
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function snapRangeToTicks(axis, ticks) {
>, <Line: -            if (axis.options.autoscaleMargin && ticks.length > 0) {
>, <Line: -                // snap to ticks
>, <Line: -                if (axis.options.min == null)
>, <Line: -                    axis.min = Math.min(axis.min, ticks[0].v);
>, <Line: -                if (axis.options.max == null && ticks.length > 1)
>, <Line: -                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function draw() {
>, <Line: -            surface.clear();
>, <Line: -            executeHooks(hooks.drawBackground, [ctx]);
>, <Line: -            var grid = options.grid;
>, <Line: -            // draw background, if any
>, <Line: -            if (grid.show && grid.backgroundColor)
>, <Line: -                drawBackground();
>, <Line: -            if (grid.show && !grid.aboveData) {
>, <Line: -                drawGrid();
>, <Line: -            }
>, <Line: -            for (var i = 0; i < series.length; ++i) {
>, <Line: -                executeHooks(hooks.drawSeries, [ctx, series[i]]);
>, <Line: -                drawSeries(series[i]);
>, <Line: -            }
>, <Line: -            executeHooks(hooks.draw, [ctx]);
>, <Line: -            if (grid.show && grid.aboveData) {
>, <Line: -                drawGrid();
>, <Line: -            }
>, <Line: -            surface.render();
>, <Line: -            // A draw implies that either the axes or data have changed, so we
>, <Line: -            // should probably update the overlay highlights as well.
>, <Line: -            triggerRedrawOverlay();
>, <Line: -        }
>, <Line: -        function extractRange(ranges, coord) {
>, <Line: -            var axis, from, to, key, axes = allAxes();
>, <Line: -            for (var i = 0; i < axes.length; ++i) {
>, <Line: -                axis = axes[i];
>, <Line: -                if (axis.direction == coord) {
>, <Line: -                    key = coord + axis.n + "axis";
>, <Line: -                    if (!ranges[key] && axis.n == 1)
>, <Line: -                        key = coord + "axis"; // support x1axis as xaxis
>, <Line: -                    if (ranges[key]) {
>, <Line: -                        from = ranges[key].from;
>, <Line: -                        to = ranges[key].to;
>, <Line: -                        break;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // backwards-compat stuff - to be removed in future
>, <Line: -            if (!ranges[key]) {
>, <Line: -                axis = coord == "x" ? xaxes[0] : yaxes[0];
>, <Line: -                from = ranges[coord + "1"];
>, <Line: -                to = ranges[coord + "2"];
>, <Line: -            }
>, <Line: -            // auto-reverse as an added bonus
>, <Line: -            if (from != null && to != null && from > to) {
>, <Line: -                var tmp = from;
>, <Line: -                from = to;
>, <Line: -                to = tmp;
>, <Line: -            }
>, <Line: -            return { from: from, to: to, axis: axis };
>, <Line: -        }
>, <Line: -        function drawBackground() {
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
>, <Line: -            ctx.fillRect(0, 0, plotWidth, plotHeight);
>, <Line: -            ctx.restore();
>, <Line: -        }
>, <Line: -        function drawGrid() {
>, <Line: -            var i, axes, bw, bc;
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            // draw markings
>, <Line: -            var markings = options.grid.markings;
>, <Line: -            if (markings) {
>, <Line: -                if ($.isFunction(markings)) {
>, <Line: -                    axes = plot.getAxes();
>, <Line: -                    // xmin etc. is backwards compatibility, to be
>, <Line: -                    // removed in the future
>, <Line: -                    axes.xmin = axes.xaxis.min;
>, <Line: -                    axes.xmax = axes.xaxis.max;
>, <Line: -                    axes.ymin = axes.yaxis.min;
>, <Line: -                    axes.ymax = axes.yaxis.max;
>, <Line: -                    markings = markings(axes);
>, <Line: -                }
>, <Line: -                for (i = 0; i < markings.length; ++i) {
>, <Line: -                    var m = markings[i],
>, <Line: -                        xrange = extractRange(m, "x"),
>, <Line: -                        yrange = extractRange(m, "y");
>, <Line: -                    // fill in missing
>, <Line: -                    if (xrange.from == null)
>, <Line: -                        xrange.from = xrange.axis.min;
>, <Line: -                    if (xrange.to == null)
>, <Line: -                        xrange.to = xrange.axis.max;
>, <Line: -                    if (yrange.from == null)
>, <Line: -                        yrange.from = yrange.axis.min;
>, <Line: -                    if (yrange.to == null)
>, <Line: -                        yrange.to = yrange.axis.max;
>, <Line: -                    // clip
>, <Line: -                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
>, <Line: -                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
>, <Line: -                        continue;
>, <Line: -                    xrange.from = Math.max(xrange.from, xrange.axis.min);
>, <Line: -                    xrange.to = Math.min(xrange.to, xrange.axis.max);
>, <Line: -                    yrange.from = Math.max(yrange.from, yrange.axis.min);
>, <Line: -                    yrange.to = Math.min(yrange.to, yrange.axis.max);
>, <Line: -                    var xequal = xrange.from === xrange.to,
>, <Line: -                        yequal = yrange.from === yrange.to;
>, <Line: -                    if (xequal && yequal) {
>, <Line: -                        continue;
>, <Line: -                    }
>, <Line: -                    // then draw
>, <Line: -                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
>, <Line: -                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
>, <Line: -                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
>, <Line: -                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));
>, <Line: -                    if (xequal || yequal) {
>, <Line: -                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
>, <Line: -                            subPixel = lineWidth % 2 ? 0.5 : 0;
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.strokeStyle = m.color || options.grid.markingsColor;
>, <Line: -                        ctx.lineWidth = lineWidth;
>, <Line: -                        if (xequal) {
>, <Line: -                            ctx.moveTo(xrange.to + subPixel, yrange.from);
>, <Line: -                            ctx.lineTo(xrange.to + subPixel, yrange.to);
>, <Line: -                        } else {
>, <Line: -                            ctx.moveTo(xrange.from, yrange.to + subPixel);
>, <Line: -                            ctx.lineTo(xrange.to, yrange.to + subPixel);
>, <Line: -                        }
>, <Line: -                        ctx.stroke();
>, <Line: -                    } else {
>, <Line: -                        ctx.fillStyle = m.color || options.grid.markingsColor;
>, <Line: -                        ctx.fillRect(xrange.from, yrange.to,
>, <Line: -                                     xrange.to - xrange.from,
>, <Line: -                                     yrange.from - yrange.to);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // draw the ticks
>, <Line: -            axes = allAxes();
>, <Line: -            bw = options.grid.borderWidth;
>, <Line: -            for (var j = 0; j < axes.length; ++j) {
>, <Line: -                var axis = axes[j], box = axis.box,
>, <Line: -                    t = axis.tickLength, x, y, xoff, yoff;
>, <Line: -                if (!axis.show || axis.ticks.length == 0)
>, <Line: -                    continue;
>, <Line: -                ctx.lineWidth = 1;
>, <Line: -                // find the edges
>, <Line: -                if (axis.direction == "x") {
>, <Line: -                    x = 0;
>, <Line: -                    if (t == "full")
>, <Line: -                        y = (axis.position == "top" ? 0 : plotHeight);
>, <Line: -                    else
>, <Line: -                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    y = 0;
>, <Line: -                    if (t == "full")
>, <Line: -                        x = (axis.position == "left" ? 0 : plotWidth);
>, <Line: -                    else
>, <Line: -                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
>, <Line: -                }
>, <Line: -                // draw tick bar
>, <Line: -                if (!axis.innermost) {
>, <Line: -                    ctx.strokeStyle = axis.options.color;
>, <Line: -                    ctx.beginPath();
>, <Line: -                    xoff = yoff = 0;
>, <Line: -                    if (axis.direction == "x")
>, <Line: -                        xoff = plotWidth + 1;
>, <Line: -                    else
>, <Line: -                        yoff = plotHeight + 1;
>, <Line: -                    if (ctx.lineWidth == 1) {
>, <Line: -                        if (axis.direction == "x") {
>, <Line: -                            y = Math.floor(y) + 0.5;
>, <Line: -                        } else {
>, <Line: -                            x = Math.floor(x) + 0.5;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    ctx.moveTo(x, y);
>, <Line: -                    ctx.lineTo(x + xoff, y + yoff);
>, <Line: -                    ctx.stroke();
>, <Line: -                }
>, <Line: -                // draw ticks
>, <Line: -                ctx.strokeStyle = axis.options.tickColor;
>, <Line: -                ctx.beginPath();
>, <Line: -                for (i = 0; i < axis.ticks.length; ++i) {
>, <Line: -                    var v = axis.ticks[i].v;
>, <Line: -                    xoff = yoff = 0;
>, <Line: -                    if (isNaN(v) || v < axis.min || v > axis.max
>, <Line: -                        // skip those lying on the axes if we got a border
>, <Line: -                        || (t == "full"
>, <Line: -                            && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
>, <Line: -                            && (v == axis.min || v == axis.max)))
>, <Line: -                        continue;
>, <Line: -                    if (axis.direction == "x") {
>, <Line: -                        x = axis.p2c(v);
>, <Line: -                        yoff = t == "full" ? -plotHeight : t;
>, <Line: -                        if (axis.position == "top")
>, <Line: -                            yoff = -yoff;
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        y = axis.p2c(v);
>, <Line: -                        xoff = t == "full" ? -plotWidth : t;
>, <Line: -                        if (axis.position == "left")
>, <Line: -                            xoff = -xoff;
>, <Line: -                    }
>, <Line: -                    if (ctx.lineWidth == 1) {
>, <Line: -                        if (axis.direction == "x")
>, <Line: -                            x = Math.floor(x) + 0.5;
>, <Line: -                        else
>, <Line: -                            y = Math.floor(y) + 0.5;
>, <Line: -                    }
>, <Line: -                    ctx.moveTo(x, y);
>, <Line: -                    ctx.lineTo(x + xoff, y + yoff);
>, <Line: -                }
>, <Line: -                ctx.stroke();
>, <Line: -            }
>, <Line: -            // draw border
>, <Line: -            if (bw) {
>, <Line: -                // If either borderWidth or borderColor is an object, then draw the border
>, <Line: -                // line by line instead of as one rectangle
>, <Line: -                bc = options.grid.borderColor;
>, <Line: -                if(typeof bw == "object" || typeof bc == "object") {
>, <Line: -                    if (typeof bw !== "object") {
>, <Line: -                        bw = {top: bw, right: bw, bottom: bw, left: bw};
>, <Line: -                    }
>, <Line: -                    if (typeof bc !== "object") {
>, <Line: -                        bc = {top: bc, right: bc, bottom: bc, left: bc};
>, <Line: -                    }
>, <Line: -                    if (bw.top > 0) {
>, <Line: -                        ctx.strokeStyle = bc.top;
>, <Line: -                        ctx.lineWidth = bw.top;
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);
>, <Line: -                        ctx.lineTo(plotWidth, 0 - bw.top/2);
>, <Line: -                        ctx.stroke();
>, <Line: -                    }
>, <Line: -                    if (bw.right > 0) {
>, <Line: -                        ctx.strokeStyle = bc.right;
>, <Line: -                        ctx.lineWidth = bw.right;
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
>, <Line: -                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
>, <Line: -                        ctx.stroke();
>, <Line: -                    }
>, <Line: -                    if (bw.bottom > 0) {
>, <Line: -                        ctx.strokeStyle = bc.bottom;
>, <Line: -                        ctx.lineWidth = bw.bottom;
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
>, <Line: -                        ctx.lineTo(0, plotHeight + bw.bottom / 2);
>, <Line: -                        ctx.stroke();
>, <Line: -                    }
>, <Line: -                    if (bw.left > 0) {
>, <Line: -                        ctx.strokeStyle = bc.left;
>, <Line: -                        ctx.lineWidth = bw.left;
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
>, <Line: -                        ctx.lineTo(0- bw.left/2, 0);
>, <Line: -                        ctx.stroke();
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    ctx.lineWidth = bw;
>, <Line: -                    ctx.strokeStyle = options.grid.borderColor;
>, <Line: -                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            ctx.restore();
>, <Line: -        }
>, <Line: -        function drawAxisLabels() {
>, <Line: -            $.each(allAxes(), function (_, axis) {
>, <Line: -                var box = axis.box,
>, <Line: -                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
>, <Line: -                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
>, <Line: -                    font = axis.options.font || "flot-tick-label tickLabel",
>, <Line: -                    tick, x, y, halign, valign;
>, <Line: -                // Remove text before checking for axis.show and ticks.length;
>, <Line: -                // otherwise plugins, like flot-tickrotor, that draw their own
>, <Line: -                // tick labels will end up with both theirs and the defaults.
>, <Line: -                surface.removeText(layer);
>, <Line: -                if (!axis.show || axis.ticks.length == 0)
>, <Line: -                    return;
>, <Line: -                for (var i = 0; i < axis.ticks.length; ++i) {
>, <Line: -                    tick = axis.ticks[i];
>, <Line: -                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)
>, <Line: -                        continue;
>, <Line: -                    if (axis.direction == "x") {
>, <Line: -                        halign = "center";
>, <Line: -                        x = plotOffset.left + axis.p2c(tick.v);
>, <Line: -                        if (axis.position == "bottom") {
>, <Line: -                            y = box.top + box.padding;
>, <Line: -                        } else {
>, <Line: -                            y = box.top + box.height - box.padding;
>, <Line: -                            valign = "bottom";
>, <Line: -                        }
>, <Line: -                    } else {
>, <Line: -                        valign = "middle";
>, <Line: -                        y = plotOffset.top + axis.p2c(tick.v);
>, <Line: -                        if (axis.position == "left") {
>, <Line: -                            x = box.left + box.width - box.padding;
>, <Line: -                            halign = "right";
>, <Line: -                        } else {
>, <Line: -                            x = box.left + box.padding;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
>, <Line: -                }
>, <Line: -            });
>, <Line: -        }
>, <Line: -        function drawSeries(series) {
>, <Line: -            if (series.lines.show)
>, <Line: -                drawSeriesLines(series);
>, <Line: -            if (series.bars.show)
>, <Line: -                drawSeriesBars(series);
>, <Line: -            if (series.points.show)
>, <Line: -                drawSeriesPoints(series);
>, <Line: -        }
>, <Line: -        function drawSeriesLines(series) {
>, <Line: -            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
>, <Line: -                var points = datapoints.points,
>, <Line: -                    ps = datapoints.pointsize,
>, <Line: -                    prevx = null, prevy = null;
>, <Line: -                ctx.beginPath();
>, <Line: -                for (var i = ps; i < points.length; i += ps) {
>, <Line: -                    var x1 = points[i - ps], y1 = points[i - ps + 1],
>, <Line: -                        x2 = points[i], y2 = points[i + 1];
>, <Line: -                    if (x1 == null || x2 == null)
>, <Line: -                        continue;
>, <Line: -                    // clip with ymin
>, <Line: -                    if (y1 <= y2 && y1 < axisy.min) {
>, <Line: -                        if (y2 < axisy.min)
>, <Line: -                            continue;   // line segment is outside
>, <Line: -                        // compute new intersection point
>, <Line: -                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y1 = axisy.min;
>, <Line: -                    }
>, <Line: -                    else if (y2 <= y1 && y2 < axisy.min) {
>, <Line: -                        if (y1 < axisy.min)
>, <Line: -                            continue;
>, <Line: -                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y2 = axisy.min;
>, <Line: -                    }
>, <Line: -                    // clip with ymax
>, <Line: -                    if (y1 >= y2 && y1 > axisy.max) {
>, <Line: -                        if (y2 > axisy.max)
>, <Line: -                            continue;
>, <Line: -                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y1 = axisy.max;
>, <Line: -                    }
>, <Line: -                    else if (y2 >= y1 && y2 > axisy.max) {
>, <Line: -                        if (y1 > axisy.max)
>, <Line: -                            continue;
>, <Line: -                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y2 = axisy.max;
>, <Line: -                    }
>, <Line: -                    // clip with xmin
>, <Line: -                    if (x1 <= x2 && x1 < axisx.min) {
>, <Line: -                        if (x2 < axisx.min)
>, <Line: -                            continue;
>, <Line: -                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x1 = axisx.min;
>, <Line: -                    }
>, <Line: -                    else if (x2 <= x1 && x2 < axisx.min) {
>, <Line: -                        if (x1 < axisx.min)
>, <Line: -                            continue;
>, <Line: -                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x2 = axisx.min;
>, <Line: -                    }
>, <Line: -                    // clip with xmax
>, <Line: -                    if (x1 >= x2 && x1 > axisx.max) {
>, <Line: -                        if (x2 > axisx.max)
>, <Line: -                            continue;
>, <Line: -                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x1 = axisx.max;
>, <Line: -                    }
>, <Line: -                    else if (x2 >= x1 && x2 > axisx.max) {
>, <Line: -                        if (x1 > axisx.max)
>, <Line: -                            continue;
>, <Line: -                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x2 = axisx.max;
>, <Line: -                    }
>, <Line: -                    if (x1 != prevx || y1 != prevy)
>, <Line: -                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
>, <Line: -                    prevx = x2;
>, <Line: -                    prevy = y2;
>, <Line: -                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
>, <Line: -                }
>, <Line: -                ctx.stroke();
>, <Line: -            }
>, <Line: -            function plotLineArea(datapoints, axisx, axisy) {
>, <Line: -                var points = datapoints.points,
>, <Line: -                    ps = datapoints.pointsize,
>, <Line: -                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),
>, <Line: -                    i = 0, top, areaOpen = false,
>, <Line: -                    ypos = 1, segmentStart = 0, segmentEnd = 0;
>, <Line: -                // we process each segment in two turns, first forward
>, <Line: -                // direction to sketch out top, then once we hit the
>, <Line: -                // end we go backwards to sketch the bottom
>, <Line: -                while (true) {
>, <Line: -                    if (ps > 0 && i > points.length + ps)
>, <Line: -                        break;
>, <Line: -                    i += ps; // ps is negative if going backwards
>, <Line: -                    var x1 = points[i - ps],
>, <Line: -                        y1 = points[i - ps + ypos],
>, <Line: -                        x2 = points[i], y2 = points[i + ypos];
>, <Line: -                    if (areaOpen) {
>, <Line: -                        if (ps > 0 && x1 != null && x2 == null) {
>, <Line: -                            // at turning point
>, <Line: -                            segmentEnd = i;
>, <Line: -                            ps = -ps;
>, <Line: -                            ypos = 2;
>, <Line: -                            continue;
>, <Line: -                        }
>, <Line: -                        if (ps < 0 && i == segmentStart + ps) {
>, <Line: -                            // done with the reverse sweep
>, <Line: -                            ctx.fill();
>, <Line: -                            areaOpen = false;
>, <Line: -                            ps = -ps;
>, <Line: -                            ypos = 1;
>, <Line: -                            i = segmentStart = segmentEnd + ps;
>, <Line: -                            continue;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    if (x1 == null || x2 == null)
>, <Line: -                        continue;
>, <Line: -                    // clip x values
>, <Line: -                    // clip with xmin
>, <Line: -                    if (x1 <= x2 && x1 < axisx.min) {
>, <Line: -                        if (x2 < axisx.min)
>, <Line: -                            continue;
>, <Line: -                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x1 = axisx.min;
>, <Line: -                    }
>, <Line: -                    else if (x2 <= x1 && x2 < axisx.min) {
>, <Line: -                        if (x1 < axisx.min)
>, <Line: -                            continue;
>, <Line: -                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x2 = axisx.min;
>, <Line: -                    }
>, <Line: -                    // clip with xmax
>, <Line: -                    if (x1 >= x2 && x1 > axisx.max) {
>, <Line: -                        if (x2 > axisx.max)
>, <Line: -                            continue;
>, <Line: -                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x1 = axisx.max;
>, <Line: -                    }
>, <Line: -                    else if (x2 >= x1 && x2 > axisx.max) {
>, <Line: -                        if (x1 > axisx.max)
>, <Line: -                            continue;
>, <Line: -                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
>, <Line: -                        x2 = axisx.max;
>, <Line: -                    }
>, <Line: -                    if (!areaOpen) {
>, <Line: -                        // open area
>, <Line: -                        ctx.beginPath();
>, <Line: -                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
>, <Line: -                        areaOpen = true;
>, <Line: -                    }
>, <Line: -                    // now first check the case where both is outside
>, <Line: -                    if (y1 >= axisy.max && y2 >= axisy.max) {
>, <Line: -                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
>, <Line: -                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
>, <Line: -                        continue;
>, <Line: -                    }
>, <Line: -                    else if (y1 <= axisy.min && y2 <= axisy.min) {
>, <Line: -                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
>, <Line: -                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
>, <Line: -                        continue;
>, <Line: -                    }
>, <Line: -                    // else it's a bit more complicated, there might
>, <Line: -                    // be a flat maxed out rectangle first, then a
>, <Line: -                    // triangular cutout or reverse; to find these
>, <Line: -                    // keep track of the current x values
>, <Line: -                    var x1old = x1, x2old = x2;
>, <Line: -                    // clip the y values, without shortcutting, we
>, <Line: -                    // go through all cases in turn
>, <Line: -                    // clip with ymin
>, <Line: -                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
>, <Line: -                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y1 = axisy.min;
>, <Line: -                    }
>, <Line: -                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
>, <Line: -                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y2 = axisy.min;
>, <Line: -                    }
>, <Line: -                    // clip with ymax
>, <Line: -                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
>, <Line: -                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y1 = axisy.max;
>, <Line: -                    }
>, <Line: -                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
>, <Line: -                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
>, <Line: -                        y2 = axisy.max;
>, <Line: -                    }
>, <Line: -                    // if the x value was changed we got a rectangle
>, <Line: -                    // to fill
>, <Line: -                    if (x1 != x1old) {
>, <Line: -                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
>, <Line: -                        // it goes to (x1, y1), but we fill that below
>, <Line: -                    }
>, <Line: -                    // fill triangular section, this sometimes result
>, <Line: -                    // in redundant points if (x1, y1) hasn't changed
>, <Line: -                    // from previous line to, but we just ignore that
>, <Line: -                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
>, <Line: -                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
>, <Line: -                    // fill the other rectangle if it's there
>, <Line: -                    if (x2 != x2old) {
>, <Line: -                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
>, <Line: -                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            ctx.lineJoin = "round";
>, <Line: -            var lw = series.lines.lineWidth,
>, <Line: -                sw = series.shadowSize;
>, <Line: -            // FIXME: consider another form of shadow when filling is turned on
>, <Line: -            if (lw > 0 && sw > 0) {
>, <Line: -                // draw shadow as a thick and thin line with transparency
>, <Line: -                ctx.lineWidth = sw;
>, <Line: -                ctx.strokeStyle = "rgba(0,0,0,0.1)";
>, <Line: -                // position shadow at angle from the mid of line
>, <Line: -                var angle = Math.PI/18;
>, <Line: -                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
>, <Line: -                ctx.lineWidth = sw/2;
>, <Line: -                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
>, <Line: -            }
>, <Line: -            ctx.lineWidth = lw;
>, <Line: -            ctx.strokeStyle = series.color;
>, <Line: -            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
>, <Line: -            if (fillStyle) {
>, <Line: -                ctx.fillStyle = fillStyle;
>, <Line: -                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
>, <Line: -            }
>, <Line: -            if (lw > 0)
>, <Line: -                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
>, <Line: -            ctx.restore();
>, <Line: -        }
>, <Line: -        function drawSeriesPoints(series) {
>, <Line: -            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
>, <Line: -                var points = datapoints.points, ps = datapoints.pointsize;
>, <Line: -                for (var i = 0; i < points.length; i += ps) {
>, <Line: -                    var x = points[i], y = points[i + 1];
>, <Line: -                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
>, <Line: -                        continue;
>, <Line: -                    ctx.beginPath();
>, <Line: -                    x = axisx.p2c(x);
>, <Line: -                    y = axisy.p2c(y) + offset;
>, <Line: -                    if (symbol == "circle")
>, <Line: -                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
>, <Line: -                    else
>, <Line: -                        symbol(ctx, x, y, radius, shadow);
>, <Line: -                    ctx.closePath();
>, <Line: -                    if (fillStyle) {
>, <Line: -                        ctx.fillStyle = fillStyle;
>, <Line: -                        ctx.fill();
>, <Line: -                    }
>, <Line: -                    ctx.stroke();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            var lw = series.points.lineWidth,
>, <Line: -                sw = series.shadowSize,
>, <Line: -                radius = series.points.radius,
>, <Line: -                symbol = series.points.symbol;
>, <Line: -            // If the user sets the line width to 0, we change it to a very
>, <Line: -            // small value. A line width of 0 seems to force the default of 1.
>, <Line: -            // Doing the conditional here allows the shadow setting to still be
>, <Line: -            // optional even with a lineWidth of 0.
>, <Line: -            if( lw == 0 )
>, <Line: -                lw = 0.0001;
>, <Line: -            if (lw > 0 && sw > 0) {
>, <Line: -                // draw shadow in two steps
>, <Line: -                var w = sw / 2;
>, <Line: -                ctx.lineWidth = w;
>, <Line: -                ctx.strokeStyle = "rgba(0,0,0,0.1)";
>, <Line: -                plotPoints(series.datapoints, radius, null, w + w/2, true,
>, <Line: -                           series.xaxis, series.yaxis, symbol);
>, <Line: -                ctx.strokeStyle = "rgba(0,0,0,0.2)";
>, <Line: -                plotPoints(series.datapoints, radius, null, w/2, true,
>, <Line: -                           series.xaxis, series.yaxis, symbol);
>, <Line: -            }
>, <Line: -            ctx.lineWidth = lw;
>, <Line: -            ctx.strokeStyle = series.color;
>, <Line: -            plotPoints(series.datapoints, radius,
>, <Line: -                       getFillStyle(series.points, series.color), 0, false,
>, <Line: -                       series.xaxis, series.yaxis, symbol);
>, <Line: -            ctx.restore();
>, <Line: -        }
>, <Line: -        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
>, <Line: -            var left, right, bottom, top,
>, <Line: -                drawLeft, drawRight, drawTop, drawBottom,
>, <Line: -                tmp;
>, <Line: -            // in horizontal mode, we start the bar from the left
>, <Line: -            // instead of from the bottom so it appears to be
>, <Line: -            // horizontal rather than vertical
>, <Line: -            if (horizontal) {
>, <Line: -                drawBottom = drawRight = drawTop = true;
>, <Line: -                drawLeft = false;
>, <Line: -                left = b;
>, <Line: -                right = x;
>, <Line: -                top = y + barLeft;
>, <Line: -                bottom = y + barRight;
>, <Line: -                // account for negative bars
>, <Line: -                if (right < left) {
>, <Line: -                    tmp = right;
>, <Line: -                    right = left;
>, <Line: -                    left = tmp;
>, <Line: -                    drawLeft = true;
>, <Line: -                    drawRight = false;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                drawLeft = drawRight = drawTop = true;
>, <Line: -                drawBottom = false;
>, <Line: -                left = x + barLeft;
>, <Line: -                right = x + barRight;
>, <Line: -                bottom = b;
>, <Line: -                top = y;
>, <Line: -                // account for negative bars
>, <Line: -                if (top < bottom) {
>, <Line: -                    tmp = top;
>, <Line: -                    top = bottom;
>, <Line: -                    bottom = tmp;
>, <Line: -                    drawBottom = true;
>, <Line: -                    drawTop = false;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // clip
>, <Line: -            if (right < axisx.min || left > axisx.max ||
>, <Line: -                top < axisy.min || bottom > axisy.max)
>, <Line: -                return;
>, <Line: -            if (left < axisx.min) {
>, <Line: -                left = axisx.min;
>, <Line: -                drawLeft = false;
>, <Line: -            }
>, <Line: -            if (right > axisx.max) {
>, <Line: -                right = axisx.max;
>, <Line: -                drawRight = false;
>, <Line: -            }
>, <Line: -            if (bottom < axisy.min) {
>, <Line: -                bottom = axisy.min;
>, <Line: -                drawBottom = false;
>, <Line: -            }
>, <Line: -            if (top > axisy.max) {
>, <Line: -                top = axisy.max;
>, <Line: -                drawTop = false;
>, <Line: -            }
>, <Line: -            left = axisx.p2c(left);
>, <Line: -            bottom = axisy.p2c(bottom);
>, <Line: -            right = axisx.p2c(right);
>, <Line: -            top = axisy.p2c(top);
>, <Line: -            // fill the bar
>, <Line: -            if (fillStyleCallback) {
>, <Line: -                c.fillStyle = fillStyleCallback(bottom, top);
>, <Line: -                c.fillRect(left, top, right - left, bottom - top)
>, <Line: -            }
>, <Line: -            // draw outline
>, <Line: -            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
>, <Line: -                c.beginPath();
>, <Line: -                // FIXME: inline moveTo is buggy with excanvas
>, <Line: -                c.moveTo(left, bottom);
>, <Line: -                if (drawLeft)
>, <Line: -                    c.lineTo(left, top);
>, <Line: -                else
>, <Line: -                    c.moveTo(left, top);
>, <Line: -                if (drawTop)
>, <Line: -                    c.lineTo(right, top);
>, <Line: -                else
>, <Line: -                    c.moveTo(right, top);
>, <Line: -                if (drawRight)
>, <Line: -                    c.lineTo(right, bottom);
>, <Line: -                else
>, <Line: -                    c.moveTo(right, bottom);
>, <Line: -                if (drawBottom)
>, <Line: -                    c.lineTo(left, bottom);
>, <Line: -                else
>, <Line: -                    c.moveTo(left, bottom);
>, <Line: -                c.stroke();
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function drawSeriesBars(series) {
>, <Line: -            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
>, <Line: -                var points = datapoints.points, ps = datapoints.pointsize;
>, <Line: -                for (var i = 0; i < points.length; i += ps) {
>, <Line: -                    if (points[i] == null)
>, <Line: -                        continue;
>, <Line: -                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            // FIXME: figure out a way to add shadows (for instance along the right edge)
>, <Line: -            ctx.lineWidth = series.bars.lineWidth;
>, <Line: -            ctx.strokeStyle = series.color;
>, <Line: -            var barLeft;
>, <Line: -            switch (series.bars.align) {
>, <Line: -                case "left":
>, <Line: -                    barLeft = 0;
>, <Line: -                    break;
>, <Line: -                case "right":
>, <Line: -                    barLeft = -series.bars.barWidth;
>, <Line: -                    break;
>, <Line: -                default:
>, <Line: -                    barLeft = -series.bars.barWidth / 2;
>, <Line: -            }
>, <Line: -            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
>, <Line: -            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
>, <Line: -            ctx.restore();
>, <Line: -        }
>, <Line: -        function getFillStyle(filloptions, seriesColor, bottom, top) {
>, <Line: -            var fill = filloptions.fill;
>, <Line: -            if (!fill)
>, <Line: -                return null;
>, <Line: -            if (filloptions.fillColor)
>, <Line: -                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
>, <Line: -            var c = $.color.parse(seriesColor);
>, <Line: -            c.a = typeof fill == "number" ? fill : 0.4;
>, <Line: -            c.normalize();
>, <Line: -            return c.toString();
>, <Line: -        }
>, <Line: -        function insertLegend() {
>, <Line: -            if (options.legend.container != null) {
>, <Line: -                $(options.legend.container).html("");
>, <Line: -            } else {
>, <Line: -                placeholder.find(".legend").remove();
>, <Line: -            }
>, <Line: -            if (!options.legend.show) {
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            var fragments = [], entries = [], rowStarted = false,
>, <Line: -                lf = options.legend.labelFormatter, s, label;
>, <Line: -            // Build a list of legend entries, with each having a label and a color
>, <Line: -            for (var i = 0; i < series.length; ++i) {
>, <Line: -                s = series[i];
>, <Line: -                if (s.label) {
>, <Line: -                    label = lf ? lf(s.label, s) : s.label;
>, <Line: -                    if (label) {
>, <Line: -                        entries.push({
>, <Line: -                            label: label,
>, <Line: -                            color: s.color
>, <Line: -                        });
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // Sort the legend using either the default or a custom comparator
>, <Line: -            if (options.legend.sorted) {
>, <Line: -                if ($.isFunction(options.legend.sorted)) {
>, <Line: -                    entries.sort(options.legend.sorted);
>, <Line: -                } else if (options.legend.sorted == "reverse") {
>, <Line: -                	entries.reverse();
>, <Line: -                } else {
>, <Line: -                    var ascending = options.legend.sorted != "descending";
>, <Line: -                    entries.sort(function(a, b) {
>, <Line: -                        return a.label == b.label ? 0 : (
>, <Line: -                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
>, <Line: -                        );
>, <Line: -                    });
>, <Line: -                }
>, <Line: -            }
>, <Line: -            // Generate markup for the list of entries, in their final order
>, <Line: -            for (var i = 0; i < entries.length; ++i) {
>, <Line: -                var entry = entries[i];
>, <Line: -                if (i % options.legend.noColumns == 0) {
>, <Line: -                    if (rowStarted)
>, <Line: -                        fragments.push('</tr>');
>, <Line: -                    fragments.push('<tr>');
>, <Line: -                    rowStarted = true;
>, <Line: -                }
>, <Line: -                fragments.push(
>, <Line: -                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
>, <Line: -                    '<td class="legendLabel">' + entry.label + '</td>'
>, <Line: -                );
>, <Line: -            }
>, <Line: -            if (rowStarted)
>, <Line: -                fragments.push('</tr>');
>, <Line: -            if (fragments.length == 0)
>, <Line: -                return;
>, <Line: -            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
>, <Line: -            if (options.legend.container != null)
>, <Line: -                $(options.legend.container).html(table);
>, <Line: -            else {
>, <Line: -                var pos = "",
>, <Line: -                    p = options.legend.position,
>, <Line: -                    m = options.legend.margin;
>, <Line: -                if (m[0] == null)
>, <Line: -                    m = [m, m];
>, <Line: -                if (p.charAt(0) == "n")
>, <Line: -                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
>, <Line: -                else if (p.charAt(0) == "s")
>, <Line: -                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
>, <Line: -                if (p.charAt(1) == "e")
>, <Line: -                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
>, <Line: -                else if (p.charAt(1) == "w")
>, <Line: -                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
>, <Line: -                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);
>, <Line: -                if (options.legend.backgroundOpacity != 0.0) {
>, <Line: -                    // put in the transparent background
>, <Line: -                    // separately to avoid blended labels and
>, <Line: -                    // label boxes
>, <Line: -                    var c = options.legend.backgroundColor;
>, <Line: -                    if (c == null) {
>, <Line: -                        c = options.grid.backgroundColor;
>, <Line: -                        if (c && typeof c == "string")
>, <Line: -                            c = $.color.parse(c);
>, <Line: -                        else
>, <Line: -                            c = $.color.extract(legend, 'background-color');
>, <Line: -                        c.a = 1;
>, <Line: -                        c = c.toString();
>, <Line: -                    }
>, <Line: -                    var div = legend.children();
>, <Line: -                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        // interactive features
>, <Line: -        var highlights = [],
>, <Line: -            redrawTimeout = null;
>, <Line: -        // returns the data item the mouse is over, or null if none is found
>, <Line: -        function findNearbyItem(mouseX, mouseY, seriesFilter) {
>, <Line: -            var maxDistance = options.grid.mouseActiveRadius,
>, <Line: -                smallestDistance = maxDistance * maxDistance + 1,
>, <Line: -                item = null, foundPoint = false, i, j, ps;
>, <Line: -            for (i = series.length - 1; i >= 0; --i) {
>, <Line: -                if (!seriesFilter(series[i]))
>, <Line: -                    continue;
>, <Line: -                var s = series[i],
>, <Line: -                    axisx = s.xaxis,
>, <Line: -                    axisy = s.yaxis,
>, <Line: -                    points = s.datapoints.points,
>, <Line: -                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
>, <Line: -                    my = axisy.c2p(mouseY),
>, <Line: -                    maxx = maxDistance / axisx.scale,
>, <Line: -                    maxy = maxDistance / axisy.scale;
>, <Line: -                ps = s.datapoints.pointsize;
>, <Line: -                // with inverse transforms, we can't use the maxx/maxy
>, <Line: -                // optimization, sadly
>, <Line: -                if (axisx.options.inverseTransform)
>, <Line: -                    maxx = Number.MAX_VALUE;
>, <Line: -                if (axisy.options.inverseTransform)
>, <Line: -                    maxy = Number.MAX_VALUE;
>, <Line: -                if (s.lines.show || s.points.show) {
>, <Line: -                    for (j = 0; j < points.length; j += ps) {
>, <Line: -                        var x = points[j], y = points[j + 1];
>, <Line: -                        if (x == null)
>, <Line: -                            continue;
>, <Line: -                        // For points and lines, the cursor must be within a
>, <Line: -                        // certain distance to the data point
>, <Line: -                        if (x - mx > maxx || x - mx < -maxx ||
>, <Line: -                            y - my > maxy || y - my < -maxy)
>, <Line: -                            continue;
>, <Line: -                        // We have to calculate distances in pixels, not in
>, <Line: -                        // data units, because the scales of the axes may be different
>, <Line: -                        var dx = Math.abs(axisx.p2c(x) - mouseX),
>, <Line: -                            dy = Math.abs(axisy.p2c(y) - mouseY),
>, <Line: -                            dist = dx * dx + dy * dy; // we save the sqrt
>, <Line: -                        // use <= to ensure last point takes precedence
>, <Line: -                        // (last generally means on top of)
>, <Line: -                        if (dist < smallestDistance) {
>, <Line: -                            smallestDistance = dist;
>, <Line: -                            item = [i, j / ps];
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                if (s.bars.show && !item) { // no other point can be nearby
>, <Line: -                    var barLeft, barRight;
>, <Line: -                    switch (s.bars.align) {
>, <Line: -                        case "left":
>, <Line: -                            barLeft = 0;
>, <Line: -                            break;
>, <Line: -                        case "right":
>, <Line: -                            barLeft = -s.bars.barWidth;
>, <Line: -                            break;
>, <Line: -                        default:
>, <Line: -                            barLeft = -s.bars.barWidth / 2;
>, <Line: -                    }
>, <Line: -                    barRight = barLeft + s.bars.barWidth;
>, <Line: -                    for (j = 0; j < points.length; j += ps) {
>, <Line: -                        var x = points[j], y = points[j + 1], b = points[j + 2];
>, <Line: -                        if (x == null)
>, <Line: -                            continue;
>, <Line: -                        // for a bar graph, the cursor must be inside the bar
>, <Line: -                        if (series[i].bars.horizontal ?
>, <Line: -                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
>, <Line: -                             my >= y + barLeft && my <= y + barRight) :
>, <Line: -                            (mx >= x + barLeft && mx <= x + barRight &&
>, <Line: -                             my >= Math.min(b, y) && my <= Math.max(b, y)))
>, <Line: -                                item = [i, j / ps];
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            if (item) {
>, <Line: -                i = item[0];
>, <Line: -                j = item[1];
>, <Line: -                ps = series[i].datapoints.pointsize;
>, <Line: -                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
>, <Line: -                         dataIndex: j,
>, <Line: -                         series: series[i],
>, <Line: -                         seriesIndex: i };
>, <Line: -            }
>, <Line: -            return null;
>, <Line: -        }
>, <Line: -        function onMouseMove(e) {
>, <Line: -            if (options.grid.hoverable)
>, <Line: -                triggerClickHoverEvent("plothover", e,
>, <Line: -                                       function (s) { return s["hoverable"] != false; });
>, <Line: -        }
>, <Line: -        function onMouseLeave(e) {
>, <Line: -            if (options.grid.hoverable)
>, <Line: -                triggerClickHoverEvent("plothover", e,
>, <Line: -                                       function (s) { return false; });
>, <Line: -        }
>, <Line: -        function onClick(e) {
>, <Line: -            triggerClickHoverEvent("plotclick", e,
>, <Line: -                                   function (s) { return s["clickable"] != false; });
>, <Line: -        }
>, <Line: -        // trigger click or hover event (they send the same parameters
>, <Line: -        // so we share their code)
>, <Line: -        function triggerClickHoverEvent(eventname, event, seriesFilter) {
>, <Line: -            var offset = eventHolder.offset(),
>, <Line: -                canvasX = event.pageX - offset.left - plotOffset.left,
>, <Line: -                canvasY = event.pageY - offset.top - plotOffset.top,
>, <Line: -            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });
>, <Line: -            pos.pageX = event.pageX;
>, <Line: -            pos.pageY = event.pageY;
>, <Line: -            var item = findNearbyItem(canvasX, canvasY, seriesFilter);
>, <Line: -            if (item) {
>, <Line: -                // fill in mouse pos for any listeners out there
>, <Line: -                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
>, <Line: -                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
>, <Line: -            }
>, <Line: -            if (options.grid.autoHighlight) {
>, <Line: -                // clear auto-highlights
>, <Line: -                for (var i = 0; i < highlights.length; ++i) {
>, <Line: -                    var h = highlights[i];
>, <Line: -                    if (h.auto == eventname &&
>, <Line: -                        !(item && h.series == item.series &&
>, <Line: -                          h.point[0] == item.datapoint[0] &&
>, <Line: -                          h.point[1] == item.datapoint[1]))
>, <Line: -                        unhighlight(h.series, h.point);
>, <Line: -                }
>, <Line: -                if (item)
>, <Line: -                    highlight(item.series, item.datapoint, eventname);
>, <Line: -            }
>, <Line: -            placeholder.trigger(eventname, [ pos, item ]);
>, <Line: -        }
>, <Line: -        function triggerRedrawOverlay() {
>, <Line: -            var t = options.interaction.redrawOverlayInterval;
>, <Line: -            if (t == -1) {      // skip event queue
>, <Line: -                drawOverlay();
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            if (!redrawTimeout)
>, <Line: -                redrawTimeout = setTimeout(drawOverlay, t);
>, <Line: -        }
>, <Line: -        function drawOverlay() {
>, <Line: -            redrawTimeout = null;
>, <Line: -            // draw highlights
>, <Line: -            octx.save();
>, <Line: -            overlay.clear();
>, <Line: -            octx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            var i, hi;
>, <Line: -            for (i = 0; i < highlights.length; ++i) {
>, <Line: -                hi = highlights[i];
>, <Line: -                if (hi.series.bars.show)
>, <Line: -                    drawBarHighlight(hi.series, hi.point);
>, <Line: -                else
>, <Line: -                    drawPointHighlight(hi.series, hi.point);
>, <Line: -            }
>, <Line: -            octx.restore();
>, <Line: -            executeHooks(hooks.drawOverlay, [octx]);
>, <Line: -        }
>, <Line: -        function highlight(s, point, auto) {
>, <Line: -            if (typeof s == "number")
>, <Line: -                s = series[s];
>, <Line: -            if (typeof point == "number") {
>, <Line: -                var ps = s.datapoints.pointsize;
>, <Line: -                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
>, <Line: -            }
>, <Line: -            var i = indexOfHighlight(s, point);
>, <Line: -            if (i == -1) {
>, <Line: -                highlights.push({ series: s, point: point, auto: auto });
>, <Line: -                triggerRedrawOverlay();
>, <Line: -            }
>, <Line: -            else if (!auto)
>, <Line: -                highlights[i].auto = false;
>, <Line: -        }
>, <Line: -        function unhighlight(s, point) {
>, <Line: -            if (s == null && point == null) {
>, <Line: -                highlights = [];
>, <Line: -                triggerRedrawOverlay();
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            if (typeof s == "number")
>, <Line: -                s = series[s];
>, <Line: -            if (typeof point == "number") {
>, <Line: -                var ps = s.datapoints.pointsize;
>, <Line: -                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
>, <Line: -            }
>, <Line: -            var i = indexOfHighlight(s, point);
>, <Line: -            if (i != -1) {
>, <Line: -                highlights.splice(i, 1);
>, <Line: -                triggerRedrawOverlay();
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function indexOfHighlight(s, p) {
>, <Line: -            for (var i = 0; i < highlights.length; ++i) {
>, <Line: -                var h = highlights[i];
>, <Line: -                if (h.series == s && h.point[0] == p[0]
>, <Line: -                    && h.point[1] == p[1])
>, <Line: -                    return i;
>, <Line: -            }
>, <Line: -            return -1;
>, <Line: -        }
>, <Line: -        function drawPointHighlight(series, point) {
>, <Line: -            var x = point[0], y = point[1],
>, <Line: -                axisx = series.xaxis, axisy = series.yaxis,
>, <Line: -                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();
>, <Line: -            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
>, <Line: -                return;
>, <Line: -            var pointRadius = series.points.radius + series.points.lineWidth / 2;
>, <Line: -            octx.lineWidth = pointRadius;
>, <Line: -            octx.strokeStyle = highlightColor;
>, <Line: -            var radius = 1.5 * pointRadius;
>, <Line: -            x = axisx.p2c(x);
>, <Line: -            y = axisy.p2c(y);
>, <Line: -            octx.beginPath();
>, <Line: -            if (series.points.symbol == "circle")
>, <Line: -                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
>, <Line: -            else
>, <Line: -                series.points.symbol(octx, x, y, radius, false);
>, <Line: -            octx.closePath();
>, <Line: -            octx.stroke();
>, <Line: -        }
>, <Line: -        function drawBarHighlight(series, point) {
>, <Line: -            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
>, <Line: -                fillStyle = highlightColor,
>, <Line: -                barLeft;
>, <Line: -            switch (series.bars.align) {
>, <Line: -                case "left":
>, <Line: -                    barLeft = 0;
>, <Line: -                    break;
>, <Line: -                case "right":
>, <Line: -                    barLeft = -series.bars.barWidth;
>, <Line: -                    break;
>, <Line: -                default:
>, <Line: -                    barLeft = -series.bars.barWidth / 2;
>, <Line: -            }
>, <Line: -            octx.lineWidth = series.bars.lineWidth;
>, <Line: -            octx.strokeStyle = highlightColor;
>, <Line: -            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
>, <Line: -                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
>, <Line: -        }
>, <Line: -        function getColorOrGradient(spec, bottom, top, defaultColor) {
>, <Line: -            if (typeof spec == "string")
>, <Line: -                return spec;
>, <Line: -            else {
>, <Line: -                // assume this is a gradient spec; IE currently only
>, <Line: -                // supports a simple vertical gradient properly, so that's
>, <Line: -                // what we support too
>, <Line: -                var gradient = ctx.createLinearGradient(0, top, 0, bottom);
>, <Line: -                for (var i = 0, l = spec.colors.length; i < l; ++i) {
>, <Line: -                    var c = spec.colors[i];
>, <Line: -                    if (typeof c != "string") {
>, <Line: -                        var co = $.color.parse(defaultColor);
>, <Line: -                        if (c.brightness != null)
>, <Line: -                            co = co.scale('rgb', c.brightness);
>, <Line: -                        if (c.opacity != null)
>, <Line: -                            co.a *= c.opacity;
>, <Line: -                        c = co.toString();
>, <Line: -                    }
>, <Line: -                    gradient.addColorStop(i / (l - 1), c);
>, <Line: -                }
>, <Line: -                return gradient;
>, <Line: -            }
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // Add the plot function to the top level of the jQuery object
>, <Line: -    $.plot = function(placeholder, data, options) {
>, <Line: -        //var t0 = new Date();
>, <Line: -        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
>, <Line: -        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
>, <Line: -        return plot;
>, <Line: -    };
>, <Line: -    $.plot.version = "0.8.3";
>, <Line: -    $.plot.plugins = [];
>, <Line: -    // Also add the plot function as a chainable property
>, <Line: -    $.fn.plot = function(data, options) {
>, <Line: -        return this.each(function() {
>, <Line: -            $.plot(this, data, options);
>, <Line: -        });
>, <Line: -    };
>, <Line: -    // round to nearby lower multiple of base
>, <Line: -    function floorInBase(n, base) {
>, <Line: -        return base * Math.floor(n / base);
>, <Line: -    }
>]