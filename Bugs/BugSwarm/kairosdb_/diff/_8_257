[<Line: +		'angular',
>, <Line: +		'lodash',
>, <Line: +		'jquery',
>, <Line: +		'config',
>, <Line: +		'kbn',
>, <Line: +		'moment'
>, <Line: +	],
>, <Line: +	function (angular, _, $, config, kbn, moment) {
>, <Line: +		'use strict';
>, <Line: +		var module = angular.module('grafana.services');
>, <Line: +		module.factory('GraphiteDatasource', function ($q, $http, templateSrv) {
>, <Line: +			function GraphiteDatasource(datasource) {
>, <Line: +				this.type = 'graphite';
>, <Line: +				this.basicAuth = datasource.basicAuth;
>, <Line: +				this.url = datasource.url;
>, <Line: +				this.editorSrc = 'app/partials/graphite/editor.html';
>, <Line: +				this.name = datasource.name;
>, <Line: +				this.render_method = datasource.render_method || 'POST';
>, <Line: +				this.supportAnnotations = true;
>, <Line: +				this.supportMetrics = true;
>, <Line: +				this.annotationEditorSrc = 'app/partials/graphite/annotation_editor.html';
>, <Line: +				this.cacheTimeout = datasource.cacheTimeout;
>, <Line: +				this.withCredentials = datasource.withCredentials;
>, <Line: +			}
>, <Line: +			GraphiteDatasource.prototype.query = function (options) {
>, <Line: +				try {
>, <Line: +					var graphOptions = {
>, <Line: +						from: this.translateTime(options.range.from, 'round-down'),
>, <Line: +						until: this.translateTime(options.range.to, 'round-up'),
>, <Line: +						targets: options.targets,
>, <Line: +						format: options.format,
>, <Line: +						cacheTimeout: options.cacheTimeout || this.cacheTimeout,
>, <Line: +						maxDataPoints: options.maxDataPoints,
>, <Line: +					};
>, <Line: +					var params = this.buildGraphiteParams(graphOptions);
>, <Line: +					if (options.format === 'png') {
>, <Line: +						return $q.when(this.url + '/render' + '?' + params.join('&'));
>, <Line: +					}
>, <Line: +					var httpOptions = {
>, <Line: +						method: this.render_method,
>, <Line: +						url: '/render'
>, <Line: +					};
>, <Line: +					if (httpOptions.method === 'GET') {
>, <Line: +						httpOptions.url = httpOptions.url + '?' + params.join('&');
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						httpOptions.data = params.join('&');
>, <Line: +						httpOptions.headers = {'Content-Type': 'application/x-www-form-urlencoded'};
>, <Line: +					}
>, <Line: +					return this.doGraphiteRequest(httpOptions).then(this.convertDataPointsToMs);
>, <Line: +				}
>, <Line: +				catch (err) {
>, <Line: +					return $q.reject(err);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.convertDataPointsToMs = function (result) {
>, <Line: +				if (!result || !result.data) {
>, <Line: +					return [];
>, <Line: +				}
>, <Line: +				for (var i = 0; i < result.data.length; i++) {
>, <Line: +					var series = result.data[i];
>, <Line: +					for (var y = 0; y < series.datapoints.length; y++) {
>, <Line: +						series.datapoints[y][1] *= 1000;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.annotationQuery = function (annotation, rangeUnparsed) {
>, <Line: +				// Graphite metric as annotation
>, <Line: +				if (annotation.target) {
>, <Line: +					var target = templateSrv.replace(annotation.target);
>, <Line: +					var graphiteQuery = {
>, <Line: +						range: rangeUnparsed,
>, <Line: +						targets: [{target: target}],
>, <Line: +						format: 'json',
>, <Line: +						maxDataPoints: 100
>, <Line: +					};
>, <Line: +					return this.query(graphiteQuery)
>, <Line: +						.then(function (result) {
>, <Line: +							var list = [];
>, <Line: +							for (var i = 0; i < result.data.length; i++) {
>, <Line: +								var target = result.data[i];
>, <Line: +								for (var y = 0; y < target.datapoints.length; y++) {
>, <Line: +									var datapoint = target.datapoints[y];
>, <Line: +									if (!datapoint[0]) {
>, <Line: +										continue;
>, <Line: +									}
>, <Line: +									list.push({
>, <Line: +										annotation: annotation,
>, <Line: +										time: datapoint[1],
>, <Line: +										title: target.target
>, <Line: +									});
>, <Line: +								}
>, <Line: +							}
>, <Line: +							return list;
>, <Line: +						});
>, <Line: +				}
>, <Line: +				// Graphite event as annotation
>, <Line: +				else {
>, <Line: +					var tags = templateSrv.replace(annotation.tags);
>, <Line: +					return this.events({range: rangeUnparsed, tags: tags})
>, <Line: +						.then(function (results) {
>, <Line: +							var list = [];
>, <Line: +							for (var i = 0; i < results.data.length; i++) {
>, <Line: +								var e = results.data[i];
>, <Line: +								list.push({
>, <Line: +									annotation: annotation,
>, <Line: +									time: e.when * 1000,
>, <Line: +									title: e.what,
>, <Line: +									tags: e.tags,
>, <Line: +									text: e.data
>, <Line: +								});
>, <Line: +							}
>, <Line: +							return list;
>, <Line: +						});
>, <Line: +				}
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.events = function (options) {
>, <Line: +				try {
>, <Line: +					var tags = '';
>, <Line: +					if (options.tags) {
>, <Line: +						tags = '&tags=' + options.tags;
>, <Line: +					}
>, <Line: +					return this.doGraphiteRequest({
>, <Line: +						method: 'GET',
>, <Line: +						url: '/events/get_data?from=' + this.translateTime(options.range.from) + '&until=' + this.translateTime(options.range.to) + tags,
>, <Line: +					});
>, <Line: +				}
>, <Line: +				catch (err) {
>, <Line: +					return $q.reject(err);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.translateTime = function (date, rounding) {
>, <Line: +				if (_.isString(date)) {
>, <Line: +					if (date === 'now') {
>, <Line: +						return 'now';
>, <Line: +					}
>, <Line: +					else if (date.indexOf('now') >= 0) {
>, <Line: +						date = date.substring(3);
>, <Line: +						date = date.replace('m', 'min');
>, <Line: +						date = date.replace('M', 'mon');
>, <Line: +						return date;
>, <Line: +					}
>, <Line: +					date = kbn.parseDate(date);
>, <Line: +				}
>, <Line: +				date = moment.utc(date);
>, <Line: +				if (rounding === 'round-up') {
>, <Line: +					if (date.get('s')) {
>, <Line: +						date.add(1, 'm');
>, <Line: +					}
>, <Line: +				}
>, <Line: +				else if (rounding === 'round-down') {
>, <Line: +					// graphite' s from filter is exclusive
>, <Line: +					// here we step back one minute in order
>, <Line: +					// to guarantee that we get all the data that
>, <Line: +					// exists for the specified range
>, <Line: +					if (date.get('s')) {
>, <Line: +						date.subtract(1, 'm');
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return date.unix();
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.metricFindQuery = function (query) {
>, <Line: +				var interpolated;
>, <Line: +				try {
>, <Line: +					interpolated = encodeURIComponent(templateSrv.replace(query));
>, <Line: +				}
>, <Line: +				catch (err) {
>, <Line: +					return $q.reject(err);
>, <Line: +				}
>, <Line: +				return this.doGraphiteRequest({
>, <Line: +					method: 'GET',
>, <Line: +					url: '/metrics/find/?query=' + interpolated
>, <Line: +				})
>, <Line: +					.then(function (results) {
>, <Line: +						return _.map(results.data, function (metric) {
>, <Line: +							return {
>, <Line: +								text: metric.text,
>, <Line: +								expandable: metric.expandable ? true : false
>, <Line: +							};
>, <Line: +						});
>, <Line: +					});
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.listDashboards = function (query) {
>, <Line: +				return this.doGraphiteRequest({
>, <Line: +					method: 'GET',
>, <Line: +					url: '/dashboard/find/',
>, <Line: +					params: {query: query || ''}
>, <Line: +				})
>, <Line: +					.then(function (results) {
>, <Line: +						return results.data.dashboards;
>, <Line: +					});
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.loadDashboard = function (dashName) {
>, <Line: +				return this.doGraphiteRequest({
>, <Line: +					method: 'GET',
>, <Line: +					url: '/dashboard/load/' + encodeURIComponent(dashName)
>, <Line: +				});
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype.doGraphiteRequest = function (options) {
>, <Line: +				if (this.basicAuth || this.withCredentials) {
>, <Line: +					options.withCredentials = true;
>, <Line: +				}
>, <Line: +				if (this.basicAuth) {
>, <Line: +					options.headers = options.headers || {};
>, <Line: +					options.headers.Authorization = 'Basic ' + this.basicAuth;
>, <Line: +				}
>, <Line: +				options.url = this.url + options.url;
>, <Line: +				options.inspect = {type: 'graphite'};
>, <Line: +				return $http(options);
>, <Line: +			};
>, <Line: +			GraphiteDatasource.prototype._seriesRefLetters = [
>, <Line: +				'#A', '#B', '#C', '#D',
>, <Line: +				'#E', '#F', '#G', '#H',
>, <Line: +				'#I', '#J', '#K', '#L',
>, <Line: +				'#M', '#N', '#O'
>, <Line: +			];
>, <Line: +			GraphiteDatasource.prototype.buildGraphiteParams = function (options) {
>, <Line: +				var graphite_options = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];
>, <Line: +				var clean_options = [], targets = {};
>, <Line: +				var target, targetValue, i;
>, <Line: +				var regex = /(\#[A-Z])/g;
>, <Line: +				var intervalFormatFixRegex = /'(\d+)m'/gi;
>, <Line: +				if (options.format !== 'png') {
>, <Line: +					options['format'] = 'json';
>, <Line: +				}
>, <Line: +				function fixIntervalFormat(match) {
>, <Line: +					return match.replace('m', 'min').replace('M', 'mon');
>, <Line: +				}
>, <Line: +				for (i = 0; i < options.targets.length; i++) {
>, <Line: +					target = options.targets[i];
>, <Line: +					if (!target.target) {
>, <Line: +						continue;
>, <Line: +					}
>, <Line: +					targetValue = templateSrv.replace(target.target);
>, <Line: +					targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);
>, <Line: +					targets[this._seriesRefLetters[i]] = targetValue;
>, <Line: +				}
>, <Line: +				function nestedSeriesRegexReplacer(match) {
>, <Line: +					return targets[match];
>, <Line: +				}
>, <Line: +				for (i = 0; i < options.targets.length; i++) {
>, <Line: +					target = options.targets[i];
>, <Line: +					if (!target.target || target.hide) {
>, <Line: +						continue;
>, <Line: +					}
>, <Line: +					targetValue = targets[this._seriesRefLetters[i]];
>, <Line: +					targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);
>, <Line: +					clean_options.push("target=" + encodeURIComponent(targetValue));
>, <Line: +				}
>, <Line: +				_.each(options, function (value, key) {
>, <Line: +					if ($.inArray(key, graphite_options) === -1) {
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					if (value) {
>, <Line: +						clean_options.push(key + "=" + encodeURIComponent(value));
>, <Line: +					}
>, <Line: +				});
>, <Line: +				return clean_options;
>, <Line: +			};
>, <Line: +			return GraphiteDatasource;
>, <Line: +		});
>, <Line: +	});
>]
[<Line: -  'angular',
>, <Line: -  'lodash',
>, <Line: -  'jquery',
>, <Line: -  'config',
>, <Line: -  'kbn',
>, <Line: -  'moment'
>, <Line: -],
>, <Line: -function (angular, _, $, config, kbn, moment) {
>, <Line: -  'use strict';
>, <Line: -  var module = angular.module('grafana.services');
>, <Line: -  module.factory('GraphiteDatasource', function($q, $http, templateSrv) {
>, <Line: -    function GraphiteDatasource(datasource) {
>, <Line: -      this.type = 'graphite';
>, <Line: -      this.basicAuth = datasource.basicAuth;
>, <Line: -      this.url = datasource.url;
>, <Line: -      this.editorSrc = 'app/partials/graphite/editor.html';
>, <Line: -      this.name = datasource.name;
>, <Line: -      this.render_method = datasource.render_method || 'POST';
>, <Line: -      this.supportAnnotations = true;
>, <Line: -      this.supportMetrics = true;
>, <Line: -      this.annotationEditorSrc = 'app/partials/graphite/annotation_editor.html';
>, <Line: -      this.cacheTimeout = datasource.cacheTimeout;
>, <Line: -      this.withCredentials = datasource.withCredentials;
>, <Line: -    }
>, <Line: -    GraphiteDatasource.prototype.query = function(options) {
>, <Line: -      try {
>, <Line: -        var graphOptions = {
>, <Line: -          from: this.translateTime(options.range.from, 'round-down'),
>, <Line: -          until: this.translateTime(options.range.to, 'round-up'),
>, <Line: -          targets: options.targets,
>, <Line: -          format: options.format,
>, <Line: -          cacheTimeout: options.cacheTimeout || this.cacheTimeout,
>, <Line: -          maxDataPoints: options.maxDataPoints,
>, <Line: -        };
>, <Line: -        var params = this.buildGraphiteParams(graphOptions);
>, <Line: -        if (options.format === 'png') {
>, <Line: -          return $q.when(this.url + '/render' + '?' + params.join('&'));
>, <Line: -        }
>, <Line: -        var httpOptions = { method: this.render_method, url: '/render' };
>, <Line: -        if (httpOptions.method === 'GET') {
>, <Line: -          httpOptions.url = httpOptions.url + '?' + params.join('&');
>, <Line: -        }
>, <Line: -        else {
>, <Line: -          httpOptions.data = params.join('&');
>, <Line: -          httpOptions.headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
>, <Line: -        }
>, <Line: -        return this.doGraphiteRequest(httpOptions).then(this.convertDataPointsToMs);
>, <Line: -      }
>, <Line: -      catch(err) {
>, <Line: -        return $q.reject(err);
>, <Line: -      }
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.convertDataPointsToMs = function(result) {
>, <Line: -      if (!result || !result.data) { return []; }
>, <Line: -      for (var i = 0; i < result.data.length; i++) {
>, <Line: -        var series = result.data[i];
>, <Line: -        for (var y = 0; y < series.datapoints.length; y++) {
>, <Line: -          series.datapoints[y][1] *= 1000;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.annotationQuery = function(annotation, rangeUnparsed) {
>, <Line: -      // Graphite metric as annotation
>, <Line: -      if (annotation.target) {
>, <Line: -        var target = templateSrv.replace(annotation.target);
>, <Line: -        var graphiteQuery = {
>, <Line: -          range: rangeUnparsed,
>, <Line: -          targets: [{ target: target }],
>, <Line: -          format: 'json',
>, <Line: -          maxDataPoints: 100
>, <Line: -        };
>, <Line: -        return this.query(graphiteQuery)
>, <Line: -          .then(function(result) {
>, <Line: -            var list = [];
>, <Line: -            for (var i = 0; i < result.data.length; i++) {
>, <Line: -              var target = result.data[i];
>, <Line: -              for (var y = 0; y < target.datapoints.length; y++) {
>, <Line: -                var datapoint = target.datapoints[y];
>, <Line: -                if (!datapoint[0]) { continue; }
>, <Line: -                list.push({
>, <Line: -                  annotation: annotation,
>, <Line: -                  time: datapoint[1],
>, <Line: -                  title: target.target
>, <Line: -                });
>, <Line: -              }
>, <Line: -            }
>, <Line: -            return list;
>, <Line: -          });
>, <Line: -      }
>, <Line: -      // Graphite event as annotation
>, <Line: -      else {
>, <Line: -        var tags = templateSrv.replace(annotation.tags);
>, <Line: -        return this.events({ range: rangeUnparsed, tags: tags })
>, <Line: -          .then(function(results) {
>, <Line: -            var list = [];
>, <Line: -            for (var i = 0; i < results.data.length; i++) {
>, <Line: -              var e = results.data[i];
>, <Line: -              list.push({
>, <Line: -                annotation: annotation,
>, <Line: -                time: e.when * 1000,
>, <Line: -                title: e.what,
>, <Line: -                tags: e.tags,
>, <Line: -                text: e.data
>, <Line: -              });
>, <Line: -            }
>, <Line: -            return list;
>, <Line: -          });
>, <Line: -      }
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.events = function(options) {
>, <Line: -      try {
>, <Line: -        var tags = '';
>, <Line: -        if (options.tags) {
>, <Line: -          tags = '&tags=' + options.tags;
>, <Line: -        }
>, <Line: -        return this.doGraphiteRequest({
>, <Line: -          method: 'GET',
>, <Line: -          url: '/events/get_data?from=' + this.translateTime(options.range.from) + '&until=' + this.translateTime(options.range.to) + tags,
>, <Line: -        });
>, <Line: -      }
>, <Line: -      catch(err) {
>, <Line: -        return $q.reject(err);
>, <Line: -      }
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.translateTime = function(date, rounding) {
>, <Line: -      if (_.isString(date)) {
>, <Line: -        if (date === 'now') {
>, <Line: -          return 'now';
>, <Line: -        }
>, <Line: -        else if (date.indexOf('now') >= 0) {
>, <Line: -          date = date.substring(3);
>, <Line: -          date = date.replace('m', 'min');
>, <Line: -          date = date.replace('M', 'mon');
>, <Line: -          return date;
>, <Line: -        }
>, <Line: -        date = kbn.parseDate(date);
>, <Line: -      }
>, <Line: -      date = moment.utc(date);
>, <Line: -      if (rounding === 'round-up') {
>, <Line: -        if (date.get('s')) {
>, <Line: -          date.add(1, 'm');
>, <Line: -        }
>, <Line: -      }
>, <Line: -      else if (rounding === 'round-down') {
>, <Line: -        // graphite' s from filter is exclusive
>, <Line: -        // here we step back one minute in order
>, <Line: -        // to guarantee that we get all the data that
>, <Line: -        // exists for the specified range
>, <Line: -        if (date.get('s')) {
>, <Line: -          date.subtract(1, 'm');
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return date.unix();
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.metricFindQuery = function(query) {
>, <Line: -      var interpolated;
>, <Line: -      try {
>, <Line: -        interpolated = encodeURIComponent(templateSrv.replace(query));
>, <Line: -      }
>, <Line: -      catch(err) {
>, <Line: -        return $q.reject(err);
>, <Line: -      }
>, <Line: -      return this.doGraphiteRequest({method: 'GET', url: '/metrics/find/?query=' + interpolated })
>, <Line: -        .then(function(results) {
>, <Line: -          return _.map(results.data, function(metric) {
>, <Line: -            return {
>, <Line: -              text: metric.text,
>, <Line: -              expandable: metric.expandable ? true : false
>, <Line: -            };
>, <Line: -          });
>, <Line: -        });
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.listDashboards = function(query) {
>, <Line: -      return this.doGraphiteRequest({ method: 'GET',  url: '/dashboard/find/', params: {query: query || ''} })
>, <Line: -        .then(function(results) {
>, <Line: -          return results.data.dashboards;
>, <Line: -        });
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.loadDashboard = function(dashName) {
>, <Line: -      return this.doGraphiteRequest({method: 'GET', url: '/dashboard/load/' + encodeURIComponent(dashName) });
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype.doGraphiteRequest = function(options) {
>, <Line: -      if (this.basicAuth || this.withCredentials) {
>, <Line: -        options.withCredentials = true;
>, <Line: -      }
>, <Line: -      if (this.basicAuth) {
>, <Line: -        options.headers = options.headers || {};
>, <Line: -        options.headers.Authorization = 'Basic ' + this.basicAuth;
>, <Line: -      }
>, <Line: -      options.url = this.url + options.url;
>, <Line: -      options.inspect = { type: 'graphite' };
>, <Line: -      return $http(options);
>, <Line: -    };
>, <Line: -    GraphiteDatasource.prototype._seriesRefLetters = [
>, <Line: -      '#A', '#B', '#C', '#D',
>, <Line: -      '#E', '#F', '#G', '#H',
>, <Line: -      '#I', '#J', '#K', '#L',
>, <Line: -      '#M', '#N', '#O'
>, <Line: -    ];
>, <Line: -    GraphiteDatasource.prototype.buildGraphiteParams = function(options) {
>, <Line: -      var graphite_options = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];
>, <Line: -      var clean_options = [], targets = {};
>, <Line: -      var target, targetValue, i;
>, <Line: -      var regex = /(\#[A-Z])/g;
>, <Line: -      var intervalFormatFixRegex = /'(\d+)m'/gi;
>, <Line: -      if (options.format !== 'png') {
>, <Line: -        options['format'] = 'json';
>, <Line: -      }
>, <Line: -      function fixIntervalFormat(match) {
>, <Line: -        return match.replace('m', 'min').replace('M', 'mon');
>, <Line: -      }
>, <Line: -      for (i = 0; i < options.targets.length; i++) {
>, <Line: -        target = options.targets[i];
>, <Line: -        if (!target.target) {
>, <Line: -          continue;
>, <Line: -        }
>, <Line: -        targetValue = templateSrv.replace(target.target);
>, <Line: -        targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);
>, <Line: -        targets[this._seriesRefLetters[i]] = targetValue;
>, <Line: -      }
>, <Line: -      function nestedSeriesRegexReplacer(match) {
>, <Line: -        return targets[match];
>, <Line: -      }
>, <Line: -      for (i = 0; i < options.targets.length; i++) {
>, <Line: -        target = options.targets[i];
>, <Line: -        if (!target.target || target.hide) {
>, <Line: -          continue;
>, <Line: -        }
>, <Line: -        targetValue = targets[this._seriesRefLetters[i]];
>, <Line: -        targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);
>, <Line: -        clean_options.push("target=" + encodeURIComponent(targetValue));
>, <Line: -      }
>, <Line: -      _.each(options, function (value, key) {
>, <Line: -        if ($.inArray(key, graphite_options) === -1) { return; }
>, <Line: -        if (value) {
>, <Line: -          clean_options.push(key + "=" + encodeURIComponent(value));
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return clean_options;
>, <Line: -    };
>, <Line: -    return GraphiteDatasource;
>, <Line: -  });
>, <Line: -});
>]