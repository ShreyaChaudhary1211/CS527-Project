[<Line: +		'angular',
>, <Line: +		'lodash',
>, <Line: +		'kbn',
>, <Line: +		'moment'
>, <Line: +	],
>, <Line: +	function (angular, _, kbn) {
>, <Line: +		'use strict';
>, <Line: +		var module = angular.module('grafana.services');
>, <Line: +		module.factory('OpenTSDBDatasource', function ($q, $http, templateSrv) {
>, <Line: +			function OpenTSDBDatasource(datasource) {
>, <Line: +				this.type = 'opentsdb';
>, <Line: +				this.editorSrc = 'app/partials/opentsdb/editor.html';
>, <Line: +				this.url = datasource.url;
>, <Line: +				this.name = datasource.name;
>, <Line: +				this.supportMetrics = true;
>, <Line: +			}
>, <Line: +			// Called once per panel (graph)
>, <Line: +			OpenTSDBDatasource.prototype.query = function (options) {
>, <Line: +				var start = convertToTSDBTime(options.range.from);
>, <Line: +				var end = convertToTSDBTime(options.range.to);
>, <Line: +				var queries = _.compact(_.map(options.targets, convertTargetToQuery));
>, <Line: +				// No valid targets, return the empty result to save a round trip.
>, <Line: +				if (_.isEmpty(queries)) {
>, <Line: +					var d = $q.defer();
>, <Line: +					d.resolve({data: []});
>, <Line: +					return d.promise;
>, <Line: +				}
>, <Line: +				var groupByTags = {};
>, <Line: +				_.each(queries, function (query) {
>, <Line: +					_.each(query.tags, function (val, key) {
>, <Line: +						groupByTags[key] = true;
>, <Line: +					});
>, <Line: +				});
>, <Line: +				return this.performTimeSeriesQuery(queries, start, end)
>, <Line: +					.then(_.bind(function (response) {
>, <Line: +						var result = _.map(response.data, _.bind(function (metricData, index) {
>, <Line: +							return transformMetricData(metricData, groupByTags, this.targets[index]);
>, <Line: +						}, this));
>, <Line: +						return {data: result};
>, <Line: +					}, options));
>, <Line: +			};
>, <Line: +			OpenTSDBDatasource.prototype.performTimeSeriesQuery = function (queries, start, end) {
>, <Line: +				var reqBody = {
>, <Line: +					start: start,
>, <Line: +					queries: queries
>, <Line: +				};
>, <Line: +				// Relative queries (e.g. last hour) don't include an end time
>, <Line: +				if (end) {
>, <Line: +					reqBody.end = end;
>, <Line: +				}
>, <Line: +				var options = {
>, <Line: +					method: 'POST',
>, <Line: +					url: this.url + '/api/query',
>, <Line: +					data: reqBody
>, <Line: +				};
>, <Line: +				return $http(options);
>, <Line: +			};
>, <Line: +			OpenTSDBDatasource.prototype.performSuggestQuery = function (query, type) {
>, <Line: +				var options = {
>, <Line: +					method: 'GET',
>, <Line: +					url: this.url + '/api/suggest',
>, <Line: +					params: {
>, <Line: +						type: type,
>, <Line: +						q: query
>, <Line: +					}
>, <Line: +				};
>, <Line: +				return $http(options).then(function (result) {
>, <Line: +					return result.data;
>, <Line: +				});
>, <Line: +			};
>, <Line: +			function transformMetricData(md, groupByTags, options) {
>, <Line: +				var dps = [],
>, <Line: +					tagData = [],
>, <Line: +					metricLabel = null;
>, <Line: +				if (!_.isEmpty(md.tags)) {
>, <Line: +					_.each(_.pairs(md.tags), function (tag) {
>, <Line: +						if (_.has(groupByTags, tag[0])) {
>, <Line: +							tagData.push(tag[0] + "=" + tag[1]);
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +				metricLabel = createMetricLabel(md.metric, tagData, options);
>, <Line: +				// TSDB returns datapoints has a hash of ts => value.
>, <Line: +				// Can't use _.pairs(invert()) because it stringifies keys/values
>, <Line: +				_.each(md.dps, function (v, k) {
>, <Line: +					dps.push([v, k * 1000]);
>, <Line: +				});
>, <Line: +				return {target: metricLabel, datapoints: dps};
>, <Line: +			}
>, <Line: +			function createMetricLabel(metric, tagData, options) {
>, <Line: +				if (!_.isUndefined(options) && options.alias) {
>, <Line: +					return options.alias;
>, <Line: +				}
>, <Line: +				if (!_.isEmpty(tagData)) {
>, <Line: +					metric += "{" + tagData.join(", ") + "}";
>, <Line: +				}
>, <Line: +				return metric;
>, <Line: +			}
>, <Line: +			function convertTargetToQuery(target) {
>, <Line: +				if (!target.metric) {
>, <Line: +					return null;
>, <Line: +				}
>, <Line: +				var query = {
>, <Line: +					metric: templateSrv.replace(target.metric),
>, <Line: +					aggregator: "avg"
>, <Line: +				};
>, <Line: +				if (target.aggregator) {
>, <Line: +					query.aggregator = templateSrv.replace(target.aggregator);
>, <Line: +				}
>, <Line: +				if (target.shouldComputeRate) {
>, <Line: +					query.rate = true;
>, <Line: +					query.rateOptions = {
>, <Line: +						counter: !!target.isCounter
>, <Line: +					};
>, <Line: +					if (target.counterMax && target.counterMax.length) {
>, <Line: +						query.rateOptions.counterMax = parseInt(target.counterMax);
>, <Line: +					}
>, <Line: +					if (target.counterResetValue && target.counterResetValue.length) {
>, <Line: +						query.rateOptions.resetValue = parseInt(target.counterResetValue);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (target.shouldDownsample) {
>, <Line: +					query.downsample = templateSrv.replace(target.downsampleInterval) + "-" + target.downsampleAggregator;
>, <Line: +				}
>, <Line: +				query.tags = angular.copy(target.tags);
>, <Line: +				if (query.tags) {
>, <Line: +					for (var key in query.tags) {
>, <Line: +						query.tags[key] = templateSrv.replace(query.tags[key]);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return query;
>, <Line: +			}
>, <Line: +			function convertToTSDBTime(date) {
>, <Line: +				if (date === 'now') {
>, <Line: +					return null;
>, <Line: +				}
>, <Line: +				date = kbn.parseDate(date);
>, <Line: +				return date.getTime();
>, <Line: +			}
>, <Line: +			return OpenTSDBDatasource;
>, <Line: +		});
>, <Line: +	});
>]
[<Line: -  'angular',
>, <Line: -  'lodash',
>, <Line: -  'kbn',
>, <Line: -  'moment'
>, <Line: -],
>, <Line: -function (angular, _, kbn) {
>, <Line: -  'use strict';
>, <Line: -  var module = angular.module('grafana.services');
>, <Line: -  module.factory('OpenTSDBDatasource', function($q, $http, templateSrv) {
>, <Line: -    function OpenTSDBDatasource(datasource) {
>, <Line: -      this.type = 'opentsdb';
>, <Line: -      this.editorSrc = 'app/partials/opentsdb/editor.html';
>, <Line: -      this.url = datasource.url;
>, <Line: -      this.name = datasource.name;
>, <Line: -      this.supportMetrics = true;
>, <Line: -    }
>, <Line: -    // Called once per panel (graph)
>, <Line: -    OpenTSDBDatasource.prototype.query = function(options) {
>, <Line: -      var start = convertToTSDBTime(options.range.from);
>, <Line: -      var end = convertToTSDBTime(options.range.to);
>, <Line: -      var queries = _.compact(_.map(options.targets, convertTargetToQuery));
>, <Line: -      // No valid targets, return the empty result to save a round trip.
>, <Line: -      if (_.isEmpty(queries)) {
>, <Line: -        var d = $q.defer();
>, <Line: -        d.resolve({ data: [] });
>, <Line: -        return d.promise;
>, <Line: -      }
>, <Line: -      var groupByTags = {};
>, <Line: -      _.each(queries, function(query) {
>, <Line: -        _.each(query.tags, function(val, key) {
>, <Line: -          groupByTags[key] = true;
>, <Line: -        });
>, <Line: -      });
>, <Line: -      return this.performTimeSeriesQuery(queries, start, end)
>, <Line: -        .then(_.bind(function(response) {
>, <Line: -          var result = _.map(response.data, _.bind(function(metricData, index) {
>, <Line: -            return transformMetricData(metricData, groupByTags, this.targets[index]);
>, <Line: -          }, this));
>, <Line: -          return { data: result };
>, <Line: -        }, options));
>, <Line: -    };
>, <Line: -    OpenTSDBDatasource.prototype.performTimeSeriesQuery = function(queries, start, end) {
>, <Line: -      var reqBody = {
>, <Line: -        start: start,
>, <Line: -        queries: queries
>, <Line: -      };
>, <Line: -      // Relative queries (e.g. last hour) don't include an end time
>, <Line: -      if (end) {
>, <Line: -        reqBody.end = end;
>, <Line: -      }
>, <Line: -      var options = {
>, <Line: -        method: 'POST',
>, <Line: -        url: this.url + '/api/query',
>, <Line: -        data: reqBody
>, <Line: -      };
>, <Line: -      return $http(options);
>, <Line: -    };
>, <Line: -    OpenTSDBDatasource.prototype.performSuggestQuery = function(query, type) {
>, <Line: -      var options = {
>, <Line: -        method: 'GET',
>, <Line: -        url: this.url + '/api/suggest',
>, <Line: -        params: {
>, <Line: -          type: type,
>, <Line: -          q: query
>, <Line: -        }
>, <Line: -      };
>, <Line: -      return $http(options).then(function(result) {
>, <Line: -        return result.data;
>, <Line: -      });
>, <Line: -    };
>, <Line: -    function transformMetricData(md, groupByTags, options) {
>, <Line: -      var dps = [],
>, <Line: -          tagData = [],
>, <Line: -          metricLabel = null;
>, <Line: -      if (!_.isEmpty(md.tags)) {
>, <Line: -        _.each(_.pairs(md.tags), function(tag) {
>, <Line: -          if (_.has(groupByTags, tag[0])) {
>, <Line: -            tagData.push(tag[0] + "=" + tag[1]);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      metricLabel = createMetricLabel(md.metric, tagData, options);
>, <Line: -      // TSDB returns datapoints has a hash of ts => value.
>, <Line: -      // Can't use _.pairs(invert()) because it stringifies keys/values
>, <Line: -      _.each(md.dps, function (v, k) {
>, <Line: -        dps.push([v, k * 1000]);
>, <Line: -      });
>, <Line: -      return { target: metricLabel, datapoints: dps };
>, <Line: -    }
>, <Line: -    function createMetricLabel(metric, tagData, options) {
>, <Line: -      if (!_.isUndefined(options) && options.alias) {
>, <Line: -        return options.alias;
>, <Line: -      }
>, <Line: -      if (!_.isEmpty(tagData)) {
>, <Line: -        metric += "{" + tagData.join(", ") + "}";
>, <Line: -      }
>, <Line: -      return metric;
>, <Line: -    }
>, <Line: -    function convertTargetToQuery(target) {
>, <Line: -      if (!target.metric) {
>, <Line: -        return null;
>, <Line: -      }
>, <Line: -      var query = {
>, <Line: -        metric: templateSrv.replace(target.metric),
>, <Line: -        aggregator: "avg"
>, <Line: -      };
>, <Line: -      if (target.aggregator) {
>, <Line: -        query.aggregator = templateSrv.replace(target.aggregator);
>, <Line: -      }
>, <Line: -      if (target.shouldComputeRate) {
>, <Line: -        query.rate = true;
>, <Line: -        query.rateOptions = {
>, <Line: -          counter: !!target.isCounter
>, <Line: -        };
>, <Line: -        if (target.counterMax && target.counterMax.length) {
>, <Line: -          query.rateOptions.counterMax = parseInt(target.counterMax);
>, <Line: -        }
>, <Line: -        if (target.counterResetValue && target.counterResetValue.length) {
>, <Line: -          query.rateOptions.resetValue = parseInt(target.counterResetValue);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (target.shouldDownsample) {
>, <Line: -        query.downsample = templateSrv.replace(target.downsampleInterval) + "-" + target.downsampleAggregator;
>, <Line: -      }
>, <Line: -      query.tags = angular.copy(target.tags);
>, <Line: -      if(query.tags){
>, <Line: -        for(var key in query.tags){
>, <Line: -          query.tags[key] = templateSrv.replace(query.tags[key]);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return query;
>, <Line: -    }
>, <Line: -    function convertToTSDBTime(date) {
>, <Line: -      if (date === 'now') {
>, <Line: -        return null;
>, <Line: -      }
>, <Line: -      date = kbn.parseDate(date);
>, <Line: -      return date.getTime();
>, <Line: -    }
>, <Line: -    return OpenTSDBDatasource;
>, <Line: -  });
>, <Line: -});
>]