[<Line: +/**
>, <Line: + * angular-strap
>, <Line: + * @version v2.3.3 - 2015-09-24
>, <Line: + * @link http://mgcrea.github.io/angular-strap
>, <Line: + * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
>, <Line: + * @license MIT License, http://www.opensource.org/licenses/MIT
>, <Line: + */
>, <Line: +!function (e, t, n) {
>, <Line: +	'use strict';
>, <Line: +	function a(e, n, a, o, i, r) {
>, <Line: +		function s(e, n) {
>, <Line: +			return angular.element((n || t).querySelectorAll(e))
>, <Line: +		}
>, <Line: +		function l(e) {
>, <Line: +			return u[e] ? u[e] : u[e] = n.get(e, {cache: r}).then(function (e) {
>, <Line: +				return e.data
>, <Line: +			})
>, <Line: +		}
>, <Line: +		this.compile = function (t) {
>, <Line: +			t.template && /\.html$/.test(t.template) && (console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.'), t.templateUrl = t.template, t.template = '');
>, <Line: +			var n = t.templateUrl, r = t.template || '', u = t.controller, c = t.controllerAs, d = angular.copy(t.resolve || {}), f = angular.copy(t.locals || {}), p = t.transformTemplate || angular.identity, g = t.bindToController;
>, <Line: +			return angular.forEach(d, function (e, t) {
>, <Line: +				angular.isString(e) ? d[t] = a.get(e) : d[t] = a.invoke(e)
>, <Line: +			}), angular.extend(d, f), n ? d.$template = l(n) : d.$template = e.when(r), t.contentTemplate && (d.$template = e.all([d.$template, l(t.contentTemplate)]).then(function (e) {
>, <Line: +				var n = angular.element(e[0]), a = s('[ng-bind="content"]', n[0]).removeAttr('ng-bind').html(e[1]);
>, <Line: +				return t.templateUrl || a.next().remove(), n[0].outerHTML
>, <Line: +			})), e.all(d).then(function (e) {
>, <Line: +				var n = p(e.$template);
>, <Line: +				t.html && (n = n.replace(/ng-bind="/gi, 'ng-bind-html="'));
>, <Line: +				var a = angular.element('<div>').html(n.trim()).contents(), r = o(a);
>, <Line: +				return {
>, <Line: +					locals: e, element: a, link: function (t) {
>, <Line: +						if (e.$scope = t, u) {
>, <Line: +							var n = i(u, e, !0);
>, <Line: +							g && angular.extend(n.instance, e);
>, <Line: +							var o = angular.isObject(n) ? n : n();
>, <Line: +							a.data('$ngControllerController', o), a.children().data('$ngControllerController', o), c && (t[c] = o)
>, <Line: +						}
>, <Line: +						return r.apply(null, arguments)
>, <Line: +					}
>, <Line: +				}
>, <Line: +			})
>, <Line: +		};
>, <Line: +		var u = {}
>, <Line: +	}
>, <Line: +	angular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions']).provider('$typeahead', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'typeahead',
>, <Line: +			prefixEvent: '$typeahead',
>, <Line: +			placement: 'bottom-left',
>, <Line: +			templateUrl: 'typeahead/typeahead.tpl.html',
>, <Line: +			trigger: 'focus',
>, <Line: +			container: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			delay: 0,
>, <Line: +			minLength: 1,
>, <Line: +			filter: 'bsAsyncFilter',
>, <Line: +			limit: 6,
>, <Line: +			autoSelect: !1,
>, <Line: +			comparator: '',
>, <Line: +			trimValue: !0
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$rootScope', '$tooltip', '$$rAF', '$timeout', function (t, n, a, o, i) {
>, <Line: +			function r(t, n, r) {
>, <Line: +				var l = {}, u = angular.extend({}, e, r);
>, <Line: +				l = a(t, u);
>, <Line: +				var c = r.scope, d = l.$scope;
>, <Line: +				d.$resetMatches = function () {
>, <Line: +					d.$matches = [], d.$activeIndex = u.autoSelect ? 0 : -1
>, <Line: +				}, d.$resetMatches(), d.$activate = function (e) {
>, <Line: +					d.$$postDigest(function () {
>, <Line: +						l.activate(e)
>, <Line: +					})
>, <Line: +				}, d.$select = function (e, t) {
>, <Line: +					d.$$postDigest(function () {
>, <Line: +						l.select(e)
>, <Line: +					})
>, <Line: +				}, d.$isVisible = function () {
>, <Line: +					return l.$isVisible()
>, <Line: +				}, l.update = function (e) {
>, <Line: +					d.$matches = e, d.$activeIndex >= e.length && (d.$activeIndex = u.autoSelect ? 0 : -1), s(d), o(l.$applyPlacement)
>, <Line: +				}, l.activate = function (e) {
>, <Line: +					d.$activeIndex = e
>, <Line: +				}, l.select = function (e) {
>, <Line: +					if (-1 !== e) {
>, <Line: +						var t = d.$matches[e].value;
>, <Line: +						n.$setViewValue(t), n.$render(), d.$resetMatches(), c && c.$digest(), d.$emit(u.prefixEvent + '.select', t, e, l)
>, <Line: +					}
>, <Line: +				}, l.$isVisible = function () {
>, <Line: +					return u.minLength && n ? d.$matches.length && angular.isString(n.$viewValue) && n.$viewValue.length >= u.minLength : !!d.$matches.length
>, <Line: +				}, l.$getIndex = function (e) {
>, <Line: +					var t = d.$matches.length, n = t;
>, <Line: +					if (t) {
>, <Line: +						for (n = t; n-- && d.$matches[n].value !== e;);
>, <Line: +						if (!(0 > n))return n
>, <Line: +					}
>, <Line: +				}, l.$onMouseDown = function (e) {
>, <Line: +					e.preventDefault(), e.stopPropagation()
>, <Line: +				}, l.$onKeyDown = function (e) {
>, <Line: +					/(38|40|13)/.test(e.keyCode) && (!l.$isVisible() || 13 === e.keyCode && -1 === d.$activeIndex || (e.preventDefault(), e.stopPropagation()), 13 === e.keyCode && d.$matches.length ? l.select(d.$activeIndex) : 38 === e.keyCode && d.$activeIndex > 0 ? d.$activeIndex-- : 40 === e.keyCode && d.$activeIndex < d.$matches.length - 1 ? d.$activeIndex++ : angular.isUndefined(d.$activeIndex) && (d.$activeIndex = 0), d.$digest())
>, <Line: +				};
>, <Line: +				var f = l.show;
>, <Line: +				l.show = function () {
>, <Line: +					f(), i(function () {
>, <Line: +						l.$element && l.$element.on('mousedown', l.$onMouseDown), u.keyboard && t && t.on('keydown', l.$onKeyDown)
>, <Line: +					}, 0, !1)
>, <Line: +				};
>, <Line: +				var p = l.hide;
>, <Line: +				return l.hide = function () {
>, <Line: +					l.$element && l.$element.off('mousedown', l.$onMouseDown), u.keyboard && t && t.off('keydown', l.$onKeyDown), u.autoSelect || l.activate(-1), p()
>, <Line: +				}, l
>, <Line: +			}
>, <Line: +			function s(e) {
>, <Line: +				e.$$phase || e.$root && e.$root.$$phase || e.$digest()
>, <Line: +			}
>, <Line: +			angular.element(t.document.body);
>, <Line: +			return r.defaults = e, r
>, <Line: +		}]
>, <Line: +	}).filter('bsAsyncFilter', ['$filter', function (e) {
>, <Line: +		return function (t, n, a) {
>, <Line: +			return t && angular.isFunction(t.then) ? t.then(function (t) {
>, <Line: +				return e('filter')(t, n, a)
>, <Line: +			}) : e('filter')(t, n, a)
>, <Line: +		}
>, <Line: +	}]).directive('bsTypeahead', ['$window', '$parse', '$q', '$typeahead', '$parseOptions', function (e, t, n, a, o) {
>, <Line: +		var i = a.defaults;
>, <Line: +		return {
>, <Line: +			restrict: 'EAC',
>, <Line: +			require: 'ngModel',
>, <Line: +			link: function (e, t, n, r) {
>, <Line: +				var s = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && (s[e] = n[e])
>, <Line: +				});
>, <Line: +				var l = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container', 'trimValue'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && l.test(n[e]) && (s[e] = !1)
>, <Line: +				}), t.attr('autocomplete') || t.attr('autocomplete', 'off');
>, <Line: +				var u = s.filter || i.filter, c = s.limit || i.limit, d = s.comparator || i.comparator, f = n.bsOptions;
>, <Line: +				u && (f += ' | ' + u + ':$viewValue'), d && (f += ':' + d), c && (f += ' | limitTo:' + c);
>, <Line: +				var p = o(f), g = a(t, r, s);
>, <Line: +				if (s.watchOptions) {
>, <Line: +					var m = p.$match[7].replace(/\|.+/, '').replace(/\(.*\)/g, '').trim();
>, <Line: +					e.$watchCollection(m, function (t, n) {
>, <Line: +						p.valuesFn(e, r).then(function (e) {
>, <Line: +							g.update(e), r.$render()
>, <Line: +						})
>, <Line: +					})
>, <Line: +				}
>, <Line: +				e.$watch(n.ngModel, function (t, n) {
>, <Line: +					e.$modelValue = t, p.valuesFn(e, r).then(function (e) {
>, <Line: +						if (s.selectMode && !e.length && t.length > 0)return void r.$setViewValue(r.$viewValue.substring(0, r.$viewValue.length - 1));
>, <Line: +						e.length > c && (e = e.slice(0, c));
>, <Line: +						var n = g.$isVisible();
>, <Line: +						n && g.update(e), (1 !== e.length || e[0].value !== t) && (!n && g.update(e), r.$render())
>, <Line: +					})
>, <Line: +				}), r.$formatters.push(function (e) {
>, <Line: +					var t = p.displayValue(e);
>, <Line: +					return t ? t : e && 'object' != typeof e ? e : ''
>, <Line: +				}), r.$render = function () {
>, <Line: +					if (r.$isEmpty(r.$viewValue))return t.val('');
>, <Line: +					var e = g.$getIndex(r.$modelValue), n = angular.isDefined(e) ? g.$scope.$matches[e].label : r.$viewValue;
>, <Line: +					n = angular.isObject(n) ? p.displayValue(n) : n;
>, <Line: +					var a = n ? n.toString().replace(/<(?:.|\n)*?>/gm, '') : '';
>, <Line: +					t.val(s.trimValue === !1 ? a : a.trim())
>, <Line: +				}, e.$on('$destroy', function () {
>, <Line: +					g && g.destroy(), s = null, g = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions']).provider('$tooltip', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			customClass: '',
>, <Line: +			prefixClass: 'tooltip',
>, <Line: +			prefixEvent: 'tooltip',
>, <Line: +			container: !1,
>, <Line: +			target: !1,
>, <Line: +			placement: 'top',
>, <Line: +			templateUrl: 'tooltip/tooltip.tpl.html',
>, <Line: +			template: '',
>, <Line: +			contentTemplate: !1,
>, <Line: +			trigger: 'hover focus',
>, <Line: +			keyboard: !1,
>, <Line: +			html: !1,
>, <Line: +			show: !1,
>, <Line: +			title: '',
>, <Line: +			type: '',
>, <Line: +			delay: 0,
>, <Line: +			autoClose: !1,
>, <Line: +			bsEnabled: !0,
>, <Line: +			viewport: {selector: 'body', padding: 0}
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$rootScope', '$bsCompiler', '$q', '$templateCache', '$http', '$animate', '$sce', 'dimensions', '$$rAF', '$timeout', function (n, a, o, i, r, s, l, u, c, d, f) {
>, <Line: +			function p(i, r) {
>, <Line: +				function s() {
>, <Line: +					I.$emit(V.prefixEvent + '.show', F)
>, <Line: +				}
>, <Line: +				function p() {
>, <Line: +					if (I.$emit(V.prefixEvent + '.hide', F), R === j) {
>, <Line: +						if (z && 'focus' === V.trigger)return i[0].blur();
>, <Line: +						A()
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function v() {
>, <Line: +					var e = V.trigger.split(' ');
>, <Line: +					angular.forEach(e, function (e) {
>, <Line: +						'click' === e ? i.on('click', F.toggle) : 'manual' !== e && (i.on('hover' === e ? 'mouseenter' : 'focus', F.enter), i.on('hover' === e ? 'mouseleave' : 'blur', F.leave), 'button' === N && 'hover' !== e && i.on($ ? 'touchstart' : 'mousedown', F.$onFocusElementMouseDown))
>, <Line: +					})
>, <Line: +				}
>, <Line: +				function w() {
>, <Line: +					for (var e = V.trigger.split(' '), t = e.length; t--;) {
>, <Line: +						var n = e[t];
>, <Line: +						'click' === n ? i.off('click', F.toggle) : 'manual' !== n && (i.off('hover' === n ? 'mouseenter' : 'focus', F.enter), i.off('hover' === n ? 'mouseleave' : 'blur', F.leave), 'button' === N && 'hover' !== n && i.off($ ? 'touchstart' : 'mousedown', F.$onFocusElementMouseDown))
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function y() {
>, <Line: +					'focus' !== V.trigger ? R.on('keyup', F.$onKeyUp) : i.on('keyup', F.$onFocusKeyUp)
>, <Line: +				}
>, <Line: +				function b() {
>, <Line: +					'focus' !== V.trigger ? R.off('keyup', F.$onKeyUp) : i.off('keyup', F.$onFocusKeyUp)
>, <Line: +				}
>, <Line: +				function D() {
>, <Line: +					f(function () {
>, <Line: +						R.on('click', S), h.on('click', F.hide), K = !0
>, <Line: +					}, 0, !1)
>, <Line: +				}
>, <Line: +				function k() {
>, <Line: +					K && (R.off('click', S), h.off('click', F.hide), K = !1)
>, <Line: +				}
>, <Line: +				function S(e) {
>, <Line: +					e.stopPropagation()
>, <Line: +				}
>, <Line: +				function x(e) {
>, <Line: +					e = e || V.target || i;
>, <Line: +					var a = e[0], o = 'BODY' === a.tagName, r = a.getBoundingClientRect(), s = {};
>, <Line: +					for (var l in r)s[l] = r[l];
>, <Line: +					null === s.width && (s = angular.extend({}, s, {
>, <Line: +						width: r.right - r.left,
>, <Line: +						height: r.bottom - r.top
>, <Line: +					}));
>, <Line: +					var u = o ? {
>, <Line: +						top: 0,
>, <Line: +						left: 0
>, <Line: +					} : c.offset(a), d = {scroll: o ? t.documentElement.scrollTop || t.body.scrollTop : e.prop('scrollTop') || 0}, f = o ? {
>, <Line: +						width: t.documentElement.clientWidth,
>, <Line: +						height: n.innerHeight
>, <Line: +					} : null;
>, <Line: +					return angular.extend({}, s, d, f, u)
>, <Line: +				}
>, <Line: +				function T(e, t, n, a) {
>, <Line: +					var o, i = e.split('-');
>, <Line: +					switch (i[0]) {
>, <Line: +						case'right':
>, <Line: +							o = {
>, <Line: +								top: t.top + t.height / 2 - a / 2,
>, <Line: +								left: t.left + t.width
>, <Line: +							};
>, <Line: +							break;
>, <Line: +						case'bottom':
>, <Line: +							o = {
>, <Line: +								top: t.top + t.height,
>, <Line: +								left: t.left + t.width / 2 - n / 2
>, <Line: +							};
>, <Line: +							break;
>, <Line: +						case'left':
>, <Line: +							o = {
>, <Line: +								top: t.top + t.height / 2 - a / 2,
>, <Line: +								left: t.left - n
>, <Line: +							};
>, <Line: +							break;
>, <Line: +						default:
>, <Line: +							o = {
>, <Line: +								top: t.top - a,
>, <Line: +								left: t.left + t.width / 2 - n / 2
>, <Line: +							}
>, <Line: +					}
>, <Line: +					if (!i[1])return o;
>, <Line: +					if ('top' === i[0] || 'bottom' === i[0])switch (i[1]) {
>, <Line: +						case'left':
>, <Line: +							o.left = t.left;
>, <Line: +							break;
>, <Line: +						case'right':
>, <Line: +							o.left = t.left + t.width - n
>, <Line: +					} else if ('left' === i[0] || 'right' === i[0])switch (i[1]) {
>, <Line: +						case'top':
>, <Line: +							o.top = t.top - a;
>, <Line: +							break;
>, <Line: +						case'bottom':
>, <Line: +							o.top = t.top + t.height
>, <Line: +					}
>, <Line: +					return o
>, <Line: +				}
>, <Line: +				function C(e, t) {
>, <Line: +					var n = R[0], a = n.offsetWidth, o = n.offsetHeight, i = parseInt(c.css(n, 'margin-top'), 10), r = parseInt(c.css(n, 'margin-left'), 10);
>, <Line: +					isNaN(i) && (i = 0), isNaN(r) && (r = 0), e.top = e.top + i, e.left = e.left + r, c.setOffset(n, angular.extend({
>, <Line: +						using: function (e) {
>, <Line: +							R.css({
>, <Line: +								top: Math.round(e.top) + 'px',
>, <Line: +								left: Math.round(e.left) + 'px',
>, <Line: +								right: ''
>, <Line: +							})
>, <Line: +						}
>, <Line: +					}, e), 0);
>, <Line: +					var s = n.offsetWidth, l = n.offsetHeight;
>, <Line: +					if ('top' === t && l !== o && (e.top = e.top + o - l), !/top-left|top-right|bottom-left|bottom-right/.test(t)) {
>, <Line: +						var u = E(t, e, s, l);
>, <Line: +						if (u.left ? e.left += u.left : e.top += u.top, c.setOffset(n, e), /top|right|bottom|left/.test(t)) {
>, <Line: +							var d = /top|bottom/.test(t), f = d ? 2 * u.left - a + s : 2 * u.top - o + l, p = d ? 'offsetWidth' : 'offsetHeight';
>, <Line: +							M(f, n[p], d)
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function E(e, t, n, a) {
>, <Line: +					var o = {top: 0, left: 0};
>, <Line: +					if (!F.$viewport)return o;
>, <Line: +					var i = V.viewport && V.viewport.padding || 0, r = x(F.$viewport);
>, <Line: +					if (/right|left/.test(e)) {
>, <Line: +						var s = t.top - i - r.scroll, l = t.top + i - r.scroll + a;
>, <Line: +						s < r.top ? o.top = r.top - s : l > r.top + r.height && (o.top = r.top + r.height - l)
>, <Line: +					} else {
>, <Line: +						var u = t.left - i, c = t.left + i + n;
>, <Line: +						u < r.left ? o.left = r.left - u : c > r.right && (o.left = r.left + r.width - c)
>, <Line: +					}
>, <Line: +					return o
>, <Line: +				}
>, <Line: +				function M(e, t, n) {
>, <Line: +					var a = m('.tooltip-arrow, .arrow', R[0]);
>, <Line: +					a.css(n ? 'left' : 'top', 50 * (1 - e / t) + '%').css(n ? 'top' : 'left', '')
>, <Line: +				}
>, <Line: +				function A() {
>, <Line: +					clearTimeout(H), F.$isShown && null !== R && (V.autoClose && k(), V.keyboard && b()), q && (q.$destroy(), q = null), R && (R.remove(), R = F.$element = null)
>, <Line: +				}
>, <Line: +				var F = {}, V = F.$options = angular.extend({}, e, r), O = F.$promise = o.compile(V), I = F.$scope = V.scope && V.scope.$new() || a.$new(), N = i[0].nodeName.toLowerCase();
>, <Line: +				if (V.delay && angular.isString(V.delay)) {
>, <Line: +					var P = V.delay.split(',').map(parseFloat);
>, <Line: +					V.delay = P.length > 1 ? {show: P[0], hide: P[1]} : P[0]
>, <Line: +				}
>, <Line: +				F.$id = V.id || i.attr('id') || '', V.title && (I.title = u.trustAsHtml(V.title)), I.$setEnabled = function (e) {
>, <Line: +					I.$$postDigest(function () {
>, <Line: +						F.setEnabled(e)
>, <Line: +					})
>, <Line: +				}, I.$hide = function () {
>, <Line: +					I.$$postDigest(function () {
>, <Line: +						F.hide()
>, <Line: +					})
>, <Line: +				}, I.$show = function () {
>, <Line: +					I.$$postDigest(function () {
>, <Line: +						F.show()
>, <Line: +					})
>, <Line: +				}, I.$toggle = function () {
>, <Line: +					I.$$postDigest(function () {
>, <Line: +						F.toggle()
>, <Line: +					})
>, <Line: +				}, F.$isShown = I.$isShown = !1;
>, <Line: +				var H, L, U, R, Y, q;
>, <Line: +				O.then(function (e) {
>, <Line: +					U = e, F.init()
>, <Line: +				}), F.init = function () {
>, <Line: +					V.delay && angular.isNumber(V.delay) && (V.delay = {
>, <Line: +						show: V.delay,
>, <Line: +						hide: V.delay
>, <Line: +					}), 'self' === V.container ? Y = i : angular.isElement(V.container) ? Y = V.container : V.container && (Y = m(V.container)), v(), V.target && (V.target = angular.isElement(V.target) ? V.target : m(V.target)), V.show && I.$$postDigest(function () {
>, <Line: +						'focus' === V.trigger ? i[0].focus() : F.show()
>, <Line: +					})
>, <Line: +				}, F.destroy = function () {
>, <Line: +					w(), A(), I.$destroy()
>, <Line: +				}, F.enter = function () {
>, <Line: +					return clearTimeout(H), L = 'in', V.delay && V.delay.show ? void(H = setTimeout(function () {
>, <Line: +						'in' === L && F.show()
>, <Line: +					}, V.delay.show)) : F.show()
>, <Line: +				}, F.show = function () {
>, <Line: +					if (V.bsEnabled && !F.$isShown) {
>, <Line: +						I.$emit(V.prefixEvent + '.show.before', F);
>, <Line: +						var e, t;
>, <Line: +						V.container ? (e = Y, t = Y[0].lastChild ? angular.element(Y[0].lastChild) : null) : (e = null, t = i), R && A(), q = F.$scope.$new(), R = F.$element = U.link(q, function (e, t) {
>, <Line: +						}), R.css({
>, <Line: +							top: '-9999px',
>, <Line: +							left: '-9999px',
>, <Line: +							right: 'auto',
>, <Line: +							display: 'block',
>, <Line: +							visibility: 'hidden'
>, <Line: +						}), V.animation && R.addClass(V.animation), V.type && R.addClass(V.prefixClass + '-' + V.type), V.customClass && R.addClass(V.customClass), t ? t.after(R) : e.prepend(R), F.$isShown = I.$isShown = !0, g(I), F.$applyPlacement(), angular.version.minor <= 2 ? l.enter(R, e, t, s) : l.enter(R, e, t).then(s), g(I), d(function () {
>, <Line: +							R && R.css({visibility: 'visible'})
>, <Line: +						}), V.keyboard && ('focus' !== V.trigger && F.focus(), y()), V.autoClose && D()
>, <Line: +					}
>, <Line: +				}, F.leave = function () {
>, <Line: +					return clearTimeout(H), L = 'out', V.delay && V.delay.hide ? void(H = setTimeout(function () {
>, <Line: +						'out' === L && F.hide()
>, <Line: +					}, V.delay.hide)) : F.hide()
>, <Line: +				};
>, <Line: +				var z, j;
>, <Line: +				F.hide = function (e) {
>, <Line: +					F.$isShown && (I.$emit(V.prefixEvent + '.hide.before', F), z = e, j = R, angular.version.minor <= 2 ? l.leave(R, p) : l.leave(R).then(p), F.$isShown = I.$isShown = !1, g(I), V.keyboard && null !== R && b(), V.autoClose && null !== R && k())
>, <Line: +				}, F.toggle = function () {
>, <Line: +					F.$isShown ? F.leave() : F.enter()
>, <Line: +				}, F.focus = function () {
>, <Line: +					R[0].focus()
>, <Line: +				}, F.setEnabled = function (e) {
>, <Line: +					V.bsEnabled = e
>, <Line: +				}, F.setViewport = function (e) {
>, <Line: +					V.viewport = e
>, <Line: +				}, F.$applyPlacement = function () {
>, <Line: +					if (R) {
>, <Line: +						var t = V.placement, n = /\s?auto?\s?/i, a = n.test(t);
>, <Line: +						a && (t = t.replace(n, '') || e.placement), R.addClass(V.placement);
>, <Line: +						var o = x(), i = R.prop('offsetWidth'), r = R.prop('offsetHeight');
>, <Line: +						if (F.$viewport = V.viewport && m(V.viewport.selector || V.viewport), a) {
>, <Line: +							var s = t, l = x(F.$viewport);
>, <Line: +							s.indexOf('bottom') >= 0 && o.bottom + r > l.bottom ? t = s.replace('bottom', 'top') : s.indexOf('top') >= 0 && o.top - r < l.top && (t = s.replace('top', 'bottom')), ('right' === s || 'bottom-left' === s || 'top-left' === s) && o.right + i > l.width ? t = 'right' === s ? 'left' : t.replace('left', 'right') : ('left' === s || 'bottom-right' === s || 'top-right' === s) && o.left - i < l.left && (t = 'left' === s ? 'right' : t.replace('right', 'left')), R.removeClass(s).addClass(t)
>, <Line: +						}
>, <Line: +						var u = T(t, o, i, r);
>, <Line: +						C(u, t)
>, <Line: +					}
>, <Line: +				}, F.$onKeyUp = function (e) {
>, <Line: +					27 === e.which && F.$isShown && (F.hide(), e.stopPropagation())
>, <Line: +				}, F.$onFocusKeyUp = function (e) {
>, <Line: +					27 === e.which && (i[0].blur(), e.stopPropagation())
>, <Line: +				}, F.$onFocusElementMouseDown = function (e) {
>, <Line: +					e.preventDefault(), e.stopPropagation(), F.$isShown ? i[0].blur() : i[0].focus()
>, <Line: +				};
>, <Line: +				var K = !1;
>, <Line: +				return F
>, <Line: +			}
>, <Line: +			function g(e) {
>, <Line: +				e.$$phase || e.$root && e.$root.$$phase || e.$digest()
>, <Line: +			}
>, <Line: +			function m(e, n) {
>, <Line: +				return angular.element((n || t).querySelectorAll(e))
>, <Line: +			}
>, <Line: +			var $ = (String.prototype.trim, 'createTouch'in n.document), h = angular.element(n.document);
>, <Line: +			return p
>, <Line: +		}]
>, <Line: +	}).directive('bsTooltip', ['$window', '$location', '$sce', '$tooltip', '$$rAF', function (e, t, n, a, o) {
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, t, i, r) {
>, <Line: +				var s = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (e) {
>, <Line: +					angular.isDefined(i[e]) && (s[e] = i[e])
>, <Line: +				});
>, <Line: +				var l = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container'], function (e) {
>, <Line: +					angular.isDefined(i[e]) && l.test(i[e]) && (s[e] = !1)
>, <Line: +				});
>, <Line: +				var u = t.attr('data-target');
>, <Line: +				angular.isDefined(u) && (l.test(u) ? s.target = !1 : s.target = u), e.hasOwnProperty('title') || (e.title = ''), i.$observe('title', function (t) {
>, <Line: +					if (angular.isDefined(t) || !e.hasOwnProperty('title')) {
>, <Line: +						var a = e.title;
>, <Line: +						e.title = n.trustAsHtml(t), angular.isDefined(a) && o(function () {
>, <Line: +							c && c.$applyPlacement()
>, <Line: +						})
>, <Line: +					}
>, <Line: +				}), i.bsTooltip && e.$watch(i.bsTooltip, function (t, n) {
>, <Line: +					angular.isObject(t) ? angular.extend(e, t) : e.title = t, angular.isDefined(n) && o(function () {
>, <Line: +						c && c.$applyPlacement()
>, <Line: +					})
>, <Line: +				}, !0), i.bsShow && e.$watch(i.bsShow, function (e, t) {
>, <Line: +					c && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|,?(tooltip),?/i)), e === !0 ? c.show() : c.hide())
>, <Line: +				}), i.bsEnabled && e.$watch(i.bsEnabled, function (e, t) {
>, <Line: +					c && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|1|,?(tooltip),?/i)), e === !1 ? c.setEnabled(!1) : c.setEnabled(!0))
>, <Line: +				}), i.viewport && e.$watch(i.viewport, function (e) {
>, <Line: +					c && angular.isDefined(e) && c.setViewport(e)
>, <Line: +				});
>, <Line: +				var c = a(t, s);
>, <Line: +				e.$on('$destroy', function () {
>, <Line: +					c && c.destroy(), s = null, c = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip']).provider('$timepicker', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'timepicker',
>, <Line: +			placement: 'bottom-left',
>, <Line: +			templateUrl: 'timepicker/timepicker.tpl.html',
>, <Line: +			trigger: 'focus',
>, <Line: +			container: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			delay: 0,
>, <Line: +			useNative: !0,
>, <Line: +			timeType: 'date',
>, <Line: +			timeFormat: 'shortTime',
>, <Line: +			timezone: null,
>, <Line: +			modelTimeFormat: null,
>, <Line: +			autoclose: !1,
>, <Line: +			minTime: -(1 / 0),
>, <Line: +			maxTime: +(1 / 0),
>, <Line: +			length: 5,
>, <Line: +			hourStep: 1,
>, <Line: +			minuteStep: 5,
>, <Line: +			secondStep: 5,
>, <Line: +			roundDisplay: !1,
>, <Line: +			iconUp: 'glyphicon glyphicon-chevron-up',
>, <Line: +			iconDown: 'glyphicon glyphicon-chevron-down',
>, <Line: +			arrowBehavior: 'pager'
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$document', '$rootScope', '$sce', '$dateFormatter', '$tooltip', '$timeout', function (t, n, a, o, i, r, s) {
>, <Line: +			function l(t, n, a) {
>, <Line: +				function o(e) {
>, <Line: +					var t = 6e4 * g.minuteStep;
>, <Line: +					return new Date(Math.floor(e.getTime() / t) * t)
>, <Line: +				}
>, <Line: +				function l(e, n) {
>, <Line: +					var a = e + n;
>, <Line: +					if (t[0].createTextRange) {
>, <Line: +						var o = t[0].createTextRange();
>, <Line: +						o.collapse(!0), o.moveStart('character', e), o.moveEnd('character', a), o.select()
>, <Line: +					} else t[0].setSelectionRange ? t[0].setSelectionRange(e, a) : angular.isUndefined(t[0].selectionStart) && (t[0].selectionStart = e, t[0].selectionEnd = a)
>, <Line: +				}
>, <Line: +				function d() {
>, <Line: +					t[0].focus()
>, <Line: +				}
>, <Line: +				var f = r(t, angular.extend({}, e, a)), p = a.scope, g = f.$options, m = f.$scope, $ = g.lang, h = function (e, t, n) {
>, <Line: +					return i.formatDate(e, t, $, n)
>, <Line: +				}, v = 0, w = g.roundDisplay ? o(new Date) : new Date, y = n.$dateValue || w, b = {
>, <Line: +					hour: y.getHours(),
>, <Line: +					meridian: y.getHours() < 12,
>, <Line: +					minute: y.getMinutes(),
>, <Line: +					second: y.getSeconds(),
>, <Line: +					millisecond: y.getMilliseconds()
>, <Line: +				}, D = i.getDatetimeFormat(g.timeFormat, $), k = i.hoursFormat(D), S = i.timeSeparator(D), x = i.minutesFormat(D), T = i.secondsFormat(D), C = i.showSeconds(D), E = i.showAM(D);
>, <Line: +				m.$iconUp = g.iconUp, m.$iconDown = g.iconDown, m.$select = function (e, t) {
>, <Line: +					f.select(e, t)
>, <Line: +				}, m.$moveIndex = function (e, t) {
>, <Line: +					f.$moveIndex(e, t)
>, <Line: +				}, m.$switchMeridian = function (e) {
>, <Line: +					f.switchMeridian(e)
>, <Line: +				}, f.update = function (e) {
>, <Line: +					angular.isDate(e) && !isNaN(e.getTime()) ? (f.$date = e, angular.extend(b, {
>, <Line: +						hour: e.getHours(),
>, <Line: +						minute: e.getMinutes(),
>, <Line: +						second: e.getSeconds(),
>, <Line: +						millisecond: e.getMilliseconds()
>, <Line: +					}), f.$build()) : f.$isBuilt || f.$build()
>, <Line: +				}, f.select = function (e, t, a) {
>, <Line: +					(!n.$dateValue || isNaN(n.$dateValue.getTime())) && (n.$dateValue = new Date(1970, 0, 1)), angular.isDate(e) || (e = new Date(e)), 0 === t ? n.$dateValue.setHours(e.getHours()) : 1 === t ? n.$dateValue.setMinutes(e.getMinutes()) : 2 === t && n.$dateValue.setSeconds(e.getSeconds()), n.$setViewValue(angular.copy(n.$dateValue)), n.$render(), g.autoclose && !a && s(function () {
>, <Line: +						f.hide(!0)
>, <Line: +					})
>, <Line: +				}, f.switchMeridian = function (e) {
>, <Line: +					if (n.$dateValue && !isNaN(n.$dateValue.getTime())) {
>, <Line: +						var t = (e || n.$dateValue).getHours();
>, <Line: +						n.$dateValue.setHours(12 > t ? t + 12 : t - 12), n.$setViewValue(angular.copy(n.$dateValue)), n.$render()
>, <Line: +					}
>, <Line: +				}, f.$build = function () {
>, <Line: +					var e, t, n = m.midIndex = parseInt(g.length / 2, 10), a = [];
>, <Line: +					for (e = 0; e < g.length; e++)t = new Date(1970, 0, 1, b.hour - (n - e) * g.hourStep), a.push({
>, <Line: +						date: t,
>, <Line: +						label: h(t, k),
>, <Line: +						selected: f.$date && f.$isSelected(t, 0),
>, <Line: +						disabled: f.$isDisabled(t, 0)
>, <Line: +					});
>, <Line: +					var o, i = [];
>, <Line: +					for (e = 0; e < g.length; e++)o = new Date(1970, 0, 1, 0, b.minute - (n - e) * g.minuteStep), i.push({
>, <Line: +						date: o,
>, <Line: +						label: h(o, x),
>, <Line: +						selected: f.$date && f.$isSelected(o, 1),
>, <Line: +						disabled: f.$isDisabled(o, 1)
>, <Line: +					});
>, <Line: +					var r, s = [];
>, <Line: +					for (e = 0; e < g.length; e++)r = new Date(1970, 0, 1, 0, 0, b.second - (n - e) * g.secondStep), s.push({
>, <Line: +						date: r,
>, <Line: +						label: h(r, T),
>, <Line: +						selected: f.$date && f.$isSelected(r, 2),
>, <Line: +						disabled: f.$isDisabled(r, 2)
>, <Line: +					});
>, <Line: +					var l = [];
>, <Line: +					for (e = 0; e < g.length; e++)C ? l.push([a[e], i[e], s[e]]) : l.push([a[e], i[e]]);
>, <Line: +					m.rows = l, m.showSeconds = C, m.showAM = E, m.isAM = (f.$date || a[n].date).getHours() < 12, m.timeSeparator = S, f.$isBuilt = !0
>, <Line: +				}, f.$isSelected = function (e, t) {
>, <Line: +					return f.$date ? 0 === t ? e.getHours() === f.$date.getHours() : 1 === t ? e.getMinutes() === f.$date.getMinutes() : 2 === t ? e.getSeconds() === f.$date.getSeconds() : void 0 : !1
>, <Line: +				}, f.$isDisabled = function (e, t) {
>, <Line: +					var n;
>, <Line: +					return 0 === t ? n = e.getTime() + 6e4 * b.minute + 1e3 * b.second : 1 === t ? n = e.getTime() + 36e5 * b.hour + 1e3 * b.second : 2 === t && (n = e.getTime() + 36e5 * b.hour + 6e4 * b.minute), n < 1 * g.minTime || n > 1 * g.maxTime
>, <Line: +				}, m.$arrowAction = function (e, t) {
>, <Line: +					'picker' === g.arrowBehavior ? f.$setTimeByStep(e, t) : f.$moveIndex(e, t)
>, <Line: +				}, f.$setTimeByStep = function (e, t) {
>, <Line: +					var n = new Date(f.$date || y), a = n.getHours(), o = n.getMinutes(), i = n.getSeconds();
>, <Line: +					0 === t ? n.setHours(a - parseInt(g.hourStep, 10) * e) : 1 === t ? n.setMinutes(o - parseInt(g.minuteStep, 10) * e) : 2 === t && n.setSeconds(i - parseInt(g.secondStep, 10) * e), f.select(n, t, !0)
>, <Line: +				}, f.$moveIndex = function (e, t) {
>, <Line: +					var n;
>, <Line: +					0 === t ? (n = new Date(1970, 0, 1, b.hour + e * g.length, b.minute, b.second), angular.extend(b, {hour: n.getHours()})) : 1 === t ? (n = new Date(1970, 0, 1, b.hour, b.minute + e * g.length * g.minuteStep, b.second), angular.extend(b, {minute: n.getMinutes()})) : 2 === t && (n = new Date(1970, 0, 1, b.hour, b.minute, b.second + e * g.length * g.secondStep), angular.extend(b, {second: n.getSeconds()})), f.$build()
>, <Line: +				}, f.$onMouseDown = function (e) {
>, <Line: +					if ('input' !== e.target.nodeName.toLowerCase() && e.preventDefault(), e.stopPropagation(), c) {
>, <Line: +						var t = angular.element(e.target);
>, <Line: +						'button' !== t[0].nodeName.toLowerCase() && (t = t.parent()), t.triggerHandler('click')
>, <Line: +					}
>, <Line: +				}, f.$onKeyDown = function (e) {
>, <Line: +					if (/(38|37|39|40|13)/.test(e.keyCode) && !e.shiftKey && !e.altKey) {
>, <Line: +						if (e.preventDefault(), e.stopPropagation(), 13 === e.keyCode)return void f.hide(!0);
>, <Line: +						var t = new Date(f.$date), n = t.getHours(), a = h(t, k).length, o = t.getMinutes(), i = h(t, x).length, r = t.getSeconds(), s = h(t, T).length, u = 1, c = /(37|39)/.test(e.keyCode), d = 2 + 1 * C + 1 * E;
>, <Line: +						c && (37 === e.keyCode ? v = 1 > v ? d - 1 : v - 1 : 39 === e.keyCode && (v = d - 1 > v ? v + 1 : 0));
>, <Line: +						var m = [0, a], $ = 0;
>, <Line: +						38 === e.keyCode && ($ = -1), 40 === e.keyCode && ($ = 1);
>, <Line: +						var w = 2 === v && C, y = 2 === v && !C || 3 === v && C;
>, <Line: +						0 === v ? (t.setHours(n + $ * parseInt(g.hourStep, 10)), a = h(t, k).length, m = [0, a]) : 1 === v ? (t.setMinutes(o + $ * parseInt(g.minuteStep, 10)), i = h(t, x).length, m = [a + u, i]) : w ? (t.setSeconds(r + $ * parseInt(g.secondStep, 10)), s = h(t, T).length, m = [a + u + i + u, s]) : y && (c || f.switchMeridian(), m = [a + u + i + u + (s + u) * C, 2]), f.select(t, v, !0), l(m[0], m[1]), p.$digest()
>, <Line: +					}
>, <Line: +				};
>, <Line: +				var M = f.init;
>, <Line: +				f.init = function () {
>, <Line: +					return u && g.useNative ? (t.prop('type', 'time'), void t.css('-webkit-appearance', 'textfield')) : (c && (t.prop('type', 'text'), t.attr('readonly', 'true'), t.on('click', d)), void M())
>, <Line: +				};
>, <Line: +				var A = f.destroy;
>, <Line: +				f.destroy = function () {
>, <Line: +					u && g.useNative && t.off('click', d), A()
>, <Line: +				};
>, <Line: +				var F = f.show;
>, <Line: +				f.show = function () {
>, <Line: +					!c && t.attr('readonly') || t.attr('disabled') || (F(), s(function () {
>, <Line: +						f.$element && f.$element.on(c ? 'touchstart' : 'mousedown', f.$onMouseDown), g.keyboard && t && t.on('keydown', f.$onKeyDown)
>, <Line: +					}, 0, !1))
>, <Line: +				};
>, <Line: +				var V = f.hide;
>, <Line: +				return f.hide = function (e) {
>, <Line: +					f.$isShown && (f.$element && f.$element.off(c ? 'touchstart' : 'mousedown', f.$onMouseDown), g.keyboard && t && t.off('keydown', f.$onKeyDown), V(e))
>, <Line: +				}, f
>, <Line: +			}
>, <Line: +			var u = /(ip(a|o)d|iphone|android)/gi.test(t.navigator.userAgent), c = 'createTouch'in t.document && u;
>, <Line: +			return e.lang || (e.lang = i.getDefaultLocale()), l.defaults = e, l
>, <Line: +		}]
>, <Line: +	}).directive('bsTimepicker', ['$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$timepicker', function (e, t, a, o, i, r) {
>, <Line: +		var s = r.defaults, l = /(ip(a|o)d|iphone|android)/gi.test(e.navigator.userAgent);
>, <Line: +		return {
>, <Line: +			restrict: 'EAC',
>, <Line: +			require: 'ngModel',
>, <Line: +			link: function (e, t, a, u) {
>, <Line: +				function c(e) {
>, <Line: +					if (angular.isDate(e)) {
>, <Line: +						var t = isNaN(f.minTime) || new Date(e.getTime()).setFullYear(1970, 0, 1) >= f.minTime, n = isNaN(f.maxTime) || new Date(e.getTime()).setFullYear(1970, 0, 1) <= f.maxTime, a = t && n;
>, <Line: +						u.$setValidity('date', a), u.$setValidity('min', t), u.$setValidity('max', n), a && (u.$dateValue = e)
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function d() {
>, <Line: +					return !u.$dateValue || isNaN(u.$dateValue.getTime()) ? '' : $(u.$dateValue, f.timeFormat)
>, <Line: +				}
>, <Line: +				var f = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (e) {
>, <Line: +					angular.isDefined(a[e]) && (f[e] = a[e])
>, <Line: +				});
>, <Line: +				var p = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (e) {
>, <Line: +					angular.isDefined(a[e]) && p.test(a[e]) && (f[e] = !1)
>, <Line: +				}), a.bsShow && e.$watch(a.bsShow, function (e, t) {
>, <Line: +					g && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|,?(timepicker),?/i)), e === !0 ? g.show() : g.hide())
>, <Line: +				}), l && (f.useNative || s.useNative) && (f.timeFormat = 'HH:mm');
>, <Line: +				var g = r(t, u, f);
>, <Line: +				f = g.$options;
>, <Line: +				var m = f.lang, $ = function (e, t, n) {
>, <Line: +					return o.formatDate(e, t, m, n)
>, <Line: +				}, h = i({format: f.timeFormat, lang: m});
>, <Line: +				angular.forEach(['minTime', 'maxTime'], function (e) {
>, <Line: +					angular.isDefined(a[e]) && a.$observe(e, function (t) {
>, <Line: +						g.$options[e] = h.getTimeForAttribute(e, t), !isNaN(g.$options[e]) && g.$build(), c(u.$dateValue)
>, <Line: +					})
>, <Line: +				}), e.$watch(a.ngModel, function (e, t) {
>, <Line: +					g.update(u.$dateValue)
>, <Line: +				}, !0), u.$parsers.unshift(function (e) {
>, <Line: +					var t;
>, <Line: +					if (!e)return u.$setValidity('date', !0), null;
>, <Line: +					var a = angular.isDate(e) ? e : h.parse(e, u.$dateValue);
>, <Line: +					return !a || isNaN(a.getTime()) ? (u.$setValidity('date', !1), n) : (c(a), 'string' === f.timeType ? (t = h.timezoneOffsetAdjust(a, f.timezone, !0), $(t, f.modelTimeFormat || f.timeFormat)) : (t = h.timezoneOffsetAdjust(u.$dateValue, f.timezone, !0), 'number' === f.timeType ? t.getTime() : 'unix' === f.timeType ? t.getTime() / 1e3 : 'iso' === f.timeType ? t.toISOString() : new Date(t)))
>, <Line: +				}), u.$formatters.push(function (e) {
>, <Line: +					var t;
>, <Line: +					return t = angular.isUndefined(e) || null === e ? NaN : angular.isDate(e) ? e : 'string' === f.timeType ? h.parse(e, null, f.modelTimeFormat) : 'unix' === f.timeType ? new Date(1e3 * e) : new Date(e), u.$dateValue = h.timezoneOffsetAdjust(t, f.timezone), d()
>, <Line: +				}), u.$render = function () {
>, <Line: +					t.val(d())
>, <Line: +				}, e.$on('$destroy', function () {
>, <Line: +					g && g.destroy(), f = null, g = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.tab', []).provider('$tab', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			template: 'tab/tab.tpl.html',
>, <Line: +			navClass: 'nav-tabs',
>, <Line: +			activeClass: 'active'
>, <Line: +		}, t = this.controller = function (t, n, a) {
>, <Line: +			var o = this;
>, <Line: +			o.$options = angular.copy(e), angular.forEach(['animation', 'navClass', 'activeClass'], function (e) {
>, <Line: +				angular.isDefined(a[e]) && (o.$options[e] = a[e])
>, <Line: +			}), t.$navClass = o.$options.navClass, t.$activeClass = o.$options.activeClass, o.$panes = t.$panes = [], o.$activePaneChangeListeners = o.$viewChangeListeners = [], o.$push = function (e) {
>, <Line: +				angular.isUndefined(o.$panes.$active) && t.$setActive(e.name || 0), o.$panes.push(e)
>, <Line: +			}, o.$remove = function (e) {
>, <Line: +				var t, n = o.$panes.indexOf(e), a = o.$panes.$active;
>, <Line: +				t = angular.isString(a) ? o.$panes.map(function (e) {
>, <Line: +					return e.name
>, <Line: +				}).indexOf(a) : o.$panes.$active, o.$panes.splice(n, 1), t > n ? t-- : n === t && t === o.$panes.length && t--, t >= 0 && t < o.$panes.length ? o.$setActive(o.$panes[t].name || t) : o.$setActive()
>, <Line: +			}, o.$setActive = t.$setActive = function (e) {
>, <Line: +				o.$panes.$active = e, o.$activePaneChangeListeners.forEach(function (e) {
>, <Line: +					e()
>, <Line: +				})
>, <Line: +			}, o.$isActive = t.$isActive = function (e, t) {
>, <Line: +				return o.$panes.$active === e.name || o.$panes.$active === t
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			var n = {};
>, <Line: +			return n.defaults = e, n.controller = t, n
>, <Line: +		}
>, <Line: +	}).directive('bsTabs', ['$window', '$animate', '$tab', '$parse', function (e, t, n, a) {
>, <Line: +		var o = n.defaults;
>, <Line: +		return {
>, <Line: +			require: ['?ngModel', 'bsTabs'],
>, <Line: +			transclude: !0,
>, <Line: +			scope: !0,
>, <Line: +			controller: ['$scope', '$element', '$attrs', n.controller],
>, <Line: +			templateUrl: function (e, t) {
>, <Line: +				return t.template || o.template
>, <Line: +			},
>, <Line: +			link: function (e, t, n, o) {
>, <Line: +				var i = o[0], r = o[1];
>, <Line: +				if (i && (r.$activePaneChangeListeners.push(function () {
>, <Line: +						i.$setViewValue(r.$panes.$active)
>, <Line: +					}), i.$formatters.push(function (e) {
>, <Line: +						return r.$setActive(e), e
>, <Line: +					})), n.bsActivePane) {
>, <Line: +					var s = a(n.bsActivePane);
>, <Line: +					r.$activePaneChangeListeners.push(function () {
>, <Line: +						s.assign(e, r.$panes.$active)
>, <Line: +					}), e.$watch(n.bsActivePane, function (e, t) {
>, <Line: +						r.$setActive(e)
>, <Line: +					}, !0)
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).directive('bsPane', ['$window', '$animate', '$sce', function (e, t, n) {
>, <Line: +		return {
>, <Line: +			require: ['^?ngModel', '^bsTabs'],
>, <Line: +			scope: !0,
>, <Line: +			link: function (e, a, o, i) {
>, <Line: +				function r() {
>, <Line: +					var n = s.$panes.indexOf(e);
>, <Line: +					t[s.$isActive(e, n) ? 'addClass' : 'removeClass'](a, s.$options.activeClass)
>, <Line: +				}
>, <Line: +				var s = (i[0], i[1]);
>, <Line: +				a.addClass('tab-pane'), o.$observe('title', function (t, a) {
>, <Line: +					e.title = n.trustAsHtml(t)
>, <Line: +				}), e.name = o.name, s.$options.animation && a.addClass(s.$options.animation), o.$observe('disabled', function (t, n) {
>, <Line: +					e.disabled = e.$eval(t)
>, <Line: +				}), s.$push(e), e.$on('$destroy', function () {
>, <Line: +					s.$remove(e)
>, <Line: +				}), s.$activePaneChangeListeners.push(function () {
>, <Line: +					r()
>, <Line: +				}), r()
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions']).provider('$select', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'select',
>, <Line: +			prefixEvent: '$select',
>, <Line: +			placement: 'bottom-left',
>, <Line: +			templateUrl: 'select/select.tpl.html',
>, <Line: +			trigger: 'focus',
>, <Line: +			container: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			delay: 0,
>, <Line: +			multiple: !1,
>, <Line: +			allNoneButtons: !1,
>, <Line: +			sort: !0,
>, <Line: +			caretHtml: '&nbsp;<span class="caret"></span>',
>, <Line: +			placeholder: 'Choose among the following...',
>, <Line: +			allText: 'All',
>, <Line: +			noneText: 'None',
>, <Line: +			maxLength: 3,
>, <Line: +			maxLengthHtml: 'selected',
>, <Line: +			iconCheckmark: 'glyphicon glyphicon-ok'
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$document', '$rootScope', '$tooltip', '$timeout', function (t, n, a, o, i) {
>, <Line: +			function r(a, r, s) {
>, <Line: +				var u = {}, c = angular.extend({}, e, s);
>, <Line: +				u = o(a, c);
>, <Line: +				var d = u.$scope;
>, <Line: +				d.$matches = [], c.multiple ? d.$activeIndex = [] : d.$activeIndex = -1, d.$isMultiple = c.multiple, d.$showAllNoneButtons = c.allNoneButtons && c.multiple, d.$iconCheckmark = c.iconCheckmark, d.$allText = c.allText, d.$noneText = c.noneText, d.$activate = function (e) {
>, <Line: +					d.$$postDigest(function () {
>, <Line: +						u.activate(e)
>, <Line: +					})
>, <Line: +				}, d.$select = function (e, t) {
>, <Line: +					d.$$postDigest(function () {
>, <Line: +						u.select(e)
>, <Line: +					})
>, <Line: +				}, d.$isVisible = function () {
>, <Line: +					return u.$isVisible()
>, <Line: +				}, d.$isActive = function (e) {
>, <Line: +					return u.$isActive(e)
>, <Line: +				}, d.$selectAll = function () {
>, <Line: +					for (var e = 0; e < d.$matches.length; e++)d.$isActive(e) || d.$select(e)
>, <Line: +				}, d.$selectNone = function () {
>, <Line: +					for (var e = 0; e < d.$matches.length; e++)d.$isActive(e) && d.$select(e)
>, <Line: +				}, u.update = function (e) {
>, <Line: +					d.$matches = e, u.$updateActiveIndex()
>, <Line: +				}, u.activate = function (e) {
>, <Line: +					return c.multiple ? (u.$isActive(e) ? d.$activeIndex.splice(d.$activeIndex.indexOf(e), 1) : d.$activeIndex.push(e), c.sort && d.$activeIndex.sort(function (e, t) {
>, <Line: +						return e - t
>, <Line: +					})) : d.$activeIndex = e, d.$activeIndex
>, <Line: +				}, u.select = function (e) {
>, <Line: +					var t = d.$matches[e].value;
>, <Line: +					d.$apply(function () {
>, <Line: +						u.activate(e), c.multiple ? r.$setViewValue(d.$activeIndex.map(function (e) {
>, <Line: +							return angular.isUndefined(d.$matches[e]) ? null : d.$matches[e].value
>, <Line: +						})) : (r.$setViewValue(t), u.hide())
>, <Line: +					}), d.$emit(c.prefixEvent + '.select', t, e, u)
>, <Line: +				}, u.$updateActiveIndex = function () {
>, <Line: +					r.$modelValue && d.$matches.length ? c.multiple && angular.isArray(r.$modelValue) ? d.$activeIndex = r.$modelValue.map(function (e) {
>, <Line: +						return u.$getIndex(e)
>, <Line: +					}) : d.$activeIndex = u.$getIndex(r.$modelValue) : d.$activeIndex >= d.$matches.length ? d.$activeIndex = c.multiple ? [] : 0 : r.$modelValue || c.multiple || (d.$activeIndex = -1)
>, <Line: +				}, u.$isVisible = function () {
>, <Line: +					return c.minLength && r ? d.$matches.length && r.$viewValue.length >= c.minLength : d.$matches.length
>, <Line: +				}, u.$isActive = function (e) {
>, <Line: +					return c.multiple ? -1 !== d.$activeIndex.indexOf(e) : d.$activeIndex === e
>, <Line: +				}, u.$getIndex = function (e) {
>, <Line: +					var t = d.$matches.length, n = t;
>, <Line: +					if (t) {
>, <Line: +						for (n = t; n-- && d.$matches[n].value !== e;);
>, <Line: +						if (!(0 > n))return n
>, <Line: +					}
>, <Line: +				}, u.$onMouseDown = function (e) {
>, <Line: +					if (e.preventDefault(), e.stopPropagation(), l) {
>, <Line: +						var t = angular.element(e.target);
>, <Line: +						t.triggerHandler('click')
>, <Line: +					}
>, <Line: +				}, u.$onKeyDown = function (e) {
>, <Line: +					return /(9|13|38|40)/.test(e.keyCode) ? (9 !== e.keyCode && (e.preventDefault(), e.stopPropagation()), c.multiple && 9 === e.keyCode ? u.hide() : c.multiple || 13 !== e.keyCode && 9 !== e.keyCode ? void(c.multiple || (38 === e.keyCode && d.$activeIndex > 0 ? d.$activeIndex-- : 38 === e.keyCode && d.$activeIndex < 0 ? d.$activeIndex = d.$matches.length - 1 : 40 === e.keyCode && d.$activeIndex < d.$matches.length - 1 ? d.$activeIndex++ : angular.isUndefined(d.$activeIndex) && (d.$activeIndex = 0), d.$digest())) : u.select(d.$activeIndex)) : void 0
>, <Line: +				}, u.$isIE = function () {
>, <Line: +					var e = t.navigator.userAgent;
>, <Line: +					return e.indexOf('MSIE ') > 0 || e.indexOf('Trident/') > 0 || e.indexOf('Edge/') > 0
>, <Line: +				}, u.$selectScrollFix = function (e) {
>, <Line: +					'UL' === n[0].activeElement.tagName && (e.preventDefault(), e.stopImmediatePropagation(), e.target.focus())
>, <Line: +				};
>, <Line: +				var f = u.show;
>, <Line: +				u.show = function () {
>, <Line: +					f(), c.multiple && u.$element.addClass('select-multiple'), i(function () {
>, <Line: +						u.$element.on(l ? 'touchstart' : 'mousedown', u.$onMouseDown), c.keyboard && a.on('keydown', u.$onKeyDown)
>, <Line: +					}, 0, !1)
>, <Line: +				};
>, <Line: +				var p = u.hide;
>, <Line: +				return u.hide = function () {
>, <Line: +					c.multiple || r.$modelValue || (d.$activeIndex = -1), u.$element.off(l ? 'touchstart' : 'mousedown', u.$onMouseDown), c.keyboard && a.off('keydown', u.$onKeyDown), p(!0)
>, <Line: +				}, u
>, <Line: +			}
>, <Line: +			var s = (angular.element(t.document.body), /(ip(a|o)d|iphone|android)/gi.test(t.navigator.userAgent)), l = 'createTouch'in t.document && s;
>, <Line: +			return r.defaults = e, r
>, <Line: +		}]
>, <Line: +	}).directive('bsSelect', ['$window', '$parse', '$q', '$select', '$parseOptions', function (e, t, n, a, o) {
>, <Line: +		var i = a.defaults;
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', require: 'ngModel', link: function (e, t, n, r) {
>, <Line: +				var s = {scope: e, placeholder: i.placeholder};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && (s[e] = n[e])
>, <Line: +				});
>, <Line: +				var l = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && l.test(n[e]) && (s[e] = !1)
>, <Line: +				});
>, <Line: +				var u = t.attr('data-multiple');
>, <Line: +				if (angular.isDefined(u) && (l.test(u) ? s.multiple = !1 : s.multiple = u), 'select' === t[0].nodeName.toLowerCase()) {
>, <Line: +					var c = t;
>, <Line: +					c.css('display', 'none'), t = angular.element('<button type="button" class="btn btn-default"></button>'), c.after(t)
>, <Line: +				}
>, <Line: +				var d = o(n.bsOptions), f = a(t, r, s);
>, <Line: +				f.$isIE() && t[0].addEventListener('blur', f.$selectScrollFix);
>, <Line: +				var p = d.$match[7].replace(/\|.+/, '').trim();
>, <Line: +				e.$watchCollection(p, function (t, n) {
>, <Line: +					d.valuesFn(e, r).then(function (e) {
>, <Line: +						f.update(e), r.$render()
>, <Line: +					})
>, <Line: +				}), e.$watch(n.ngModel, function (e, t) {
>, <Line: +					f.$updateActiveIndex(), r.$render()
>, <Line: +				}, !0), r.$render = function () {
>, <Line: +					var e, n;
>, <Line: +					s.multiple && angular.isArray(r.$modelValue) ? (e = r.$modelValue.map(function (e) {
>, <Line: +						return n = f.$getIndex(e), angular.isDefined(n) ? f.$scope.$matches[n].label : !1
>, <Line: +					}).filter(angular.isDefined), e = e.length > (s.maxLength || i.maxLength) ? e.length + ' ' + (s.maxLengthHtml || i.maxLengthHtml) : e.join(', ')) : (n = f.$getIndex(r.$modelValue), e = angular.isDefined(n) ? f.$scope.$matches[n].label : !1), t.html((e ? e : s.placeholder) + (s.caretHtml ? s.caretHtml : i.caretHtml))
>, <Line: +				}, s.multiple && (r.$isEmpty = function (e) {
>, <Line: +					return !e || 0 === e.length
>, <Line: +				}), e.$on('$destroy', function () {
>, <Line: +					f && f.destroy(), s = null, f = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions']).provider('$scrollspy', function () {
>, <Line: +		var e = this.$$spies = {}, n = this.defaults = {
>, <Line: +			debounce: 150,
>, <Line: +			throttle: 100,
>, <Line: +			offset: 100
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$document', '$rootScope', 'dimensions', 'debounce', 'throttle', function (a, o, i, r, s, l) {
>, <Line: +			function u(e, t) {
>, <Line: +				return e[0].nodeName && e[0].nodeName.toLowerCase() === t.toLowerCase()
>, <Line: +			}
>, <Line: +			function c(o) {
>, <Line: +				var c = angular.extend({}, n, o);
>, <Line: +				c.element || (c.element = p);
>, <Line: +				var g = u(c.element, 'body'), m = g ? d : c.element, $ = g ? 'window' : c.id;
>, <Line: +				if (e[$])return e[$].$$count++, e[$];
>, <Line: +				var h, v, w, y, b, D, k, S, x = {}, T = x.$trackedElements = [], C = [];
>, <Line: +				return x.init = function () {
>, <Line: +					this.$$count = 1, y = s(this.checkPosition, c.debounce), b = l(this.checkPosition, c.throttle), m.on('click', this.checkPositionWithEventLoop), d.on('resize', y), m.on('scroll', b), D = s(this.checkOffsets, c.debounce), h = i.$on('$viewContentLoaded', D), v = i.$on('$includeContentLoaded', D), D(), $ && (e[$] = x)
>, <Line: +				}, x.destroy = function () {
>, <Line: +					this.$$count--, this.$$count > 0 || (m.off('click', this.checkPositionWithEventLoop), d.off('resize', y), m.off('scroll', b), h(), v(), $ && delete e[$])
>, <Line: +				}, x.checkPosition = function () {
>, <Line: +					if (C.length) {
>, <Line: +						if (S = (g ? a.pageYOffset : m.prop('scrollTop')) || 0, k = Math.max(a.innerHeight, f.prop('clientHeight')), S < C[0].offsetTop && w !== C[0].target)return x.$activateElement(C[0]);
>, <Line: +						for (var e = C.length; e--;)if (!angular.isUndefined(C[e].offsetTop) && null !== C[e].offsetTop && w !== C[e].target && !(S < C[e].offsetTop || C[e + 1] && S > C[e + 1].offsetTop))return x.$activateElement(C[e])
>, <Line: +					}
>, <Line: +				}, x.checkPositionWithEventLoop = function () {
>, <Line: +					setTimeout(x.checkPosition, 1)
>, <Line: +				}, x.$activateElement = function (e) {
>, <Line: +					if (w) {
>, <Line: +						var t = x.$getTrackedElement(w);
>, <Line: +						t && (t.source.removeClass('active'), u(t.source, 'li') && u(t.source.parent().parent(), 'li') && t.source.parent().parent().removeClass('active'))
>, <Line: +					}
>, <Line: +					w = e.target, e.source.addClass('active'), u(e.source, 'li') && u(e.source.parent().parent(), 'li') && e.source.parent().parent().addClass('active')
>, <Line: +				}, x.$getTrackedElement = function (e) {
>, <Line: +					return T.filter(function (t) {
>, <Line: +						return t.target === e
>, <Line: +					})[0]
>, <Line: +				}, x.checkOffsets = function () {
>, <Line: +					angular.forEach(T, function (e) {
>, <Line: +						var n = t.querySelector(e.target);
>, <Line: +						e.offsetTop = n ? r.offset(n).top : null, c.offset && null !== e.offsetTop && (e.offsetTop -= 1 * c.offset)
>, <Line: +					}), C = T.filter(function (e) {
>, <Line: +						return null !== e.offsetTop
>, <Line: +					}).sort(function (e, t) {
>, <Line: +						return e.offsetTop - t.offsetTop
>, <Line: +					}), y()
>, <Line: +				}, x.trackElement = function (e, t) {
>, <Line: +					T.push({target: e, source: t})
>, <Line: +				}, x.untrackElement = function (e, t) {
>, <Line: +					for (var n, a = T.length; a--;)if (T[a].target === e && T[a].source === t) {
>, <Line: +						n = a;
>, <Line: +						break
>, <Line: +					}
>, <Line: +					T = T.splice(n, 1)
>, <Line: +				}, x.activate = function (e) {
>, <Line: +					T[e].addClass('active')
>, <Line: +				}, x.init(), x
>, <Line: +			}
>, <Line: +			var d = angular.element(a), f = angular.element(o.prop('documentElement')), p = angular.element(a.document.body);
>, <Line: +			return c
>, <Line: +		}]
>, <Line: +	}).directive('bsScrollspy', ['$rootScope', 'debounce', 'dimensions', '$scrollspy', function (e, t, n, a) {
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', link: function (e, t, n) {
>, <Line: +				var o = {scope: e};
>, <Line: +				angular.forEach(['offset', 'target'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && (o[e] = n[e])
>, <Line: +				});
>, <Line: +				var i = a(o);
>, <Line: +				i.trackElement(o.target, t), e.$on('$destroy', function () {
>, <Line: +					i && (i.untrackElement(o.target, t), i.destroy()), o = null, i = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).directive('bsScrollspyList', ['$rootScope', 'debounce', 'dimensions', '$scrollspy', function (e, t, n, a) {
>, <Line: +		return {
>, <Line: +			restrict: 'A', compile: function (e, t) {
>, <Line: +				var n = e[0].querySelectorAll('li > a[href]');
>, <Line: +				angular.forEach(n, function (e) {
>, <Line: +					var t = angular.element(e);
>, <Line: +					t.parent().attr('bs-scrollspy', '').attr('data-target', t.attr('href'))
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip']).provider('$popover', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			customClass: '',
>, <Line: +			container: !1,
>, <Line: +			target: !1,
>, <Line: +			placement: 'right',
>, <Line: +			templateUrl: 'popover/popover.tpl.html',
>, <Line: +			contentTemplate: !1,
>, <Line: +			trigger: 'click',
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			title: '',
>, <Line: +			content: '',
>, <Line: +			delay: 0,
>, <Line: +			autoClose: !1
>, <Line: +		};
>, <Line: +		this.$get = ['$tooltip', function (t) {
>, <Line: +			function n(n, a) {
>, <Line: +				var o = angular.extend({}, e, a), i = t(n, o);
>, <Line: +				return o.content && (i.$scope.content = o.content), i
>, <Line: +			}
>, <Line: +			return n
>, <Line: +		}]
>, <Line: +	}).directive('bsPopover', ['$window', '$sce', '$popover', function (e, t, n) {
>, <Line: +		var a = e.requestAnimationFrame || e.setTimeout;
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, o, i) {
>, <Line: +				var r = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function (e) {
>, <Line: +					angular.isDefined(i[e]) && (r[e] = i[e])
>, <Line: +				});
>, <Line: +				var s = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container', 'autoClose'], function (e) {
>, <Line: +					angular.isDefined(i[e]) && s.test(i[e]) && (r[e] = !1)
>, <Line: +				});
>, <Line: +				var l = o.attr('data-target');
>, <Line: +				angular.isDefined(l) && (s.test(l) ? r.target = !1 : r.target = l), angular.forEach(['title', 'content'], function (n) {
>, <Line: +					i[n] && i.$observe(n, function (o, i) {
>, <Line: +						e[n] = t.trustAsHtml(o), angular.isDefined(i) && a(function () {
>, <Line: +							u && u.$applyPlacement()
>, <Line: +						})
>, <Line: +					})
>, <Line: +				}), i.bsPopover && e.$watch(i.bsPopover, function (t, n) {
>, <Line: +					angular.isObject(t) ? angular.extend(e, t) : e.content = t, angular.isDefined(n) && a(function () {
>, <Line: +						u && u.$applyPlacement()
>, <Line: +					})
>, <Line: +				}, !0), i.bsShow && e.$watch(i.bsShow, function (e, t) {
>, <Line: +					u && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|,?(popover),?/i)), e === !0 ? u.show() : u.hide())
>, <Line: +				}), i.viewport && e.$watch(i.viewport, function (e) {
>, <Line: +					u && angular.isDefined(e) && u.setViewport(e)
>, <Line: +				});
>, <Line: +				var u = n(o, r);
>, <Line: +				e.$on('$destroy', function () {
>, <Line: +					u && u.destroy(), r = null, u = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.navbar', []).provider('$navbar', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			activeClass: 'active',
>, <Line: +			routeAttr: 'data-match-route',
>, <Line: +			strict: !1
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			return {defaults: e}
>, <Line: +		}
>, <Line: +	}).directive('bsNavbar', ['$window', '$location', '$navbar', function (e, t, n) {
>, <Line: +		var a = n.defaults;
>, <Line: +		return {
>, <Line: +			restrict: 'A', link: function (e, n, o, i) {
>, <Line: +				var r = angular.copy(a);
>, <Line: +				angular.forEach(Object.keys(a), function (e) {
>, <Line: +					angular.isDefined(o[e]) && (r[e] = o[e])
>, <Line: +				}), e.$watch(function () {
>, <Line: +					return t.path()
>, <Line: +				}, function (e, t) {
>, <Line: +					var a = n[0].querySelectorAll('li[' + r.routeAttr + ']');
>, <Line: +					angular.forEach(a, function (t) {
>, <Line: +						var n = angular.element(t), a = n.attr(r.routeAttr).replace('/', '\\/');
>, <Line: +						r.strict && (a = '^' + a + '$');
>, <Line: +						var o = new RegExp(a, 'i');
>, <Line: +						o.test(e) ? n.addClass(r.activeClass) : n.removeClass(r.activeClass)
>, <Line: +					})
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions']).provider('$modal', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			backdropAnimation: 'am-fade',
>, <Line: +			prefixClass: 'modal',
>, <Line: +			prefixEvent: 'modal',
>, <Line: +			placement: 'top',
>, <Line: +			templateUrl: 'modal/modal.tpl.html',
>, <Line: +			template: '',
>, <Line: +			contentTemplate: !1,
>, <Line: +			container: !1,
>, <Line: +			element: null,
>, <Line: +			backdrop: !0,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			show: !0
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$rootScope', '$bsCompiler', '$animate', '$timeout', '$sce', 'dimensions', function (n, a, o, i, r, s, l) {
>, <Line: +			function u(t) {
>, <Line: +				function n() {
>, <Line: +					k.$emit(b.prefixEvent + '.show', y)
>, <Line: +				}
>, <Line: +				function r() {
>, <Line: +					k.$emit(b.prefixEvent + '.hide', y), g.removeClass(b.prefixClass + '-open'), b.animation && g.removeClass(b.prefixClass + '-with-' + b.animation)
>, <Line: +				}
>, <Line: +				function l() {
>, <Line: +					b.backdrop && (x.on('click', h), C.on('click', h), C.on('wheel', v))
>, <Line: +				}
>, <Line: +				function u() {
>, <Line: +					b.backdrop && (x.off('click', h), C.off('click', h), C.off('wheel', v))
>, <Line: +				}
>, <Line: +				function m() {
>, <Line: +					b.keyboard && x.on('keyup', y.$onKeyUp)
>, <Line: +				}
>, <Line: +				function $() {
>, <Line: +					b.keyboard && x.off('keyup', y.$onKeyUp)
>, <Line: +				}
>, <Line: +				function h(e) {
>, <Line: +					e.target === e.currentTarget && ('static' === b.backdrop ? y.focus() : y.hide())
>, <Line: +				}
>, <Line: +				function v(e) {
>, <Line: +					e.preventDefault()
>, <Line: +				}
>, <Line: +				function w() {
>, <Line: +					y.$isShown && null !== x && (u(), $()), T && (T.$destroy(), T = null), x && (x.remove(), x = y.$element = null)
>, <Line: +				}
>, <Line: +				var y = {}, b = y.$options = angular.extend({}, e, t), D = y.$promise = o.compile(b), k = y.$scope = b.scope && b.scope.$new() || a.$new();
>, <Line: +				b.element || b.container || (b.container = 'body'), y.$id = b.id || b.element && b.element.attr('id') || '', f(['title', 'content'], function (e) {
>, <Line: +					b[e] && (k[e] = s.trustAsHtml(b[e]))
>, <Line: +				}), k.$hide = function () {
>, <Line: +					k.$$postDigest(function () {
>, <Line: +						y.hide()
>, <Line: +					})
>, <Line: +				}, k.$show = function () {
>, <Line: +					k.$$postDigest(function () {
>, <Line: +						y.show()
>, <Line: +					})
>, <Line: +				}, k.$toggle = function () {
>, <Line: +					k.$$postDigest(function () {
>, <Line: +						y.toggle()
>, <Line: +					})
>, <Line: +				}, y.$isShown = k.$isShown = !1;
>, <Line: +				var S, x, T, C = angular.element('<div class="' + b.prefixClass + '-backdrop"/>');
>, <Line: +				return C.css({
>, <Line: +					position: 'fixed',
>, <Line: +					top: '0px',
>, <Line: +					left: '0px',
>, <Line: +					bottom: '0px',
>, <Line: +					right: '0px',
>, <Line: +					'z-index': 1038
>, <Line: +				}), D.then(function (e) {
>, <Line: +					S = e, y.init()
>, <Line: +				}), y.init = function () {
>, <Line: +					b.show && k.$$postDigest(function () {
>, <Line: +						y.show()
>, <Line: +					})
>, <Line: +				}, y.destroy = function () {
>, <Line: +					w(), C && (C.remove(), C = null), k.$destroy()
>, <Line: +				}, y.show = function () {
>, <Line: +					if (!y.$isShown) {
>, <Line: +						var e, t;
>, <Line: +						if (angular.isElement(b.container) ? (e = b.container, t = b.container[0].lastChild ? angular.element(b.container[0].lastChild) : null) : b.container ? (e = d(b.container), t = e[0] && e[0].lastChild ? angular.element(e[0].lastChild) : null) : (e = null, t = b.element), x && w(), T = y.$scope.$new(), x = y.$element = S.link(T, function (e, t) {
>, <Line: +							}), !k.$emit(b.prefixEvent + '.show.before', y).defaultPrevented) {
>, <Line: +							x.css({display: 'block'}).addClass(b.placement), b.animation && (b.backdrop && C.addClass(b.backdropAnimation), x.addClass(b.animation)), b.backdrop && i.enter(C, g, null), angular.version.minor <= 2 ? i.enter(x, e, t, n) : i.enter(x, e, t).then(n), y.$isShown = k.$isShown = !0, c(k);
>, <Line: +							var a = x[0];
>, <Line: +							p(function () {
>, <Line: +								a.focus()
>, <Line: +							}), g.addClass(b.prefixClass + '-open'), b.animation && g.addClass(b.prefixClass + '-with-' + b.animation), l(), m()
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}, y.hide = function () {
>, <Line: +					y.$isShown && (k.$emit(b.prefixEvent + '.hide.before', y).defaultPrevented || (angular.version.minor <= 2 ? i.leave(x, r) : i.leave(x).then(r), b.backdrop && i.leave(C), y.$isShown = k.$isShown = !1, c(k), u(), $()))
>, <Line: +				}, y.toggle = function () {
>, <Line: +					y.$isShown ? y.hide() : y.show()
>, <Line: +				}, y.focus = function () {
>, <Line: +					x[0].focus()
>, <Line: +				}, y.$onKeyUp = function (e) {
>, <Line: +					27 === e.which && y.$isShown && (y.hide(), e.stopPropagation())
>, <Line: +				}, y
>, <Line: +			}
>, <Line: +			function c(e) {
>, <Line: +				e.$$phase || e.$root && e.$root.$$phase || e.$digest()
>, <Line: +			}
>, <Line: +			function d(e, n) {
>, <Line: +				return angular.element((n || t).querySelectorAll(e))
>, <Line: +			}
>, <Line: +			var f = angular.forEach, p = (String.prototype.trim, n.requestAnimationFrame || n.setTimeout), g = angular.element(n.document.body);
>, <Line: +			return u
>, <Line: +		}]
>, <Line: +	}).directive('bsModal', ['$window', '$sce', '$modal', function (e, t, n) {
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, a, o, i) {
>, <Line: +				var r = {scope: e, element: a, show: !1};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && (r[e] = o[e])
>, <Line: +				});
>, <Line: +				var s = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && s.test(o[e]) && (r[e] = !1)
>, <Line: +				}), angular.forEach(['title', 'content'], function (n) {
>, <Line: +					o[n] && o.$observe(n, function (a, o) {
>, <Line: +						e[n] = t.trustAsHtml(a)
>, <Line: +					})
>, <Line: +				}), o.bsModal && e.$watch(o.bsModal, function (t, n) {
>, <Line: +					angular.isObject(t) ? angular.extend(e, t) : e.content = t
>, <Line: +				}, !0);
>, <Line: +				var l = n(r);
>, <Line: +				a.on(o.trigger || 'click', l.toggle), e.$on('$destroy', function () {
>, <Line: +					l && l.destroy(), r = null, l = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.version.minor < 3 && angular.version.dot < 14 && angular.module('ng').factory('$$rAF', ['$window', '$timeout', function (e, t) {
>, <Line: +		var n = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame, a = e.cancelAnimationFrame || e.webkitCancelAnimationFrame || e.mozCancelAnimationFrame || e.webkitCancelRequestAnimationFrame, o = !!n, i = o ? function (e) {
>, <Line: +			var t = n(e);
>, <Line: +			return function () {
>, <Line: +				a(t)
>, <Line: +			}
>, <Line: +		} : function (e) {
>, <Line: +			var n = t(e, 16.66, !1);
>, <Line: +			return function () {
>, <Line: +				t.cancel(n)
>, <Line: +			}
>, <Line: +		};
>, <Line: +		return i.supported = o, i
>, <Line: +	}]), angular.module('mgcrea.ngStrap.helpers.parseOptions', []).provider('$parseOptions', function () {
>, <Line: +		var e = this.defaults = {regexp: /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/};
>, <Line: +		this.$get = ['$parse', '$q', function (t, n) {
>, <Line: +			function a(a, o) {
>, <Line: +				function i(e, t) {
>, <Line: +					return e.map(function (e, n) {
>, <Line: +						var a, o, i = {};
>, <Line: +						return i[c] = e, a = u(t, i), o = p(t, i), {
>, <Line: +							label: a,
>, <Line: +							value: o,
>, <Line: +							index: n
>, <Line: +						}
>, <Line: +					})
>, <Line: +				}
>, <Line: +				var r = {}, s = angular.extend({}, e, o);
>, <Line: +				r.$values = [];
>, <Line: +				var l, u, c, d, f, p, g;
>, <Line: +				return r.init = function () {
>, <Line: +					r.$match = l = a.match(s.regexp), u = t(l[2] || l[1]), c = l[4] || l[6], d = l[5], f = t(l[3] || ''), p = t(l[2] ? l[1] : c), g = t(l[7])
>, <Line: +				}, r.valuesFn = function (e, t) {
>, <Line: +					return n.when(g(e, t)).then(function (t) {
>, <Line: +						return angular.isArray(t) || (t = []), r.$values = t.length ? i(t, e) : [], r.$values
>, <Line: +					})
>, <Line: +				}, r.displayValue = function (e) {
>, <Line: +					var t = {};
>, <Line: +					return t[c] = e, u(t)
>, <Line: +				}, r.init(), r
>, <Line: +			}
>, <Line: +			return a
>, <Line: +		}]
>, <Line: +	}), angular.module('mgcrea.ngStrap.helpers.dimensions', []).factory('dimensions', ['$document', '$window', function (t, n) {
>, <Line: +		var a = (angular.element, {}), o = a.nodeName = function (e, t) {
>, <Line: +			return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
>, <Line: +		};
>, <Line: +		a.css = function (t, n, a) {
>, <Line: +			var o;
>, <Line: +			return o = t.currentStyle ? t.currentStyle[n] : e.getComputedStyle ? e.getComputedStyle(t)[n] : t.style[n], a === !0 ? parseFloat(o) || 0 : o
>, <Line: +		}, a.offset = function (t) {
>, <Line: +			var n = t.getBoundingClientRect(), a = t.ownerDocument;
>, <Line: +			return {
>, <Line: +				width: n.width || t.offsetWidth,
>, <Line: +				height: n.height || t.offsetHeight,
>, <Line: +				top: n.top + (e.pageYOffset || a.documentElement.scrollTop) - (a.documentElement.clientTop || 0),
>, <Line: +				left: n.left + (e.pageXOffset || a.documentElement.scrollLeft) - (a.documentElement.clientLeft || 0)
>, <Line: +			}
>, <Line: +		}, a.setOffset = function (e, t, n) {
>, <Line: +			var o, i, r, s, l, u, c, d = a.css(e, 'position'), f = angular.element(e), p = {};
>, <Line: +			'static' === d && (e.style.position = 'relative'), l = a.offset(e), r = a.css(e, 'top'), u = a.css(e, 'left'), c = ('absolute' === d || 'fixed' === d) && (r + u).indexOf('auto') > -1, c ? (o = a.position(e), s = o.top, i = o.left) : (s = parseFloat(r) || 0, i = parseFloat(u) || 0), angular.isFunction(t) && (t = t.call(e, n, l)), null !== t.top && (p.top = t.top - l.top + s), null !== t.left && (p.left = t.left - l.left + i), 'using'in t ? t.using.call(f, p) : f.css({
>, <Line: +				top: p.top + 'px',
>, <Line: +				left: p.left + 'px'
>, <Line: +			})
>, <Line: +		}, a.position = function (e) {
>, <Line: +			var t, n, r = {top: 0, left: 0};
>, <Line: +			return 'fixed' === a.css(e, 'position') ? n = e.getBoundingClientRect() : (t = i(e), n = a.offset(e), o(t, 'html') || (r = a.offset(t)), r.top += a.css(t, 'borderTopWidth', !0), r.left += a.css(t, 'borderLeftWidth', !0)), {
>, <Line: +				width: e.offsetWidth,
>, <Line: +				height: e.offsetHeight,
>, <Line: +				top: n.top - r.top - a.css(e, 'marginTop', !0),
>, <Line: +				left: n.left - r.left - a.css(e, 'marginLeft', !0)
>, <Line: +			}
>, <Line: +		};
>, <Line: +		var i = function (e) {
>, <Line: +			var t = e.ownerDocument, n = e.offsetParent || t;
>, <Line: +			if (o(n, '#document'))return t.documentElement;
>, <Line: +			for (; n && !o(n, 'html') && 'static' === a.css(n, 'position');)n = n.offsetParent;
>, <Line: +			return n || t.documentElement
>, <Line: +		};
>, <Line: +		return a.height = function (e, t) {
>, <Line: +			var n = e.offsetHeight;
>, <Line: +			return t ? n += a.css(e, 'marginTop', !0) + a.css(e, 'marginBottom', !0) : n -= a.css(e, 'paddingTop', !0) + a.css(e, 'paddingBottom', !0) + a.css(e, 'borderTopWidth', !0) + a.css(e, 'borderBottomWidth', !0), n
>, <Line: +		}, a.width = function (e, t) {
>, <Line: +			var n = e.offsetWidth;
>, <Line: +			return t ? n += a.css(e, 'marginLeft', !0) + a.css(e, 'marginRight', !0) : n -= a.css(e, 'paddingLeft', !0) + a.css(e, 'paddingRight', !0) + a.css(e, 'borderLeftWidth', !0) + a.css(e, 'borderRightWidth', !0), n
>, <Line: +		}, a
>, <Line: +	}]), angular.module('mgcrea.ngStrap.helpers.debounce', []).factory('debounce', ['$timeout', function (e) {
>, <Line: +		return function (t, n, a) {
>, <Line: +			var o = null;
>, <Line: +			return function () {
>, <Line: +				var i = this, r = arguments, s = a && !o;
>, <Line: +				return o && e.cancel(o), o = e(function () {
>, <Line: +					o = null, a || t.apply(i, r)
>, <Line: +				}, n, !1), s && t.apply(i, r), o
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).factory('throttle', ['$timeout', function (e) {
>, <Line: +		return function (t, n, a) {
>, <Line: +			var o = null;
>, <Line: +			return a || (a = {}), function () {
>, <Line: +				var i = this, r = arguments;
>, <Line: +				o || (a.leading !== !1 && t.apply(i, r), o = e(function () {
>, <Line: +					o = null, a.trailing !== !1 && t.apply(i, r)
>, <Line: +				}, n, !1))
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.helpers.dateParser', []).provider('$dateParser', ['$localeProvider', function (e) {
>, <Line: +		function t() {
>, <Line: +			this.year = 1970, this.month = 0, this.day = 1, this.hours = 0, this.minutes = 0, this.seconds = 0, this.milliseconds = 0
>, <Line: +		}
>, <Line: +		function n() {
>, <Line: +		}
>, <Line: +		function a(e) {
>, <Line: +			return !isNaN(parseFloat(e)) && isFinite(e)
>, <Line: +		}
>, <Line: +		function o(e, t) {
>, <Line: +			for (var n = e.length, a = t.toString().toLowerCase(), o = 0; n > o; o++)if (e[o].toLowerCase() === a)return o;
>, <Line: +			return -1
>, <Line: +		}
>, <Line: +		t.prototype.setMilliseconds = function (e) {
>, <Line: +			this.milliseconds = e
>, <Line: +		}, t.prototype.setSeconds = function (e) {
>, <Line: +			this.seconds = e
>, <Line: +		}, t.prototype.setMinutes = function (e) {
>, <Line: +			this.minutes = e
>, <Line: +		}, t.prototype.setHours = function (e) {
>, <Line: +			this.hours = e
>, <Line: +		}, t.prototype.getHours = function () {
>, <Line: +			return this.hours
>, <Line: +		}, t.prototype.setDate = function (e) {
>, <Line: +			this.day = e
>, <Line: +		}, t.prototype.setMonth = function (e) {
>, <Line: +			this.month = e
>, <Line: +		}, t.prototype.setFullYear = function (e) {
>, <Line: +			this.year = e
>, <Line: +		}, t.prototype.fromDate = function (e) {
>, <Line: +			return this.year = e.getFullYear(), this.month = e.getMonth(), this.day = e.getDate(), this.hours = e.getHours(), this.minutes = e.getMinutes(), this.seconds = e.getSeconds(), this.milliseconds = e.getMilliseconds(), this
>, <Line: +		}, t.prototype.toDate = function () {
>, <Line: +			return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds)
>, <Line: +		};
>, <Line: +		var i = t.prototype, r = this.defaults = {
>, <Line: +			format: 'shortDate',
>, <Line: +			strict: !1
>, <Line: +		};
>, <Line: +		this.$get = ['$locale', 'dateFilter', function (e, s) {
>, <Line: +			var l = function (l) {
>, <Line: +				function u(e) {
>, <Line: +					var t, n = Object.keys(h), a = [], o = [], i = e;
>, <Line: +					for (t = 0; t < n.length; t++)if (e.split(n[t]).length > 1) {
>, <Line: +						var r = i.search(n[t]);
>, <Line: +						e = e.split(n[t]).join(''), h[n[t]] && (a[r] = h[n[t]])
>, <Line: +					}
>, <Line: +					return angular.forEach(a, function (e) {
>, <Line: +						e && o.push(e)
>, <Line: +					}), o
>, <Line: +				}
>, <Line: +				function c(e) {
>, <Line: +					return e.replace(/\//g, '[\\/]').replace('/-/g', '[-]').replace(/\./g, '[.]').replace(/\\s/g, '[\\s]')
>, <Line: +				}
>, <Line: +				function d(e) {
>, <Line: +					var t, n = Object.keys($), a = e;
>, <Line: +					for (t = 0; t < n.length; t++)a = a.split(n[t]).join('${' + t + '}');
>, <Line: +					for (t = 0; t < n.length; t++)a = a.split('${' + t + '}').join('(' + $[n[t]] + ')');
>, <Line: +					return e = c(e), new RegExp('^' + a + '$', ['i'])
>, <Line: +				}
>, <Line: +				var f, p, g = angular.extend({}, r, l), m = {}, $ = {
>, <Line: +					sss: '[0-9]{3}',
>, <Line: +					ss: '[0-5][0-9]',
>, <Line: +					s: g.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
>, <Line: +					mm: '[0-5][0-9]',
>, <Line: +					m: g.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
>, <Line: +					HH: '[01][0-9]|2[0-3]',
>, <Line: +					H: g.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',
>, <Line: +					hh: '[0][1-9]|[1][012]',
>, <Line: +					h: g.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
>, <Line: +					a: 'AM|PM',
>, <Line: +					EEEE: e.DATETIME_FORMATS.DAY.join('|'),
>, <Line: +					EEE: e.DATETIME_FORMATS.SHORTDAY.join('|'),
>, <Line: +					dd: '0[1-9]|[12][0-9]|3[01]',
>, <Line: +					d: g.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',
>, <Line: +					MMMM: e.DATETIME_FORMATS.MONTH.join('|'),
>, <Line: +					MMM: e.DATETIME_FORMATS.SHORTMONTH.join('|'),
>, <Line: +					MM: '0[1-9]|1[012]',
>, <Line: +					M: g.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
>, <Line: +					yyyy: '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',
>, <Line: +					yy: '[0-9]{2}',
>, <Line: +					y: g.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'
>, <Line: +				}, h = {
>, <Line: +					sss: i.setMilliseconds,
>, <Line: +					ss: i.setSeconds,
>, <Line: +					s: i.setSeconds,
>, <Line: +					mm: i.setMinutes,
>, <Line: +					m: i.setMinutes,
>, <Line: +					HH: i.setHours,
>, <Line: +					H: i.setHours,
>, <Line: +					hh: i.setHours,
>, <Line: +					h: i.setHours,
>, <Line: +					EEEE: n,
>, <Line: +					EEE: n,
>, <Line: +					dd: i.setDate,
>, <Line: +					d: i.setDate,
>, <Line: +					a: function (e) {
>, <Line: +						var t = this.getHours() % 12;
>, <Line: +						return this.setHours(e.match(/pm/i) ? t + 12 : t)
>, <Line: +					},
>, <Line: +					MMMM: function (t) {
>, <Line: +						return this.setMonth(o(e.DATETIME_FORMATS.MONTH, t))
>, <Line: +					},
>, <Line: +					MMM: function (t) {
>, <Line: +						return this.setMonth(o(e.DATETIME_FORMATS.SHORTMONTH, t))
>, <Line: +					},
>, <Line: +					MM: function (e) {
>, <Line: +						return this.setMonth(1 * e - 1)
>, <Line: +					},
>, <Line: +					M: function (e) {
>, <Line: +						return this.setMonth(1 * e - 1)
>, <Line: +					},
>, <Line: +					yyyy: i.setFullYear,
>, <Line: +					yy: function (e) {
>, <Line: +						return this.setFullYear(2e3 + 1 * e)
>, <Line: +					},
>, <Line: +					y: function (e) {
>, <Line: +						return 50 >= 1 * e && 2 === e.length ? this.setFullYear(2e3 + 1 * e) : this.setFullYear(1 * e)
>, <Line: +					}
>, <Line: +				};
>, <Line: +				return m.init = function () {
>, <Line: +					m.$format = e.DATETIME_FORMATS[g.format] || g.format, f = d(m.$format), p = u(m.$format)
>, <Line: +				}, m.isValid = function (e) {
>, <Line: +					return angular.isDate(e) ? !isNaN(e.getTime()) : f.test(e)
>, <Line: +				}, m.parse = function (n, a, o, i) {
>, <Line: +					o && (o = e.DATETIME_FORMATS[o] || o), angular.isDate(n) && (n = s(n, o || m.$format, i));
>, <Line: +					var r = o ? d(o) : f, l = o ? u(o) : p, c = r.exec(n);
>, <Line: +					if (!c)return !1;
>, <Line: +					for (var g = a && !isNaN(a.getTime()) ? (new t).fromDate(a) : (new t).fromDate(new Date(1970, 0, 1, 0)), $ = 0; $ < c.length - 1; $++)l[$] && l[$].call(g, c[$ + 1]);
>, <Line: +					var h = g.toDate();
>, <Line: +					return parseInt(g.day, 10) !== h.getDate() ? !1 : h
>, <Line: +				}, m.getDateForAttribute = function (e, t) {
>, <Line: +					var n;
>, <Line: +					if ('today' === t) {
>, <Line: +						var o = new Date;
>, <Line: +						n = new Date(o.getFullYear(), o.getMonth(), o.getDate() + ('maxDate' === e ? 1 : 0), 0, 0, 0, 'minDate' === e ? 0 : -1)
>, <Line: +					} else n = angular.isString(t) && t.match(/^".+"$/) ? new Date(t.substr(1, t.length - 2)) : a(t) ? new Date(parseInt(t, 10)) : angular.isString(t) && 0 === t.length ? 'minDate' === e ? -(1 / 0) : +(1 / 0) : new Date(t);
>, <Line: +					return n
>, <Line: +				}, m.getTimeForAttribute = function (e, t) {
>, <Line: +					var n;
>, <Line: +					return n = 'now' === t ? (new Date).setFullYear(1970, 0, 1) : angular.isString(t) && t.match(/^".+"$/) ? new Date(t.substr(1, t.length - 2)).setFullYear(1970, 0, 1) : a(t) ? new Date(parseInt(t, 10)).setFullYear(1970, 0, 1) : angular.isString(t) && 0 === t.length ? 'minTime' === e ? -(1 / 0) : +(1 / 0) : m.parse(t, new Date(1970, 0, 1, 0))
>, <Line: +				}, m.daylightSavingAdjust = function (e) {
>, <Line: +					return e ? (e.setHours(e.getHours() > 12 ? e.getHours() + 2 : 0), e) : null
>, <Line: +				}, m.timezoneOffsetAdjust = function (e, t, n) {
>, <Line: +					return e ? (t && 'UTC' === t && (e = new Date(e.getTime()), e.setMinutes(e.getMinutes() + (n ? -1 : 1) * e.getTimezoneOffset())), e) : null
>, <Line: +				}, m.init(), m
>, <Line: +			};
>, <Line: +			return l
>, <Line: +		}]
>, <Line: +	}]), angular.module('mgcrea.ngStrap.helpers.dateFormatter', []).service('$dateFormatter', ['$locale', 'dateFilter', function (e, t) {
>, <Line: +		function n(e) {
>, <Line: +			return /(h+)([:\.])?(m+)([:\.])?(s*)[ ]?(a?)/i.exec(e).slice(1)
>, <Line: +		}
>, <Line: +		this.getDefaultLocale = function () {
>, <Line: +			return e.id
>, <Line: +		}, this.getDatetimeFormat = function (t, n) {
>, <Line: +			return e.DATETIME_FORMATS[t] || t
>, <Line: +		}, this.weekdaysShort = function (t) {
>, <Line: +			return e.DATETIME_FORMATS.SHORTDAY
>, <Line: +		}, this.hoursFormat = function (e) {
>, <Line: +			return n(e)[0]
>, <Line: +		}, this.minutesFormat = function (e) {
>, <Line: +			return n(e)[2]
>, <Line: +		}, this.secondsFormat = function (e) {
>, <Line: +			return n(e)[4]
>, <Line: +		}, this.timeSeparator = function (e) {
>, <Line: +			return n(e)[1]
>, <Line: +		}, this.showSeconds = function (e) {
>, <Line: +			return !!n(e)[4]
>, <Line: +		}, this.showAM = function (e) {
>, <Line: +			return !!n(e)[5]
>, <Line: +		}, this.formatDate = function (e, n, a, o) {
>, <Line: +			return t(e, n, o)
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.core', []).service('$bsCompiler', a), a.$inject = ['$q', '$http', '$injector', '$compile', '$controller', '$templateCache'], angular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip']).provider('$dropdown', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'dropdown',
>, <Line: +			prefixEvent: 'dropdown',
>, <Line: +			placement: 'bottom-left',
>, <Line: +			templateUrl: 'dropdown/dropdown.tpl.html',
>, <Line: +			trigger: 'click',
>, <Line: +			container: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			delay: 0
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$rootScope', '$tooltip', '$timeout', function (t, n, a, o) {
>, <Line: +			function i(t, i) {
>, <Line: +				function l(e) {
>, <Line: +					return e.target !== t[0] ? e.target !== t[0] && u.hide() : void 0
>, <Line: +				}
>, <Line: +				var u = {}, c = angular.extend({}, e, i);
>, <Line: +				u.$scope = c.scope && c.scope.$new() || n.$new();
>, <Line: +				u = a(t, c);
>, <Line: +				var d = t.parent();
>, <Line: +				u.$onKeyDown = function (e) {
>, <Line: +					if (/(38|40)/.test(e.keyCode)) {
>, <Line: +						e.preventDefault(), e.stopPropagation();
>, <Line: +						var t = angular.element(u.$element[0].querySelectorAll('li:not(.divider) a'));
>, <Line: +						if (t.length) {
>, <Line: +							var n;
>, <Line: +							angular.forEach(t, function (e, t) {
>, <Line: +								s && s.call(e, ':focus') && (n = t)
>, <Line: +							}), 38 === e.keyCode && n > 0 ? n-- : 40 === e.keyCode && n < t.length - 1 ? n++ : angular.isUndefined(n) && (n = 0), t.eq(n)[0].focus()
>, <Line: +						}
>, <Line: +					}
>, <Line: +				};
>, <Line: +				var f = u.show;
>, <Line: +				u.show = function () {
>, <Line: +					f(), o(function () {
>, <Line: +						c.keyboard && u.$element && u.$element.on('keydown', u.$onKeyDown), r.on('click', l)
>, <Line: +					}, 0, !1), d.hasClass('dropdown') && d.addClass('open')
>, <Line: +				};
>, <Line: +				var p = u.hide;
>, <Line: +				u.hide = function () {
>, <Line: +					u.$isShown && (c.keyboard && u.$element && u.$element.off('keydown', u.$onKeyDown), r.off('click', l), d.hasClass('dropdown') && d.removeClass('open'), p())
>, <Line: +				};
>, <Line: +				var g = u.destroy;
>, <Line: +				return u.destroy = function () {
>, <Line: +					r.off('click', l), g()
>, <Line: +				}, u
>, <Line: +			}
>, <Line: +			var r = angular.element(t.document.body), s = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;
>, <Line: +			return i
>, <Line: +		}]
>, <Line: +	}).directive('bsDropdown', ['$window', '$sce', '$dropdown', function (e, t, n) {
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, t, a, o) {
>, <Line: +				var i = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id'], function (e) {
>, <Line: +					angular.isDefined(a[e]) && (i[e] = a[e])
>, <Line: +				});
>, <Line: +				var r = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container'], function (e) {
>, <Line: +					angular.isDefined(a[e]) && r.test(a[e]) && (i[e] = !1)
>, <Line: +				}), a.bsDropdown && e.$watch(a.bsDropdown, function (t, n) {
>, <Line: +					e.content = t
>, <Line: +				}, !0), a.bsShow && e.$watch(a.bsShow, function (e, t) {
>, <Line: +					s && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|,?(dropdown),?/i)), e === !0 ? s.show() : s.hide())
>, <Line: +				});
>, <Line: +				var s = n(t, i);
>, <Line: +				e.$on('$destroy', function () {
>, <Line: +					s && s.destroy(), i = null, s = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip']).provider('$datepicker', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'datepicker',
>, <Line: +			placement: 'bottom-left',
>, <Line: +			templateUrl: 'datepicker/datepicker.tpl.html',
>, <Line: +			trigger: 'focus',
>, <Line: +			container: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			delay: 0,
>, <Line: +			useNative: !1,
>, <Line: +			dateType: 'date',
>, <Line: +			dateFormat: 'shortDate',
>, <Line: +			timezone: null,
>, <Line: +			modelDateFormat: null,
>, <Line: +			dayFormat: 'dd',
>, <Line: +			monthFormat: 'MMM',
>, <Line: +			yearFormat: 'yyyy',
>, <Line: +			monthTitleFormat: 'MMMM yyyy',
>, <Line: +			yearTitleFormat: 'yyyy',
>, <Line: +			strictFormat: !1,
>, <Line: +			autoclose: !1,
>, <Line: +			minDate: -(1 / 0),
>, <Line: +			maxDate: +(1 / 0),
>, <Line: +			startView: 0,
>, <Line: +			minView: 0,
>, <Line: +			startWeek: 0,
>, <Line: +			daysOfWeekDisabled: '',
>, <Line: +			iconLeft: 'glyphicon glyphicon-chevron-left',
>, <Line: +			iconRight: 'glyphicon glyphicon-chevron-right'
>, <Line: +		};
>, <Line: +		this.$get = ['$window', '$document', '$rootScope', '$sce', '$dateFormatter', 'datepickerViews', '$tooltip', '$timeout', function (t, n, a, o, i, r, s, l) {
>, <Line: +			function u(t, n, a) {
>, <Line: +				function o(e) {
>, <Line: +					e.selected = u.$isSelected(e.date)
>, <Line: +				}
>, <Line: +				function i() {
>, <Line: +					t[0].focus()
>, <Line: +				}
>, <Line: +				var u = s(t, angular.extend({}, e, a)), f = a.scope, p = u.$options, g = u.$scope;
>, <Line: +				p.startView && (p.startView -= p.minView);
>, <Line: +				var m = r(u);
>, <Line: +				u.$views = m.views;
>, <Line: +				var $ = m.viewDate;
>, <Line: +				g.$mode = p.startView, g.$iconLeft = p.iconLeft, g.$iconRight = p.iconRight;
>, <Line: +				var h = u.$views[g.$mode];
>, <Line: +				g.$select = function (e) {
>, <Line: +					u.select(e)
>, <Line: +				}, g.$selectPane = function (e) {
>, <Line: +					u.$selectPane(e)
>, <Line: +				}, g.$toggleMode = function () {
>, <Line: +					u.setMode((g.$mode + 1) % u.$views.length)
>, <Line: +				}, u.update = function (e) {
>, <Line: +					angular.isDate(e) && !isNaN(e.getTime()) && (u.$date = e, h.update.call(h, e)), u.$build(!0)
>, <Line: +				}, u.updateDisabledDates = function (e) {
>, <Line: +					p.disabledDateRanges = e;
>, <Line: +					for (var t = 0, n = g.rows.length; n > t; t++)angular.forEach(g.rows[t], u.$setDisabledEl)
>, <Line: +				}, u.select = function (e, t) {
>, <Line: +					angular.isDate(n.$dateValue) || (n.$dateValue = new Date(e)), !g.$mode || t ? (n.$setViewValue(angular.copy(e)), n.$render(), p.autoclose && !t && l(function () {
>, <Line: +						u.hide(!0)
>, <Line: +					})) : (angular.extend($, {
>, <Line: +						year: e.getFullYear(),
>, <Line: +						month: e.getMonth(),
>, <Line: +						date: e.getDate()
>, <Line: +					}), u.setMode(g.$mode - 1), u.$build())
>, <Line: +				}, u.setMode = function (e) {
>, <Line: +					g.$mode = e, h = u.$views[g.$mode], u.$build()
>, <Line: +				}, u.$build = function (e) {
>, <Line: +					e === !0 && h.built || (e !== !1 || h.built) && h.build.call(h)
>, <Line: +				}, u.$updateSelected = function () {
>, <Line: +					for (var e = 0, t = g.rows.length; t > e; e++)angular.forEach(g.rows[e], o)
>, <Line: +				}, u.$isSelected = function (e) {
>, <Line: +					return h.isSelected(e)
>, <Line: +				}, u.$setDisabledEl = function (e) {
>, <Line: +					e.disabled = h.isDisabled(e.date)
>, <Line: +				}, u.$selectPane = function (e) {
>, <Line: +					var t = h.steps, n = new Date(Date.UTC($.year + (t.year || 0) * e, $.month + (t.month || 0) * e, 1));
>, <Line: +					angular.extend($, {
>, <Line: +						year: n.getUTCFullYear(),
>, <Line: +						month: n.getUTCMonth(),
>, <Line: +						date: n.getUTCDate()
>, <Line: +					}), u.$build()
>, <Line: +				}, u.$onMouseDown = function (e) {
>, <Line: +					if (e.preventDefault(), e.stopPropagation(), d) {
>, <Line: +						var t = angular.element(e.target);
>, <Line: +						'button' !== t[0].nodeName.toLowerCase() && (t = t.parent()), t.triggerHandler('click')
>, <Line: +					}
>, <Line: +				}, u.$onKeyDown = function (e) {
>, <Line: +					if (/(38|37|39|40|13)/.test(e.keyCode) && !e.shiftKey && !e.altKey) {
>, <Line: +						if (e.preventDefault(), e.stopPropagation(), 13 === e.keyCode)return g.$mode ? g.$apply(function () {
>, <Line: +							u.setMode(g.$mode - 1)
>, <Line: +						}) : u.hide(!0);
>, <Line: +						h.onKeyDown(e), f.$digest()
>, <Line: +					}
>, <Line: +				};
>, <Line: +				var v = u.init;
>, <Line: +				u.init = function () {
>, <Line: +					return c && p.useNative ? (t.prop('type', 'date'), void t.css('-webkit-appearance', 'textfield')) : (d && (t.prop('type', 'text'), t.attr('readonly', 'true'), t.on('click', i)), void v())
>, <Line: +				};
>, <Line: +				var w = u.destroy;
>, <Line: +				u.destroy = function () {
>, <Line: +					c && p.useNative && t.off('click', i), w()
>, <Line: +				};
>, <Line: +				var y = u.show;
>, <Line: +				u.show = function () {
>, <Line: +					!d && t.attr('readonly') || t.attr('disabled') || (y(), l(function () {
>, <Line: +						u.$isShown && (u.$element.on(d ? 'touchstart' : 'mousedown', u.$onMouseDown), p.keyboard && t.on('keydown', u.$onKeyDown))
>, <Line: +					}, 0, !1))
>, <Line: +				};
>, <Line: +				var b = u.hide;
>, <Line: +				return u.hide = function (e) {
>, <Line: +					u.$isShown && (u.$element.off(d ? 'touchstart' : 'mousedown', u.$onMouseDown), p.keyboard && t.off('keydown', u.$onKeyDown), b(e))
>, <Line: +				}, u
>, <Line: +			}
>, <Line: +			var c = (angular.element(t.document.body), /(ip(a|o)d|iphone|android)/gi.test(t.navigator.userAgent)), d = 'createTouch'in t.document && c;
>, <Line: +			return e.lang || (e.lang = i.getDefaultLocale()), u.defaults = e, u
>, <Line: +		}]
>, <Line: +	}).directive('bsDatepicker', ['$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$datepicker', function (e, t, n, a, o, i) {
>, <Line: +		var r = (i.defaults, /(ip(a|o)d|iphone|android)/gi.test(e.navigator.userAgent));
>, <Line: +		return {
>, <Line: +			restrict: 'EAC',
>, <Line: +			require: 'ngModel',
>, <Line: +			link: function (e, t, n, s) {
>, <Line: +				function l(e) {
>, <Line: +					return e && e.length ? e : null
>, <Line: +				}
>, <Line: +				function u(e) {
>, <Line: +					if (angular.isDate(e)) {
>, <Line: +						var t = isNaN(p.$options.minDate) || e.getTime() >= p.$options.minDate, n = isNaN(p.$options.maxDate) || e.getTime() <= p.$options.maxDate, a = t && n;
>, <Line: +						s.$setValidity('date', a), s.$setValidity('min', t), s.$setValidity('max', n), a && (s.$dateValue = e)
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function c() {
>, <Line: +					return !s.$dateValue || isNaN(s.$dateValue.getTime()) ? '' : m(s.$dateValue, d.dateFormat)
>, <Line: +				}
>, <Line: +				var d = {scope: e};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && (d[e] = n[e])
>, <Line: +				});
>, <Line: +				var f = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && f.test(n[e]) && (d[e] = !1)
>, <Line: +				}), n.bsShow && e.$watch(n.bsShow, function (e, t) {
>, <Line: +					p && angular.isDefined(e) && (angular.isString(e) && (e = !!e.match(/true|,?(datepicker),?/i)), e === !0 ? p.show() : p.hide())
>, <Line: +				});
>, <Line: +				var p = i(t, s, d);
>, <Line: +				d = p.$options, r && d.useNative && (d.dateFormat = 'yyyy-MM-dd');
>, <Line: +				var g = d.lang, m = function (e, t) {
>, <Line: +					return a.formatDate(e, t, g)
>, <Line: +				}, $ = o({
>, <Line: +					format: d.dateFormat,
>, <Line: +					lang: g,
>, <Line: +					strict: d.strictFormat
>, <Line: +				});
>, <Line: +				angular.forEach(['minDate', 'maxDate'], function (e) {
>, <Line: +					angular.isDefined(n[e]) && n.$observe(e, function (t) {
>, <Line: +						p.$options[e] = $.getDateForAttribute(e, t), !isNaN(p.$options[e]) && p.$build(!1), u(s.$dateValue)
>, <Line: +					})
>, <Line: +				}), e.$watch(n.ngModel, function (e, t) {
>, <Line: +					p.update(s.$dateValue)
>, <Line: +				}, !0), angular.isDefined(n.disabledDates) && e.$watch(n.disabledDates, function (e, t) {
>, <Line: +					e = l(e), t = l(t), e && p.updateDisabledDates(e)
>, <Line: +				}), s.$parsers.unshift(function (e) {
>, <Line: +					var t;
>, <Line: +					if (!e)return s.$setValidity('date', !0), null;
>, <Line: +					var n = $.parse(e, s.$dateValue);
>, <Line: +					return !n || isNaN(n.getTime()) ? void s.$setValidity('date', !1) : (u(n), 'string' === d.dateType ? (t = $.timezoneOffsetAdjust(n, d.timezone, !0), m(t, d.modelDateFormat || d.dateFormat)) : (t = $.timezoneOffsetAdjust(s.$dateValue, d.timezone, !0), 'number' === d.dateType ? t.getTime() : 'unix' === d.dateType ? t.getTime() / 1e3 : 'iso' === d.dateType ? t.toISOString() : new Date(t)))
>, <Line: +				}), s.$formatters.push(function (e) {
>, <Line: +					var t;
>, <Line: +					return t = angular.isUndefined(e) || null === e ? NaN : angular.isDate(e) ? e : 'string' === d.dateType ? $.parse(e, null, d.modelDateFormat) : 'unix' === d.dateType ? new Date(1e3 * e) : new Date(e), s.$dateValue = $.timezoneOffsetAdjust(t, d.timezone), c()
>, <Line: +				}), s.$render = function () {
>, <Line: +					t.val(c())
>, <Line: +				}, e.$on('$destroy', function () {
>, <Line: +					p && p.destroy(), d = null, p = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).provider('datepickerViews', function () {
>, <Line: +		function e(e, t) {
>, <Line: +			for (var n = []; e.length > 0;)n.push(e.splice(0, t));
>, <Line: +			return n
>, <Line: +		}
>, <Line: +		function t(e, t) {
>, <Line: +			return (e % t + t) % t
>, <Line: +		}
>, <Line: +		this.defaults = {dayFormat: 'dd', daySplit: 7};
>, <Line: +		this.$get = ['$dateFormatter', '$dateParser', '$sce', function (n, a, o) {
>, <Line: +			return function (i) {
>, <Line: +				var r = i.$scope, s = i.$options, l = s.lang, u = function (e, t) {
>, <Line: +					return n.formatDate(e, t, l)
>, <Line: +				}, c = a({
>, <Line: +					format: s.dateFormat,
>, <Line: +					lang: l,
>, <Line: +					strict: s.strictFormat
>, <Line: +				}), d = n.weekdaysShort(l), f = d.slice(s.startWeek).concat(d.slice(0, s.startWeek)), p = o.trustAsHtml('<th class="dow text-center">' + f.join('</th><th class="dow text-center">') + '</th>'), g = i.$date || (s.startDate ? c.getDateForAttribute('startDate', s.startDate) : new Date), m = {
>, <Line: +					year: g.getFullYear(),
>, <Line: +					month: g.getMonth(),
>, <Line: +					date: g.getDate()
>, <Line: +				}, $ = [{
>, <Line: +					format: s.dayFormat,
>, <Line: +					split: 7,
>, <Line: +					steps: {month: 1},
>, <Line: +					update: function (e, t) {
>, <Line: +						!this.built || t || e.getFullYear() !== m.year || e.getMonth() !== m.month ? (angular.extend(m, {
>, <Line: +							year: i.$date.getFullYear(),
>, <Line: +							month: i.$date.getMonth(),
>, <Line: +							date: i.$date.getDate()
>, <Line: +						}), i.$build()) : (e.getDate() !== m.date || 1 === e.getDate()) && (m.date = i.$date.getDate(), i.$updateSelected())
>, <Line: +					},
>, <Line: +					build: function () {
>, <Line: +						var n = new Date(m.year, m.month, 1), a = n.getTimezoneOffset(), o = new Date(+n - 864e5 * t(n.getDay() - s.startWeek, 7)), l = o.getTimezoneOffset(), d = c.timezoneOffsetAdjust(new Date, s.timezone).toDateString();
>, <Line: +						l !== a && (o = new Date(+o + 6e4 * (l - a)));
>, <Line: +						for (var f, g = [], $ = 0; 42 > $; $++)f = c.daylightSavingAdjust(new Date(o.getFullYear(), o.getMonth(), o.getDate() + $)), g.push({
>, <Line: +							date: f,
>, <Line: +							isToday: f.toDateString() === d,
>, <Line: +							label: u(f, this.format),
>, <Line: +							selected: i.$date && this.isSelected(f),
>, <Line: +							muted: f.getMonth() !== m.month,
>, <Line: +							disabled: this.isDisabled(f)
>, <Line: +						});
>, <Line: +						r.title = u(n, s.monthTitleFormat), r.showLabels = !0, r.labels = p, r.rows = e(g, this.split), this.built = !0
>, <Line: +					},
>, <Line: +					isSelected: function (e) {
>, <Line: +						return i.$date && e.getFullYear() === i.$date.getFullYear() && e.getMonth() === i.$date.getMonth() && e.getDate() === i.$date.getDate()
>, <Line: +					},
>, <Line: +					isDisabled: function (e) {
>, <Line: +						var t = e.getTime();
>, <Line: +						if (t < s.minDate || t > s.maxDate)return !0;
>, <Line: +						if (-1 !== s.daysOfWeekDisabled.indexOf(e.getDay()))return !0;
>, <Line: +						if (s.disabledDateRanges)for (var n = 0; n < s.disabledDateRanges.length; n++)if (t >= s.disabledDateRanges[n].start && t <= s.disabledDateRanges[n].end)return !0;
>, <Line: +						return !1
>, <Line: +					},
>, <Line: +					onKeyDown: function (e) {
>, <Line: +						if (i.$date) {
>, <Line: +							var t, n = i.$date.getTime();
>, <Line: +							37 === e.keyCode ? t = new Date(n - 864e5) : 38 === e.keyCode ? t = new Date(n - 6048e5) : 39 === e.keyCode ? t = new Date(n + 864e5) : 40 === e.keyCode && (t = new Date(n + 6048e5)), this.isDisabled(t) || i.select(t, !0)
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}, {
>, <Line: +					name: 'month',
>, <Line: +					format: s.monthFormat,
>, <Line: +					split: 4,
>, <Line: +					steps: {year: 1},
>, <Line: +					update: function (e, t) {
>, <Line: +						this.built && e.getFullYear() === m.year ? e.getMonth() !== m.month && (angular.extend(m, {
>, <Line: +							month: i.$date.getMonth(),
>, <Line: +							date: i.$date.getDate()
>, <Line: +						}), i.$updateSelected()) : (angular.extend(m, {
>, <Line: +							year: i.$date.getFullYear(),
>, <Line: +							month: i.$date.getMonth(),
>, <Line: +							date: i.$date.getDate()
>, <Line: +						}), i.$build())
>, <Line: +					},
>, <Line: +					build: function () {
>, <Line: +						for (var t, n = (new Date(m.year, 0, 1), []), a = 0; 12 > a; a++)t = new Date(m.year, a, 1),
>, <Line: +							n.push({
>, <Line: +								date: t,
>, <Line: +								label: u(t, this.format),
>, <Line: +								selected: i.$isSelected(t),
>, <Line: +								disabled: this.isDisabled(t)
>, <Line: +							});
>, <Line: +						r.title = u(t, s.yearTitleFormat), r.showLabels = !1, r.rows = e(n, this.split), this.built = !0
>, <Line: +					},
>, <Line: +					isSelected: function (e) {
>, <Line: +						return i.$date && e.getFullYear() === i.$date.getFullYear() && e.getMonth() === i.$date.getMonth()
>, <Line: +					},
>, <Line: +					isDisabled: function (e) {
>, <Line: +						var t = +new Date(e.getFullYear(), e.getMonth() + 1, 0);
>, <Line: +						return t < s.minDate || e.getTime() > s.maxDate
>, <Line: +					},
>, <Line: +					onKeyDown: function (e) {
>, <Line: +						if (i.$date) {
>, <Line: +							var t = i.$date.getMonth(), n = new Date(i.$date);
>, <Line: +							37 === e.keyCode ? n.setMonth(t - 1) : 38 === e.keyCode ? n.setMonth(t - 4) : 39 === e.keyCode ? n.setMonth(t + 1) : 40 === e.keyCode && n.setMonth(t + 4), this.isDisabled(n) || i.select(n, !0)
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}, {
>, <Line: +					name: 'year',
>, <Line: +					format: s.yearFormat,
>, <Line: +					split: 4,
>, <Line: +					steps: {year: 12},
>, <Line: +					update: function (e, t) {
>, <Line: +						!this.built || t || parseInt(e.getFullYear() / 20, 10) !== parseInt(m.year / 20, 10) ? (angular.extend(m, {
>, <Line: +							year: i.$date.getFullYear(),
>, <Line: +							month: i.$date.getMonth(),
>, <Line: +							date: i.$date.getDate()
>, <Line: +						}), i.$build()) : e.getFullYear() !== m.year && (angular.extend(m, {
>, <Line: +							year: i.$date.getFullYear(),
>, <Line: +							month: i.$date.getMonth(),
>, <Line: +							date: i.$date.getDate()
>, <Line: +						}), i.$updateSelected())
>, <Line: +					},
>, <Line: +					build: function () {
>, <Line: +						for (var t, n = m.year - m.year % (3 * this.split), a = [], o = 0; 12 > o; o++)t = new Date(n + o, 0, 1), a.push({
>, <Line: +							date: t,
>, <Line: +							label: u(t, this.format),
>, <Line: +							selected: i.$isSelected(t),
>, <Line: +							disabled: this.isDisabled(t)
>, <Line: +						});
>, <Line: +						r.title = a[0].label + '-' + a[a.length - 1].label, r.showLabels = !1, r.rows = e(a, this.split), this.built = !0
>, <Line: +					},
>, <Line: +					isSelected: function (e) {
>, <Line: +						return i.$date && e.getFullYear() === i.$date.getFullYear()
>, <Line: +					},
>, <Line: +					isDisabled: function (e) {
>, <Line: +						var t = +new Date(e.getFullYear() + 1, 0, 0);
>, <Line: +						return t < s.minDate || e.getTime() > s.maxDate
>, <Line: +					},
>, <Line: +					onKeyDown: function (e) {
>, <Line: +						if (i.$date) {
>, <Line: +							var t = i.$date.getFullYear(), n = new Date(i.$date);
>, <Line: +							37 === e.keyCode ? n.setYear(t - 1) : 38 === e.keyCode ? n.setYear(t - 4) : 39 === e.keyCode ? n.setYear(t + 1) : 40 === e.keyCode && n.setYear(t + 4), this.isDisabled(n) || i.select(n, !0)
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}];
>, <Line: +				return {
>, <Line: +					views: s.minView ? Array.prototype.slice.call($, s.minView) : $,
>, <Line: +					viewDate: m
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}]
>, <Line: +	}), angular.module('mgcrea.ngStrap.collapse', []).provider('$collapse', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-collapse',
>, <Line: +			disallowToggle: !1,
>, <Line: +			activeClass: 'in',
>, <Line: +			startCollapsed: !1,
>, <Line: +			allowMultiple: !1
>, <Line: +		}, t = this.controller = function (t, n, a) {
>, <Line: +			function o(e) {
>, <Line: +				for (var t = l.$targets.$active, n = 0; n < t.length; n++)e < t[n] && (t[n] = t[n] - 1), t[n] === l.$targets.length && (t[n] = l.$targets.length - 1)
>, <Line: +			}
>, <Line: +			function i(e) {
>, <Line: +				var t = l.$targets.$active;
>, <Line: +				return -1 === t.indexOf(e) ? !1 : !0
>, <Line: +			}
>, <Line: +			function r(e) {
>, <Line: +				var t = l.$targets.$active.indexOf(e);
>, <Line: +				-1 !== t && l.$targets.$active.splice(t, 1)
>, <Line: +			}
>, <Line: +			function s(e) {
>, <Line: +				l.$options.allowMultiple || l.$targets.$active.splice(0, 1), -1 === l.$targets.$active.indexOf(e) && l.$targets.$active.push(e)
>, <Line: +			}
>, <Line: +			var l = this;
>, <Line: +			l.$options = angular.copy(e), angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (e) {
>, <Line: +				angular.isDefined(a[e]) && (l.$options[e] = a[e])
>, <Line: +			});
>, <Line: +			var u = /^(false|0|)$/i;
>, <Line: +			angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (e) {
>, <Line: +				angular.isDefined(a[e]) && u.test(a[e]) && (l.$options[e] = !1)
>, <Line: +			}), l.$toggles = [], l.$targets = [], l.$viewChangeListeners = [], l.$registerToggle = function (e) {
>, <Line: +				l.$toggles.push(e)
>, <Line: +			}, l.$registerTarget = function (e) {
>, <Line: +				l.$targets.push(e)
>, <Line: +			}, l.$unregisterToggle = function (e) {
>, <Line: +				var t = l.$toggles.indexOf(e);
>, <Line: +				l.$toggles.splice(t, 1)
>, <Line: +			}, l.$unregisterTarget = function (e) {
>, <Line: +				var t = l.$targets.indexOf(e);
>, <Line: +				l.$targets.splice(t, 1), l.$options.allowMultiple && r(e), o(t), l.$viewChangeListeners.forEach(function (e) {
>, <Line: +					e()
>, <Line: +				})
>, <Line: +			}, l.$targets.$active = l.$options.startCollapsed ? [] : [0], l.$setActive = t.$setActive = function (e) {
>, <Line: +				angular.isArray(e) ? l.$targets.$active = e : l.$options.disallowToggle ? s(e) : i(e) ? r(e) : s(e), l.$viewChangeListeners.forEach(function (e) {
>, <Line: +					e()
>, <Line: +				})
>, <Line: +			}, l.$activeIndexes = function () {
>, <Line: +				return l.$options.allowMultiple ? l.$targets.$active : 1 === l.$targets.$active.length ? l.$targets.$active[0] : -1
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			var n = {};
>, <Line: +			return n.defaults = e, n.controller = t, n
>, <Line: +		}
>, <Line: +	}).directive('bsCollapse', ['$window', '$animate', '$collapse', function (e, t, n) {
>, <Line: +		n.defaults;
>, <Line: +		return {
>, <Line: +			require: ['?ngModel', 'bsCollapse'],
>, <Line: +			controller: ['$scope', '$element', '$attrs', n.controller],
>, <Line: +			link: function (e, t, n, a) {
>, <Line: +				var o = a[0], i = a[1];
>, <Line: +				o && (i.$viewChangeListeners.push(function () {
>, <Line: +					o.$setViewValue(i.$activeIndexes())
>, <Line: +				}), o.$formatters.push(function (e) {
>, <Line: +					if (angular.isArray(e))i.$setActive(e); else {
>, <Line: +						var t = i.$activeIndexes();
>, <Line: +						angular.isArray(t) ? -1 === t.indexOf(1 * e) && i.$setActive(1 * e) : t !== 1 * e && i.$setActive(1 * e)
>, <Line: +					}
>, <Line: +					return e
>, <Line: +				}))
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).directive('bsCollapseToggle', function () {
>, <Line: +		return {
>, <Line: +			require: ['^?ngModel', '^bsCollapse'],
>, <Line: +			link: function (e, t, n, a) {
>, <Line: +				var o = (a[0], a[1]);
>, <Line: +				t.attr('data-toggle', 'collapse'), o.$registerToggle(t), e.$on('$destroy', function () {
>, <Line: +					o.$unregisterToggle(t)
>, <Line: +				}), t.on('click', function () {
>, <Line: +					var a = n.bsCollapseToggle && 'bs-collapse-toggle' !== n.bsCollapseToggle ? n.bsCollapseToggle : o.$toggles.indexOf(t);
>, <Line: +					o.$setActive(1 * a), e.$apply()
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}).directive('bsCollapseTarget', ['$animate', function (e) {
>, <Line: +		return {
>, <Line: +			require: ['^?ngModel', '^bsCollapse'],
>, <Line: +			link: function (t, n, a, o) {
>, <Line: +				function i() {
>, <Line: +					var t = r.$targets.indexOf(n), a = r.$activeIndexes(), o = 'removeClass';
>, <Line: +					angular.isArray(a) ? -1 !== a.indexOf(t) && (o = 'addClass') : t === a && (o = 'addClass'), e[o](n, r.$options.activeClass)
>, <Line: +				}
>, <Line: +				var r = (o[0], o[1]);
>, <Line: +				n.addClass('collapse'), r.$options.animation && n.addClass(r.$options.animation), r.$registerTarget(n), t.$on('$destroy', function () {
>, <Line: +					r.$unregisterTarget(n)
>, <Line: +				}), r.$viewChangeListeners.push(function () {
>, <Line: +					i()
>, <Line: +				}), i()
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.button', []).provider('$button', function () {
>, <Line: +		var e = this.defaults = {activeClass: 'active', toggleEvent: 'click'};
>, <Line: +		this.$get = function () {
>, <Line: +			return {defaults: e}
>, <Line: +		}
>, <Line: +	}).directive('bsCheckboxGroup', function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A', require: 'ngModel', compile: function (e, t) {
>, <Line: +				e.attr('data-toggle', 'buttons'), e.removeAttr('ng-model');
>, <Line: +				var n = e[0].querySelectorAll('input[type="checkbox"]');
>, <Line: +				angular.forEach(n, function (e) {
>, <Line: +					var n = angular.element(e);
>, <Line: +					n.attr('bs-checkbox', ''), n.attr('ng-model', t.ngModel + '.' + n.attr('value'))
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}).directive('bsCheckbox', ['$button', '$$rAF', function (e, t) {
>, <Line: +		var n = e.defaults, a = /^(true|false|\d+)$/;
>, <Line: +		return {
>, <Line: +			restrict: 'A', require: 'ngModel', link: function (e, o, i, r) {
>, <Line: +				var s = n, l = 'INPUT' === o[0].nodeName, u = l ? o.parent() : o, c = angular.isDefined(i.trueValue) ? i.trueValue : !0;
>, <Line: +				a.test(i.trueValue) && (c = e.$eval(i.trueValue));
>, <Line: +				var d = angular.isDefined(i.falseValue) ? i.falseValue : !1;
>, <Line: +				a.test(i.falseValue) && (d = e.$eval(i.falseValue));
>, <Line: +				var f = 'boolean' != typeof c || 'boolean' != typeof d;
>, <Line: +				f && (r.$parsers.push(function (e) {
>, <Line: +					return e ? c : d
>, <Line: +				}), r.$formatters.push(function (e) {
>, <Line: +					return angular.equals(e, c)
>, <Line: +				}), e.$watch(i.ngModel, function (e, t) {
>, <Line: +					r.$render()
>, <Line: +				})), r.$render = function () {
>, <Line: +					var e = angular.equals(r.$modelValue, c);
>, <Line: +					t(function () {
>, <Line: +						l && (o[0].checked = e), u.toggleClass(s.activeClass, e)
>, <Line: +					})
>, <Line: +				}, o.bind(s.toggleEvent, function () {
>, <Line: +					e.$apply(function () {
>, <Line: +						l || r.$setViewValue(!u.hasClass('active')), f || r.$render()
>, <Line: +					})
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).directive('bsRadioGroup', function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A', require: 'ngModel', compile: function (e, t) {
>, <Line: +				e.attr('data-toggle', 'buttons'), e.removeAttr('ng-model');
>, <Line: +				var n = e[0].querySelectorAll('input[type="radio"]');
>, <Line: +				angular.forEach(n, function (e) {
>, <Line: +					angular.element(e).attr('bs-radio', ''), angular.element(e).attr('ng-model', t.ngModel)
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}).directive('bsRadio', ['$button', '$$rAF', function (e, t) {
>, <Line: +		var n = e.defaults, a = /^(true|false|\d+)$/;
>, <Line: +		return {
>, <Line: +			restrict: 'A', require: 'ngModel', link: function (e, o, i, r) {
>, <Line: +				var s, l = n, u = 'INPUT' === o[0].nodeName, c = u ? o.parent() : o;
>, <Line: +				i.$observe('value', function (t) {
>, <Line: +					s = a.test(t) ? e.$eval(t) : t, r.$render()
>, <Line: +				}), r.$render = function () {
>, <Line: +					var e = angular.equals(r.$modelValue, s);
>, <Line: +					t(function () {
>, <Line: +						u && (o[0].checked = e), c.toggleClass(l.activeClass, e)
>, <Line: +					})
>, <Line: +				}, o.bind(l.toggleEvent, function () {
>, <Line: +					e.$apply(function () {
>, <Line: +						r.$setViewValue(s), r.$render()
>, <Line: +					})
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal']).provider('$aside', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade-and-slide-right',
>, <Line: +			prefixClass: 'aside',
>, <Line: +			prefixEvent: 'aside',
>, <Line: +			placement: 'right',
>, <Line: +			templateUrl: 'aside/aside.tpl.html',
>, <Line: +			contentTemplate: !1,
>, <Line: +			container: !1,
>, <Line: +			element: null,
>, <Line: +			backdrop: !0,
>, <Line: +			keyboard: !0,
>, <Line: +			html: !1,
>, <Line: +			show: !0
>, <Line: +		};
>, <Line: +		this.$get = ['$modal', function (t) {
>, <Line: +			function n(n) {
>, <Line: +				var a = {}, o = angular.extend({}, e, n);
>, <Line: +				return a = t(o)
>, <Line: +			}
>, <Line: +			return n
>, <Line: +		}]
>, <Line: +	}).directive('bsAside', ['$window', '$sce', '$aside', function (e, t, n) {
>, <Line: +		e.requestAnimationFrame || e.setTimeout;
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, a, o, i) {
>, <Line: +				var r = {scope: e, element: a, show: !1};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && (r[e] = o[e])
>, <Line: +				});
>, <Line: +				var s = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && s.test(o[e]) && (r[e] = !1)
>, <Line: +				}), angular.forEach(['title', 'content'], function (n) {
>, <Line: +					o[n] && o.$observe(n, function (a, o) {
>, <Line: +						e[n] = t.trustAsHtml(a)
>, <Line: +					})
>, <Line: +				}), o.bsAside && e.$watch(o.bsAside, function (t, n) {
>, <Line: +					angular.isObject(t) ? angular.extend(e, t) : e.content = t
>, <Line: +				}, !0);
>, <Line: +				var l = n(r);
>, <Line: +				a.on(o.trigger || 'click', l.toggle), e.$on('$destroy', function () {
>, <Line: +					l && l.destroy(), r = null, l = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal']).provider('$alert', function () {
>, <Line: +		var e = this.defaults = {
>, <Line: +			animation: 'am-fade',
>, <Line: +			prefixClass: 'alert',
>, <Line: +			prefixEvent: 'alert',
>, <Line: +			placement: null,
>, <Line: +			templateUrl: 'alert/alert.tpl.html',
>, <Line: +			container: !1,
>, <Line: +			element: null,
>, <Line: +			backdrop: !1,
>, <Line: +			keyboard: !0,
>, <Line: +			show: !0,
>, <Line: +			duration: !1,
>, <Line: +			type: !1,
>, <Line: +			dismissable: !0
>, <Line: +		};
>, <Line: +		this.$get = ['$modal', '$timeout', function (t, n) {
>, <Line: +			function a(a) {
>, <Line: +				var o = {}, i = angular.extend({}, e, a);
>, <Line: +				o = t(i), o.$scope.dismissable = !!i.dismissable, i.type && (o.$scope.type = i.type);
>, <Line: +				var r = o.show;
>, <Line: +				return i.duration && (o.show = function () {
>, <Line: +					r(), n(function () {
>, <Line: +						o.hide()
>, <Line: +					}, 1e3 * i.duration)
>, <Line: +				}), o
>, <Line: +			}
>, <Line: +			return a
>, <Line: +		}]
>, <Line: +	}).directive('bsAlert', ['$window', '$sce', '$alert', function (e, t, n) {
>, <Line: +		e.requestAnimationFrame || e.setTimeout;
>, <Line: +		return {
>, <Line: +			restrict: 'EAC', scope: !0, link: function (e, a, o, i) {
>, <Line: +				var r = {scope: e, element: a, show: !1};
>, <Line: +				angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && (r[e] = o[e])
>, <Line: +				});
>, <Line: +				var s = /^(false|0|)$/i;
>, <Line: +				angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (e) {
>, <Line: +					angular.isDefined(o[e]) && s.test(o[e]) && (r[e] = !1)
>, <Line: +				}), e.hasOwnProperty('title') || (e.title = ''), angular.forEach(['title', 'content', 'type'], function (n) {
>, <Line: +					o[n] && o.$observe(n, function (a, o) {
>, <Line: +						e[n] = t.trustAsHtml(a)
>, <Line: +					})
>, <Line: +				}), o.bsAlert && e.$watch(o.bsAlert, function (t, n) {
>, <Line: +					angular.isObject(t) ? angular.extend(e, t) : e.content = t
>, <Line: +				}, !0);
>, <Line: +				var l = n(r);
>, <Line: +				a.on(o.trigger || 'click', l.toggle), e.$on('$destroy', function () {
>, <Line: +					l && l.destroy(), r = null, l = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]), angular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce']).provider('$affix', function () {
>, <Line: +		var e = this.defaults = {offsetTop: 'auto', inlineStyles: !0};
>, <Line: +		this.$get = ['$window', 'debounce', 'dimensions', function (t, n, a) {
>, <Line: +			function o(o, s) {
>, <Line: +				function l(e, t, n) {
>, <Line: +					var a = u(), o = c();
>, <Line: +					return v >= a ? 'top' : null !== e && a + e <= t.top ? 'middle' : null !== w && t.top + n + $ >= o - w ? 'bottom' : 'middle'
>, <Line: +				}
>, <Line: +				function u() {
>, <Line: +					return p[0] === t ? t.pageYOffset : p[0].scrollTop
>, <Line: +				}
>, <Line: +				function c() {
>, <Line: +					return p[0] === t ? t.document.body.scrollHeight : p[0].scrollHeight
>, <Line: +				}
>, <Line: +				var d = {}, f = angular.extend({}, e, s), p = f.target, g = 'affix affix-top affix-bottom', m = !1, $ = 0, h = 0, v = 0, w = 0, y = null, b = null, D = o.parent();
>, <Line: +				if (f.offsetParent)if (f.offsetParent.match(/^\d+$/))for (var k = 0; k < 1 * f.offsetParent - 1; k++)D = D.parent(); else D = angular.element(f.offsetParent);
>, <Line: +				return d.init = function () {
>, <Line: +					this.$parseOffsets(), h = a.offset(o[0]).top + $, m = !o[0].style.width, p.on('scroll', this.checkPosition), p.on('click', this.checkPositionWithEventLoop), r.on('resize', this.$debouncedOnResize), this.checkPosition(), this.checkPositionWithEventLoop()
>, <Line: +				}, d.destroy = function () {
>, <Line: +					p.off('scroll', this.checkPosition), p.off('click', this.checkPositionWithEventLoop), r.off('resize', this.$debouncedOnResize)
>, <Line: +				}, d.checkPositionWithEventLoop = function () {
>, <Line: +					setTimeout(d.checkPosition, 1)
>, <Line: +				}, d.checkPosition = function () {
>, <Line: +					var e = u(), t = a.offset(o[0]), n = a.height(o[0]), r = l(b, t, n);
>, <Line: +					y !== r && (y = r, 'top' === r ? (b = null, m && o.css('width', ''), f.inlineStyles && (o.css('position', f.offsetParent ? '' : 'relative'), o.css('top', ''))) : 'bottom' === r ? (b = f.offsetUnpin ? -(1 * f.offsetUnpin) : t.top - e, m && o.css('width', ''), f.inlineStyles && (o.css('position', f.offsetParent ? '' : 'relative'), o.css('top', f.offsetParent ? '' : i[0].offsetHeight - w - n - h + 'px'))) : (b = null, m && o.css('width', o[0].offsetWidth + 'px'), f.inlineStyles && (o.css('position', 'fixed'), o.css('top', $ + 'px'))), o.removeClass(g).addClass('affix' + ('middle' !== r ? '-' + r : '')))
>, <Line: +				}, d.$onResize = function () {
>, <Line: +					d.$parseOffsets(), d.checkPosition()
>, <Line: +				}, d.$debouncedOnResize = n(d.$onResize, 50), d.$parseOffsets = function () {
>, <Line: +					var e = o.css('position');
>, <Line: +					f.inlineStyles && o.css('position', f.offsetParent ? '' : 'relative'), f.offsetTop && ('auto' === f.offsetTop && (f.offsetTop = '+0'), f.offsetTop.match(/^[-+]\d+$/) ? ($ = 1 * -f.offsetTop, v = f.offsetParent ? a.offset(D[0]).top + 1 * f.offsetTop : a.offset(o[0]).top - a.css(o[0], 'marginTop', !0) + 1 * f.offsetTop) : v = 1 * f.offsetTop), f.offsetBottom && (w = f.offsetParent && f.offsetBottom.match(/^[-+]\d+$/) ? c() - (a.offset(D[0]).top + a.height(D[0])) + 1 * f.offsetBottom + 1 : 1 * f.offsetBottom), f.inlineStyles && o.css('position', e)
>, <Line: +				}, d.init(), d
>, <Line: +			}
>, <Line: +			var i = angular.element(t.document.body), r = angular.element(t);
>, <Line: +			return o
>, <Line: +		}]
>, <Line: +	}).directive('bsAffix', ['$affix', '$window', function (e, t) {
>, <Line: +		return {
>, <Line: +			restrict: 'EAC',
>, <Line: +			require: '^?bsAffixTarget',
>, <Line: +			link: function (n, a, o, i) {
>, <Line: +				var r = {scope: n, target: i ? i.$element : angular.element(t)};
>, <Line: +				angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (e) {
>, <Line: +					if (angular.isDefined(o[e])) {
>, <Line: +						var t = o[e];
>, <Line: +						/true/i.test(t) && (t = !0), /false/i.test(t) && (t = !1), r[e] = t
>, <Line: +					}
>, <Line: +				});
>, <Line: +				var s = e(a, r);
>, <Line: +				n.$on('$destroy', function () {
>, <Line: +					s && s.destroy(), r = null, s = null
>, <Line: +				})
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}]).directive('bsAffixTarget', function () {
>, <Line: +		return {
>, <Line: +			controller: ['$element', function (e) {
>, <Line: +				this.$element = e
>, <Line: +			}]
>, <Line: +		}
>, <Line: +	}), angular.module('mgcrea.ngStrap', ['mgcrea.ngStrap.modal', 'mgcrea.ngStrap.aside', 'mgcrea.ngStrap.alert', 'mgcrea.ngStrap.button', 'mgcrea.ngStrap.select', 'mgcrea.ngStrap.datepicker', 'mgcrea.ngStrap.timepicker', 'mgcrea.ngStrap.navbar', 'mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.popover', 'mgcrea.ngStrap.dropdown', 'mgcrea.ngStrap.typeahead', 'mgcrea.ngStrap.scrollspy', 'mgcrea.ngStrap.affix', 'mgcrea.ngStrap.tab', 'mgcrea.ngStrap.collapse'])
>, <Line: +}(window, document);
>, <Line: +//# sourceMappingURL=angular-strap.min.js.map
>]
[]