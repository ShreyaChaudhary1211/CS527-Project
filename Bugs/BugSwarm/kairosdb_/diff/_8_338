[<Line: +(function ($) {
>, <Line: +	function init(plot) {
>, <Line: +		var DEFAULT_ICON = {
>, <Line: +			icon: "icon-caret-up",
>, <Line: +			size: 20,
>, <Line: +			width: 19,
>, <Line: +			height: 10
>, <Line: +		};
>, <Line: +		var _events = [], _types, _eventsEnabled = false, lastRange;
>, <Line: +		plot.getEvents = function () {
>, <Line: +			return _events;
>, <Line: +		};
>, <Line: +		plot.hideEvents = function (levelRange) {
>, <Line: +			$.each(_events, function (index, event) {
>, <Line: +				if (_withinHierarchy(event.level(), levelRange)) {
>, <Line: +					event.visual().getObject().hide();
>, <Line: +				}
>, <Line: +			});
>, <Line: +		};
>, <Line: +		plot.showEvents = function (levelRange) {
>, <Line: +			plot.hideEvents();
>, <Line: +			$.each(_events, function (index, event) {
>, <Line: +				if (!_withinHierarchy(event.level(), levelRange)) {
>, <Line: +					event.hide();
>, <Line: +				}
>, <Line: +			});
>, <Line: +			_drawEvents();
>, <Line: +		};
>, <Line: +		plot.hooks.processOptions.push(function (plot, options) {
>, <Line: +			// enable the plugin
>, <Line: +			if (options.events.data != null) {
>, <Line: +				_eventsEnabled = true;
>, <Line: +			}
>, <Line: +		});
>, <Line: +		plot.hooks.draw.push(function (plot, canvascontext) {
>, <Line: +			var options = plot.getOptions();
>, <Line: +			var xaxis = plot.getXAxes()[options.events.xaxis - 1];
>, <Line: +			if (_eventsEnabled) {
>, <Line: +				// check for first run
>, <Line: +				if (_events.length < 1) {
>, <Line: +					_lastRange = xaxis.max - xaxis.min;
>, <Line: +					// check for clustering
>, <Line: +					if (options.events.clustering) {
>, <Line: +						var ed = _clusterEvents(options.events.types, options.events.data, xaxis.max - xaxis.min);
>, <Line: +						_types = ed.types;
>, <Line: +						_setupEvents(ed.data);
>, <Line: +					} else {
>, <Line: +						_types = options.events.types;
>, <Line: +						_setupEvents(options.events.data);
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					/*if (options.events.clustering) {
>, <Line: +					 _clearEvents();
>, <Line: +					 var ed = _clusterEvents(options.events.types, options.events.data, xaxis.max - xaxis.min);
>, <Line: +					 _types = ed.types;
>, <Line: +					 _setupEvents(ed.data);
>, <Line: +					 }*/
>, <Line: +					_updateEvents();
>, <Line: +				}
>, <Line: +			}
>, <Line: +			_drawEvents();
>, <Line: +		});
>, <Line: +		var _drawEvents = function () {
>, <Line: +			var o = plot.getPlotOffset();
>, <Line: +			var pleft = o.left, pright = plot.width() - o.right;
>, <Line: +			$.each(_events, function (index, event) {
>, <Line: +				// check event is inside the graph range and inside the hierarchy level
>, <Line: +				if (_insidePlot(event.getOptions().min) && !event.isHidden()) {
>, <Line: +					event.visual().draw();
>, <Line: +				} else {
>, <Line: +					event.visual().getObject().hide();
>, <Line: +				}
>, <Line: +			});
>, <Line: +			_identicalStarts();
>, <Line: +			_overlaps();
>, <Line: +		};
>, <Line: +		var _withinHierarchy = function (level, levelRange) {
>, <Line: +			var range = {};
>, <Line: +			if (!levelRange) {
>, <Line: +				range.start = 0;
>, <Line: +				range.end = _events.length - 1;
>, <Line: +			} else {
>, <Line: +				range.start = (levelRange.min == undefined) ? 0 : levelRange.min;
>, <Line: +				range.end = (levelRange.max == undefined) ? _events.length - 1 : levelRange.max;
>, <Line: +			}
>, <Line: +			if (level >= range.start && level <= range.end) {
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		};
>, <Line: +		var _clearEvents = function () {
>, <Line: +			$.each(_events, function (index, val) {
>, <Line: +				val.visual().clear();
>, <Line: +			});
>, <Line: +			_events = [];
>, <Line: +		};
>, <Line: +		var _updateEvents = function () {
>, <Line: +			var o = plot.getPlotOffset(), left, top;
>, <Line: +			var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: +			$.each(_events, function (index, event) {
>, <Line: +				top = o.top + plot.height() - event.visual().height();
>, <Line: +				left = xaxis.p2c(event.getOptions().min) + o.left - event.visual().width() / 2;
>, <Line: +				event.visual().moveTo({top: top, left: left});
>, <Line: +			});
>, <Line: +		};
>, <Line: +		var _showTooltip = function (x, y, event) {
>, <Line: +			/*
>, <Line: +			 var tooltip = $('<div id="tooltip" class=""></div>').appendTo('body').fadeIn(200);
>, <Line: +			 $('<div id="title">' + event.title + '</div>').appendTo(tooltip);
>, <Line: +			 $('<div id="type">Type: ' + event.eventType + '</div>').appendTo(tooltip);
>, <Line: +			 $('<div id="description">' + event.description + '</div>').appendTo(tooltip);
>, <Line: +			 tooltip.css({
>, <Line: +			 top: y - tooltip.height() - 5,
>, <Line: +			 left: x
>, <Line: +			 });
>, <Line: +			 console.log(tooltip);
>, <Line: +			 */
>, <Line: +			// @rashidkpc - hack to work with our normal tooltip placer
>, <Line: +			var $tooltip = $('<div id="tooltip">');
>, <Line: +			if (event) {
>, <Line: +				$tooltip
>, <Line: +					.html(event.description)
>, <Line: +					.place_tt(x, y, {
>, <Line: +						offset: 10
>, <Line: +					});
>, <Line: +			} else {
>, <Line: +				$tooltip.remove();
>, <Line: +			}
>, <Line: +		};
>, <Line: +		var _setupEvents = function (events) {
>, <Line: +			$.each(events, function (index, event) {
>, <Line: +				var level = (plot.getOptions().events.levels == null || !_types || !_types[event.eventType]) ? 0 : _types[event.eventType].level;
>, <Line: +				if (level > plot.getOptions().events.levels) {
>, <Line: +					throw "A type's level has exceeded the maximum. Level=" +
>, <Line: +					level +
>, <Line: +					", Max levels:" +
>, <Line: +					(plot.getOptions().events.levels);
>, <Line: +				}
>, <Line: +				_events.push(new VisualEvent(event, _buildDiv(event), level));
>, <Line: +			});
>, <Line: +			_events.sort(compareEvents);
>, <Line: +		};
>, <Line: +		var _identicalStarts = function () {
>, <Line: +			var ranges = [], range = {}, event, prev, offset = 0;
>, <Line: +			$.each(_events, function (index, val) {
>, <Line: +				if (prev) {
>, <Line: +					if (val.getOptions().min == prev.getOptions().min) {
>, <Line: +						if (!range.min) {
>, <Line: +							range.min = index;
>, <Line: +						}
>, <Line: +						range.max = index;
>, <Line: +					} else {
>, <Line: +						if (range.min) {
>, <Line: +							ranges.push(range);
>, <Line: +							range = {};
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				prev = val;
>, <Line: +			});
>, <Line: +			if (range.min) {
>, <Line: +				ranges.push(range);
>, <Line: +			}
>, <Line: +			$.each(ranges, function (index, val) {
>, <Line: +				var removed = _events.splice(val.min - offset, val.max - val.min + 1);
>, <Line: +				$.each(removed, function (index, val) {
>, <Line: +					val.visual().clear();
>, <Line: +				});
>, <Line: +				offset += val.max - val.min + 1;
>, <Line: +			});
>, <Line: +		};
>, <Line: +		var _overlaps = function () {
>, <Line: +			var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: +			var range, diff, cmid, pmid, left = 0, right = -1;
>, <Line: +			pright = plot.width() - plot.getPlotOffset().right;
>, <Line: +			// coverts a clump of events into a single vertical line
>, <Line: +			var processClump = function () {
>, <Line: +				// find the middle x value
>, <Line: +				pmid = _events[right].getOptions().min -
>, <Line: +					(_events[right].getOptions().min - _events[left].getOptions().min) / 2;
>, <Line: +				cmid = xaxis.p2c(pmid);
>, <Line: +				// hide the events between the discovered range
>, <Line: +				while (left <= right) {
>, <Line: +					_events[left++].visual().getObject().hide();
>, <Line: +				}
>, <Line: +				// draw a vertical line in the middle of where they are
>, <Line: +				if (_insidePlot(pmid)) {
>, <Line: +					_drawLine('#000', 1, {x: cmid, y: 0}, {
>, <Line: +						x: cmid,
>, <Line: +						y: plot.height()
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +			if (xaxis.min && xaxis.max) {
>, <Line: +				range = xaxis.max - xaxis.min;
>, <Line: +				for (var i = 1; i < _events.length; i++) {
>, <Line: +					diff = _events[i].getOptions().min - _events[i - 1].getOptions().min;
>, <Line: +					if (diff / range > 0.007) {  //enough variance
>, <Line: +						// has a clump has been found
>, <Line: +						if (right != -1) {
>, <Line: +							//processClump();
>, <Line: +						}
>, <Line: +						right = -1;
>, <Line: +						left = i;
>, <Line: +					} else {    // not enough variance
>, <Line: +						right = i;
>, <Line: +						// handle to final case
>, <Line: +						if (i == _events.length - 1) {
>, <Line: +							//processClump();
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +		var _buildDiv = function (event) {
>, <Line: +			//var po = plot.pointOffset({ x: 450, y: 1});
>, <Line: +			var container = plot.getPlaceholder(), o = plot.getPlotOffset(), yaxis,
>, <Line: +				xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1], axes = plot.getAxes();
>, <Line: +			var top, left, div, icon, level, drawableEvent;
>, <Line: +			// determine the y axis used
>, <Line: +			if (axes.yaxis && axes.yaxis.used) yaxis = axes.yaxis;
>, <Line: +			if (axes.yaxis2 && axes.yaxis2.used) yaxis = axes.yaxis2;
>, <Line: +			// use the default icon and level
>, <Line: +			if (_types == null || !_types[event.eventType] || !_types[event.eventType].icon) {
>, <Line: +				icon = DEFAULT_ICON;
>, <Line: +				level = 0;
>, <Line: +			} else {
>, <Line: +				icon = _types[event.eventType].icon;
>, <Line: +				level = _types[event.eventType].level;
>, <Line: +			}
>, <Line: +			div = $('<i style="position:absolute" class="' + icon.icon + '"></i>').appendTo(container);
>, <Line: +			top = o.top + plot.height() - icon.size + 1;
>, <Line: +			left = xaxis.p2c(event.min) + o.left - icon.size / 2;
>, <Line: +			div.css({
>, <Line: +				left: left + 'px',
>, <Line: +				top: top,
>, <Line: +				color: icon.color,
>, <Line: +				"text-shadow": "1px 1px " + icon.outline + ", -1px -1px " + icon.outline + ", -1px 1px " + icon.outline + ", 1px -1px " + icon.outline,
>, <Line: +				'font-size': icon['size'] + 'px',
>, <Line: +			});
>, <Line: +			div.hide();
>, <Line: +			div.data({
>, <Line: +				"event": event
>, <Line: +			});
>, <Line: +			div.hover(
>, <Line: +				// mouseenter
>, <Line: +				function () {
>, <Line: +					var pos = $(this).offset();
>, <Line: +					_showTooltip(pos.left + $(this).width() / 2, pos.top, $(this).data("event"));
>, <Line: +				},
>, <Line: +				// mouseleave
>, <Line: +				function () {
>, <Line: +					//$(this).data("bouncing", false);
>, <Line: +					$('#tooltip').remove();
>, <Line: +					plot.clearSelection();
>, <Line: +				});
>, <Line: +			drawableEvent = new DrawableEvent(
>, <Line: +				div,
>, <Line: +				function (obj) {
>, <Line: +					obj.show();
>, <Line: +				},
>, <Line: +				function (obj) {
>, <Line: +					obj.remove();
>, <Line: +				},
>, <Line: +				function (obj, position) {
>, <Line: +					obj.css({
>, <Line: +						top: position.top,
>, <Line: +						left: position.left
>, <Line: +					});
>, <Line: +				},
>, <Line: +				left, top, div.width(), div.height());
>, <Line: +			return drawableEvent;
>, <Line: +		};
>, <Line: +		var _getEventsAtPos = function (x, y) {
>, <Line: +			var found = [], left, top, width, height;
>, <Line: +			$.each(_events, function (index, val) {
>, <Line: +				left = val.div.offset().left;
>, <Line: +				top = val.div.offset().top;
>, <Line: +				width = val.div.width();
>, <Line: +				height = val.div.height();
>, <Line: +				if (x >= left && x <= left + width && y >= top && y <= top + height) {
>, <Line: +					found.push(val);
>, <Line: +				}
>, <Line: +				return found;
>, <Line: +			});
>, <Line: +		};
>, <Line: +		var _insidePlot = function (x) {
>, <Line: +			var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: +			var xc = xaxis.p2c(x);
>, <Line: +			return xc > 0 && xc < xaxis.p2c(xaxis.max);
>, <Line: +		};
>, <Line: +		var _drawLine = function (color, lineWidth, from, to) {
>, <Line: +			var ctx = plot.getCanvas().getContext("2d");
>, <Line: +			var plotOffset = plot.getPlotOffset();
>, <Line: +			ctx.save();
>, <Line: +			ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: +			ctx.beginPath();
>, <Line: +			ctx.strokeStyle = color;
>, <Line: +			ctx.lineWidth = lineWidth;
>, <Line: +			ctx.moveTo(from.x, from.y);
>, <Line: +			ctx.lineTo(to.x, to.y);
>, <Line: +			ctx.stroke();
>, <Line: +			ctx.restore();
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Runs over the given 2d array of event objects and returns an object
>, <Line: +		 * containing:
>, <Line: +		 *
>, <Line: +		 * {
>, <Line: +		 *
>, <Line: +		 * @param {Object} types
>, <Line: +		 *          an object containing event types
>, <Line: +		 * @param {Object} events
>, <Line: +		 *          an array of event to cluster
>, <Line: +		 * @param {Object} range
>, <Line: +		 *          the current graph range
>, <Line: +		 */
>, <Line: +		var _clusterEvents = function (types, events, range) {
>, <Line: +			//TODO: support custom types
>, <Line: +			var groups, clusters = [], newEvents = [];
>, <Line: +			// split into same evenType groups
>, <Line: +			groups = _groupEvents(events);
>, <Line: +			$.each(groups.eventTypes, function (index, val) {
>, <Line: +				clusters.push(_varianceAlgorithm(groups.groupedEvents[val], 1, range));
>, <Line: +			});
>, <Line: +			// summarise clusters
>, <Line: +			$.each(clusters, function (index, eventType) {
>, <Line: +				// each cluser of each event type
>, <Line: +				$.each(eventType, function (index, cluster) {
>, <Line: +					var newEvent = {
>, <Line: +						min: cluster[0].min,
>, <Line: +						max: cluster[cluster.length - 1].min,    //TODO: needs to be max of end event if it exists
>, <Line: +						eventType: cluster[0].eventType + ",cluster",
>, <Line: +						title: "Cluster of: " + cluster[0].title,
>, <Line: +						description: cluster[0].description + ", Number of events in the cluster: " + cluster.length
>, <Line: +					};
>, <Line: +					newEvents.push(newEvent);
>, <Line: +				});
>, <Line: +			});
>, <Line: +			return {types: types, data: newEvents};
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Runs over the given 2d array of event objects and returns an object
>, <Line: +		 * containing:
>, <Line: +		 *
>, <Line: +		 * {
>, <Line: +		 *
>, <Line: +		 * @param {Object} events
>, <Line: +		 *          an array of event objects
>, <Line: +		 */
>, <Line: +		var _groupEvents = function (events) {
>, <Line: +			var eventTypes = [], groupedEvents = {};
>, <Line: +			$.each(events, function (index, val) {
>, <Line: +				if (!groupedEvents[val.eventType]) {
>, <Line: +					groupedEvents[val.eventType] = [];
>, <Line: +					eventTypes.push(val.eventType);
>, <Line: +				}
>, <Line: +				groupedEvents[val.eventType].push(val);
>, <Line: +			});
>, <Line: +			return {eventTypes: eventTypes, groupedEvents: groupedEvents};
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Runs over the given 2d array of event objects and returns a 3d array of
>, <Line: +		 * the same events,but clustered into groups with similar x deltas.
>, <Line: +		 *
>, <Line: +		 * This function assumes that the events are related. So it must be run on
>, <Line: +		 * each set of related events.
>, <Line: +		 *
>, <Line: +		 * @param {Object} events
>, <Line: +		 *          an array of event objects
>, <Line: +		 * @param {Object} sens
>, <Line: +		 *          a measure of the level of grouping tolerance
>, <Line: +		 * @param {Object} space
>, <Line: +		 *          the size of the space we have to place clusters within
>, <Line: +		 */
>, <Line: +		var _varianceAlgorithm = function (events, sens, space) {
>, <Line: +			var cluster, clusters = [], sum = 0, avg, density;
>, <Line: +			// find the average x delta
>, <Line: +			for (var i = 1; i < events.length - 1; i++) {
>, <Line: +				sum += events[i].min - events[i - 1].min;
>, <Line: +			}
>, <Line: +			avg = sum / (events.length - 2);
>, <Line: +			// first point
>, <Line: +			cluster = [events[0]];
>, <Line: +			// middle points
>, <Line: +			for (var i = 1; i < events.length; i++) {
>, <Line: +				var leftDiff = events[i].min - events[i - 1].min;
>, <Line: +				density = leftDiff / space;
>, <Line: +				if (leftDiff > avg * sens && density > 0.05) {
>, <Line: +					clusters.push(cluster);
>, <Line: +					cluster = [events[i]];
>, <Line: +				} else {
>, <Line: +					cluster.push(events[i]);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			clusters.push(cluster);
>, <Line: +			return clusters;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	var options = {
>, <Line: +		events: {
>, <Line: +			levels: null,
>, <Line: +			data: null,
>, <Line: +			types: null,
>, <Line: +			xaxis: 1,
>, <Line: +			clustering: false
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$.plot.plugins.push({
>, <Line: +		init: init,
>, <Line: +		options: options,
>, <Line: +		name: "events",
>, <Line: +		version: "0.20"
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * A class that allows for the drawing an remove of some object
>, <Line: +	 *
>, <Line: +	 * @param {Object} object
>, <Line: +	 *          the drawable object
>, <Line: +	 * @param {Object} drawFunc
>, <Line: +	 *          the draw function
>, <Line: +	 * @param {Object} clearFunc
>, <Line: +	 *          the clear function
>, <Line: +	 */
>, <Line: +	function DrawableEvent(object, drawFunc, clearFunc, moveFunc, left, top, width, height) {
>, <Line: +		var _object = object, _drawFunc = drawFunc, _clearFunc = clearFunc, _moveFunc = moveFunc,
>, <Line: +			_position = {
>, <Line: +				left: left,
>, <Line: +				top: top
>, <Line: +			}, _width = width, _height = height;
>, <Line: +		this.width = function () {
>, <Line: +			return _width;
>, <Line: +		};
>, <Line: +		this.height = function () {
>, <Line: +			return _height
>, <Line: +		};
>, <Line: +		this.position = function () {
>, <Line: +			return _position;
>, <Line: +		};
>, <Line: +		this.draw = function () {
>, <Line: +			_drawFunc(_object);
>, <Line: +		};
>, <Line: +		this.clear = function () {
>, <Line: +			_clearFunc(_object);
>, <Line: +		};
>, <Line: +		this.getObject = function () {
>, <Line: +			return _object;
>, <Line: +		};
>, <Line: +		this.moveTo = function (position) {
>, <Line: +			_position = position;
>, <Line: +			_moveFunc(_object, _position);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Event class that stores options (eventType, min, max, title, description) and the object to draw.
>, <Line: +	 *
>, <Line: +	 * @param {Object} options
>, <Line: +	 * @param {Object} drawableEvent
>, <Line: +	 */
>, <Line: +	function VisualEvent(options, drawableEvent, level) {
>, <Line: +		var _parent, _options = options, _drawableEvent = drawableEvent,
>, <Line: +			_level = level, _hidden = false;
>, <Line: +		this.visual = function () {
>, <Line: +			return _drawableEvent;
>, <Line: +		}
>, <Line: +		this.level = function () {
>, <Line: +			return _level;
>, <Line: +		};
>, <Line: +		this.getOptions = function () {
>, <Line: +			return _options;
>, <Line: +		};
>, <Line: +		this.getParent = function () {
>, <Line: +			return _parent;
>, <Line: +		};
>, <Line: +		this.isHidden = function () {
>, <Line: +			return _hidden;
>, <Line: +		};
>, <Line: +		this.hide = function () {
>, <Line: +			_hidden = true;
>, <Line: +		};
>, <Line: +		this.unhide = function () {
>, <Line: +			_hidden = false;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function compareEvents(a, b) {
>, <Line: +		var ao = a.getOptions(), bo = b.getOptions();
>, <Line: +		if (ao.min > bo.min) return 1;
>, <Line: +		if (ao.min < bo.min) return -1;
>, <Line: +		return 0;
>, <Line: +	};
>]
[<Line: -(function($){
>, <Line: -    function init(plot){
>, <Line: -        var DEFAULT_ICON = {
>, <Line: -            icon: "icon-caret-up",
>, <Line: -            size: 20,
>, <Line: -            width: 19,
>, <Line: -            height: 10
>, <Line: -        };
>, <Line: -        var _events = [], _types, _eventsEnabled = false, lastRange;
>, <Line: -        plot.getEvents = function(){
>, <Line: -            return _events;
>, <Line: -        };
>, <Line: -        plot.hideEvents = function(levelRange){
>, <Line: -            $.each(_events, function(index, event){
>, <Line: -                if (_withinHierarchy(event.level(), levelRange)) {
>, <Line: -                    event.visual().getObject().hide();
>, <Line: -                }
>, <Line: -            });
>, <Line: -        };
>, <Line: -        plot.showEvents = function(levelRange){
>, <Line: -            plot.hideEvents();
>, <Line: -            $.each(_events, function(index, event){
>, <Line: -                if (!_withinHierarchy(event.level(), levelRange)) {
>, <Line: -                    event.hide();
>, <Line: -                }
>, <Line: -            });
>, <Line: -            _drawEvents();
>, <Line: -        };
>, <Line: -        plot.hooks.processOptions.push(function(plot, options){
>, <Line: -            // enable the plugin
>, <Line: -            if (options.events.data != null) {
>, <Line: -                _eventsEnabled = true;
>, <Line: -            }
>, <Line: -        });
>, <Line: -        plot.hooks.draw.push(function(plot, canvascontext){
>, <Line: -            var options = plot.getOptions();
>, <Line: -            var xaxis = plot.getXAxes()[options.events.xaxis - 1];
>, <Line: -            if (_eventsEnabled) {
>, <Line: -                // check for first run
>, <Line: -                if (_events.length < 1) {
>, <Line: -                    _lastRange = xaxis.max - xaxis.min;
>, <Line: -                    // check for clustering
>, <Line: -                    if (options.events.clustering) {
>, <Line: -                        var ed = _clusterEvents(options.events.types, options.events.data, xaxis.max - xaxis.min);
>, <Line: -                        _types = ed.types;
>, <Line: -                        _setupEvents(ed.data);
>, <Line: -                    } else {
>, <Line: -                        _types = options.events.types;
>, <Line: -                        _setupEvents(options.events.data);
>, <Line: -                    }
>, <Line: -                } else {
>, <Line: -                    /*if (options.events.clustering) {
>, <Line: -                        _clearEvents();
>, <Line: -                        var ed = _clusterEvents(options.events.types, options.events.data, xaxis.max - xaxis.min);
>, <Line: -                        _types = ed.types;
>, <Line: -                        _setupEvents(ed.data);
>, <Line: -                    }*/
>, <Line: -                    _updateEvents();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            _drawEvents();
>, <Line: -        });
>, <Line: -        var _drawEvents = function() {
>, <Line: -            var o = plot.getPlotOffset();
>, <Line: -            var pleft = o.left, pright = plot.width() - o.right;
>, <Line: -            $.each(_events, function(index, event){
>, <Line: -                // check event is inside the graph range and inside the hierarchy level
>, <Line: -                if (_insidePlot(event.getOptions().min) &&
>, <Line: -                    !event.isHidden()) {
>, <Line: -                    event.visual().draw();
>, <Line: -                }  else {
>, <Line: -                    event.visual().getObject().hide();
>, <Line: -                }
>, <Line: -            });
>, <Line: -            _identicalStarts();
>, <Line: -            _overlaps();
>, <Line: -        };
>, <Line: -        var _withinHierarchy = function(level, levelRange){
>, <Line: -            var range = {};
>, <Line: -            if (!levelRange) {
>, <Line: -                range.start = 0;
>, <Line: -                range.end = _events.length - 1;
>, <Line: -            } else {
>, <Line: -                range.start = (levelRange.min == undefined) ? 0 : levelRange.min;
>, <Line: -                range.end = (levelRange.max == undefined) ? _events.length - 1 : levelRange.max;
>, <Line: -            }
>, <Line: -            if (level >= range.start && level <= range.end) {
>, <Line: -                return true;
>, <Line: -            }
>, <Line: -            return false;
>, <Line: -        };
>, <Line: -        var _clearEvents = function(){
>, <Line: -            $.each(_events, function(index, val) {
>, <Line: -                val.visual().clear();
>, <Line: -            });
>, <Line: -            _events = [];
>, <Line: -        };
>, <Line: -        var _updateEvents = function() {
>, <Line: -            var o = plot.getPlotOffset(), left, top;
>, <Line: -            var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: -            $.each(_events, function(index, event) {
>, <Line: -                top = o.top + plot.height() - event.visual().height();
>, <Line: -                left = xaxis.p2c(event.getOptions().min) + o.left - event.visual().width() / 2;
>, <Line: -                event.visual().moveTo({ top: top, left: left });
>, <Line: -            });
>, <Line: -        };
>, <Line: -        var _showTooltip = function(x, y, event){
>, <Line: -            /*
>, <Line: -            var tooltip = $('<div id="tooltip" class=""></div>').appendTo('body').fadeIn(200);
>, <Line: -            $('<div id="title">' + event.title + '</div>').appendTo(tooltip);
>, <Line: -            $('<div id="type">Type: ' + event.eventType + '</div>').appendTo(tooltip);
>, <Line: -            $('<div id="description">' + event.description + '</div>').appendTo(tooltip);
>, <Line: -            tooltip.css({
>, <Line: -                top: y - tooltip.height() - 5,
>, <Line: -                left: x
>, <Line: -            });
>, <Line: -            console.log(tooltip);
>, <Line: -            */
>, <Line: -            // @rashidkpc - hack to work with our normal tooltip placer
>, <Line: -            var $tooltip = $('<div id="tooltip">');
>, <Line: -            if (event) {
>, <Line: -                $tooltip
>, <Line: -                    .html(event.description)
>, <Line: -                    .place_tt(x, y, {
>, <Line: -                        offset: 10
>, <Line: -                    });
>, <Line: -            } else {
>, <Line: -                $tooltip.remove();
>, <Line: -            }
>, <Line: -        };
>, <Line: -        var _setupEvents = function(events){
>, <Line: -            $.each(events, function(index, event){
>, <Line: -                var level = (plot.getOptions().events.levels == null || !_types || !_types[event.eventType]) ? 0 : _types[event.eventType].level;
>, <Line: -                if (level > plot.getOptions().events.levels) {
>, <Line: -                    throw "A type's level has exceeded the maximum. Level=" +
>, <Line: -                    level +
>, <Line: -                    ", Max levels:" +
>, <Line: -                    (plot.getOptions().events.levels);
>, <Line: -                }
>, <Line: -                _events.push(new VisualEvent(event, _buildDiv(event), level));
>, <Line: -            });
>, <Line: -            _events.sort(compareEvents);
>, <Line: -        };
>, <Line: -        var _identicalStarts = function() {
>, <Line: -            var ranges = [], range = {}, event, prev, offset = 0;
>, <Line: -            $.each(_events, function(index, val) {
>, <Line: -                if (prev) {
>, <Line: -                    if (val.getOptions().min == prev.getOptions().min) {
>, <Line: -                        if (!range.min) {
>, <Line: -                            range.min = index;
>, <Line: -                        }
>, <Line: -                        range.max = index;
>, <Line: -                    } else {
>, <Line: -                        if (range.min) {
>, <Line: -                            ranges.push(range);
>, <Line: -                            range = {};
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                prev = val;
>, <Line: -            });
>, <Line: -            if (range.min) {
>, <Line: -                ranges.push(range);
>, <Line: -            }
>, <Line: -            $.each(ranges, function(index, val) {
>, <Line: -                var removed = _events.splice(val.min - offset, val.max - val.min + 1);
>, <Line: -                $.each(removed, function(index, val) {
>, <Line: -                    val.visual().clear();
>, <Line: -                });
>, <Line: -                offset += val.max - val.min + 1;
>, <Line: -            });
>, <Line: -        };
>, <Line: -        var _overlaps = function() {
>, <Line: -            var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: -            var range, diff, cmid, pmid, left = 0, right = -1;
>, <Line: -            pright = plot.width() - plot.getPlotOffset().right;
>, <Line: -            // coverts a clump of events into a single vertical line
>, <Line: -            var processClump = function() {
>, <Line: -                // find the middle x value
>, <Line: -                pmid = _events[right].getOptions().min -
>, <Line: -                    (_events[right].getOptions().min - _events[left].getOptions().min) / 2;
>, <Line: -                cmid = xaxis.p2c(pmid);
>, <Line: -                // hide the events between the discovered range
>, <Line: -                while (left <= right) {
>, <Line: -                    _events[left++].visual().getObject().hide();
>, <Line: -                }
>, <Line: -                // draw a vertical line in the middle of where they are
>, <Line: -                if (_insidePlot(pmid)) {
>, <Line: -                    _drawLine('#000', 1, { x: cmid, y: 0 }, { x: cmid, y: plot.height() });
>, <Line: -                }
>, <Line: -            };
>, <Line: -            if (xaxis.min && xaxis.max) {
>, <Line: -                range = xaxis.max - xaxis.min;
>, <Line: -                for (var i = 1; i < _events.length; i++) {
>, <Line: -                    diff = _events[i].getOptions().min - _events[i - 1].getOptions().min;
>, <Line: -                    if (diff / range > 0.007) {  //enough variance
>, <Line: -                        // has a clump has been found
>, <Line: -                        if (right != -1) {
>, <Line: -                            //processClump();
>, <Line: -                        }
>, <Line: -                        right = -1;
>, <Line: -                        left = i;
>, <Line: -                    } else {    // not enough variance
>, <Line: -                        right = i;
>, <Line: -                        // handle to final case
>, <Line: -                        if (i == _events.length - 1) {
>, <Line: -                            //processClump();
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -        };
>, <Line: -        var _buildDiv = function(event){
>, <Line: -            //var po = plot.pointOffset({ x: 450, y: 1});
>, <Line: -            var container = plot.getPlaceholder(), o = plot.getPlotOffset(), yaxis,
>, <Line: -            xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1], axes = plot.getAxes();
>, <Line: -            var top, left, div, icon, level, drawableEvent;
>, <Line: -            // determine the y axis used
>, <Line: -            if (axes.yaxis && axes.yaxis.used) yaxis = axes.yaxis;
>, <Line: -            if (axes.yaxis2 && axes.yaxis2.used) yaxis = axes.yaxis2;
>, <Line: -            // use the default icon and level
>, <Line: -            if (_types == null || !_types[event.eventType] || !_types[event.eventType].icon) {
>, <Line: -                icon = DEFAULT_ICON;
>, <Line: -                level = 0;
>, <Line: -            } else {
>, <Line: -                icon = _types[event.eventType].icon;
>, <Line: -                level = _types[event.eventType].level;
>, <Line: -            }
>, <Line: -            div = $('<i style="position:absolute" class="'+icon.icon+'"></i>').appendTo(container);
>, <Line: -            top = o.top + plot.height() - icon.size + 1;
>, <Line: -            left = xaxis.p2c(event.min) + o.left - icon.size / 2;
>, <Line: -            div.css({
>, <Line: -                left: left + 'px',
>, <Line: -                top: top,
>, <Line: -                color: icon.color,
>, <Line: -                "text-shadow" : "1px 1px "+icon.outline+", -1px -1px "+icon.outline+", -1px 1px "+icon.outline+", 1px -1px "+icon.outline,
>, <Line: -                'font-size': icon['size']+'px',
>, <Line: -            });
>, <Line: -            div.hide();
>, <Line: -            div.data({
>, <Line: -                "event": event
>, <Line: -            });
>, <Line: -            div.hover(
>, <Line: -            // mouseenter
>, <Line: -            function(){
>, <Line: -                var pos = $(this).offset();
>, <Line: -                _showTooltip(pos.left + $(this).width() / 2, pos.top, $(this).data("event"));
>, <Line: -            },
>, <Line: -            // mouseleave
>, <Line: -            function(){
>, <Line: -                //$(this).data("bouncing", false);
>, <Line: -                $('#tooltip').remove();
>, <Line: -                plot.clearSelection();
>, <Line: -            });
>, <Line: -            drawableEvent = new DrawableEvent(
>, <Line: -                div,
>, <Line: -                function(obj){
>, <Line: -                    obj.show();
>, <Line: -                },
>, <Line: -                function(obj){
>, <Line: -                    obj.remove();
>, <Line: -                },
>, <Line: -                function(obj, position){
>, <Line: -                    obj.css({
>, <Line: -                        top: position.top,
>, <Line: -                        left: position.left
>, <Line: -                    });
>, <Line: -                },
>, <Line: -                left, top, div.width(), div.height());
>, <Line: -            return drawableEvent;
>, <Line: -        };
>, <Line: -        var _getEventsAtPos = function(x, y){
>, <Line: -            var found = [], left, top, width, height;
>, <Line: -            $.each(_events, function(index, val){
>, <Line: -                left = val.div.offset().left;
>, <Line: -                top = val.div.offset().top;
>, <Line: -                width = val.div.width();
>, <Line: -                height = val.div.height();
>, <Line: -                if (x >= left && x <= left + width && y >= top && y <= top + height) {
>, <Line: -                    found.push(val);
>, <Line: -                }
>, <Line: -                return found;
>, <Line: -            });
>, <Line: -        };
>, <Line: -        var _insidePlot = function(x) {
>, <Line: -            var xaxis = plot.getXAxes()[plot.getOptions().events.xaxis - 1];
>, <Line: -            var xc = xaxis.p2c(x);
>, <Line: -            return xc > 0 && xc < xaxis.p2c(xaxis.max);
>, <Line: -        };
>, <Line: -        var _drawLine = function(color, lineWidth, from, to) {
>, <Line: -            var ctx = plot.getCanvas().getContext("2d");
>, <Line: -            var plotOffset = plot.getPlotOffset();
>, <Line: -            ctx.save();
>, <Line: -            ctx.translate(plotOffset.left, plotOffset.top);
>, <Line: -            ctx.beginPath();
>, <Line: -            ctx.strokeStyle = color;
>, <Line: -            ctx.lineWidth = lineWidth;
>, <Line: -            ctx.moveTo(from.x, from.y);
>, <Line: -            ctx.lineTo(to.x, to.y);
>, <Line: -            ctx.stroke();
>, <Line: -            ctx.restore();
>, <Line: -        };
>, <Line: -        /**
>, <Line: -         * Runs over the given 2d array of event objects and returns an object
>, <Line: -         * containing:
>, <Line: -         *
>, <Line: -         * {
>, <Line: -         *
>, <Line: -         * @param {Object} types
>, <Line: -         *          an object containing event types
>, <Line: -         * @param {Object} events
>, <Line: -         *          an array of event to cluster
>, <Line: -         * @param {Object} range
>, <Line: -         *          the current graph range
>, <Line: -         */
>, <Line: -        var _clusterEvents = function(types, events, range) {
>, <Line: -            //TODO: support custom types
>, <Line: -            var groups, clusters = [], newEvents = [];
>, <Line: -            // split into same evenType groups
>, <Line: -            groups = _groupEvents(events);
>, <Line: -            $.each(groups.eventTypes, function(index, val) {
>, <Line: -                clusters.push(_varianceAlgorithm(groups.groupedEvents[val], 1, range));
>, <Line: -            });
>, <Line: -            // summarise clusters
>, <Line: -            $.each(clusters, function(index, eventType) {
>, <Line: -                // each cluser of each event type
>, <Line: -                $.each(eventType, function(index, cluster) {
>, <Line: -                    var newEvent = {
>, <Line: -                        min: cluster[0].min,
>, <Line: -                        max: cluster[cluster.length - 1].min,    //TODO: needs to be max of end event if it exists
>, <Line: -                        eventType: cluster[0].eventType + ",cluster",
>, <Line: -                        title: "Cluster of: " + cluster[0].title,
>, <Line: -                        description: cluster[0].description + ", Number of events in the cluster: " + cluster.length
>, <Line: -                    };
>, <Line: -                    newEvents.push(newEvent);
>, <Line: -                });
>, <Line: -            });
>, <Line: -            return { types: types, data: newEvents };
>, <Line: -        };
>, <Line: -        /**
>, <Line: -         * Runs over the given 2d array of event objects and returns an object
>, <Line: -         * containing:
>, <Line: -         *
>, <Line: -         * {
>, <Line: -         *
>, <Line: -         * @param {Object} events
>, <Line: -         *          an array of event objects
>, <Line: -         */
>, <Line: -        var _groupEvents = function(events) {
>, <Line: -            var eventTypes = [], groupedEvents = {};
>, <Line: -            $.each(events, function(index, val) {
>, <Line: -                if (!groupedEvents[val.eventType]) {
>, <Line: -                    groupedEvents[val.eventType] = [];
>, <Line: -                    eventTypes.push(val.eventType);
>, <Line: -                }
>, <Line: -                groupedEvents[val.eventType].push(val);
>, <Line: -            });
>, <Line: -            return { eventTypes: eventTypes, groupedEvents: groupedEvents };
>, <Line: -        };
>, <Line: -        /**
>, <Line: -         * Runs over the given 2d array of event objects and returns a 3d array of
>, <Line: -         * the same events,but clustered into groups with similar x deltas.
>, <Line: -         *
>, <Line: -         * This function assumes that the events are related. So it must be run on
>, <Line: -         * each set of related events.
>, <Line: -         *
>, <Line: -         * @param {Object} events
>, <Line: -         *          an array of event objects
>, <Line: -         * @param {Object} sens
>, <Line: -         *          a measure of the level of grouping tolerance
>, <Line: -         * @param {Object} space
>, <Line: -         *          the size of the space we have to place clusters within
>, <Line: -         */
>, <Line: -        var _varianceAlgorithm = function(events, sens, space) {
>, <Line: -            var cluster, clusters = [], sum = 0, avg, density;
>, <Line: -            // find the average x delta
>, <Line: -            for (var i = 1; i < events.length - 1; i++) {
>, <Line: -                sum += events[i].min - events[i - 1].min;
>, <Line: -            }
>, <Line: -            avg = sum / (events.length - 2);
>, <Line: -            // first point
>, <Line: -            cluster = [ events[0] ];
>, <Line: -            // middle points
>, <Line: -            for (var i = 1; i < events.length; i++) {
>, <Line: -                var leftDiff = events[i].min - events[i - 1].min;
>, <Line: -                density = leftDiff / space;
>, <Line: -                if (leftDiff > avg * sens && density > 0.05) {
>, <Line: -                    clusters.push(cluster);
>, <Line: -                    cluster = [ events[i] ];
>, <Line: -                } else {
>, <Line: -                    cluster.push(events[i]);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            clusters.push(cluster);
>, <Line: -            return clusters;
>, <Line: -        };
>, <Line: -    }
>, <Line: -    var options = {
>, <Line: -        events: {
>, <Line: -            levels: null,
>, <Line: -            data: null,
>, <Line: -            types: null,
>, <Line: -            xaxis: 1,
>, <Line: -            clustering: false
>, <Line: -        }
>, <Line: -    };
>, <Line: -    $.plot.plugins.push({
>, <Line: -        init: init,
>, <Line: -        options: options,
>, <Line: -        name: "events",
>, <Line: -        version: "0.20"
>, <Line: -    });
>, <Line: -    /**
>, <Line: -     * A class that allows for the drawing an remove of some object
>, <Line: -     *
>, <Line: -     * @param {Object} object
>, <Line: -     *          the drawable object
>, <Line: -     * @param {Object} drawFunc
>, <Line: -     *          the draw function
>, <Line: -     * @param {Object} clearFunc
>, <Line: -     *          the clear function
>, <Line: -     */
>, <Line: -    function DrawableEvent(object, drawFunc, clearFunc, moveFunc, left, top, width, height){
>, <Line: -        var _object = object, _drawFunc = drawFunc, _clearFunc = clearFunc, _moveFunc = moveFunc,
>, <Line: -        _position = { left: left, top: top }, _width = width, _height = height;
>, <Line: -        this.width = function() { return _width; };
>, <Line: -        this.height = function() { return _height };
>, <Line: -        this.position = function() { return _position; };
>, <Line: -        this.draw = function() { _drawFunc(_object); };
>, <Line: -        this.clear = function() { _clearFunc(_object); };
>, <Line: -        this.getObject = function() { return _object; };
>, <Line: -        this.moveTo = function(position) {
>, <Line: -            _position = position;
>, <Line: -            _moveFunc(_object, _position);
>, <Line: -        };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Event class that stores options (eventType, min, max, title, description) and the object to draw.
>, <Line: -     *
>, <Line: -     * @param {Object} options
>, <Line: -     * @param {Object} drawableEvent
>, <Line: -     */
>, <Line: -    function VisualEvent(options, drawableEvent, level){
>, <Line: -        var _parent, _options = options, _drawableEvent = drawableEvent,
>, <Line: -            _level = level, _hidden = false;
>, <Line: -        this.visual = function() { return _drawableEvent; }
>, <Line: -        this.level = function() { return _level; };
>, <Line: -        this.getOptions = function() { return _options; };
>, <Line: -        this.getParent = function() { return _parent; };
>, <Line: -        this.isHidden = function() { return _hidden; };
>, <Line: -        this.hide = function() { _hidden = true; };
>, <Line: -        this.unhide = function() { _hidden = false; };
>, <Line: -    }
>, <Line: -    function compareEvents(a, b) {
>, <Line: -        var ao = a.getOptions(), bo = b.getOptions();
>, <Line: -        if (ao.min > bo.min) return 1;
>, <Line: -        if (ao.min < bo.min) return -1;
>, <Line: -        return 0;
>, <Line: -    };
>]