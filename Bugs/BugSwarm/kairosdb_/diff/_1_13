[<Line: +package org.kairosdb.util;
>, <Line: +import com.google.common.base.Stopwatch;
>, <Line: +import com.google.common.collect.ImmutableSortedMap;
>, <Line: +import com.google.common.eventbus.EventBus;
>, <Line: +import org.kairosdb.core.datapoints.DoubleDataPointFactory;
>, <Line: +import org.kairosdb.core.datapoints.DoubleDataPointFactoryImpl;
>, <Line: +import org.kairosdb.events.DataPointEvent;
>, <Line: +import javax.inject.Inject;
>, <Line: +import java.util.List;
>, <Line: +import java.util.concurrent.*;
>, <Line: +/**
>, <Line: + Created by bhawkins on 10/27/16.
>, <Line: + */
>, <Line: +public class CongestionExecutorService extends AbstractExecutorService
>, <Line: +{
>, <Line: +	private final EventBus m_eventBus;
>, <Line: +	private final ExecutorService m_internalExecutor;
>, <Line: +	private final ThreadGroup m_threadGroup;
>, <Line: +	private final CongestionSemaphore m_semaphore;
>, <Line: +	private final CongestionTimer m_congestionTimer;
>, <Line: +	private int m_permitCount = 10;
>, <Line: +	@Inject
>, <Line: +	private DoubleDataPointFactory m_dataPointFactory = new DoubleDataPointFactoryImpl();
>, <Line: +	@Inject
>, <Line: +	public CongestionExecutorService(EventBus eventBus)
>, <Line: +	{
>, <Line: +		m_eventBus = eventBus;
>, <Line: +		m_congestionTimer = new CongestionTimer(m_permitCount);
>, <Line: +		m_semaphore = new CongestionSemaphore(m_permitCount);
>, <Line: +		m_threadGroup = new ThreadGroup("KairosDynamic");
>, <Line: +		/*m_internalExecutor = Executors.newCachedThreadPool(new ThreadFactory()
>, <Line: +		{
>, <Line: +			@Override
>, <Line: +			public Thread newThread(Runnable r)
>, <Line: +			{
>, <Line: +				Thread t = new Thread(m_threadGroup, "worker");
>, <Line: +				return t;
>, <Line: +			}
>, <Line: +		});*/
>, <Line: +		m_internalExecutor = Executors.newCachedThreadPool();
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void shutdown()
>, <Line: +	{
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public List<Runnable> shutdownNow()
>, <Line: +	{
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean isShutdown()
>, <Line: +	{
>, <Line: +		return false;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean isTerminated()
>, <Line: +	{
>, <Line: +		return false;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
>, <Line: +	{
>, <Line: +		return false;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void execute(Runnable command)
>, <Line: +	{
>, <Line: +		try
>, <Line: +		{
>, <Line: +			//System.out.println("Execute called");
>, <Line: +			m_semaphore.acquire();
>, <Line: +			//System.out.println("Submitting");
>, <Line: +			m_internalExecutor.submit(command);
>, <Line: +			//System.out.println("Done submitting");
>, <Line: +		}
>, <Line: +		catch (InterruptedException e)
>, <Line: +		{
>, <Line: +			e.printStackTrace();
>, <Line: +		}
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable)
>, <Line: +	{
>, <Line: +		//System.out.println("Returning new future");
>, <Line: +		return new DynamicFutureTask<T>(callable);
>, <Line: +	}
>, <Line: +	private class DynamicFutureTask<T> extends FutureTask<T>
>, <Line: +	{
>, <Line: +		private final Stopwatch m_stopwatch;
>, <Line: +		public DynamicFutureTask(Callable<T> callable)
>, <Line: +		{
>, <Line: +			super(callable);
>, <Line: +			m_stopwatch = Stopwatch.createUnstarted();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public void run()
>, <Line: +		{
>, <Line: +			System.out.println("DynamicFutureTask.run");
>, <Line: +			//Todo start stopwatch
>, <Line: +			m_stopwatch.start();
>, <Line: +			super.run();
>, <Line: +			m_stopwatch.stop();
>, <Line: +			//Todo do something with elapsed time
>, <Line: +			CongestionTimer.TimerStat timerStat = m_congestionTimer.reportTaskTime(m_stopwatch.elapsed(TimeUnit.MILLISECONDS));
>, <Line: +			m_semaphore.release();
>, <Line: +			if (timerStat != null)
>, <Line: +			{
>, <Line: +				System.out.println("Sending stats");
>, <Line: +				long now = System.currentTimeMillis();
>, <Line: +				ImmutableSortedMap<String, String> tags = ImmutableSortedMap.of("host", "test");
>, <Line: +				DataPointEvent dpe = new DataPointEvent("kairosdb.congestion.stats.min", tags,
>, <Line: +						m_dataPointFactory.createDataPoint(now, timerStat.min));
>, <Line: +				m_eventBus.post(dpe);
>, <Line: +				dpe = new DataPointEvent("kairosdb.congestion.stats.max", tags,
>, <Line: +						m_dataPointFactory.createDataPoint(now, timerStat.max));
>, <Line: +				m_eventBus.post(dpe);
>, <Line: +				dpe = new DataPointEvent("kairosdb.congestion.stats.avg", tags,
>, <Line: +						m_dataPointFactory.createDataPoint(now, timerStat.avg));
>, <Line: +				m_eventBus.post(dpe);
>, <Line: +				dpe = new DataPointEvent("kairosdb.congestion.stats.median", tags,
>, <Line: +						m_dataPointFactory.createDataPoint(now, timerStat.median));
>, <Line: +				m_eventBus.post(dpe);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public void set(T result)
>, <Line: +		{
>, <Line: +			//Todo Calculate time to run and adjust number of threads
>, <Line: +			super.set(result);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static class CongestionSemaphore extends Semaphore
>, <Line: +	{
>, <Line: +		public CongestionSemaphore(int permits)
>, <Line: +		{
>, <Line: +			super(permits);
>, <Line: +		}
>, <Line: +		public void reducePermits(int reduction)
>, <Line: +		{
>, <Line: +			super.reducePermits(reduction);
>, <Line: +		}
>, <Line: +	}
>, <Line: +}
>]
[]