[<Line: +	/************************************
>, <Line: +	 Constants
>, <Line: +	 ************************************/
>, <Line: +	var moment,
>, <Line: +		VERSION = '2.8.1',
>, <Line: +	// the global-scope this is NOT the global object in Node.js
>, <Line: +		globalScope = typeof global !== 'undefined' ? global : this,
>, <Line: +		oldGlobalMoment,
>, <Line: +		round = Math.round,
>, <Line: +		i,
>, <Line: +		YEAR = 0,
>, <Line: +		MONTH = 1,
>, <Line: +		DATE = 2,
>, <Line: +		HOUR = 3,
>, <Line: +		MINUTE = 4,
>, <Line: +		SECOND = 5,
>, <Line: +		MILLISECOND = 6,
>, <Line: +	// internal storage for locale config files
>, <Line: +		locales = {},
>, <Line: +	// extra moment internal properties (plugins register props here)
>, <Line: +		momentProperties = [],
>, <Line: +	// check for nodeJS
>, <Line: +		hasModule = (typeof module !== 'undefined' && module.exports),
>, <Line: +	// ASP.NET json date format regex
>, <Line: +		aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
>, <Line: +		aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
>, <Line: +	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
>, <Line: +	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
>, <Line: +		isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
>, <Line: +	// format tokens
>, <Line: +		formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
>, <Line: +		localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
>, <Line: +	// parsing token regexes
>, <Line: +		parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
>, <Line: +		parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
>, <Line: +		parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
>, <Line: +		parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
>, <Line: +		parseTokenDigits = /\d+/, // nonzero number of digits
>, <Line: +		parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
>, <Line: +		parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
>, <Line: +		parseTokenT = /T/i, // T (ISO separator)
>, <Line: +		parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
>, <Line: +		parseTokenOrdinal = /\d{1,2}/,
>, <Line: +	//strict parsing regexes
>, <Line: +		parseTokenOneDigit = /\d/, // 0 - 9
>, <Line: +		parseTokenTwoDigits = /\d\d/, // 00 - 99
>, <Line: +		parseTokenThreeDigits = /\d{3}/, // 000 - 999
>, <Line: +		parseTokenFourDigits = /\d{4}/, // 0000 - 9999
>, <Line: +		parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
>, <Line: +		parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf
>, <Line: +	// iso 8601 regex
>, <Line: +	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
>, <Line: +		isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
>, <Line: +		isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
>, <Line: +		isoDates = [
>, <Line: +			['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
>, <Line: +			['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
>, <Line: +			['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
>, <Line: +			['GGGG-[W]WW', /\d{4}-W\d{2}/],
>, <Line: +			['YYYY-DDD', /\d{4}-\d{3}/]
>, <Line: +		],
>, <Line: +	// iso time formats and regexes
>, <Line: +		isoTimes = [
>, <Line: +			['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
>, <Line: +			['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
>, <Line: +			['HH:mm', /(T| )\d\d:\d\d/],
>, <Line: +			['HH', /(T| )\d\d/]
>, <Line: +		],
>, <Line: +	// timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
>, <Line: +		parseTimezoneChunker = /([\+\-]|\d\d)/gi,
>, <Line: +	// getter and setter names
>, <Line: +		proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
>, <Line: +		unitMillisecondFactors = {
>, <Line: +			'Milliseconds': 1,
>, <Line: +			'Seconds': 1e3,
>, <Line: +			'Minutes': 6e4,
>, <Line: +			'Hours': 36e5,
>, <Line: +			'Days': 864e5,
>, <Line: +			'Months': 2592e6,
>, <Line: +			'Years': 31536e6
>, <Line: +		},
>, <Line: +		unitAliases = {
>, <Line: +			ms: 'millisecond',
>, <Line: +			s: 'second',
>, <Line: +			m: 'minute',
>, <Line: +			h: 'hour',
>, <Line: +			d: 'day',
>, <Line: +			D: 'date',
>, <Line: +			w: 'week',
>, <Line: +			W: 'isoWeek',
>, <Line: +			M: 'month',
>, <Line: +			Q: 'quarter',
>, <Line: +			y: 'year',
>, <Line: +			DDD: 'dayOfYear',
>, <Line: +			e: 'weekday',
>, <Line: +			E: 'isoWeekday',
>, <Line: +			gg: 'weekYear',
>, <Line: +			GG: 'isoWeekYear'
>, <Line: +		},
>, <Line: +		camelFunctions = {
>, <Line: +			dayofyear: 'dayOfYear',
>, <Line: +			isoweekday: 'isoWeekday',
>, <Line: +			isoweek: 'isoWeek',
>, <Line: +			weekyear: 'weekYear',
>, <Line: +			isoweekyear: 'isoWeekYear'
>, <Line: +		},
>, <Line: +	// format function strings
>, <Line: +		formatFunctions = {},
>, <Line: +	// default relative time thresholds
>, <Line: +		relativeTimeThresholds = {
>, <Line: +			s: 45,  // seconds to minute
>, <Line: +			m: 45,  // minutes to hour
>, <Line: +			h: 22,  // hours to day
>, <Line: +			d: 26,  // days to month
>, <Line: +			M: 11   // months to year
>, <Line: +		},
>, <Line: +	// tokens to ordinalize and pad
>, <Line: +		ordinalizeTokens = 'DDD w W M D d'.split(' '),
>, <Line: +		paddedTokens = 'M D H h m s w W'.split(' '),
>, <Line: +		formatTokenFunctions = {
>, <Line: +			M: function () {
>, <Line: +				return this.month() + 1;
>, <Line: +			},
>, <Line: +			MMM: function (format) {
>, <Line: +				return this.localeData().monthsShort(this, format);
>, <Line: +			},
>, <Line: +			MMMM: function (format) {
>, <Line: +				return this.localeData().months(this, format);
>, <Line: +			},
>, <Line: +			D: function () {
>, <Line: +				return this.date();
>, <Line: +			},
>, <Line: +			DDD: function () {
>, <Line: +				return this.dayOfYear();
>, <Line: +			},
>, <Line: +			d: function () {
>, <Line: +				return this.day();
>, <Line: +			},
>, <Line: +			dd: function (format) {
>, <Line: +				return this.localeData().weekdaysMin(this, format);
>, <Line: +			},
>, <Line: +			ddd: function (format) {
>, <Line: +				return this.localeData().weekdaysShort(this, format);
>, <Line: +			},
>, <Line: +			dddd: function (format) {
>, <Line: +				return this.localeData().weekdays(this, format);
>, <Line: +			},
>, <Line: +			w: function () {
>, <Line: +				return this.week();
>, <Line: +			},
>, <Line: +			W: function () {
>, <Line: +				return this.isoWeek();
>, <Line: +			},
>, <Line: +			YY: function () {
>, <Line: +				return leftZeroFill(this.year() % 100, 2);
>, <Line: +			},
>, <Line: +			YYYY: function () {
>, <Line: +				return leftZeroFill(this.year(), 4);
>, <Line: +			},
>, <Line: +			YYYYY: function () {
>, <Line: +				return leftZeroFill(this.year(), 5);
>, <Line: +			},
>, <Line: +			YYYYYY: function () {
>, <Line: +				var y = this.year(), sign = y >= 0 ? '+' : '-';
>, <Line: +				return sign + leftZeroFill(Math.abs(y), 6);
>, <Line: +			},
>, <Line: +			gg: function () {
>, <Line: +				return leftZeroFill(this.weekYear() % 100, 2);
>, <Line: +			},
>, <Line: +			gggg: function () {
>, <Line: +				return leftZeroFill(this.weekYear(), 4);
>, <Line: +			},
>, <Line: +			ggggg: function () {
>, <Line: +				return leftZeroFill(this.weekYear(), 5);
>, <Line: +			},
>, <Line: +			GG: function () {
>, <Line: +				return leftZeroFill(this.isoWeekYear() % 100, 2);
>, <Line: +			},
>, <Line: +			GGGG: function () {
>, <Line: +				return leftZeroFill(this.isoWeekYear(), 4);
>, <Line: +			},
>, <Line: +			GGGGG: function () {
>, <Line: +				return leftZeroFill(this.isoWeekYear(), 5);
>, <Line: +			},
>, <Line: +			e: function () {
>, <Line: +				return this.weekday();
>, <Line: +			},
>, <Line: +			E: function () {
>, <Line: +				return this.isoWeekday();
>, <Line: +			},
>, <Line: +			a: function () {
>, <Line: +				return this.localeData().meridiem(this.hours(), this.minutes(), true);
>, <Line: +			},
>, <Line: +			A: function () {
>, <Line: +				return this.localeData().meridiem(this.hours(), this.minutes(), false);
>, <Line: +			},
>, <Line: +			H: function () {
>, <Line: +				return this.hours();
>, <Line: +			},
>, <Line: +			h: function () {
>, <Line: +				return this.hours() % 12 || 12;
>, <Line: +			},
>, <Line: +			m: function () {
>, <Line: +				return this.minutes();
>, <Line: +			},
>, <Line: +			s: function () {
>, <Line: +				return this.seconds();
>, <Line: +			},
>, <Line: +			S: function () {
>, <Line: +				return toInt(this.milliseconds() / 100);
>, <Line: +			},
>, <Line: +			SS: function () {
>, <Line: +				return leftZeroFill(toInt(this.milliseconds() / 10), 2);
>, <Line: +			},
>, <Line: +			SSS: function () {
>, <Line: +				return leftZeroFill(this.milliseconds(), 3);
>, <Line: +			},
>, <Line: +			SSSS: function () {
>, <Line: +				return leftZeroFill(this.milliseconds(), 3);
>, <Line: +			},
>, <Line: +			Z: function () {
>, <Line: +				var a = -this.zone(),
>, <Line: +					b = '+';
>, <Line: +				if (a < 0) {
>, <Line: +					a = -a;
>, <Line: +					b = '-';
>, <Line: +				}
>, <Line: +				return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
>, <Line: +			},
>, <Line: +			ZZ: function () {
>, <Line: +				var a = -this.zone(),
>, <Line: +					b = '+';
>, <Line: +				if (a < 0) {
>, <Line: +					a = -a;
>, <Line: +					b = '-';
>, <Line: +				}
>, <Line: +				return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
>, <Line: +			},
>, <Line: +			z: function () {
>, <Line: +				return this.zoneAbbr();
>, <Line: +			},
>, <Line: +			zz: function () {
>, <Line: +				return this.zoneName();
>, <Line: +			},
>, <Line: +			X: function () {
>, <Line: +				return this.unix();
>, <Line: +			},
>, <Line: +			Q: function () {
>, <Line: +				return this.quarter();
>, <Line: +			}
>, <Line: +		},
>, <Line: +		deprecations = {},
>, <Line: +		lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
>, <Line: +	// Pick the first defined of two or three arguments. dfl comes from
>, <Line: +	// default.
>, <Line: +	function dfl(a, b, c) {
>, <Line: +		switch (arguments.length) {
>, <Line: +			case 2:
>, <Line: +				return a != null ? a : b;
>, <Line: +			case 3:
>, <Line: +				return a != null ? a : b != null ? b : c;
>, <Line: +			default:
>, <Line: +				throw new Error('Implement me');
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function defaultParsingFlags() {
>, <Line: +		// We need to deep clone this object, and es5 standard is not very
>, <Line: +		// helpful.
>, <Line: +		return {
>, <Line: +			empty: false,
>, <Line: +			unusedTokens: [],
>, <Line: +			unusedInput: [],
>, <Line: +			overflow: -2,
>, <Line: +			charsLeftOver: 0,
>, <Line: +			nullInput: false,
>, <Line: +			invalidMonth: null,
>, <Line: +			invalidFormat: false,
>, <Line: +			userInvalidated: false,
>, <Line: +			iso: false
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function printMsg(msg) {
>, <Line: +		if (moment.suppressDeprecationWarnings === false &&
>, <Line: +			typeof console !== 'undefined' && console.warn) {
>, <Line: +			console.warn("Deprecation warning: " + msg);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function deprecate(msg, fn) {
>, <Line: +		var firstTime = true;
>, <Line: +		return extend(function () {
>, <Line: +			if (firstTime) {
>, <Line: +				printMsg(msg);
>, <Line: +				firstTime = false;
>, <Line: +			}
>, <Line: +			return fn.apply(this, arguments);
>, <Line: +		}, fn);
>, <Line: +	}
>, <Line: +	function deprecateSimple(name, msg) {
>, <Line: +		if (!deprecations[name]) {
>, <Line: +			printMsg(msg);
>, <Line: +			deprecations[name] = true;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function padToken(func, count) {
>, <Line: +		return function (a) {
>, <Line: +			return leftZeroFill(func.call(this, a), count);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function ordinalizeToken(func, period) {
>, <Line: +		return function (a) {
>, <Line: +			return this.localeData().ordinal(func.call(this, a), period);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	while (ordinalizeTokens.length) {
>, <Line: +		i = ordinalizeTokens.pop();
>, <Line: +		formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
>, <Line: +	}
>, <Line: +	while (paddedTokens.length) {
>, <Line: +		i = paddedTokens.pop();
>, <Line: +		formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
>, <Line: +	}
>, <Line: +	formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
>, <Line: +	/************************************
>, <Line: +	 Constructors
>, <Line: +	 ************************************/
>, <Line: +	function Locale() {
>, <Line: +	}
>, <Line: +	// Moment prototype object
>, <Line: +	function Moment(config, skipOverflow) {
>, <Line: +		if (skipOverflow !== false) {
>, <Line: +			checkOverflow(config);
>, <Line: +		}
>, <Line: +		copyConfig(this, config);
>, <Line: +		this._d = new Date(+config._d);
>, <Line: +	}
>, <Line: +	// Duration Constructor
>, <Line: +	function Duration(duration) {
>, <Line: +		var normalizedInput = normalizeObjectUnits(duration),
>, <Line: +			years = normalizedInput.year || 0,
>, <Line: +			quarters = normalizedInput.quarter || 0,
>, <Line: +			months = normalizedInput.month || 0,
>, <Line: +			weeks = normalizedInput.week || 0,
>, <Line: +			days = normalizedInput.day || 0,
>, <Line: +			hours = normalizedInput.hour || 0,
>, <Line: +			minutes = normalizedInput.minute || 0,
>, <Line: +			seconds = normalizedInput.second || 0,
>, <Line: +			milliseconds = normalizedInput.millisecond || 0;
>, <Line: +		// representation for dateAddRemove
>, <Line: +		this._milliseconds = +milliseconds +
>, <Line: +			seconds * 1e3 + // 1000
>, <Line: +			minutes * 6e4 + // 1000 * 60
>, <Line: +			hours * 36e5; // 1000 * 60 * 60
>, <Line: +		// Because of dateAddRemove treats 24 hours as different from a
>, <Line: +		// day when working around DST, we need to store them separately
>, <Line: +		this._days = +days +
>, <Line: +			weeks * 7;
>, <Line: +		// It is impossible translate months into days without knowing
>, <Line: +		// which months you are are talking about, so we have to store
>, <Line: +		// it separately.
>, <Line: +		this._months = +months +
>, <Line: +			quarters * 3 +
>, <Line: +			years * 12;
>, <Line: +		this._data = {};
>, <Line: +		this._locale = moment.localeData();
>, <Line: +		this._bubble();
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Helpers
>, <Line: +	 ************************************/
>, <Line: +	function extend(a, b) {
>, <Line: +		for (var i in b) {
>, <Line: +			if (b.hasOwnProperty(i)) {
>, <Line: +				a[i] = b[i];
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (b.hasOwnProperty('toString')) {
>, <Line: +			a.toString = b.toString;
>, <Line: +		}
>, <Line: +		if (b.hasOwnProperty('valueOf')) {
>, <Line: +			a.valueOf = b.valueOf;
>, <Line: +		}
>, <Line: +		return a;
>, <Line: +	}
>, <Line: +	function copyConfig(to, from) {
>, <Line: +		var i, prop, val;
>, <Line: +		if (typeof from._isAMomentObject !== 'undefined') {
>, <Line: +			to._isAMomentObject = from._isAMomentObject;
>, <Line: +		}
>, <Line: +		if (typeof from._i !== 'undefined') {
>, <Line: +			to._i = from._i;
>, <Line: +		}
>, <Line: +		if (typeof from._f !== 'undefined') {
>, <Line: +			to._f = from._f;
>, <Line: +		}
>, <Line: +		if (typeof from._l !== 'undefined') {
>, <Line: +			to._l = from._l;
>, <Line: +		}
>, <Line: +		if (typeof from._strict !== 'undefined') {
>, <Line: +			to._strict = from._strict;
>, <Line: +		}
>, <Line: +		if (typeof from._tzm !== 'undefined') {
>, <Line: +			to._tzm = from._tzm;
>, <Line: +		}
>, <Line: +		if (typeof from._isUTC !== 'undefined') {
>, <Line: +			to._isUTC = from._isUTC;
>, <Line: +		}
>, <Line: +		if (typeof from._offset !== 'undefined') {
>, <Line: +			to._offset = from._offset;
>, <Line: +		}
>, <Line: +		if (typeof from._pf !== 'undefined') {
>, <Line: +			to._pf = from._pf;
>, <Line: +		}
>, <Line: +		if (typeof from._locale !== 'undefined') {
>, <Line: +			to._locale = from._locale;
>, <Line: +		}
>, <Line: +		if (momentProperties.length > 0) {
>, <Line: +			for (i in momentProperties) {
>, <Line: +				prop = momentProperties[i];
>, <Line: +				val = from[prop];
>, <Line: +				if (typeof val !== 'undefined') {
>, <Line: +					to[prop] = val;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return to;
>, <Line: +	}
>, <Line: +	function absRound(number) {
>, <Line: +		if (number < 0) {
>, <Line: +			return Math.ceil(number);
>, <Line: +		} else {
>, <Line: +			return Math.floor(number);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// left zero fill a number
>, <Line: +	// see http://jsperf.com/left-zero-filling for performance comparison
>, <Line: +	function leftZeroFill(number, targetLength, forceSign) {
>, <Line: +		var output = '' + Math.abs(number),
>, <Line: +			sign = number >= 0;
>, <Line: +		while (output.length < targetLength) {
>, <Line: +			output = '0' + output;
>, <Line: +		}
>, <Line: +		return (sign ? (forceSign ? '+' : '') : '-') + output;
>, <Line: +	}
>, <Line: +	function positiveMomentsDifference(base, other) {
>, <Line: +		var res = {milliseconds: 0, months: 0};
>, <Line: +		res.months = other.month() - base.month() +
>, <Line: +			(other.year() - base.year()) * 12;
>, <Line: +		if (base.clone().add(res.months, 'M').isAfter(other)) {
>, <Line: +			--res.months;
>, <Line: +		}
>, <Line: +		res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
>, <Line: +		return res;
>, <Line: +	}
>, <Line: +	function momentsDifference(base, other) {
>, <Line: +		var res;
>, <Line: +		other = makeAs(other, base);
>, <Line: +		if (base.isBefore(other)) {
>, <Line: +			res = positiveMomentsDifference(base, other);
>, <Line: +		} else {
>, <Line: +			res = positiveMomentsDifference(other, base);
>, <Line: +			res.milliseconds = -res.milliseconds;
>, <Line: +			res.months = -res.months;
>, <Line: +		}
>, <Line: +		return res;
>, <Line: +	}
>, <Line: +	// TODO: remove 'name' arg after deprecation is removed
>, <Line: +	function createAdder(direction, name) {
>, <Line: +		return function (val, period) {
>, <Line: +			var dur, tmp;
>, <Line: +			//invert the arguments, but complain about it
>, <Line: +			if (period !== null && !isNaN(+period)) {
>, <Line: +				deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
>, <Line: +				tmp = val;
>, <Line: +				val = period;
>, <Line: +				period = tmp;
>, <Line: +			}
>, <Line: +			val = typeof val === 'string' ? +val : val;
>, <Line: +			dur = moment.duration(val, period);
>, <Line: +			addOrSubtractDurationFromMoment(this, dur, direction);
>, <Line: +			return this;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
>, <Line: +		var milliseconds = duration._milliseconds,
>, <Line: +			days = duration._days,
>, <Line: +			months = duration._months;
>, <Line: +		updateOffset = updateOffset == null ? true : updateOffset;
>, <Line: +		if (milliseconds) {
>, <Line: +			mom._d.setTime(+mom._d + milliseconds * isAdding);
>, <Line: +		}
>, <Line: +		if (days) {
>, <Line: +			rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
>, <Line: +		}
>, <Line: +		if (months) {
>, <Line: +			rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
>, <Line: +		}
>, <Line: +		if (updateOffset) {
>, <Line: +			moment.updateOffset(mom, days || months);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// check if is an array
>, <Line: +	function isArray(input) {
>, <Line: +		return Object.prototype.toString.call(input) === '[object Array]';
>, <Line: +	}
>, <Line: +	function isDate(input) {
>, <Line: +		return Object.prototype.toString.call(input) === '[object Date]' ||
>, <Line: +			input instanceof Date;
>, <Line: +	}
>, <Line: +	// compare two arrays, return the number of differences
>, <Line: +	function compareArrays(array1, array2, dontConvert) {
>, <Line: +		var len = Math.min(array1.length, array2.length),
>, <Line: +			lengthDiff = Math.abs(array1.length - array2.length),
>, <Line: +			diffs = 0,
>, <Line: +			i;
>, <Line: +		for (i = 0; i < len; i++) {
>, <Line: +			if ((dontConvert && array1[i] !== array2[i]) ||
>, <Line: +				(!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
>, <Line: +				diffs++;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return diffs + lengthDiff;
>, <Line: +	}
>, <Line: +	function normalizeUnits(units) {
>, <Line: +		if (units) {
>, <Line: +			var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
>, <Line: +			units = unitAliases[units] || camelFunctions[lowered] || lowered;
>, <Line: +		}
>, <Line: +		return units;
>, <Line: +	}
>, <Line: +	function normalizeObjectUnits(inputObject) {
>, <Line: +		var normalizedInput = {},
>, <Line: +			normalizedProp,
>, <Line: +			prop;
>, <Line: +		for (prop in inputObject) {
>, <Line: +			if (inputObject.hasOwnProperty(prop)) {
>, <Line: +				normalizedProp = normalizeUnits(prop);
>, <Line: +				if (normalizedProp) {
>, <Line: +					normalizedInput[normalizedProp] = inputObject[prop];
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return normalizedInput;
>, <Line: +	}
>, <Line: +	function makeList(field) {
>, <Line: +		var count, setter;
>, <Line: +		if (field.indexOf('week') === 0) {
>, <Line: +			count = 7;
>, <Line: +			setter = 'day';
>, <Line: +		}
>, <Line: +		else if (field.indexOf('month') === 0) {
>, <Line: +			count = 12;
>, <Line: +			setter = 'month';
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		moment[field] = function (format, index) {
>, <Line: +			var i, getter,
>, <Line: +				method = moment._locale[field],
>, <Line: +				results = [];
>, <Line: +			if (typeof format === 'number') {
>, <Line: +				index = format;
>, <Line: +				format = undefined;
>, <Line: +			}
>, <Line: +			getter = function (i) {
>, <Line: +				var m = moment().utc().set(setter, i);
>, <Line: +				return method.call(moment._locale, m, format || '');
>, <Line: +			};
>, <Line: +			if (index != null) {
>, <Line: +				return getter(index);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				for (i = 0; i < count; i++) {
>, <Line: +					results.push(getter(i));
>, <Line: +				}
>, <Line: +				return results;
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function toInt(argumentForCoercion) {
>, <Line: +		var coercedNumber = +argumentForCoercion,
>, <Line: +			value = 0;
>, <Line: +		if (coercedNumber !== 0 && isFinite(coercedNumber)) {
>, <Line: +			if (coercedNumber >= 0) {
>, <Line: +				value = Math.floor(coercedNumber);
>, <Line: +			} else {
>, <Line: +				value = Math.ceil(coercedNumber);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return value;
>, <Line: +	}
>, <Line: +	function daysInMonth(year, month) {
>, <Line: +		return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
>, <Line: +	}
>, <Line: +	function weeksInYear(year, dow, doy) {
>, <Line: +		return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
>, <Line: +	}
>, <Line: +	function daysInYear(year) {
>, <Line: +		return isLeapYear(year) ? 366 : 365;
>, <Line: +	}
>, <Line: +	function isLeapYear(year) {
>, <Line: +		return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
>, <Line: +	}
>, <Line: +	function checkOverflow(m) {
>, <Line: +		var overflow;
>, <Line: +		if (m._a && m._pf.overflow === -2) {
>, <Line: +			overflow =
>, <Line: +				m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
>, <Line: +					m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
>, <Line: +						m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
>, <Line: +							m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
>, <Line: +								m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
>, <Line: +									m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
>, <Line: +										-1;
>, <Line: +			if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
>, <Line: +				overflow = DATE;
>, <Line: +			}
>, <Line: +			m._pf.overflow = overflow;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function isValid(m) {
>, <Line: +		if (m._isValid == null) {
>, <Line: +			m._isValid = !isNaN(m._d.getTime()) &&
>, <Line: +				m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
>, <Line: +			if (m._strict) {
>, <Line: +				m._isValid = m._isValid &&
>, <Line: +					m._pf.charsLeftOver === 0 &&
>, <Line: +					m._pf.unusedTokens.length === 0;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return m._isValid;
>, <Line: +	}
>, <Line: +	function normalizeLocale(key) {
>, <Line: +		return key ? key.toLowerCase().replace('_', '-') : key;
>, <Line: +	}
>, <Line: +	// pick the locale from the array
>, <Line: +	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
>, <Line: +	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
>, <Line: +	function chooseLocale(names) {
>, <Line: +		var i = 0, j, next, locale, split;
>, <Line: +		while (i < names.length) {
>, <Line: +			split = normalizeLocale(names[i]).split('-');
>, <Line: +			j = split.length;
>, <Line: +			next = normalizeLocale(names[i + 1]);
>, <Line: +			next = next ? next.split('-') : null;
>, <Line: +			while (j > 0) {
>, <Line: +				locale = loadLocale(split.slice(0, j).join('-'));
>, <Line: +				if (locale) {
>, <Line: +					return locale;
>, <Line: +				}
>, <Line: +				if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
>, <Line: +					//the next array item is better than a shallower substring of this one
>, <Line: +					break;
>, <Line: +				}
>, <Line: +				j--;
>, <Line: +			}
>, <Line: +			i++;
>, <Line: +		}
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	function loadLocale(name) {
>, <Line: +		var oldLocale = null;
>, <Line: +		if (!locales[name] && hasModule) {
>, <Line: +			try {
>, <Line: +				oldLocale = moment.locale();
>, <Line: +				require('./locale/' + name);
>, <Line: +				// because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
>, <Line: +				moment.locale(oldLocale);
>, <Line: +			} catch (e) {
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return locales[name];
>, <Line: +	}
>, <Line: +	// Return a moment from input, that is local/utc/zone equivalent to model.
>, <Line: +	function makeAs(input, model) {
>, <Line: +		return model._isUTC ? moment(input).zone(model._offset || 0) :
>, <Line: +			moment(input).local();
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Locale
>, <Line: +	 ************************************/
>, <Line: +	extend(Locale.prototype, {
>, <Line: +		set: function (config) {
>, <Line: +			var prop, i;
>, <Line: +			for (i in config) {
>, <Line: +				prop = config[i];
>, <Line: +				if (typeof prop === 'function') {
>, <Line: +					this[i] = prop;
>, <Line: +				} else {
>, <Line: +					this['_' + i] = prop;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		_months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
>, <Line: +		months: function (m) {
>, <Line: +			return this._months[m.month()];
>, <Line: +		},
>, <Line: +		_monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
>, <Line: +		monthsShort: function (m) {
>, <Line: +			return this._monthsShort[m.month()];
>, <Line: +		},
>, <Line: +		monthsParse: function (monthName) {
>, <Line: +			var i, mom, regex;
>, <Line: +			if (!this._monthsParse) {
>, <Line: +				this._monthsParse = [];
>, <Line: +			}
>, <Line: +			for (i = 0; i < 12; i++) {
>, <Line: +				// make the regex if we don't have it already
>, <Line: +				if (!this._monthsParse[i]) {
>, <Line: +					mom = moment.utc([2000, i]);
>, <Line: +					regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
>, <Line: +					this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
>, <Line: +				}
>, <Line: +				// test the regex
>, <Line: +				if (this._monthsParse[i].test(monthName)) {
>, <Line: +					return i;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		_weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
>, <Line: +		weekdays: function (m) {
>, <Line: +			return this._weekdays[m.day()];
>, <Line: +		},
>, <Line: +		_weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
>, <Line: +		weekdaysShort: function (m) {
>, <Line: +			return this._weekdaysShort[m.day()];
>, <Line: +		},
>, <Line: +		_weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
>, <Line: +		weekdaysMin: function (m) {
>, <Line: +			return this._weekdaysMin[m.day()];
>, <Line: +		},
>, <Line: +		weekdaysParse: function (weekdayName) {
>, <Line: +			var i, mom, regex;
>, <Line: +			if (!this._weekdaysParse) {
>, <Line: +				this._weekdaysParse = [];
>, <Line: +			}
>, <Line: +			for (i = 0; i < 7; i++) {
>, <Line: +				// make the regex if we don't have it already
>, <Line: +				if (!this._weekdaysParse[i]) {
>, <Line: +					mom = moment([2000, 1]).day(i);
>, <Line: +					regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
>, <Line: +					this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
>, <Line: +				}
>, <Line: +				// test the regex
>, <Line: +				if (this._weekdaysParse[i].test(weekdayName)) {
>, <Line: +					return i;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		_longDateFormat: {
>, <Line: +			LT: 'h:mm A',
>, <Line: +			L: 'MM/DD/YYYY',
>, <Line: +			LL: 'MMMM D, YYYY',
>, <Line: +			LLL: 'MMMM D, YYYY LT',
>, <Line: +			LLLL: 'dddd, MMMM D, YYYY LT'
>, <Line: +		},
>, <Line: +		longDateFormat: function (key) {
>, <Line: +			var output = this._longDateFormat[key];
>, <Line: +			if (!output && this._longDateFormat[key.toUpperCase()]) {
>, <Line: +				output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
>, <Line: +					return val.slice(1);
>, <Line: +				});
>, <Line: +				this._longDateFormat[key] = output;
>, <Line: +			}
>, <Line: +			return output;
>, <Line: +		},
>, <Line: +		isPM: function (input) {
>, <Line: +			// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
>, <Line: +			// Using charAt should be more compatible.
>, <Line: +			return ((input + '').toLowerCase().charAt(0) === 'p');
>, <Line: +		},
>, <Line: +		_meridiemParse: /[ap]\.?m?\.?/i,
>, <Line: +		meridiem: function (hours, minutes, isLower) {
>, <Line: +			if (hours > 11) {
>, <Line: +				return isLower ? 'pm' : 'PM';
>, <Line: +			} else {
>, <Line: +				return isLower ? 'am' : 'AM';
>, <Line: +			}
>, <Line: +		},
>, <Line: +		_calendar: {
>, <Line: +			sameDay: '[Today at] LT',
>, <Line: +			nextDay: '[Tomorrow at] LT',
>, <Line: +			nextWeek: 'dddd [at] LT',
>, <Line: +			lastDay: '[Yesterday at] LT',
>, <Line: +			lastWeek: '[Last] dddd [at] LT',
>, <Line: +			sameElse: 'L'
>, <Line: +		},
>, <Line: +		calendar: function (key, mom) {
>, <Line: +			var output = this._calendar[key];
>, <Line: +			return typeof output === 'function' ? output.apply(mom) : output;
>, <Line: +		},
>, <Line: +		_relativeTime: {
>, <Line: +			future: 'in %s',
>, <Line: +			past: '%s ago',
>, <Line: +			s: 'a few seconds',
>, <Line: +			m: 'a minute',
>, <Line: +			mm: '%d minutes',
>, <Line: +			h: 'an hour',
>, <Line: +			hh: '%d hours',
>, <Line: +			d: 'a day',
>, <Line: +			dd: '%d days',
>, <Line: +			M: 'a month',
>, <Line: +			MM: '%d months',
>, <Line: +			y: 'a year',
>, <Line: +			yy: '%d years'
>, <Line: +		},
>, <Line: +		relativeTime: function (number, withoutSuffix, string, isFuture) {
>, <Line: +			var output = this._relativeTime[string];
>, <Line: +			return (typeof output === 'function') ?
>, <Line: +				output(number, withoutSuffix, string, isFuture) :
>, <Line: +				output.replace(/%d/i, number);
>, <Line: +		},
>, <Line: +		pastFuture: function (diff, output) {
>, <Line: +			var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
>, <Line: +			return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
>, <Line: +		},
>, <Line: +		ordinal: function (number) {
>, <Line: +			return this._ordinal.replace('%d', number);
>, <Line: +		},
>, <Line: +		_ordinal: '%d',
>, <Line: +		preparse: function (string) {
>, <Line: +			return string;
>, <Line: +		},
>, <Line: +		postformat: function (string) {
>, <Line: +			return string;
>, <Line: +		},
>, <Line: +		week: function (mom) {
>, <Line: +			return weekOfYear(mom, this._week.dow, this._week.doy).week;
>, <Line: +		},
>, <Line: +		_week: {
>, <Line: +			dow: 0, // Sunday is the first day of the week.
>, <Line: +			doy: 6  // The week that contains Jan 1st is the first week of the year.
>, <Line: +		},
>, <Line: +		_invalidDate: 'Invalid date',
>, <Line: +		invalidDate: function () {
>, <Line: +			return this._invalidDate;
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/************************************
>, <Line: +	 Formatting
>, <Line: +	 ************************************/
>, <Line: +	function removeFormattingTokens(input) {
>, <Line: +		if (input.match(/\[[\s\S]/)) {
>, <Line: +			return input.replace(/^\[|\]$/g, '');
>, <Line: +		}
>, <Line: +		return input.replace(/\\/g, '');
>, <Line: +	}
>, <Line: +	function makeFormatFunction(format) {
>, <Line: +		var array = format.match(formattingTokens), i, length;
>, <Line: +		for (i = 0, length = array.length; i < length; i++) {
>, <Line: +			if (formatTokenFunctions[array[i]]) {
>, <Line: +				array[i] = formatTokenFunctions[array[i]];
>, <Line: +			} else {
>, <Line: +				array[i] = removeFormattingTokens(array[i]);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return function (mom) {
>, <Line: +			var output = '';
>, <Line: +			for (i = 0; i < length; i++) {
>, <Line: +				output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
>, <Line: +			}
>, <Line: +			return output;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	// format date using native date object
>, <Line: +	function formatMoment(m, format) {
>, <Line: +		if (!m.isValid()) {
>, <Line: +			return m.localeData().invalidDate();
>, <Line: +		}
>, <Line: +		format = expandFormat(format, m.localeData());
>, <Line: +		if (!formatFunctions[format]) {
>, <Line: +			formatFunctions[format] = makeFormatFunction(format);
>, <Line: +		}
>, <Line: +		return formatFunctions[format](m);
>, <Line: +	}
>, <Line: +	function expandFormat(format, locale) {
>, <Line: +		var i = 5;
>, <Line: +		function replaceLongDateFormatTokens(input) {
>, <Line: +			return locale.longDateFormat(input) || input;
>, <Line: +		}
>, <Line: +		localFormattingTokens.lastIndex = 0;
>, <Line: +		while (i >= 0 && localFormattingTokens.test(format)) {
>, <Line: +			format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
>, <Line: +			localFormattingTokens.lastIndex = 0;
>, <Line: +			i -= 1;
>, <Line: +		}
>, <Line: +		return format;
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Parsing
>, <Line: +	 ************************************/
>, <Line: +	// get the regex to find the next token
>, <Line: +	function getParseRegexForToken(token, config) {
>, <Line: +		var a, strict = config._strict;
>, <Line: +		switch (token) {
>, <Line: +			case 'Q':
>, <Line: +				return parseTokenOneDigit;
>, <Line: +			case 'DDDD':
>, <Line: +				return parseTokenThreeDigits;
>, <Line: +			case 'YYYY':
>, <Line: +			case 'GGGG':
>, <Line: +			case 'gggg':
>, <Line: +				return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
>, <Line: +			case 'Y':
>, <Line: +			case 'G':
>, <Line: +			case 'g':
>, <Line: +				return parseTokenSignedNumber;
>, <Line: +			case 'YYYYYY':
>, <Line: +			case 'YYYYY':
>, <Line: +			case 'GGGGG':
>, <Line: +			case 'ggggg':
>, <Line: +				return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
>, <Line: +			case 'S':
>, <Line: +				if (strict) {
>, <Line: +					return parseTokenOneDigit;
>, <Line: +				}
>, <Line: +			/* falls through */
>, <Line: +			case 'SS':
>, <Line: +				if (strict) {
>, <Line: +					return parseTokenTwoDigits;
>, <Line: +				}
>, <Line: +			/* falls through */
>, <Line: +			case 'SSS':
>, <Line: +				if (strict) {
>, <Line: +					return parseTokenThreeDigits;
>, <Line: +				}
>, <Line: +			/* falls through */
>, <Line: +			case 'DDD':
>, <Line: +				return parseTokenOneToThreeDigits;
>, <Line: +			case 'MMM':
>, <Line: +			case 'MMMM':
>, <Line: +			case 'dd':
>, <Line: +			case 'ddd':
>, <Line: +			case 'dddd':
>, <Line: +				return parseTokenWord;
>, <Line: +			case 'a':
>, <Line: +			case 'A':
>, <Line: +				return config._locale._meridiemParse;
>, <Line: +			case 'X':
>, <Line: +				return parseTokenTimestampMs;
>, <Line: +			case 'Z':
>, <Line: +			case 'ZZ':
>, <Line: +				return parseTokenTimezone;
>, <Line: +			case 'T':
>, <Line: +				return parseTokenT;
>, <Line: +			case 'SSSS':
>, <Line: +				return parseTokenDigits;
>, <Line: +			case 'MM':
>, <Line: +			case 'DD':
>, <Line: +			case 'YY':
>, <Line: +			case 'GG':
>, <Line: +			case 'gg':
>, <Line: +			case 'HH':
>, <Line: +			case 'hh':
>, <Line: +			case 'mm':
>, <Line: +			case 'ss':
>, <Line: +			case 'ww':
>, <Line: +			case 'WW':
>, <Line: +				return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
>, <Line: +			case 'M':
>, <Line: +			case 'D':
>, <Line: +			case 'd':
>, <Line: +			case 'H':
>, <Line: +			case 'h':
>, <Line: +			case 'm':
>, <Line: +			case 's':
>, <Line: +			case 'w':
>, <Line: +			case 'W':
>, <Line: +			case 'e':
>, <Line: +			case 'E':
>, <Line: +				return parseTokenOneOrTwoDigits;
>, <Line: +			case 'Do':
>, <Line: +				return parseTokenOrdinal;
>, <Line: +			default :
>, <Line: +				a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
>, <Line: +				return a;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function timezoneMinutesFromString(string) {
>, <Line: +		string = string || '';
>, <Line: +		var possibleTzMatches = (string.match(parseTokenTimezone) || []),
>, <Line: +			tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
>, <Line: +			parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
>, <Line: +			minutes = +(parts[1] * 60) + toInt(parts[2]);
>, <Line: +		return parts[0] === '+' ? -minutes : minutes;
>, <Line: +	}
>, <Line: +	// function to convert string input to date
>, <Line: +	function addTimeToArrayFromToken(token, input, config) {
>, <Line: +		var a, datePartArray = config._a;
>, <Line: +		switch (token) {
>, <Line: +			// QUARTER
>, <Line: +			case 'Q':
>, <Line: +				if (input != null) {
>, <Line: +					datePartArray[MONTH] = (toInt(input) - 1) * 3;
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			// MONTH
>, <Line: +			case 'M' : // fall through to MM
>, <Line: +			case 'MM' :
>, <Line: +				if (input != null) {
>, <Line: +					datePartArray[MONTH] = toInt(input) - 1;
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			case 'MMM' : // fall through to MMMM
>, <Line: +			case 'MMMM' :
>, <Line: +				a = config._locale.monthsParse(input);
>, <Line: +				// if we didn't find a month name, mark the date as invalid.
>, <Line: +				if (a != null) {
>, <Line: +					datePartArray[MONTH] = a;
>, <Line: +				} else {
>, <Line: +					config._pf.invalidMonth = input;
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			// DAY OF MONTH
>, <Line: +			case 'D' : // fall through to DD
>, <Line: +			case 'DD' :
>, <Line: +				if (input != null) {
>, <Line: +					datePartArray[DATE] = toInt(input);
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			case 'Do' :
>, <Line: +				if (input != null) {
>, <Line: +					datePartArray[DATE] = toInt(parseInt(input, 10));
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			// DAY OF YEAR
>, <Line: +			case 'DDD' : // fall through to DDDD
>, <Line: +			case 'DDDD' :
>, <Line: +				if (input != null) {
>, <Line: +					config._dayOfYear = toInt(input);
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			// YEAR
>, <Line: +			case 'YY' :
>, <Line: +				datePartArray[YEAR] = moment.parseTwoDigitYear(input);
>, <Line: +				break;
>, <Line: +			case 'YYYY' :
>, <Line: +			case 'YYYYY' :
>, <Line: +			case 'YYYYYY' :
>, <Line: +				datePartArray[YEAR] = toInt(input);
>, <Line: +				break;
>, <Line: +			// AM / PM
>, <Line: +			case 'a' : // fall through to A
>, <Line: +			case 'A' :
>, <Line: +				config._isPm = config._locale.isPM(input);
>, <Line: +				break;
>, <Line: +			// 24 HOUR
>, <Line: +			case 'H' : // fall through to hh
>, <Line: +			case 'HH' : // fall through to hh
>, <Line: +			case 'h' : // fall through to hh
>, <Line: +			case 'hh' :
>, <Line: +				datePartArray[HOUR] = toInt(input);
>, <Line: +				break;
>, <Line: +			// MINUTE
>, <Line: +			case 'm' : // fall through to mm
>, <Line: +			case 'mm' :
>, <Line: +				datePartArray[MINUTE] = toInt(input);
>, <Line: +				break;
>, <Line: +			// SECOND
>, <Line: +			case 's' : // fall through to ss
>, <Line: +			case 'ss' :
>, <Line: +				datePartArray[SECOND] = toInt(input);
>, <Line: +				break;
>, <Line: +			// MILLISECOND
>, <Line: +			case 'S' :
>, <Line: +			case 'SS' :
>, <Line: +			case 'SSS' :
>, <Line: +			case 'SSSS' :
>, <Line: +				datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
>, <Line: +				break;
>, <Line: +			// UNIX TIMESTAMP WITH MS
>, <Line: +			case 'X':
>, <Line: +				config._d = new Date(parseFloat(input) * 1000);
>, <Line: +				break;
>, <Line: +			// TIMEZONE
>, <Line: +			case 'Z' : // fall through to ZZ
>, <Line: +			case 'ZZ' :
>, <Line: +				config._useUTC = true;
>, <Line: +				config._tzm = timezoneMinutesFromString(input);
>, <Line: +				break;
>, <Line: +			// WEEKDAY - human
>, <Line: +			case 'dd':
>, <Line: +			case 'ddd':
>, <Line: +			case 'dddd':
>, <Line: +				a = config._locale.weekdaysParse(input);
>, <Line: +				// if we didn't get a weekday name, mark the date as invalid
>, <Line: +				if (a != null) {
>, <Line: +					config._w = config._w || {};
>, <Line: +					config._w['d'] = a;
>, <Line: +				} else {
>, <Line: +					config._pf.invalidWeekday = input;
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			// WEEK, WEEK DAY - numeric
>, <Line: +			case 'w':
>, <Line: +			case 'ww':
>, <Line: +			case 'W':
>, <Line: +			case 'WW':
>, <Line: +			case 'd':
>, <Line: +			case 'e':
>, <Line: +			case 'E':
>, <Line: +				token = token.substr(0, 1);
>, <Line: +			/* falls through */
>, <Line: +			case 'gggg':
>, <Line: +			case 'GGGG':
>, <Line: +			case 'GGGGG':
>, <Line: +				token = token.substr(0, 2);
>, <Line: +				if (input) {
>, <Line: +					config._w = config._w || {};
>, <Line: +					config._w[token] = toInt(input);
>, <Line: +				}
>, <Line: +				break;
>, <Line: +			case 'gg':
>, <Line: +			case 'GG':
>, <Line: +				config._w = config._w || {};
>, <Line: +				config._w[token] = moment.parseTwoDigitYear(input);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function dayOfYearFromWeekInfo(config) {
>, <Line: +		var w, weekYear, week, weekday, dow, doy, temp;
>, <Line: +		w = config._w;
>, <Line: +		if (w.GG != null || w.W != null || w.E != null) {
>, <Line: +			dow = 1;
>, <Line: +			doy = 4;
>, <Line: +			// TODO: We need to take the current isoWeekYear, but that depends on
>, <Line: +			// how we interpret now (local, utc, fixed offset). So create
>, <Line: +			// a now version of current config (take local/utc/offset flags, and
>, <Line: +			// create now).
>, <Line: +			weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
>, <Line: +			week = dfl(w.W, 1);
>, <Line: +			weekday = dfl(w.E, 1);
>, <Line: +		} else {
>, <Line: +			dow = config._locale._week.dow;
>, <Line: +			doy = config._locale._week.doy;
>, <Line: +			weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
>, <Line: +			week = dfl(w.w, 1);
>, <Line: +			if (w.d != null) {
>, <Line: +				// weekday -- low day numbers are considered next week
>, <Line: +				weekday = w.d;
>, <Line: +				if (weekday < dow) {
>, <Line: +					++week;
>, <Line: +				}
>, <Line: +			} else if (w.e != null) {
>, <Line: +				// local weekday -- counting starts from begining of week
>, <Line: +				weekday = w.e + dow;
>, <Line: +			} else {
>, <Line: +				// default to begining of week
>, <Line: +				weekday = dow;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
>, <Line: +		config._a[YEAR] = temp.year;
>, <Line: +		config._dayOfYear = temp.dayOfYear;
>, <Line: +	}
>, <Line: +	// convert an array to a date.
>, <Line: +	// the array should mirror the parameters below
>, <Line: +	// note: all values past the year are optional and will default to the lowest possible value.
>, <Line: +	// [year, month, day , hour, minute, second, millisecond]
>, <Line: +	function dateFromConfig(config) {
>, <Line: +		var i, date, input = [], currentDate, yearToUse;
>, <Line: +		if (config._d) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		currentDate = currentDateArray(config);
>, <Line: +		//compute day of the year from weeks and weekdays
>, <Line: +		if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
>, <Line: +			dayOfYearFromWeekInfo(config);
>, <Line: +		}
>, <Line: +		//if the day of the year is set, figure out what it is
>, <Line: +		if (config._dayOfYear) {
>, <Line: +			yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
>, <Line: +			if (config._dayOfYear > daysInYear(yearToUse)) {
>, <Line: +				config._pf._overflowDayOfYear = true;
>, <Line: +			}
>, <Line: +			date = makeUTCDate(yearToUse, 0, config._dayOfYear);
>, <Line: +			config._a[MONTH] = date.getUTCMonth();
>, <Line: +			config._a[DATE] = date.getUTCDate();
>, <Line: +		}
>, <Line: +		// Default to current date.
>, <Line: +		// * if no year, month, day of month are given, default to today
>, <Line: +		// * if day of month is given, default month and year
>, <Line: +		// * if month is given, default only year
>, <Line: +		// * if year is given, don't default anything
>, <Line: +		for (i = 0; i < 3 && config._a[i] == null; ++i) {
>, <Line: +			config._a[i] = input[i] = currentDate[i];
>, <Line: +		}
>, <Line: +		// Zero out whatever was not defaulted, including time
>, <Line: +		for (; i < 7; i++) {
>, <Line: +			config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
>, <Line: +		}
>, <Line: +		config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
>, <Line: +		// Apply timezone offset from input. The actual zone can be changed
>, <Line: +		// with parseZone.
>, <Line: +		if (config._tzm != null) {
>, <Line: +			config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function dateFromObject(config) {
>, <Line: +		var normalizedInput;
>, <Line: +		if (config._d) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		normalizedInput = normalizeObjectUnits(config._i);
>, <Line: +		config._a = [
>, <Line: +			normalizedInput.year,
>, <Line: +			normalizedInput.month,
>, <Line: +			normalizedInput.day,
>, <Line: +			normalizedInput.hour,
>, <Line: +			normalizedInput.minute,
>, <Line: +			normalizedInput.second,
>, <Line: +			normalizedInput.millisecond
>, <Line: +		];
>, <Line: +		dateFromConfig(config);
>, <Line: +	}
>, <Line: +	function currentDateArray(config) {
>, <Line: +		var now = new Date();
>, <Line: +		if (config._useUTC) {
>, <Line: +			return [
>, <Line: +				now.getUTCFullYear(),
>, <Line: +				now.getUTCMonth(),
>, <Line: +				now.getUTCDate()
>, <Line: +			];
>, <Line: +		} else {
>, <Line: +			return [now.getFullYear(), now.getMonth(), now.getDate()];
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// date from string and format string
>, <Line: +	function makeDateFromStringAndFormat(config) {
>, <Line: +		if (config._f === moment.ISO_8601) {
>, <Line: +			parseISO(config);
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		config._a = [];
>, <Line: +		config._pf.empty = true;
>, <Line: +		// This array is used to make a Date, either with `new Date` or `Date.UTC`
>, <Line: +		var string = '' + config._i,
>, <Line: +			i, parsedInput, tokens, token, skipped,
>, <Line: +			stringLength = string.length,
>, <Line: +			totalParsedInputLength = 0;
>, <Line: +		tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
>, <Line: +		for (i = 0; i < tokens.length; i++) {
>, <Line: +			token = tokens[i];
>, <Line: +			parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
>, <Line: +			if (parsedInput) {
>, <Line: +				skipped = string.substr(0, string.indexOf(parsedInput));
>, <Line: +				if (skipped.length > 0) {
>, <Line: +					config._pf.unusedInput.push(skipped);
>, <Line: +				}
>, <Line: +				string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
>, <Line: +				totalParsedInputLength += parsedInput.length;
>, <Line: +			}
>, <Line: +			// don't parse if it's not a known token
>, <Line: +			if (formatTokenFunctions[token]) {
>, <Line: +				if (parsedInput) {
>, <Line: +					config._pf.empty = false;
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					config._pf.unusedTokens.push(token);
>, <Line: +				}
>, <Line: +				addTimeToArrayFromToken(token, parsedInput, config);
>, <Line: +			}
>, <Line: +			else if (config._strict && !parsedInput) {
>, <Line: +				config._pf.unusedTokens.push(token);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// add remaining unparsed input length to the string
>, <Line: +		config._pf.charsLeftOver = stringLength - totalParsedInputLength;
>, <Line: +		if (string.length > 0) {
>, <Line: +			config._pf.unusedInput.push(string);
>, <Line: +		}
>, <Line: +		// handle am pm
>, <Line: +		if (config._isPm && config._a[HOUR] < 12) {
>, <Line: +			config._a[HOUR] += 12;
>, <Line: +		}
>, <Line: +		// if is 12 am, change hours to 0
>, <Line: +		if (config._isPm === false && config._a[HOUR] === 12) {
>, <Line: +			config._a[HOUR] = 0;
>, <Line: +		}
>, <Line: +		dateFromConfig(config);
>, <Line: +		checkOverflow(config);
>, <Line: +	}
>, <Line: +	function unescapeFormat(s) {
>, <Line: +		return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
>, <Line: +			return p1 || p2 || p3 || p4;
>, <Line: +		});
>, <Line: +	}
>, <Line: +	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
>, <Line: +	function regexpEscape(s) {
>, <Line: +		return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
>, <Line: +	}
>, <Line: +	// date from string and array of format strings
>, <Line: +	function makeDateFromStringAndArray(config) {
>, <Line: +		var tempConfig,
>, <Line: +			bestMoment,
>, <Line: +			scoreToBeat,
>, <Line: +			i,
>, <Line: +			currentScore;
>, <Line: +		if (config._f.length === 0) {
>, <Line: +			config._pf.invalidFormat = true;
>, <Line: +			config._d = new Date(NaN);
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		for (i = 0; i < config._f.length; i++) {
>, <Line: +			currentScore = 0;
>, <Line: +			tempConfig = copyConfig({}, config);
>, <Line: +			tempConfig._pf = defaultParsingFlags();
>, <Line: +			tempConfig._f = config._f[i];
>, <Line: +			makeDateFromStringAndFormat(tempConfig);
>, <Line: +			if (!isValid(tempConfig)) {
>, <Line: +				continue;
>, <Line: +			}
>, <Line: +			// if there is any input that was not parsed add a penalty for that format
>, <Line: +			currentScore += tempConfig._pf.charsLeftOver;
>, <Line: +			//or tokens
>, <Line: +			currentScore += tempConfig._pf.unusedTokens.length * 10;
>, <Line: +			tempConfig._pf.score = currentScore;
>, <Line: +			if (scoreToBeat == null || currentScore < scoreToBeat) {
>, <Line: +				scoreToBeat = currentScore;
>, <Line: +				bestMoment = tempConfig;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		extend(config, bestMoment || tempConfig);
>, <Line: +	}
>, <Line: +	// date from iso format
>, <Line: +	function parseISO(config) {
>, <Line: +		var i, l,
>, <Line: +			string = config._i,
>, <Line: +			match = isoRegex.exec(string);
>, <Line: +		if (match) {
>, <Line: +			config._pf.iso = true;
>, <Line: +			for (i = 0, l = isoDates.length; i < l; i++) {
>, <Line: +				if (isoDates[i][1].exec(string)) {
>, <Line: +					// match[5] should be "T" or undefined
>, <Line: +					config._f = isoDates[i][0] + (match[6] || ' ');
>, <Line: +					break;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			for (i = 0, l = isoTimes.length; i < l; i++) {
>, <Line: +				if (isoTimes[i][1].exec(string)) {
>, <Line: +					config._f += isoTimes[i][0];
>, <Line: +					break;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (string.match(parseTokenTimezone)) {
>, <Line: +				config._f += 'Z';
>, <Line: +			}
>, <Line: +			makeDateFromStringAndFormat(config);
>, <Line: +		} else {
>, <Line: +			config._isValid = false;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// date from iso format or fallback
>, <Line: +	function makeDateFromString(config) {
>, <Line: +		parseISO(config);
>, <Line: +		if (config._isValid === false) {
>, <Line: +			delete config._isValid;
>, <Line: +			moment.createFromInputFallback(config);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function makeDateFromInput(config) {
>, <Line: +		var input = config._i, matched;
>, <Line: +		if (input === undefined) {
>, <Line: +			config._d = new Date();
>, <Line: +		} else if (isDate(input)) {
>, <Line: +			config._d = new Date(+input);
>, <Line: +		} else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
>, <Line: +			config._d = new Date(+matched[1]);
>, <Line: +		} else if (typeof input === 'string') {
>, <Line: +			makeDateFromString(config);
>, <Line: +		} else if (isArray(input)) {
>, <Line: +			config._a = input.slice(0);
>, <Line: +			dateFromConfig(config);
>, <Line: +		} else if (typeof(input) === 'object') {
>, <Line: +			dateFromObject(config);
>, <Line: +		} else if (typeof(input) === 'number') {
>, <Line: +			// from milliseconds
>, <Line: +			config._d = new Date(input);
>, <Line: +		} else {
>, <Line: +			moment.createFromInputFallback(config);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function makeDate(y, m, d, h, M, s, ms) {
>, <Line: +		//can't just apply() to create a date:
>, <Line: +		//http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
>, <Line: +		var date = new Date(y, m, d, h, M, s, ms);
>, <Line: +		//the date constructor doesn't accept years < 1970
>, <Line: +		if (y < 1970) {
>, <Line: +			date.setFullYear(y);
>, <Line: +		}
>, <Line: +		return date;
>, <Line: +	}
>, <Line: +	function makeUTCDate(y) {
>, <Line: +		var date = new Date(Date.UTC.apply(null, arguments));
>, <Line: +		if (y < 1970) {
>, <Line: +			date.setUTCFullYear(y);
>, <Line: +		}
>, <Line: +		return date;
>, <Line: +	}
>, <Line: +	function parseWeekday(input, locale) {
>, <Line: +		if (typeof input === 'string') {
>, <Line: +			if (!isNaN(input)) {
>, <Line: +				input = parseInt(input, 10);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				input = locale.weekdaysParse(input);
>, <Line: +				if (typeof input !== 'number') {
>, <Line: +					return null;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return input;
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Relative Time
>, <Line: +	 ************************************/
>, <Line: +	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
>, <Line: +	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
>, <Line: +		return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
>, <Line: +	}
>, <Line: +	function relativeTime(posNegDuration, withoutSuffix, locale) {
>, <Line: +		var duration = moment.duration(posNegDuration).abs(),
>, <Line: +			seconds = round(duration.as('s')),
>, <Line: +			minutes = round(duration.as('m')),
>, <Line: +			hours = round(duration.as('h')),
>, <Line: +			days = round(duration.as('d')),
>, <Line: +			months = round(duration.as('M')),
>, <Line: +			years = round(duration.as('y')),
>, <Line: +			args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
>, <Line: +				minutes === 1 && ['m'] ||
>, <Line: +				minutes < relativeTimeThresholds.m && ['mm', minutes] ||
>, <Line: +				hours === 1 && ['h'] ||
>, <Line: +				hours < relativeTimeThresholds.h && ['hh', hours] ||
>, <Line: +				days === 1 && ['d'] ||
>, <Line: +				days < relativeTimeThresholds.d && ['dd', days] ||
>, <Line: +				months === 1 && ['M'] ||
>, <Line: +				months < relativeTimeThresholds.M && ['MM', months] ||
>, <Line: +				years === 1 && ['y'] || ['yy', years];
>, <Line: +		args[2] = withoutSuffix;
>, <Line: +		args[3] = +posNegDuration > 0;
>, <Line: +		args[4] = locale;
>, <Line: +		return substituteTimeAgo.apply({}, args);
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Week of Year
>, <Line: +	 ************************************/
>, <Line: +	// firstDayOfWeek       0 = sun, 6 = sat
>, <Line: +	//                      the day of the week that starts the week
>, <Line: +	//                      (usually sunday or monday)
>, <Line: +	// firstDayOfWeekOfYear 0 = sun, 6 = sat
>, <Line: +	//                      the first week is the week that contains the first
>, <Line: +	//                      of this day of the week
>, <Line: +	//                      (eg. ISO weeks use thursday (4))
>, <Line: +	function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
>, <Line: +		var end = firstDayOfWeekOfYear - firstDayOfWeek,
>, <Line: +			daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
>, <Line: +			adjustedMoment;
>, <Line: +		if (daysToDayOfWeek > end) {
>, <Line: +			daysToDayOfWeek -= 7;
>, <Line: +		}
>, <Line: +		if (daysToDayOfWeek < end - 7) {
>, <Line: +			daysToDayOfWeek += 7;
>, <Line: +		}
>, <Line: +		adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
>, <Line: +		return {
>, <Line: +			week: Math.ceil(adjustedMoment.dayOfYear() / 7),
>, <Line: +			year: adjustedMoment.year()
>, <Line: +		};
>, <Line: +	}
>, <Line: +	//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
>, <Line: +	function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
>, <Line: +		var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
>, <Line: +		d = d === 0 ? 7 : d;
>, <Line: +		weekday = weekday != null ? weekday : firstDayOfWeek;
>, <Line: +		daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
>, <Line: +		dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
>, <Line: +		return {
>, <Line: +			year: dayOfYear > 0 ? year : year - 1,
>, <Line: +			dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/************************************
>, <Line: +	 Top Level Functions
>, <Line: +	 ************************************/
>, <Line: +	function makeMoment(config) {
>, <Line: +		var input = config._i,
>, <Line: +			format = config._f;
>, <Line: +		config._locale = config._locale || moment.localeData(config._l);
>, <Line: +		if (input === null || (format === undefined && input === '')) {
>, <Line: +			return moment.invalid({nullInput: true});
>, <Line: +		}
>, <Line: +		if (typeof input === 'string') {
>, <Line: +			config._i = input = config._locale.preparse(input);
>, <Line: +		}
>, <Line: +		if (moment.isMoment(input)) {
>, <Line: +			return new Moment(input, true);
>, <Line: +		} else if (format) {
>, <Line: +			if (isArray(format)) {
>, <Line: +				makeDateFromStringAndArray(config);
>, <Line: +			} else {
>, <Line: +				makeDateFromStringAndFormat(config);
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			makeDateFromInput(config);
>, <Line: +		}
>, <Line: +		return new Moment(config);
>, <Line: +	}
>, <Line: +	moment = function (input, format, locale, strict) {
>, <Line: +		var c;
>, <Line: +		if (typeof(locale) === "boolean") {
>, <Line: +			strict = locale;
>, <Line: +			locale = undefined;
>, <Line: +		}
>, <Line: +		// object construction must be done this way.
>, <Line: +		// https://github.com/moment/moment/issues/1423
>, <Line: +		c = {};
>, <Line: +		c._isAMomentObject = true;
>, <Line: +		c._i = input;
>, <Line: +		c._f = format;
>, <Line: +		c._l = locale;
>, <Line: +		c._strict = strict;
>, <Line: +		c._isUTC = false;
>, <Line: +		c._pf = defaultParsingFlags();
>, <Line: +		return makeMoment(c);
>, <Line: +	};
>, <Line: +	moment.suppressDeprecationWarnings = false;
>, <Line: +	moment.createFromInputFallback = deprecate(
>, <Line: +		'moment construction falls back to js Date. This is ' +
>, <Line: +		'discouraged and will be removed in upcoming major ' +
>, <Line: +		'release. Please refer to ' +
>, <Line: +		'https://github.com/moment/moment/issues/1407 for more info.',
>, <Line: +		function (config) {
>, <Line: +			config._d = new Date(config._i);
>, <Line: +		}
>, <Line: +	);
>, <Line: +	// Pick a moment m from moments so that m[fn](other) is true for all
>, <Line: +	// other. This relies on the function fn to be transitive.
>, <Line: +	//
>, <Line: +	// moments should either be an array of moment objects or an array, whose
>, <Line: +	// first element is an array of moment objects.
>, <Line: +	function pickBy(fn, moments) {
>, <Line: +		var res, i;
>, <Line: +		if (moments.length === 1 && isArray(moments[0])) {
>, <Line: +			moments = moments[0];
>, <Line: +		}
>, <Line: +		if (!moments.length) {
>, <Line: +			return moment();
>, <Line: +		}
>, <Line: +		res = moments[0];
>, <Line: +		for (i = 1; i < moments.length; ++i) {
>, <Line: +			if (moments[i][fn](res)) {
>, <Line: +				res = moments[i];
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return res;
>, <Line: +	}
>, <Line: +	moment.min = function () {
>, <Line: +		var args = [].slice.call(arguments, 0);
>, <Line: +		return pickBy('isBefore', args);
>, <Line: +	};
>, <Line: +	moment.max = function () {
>, <Line: +		var args = [].slice.call(arguments, 0);
>, <Line: +		return pickBy('isAfter', args);
>, <Line: +	};
>, <Line: +	// creating with utc
>, <Line: +	moment.utc = function (input, format, locale, strict) {
>, <Line: +		var c;
>, <Line: +		if (typeof(locale) === "boolean") {
>, <Line: +			strict = locale;
>, <Line: +			locale = undefined;
>, <Line: +		}
>, <Line: +		// object construction must be done this way.
>, <Line: +		// https://github.com/moment/moment/issues/1423
>, <Line: +		c = {};
>, <Line: +		c._isAMomentObject = true;
>, <Line: +		c._useUTC = true;
>, <Line: +		c._isUTC = true;
>, <Line: +		c._l = locale;
>, <Line: +		c._i = input;
>, <Line: +		c._f = format;
>, <Line: +		c._strict = strict;
>, <Line: +		c._pf = defaultParsingFlags();
>, <Line: +		return makeMoment(c).utc();
>, <Line: +	};
>, <Line: +	// creating with unix timestamp (in seconds)
>, <Line: +	moment.unix = function (input) {
>, <Line: +		return moment(input * 1000);
>, <Line: +	};
>, <Line: +	// duration
>, <Line: +	moment.duration = function (input, key) {
>, <Line: +		var duration = input,
>, <Line: +		// matching against regexp is expensive, do it on demand
>, <Line: +			match = null,
>, <Line: +			sign,
>, <Line: +			ret,
>, <Line: +			parseIso,
>, <Line: +			diffRes;
>, <Line: +		if (moment.isDuration(input)) {
>, <Line: +			duration = {
>, <Line: +				ms: input._milliseconds,
>, <Line: +				d: input._days,
>, <Line: +				M: input._months
>, <Line: +			};
>, <Line: +		} else if (typeof input === 'number') {
>, <Line: +			duration = {};
>, <Line: +			if (key) {
>, <Line: +				duration[key] = input;
>, <Line: +			} else {
>, <Line: +				duration.milliseconds = input;
>, <Line: +			}
>, <Line: +		} else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
>, <Line: +			sign = (match[1] === '-') ? -1 : 1;
>, <Line: +			duration = {
>, <Line: +				y: 0,
>, <Line: +				d: toInt(match[DATE]) * sign,
>, <Line: +				h: toInt(match[HOUR]) * sign,
>, <Line: +				m: toInt(match[MINUTE]) * sign,
>, <Line: +				s: toInt(match[SECOND]) * sign,
>, <Line: +				ms: toInt(match[MILLISECOND]) * sign
>, <Line: +			};
>, <Line: +		} else if (!!(match = isoDurationRegex.exec(input))) {
>, <Line: +			sign = (match[1] === '-') ? -1 : 1;
>, <Line: +			parseIso = function (inp) {
>, <Line: +				// We'd normally use ~~inp for this, but unfortunately it also
>, <Line: +				// converts floats to ints.
>, <Line: +				// inp may be undefined, so careful calling replace on it.
>, <Line: +				var res = inp && parseFloat(inp.replace(',', '.'));
>, <Line: +				// apply sign while we're at it
>, <Line: +				return (isNaN(res) ? 0 : res) * sign;
>, <Line: +			};
>, <Line: +			duration = {
>, <Line: +				y: parseIso(match[2]),
>, <Line: +				M: parseIso(match[3]),
>, <Line: +				d: parseIso(match[4]),
>, <Line: +				h: parseIso(match[5]),
>, <Line: +				m: parseIso(match[6]),
>, <Line: +				s: parseIso(match[7]),
>, <Line: +				w: parseIso(match[8])
>, <Line: +			};
>, <Line: +		} else if (typeof duration === 'object' &&
>, <Line: +			('from' in duration || 'to' in duration)) {
>, <Line: +			diffRes = momentsDifference(moment(duration.from), moment(duration.to));
>, <Line: +			duration = {};
>, <Line: +			duration.ms = diffRes.milliseconds;
>, <Line: +			duration.M = diffRes.months;
>, <Line: +		}
>, <Line: +		ret = new Duration(duration);
>, <Line: +		if (moment.isDuration(input) && input.hasOwnProperty('_locale')) {
>, <Line: +			ret._locale = input._locale;
>, <Line: +		}
>, <Line: +		return ret;
>, <Line: +	};
>, <Line: +	// version number
>, <Line: +	moment.version = VERSION;
>, <Line: +	// default format
>, <Line: +	moment.defaultFormat = isoFormat;
>, <Line: +	// constant that refers to the ISO standard
>, <Line: +	moment.ISO_8601 = function () {
>, <Line: +	};
>, <Line: +	// Plugins that add properties should also add the key here (null value),
>, <Line: +	// so we can properly clone ourselves.
>, <Line: +	moment.momentProperties = momentProperties;
>, <Line: +	// This function will be called whenever a moment is mutated.
>, <Line: +	// It is intended to keep the offset in sync with the timezone.
>, <Line: +	moment.updateOffset = function () {
>, <Line: +	};
>, <Line: +	// This function allows you to set a threshold for relative time strings
>, <Line: +	moment.relativeTimeThreshold = function (threshold, limit) {
>, <Line: +		if (relativeTimeThresholds[threshold] === undefined) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		if (limit === undefined) {
>, <Line: +			return relativeTimeThresholds[threshold];
>, <Line: +		}
>, <Line: +		relativeTimeThresholds[threshold] = limit;
>, <Line: +		return true;
>, <Line: +	};
>, <Line: +	moment.lang = deprecate(
>, <Line: +		"moment.lang is deprecated. Use moment.locale instead.",
>, <Line: +		function (key, value) {
>, <Line: +			return moment.locale(key, value);
>, <Line: +		}
>, <Line: +	);
>, <Line: +	// This function will load locale and then set the global locale.  If
>, <Line: +	// no arguments are passed in, it will simply return the current global
>, <Line: +	// locale key.
>, <Line: +	moment.locale = function (key, values) {
>, <Line: +		var data;
>, <Line: +		if (key) {
>, <Line: +			if (typeof(values) !== "undefined") {
>, <Line: +				data = moment.defineLocale(key, values);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				data = moment.localeData(key);
>, <Line: +			}
>, <Line: +			if (data) {
>, <Line: +				moment.duration._locale = moment._locale = data;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return moment._locale._abbr;
>, <Line: +	};
>, <Line: +	moment.defineLocale = function (name, values) {
>, <Line: +		if (values !== null) {
>, <Line: +			values.abbr = name;
>, <Line: +			if (!locales[name]) {
>, <Line: +				locales[name] = new Locale();
>, <Line: +			}
>, <Line: +			locales[name].set(values);
>, <Line: +			// backwards compat for now: also set the locale
>, <Line: +			moment.locale(name);
>, <Line: +			return locales[name];
>, <Line: +		} else {
>, <Line: +			// useful for testing
>, <Line: +			delete locales[name];
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	moment.langData = deprecate(
>, <Line: +		"moment.langData is deprecated. Use moment.localeData instead.",
>, <Line: +		function (key) {
>, <Line: +			return moment.localeData(key);
>, <Line: +		}
>, <Line: +	);
>, <Line: +	// returns locale data
>, <Line: +	moment.localeData = function (key) {
>, <Line: +		var locale;
>, <Line: +		if (key && key._locale && key._locale._abbr) {
>, <Line: +			key = key._locale._abbr;
>, <Line: +		}
>, <Line: +		if (!key) {
>, <Line: +			return moment._locale;
>, <Line: +		}
>, <Line: +		if (!isArray(key)) {
>, <Line: +			//short-circuit everything else
>, <Line: +			locale = loadLocale(key);
>, <Line: +			if (locale) {
>, <Line: +				return locale;
>, <Line: +			}
>, <Line: +			key = [key];
>, <Line: +		}
>, <Line: +		return chooseLocale(key);
>, <Line: +	};
>, <Line: +	// compare moment object
>, <Line: +	moment.isMoment = function (obj) {
>, <Line: +		return obj instanceof Moment ||
>, <Line: +			(obj != null && obj.hasOwnProperty('_isAMomentObject'));
>, <Line: +	};
>, <Line: +	// for typechecking Duration objects
>, <Line: +	moment.isDuration = function (obj) {
>, <Line: +		return obj instanceof Duration;
>, <Line: +	};
>, <Line: +	for (i = lists.length - 1; i >= 0; --i) {
>, <Line: +		makeList(lists[i]);
>, <Line: +	}
>, <Line: +	moment.normalizeUnits = function (units) {
>, <Line: +		return normalizeUnits(units);
>, <Line: +	};
>, <Line: +	moment.invalid = function (flags) {
>, <Line: +		var m = moment.utc(NaN);
>, <Line: +		if (flags != null) {
>, <Line: +			extend(m._pf, flags);
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			m._pf.userInvalidated = true;
>, <Line: +		}
>, <Line: +		return m;
>, <Line: +	};
>, <Line: +	moment.parseZone = function () {
>, <Line: +		return moment.apply(null, arguments).parseZone();
>, <Line: +	};
>, <Line: +	moment.parseTwoDigitYear = function (input) {
>, <Line: +		return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
>, <Line: +	};
>, <Line: +	/************************************
>, <Line: +	 Moment Prototype
>, <Line: +	 ************************************/
>, <Line: +	extend(moment.fn = Moment.prototype, {
>, <Line: +		clone: function () {
>, <Line: +			return moment(this);
>, <Line: +		},
>, <Line: +		valueOf: function () {
>, <Line: +			return +this._d + ((this._offset || 0) * 60000);
>, <Line: +		},
>, <Line: +		unix: function () {
>, <Line: +			return Math.floor(+this / 1000);
>, <Line: +		},
>, <Line: +		toString: function () {
>, <Line: +			return this.clone().locale('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
>, <Line: +		},
>, <Line: +		toDate: function () {
>, <Line: +			return this._offset ? new Date(+this) : this._d;
>, <Line: +		},
>, <Line: +		toISOString: function () {
>, <Line: +			var m = moment(this).utc();
>, <Line: +			if (0 < m.year() && m.year() <= 9999) {
>, <Line: +				return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
>, <Line: +			} else {
>, <Line: +				return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
>, <Line: +			}
>, <Line: +		},
>, <Line: +		toArray: function () {
>, <Line: +			var m = this;
>, <Line: +			return [
>, <Line: +				m.year(),
>, <Line: +				m.month(),
>, <Line: +				m.date(),
>, <Line: +				m.hours(),
>, <Line: +				m.minutes(),
>, <Line: +				m.seconds(),
>, <Line: +				m.milliseconds()
>, <Line: +			];
>, <Line: +		},
>, <Line: +		isValid: function () {
>, <Line: +			return isValid(this);
>, <Line: +		},
>, <Line: +		isDSTShifted: function () {
>, <Line: +			if (this._a) {
>, <Line: +				return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		},
>, <Line: +		parsingFlags: function () {
>, <Line: +			return extend({}, this._pf);
>, <Line: +		},
>, <Line: +		invalidAt: function () {
>, <Line: +			return this._pf.overflow;
>, <Line: +		},
>, <Line: +		utc: function (keepLocalTime) {
>, <Line: +			return this.zone(0, keepLocalTime);
>, <Line: +		},
>, <Line: +		local: function (keepLocalTime) {
>, <Line: +			if (this._isUTC) {
>, <Line: +				this.zone(0, keepLocalTime);
>, <Line: +				this._isUTC = false;
>, <Line: +				if (keepLocalTime) {
>, <Line: +					this.add(this._d.getTimezoneOffset(), 'm');
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		format: function (inputString) {
>, <Line: +			var output = formatMoment(this, inputString || moment.defaultFormat);
>, <Line: +			return this.localeData().postformat(output);
>, <Line: +		},
>, <Line: +		add: createAdder(1, 'add'),
>, <Line: +		subtract: createAdder(-1, 'subtract'),
>, <Line: +		diff: function (input, units, asFloat) {
>, <Line: +			var that = makeAs(input, this),
>, <Line: +				zoneDiff = (this.zone() - that.zone()) * 6e4,
>, <Line: +				diff, output;
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			if (units === 'year' || units === 'month') {
>, <Line: +				// average number of days in the months in the given dates
>, <Line: +				diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
>, <Line: +				// difference in months
>, <Line: +				output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
>, <Line: +				// adjust by taking difference in days, average number of days
>, <Line: +				// and dst in the given months.
>, <Line: +				output += ((this - moment(this).startOf('month')) -
>, <Line: +					(that - moment(that).startOf('month'))) / diff;
>, <Line: +				// same as above but with zones, to negate all dst
>, <Line: +				output -= ((this.zone() - moment(this).startOf('month').zone()) -
>, <Line: +					(that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
>, <Line: +				if (units === 'year') {
>, <Line: +					output = output / 12;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				diff = (this - that);
>, <Line: +				output = units === 'second' ? diff / 1e3 : // 1000
>, <Line: +					units === 'minute' ? diff / 6e4 : // 1000 * 60
>, <Line: +						units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
>, <Line: +							units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
>, <Line: +								units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
>, <Line: +									diff;
>, <Line: +			}
>, <Line: +			return asFloat ? output : absRound(output);
>, <Line: +		},
>, <Line: +		from: function (time, withoutSuffix) {
>, <Line: +			return moment.duration({
>, <Line: +				to: this,
>, <Line: +				from: time
>, <Line: +			}).locale(this.locale()).humanize(!withoutSuffix);
>, <Line: +		},
>, <Line: +		fromNow: function (withoutSuffix) {
>, <Line: +			return this.from(moment(), withoutSuffix);
>, <Line: +		},
>, <Line: +		calendar: function (time) {
>, <Line: +			// We want to compare the start of today, vs this.
>, <Line: +			// Getting start-of-today depends on whether we're zone'd or not.
>, <Line: +			var now = time || moment(),
>, <Line: +				sod = makeAs(now, this).startOf('day'),
>, <Line: +				diff = this.diff(sod, 'days', true),
>, <Line: +				format = diff < -6 ? 'sameElse' :
>, <Line: +					diff < -1 ? 'lastWeek' :
>, <Line: +						diff < 0 ? 'lastDay' :
>, <Line: +							diff < 1 ? 'sameDay' :
>, <Line: +								diff < 2 ? 'nextDay' :
>, <Line: +									diff < 7 ? 'nextWeek' : 'sameElse';
>, <Line: +			return this.format(this.localeData().calendar(format, this));
>, <Line: +		},
>, <Line: +		isLeapYear: function () {
>, <Line: +			return isLeapYear(this.year());
>, <Line: +		},
>, <Line: +		isDST: function () {
>, <Line: +			return (this.zone() < this.clone().month(0).zone() ||
>, <Line: +			this.zone() < this.clone().month(5).zone());
>, <Line: +		},
>, <Line: +		day: function (input) {
>, <Line: +			var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
>, <Line: +			if (input != null) {
>, <Line: +				input = parseWeekday(input, this.localeData());
>, <Line: +				return this.add(input - day, 'd');
>, <Line: +			} else {
>, <Line: +				return day;
>, <Line: +			}
>, <Line: +		},
>, <Line: +		month: makeAccessor('Month', true),
>, <Line: +		startOf: function (units) {
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			// the following switch intentionally omits break keywords
>, <Line: +			// to utilize falling through the cases.
>, <Line: +			switch (units) {
>, <Line: +				case 'year':
>, <Line: +					this.month(0);
>, <Line: +				/* falls through */
>, <Line: +				case 'quarter':
>, <Line: +				case 'month':
>, <Line: +					this.date(1);
>, <Line: +				/* falls through */
>, <Line: +				case 'week':
>, <Line: +				case 'isoWeek':
>, <Line: +				case 'day':
>, <Line: +					this.hours(0);
>, <Line: +				/* falls through */
>, <Line: +				case 'hour':
>, <Line: +					this.minutes(0);
>, <Line: +				/* falls through */
>, <Line: +				case 'minute':
>, <Line: +					this.seconds(0);
>, <Line: +				/* falls through */
>, <Line: +				case 'second':
>, <Line: +					this.milliseconds(0);
>, <Line: +				/* falls through */
>, <Line: +			}
>, <Line: +			// weeks are a special case
>, <Line: +			if (units === 'week') {
>, <Line: +				this.weekday(0);
>, <Line: +			} else if (units === 'isoWeek') {
>, <Line: +				this.isoWeekday(1);
>, <Line: +			}
>, <Line: +			// quarters are also special
>, <Line: +			if (units === 'quarter') {
>, <Line: +				this.month(Math.floor(this.month() / 3) * 3);
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		endOf: function (units) {
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
>, <Line: +		},
>, <Line: +		isAfter: function (input, units) {
>, <Line: +			units = typeof units !== 'undefined' ? units : 'millisecond';
>, <Line: +			return +this.clone().startOf(units) > +moment(input).startOf(units);
>, <Line: +		},
>, <Line: +		isBefore: function (input, units) {
>, <Line: +			units = typeof units !== 'undefined' ? units : 'millisecond';
>, <Line: +			return +this.clone().startOf(units) < +moment(input).startOf(units);
>, <Line: +		},
>, <Line: +		isSame: function (input, units) {
>, <Line: +			units = units || 'ms';
>, <Line: +			return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
>, <Line: +		},
>, <Line: +		min: deprecate(
>, <Line: +			'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
>, <Line: +			function (other) {
>, <Line: +				other = moment.apply(null, arguments);
>, <Line: +				return other < this ? this : other;
>, <Line: +			}
>, <Line: +		),
>, <Line: +		max: deprecate(
>, <Line: +			'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
>, <Line: +			function (other) {
>, <Line: +				other = moment.apply(null, arguments);
>, <Line: +				return other > this ? this : other;
>, <Line: +			}
>, <Line: +		),
>, <Line: +		// keepLocalTime = true means only change the timezone, without
>, <Line: +		// affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
>, <Line: +		// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
>, <Line: +		// +0200, so we adjust the time as needed, to be valid.
>, <Line: +		//
>, <Line: +		// Keeping the time actually adds/subtracts (one hour)
>, <Line: +		// from the actual represented time. That is why we call updateOffset
>, <Line: +		// a second time. In case it wants us to change the offset again
>, <Line: +		// _changeInProgress == true case, then we have to adjust, because
>, <Line: +		// there is no such time in the given timezone.
>, <Line: +		zone: function (input, keepLocalTime) {
>, <Line: +			var offset = this._offset || 0,
>, <Line: +				localAdjust;
>, <Line: +			if (input != null) {
>, <Line: +				if (typeof input === 'string') {
>, <Line: +					input = timezoneMinutesFromString(input);
>, <Line: +				}
>, <Line: +				if (Math.abs(input) < 16) {
>, <Line: +					input = input * 60;
>, <Line: +				}
>, <Line: +				if (!this._isUTC && keepLocalTime) {
>, <Line: +					localAdjust = this._d.getTimezoneOffset();
>, <Line: +				}
>, <Line: +				this._offset = input;
>, <Line: +				this._isUTC = true;
>, <Line: +				if (localAdjust != null) {
>, <Line: +					this.subtract(localAdjust, 'm');
>, <Line: +				}
>, <Line: +				if (offset !== input) {
>, <Line: +					if (!keepLocalTime || this._changeInProgress) {
>, <Line: +						addOrSubtractDurationFromMoment(this,
>, <Line: +							moment.duration(offset - input, 'm'), 1, false);
>, <Line: +					} else if (!this._changeInProgress) {
>, <Line: +						this._changeInProgress = true;
>, <Line: +						moment.updateOffset(this, true);
>, <Line: +						this._changeInProgress = null;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				return this._isUTC ? offset : this._d.getTimezoneOffset();
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		zoneAbbr: function () {
>, <Line: +			return this._isUTC ? 'UTC' : '';
>, <Line: +		},
>, <Line: +		zoneName: function () {
>, <Line: +			return this._isUTC ? 'Coordinated Universal Time' : '';
>, <Line: +		},
>, <Line: +		parseZone: function () {
>, <Line: +			if (this._tzm) {
>, <Line: +				this.zone(this._tzm);
>, <Line: +			} else if (typeof this._i === 'string') {
>, <Line: +				this.zone(this._i);
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		hasAlignedHourOffset: function (input) {
>, <Line: +			if (!input) {
>, <Line: +				input = 0;
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				input = moment(input).zone();
>, <Line: +			}
>, <Line: +			return (this.zone() - input) % 60 === 0;
>, <Line: +		},
>, <Line: +		daysInMonth: function () {
>, <Line: +			return daysInMonth(this.year(), this.month());
>, <Line: +		},
>, <Line: +		dayOfYear: function (input) {
>, <Line: +			var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
>, <Line: +			return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
>, <Line: +		},
>, <Line: +		quarter: function (input) {
>, <Line: +			return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
>, <Line: +		},
>, <Line: +		weekYear: function (input) {
>, <Line: +			var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
>, <Line: +			return input == null ? year : this.add((input - year), 'y');
>, <Line: +		},
>, <Line: +		isoWeekYear: function (input) {
>, <Line: +			var year = weekOfYear(this, 1, 4).year;
>, <Line: +			return input == null ? year : this.add((input - year), 'y');
>, <Line: +		},
>, <Line: +		week: function (input) {
>, <Line: +			var week = this.localeData().week(this);
>, <Line: +			return input == null ? week : this.add((input - week) * 7, 'd');
>, <Line: +		},
>, <Line: +		isoWeek: function (input) {
>, <Line: +			var week = weekOfYear(this, 1, 4).week;
>, <Line: +			return input == null ? week : this.add((input - week) * 7, 'd');
>, <Line: +		},
>, <Line: +		weekday: function (input) {
>, <Line: +			var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
>, <Line: +			return input == null ? weekday : this.add(input - weekday, 'd');
>, <Line: +		},
>, <Line: +		isoWeekday: function (input) {
>, <Line: +			// behaves the same as moment#day except
>, <Line: +			// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
>, <Line: +			// as a setter, sunday should belong to the previous week.
>, <Line: +			return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
>, <Line: +		},
>, <Line: +		isoWeeksInYear: function () {
>, <Line: +			return weeksInYear(this.year(), 1, 4);
>, <Line: +		},
>, <Line: +		weeksInYear: function () {
>, <Line: +			var weekInfo = this.localeData()._week;
>, <Line: +			return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
>, <Line: +		},
>, <Line: +		get: function (units) {
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			return this[units]();
>, <Line: +		},
>, <Line: +		set: function (units, value) {
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			if (typeof this[units] === 'function') {
>, <Line: +				this[units](value);
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		// If passed a locale key, it will set the locale for this
>, <Line: +		// instance.  Otherwise, it will return the locale configuration
>, <Line: +		// variables for this instance.
>, <Line: +		locale: function (key) {
>, <Line: +			if (key === undefined) {
>, <Line: +				return this._locale._abbr;
>, <Line: +			} else {
>, <Line: +				this._locale = moment.localeData(key);
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +		},
>, <Line: +		lang: deprecate(
>, <Line: +			"moment().lang() is deprecated. Use moment().localeData() instead.",
>, <Line: +			function (key) {
>, <Line: +				if (key === undefined) {
>, <Line: +					return this.localeData();
>, <Line: +				} else {
>, <Line: +					this._locale = moment.localeData(key);
>, <Line: +					return this;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		),
>, <Line: +		localeData: function () {
>, <Line: +			return this._locale;
>, <Line: +		}
>, <Line: +	});
>, <Line: +	function rawMonthSetter(mom, value) {
>, <Line: +		var dayOfMonth;
>, <Line: +		// TODO: Move this out of here!
>, <Line: +		if (typeof value === 'string') {
>, <Line: +			value = mom.localeData().monthsParse(value);
>, <Line: +			// TODO: Another silent failure?
>, <Line: +			if (typeof value !== 'number') {
>, <Line: +				return mom;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		dayOfMonth = Math.min(mom.date(),
>, <Line: +			daysInMonth(mom.year(), value));
>, <Line: +		mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
>, <Line: +		return mom;
>, <Line: +	}
>, <Line: +	function rawGetter(mom, unit) {
>, <Line: +		return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
>, <Line: +	}
>, <Line: +	function rawSetter(mom, unit, value) {
>, <Line: +		if (unit === 'Month') {
>, <Line: +			return rawMonthSetter(mom, value);
>, <Line: +		} else {
>, <Line: +			return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function makeAccessor(unit, keepTime) {
>, <Line: +		return function (value) {
>, <Line: +			if (value != null) {
>, <Line: +				rawSetter(this, unit, value);
>, <Line: +				moment.updateOffset(this, keepTime);
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return rawGetter(this, unit);
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>, <Line: +	moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
>, <Line: +	moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
>, <Line: +	moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
>, <Line: +	// Setting the hour should keep the time, because the user explicitly
>, <Line: +	// specified which hour he wants. So trying to maintain the same hour (in
>, <Line: +	// a new timezone) makes sense. Adding/subtracting hours does not follow
>, <Line: +	// this rule.
>, <Line: +	moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
>, <Line: +	// moment.fn.month is defined separately
>, <Line: +	moment.fn.date = makeAccessor('Date', true);
>, <Line: +	moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
>, <Line: +	moment.fn.year = makeAccessor('FullYear', true);
>, <Line: +	moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));
>, <Line: +	// add plural methods
>, <Line: +	moment.fn.days = moment.fn.day;
>, <Line: +	moment.fn.months = moment.fn.month;
>, <Line: +	moment.fn.weeks = moment.fn.week;
>, <Line: +	moment.fn.isoWeeks = moment.fn.isoWeek;
>, <Line: +	moment.fn.quarters = moment.fn.quarter;
>, <Line: +	// add aliased format methods
>, <Line: +	moment.fn.toJSON = moment.fn.toISOString;
>, <Line: +	/************************************
>, <Line: +	 Duration Prototype
>, <Line: +	 ************************************/
>, <Line: +	function daysToYears(days) {
>, <Line: +		// 400 years have 146097 days (taking into account leap year rules)
>, <Line: +		return days * 400 / 146097;
>, <Line: +	}
>, <Line: +	function yearsToDays(years) {
>, <Line: +		// years * 365 + absRound(years / 4) -
>, <Line: +		//     absRound(years / 100) + absRound(years / 400);
>, <Line: +		return years * 146097 / 400;
>, <Line: +	}
>, <Line: +	extend(moment.duration.fn = Duration.prototype, {
>, <Line: +		_bubble: function () {
>, <Line: +			var milliseconds = this._milliseconds,
>, <Line: +				days = this._days,
>, <Line: +				months = this._months,
>, <Line: +				data = this._data,
>, <Line: +				seconds, minutes, hours, years = 0;
>, <Line: +			// The following code bubbles up values, see the tests for
>, <Line: +			// examples of what that means.
>, <Line: +			data.milliseconds = milliseconds % 1000;
>, <Line: +			seconds = absRound(milliseconds / 1000);
>, <Line: +			data.seconds = seconds % 60;
>, <Line: +			minutes = absRound(seconds / 60);
>, <Line: +			data.minutes = minutes % 60;
>, <Line: +			hours = absRound(minutes / 60);
>, <Line: +			data.hours = hours % 24;
>, <Line: +			days += absRound(hours / 24);
>, <Line: +			// Accurately convert days to years, assume start from year 0.
>, <Line: +			years = absRound(daysToYears(days));
>, <Line: +			days -= absRound(yearsToDays(years));
>, <Line: +			// 30 days to a month
>, <Line: +			// TODO (iskren): Use anchor date (like 1st Jan) to compute this.
>, <Line: +			months += absRound(days / 30);
>, <Line: +			days %= 30;
>, <Line: +			// 12 months -> 1 year
>, <Line: +			years += absRound(months / 12);
>, <Line: +			months %= 12;
>, <Line: +			data.days = days;
>, <Line: +			data.months = months;
>, <Line: +			data.years = years;
>, <Line: +		},
>, <Line: +		abs: function () {
>, <Line: +			this._milliseconds = Math.abs(this._milliseconds);
>, <Line: +			this._days = Math.abs(this._days);
>, <Line: +			this._months = Math.abs(this._months);
>, <Line: +			this._data.milliseconds = Math.abs(this._data.milliseconds);
>, <Line: +			this._data.seconds = Math.abs(this._data.seconds);
>, <Line: +			this._data.minutes = Math.abs(this._data.minutes);
>, <Line: +			this._data.hours = Math.abs(this._data.hours);
>, <Line: +			this._data.months = Math.abs(this._data.months);
>, <Line: +			this._data.years = Math.abs(this._data.years);
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		weeks: function () {
>, <Line: +			return absRound(this.days() / 7);
>, <Line: +		},
>, <Line: +		valueOf: function () {
>, <Line: +			return this._milliseconds +
>, <Line: +				this._days * 864e5 +
>, <Line: +				(this._months % 12) * 2592e6 +
>, <Line: +				toInt(this._months / 12) * 31536e6;
>, <Line: +		},
>, <Line: +		humanize: function (withSuffix) {
>, <Line: +			var output = relativeTime(this, !withSuffix, this.localeData());
>, <Line: +			if (withSuffix) {
>, <Line: +				output = this.localeData().pastFuture(+this, output);
>, <Line: +			}
>, <Line: +			return this.localeData().postformat(output);
>, <Line: +		},
>, <Line: +		add: function (input, val) {
>, <Line: +			// supports only 2.0-style add(1, 's') or add(moment)
>, <Line: +			var dur = moment.duration(input, val);
>, <Line: +			this._milliseconds += dur._milliseconds;
>, <Line: +			this._days += dur._days;
>, <Line: +			this._months += dur._months;
>, <Line: +			this._bubble();
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		subtract: function (input, val) {
>, <Line: +			var dur = moment.duration(input, val);
>, <Line: +			this._milliseconds -= dur._milliseconds;
>, <Line: +			this._days -= dur._days;
>, <Line: +			this._months -= dur._months;
>, <Line: +			this._bubble();
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		get: function (units) {
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			return this[units.toLowerCase() + 's']();
>, <Line: +		},
>, <Line: +		as: function (units) {
>, <Line: +			var days, months;
>, <Line: +			units = normalizeUnits(units);
>, <Line: +			days = this._days + this._milliseconds / 864e5;
>, <Line: +			if (units === 'month' || units === 'year') {
>, <Line: +				months = this._months + daysToYears(days) * 12;
>, <Line: +				return units === 'month' ? months : months / 12;
>, <Line: +			} else {
>, <Line: +				days += yearsToDays(this._months / 12);
>, <Line: +				switch (units) {
>, <Line: +					case 'week':
>, <Line: +						return days / 7;
>, <Line: +					case 'day':
>, <Line: +						return days;
>, <Line: +					case 'hour':
>, <Line: +						return days * 24;
>, <Line: +					case 'minute':
>, <Line: +						return days * 24 * 60;
>, <Line: +					case 'second':
>, <Line: +						return days * 24 * 60 * 60;
>, <Line: +					case 'millisecond':
>, <Line: +						return days * 24 * 60 * 60 * 1000;
>, <Line: +					default:
>, <Line: +						throw new Error('Unknown unit ' + units);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		lang: moment.fn.lang,
>, <Line: +		locale: moment.fn.locale,
>, <Line: +		toIsoString: deprecate(
>, <Line: +			"toIsoString() is deprecated. Please use toISOString() instead " +
>, <Line: +			"(notice the capitals)",
>, <Line: +			function () {
>, <Line: +				return this.toISOString();
>, <Line: +			}
>, <Line: +		),
>, <Line: +		toISOString: function () {
>, <Line: +			// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
>, <Line: +			var years = Math.abs(this.years()),
>, <Line: +				months = Math.abs(this.months()),
>, <Line: +				days = Math.abs(this.days()),
>, <Line: +				hours = Math.abs(this.hours()),
>, <Line: +				minutes = Math.abs(this.minutes()),
>, <Line: +				seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
>, <Line: +			if (!this.asSeconds()) {
>, <Line: +				// this is the same as C#'s (Noda) and python (isodate)...
>, <Line: +				// but not other JS (goog.date)
>, <Line: +				return 'P0D';
>, <Line: +			}
>, <Line: +			return (this.asSeconds() < 0 ? '-' : '') +
>, <Line: +				'P' +
>, <Line: +				(years ? years + 'Y' : '') +
>, <Line: +				(months ? months + 'M' : '') +
>, <Line: +				(days ? days + 'D' : '') +
>, <Line: +				((hours || minutes || seconds) ? 'T' : '') +
>, <Line: +				(hours ? hours + 'H' : '') +
>, <Line: +				(minutes ? minutes + 'M' : '') +
>, <Line: +				(seconds ? seconds + 'S' : '');
>, <Line: +		},
>, <Line: +		localeData: function () {
>, <Line: +			return this._locale;
>, <Line: +		}
>, <Line: +	});
>, <Line: +	function makeDurationGetter(name) {
>, <Line: +		moment.duration.fn[name] = function () {
>, <Line: +			return this._data[name];
>, <Line: +		};
>, <Line: +	}
>, <Line: +	for (i in unitMillisecondFactors) {
>, <Line: +		if (unitMillisecondFactors.hasOwnProperty(i)) {
>, <Line: +			makeDurationGetter(i.toLowerCase());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	moment.duration.fn.asMilliseconds = function () {
>, <Line: +		return this.as('ms');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asSeconds = function () {
>, <Line: +		return this.as('s');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asMinutes = function () {
>, <Line: +		return this.as('m');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asHours = function () {
>, <Line: +		return this.as('h');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asDays = function () {
>, <Line: +		return this.as('d');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asWeeks = function () {
>, <Line: +		return this.as('weeks');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asMonths = function () {
>, <Line: +		return this.as('M');
>, <Line: +	};
>, <Line: +	moment.duration.fn.asYears = function () {
>, <Line: +		return this.as('y');
>, <Line: +	};
>, <Line: +	/************************************
>, <Line: +	 Default Locale
>, <Line: +	 ************************************/
>, <Line: +		// Set default locale, other locale will inherit from English.
>, <Line: +	moment.locale('en', {
>, <Line: +		ordinal: function (number) {
>, <Line: +			var b = number % 10,
>, <Line: +				output = (toInt(number % 100 / 10) === 1) ? 'th' :
>, <Line: +					(b === 1) ? 'st' :
>, <Line: +						(b === 2) ? 'nd' :
>, <Line: +							(b === 3) ? 'rd' : 'th';
>, <Line: +			return number + output;
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/* EMBED_LOCALES */
>, <Line: +	/************************************
>, <Line: +	 Exposing Moment
>, <Line: +	 ************************************/
>, <Line: +	function makeGlobal(shouldDeprecate) {
>, <Line: +		/*global ender:false */
>, <Line: +		if (typeof ender !== 'undefined') {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		oldGlobalMoment = globalScope.moment;
>, <Line: +		if (shouldDeprecate) {
>, <Line: +			globalScope.moment = deprecate(
>, <Line: +				'Accessing Moment through the global scope is ' +
>, <Line: +				'deprecated, and will be removed in an upcoming ' +
>, <Line: +				'release.',
>, <Line: +				moment);
>, <Line: +		} else {
>, <Line: +			globalScope.moment = moment;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// CommonJS module is defined
>, <Line: +	if (hasModule) {
>, <Line: +		module.exports = moment;
>, <Line: +	} else if (typeof define === 'function' && define.amd) {
>, <Line: +		define('moment', function (require, exports, module) {
>, <Line: +			if (module.config && module.config() && module.config().noGlobal === true) {
>, <Line: +				// release the global variable
>, <Line: +				globalScope.moment = oldGlobalMoment;
>, <Line: +			}
>, <Line: +			return moment;
>, <Line: +		});
>, <Line: +		makeGlobal(true);
>, <Line: +	} else {
>, <Line: +		makeGlobal();
>, <Line: +	}
>]
[<Line: -    /************************************
>, <Line: -        Constants
>, <Line: -    ************************************/
>, <Line: -    var moment,
>, <Line: -        VERSION = '2.8.1',
>, <Line: -        // the global-scope this is NOT the global object in Node.js
>, <Line: -        globalScope = typeof global !== 'undefined' ? global : this,
>, <Line: -        oldGlobalMoment,
>, <Line: -        round = Math.round,
>, <Line: -        i,
>, <Line: -        YEAR = 0,
>, <Line: -        MONTH = 1,
>, <Line: -        DATE = 2,
>, <Line: -        HOUR = 3,
>, <Line: -        MINUTE = 4,
>, <Line: -        SECOND = 5,
>, <Line: -        MILLISECOND = 6,
>, <Line: -        // internal storage for locale config files
>, <Line: -        locales = {},
>, <Line: -        // extra moment internal properties (plugins register props here)
>, <Line: -        momentProperties = [],
>, <Line: -        // check for nodeJS
>, <Line: -        hasModule = (typeof module !== 'undefined' && module.exports),
>, <Line: -        // ASP.NET json date format regex
>, <Line: -        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
>, <Line: -        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
>, <Line: -        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
>, <Line: -        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
>, <Line: -        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
>, <Line: -        // format tokens
>, <Line: -        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
>, <Line: -        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
>, <Line: -        // parsing token regexes
>, <Line: -        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
>, <Line: -        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
>, <Line: -        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
>, <Line: -        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
>, <Line: -        parseTokenDigits = /\d+/, // nonzero number of digits
>, <Line: -        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
>, <Line: -        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
>, <Line: -        parseTokenT = /T/i, // T (ISO separator)
>, <Line: -        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
>, <Line: -        parseTokenOrdinal = /\d{1,2}/,
>, <Line: -        //strict parsing regexes
>, <Line: -        parseTokenOneDigit = /\d/, // 0 - 9
>, <Line: -        parseTokenTwoDigits = /\d\d/, // 00 - 99
>, <Line: -        parseTokenThreeDigits = /\d{3}/, // 000 - 999
>, <Line: -        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
>, <Line: -        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
>, <Line: -        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf
>, <Line: -        // iso 8601 regex
>, <Line: -        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
>, <Line: -        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
>, <Line: -        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
>, <Line: -        isoDates = [
>, <Line: -            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
>, <Line: -            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
>, <Line: -            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
>, <Line: -            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
>, <Line: -            ['YYYY-DDD', /\d{4}-\d{3}/]
>, <Line: -        ],
>, <Line: -        // iso time formats and regexes
>, <Line: -        isoTimes = [
>, <Line: -            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
>, <Line: -            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
>, <Line: -            ['HH:mm', /(T| )\d\d:\d\d/],
>, <Line: -            ['HH', /(T| )\d\d/]
>, <Line: -        ],
>, <Line: -        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
>, <Line: -        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
>, <Line: -        // getter and setter names
>, <Line: -        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
>, <Line: -        unitMillisecondFactors = {
>, <Line: -            'Milliseconds' : 1,
>, <Line: -            'Seconds' : 1e3,
>, <Line: -            'Minutes' : 6e4,
>, <Line: -            'Hours' : 36e5,
>, <Line: -            'Days' : 864e5,
>, <Line: -            'Months' : 2592e6,
>, <Line: -            'Years' : 31536e6
>, <Line: -        },
>, <Line: -        unitAliases = {
>, <Line: -            ms : 'millisecond',
>, <Line: -            s : 'second',
>, <Line: -            m : 'minute',
>, <Line: -            h : 'hour',
>, <Line: -            d : 'day',
>, <Line: -            D : 'date',
>, <Line: -            w : 'week',
>, <Line: -            W : 'isoWeek',
>, <Line: -            M : 'month',
>, <Line: -            Q : 'quarter',
>, <Line: -            y : 'year',
>, <Line: -            DDD : 'dayOfYear',
>, <Line: -            e : 'weekday',
>, <Line: -            E : 'isoWeekday',
>, <Line: -            gg: 'weekYear',
>, <Line: -            GG: 'isoWeekYear'
>, <Line: -        },
>, <Line: -        camelFunctions = {
>, <Line: -            dayofyear : 'dayOfYear',
>, <Line: -            isoweekday : 'isoWeekday',
>, <Line: -            isoweek : 'isoWeek',
>, <Line: -            weekyear : 'weekYear',
>, <Line: -            isoweekyear : 'isoWeekYear'
>, <Line: -        },
>, <Line: -        // format function strings
>, <Line: -        formatFunctions = {},
>, <Line: -        // default relative time thresholds
>, <Line: -        relativeTimeThresholds = {
>, <Line: -            s: 45,  // seconds to minute
>, <Line: -            m: 45,  // minutes to hour
>, <Line: -            h: 22,  // hours to day
>, <Line: -            d: 26,  // days to month
>, <Line: -            M: 11   // months to year
>, <Line: -        },
>, <Line: -        // tokens to ordinalize and pad
>, <Line: -        ordinalizeTokens = 'DDD w W M D d'.split(' '),
>, <Line: -        paddedTokens = 'M D H h m s w W'.split(' '),
>, <Line: -        formatTokenFunctions = {
>, <Line: -            M    : function () {
>, <Line: -                return this.month() + 1;
>, <Line: -            },
>, <Line: -            MMM  : function (format) {
>, <Line: -                return this.localeData().monthsShort(this, format);
>, <Line: -            },
>, <Line: -            MMMM : function (format) {
>, <Line: -                return this.localeData().months(this, format);
>, <Line: -            },
>, <Line: -            D    : function () {
>, <Line: -                return this.date();
>, <Line: -            },
>, <Line: -            DDD  : function () {
>, <Line: -                return this.dayOfYear();
>, <Line: -            },
>, <Line: -            d    : function () {
>, <Line: -                return this.day();
>, <Line: -            },
>, <Line: -            dd   : function (format) {
>, <Line: -                return this.localeData().weekdaysMin(this, format);
>, <Line: -            },
>, <Line: -            ddd  : function (format) {
>, <Line: -                return this.localeData().weekdaysShort(this, format);
>, <Line: -            },
>, <Line: -            dddd : function (format) {
>, <Line: -                return this.localeData().weekdays(this, format);
>, <Line: -            },
>, <Line: -            w    : function () {
>, <Line: -                return this.week();
>, <Line: -            },
>, <Line: -            W    : function () {
>, <Line: -                return this.isoWeek();
>, <Line: -            },
>, <Line: -            YY   : function () {
>, <Line: -                return leftZeroFill(this.year() % 100, 2);
>, <Line: -            },
>, <Line: -            YYYY : function () {
>, <Line: -                return leftZeroFill(this.year(), 4);
>, <Line: -            },
>, <Line: -            YYYYY : function () {
>, <Line: -                return leftZeroFill(this.year(), 5);
>, <Line: -            },
>, <Line: -            YYYYYY : function () {
>, <Line: -                var y = this.year(), sign = y >= 0 ? '+' : '-';
>, <Line: -                return sign + leftZeroFill(Math.abs(y), 6);
>, <Line: -            },
>, <Line: -            gg   : function () {
>, <Line: -                return leftZeroFill(this.weekYear() % 100, 2);
>, <Line: -            },
>, <Line: -            gggg : function () {
>, <Line: -                return leftZeroFill(this.weekYear(), 4);
>, <Line: -            },
>, <Line: -            ggggg : function () {
>, <Line: -                return leftZeroFill(this.weekYear(), 5);
>, <Line: -            },
>, <Line: -            GG   : function () {
>, <Line: -                return leftZeroFill(this.isoWeekYear() % 100, 2);
>, <Line: -            },
>, <Line: -            GGGG : function () {
>, <Line: -                return leftZeroFill(this.isoWeekYear(), 4);
>, <Line: -            },
>, <Line: -            GGGGG : function () {
>, <Line: -                return leftZeroFill(this.isoWeekYear(), 5);
>, <Line: -            },
>, <Line: -            e : function () {
>, <Line: -                return this.weekday();
>, <Line: -            },
>, <Line: -            E : function () {
>, <Line: -                return this.isoWeekday();
>, <Line: -            },
>, <Line: -            a    : function () {
>, <Line: -                return this.localeData().meridiem(this.hours(), this.minutes(), true);
>, <Line: -            },
>, <Line: -            A    : function () {
>, <Line: -                return this.localeData().meridiem(this.hours(), this.minutes(), false);
>, <Line: -            },
>, <Line: -            H    : function () {
>, <Line: -                return this.hours();
>, <Line: -            },
>, <Line: -            h    : function () {
>, <Line: -                return this.hours() % 12 || 12;
>, <Line: -            },
>, <Line: -            m    : function () {
>, <Line: -                return this.minutes();
>, <Line: -            },
>, <Line: -            s    : function () {
>, <Line: -                return this.seconds();
>, <Line: -            },
>, <Line: -            S    : function () {
>, <Line: -                return toInt(this.milliseconds() / 100);
>, <Line: -            },
>, <Line: -            SS   : function () {
>, <Line: -                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
>, <Line: -            },
>, <Line: -            SSS  : function () {
>, <Line: -                return leftZeroFill(this.milliseconds(), 3);
>, <Line: -            },
>, <Line: -            SSSS : function () {
>, <Line: -                return leftZeroFill(this.milliseconds(), 3);
>, <Line: -            },
>, <Line: -            Z    : function () {
>, <Line: -                var a = -this.zone(),
>, <Line: -                    b = '+';
>, <Line: -                if (a < 0) {
>, <Line: -                    a = -a;
>, <Line: -                    b = '-';
>, <Line: -                }
>, <Line: -                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
>, <Line: -            },
>, <Line: -            ZZ   : function () {
>, <Line: -                var a = -this.zone(),
>, <Line: -                    b = '+';
>, <Line: -                if (a < 0) {
>, <Line: -                    a = -a;
>, <Line: -                    b = '-';
>, <Line: -                }
>, <Line: -                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
>, <Line: -            },
>, <Line: -            z : function () {
>, <Line: -                return this.zoneAbbr();
>, <Line: -            },
>, <Line: -            zz : function () {
>, <Line: -                return this.zoneName();
>, <Line: -            },
>, <Line: -            X    : function () {
>, <Line: -                return this.unix();
>, <Line: -            },
>, <Line: -            Q : function () {
>, <Line: -                return this.quarter();
>, <Line: -            }
>, <Line: -        },
>, <Line: -        deprecations = {},
>, <Line: -        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
>, <Line: -    // Pick the first defined of two or three arguments. dfl comes from
>, <Line: -    // default.
>, <Line: -    function dfl(a, b, c) {
>, <Line: -        switch (arguments.length) {
>, <Line: -            case 2: return a != null ? a : b;
>, <Line: -            case 3: return a != null ? a : b != null ? b : c;
>, <Line: -            default: throw new Error('Implement me');
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function defaultParsingFlags() {
>, <Line: -        // We need to deep clone this object, and es5 standard is not very
>, <Line: -        // helpful.
>, <Line: -        return {
>, <Line: -            empty : false,
>, <Line: -            unusedTokens : [],
>, <Line: -            unusedInput : [],
>, <Line: -            overflow : -2,
>, <Line: -            charsLeftOver : 0,
>, <Line: -            nullInput : false,
>, <Line: -            invalidMonth : null,
>, <Line: -            invalidFormat : false,
>, <Line: -            userInvalidated : false,
>, <Line: -            iso: false
>, <Line: -        };
>, <Line: -    }
>, <Line: -    function printMsg(msg) {
>, <Line: -        if (moment.suppressDeprecationWarnings === false &&
>, <Line: -                typeof console !== 'undefined' && console.warn) {
>, <Line: -            console.warn("Deprecation warning: " + msg);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function deprecate(msg, fn) {
>, <Line: -        var firstTime = true;
>, <Line: -        return extend(function () {
>, <Line: -            if (firstTime) {
>, <Line: -                printMsg(msg);
>, <Line: -                firstTime = false;
>, <Line: -            }
>, <Line: -            return fn.apply(this, arguments);
>, <Line: -        }, fn);
>, <Line: -    }
>, <Line: -    function deprecateSimple(name, msg) {
>, <Line: -        if (!deprecations[name]) {
>, <Line: -            printMsg(msg);
>, <Line: -            deprecations[name] = true;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function padToken(func, count) {
>, <Line: -        return function (a) {
>, <Line: -            return leftZeroFill(func.call(this, a), count);
>, <Line: -        };
>, <Line: -    }
>, <Line: -    function ordinalizeToken(func, period) {
>, <Line: -        return function (a) {
>, <Line: -            return this.localeData().ordinal(func.call(this, a), period);
>, <Line: -        };
>, <Line: -    }
>, <Line: -    while (ordinalizeTokens.length) {
>, <Line: -        i = ordinalizeTokens.pop();
>, <Line: -        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
>, <Line: -    }
>, <Line: -    while (paddedTokens.length) {
>, <Line: -        i = paddedTokens.pop();
>, <Line: -        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
>, <Line: -    }
>, <Line: -    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
>, <Line: -    /************************************
>, <Line: -        Constructors
>, <Line: -    ************************************/
>, <Line: -    function Locale() {
>, <Line: -    }
>, <Line: -    // Moment prototype object
>, <Line: -    function Moment(config, skipOverflow) {
>, <Line: -        if (skipOverflow !== false) {
>, <Line: -            checkOverflow(config);
>, <Line: -        }
>, <Line: -        copyConfig(this, config);
>, <Line: -        this._d = new Date(+config._d);
>, <Line: -    }
>, <Line: -    // Duration Constructor
>, <Line: -    function Duration(duration) {
>, <Line: -        var normalizedInput = normalizeObjectUnits(duration),
>, <Line: -            years = normalizedInput.year || 0,
>, <Line: -            quarters = normalizedInput.quarter || 0,
>, <Line: -            months = normalizedInput.month || 0,
>, <Line: -            weeks = normalizedInput.week || 0,
>, <Line: -            days = normalizedInput.day || 0,
>, <Line: -            hours = normalizedInput.hour || 0,
>, <Line: -            minutes = normalizedInput.minute || 0,
>, <Line: -            seconds = normalizedInput.second || 0,
>, <Line: -            milliseconds = normalizedInput.millisecond || 0;
>, <Line: -        // representation for dateAddRemove
>, <Line: -        this._milliseconds = +milliseconds +
>, <Line: -            seconds * 1e3 + // 1000
>, <Line: -            minutes * 6e4 + // 1000 * 60
>, <Line: -            hours * 36e5; // 1000 * 60 * 60
>, <Line: -        // Because of dateAddRemove treats 24 hours as different from a
>, <Line: -        // day when working around DST, we need to store them separately
>, <Line: -        this._days = +days +
>, <Line: -            weeks * 7;
>, <Line: -        // It is impossible translate months into days without knowing
>, <Line: -        // which months you are are talking about, so we have to store
>, <Line: -        // it separately.
>, <Line: -        this._months = +months +
>, <Line: -            quarters * 3 +
>, <Line: -            years * 12;
>, <Line: -        this._data = {};
>, <Line: -        this._locale = moment.localeData();
>, <Line: -        this._bubble();
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Helpers
>, <Line: -    ************************************/
>, <Line: -    function extend(a, b) {
>, <Line: -        for (var i in b) {
>, <Line: -            if (b.hasOwnProperty(i)) {
>, <Line: -                a[i] = b[i];
>, <Line: -            }
>, <Line: -        }
>, <Line: -        if (b.hasOwnProperty('toString')) {
>, <Line: -            a.toString = b.toString;
>, <Line: -        }
>, <Line: -        if (b.hasOwnProperty('valueOf')) {
>, <Line: -            a.valueOf = b.valueOf;
>, <Line: -        }
>, <Line: -        return a;
>, <Line: -    }
>, <Line: -    function copyConfig(to, from) {
>, <Line: -        var i, prop, val;
>, <Line: -        if (typeof from._isAMomentObject !== 'undefined') {
>, <Line: -            to._isAMomentObject = from._isAMomentObject;
>, <Line: -        }
>, <Line: -        if (typeof from._i !== 'undefined') {
>, <Line: -            to._i = from._i;
>, <Line: -        }
>, <Line: -        if (typeof from._f !== 'undefined') {
>, <Line: -            to._f = from._f;
>, <Line: -        }
>, <Line: -        if (typeof from._l !== 'undefined') {
>, <Line: -            to._l = from._l;
>, <Line: -        }
>, <Line: -        if (typeof from._strict !== 'undefined') {
>, <Line: -            to._strict = from._strict;
>, <Line: -        }
>, <Line: -        if (typeof from._tzm !== 'undefined') {
>, <Line: -            to._tzm = from._tzm;
>, <Line: -        }
>, <Line: -        if (typeof from._isUTC !== 'undefined') {
>, <Line: -            to._isUTC = from._isUTC;
>, <Line: -        }
>, <Line: -        if (typeof from._offset !== 'undefined') {
>, <Line: -            to._offset = from._offset;
>, <Line: -        }
>, <Line: -        if (typeof from._pf !== 'undefined') {
>, <Line: -            to._pf = from._pf;
>, <Line: -        }
>, <Line: -        if (typeof from._locale !== 'undefined') {
>, <Line: -            to._locale = from._locale;
>, <Line: -        }
>, <Line: -        if (momentProperties.length > 0) {
>, <Line: -            for (i in momentProperties) {
>, <Line: -                prop = momentProperties[i];
>, <Line: -                val = from[prop];
>, <Line: -                if (typeof val !== 'undefined') {
>, <Line: -                    to[prop] = val;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return to;
>, <Line: -    }
>, <Line: -    function absRound(number) {
>, <Line: -        if (number < 0) {
>, <Line: -            return Math.ceil(number);
>, <Line: -        } else {
>, <Line: -            return Math.floor(number);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // left zero fill a number
>, <Line: -    // see http://jsperf.com/left-zero-filling for performance comparison
>, <Line: -    function leftZeroFill(number, targetLength, forceSign) {
>, <Line: -        var output = '' + Math.abs(number),
>, <Line: -            sign = number >= 0;
>, <Line: -        while (output.length < targetLength) {
>, <Line: -            output = '0' + output;
>, <Line: -        }
>, <Line: -        return (sign ? (forceSign ? '+' : '') : '-') + output;
>, <Line: -    }
>, <Line: -    function positiveMomentsDifference(base, other) {
>, <Line: -        var res = {milliseconds: 0, months: 0};
>, <Line: -        res.months = other.month() - base.month() +
>, <Line: -            (other.year() - base.year()) * 12;
>, <Line: -        if (base.clone().add(res.months, 'M').isAfter(other)) {
>, <Line: -            --res.months;
>, <Line: -        }
>, <Line: -        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
>, <Line: -        return res;
>, <Line: -    }
>, <Line: -    function momentsDifference(base, other) {
>, <Line: -        var res;
>, <Line: -        other = makeAs(other, base);
>, <Line: -        if (base.isBefore(other)) {
>, <Line: -            res = positiveMomentsDifference(base, other);
>, <Line: -        } else {
>, <Line: -            res = positiveMomentsDifference(other, base);
>, <Line: -            res.milliseconds = -res.milliseconds;
>, <Line: -            res.months = -res.months;
>, <Line: -        }
>, <Line: -        return res;
>, <Line: -    }
>, <Line: -    // TODO: remove 'name' arg after deprecation is removed
>, <Line: -    function createAdder(direction, name) {
>, <Line: -        return function (val, period) {
>, <Line: -            var dur, tmp;
>, <Line: -            //invert the arguments, but complain about it
>, <Line: -            if (period !== null && !isNaN(+period)) {
>, <Line: -                deprecateSimple(name, "moment()." + name  + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
>, <Line: -                tmp = val; val = period; period = tmp;
>, <Line: -            }
>, <Line: -            val = typeof val === 'string' ? +val : val;
>, <Line: -            dur = moment.duration(val, period);
>, <Line: -            addOrSubtractDurationFromMoment(this, dur, direction);
>, <Line: -            return this;
>, <Line: -        };
>, <Line: -    }
>, <Line: -    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
>, <Line: -        var milliseconds = duration._milliseconds,
>, <Line: -            days = duration._days,
>, <Line: -            months = duration._months;
>, <Line: -        updateOffset = updateOffset == null ? true : updateOffset;
>, <Line: -        if (milliseconds) {
>, <Line: -            mom._d.setTime(+mom._d + milliseconds * isAdding);
>, <Line: -        }
>, <Line: -        if (days) {
>, <Line: -            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
>, <Line: -        }
>, <Line: -        if (months) {
>, <Line: -            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
>, <Line: -        }
>, <Line: -        if (updateOffset) {
>, <Line: -            moment.updateOffset(mom, days || months);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // check if is an array
>, <Line: -    function isArray(input) {
>, <Line: -        return Object.prototype.toString.call(input) === '[object Array]';
>, <Line: -    }
>, <Line: -    function isDate(input) {
>, <Line: -        return Object.prototype.toString.call(input) === '[object Date]' ||
>, <Line: -            input instanceof Date;
>, <Line: -    }
>, <Line: -    // compare two arrays, return the number of differences
>, <Line: -    function compareArrays(array1, array2, dontConvert) {
>, <Line: -        var len = Math.min(array1.length, array2.length),
>, <Line: -            lengthDiff = Math.abs(array1.length - array2.length),
>, <Line: -            diffs = 0,
>, <Line: -            i;
>, <Line: -        for (i = 0; i < len; i++) {
>, <Line: -            if ((dontConvert && array1[i] !== array2[i]) ||
>, <Line: -                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
>, <Line: -                diffs++;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return diffs + lengthDiff;
>, <Line: -    }
>, <Line: -    function normalizeUnits(units) {
>, <Line: -        if (units) {
>, <Line: -            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
>, <Line: -            units = unitAliases[units] || camelFunctions[lowered] || lowered;
>, <Line: -        }
>, <Line: -        return units;
>, <Line: -    }
>, <Line: -    function normalizeObjectUnits(inputObject) {
>, <Line: -        var normalizedInput = {},
>, <Line: -            normalizedProp,
>, <Line: -            prop;
>, <Line: -        for (prop in inputObject) {
>, <Line: -            if (inputObject.hasOwnProperty(prop)) {
>, <Line: -                normalizedProp = normalizeUnits(prop);
>, <Line: -                if (normalizedProp) {
>, <Line: -                    normalizedInput[normalizedProp] = inputObject[prop];
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return normalizedInput;
>, <Line: -    }
>, <Line: -    function makeList(field) {
>, <Line: -        var count, setter;
>, <Line: -        if (field.indexOf('week') === 0) {
>, <Line: -            count = 7;
>, <Line: -            setter = 'day';
>, <Line: -        }
>, <Line: -        else if (field.indexOf('month') === 0) {
>, <Line: -            count = 12;
>, <Line: -            setter = 'month';
>, <Line: -        }
>, <Line: -        else {
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        moment[field] = function (format, index) {
>, <Line: -            var i, getter,
>, <Line: -                method = moment._locale[field],
>, <Line: -                results = [];
>, <Line: -            if (typeof format === 'number') {
>, <Line: -                index = format;
>, <Line: -                format = undefined;
>, <Line: -            }
>, <Line: -            getter = function (i) {
>, <Line: -                var m = moment().utc().set(setter, i);
>, <Line: -                return method.call(moment._locale, m, format || '');
>, <Line: -            };
>, <Line: -            if (index != null) {
>, <Line: -                return getter(index);
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                for (i = 0; i < count; i++) {
>, <Line: -                    results.push(getter(i));
>, <Line: -                }
>, <Line: -                return results;
>, <Line: -            }
>, <Line: -        };
>, <Line: -    }
>, <Line: -    function toInt(argumentForCoercion) {
>, <Line: -        var coercedNumber = +argumentForCoercion,
>, <Line: -            value = 0;
>, <Line: -        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
>, <Line: -            if (coercedNumber >= 0) {
>, <Line: -                value = Math.floor(coercedNumber);
>, <Line: -            } else {
>, <Line: -                value = Math.ceil(coercedNumber);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return value;
>, <Line: -    }
>, <Line: -    function daysInMonth(year, month) {
>, <Line: -        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
>, <Line: -    }
>, <Line: -    function weeksInYear(year, dow, doy) {
>, <Line: -        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
>, <Line: -    }
>, <Line: -    function daysInYear(year) {
>, <Line: -        return isLeapYear(year) ? 366 : 365;
>, <Line: -    }
>, <Line: -    function isLeapYear(year) {
>, <Line: -        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
>, <Line: -    }
>, <Line: -    function checkOverflow(m) {
>, <Line: -        var overflow;
>, <Line: -        if (m._a && m._pf.overflow === -2) {
>, <Line: -            overflow =
>, <Line: -                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
>, <Line: -                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
>, <Line: -                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
>, <Line: -                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
>, <Line: -                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
>, <Line: -                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
>, <Line: -                -1;
>, <Line: -            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
>, <Line: -                overflow = DATE;
>, <Line: -            }
>, <Line: -            m._pf.overflow = overflow;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function isValid(m) {
>, <Line: -        if (m._isValid == null) {
>, <Line: -            m._isValid = !isNaN(m._d.getTime()) &&
>, <Line: -                m._pf.overflow < 0 &&
>, <Line: -                !m._pf.empty &&
>, <Line: -                !m._pf.invalidMonth &&
>, <Line: -                !m._pf.nullInput &&
>, <Line: -                !m._pf.invalidFormat &&
>, <Line: -                !m._pf.userInvalidated;
>, <Line: -            if (m._strict) {
>, <Line: -                m._isValid = m._isValid &&
>, <Line: -                    m._pf.charsLeftOver === 0 &&
>, <Line: -                    m._pf.unusedTokens.length === 0;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return m._isValid;
>, <Line: -    }
>, <Line: -    function normalizeLocale(key) {
>, <Line: -        return key ? key.toLowerCase().replace('_', '-') : key;
>, <Line: -    }
>, <Line: -    // pick the locale from the array
>, <Line: -    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
>, <Line: -    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
>, <Line: -    function chooseLocale(names) {
>, <Line: -        var i = 0, j, next, locale, split;
>, <Line: -        while (i < names.length) {
>, <Line: -            split = normalizeLocale(names[i]).split('-');
>, <Line: -            j = split.length;
>, <Line: -            next = normalizeLocale(names[i + 1]);
>, <Line: -            next = next ? next.split('-') : null;
>, <Line: -            while (j > 0) {
>, <Line: -                locale = loadLocale(split.slice(0, j).join('-'));
>, <Line: -                if (locale) {
>, <Line: -                    return locale;
>, <Line: -                }
>, <Line: -                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
>, <Line: -                    //the next array item is better than a shallower substring of this one
>, <Line: -                    break;
>, <Line: -                }
>, <Line: -                j--;
>, <Line: -            }
>, <Line: -            i++;
>, <Line: -        }
>, <Line: -        return null;
>, <Line: -    }
>, <Line: -    function loadLocale(name) {
>, <Line: -        var oldLocale = null;
>, <Line: -        if (!locales[name] && hasModule) {
>, <Line: -            try {
>, <Line: -                oldLocale = moment.locale();
>, <Line: -                require('./locale/' + name);
>, <Line: -                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
>, <Line: -                moment.locale(oldLocale);
>, <Line: -            } catch (e) { }
>, <Line: -        }
>, <Line: -        return locales[name];
>, <Line: -    }
>, <Line: -    // Return a moment from input, that is local/utc/zone equivalent to model.
>, <Line: -    function makeAs(input, model) {
>, <Line: -        return model._isUTC ? moment(input).zone(model._offset || 0) :
>, <Line: -            moment(input).local();
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Locale
>, <Line: -    ************************************/
>, <Line: -    extend(Locale.prototype, {
>, <Line: -        set : function (config) {
>, <Line: -            var prop, i;
>, <Line: -            for (i in config) {
>, <Line: -                prop = config[i];
>, <Line: -                if (typeof prop === 'function') {
>, <Line: -                    this[i] = prop;
>, <Line: -                } else {
>, <Line: -                    this['_' + i] = prop;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        },
>, <Line: -        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
>, <Line: -        months : function (m) {
>, <Line: -            return this._months[m.month()];
>, <Line: -        },
>, <Line: -        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
>, <Line: -        monthsShort : function (m) {
>, <Line: -            return this._monthsShort[m.month()];
>, <Line: -        },
>, <Line: -        monthsParse : function (monthName) {
>, <Line: -            var i, mom, regex;
>, <Line: -            if (!this._monthsParse) {
>, <Line: -                this._monthsParse = [];
>, <Line: -            }
>, <Line: -            for (i = 0; i < 12; i++) {
>, <Line: -                // make the regex if we don't have it already
>, <Line: -                if (!this._monthsParse[i]) {
>, <Line: -                    mom = moment.utc([2000, i]);
>, <Line: -                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
>, <Line: -                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
>, <Line: -                }
>, <Line: -                // test the regex
>, <Line: -                if (this._monthsParse[i].test(monthName)) {
>, <Line: -                    return i;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        },
>, <Line: -        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
>, <Line: -        weekdays : function (m) {
>, <Line: -            return this._weekdays[m.day()];
>, <Line: -        },
>, <Line: -        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
>, <Line: -        weekdaysShort : function (m) {
>, <Line: -            return this._weekdaysShort[m.day()];
>, <Line: -        },
>, <Line: -        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
>, <Line: -        weekdaysMin : function (m) {
>, <Line: -            return this._weekdaysMin[m.day()];
>, <Line: -        },
>, <Line: -        weekdaysParse : function (weekdayName) {
>, <Line: -            var i, mom, regex;
>, <Line: -            if (!this._weekdaysParse) {
>, <Line: -                this._weekdaysParse = [];
>, <Line: -            }
>, <Line: -            for (i = 0; i < 7; i++) {
>, <Line: -                // make the regex if we don't have it already
>, <Line: -                if (!this._weekdaysParse[i]) {
>, <Line: -                    mom = moment([2000, 1]).day(i);
>, <Line: -                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
>, <Line: -                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
>, <Line: -                }
>, <Line: -                // test the regex
>, <Line: -                if (this._weekdaysParse[i].test(weekdayName)) {
>, <Line: -                    return i;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        },
>, <Line: -        _longDateFormat : {
>, <Line: -            LT : 'h:mm A',
>, <Line: -            L : 'MM/DD/YYYY',
>, <Line: -            LL : 'MMMM D, YYYY',
>, <Line: -            LLL : 'MMMM D, YYYY LT',
>, <Line: -            LLLL : 'dddd, MMMM D, YYYY LT'
>, <Line: -        },
>, <Line: -        longDateFormat : function (key) {
>, <Line: -            var output = this._longDateFormat[key];
>, <Line: -            if (!output && this._longDateFormat[key.toUpperCase()]) {
>, <Line: -                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
>, <Line: -                    return val.slice(1);
>, <Line: -                });
>, <Line: -                this._longDateFormat[key] = output;
>, <Line: -            }
>, <Line: -            return output;
>, <Line: -        },
>, <Line: -        isPM : function (input) {
>, <Line: -            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
>, <Line: -            // Using charAt should be more compatible.
>, <Line: -            return ((input + '').toLowerCase().charAt(0) === 'p');
>, <Line: -        },
>, <Line: -        _meridiemParse : /[ap]\.?m?\.?/i,
>, <Line: -        meridiem : function (hours, minutes, isLower) {
>, <Line: -            if (hours > 11) {
>, <Line: -                return isLower ? 'pm' : 'PM';
>, <Line: -            } else {
>, <Line: -                return isLower ? 'am' : 'AM';
>, <Line: -            }
>, <Line: -        },
>, <Line: -        _calendar : {
>, <Line: -            sameDay : '[Today at] LT',
>, <Line: -            nextDay : '[Tomorrow at] LT',
>, <Line: -            nextWeek : 'dddd [at] LT',
>, <Line: -            lastDay : '[Yesterday at] LT',
>, <Line: -            lastWeek : '[Last] dddd [at] LT',
>, <Line: -            sameElse : 'L'
>, <Line: -        },
>, <Line: -        calendar : function (key, mom) {
>, <Line: -            var output = this._calendar[key];
>, <Line: -            return typeof output === 'function' ? output.apply(mom) : output;
>, <Line: -        },
>, <Line: -        _relativeTime : {
>, <Line: -            future : 'in %s',
>, <Line: -            past : '%s ago',
>, <Line: -            s : 'a few seconds',
>, <Line: -            m : 'a minute',
>, <Line: -            mm : '%d minutes',
>, <Line: -            h : 'an hour',
>, <Line: -            hh : '%d hours',
>, <Line: -            d : 'a day',
>, <Line: -            dd : '%d days',
>, <Line: -            M : 'a month',
>, <Line: -            MM : '%d months',
>, <Line: -            y : 'a year',
>, <Line: -            yy : '%d years'
>, <Line: -        },
>, <Line: -        relativeTime : function (number, withoutSuffix, string, isFuture) {
>, <Line: -            var output = this._relativeTime[string];
>, <Line: -            return (typeof output === 'function') ?
>, <Line: -                output(number, withoutSuffix, string, isFuture) :
>, <Line: -                output.replace(/%d/i, number);
>, <Line: -        },
>, <Line: -        pastFuture : function (diff, output) {
>, <Line: -            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
>, <Line: -            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
>, <Line: -        },
>, <Line: -        ordinal : function (number) {
>, <Line: -            return this._ordinal.replace('%d', number);
>, <Line: -        },
>, <Line: -        _ordinal : '%d',
>, <Line: -        preparse : function (string) {
>, <Line: -            return string;
>, <Line: -        },
>, <Line: -        postformat : function (string) {
>, <Line: -            return string;
>, <Line: -        },
>, <Line: -        week : function (mom) {
>, <Line: -            return weekOfYear(mom, this._week.dow, this._week.doy).week;
>, <Line: -        },
>, <Line: -        _week : {
>, <Line: -            dow : 0, // Sunday is the first day of the week.
>, <Line: -            doy : 6  // The week that contains Jan 1st is the first week of the year.
>, <Line: -        },
>, <Line: -        _invalidDate: 'Invalid date',
>, <Line: -        invalidDate: function () {
>, <Line: -            return this._invalidDate;
>, <Line: -        }
>, <Line: -    });
>, <Line: -    /************************************
>, <Line: -        Formatting
>, <Line: -    ************************************/
>, <Line: -    function removeFormattingTokens(input) {
>, <Line: -        if (input.match(/\[[\s\S]/)) {
>, <Line: -            return input.replace(/^\[|\]$/g, '');
>, <Line: -        }
>, <Line: -        return input.replace(/\\/g, '');
>, <Line: -    }
>, <Line: -    function makeFormatFunction(format) {
>, <Line: -        var array = format.match(formattingTokens), i, length;
>, <Line: -        for (i = 0, length = array.length; i < length; i++) {
>, <Line: -            if (formatTokenFunctions[array[i]]) {
>, <Line: -                array[i] = formatTokenFunctions[array[i]];
>, <Line: -            } else {
>, <Line: -                array[i] = removeFormattingTokens(array[i]);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return function (mom) {
>, <Line: -            var output = '';
>, <Line: -            for (i = 0; i < length; i++) {
>, <Line: -                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
>, <Line: -            }
>, <Line: -            return output;
>, <Line: -        };
>, <Line: -    }
>, <Line: -    // format date using native date object
>, <Line: -    function formatMoment(m, format) {
>, <Line: -        if (!m.isValid()) {
>, <Line: -            return m.localeData().invalidDate();
>, <Line: -        }
>, <Line: -        format = expandFormat(format, m.localeData());
>, <Line: -        if (!formatFunctions[format]) {
>, <Line: -            formatFunctions[format] = makeFormatFunction(format);
>, <Line: -        }
>, <Line: -        return formatFunctions[format](m);
>, <Line: -    }
>, <Line: -    function expandFormat(format, locale) {
>, <Line: -        var i = 5;
>, <Line: -        function replaceLongDateFormatTokens(input) {
>, <Line: -            return locale.longDateFormat(input) || input;
>, <Line: -        }
>, <Line: -        localFormattingTokens.lastIndex = 0;
>, <Line: -        while (i >= 0 && localFormattingTokens.test(format)) {
>, <Line: -            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
>, <Line: -            localFormattingTokens.lastIndex = 0;
>, <Line: -            i -= 1;
>, <Line: -        }
>, <Line: -        return format;
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Parsing
>, <Line: -    ************************************/
>, <Line: -    // get the regex to find the next token
>, <Line: -    function getParseRegexForToken(token, config) {
>, <Line: -        var a, strict = config._strict;
>, <Line: -        switch (token) {
>, <Line: -        case 'Q':
>, <Line: -            return parseTokenOneDigit;
>, <Line: -        case 'DDDD':
>, <Line: -            return parseTokenThreeDigits;
>, <Line: -        case 'YYYY':
>, <Line: -        case 'GGGG':
>, <Line: -        case 'gggg':
>, <Line: -            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
>, <Line: -        case 'Y':
>, <Line: -        case 'G':
>, <Line: -        case 'g':
>, <Line: -            return parseTokenSignedNumber;
>, <Line: -        case 'YYYYYY':
>, <Line: -        case 'YYYYY':
>, <Line: -        case 'GGGGG':
>, <Line: -        case 'ggggg':
>, <Line: -            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
>, <Line: -        case 'S':
>, <Line: -            if (strict) {
>, <Line: -                return parseTokenOneDigit;
>, <Line: -            }
>, <Line: -            /* falls through */
>, <Line: -        case 'SS':
>, <Line: -            if (strict) {
>, <Line: -                return parseTokenTwoDigits;
>, <Line: -            }
>, <Line: -            /* falls through */
>, <Line: -        case 'SSS':
>, <Line: -            if (strict) {
>, <Line: -                return parseTokenThreeDigits;
>, <Line: -            }
>, <Line: -            /* falls through */
>, <Line: -        case 'DDD':
>, <Line: -            return parseTokenOneToThreeDigits;
>, <Line: -        case 'MMM':
>, <Line: -        case 'MMMM':
>, <Line: -        case 'dd':
>, <Line: -        case 'ddd':
>, <Line: -        case 'dddd':
>, <Line: -            return parseTokenWord;
>, <Line: -        case 'a':
>, <Line: -        case 'A':
>, <Line: -            return config._locale._meridiemParse;
>, <Line: -        case 'X':
>, <Line: -            return parseTokenTimestampMs;
>, <Line: -        case 'Z':
>, <Line: -        case 'ZZ':
>, <Line: -            return parseTokenTimezone;
>, <Line: -        case 'T':
>, <Line: -            return parseTokenT;
>, <Line: -        case 'SSSS':
>, <Line: -            return parseTokenDigits;
>, <Line: -        case 'MM':
>, <Line: -        case 'DD':
>, <Line: -        case 'YY':
>, <Line: -        case 'GG':
>, <Line: -        case 'gg':
>, <Line: -        case 'HH':
>, <Line: -        case 'hh':
>, <Line: -        case 'mm':
>, <Line: -        case 'ss':
>, <Line: -        case 'ww':
>, <Line: -        case 'WW':
>, <Line: -            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
>, <Line: -        case 'M':
>, <Line: -        case 'D':
>, <Line: -        case 'd':
>, <Line: -        case 'H':
>, <Line: -        case 'h':
>, <Line: -        case 'm':
>, <Line: -        case 's':
>, <Line: -        case 'w':
>, <Line: -        case 'W':
>, <Line: -        case 'e':
>, <Line: -        case 'E':
>, <Line: -            return parseTokenOneOrTwoDigits;
>, <Line: -        case 'Do':
>, <Line: -            return parseTokenOrdinal;
>, <Line: -        default :
>, <Line: -            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
>, <Line: -            return a;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function timezoneMinutesFromString(string) {
>, <Line: -        string = string || '';
>, <Line: -        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
>, <Line: -            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
>, <Line: -            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
>, <Line: -            minutes = +(parts[1] * 60) + toInt(parts[2]);
>, <Line: -        return parts[0] === '+' ? -minutes : minutes;
>, <Line: -    }
>, <Line: -    // function to convert string input to date
>, <Line: -    function addTimeToArrayFromToken(token, input, config) {
>, <Line: -        var a, datePartArray = config._a;
>, <Line: -        switch (token) {
>, <Line: -        // QUARTER
>, <Line: -        case 'Q':
>, <Line: -            if (input != null) {
>, <Line: -                datePartArray[MONTH] = (toInt(input) - 1) * 3;
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        // MONTH
>, <Line: -        case 'M' : // fall through to MM
>, <Line: -        case 'MM' :
>, <Line: -            if (input != null) {
>, <Line: -                datePartArray[MONTH] = toInt(input) - 1;
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        case 'MMM' : // fall through to MMMM
>, <Line: -        case 'MMMM' :
>, <Line: -            a = config._locale.monthsParse(input);
>, <Line: -            // if we didn't find a month name, mark the date as invalid.
>, <Line: -            if (a != null) {
>, <Line: -                datePartArray[MONTH] = a;
>, <Line: -            } else {
>, <Line: -                config._pf.invalidMonth = input;
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        // DAY OF MONTH
>, <Line: -        case 'D' : // fall through to DD
>, <Line: -        case 'DD' :
>, <Line: -            if (input != null) {
>, <Line: -                datePartArray[DATE] = toInt(input);
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        case 'Do' :
>, <Line: -            if (input != null) {
>, <Line: -                datePartArray[DATE] = toInt(parseInt(input, 10));
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        // DAY OF YEAR
>, <Line: -        case 'DDD' : // fall through to DDDD
>, <Line: -        case 'DDDD' :
>, <Line: -            if (input != null) {
>, <Line: -                config._dayOfYear = toInt(input);
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        // YEAR
>, <Line: -        case 'YY' :
>, <Line: -            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
>, <Line: -            break;
>, <Line: -        case 'YYYY' :
>, <Line: -        case 'YYYYY' :
>, <Line: -        case 'YYYYYY' :
>, <Line: -            datePartArray[YEAR] = toInt(input);
>, <Line: -            break;
>, <Line: -        // AM / PM
>, <Line: -        case 'a' : // fall through to A
>, <Line: -        case 'A' :
>, <Line: -            config._isPm = config._locale.isPM(input);
>, <Line: -            break;
>, <Line: -        // 24 HOUR
>, <Line: -        case 'H' : // fall through to hh
>, <Line: -        case 'HH' : // fall through to hh
>, <Line: -        case 'h' : // fall through to hh
>, <Line: -        case 'hh' :
>, <Line: -            datePartArray[HOUR] = toInt(input);
>, <Line: -            break;
>, <Line: -        // MINUTE
>, <Line: -        case 'm' : // fall through to mm
>, <Line: -        case 'mm' :
>, <Line: -            datePartArray[MINUTE] = toInt(input);
>, <Line: -            break;
>, <Line: -        // SECOND
>, <Line: -        case 's' : // fall through to ss
>, <Line: -        case 'ss' :
>, <Line: -            datePartArray[SECOND] = toInt(input);
>, <Line: -            break;
>, <Line: -        // MILLISECOND
>, <Line: -        case 'S' :
>, <Line: -        case 'SS' :
>, <Line: -        case 'SSS' :
>, <Line: -        case 'SSSS' :
>, <Line: -            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
>, <Line: -            break;
>, <Line: -        // UNIX TIMESTAMP WITH MS
>, <Line: -        case 'X':
>, <Line: -            config._d = new Date(parseFloat(input) * 1000);
>, <Line: -            break;
>, <Line: -        // TIMEZONE
>, <Line: -        case 'Z' : // fall through to ZZ
>, <Line: -        case 'ZZ' :
>, <Line: -            config._useUTC = true;
>, <Line: -            config._tzm = timezoneMinutesFromString(input);
>, <Line: -            break;
>, <Line: -        // WEEKDAY - human
>, <Line: -        case 'dd':
>, <Line: -        case 'ddd':
>, <Line: -        case 'dddd':
>, <Line: -            a = config._locale.weekdaysParse(input);
>, <Line: -            // if we didn't get a weekday name, mark the date as invalid
>, <Line: -            if (a != null) {
>, <Line: -                config._w = config._w || {};
>, <Line: -                config._w['d'] = a;
>, <Line: -            } else {
>, <Line: -                config._pf.invalidWeekday = input;
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        // WEEK, WEEK DAY - numeric
>, <Line: -        case 'w':
>, <Line: -        case 'ww':
>, <Line: -        case 'W':
>, <Line: -        case 'WW':
>, <Line: -        case 'd':
>, <Line: -        case 'e':
>, <Line: -        case 'E':
>, <Line: -            token = token.substr(0, 1);
>, <Line: -            /* falls through */
>, <Line: -        case 'gggg':
>, <Line: -        case 'GGGG':
>, <Line: -        case 'GGGGG':
>, <Line: -            token = token.substr(0, 2);
>, <Line: -            if (input) {
>, <Line: -                config._w = config._w || {};
>, <Line: -                config._w[token] = toInt(input);
>, <Line: -            }
>, <Line: -            break;
>, <Line: -        case 'gg':
>, <Line: -        case 'GG':
>, <Line: -            config._w = config._w || {};
>, <Line: -            config._w[token] = moment.parseTwoDigitYear(input);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function dayOfYearFromWeekInfo(config) {
>, <Line: -        var w, weekYear, week, weekday, dow, doy, temp;
>, <Line: -        w = config._w;
>, <Line: -        if (w.GG != null || w.W != null || w.E != null) {
>, <Line: -            dow = 1;
>, <Line: -            doy = 4;
>, <Line: -            // TODO: We need to take the current isoWeekYear, but that depends on
>, <Line: -            // how we interpret now (local, utc, fixed offset). So create
>, <Line: -            // a now version of current config (take local/utc/offset flags, and
>, <Line: -            // create now).
>, <Line: -            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
>, <Line: -            week = dfl(w.W, 1);
>, <Line: -            weekday = dfl(w.E, 1);
>, <Line: -        } else {
>, <Line: -            dow = config._locale._week.dow;
>, <Line: -            doy = config._locale._week.doy;
>, <Line: -            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
>, <Line: -            week = dfl(w.w, 1);
>, <Line: -            if (w.d != null) {
>, <Line: -                // weekday -- low day numbers are considered next week
>, <Line: -                weekday = w.d;
>, <Line: -                if (weekday < dow) {
>, <Line: -                    ++week;
>, <Line: -                }
>, <Line: -            } else if (w.e != null) {
>, <Line: -                // local weekday -- counting starts from begining of week
>, <Line: -                weekday = w.e + dow;
>, <Line: -            } else {
>, <Line: -                // default to begining of week
>, <Line: -                weekday = dow;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
>, <Line: -        config._a[YEAR] = temp.year;
>, <Line: -        config._dayOfYear = temp.dayOfYear;
>, <Line: -    }
>, <Line: -    // convert an array to a date.
>, <Line: -    // the array should mirror the parameters below
>, <Line: -    // note: all values past the year are optional and will default to the lowest possible value.
>, <Line: -    // [year, month, day , hour, minute, second, millisecond]
>, <Line: -    function dateFromConfig(config) {
>, <Line: -        var i, date, input = [], currentDate, yearToUse;
>, <Line: -        if (config._d) {
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        currentDate = currentDateArray(config);
>, <Line: -        //compute day of the year from weeks and weekdays
>, <Line: -        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
>, <Line: -            dayOfYearFromWeekInfo(config);
>, <Line: -        }
>, <Line: -        //if the day of the year is set, figure out what it is
>, <Line: -        if (config._dayOfYear) {
>, <Line: -            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
>, <Line: -            if (config._dayOfYear > daysInYear(yearToUse)) {
>, <Line: -                config._pf._overflowDayOfYear = true;
>, <Line: -            }
>, <Line: -            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
>, <Line: -            config._a[MONTH] = date.getUTCMonth();
>, <Line: -            config._a[DATE] = date.getUTCDate();
>, <Line: -        }
>, <Line: -        // Default to current date.
>, <Line: -        // * if no year, month, day of month are given, default to today
>, <Line: -        // * if day of month is given, default month and year
>, <Line: -        // * if month is given, default only year
>, <Line: -        // * if year is given, don't default anything
>, <Line: -        for (i = 0; i < 3 && config._a[i] == null; ++i) {
>, <Line: -            config._a[i] = input[i] = currentDate[i];
>, <Line: -        }
>, <Line: -        // Zero out whatever was not defaulted, including time
>, <Line: -        for (; i < 7; i++) {
>, <Line: -            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
>, <Line: -        }
>, <Line: -        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
>, <Line: -        // Apply timezone offset from input. The actual zone can be changed
>, <Line: -        // with parseZone.
>, <Line: -        if (config._tzm != null) {
>, <Line: -            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function dateFromObject(config) {
>, <Line: -        var normalizedInput;
>, <Line: -        if (config._d) {
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        normalizedInput = normalizeObjectUnits(config._i);
>, <Line: -        config._a = [
>, <Line: -            normalizedInput.year,
>, <Line: -            normalizedInput.month,
>, <Line: -            normalizedInput.day,
>, <Line: -            normalizedInput.hour,
>, <Line: -            normalizedInput.minute,
>, <Line: -            normalizedInput.second,
>, <Line: -            normalizedInput.millisecond
>, <Line: -        ];
>, <Line: -        dateFromConfig(config);
>, <Line: -    }
>, <Line: -    function currentDateArray(config) {
>, <Line: -        var now = new Date();
>, <Line: -        if (config._useUTC) {
>, <Line: -            return [
>, <Line: -                now.getUTCFullYear(),
>, <Line: -                now.getUTCMonth(),
>, <Line: -                now.getUTCDate()
>, <Line: -            ];
>, <Line: -        } else {
>, <Line: -            return [now.getFullYear(), now.getMonth(), now.getDate()];
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // date from string and format string
>, <Line: -    function makeDateFromStringAndFormat(config) {
>, <Line: -        if (config._f === moment.ISO_8601) {
>, <Line: -            parseISO(config);
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        config._a = [];
>, <Line: -        config._pf.empty = true;
>, <Line: -        // This array is used to make a Date, either with `new Date` or `Date.UTC`
>, <Line: -        var string = '' + config._i,
>, <Line: -            i, parsedInput, tokens, token, skipped,
>, <Line: -            stringLength = string.length,
>, <Line: -            totalParsedInputLength = 0;
>, <Line: -        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
>, <Line: -        for (i = 0; i < tokens.length; i++) {
>, <Line: -            token = tokens[i];
>, <Line: -            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
>, <Line: -            if (parsedInput) {
>, <Line: -                skipped = string.substr(0, string.indexOf(parsedInput));
>, <Line: -                if (skipped.length > 0) {
>, <Line: -                    config._pf.unusedInput.push(skipped);
>, <Line: -                }
>, <Line: -                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
>, <Line: -                totalParsedInputLength += parsedInput.length;
>, <Line: -            }
>, <Line: -            // don't parse if it's not a known token
>, <Line: -            if (formatTokenFunctions[token]) {
>, <Line: -                if (parsedInput) {
>, <Line: -                    config._pf.empty = false;
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    config._pf.unusedTokens.push(token);
>, <Line: -                }
>, <Line: -                addTimeToArrayFromToken(token, parsedInput, config);
>, <Line: -            }
>, <Line: -            else if (config._strict && !parsedInput) {
>, <Line: -                config._pf.unusedTokens.push(token);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        // add remaining unparsed input length to the string
>, <Line: -        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
>, <Line: -        if (string.length > 0) {
>, <Line: -            config._pf.unusedInput.push(string);
>, <Line: -        }
>, <Line: -        // handle am pm
>, <Line: -        if (config._isPm && config._a[HOUR] < 12) {
>, <Line: -            config._a[HOUR] += 12;
>, <Line: -        }
>, <Line: -        // if is 12 am, change hours to 0
>, <Line: -        if (config._isPm === false && config._a[HOUR] === 12) {
>, <Line: -            config._a[HOUR] = 0;
>, <Line: -        }
>, <Line: -        dateFromConfig(config);
>, <Line: -        checkOverflow(config);
>, <Line: -    }
>, <Line: -    function unescapeFormat(s) {
>, <Line: -        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
>, <Line: -            return p1 || p2 || p3 || p4;
>, <Line: -        });
>, <Line: -    }
>, <Line: -    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
>, <Line: -    function regexpEscape(s) {
>, <Line: -        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
>, <Line: -    }
>, <Line: -    // date from string and array of format strings
>, <Line: -    function makeDateFromStringAndArray(config) {
>, <Line: -        var tempConfig,
>, <Line: -            bestMoment,
>, <Line: -            scoreToBeat,
>, <Line: -            i,
>, <Line: -            currentScore;
>, <Line: -        if (config._f.length === 0) {
>, <Line: -            config._pf.invalidFormat = true;
>, <Line: -            config._d = new Date(NaN);
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        for (i = 0; i < config._f.length; i++) {
>, <Line: -            currentScore = 0;
>, <Line: -            tempConfig = copyConfig({}, config);
>, <Line: -            tempConfig._pf = defaultParsingFlags();
>, <Line: -            tempConfig._f = config._f[i];
>, <Line: -            makeDateFromStringAndFormat(tempConfig);
>, <Line: -            if (!isValid(tempConfig)) {
>, <Line: -                continue;
>, <Line: -            }
>, <Line: -            // if there is any input that was not parsed add a penalty for that format
>, <Line: -            currentScore += tempConfig._pf.charsLeftOver;
>, <Line: -            //or tokens
>, <Line: -            currentScore += tempConfig._pf.unusedTokens.length * 10;
>, <Line: -            tempConfig._pf.score = currentScore;
>, <Line: -            if (scoreToBeat == null || currentScore < scoreToBeat) {
>, <Line: -                scoreToBeat = currentScore;
>, <Line: -                bestMoment = tempConfig;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        extend(config, bestMoment || tempConfig);
>, <Line: -    }
>, <Line: -    // date from iso format
>, <Line: -    function parseISO(config) {
>, <Line: -        var i, l,
>, <Line: -            string = config._i,
>, <Line: -            match = isoRegex.exec(string);
>, <Line: -        if (match) {
>, <Line: -            config._pf.iso = true;
>, <Line: -            for (i = 0, l = isoDates.length; i < l; i++) {
>, <Line: -                if (isoDates[i][1].exec(string)) {
>, <Line: -                    // match[5] should be "T" or undefined
>, <Line: -                    config._f = isoDates[i][0] + (match[6] || ' ');
>, <Line: -                    break;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            for (i = 0, l = isoTimes.length; i < l; i++) {
>, <Line: -                if (isoTimes[i][1].exec(string)) {
>, <Line: -                    config._f += isoTimes[i][0];
>, <Line: -                    break;
>, <Line: -                }
>, <Line: -            }
>, <Line: -            if (string.match(parseTokenTimezone)) {
>, <Line: -                config._f += 'Z';
>, <Line: -            }
>, <Line: -            makeDateFromStringAndFormat(config);
>, <Line: -        } else {
>, <Line: -            config._isValid = false;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // date from iso format or fallback
>, <Line: -    function makeDateFromString(config) {
>, <Line: -        parseISO(config);
>, <Line: -        if (config._isValid === false) {
>, <Line: -            delete config._isValid;
>, <Line: -            moment.createFromInputFallback(config);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function makeDateFromInput(config) {
>, <Line: -        var input = config._i, matched;
>, <Line: -        if (input === undefined) {
>, <Line: -            config._d = new Date();
>, <Line: -        } else if (isDate(input)) {
>, <Line: -            config._d = new Date(+input);
>, <Line: -        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
>, <Line: -            config._d = new Date(+matched[1]);
>, <Line: -        } else if (typeof input === 'string') {
>, <Line: -            makeDateFromString(config);
>, <Line: -        } else if (isArray(input)) {
>, <Line: -            config._a = input.slice(0);
>, <Line: -            dateFromConfig(config);
>, <Line: -        } else if (typeof(input) === 'object') {
>, <Line: -            dateFromObject(config);
>, <Line: -        } else if (typeof(input) === 'number') {
>, <Line: -            // from milliseconds
>, <Line: -            config._d = new Date(input);
>, <Line: -        } else {
>, <Line: -            moment.createFromInputFallback(config);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function makeDate(y, m, d, h, M, s, ms) {
>, <Line: -        //can't just apply() to create a date:
>, <Line: -        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
>, <Line: -        var date = new Date(y, m, d, h, M, s, ms);
>, <Line: -        //the date constructor doesn't accept years < 1970
>, <Line: -        if (y < 1970) {
>, <Line: -            date.setFullYear(y);
>, <Line: -        }
>, <Line: -        return date;
>, <Line: -    }
>, <Line: -    function makeUTCDate(y) {
>, <Line: -        var date = new Date(Date.UTC.apply(null, arguments));
>, <Line: -        if (y < 1970) {
>, <Line: -            date.setUTCFullYear(y);
>, <Line: -        }
>, <Line: -        return date;
>, <Line: -    }
>, <Line: -    function parseWeekday(input, locale) {
>, <Line: -        if (typeof input === 'string') {
>, <Line: -            if (!isNaN(input)) {
>, <Line: -                input = parseInt(input, 10);
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                input = locale.weekdaysParse(input);
>, <Line: -                if (typeof input !== 'number') {
>, <Line: -                    return null;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return input;
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Relative Time
>, <Line: -    ************************************/
>, <Line: -    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
>, <Line: -    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
>, <Line: -        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
>, <Line: -    }
>, <Line: -    function relativeTime(posNegDuration, withoutSuffix, locale) {
>, <Line: -        var duration = moment.duration(posNegDuration).abs(),
>, <Line: -            seconds = round(duration.as('s')),
>, <Line: -            minutes = round(duration.as('m')),
>, <Line: -            hours = round(duration.as('h')),
>, <Line: -            days = round(duration.as('d')),
>, <Line: -            months = round(duration.as('M')),
>, <Line: -            years = round(duration.as('y')),
>, <Line: -            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
>, <Line: -                minutes === 1 && ['m'] ||
>, <Line: -                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
>, <Line: -                hours === 1 && ['h'] ||
>, <Line: -                hours < relativeTimeThresholds.h && ['hh', hours] ||
>, <Line: -                days === 1 && ['d'] ||
>, <Line: -                days < relativeTimeThresholds.d && ['dd', days] ||
>, <Line: -                months === 1 && ['M'] ||
>, <Line: -                months < relativeTimeThresholds.M && ['MM', months] ||
>, <Line: -                years === 1 && ['y'] || ['yy', years];
>, <Line: -        args[2] = withoutSuffix;
>, <Line: -        args[3] = +posNegDuration > 0;
>, <Line: -        args[4] = locale;
>, <Line: -        return substituteTimeAgo.apply({}, args);
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Week of Year
>, <Line: -    ************************************/
>, <Line: -    // firstDayOfWeek       0 = sun, 6 = sat
>, <Line: -    //                      the day of the week that starts the week
>, <Line: -    //                      (usually sunday or monday)
>, <Line: -    // firstDayOfWeekOfYear 0 = sun, 6 = sat
>, <Line: -    //                      the first week is the week that contains the first
>, <Line: -    //                      of this day of the week
>, <Line: -    //                      (eg. ISO weeks use thursday (4))
>, <Line: -    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
>, <Line: -        var end = firstDayOfWeekOfYear - firstDayOfWeek,
>, <Line: -            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
>, <Line: -            adjustedMoment;
>, <Line: -        if (daysToDayOfWeek > end) {
>, <Line: -            daysToDayOfWeek -= 7;
>, <Line: -        }
>, <Line: -        if (daysToDayOfWeek < end - 7) {
>, <Line: -            daysToDayOfWeek += 7;
>, <Line: -        }
>, <Line: -        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
>, <Line: -        return {
>, <Line: -            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
>, <Line: -            year: adjustedMoment.year()
>, <Line: -        };
>, <Line: -    }
>, <Line: -    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
>, <Line: -    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
>, <Line: -        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
>, <Line: -        d = d === 0 ? 7 : d;
>, <Line: -        weekday = weekday != null ? weekday : firstDayOfWeek;
>, <Line: -        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
>, <Line: -        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
>, <Line: -        return {
>, <Line: -            year: dayOfYear > 0 ? year : year - 1,
>, <Line: -            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
>, <Line: -        };
>, <Line: -    }
>, <Line: -    /************************************
>, <Line: -        Top Level Functions
>, <Line: -    ************************************/
>, <Line: -    function makeMoment(config) {
>, <Line: -        var input = config._i,
>, <Line: -            format = config._f;
>, <Line: -        config._locale = config._locale || moment.localeData(config._l);
>, <Line: -        if (input === null || (format === undefined && input === '')) {
>, <Line: -            return moment.invalid({nullInput: true});
>, <Line: -        }
>, <Line: -        if (typeof input === 'string') {
>, <Line: -            config._i = input = config._locale.preparse(input);
>, <Line: -        }
>, <Line: -        if (moment.isMoment(input)) {
>, <Line: -            return new Moment(input, true);
>, <Line: -        } else if (format) {
>, <Line: -            if (isArray(format)) {
>, <Line: -                makeDateFromStringAndArray(config);
>, <Line: -            } else {
>, <Line: -                makeDateFromStringAndFormat(config);
>, <Line: -            }
>, <Line: -        } else {
>, <Line: -            makeDateFromInput(config);
>, <Line: -        }
>, <Line: -        return new Moment(config);
>, <Line: -    }
>, <Line: -    moment = function (input, format, locale, strict) {
>, <Line: -        var c;
>, <Line: -        if (typeof(locale) === "boolean") {
>, <Line: -            strict = locale;
>, <Line: -            locale = undefined;
>, <Line: -        }
>, <Line: -        // object construction must be done this way.
>, <Line: -        // https://github.com/moment/moment/issues/1423
>, <Line: -        c = {};
>, <Line: -        c._isAMomentObject = true;
>, <Line: -        c._i = input;
>, <Line: -        c._f = format;
>, <Line: -        c._l = locale;
>, <Line: -        c._strict = strict;
>, <Line: -        c._isUTC = false;
>, <Line: -        c._pf = defaultParsingFlags();
>, <Line: -        return makeMoment(c);
>, <Line: -    };
>, <Line: -    moment.suppressDeprecationWarnings = false;
>, <Line: -    moment.createFromInputFallback = deprecate(
>, <Line: -        'moment construction falls back to js Date. This is ' +
>, <Line: -        'discouraged and will be removed in upcoming major ' +
>, <Line: -        'release. Please refer to ' +
>, <Line: -        'https://github.com/moment/moment/issues/1407 for more info.',
>, <Line: -        function (config) {
>, <Line: -            config._d = new Date(config._i);
>, <Line: -        }
>, <Line: -    );
>, <Line: -    // Pick a moment m from moments so that m[fn](other) is true for all
>, <Line: -    // other. This relies on the function fn to be transitive.
>, <Line: -    //
>, <Line: -    // moments should either be an array of moment objects or an array, whose
>, <Line: -    // first element is an array of moment objects.
>, <Line: -    function pickBy(fn, moments) {
>, <Line: -        var res, i;
>, <Line: -        if (moments.length === 1 && isArray(moments[0])) {
>, <Line: -            moments = moments[0];
>, <Line: -        }
>, <Line: -        if (!moments.length) {
>, <Line: -            return moment();
>, <Line: -        }
>, <Line: -        res = moments[0];
>, <Line: -        for (i = 1; i < moments.length; ++i) {
>, <Line: -            if (moments[i][fn](res)) {
>, <Line: -                res = moments[i];
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return res;
>, <Line: -    }
>, <Line: -    moment.min = function () {
>, <Line: -        var args = [].slice.call(arguments, 0);
>, <Line: -        return pickBy('isBefore', args);
>, <Line: -    };
>, <Line: -    moment.max = function () {
>, <Line: -        var args = [].slice.call(arguments, 0);
>, <Line: -        return pickBy('isAfter', args);
>, <Line: -    };
>, <Line: -    // creating with utc
>, <Line: -    moment.utc = function (input, format, locale, strict) {
>, <Line: -        var c;
>, <Line: -        if (typeof(locale) === "boolean") {
>, <Line: -            strict = locale;
>, <Line: -            locale = undefined;
>, <Line: -        }
>, <Line: -        // object construction must be done this way.
>, <Line: -        // https://github.com/moment/moment/issues/1423
>, <Line: -        c = {};
>, <Line: -        c._isAMomentObject = true;
>, <Line: -        c._useUTC = true;
>, <Line: -        c._isUTC = true;
>, <Line: -        c._l = locale;
>, <Line: -        c._i = input;
>, <Line: -        c._f = format;
>, <Line: -        c._strict = strict;
>, <Line: -        c._pf = defaultParsingFlags();
>, <Line: -        return makeMoment(c).utc();
>, <Line: -    };
>, <Line: -    // creating with unix timestamp (in seconds)
>, <Line: -    moment.unix = function (input) {
>, <Line: -        return moment(input * 1000);
>, <Line: -    };
>, <Line: -    // duration
>, <Line: -    moment.duration = function (input, key) {
>, <Line: -        var duration = input,
>, <Line: -            // matching against regexp is expensive, do it on demand
>, <Line: -            match = null,
>, <Line: -            sign,
>, <Line: -            ret,
>, <Line: -            parseIso,
>, <Line: -            diffRes;
>, <Line: -        if (moment.isDuration(input)) {
>, <Line: -            duration = {
>, <Line: -                ms: input._milliseconds,
>, <Line: -                d: input._days,
>, <Line: -                M: input._months
>, <Line: -            };
>, <Line: -        } else if (typeof input === 'number') {
>, <Line: -            duration = {};
>, <Line: -            if (key) {
>, <Line: -                duration[key] = input;
>, <Line: -            } else {
>, <Line: -                duration.milliseconds = input;
>, <Line: -            }
>, <Line: -        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
>, <Line: -            sign = (match[1] === '-') ? -1 : 1;
>, <Line: -            duration = {
>, <Line: -                y: 0,
>, <Line: -                d: toInt(match[DATE]) * sign,
>, <Line: -                h: toInt(match[HOUR]) * sign,
>, <Line: -                m: toInt(match[MINUTE]) * sign,
>, <Line: -                s: toInt(match[SECOND]) * sign,
>, <Line: -                ms: toInt(match[MILLISECOND]) * sign
>, <Line: -            };
>, <Line: -        } else if (!!(match = isoDurationRegex.exec(input))) {
>, <Line: -            sign = (match[1] === '-') ? -1 : 1;
>, <Line: -            parseIso = function (inp) {
>, <Line: -                // We'd normally use ~~inp for this, but unfortunately it also
>, <Line: -                // converts floats to ints.
>, <Line: -                // inp may be undefined, so careful calling replace on it.
>, <Line: -                var res = inp && parseFloat(inp.replace(',', '.'));
>, <Line: -                // apply sign while we're at it
>, <Line: -                return (isNaN(res) ? 0 : res) * sign;
>, <Line: -            };
>, <Line: -            duration = {
>, <Line: -                y: parseIso(match[2]),
>, <Line: -                M: parseIso(match[3]),
>, <Line: -                d: parseIso(match[4]),
>, <Line: -                h: parseIso(match[5]),
>, <Line: -                m: parseIso(match[6]),
>, <Line: -                s: parseIso(match[7]),
>, <Line: -                w: parseIso(match[8])
>, <Line: -            };
>, <Line: -        } else if (typeof duration === 'object' &&
>, <Line: -                ('from' in duration || 'to' in duration)) {
>, <Line: -            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
>, <Line: -            duration = {};
>, <Line: -            duration.ms = diffRes.milliseconds;
>, <Line: -            duration.M = diffRes.months;
>, <Line: -        }
>, <Line: -        ret = new Duration(duration);
>, <Line: -        if (moment.isDuration(input) && input.hasOwnProperty('_locale')) {
>, <Line: -            ret._locale = input._locale;
>, <Line: -        }
>, <Line: -        return ret;
>, <Line: -    };
>, <Line: -    // version number
>, <Line: -    moment.version = VERSION;
>, <Line: -    // default format
>, <Line: -    moment.defaultFormat = isoFormat;
>, <Line: -    // constant that refers to the ISO standard
>, <Line: -    moment.ISO_8601 = function () {};
>, <Line: -    // Plugins that add properties should also add the key here (null value),
>, <Line: -    // so we can properly clone ourselves.
>, <Line: -    moment.momentProperties = momentProperties;
>, <Line: -    // This function will be called whenever a moment is mutated.
>, <Line: -    // It is intended to keep the offset in sync with the timezone.
>, <Line: -    moment.updateOffset = function () {};
>, <Line: -    // This function allows you to set a threshold for relative time strings
>, <Line: -    moment.relativeTimeThreshold = function (threshold, limit) {
>, <Line: -        if (relativeTimeThresholds[threshold] === undefined) {
>, <Line: -            return false;
>, <Line: -        }
>, <Line: -        if (limit === undefined) {
>, <Line: -            return relativeTimeThresholds[threshold];
>, <Line: -        }
>, <Line: -        relativeTimeThresholds[threshold] = limit;
>, <Line: -        return true;
>, <Line: -    };
>, <Line: -    moment.lang = deprecate(
>, <Line: -        "moment.lang is deprecated. Use moment.locale instead.",
>, <Line: -        function (key, value) {
>, <Line: -            return moment.locale(key, value);
>, <Line: -        }
>, <Line: -    );
>, <Line: -    // This function will load locale and then set the global locale.  If
>, <Line: -    // no arguments are passed in, it will simply return the current global
>, <Line: -    // locale key.
>, <Line: -    moment.locale = function (key, values) {
>, <Line: -        var data;
>, <Line: -        if (key) {
>, <Line: -            if (typeof(values) !== "undefined") {
>, <Line: -                data = moment.defineLocale(key, values);
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                data = moment.localeData(key);
>, <Line: -            }
>, <Line: -            if (data) {
>, <Line: -                moment.duration._locale = moment._locale = data;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return moment._locale._abbr;
>, <Line: -    };
>, <Line: -    moment.defineLocale = function (name, values) {
>, <Line: -        if (values !== null) {
>, <Line: -            values.abbr = name;
>, <Line: -            if (!locales[name]) {
>, <Line: -                locales[name] = new Locale();
>, <Line: -            }
>, <Line: -            locales[name].set(values);
>, <Line: -            // backwards compat for now: also set the locale
>, <Line: -            moment.locale(name);
>, <Line: -            return locales[name];
>, <Line: -        } else {
>, <Line: -            // useful for testing
>, <Line: -            delete locales[name];
>, <Line: -            return null;
>, <Line: -        }
>, <Line: -    };
>, <Line: -    moment.langData = deprecate(
>, <Line: -        "moment.langData is deprecated. Use moment.localeData instead.",
>, <Line: -        function (key) {
>, <Line: -            return moment.localeData(key);
>, <Line: -        }
>, <Line: -    );
>, <Line: -    // returns locale data
>, <Line: -    moment.localeData = function (key) {
>, <Line: -        var locale;
>, <Line: -        if (key && key._locale && key._locale._abbr) {
>, <Line: -            key = key._locale._abbr;
>, <Line: -        }
>, <Line: -        if (!key) {
>, <Line: -            return moment._locale;
>, <Line: -        }
>, <Line: -        if (!isArray(key)) {
>, <Line: -            //short-circuit everything else
>, <Line: -            locale = loadLocale(key);
>, <Line: -            if (locale) {
>, <Line: -                return locale;
>, <Line: -            }
>, <Line: -            key = [key];
>, <Line: -        }
>, <Line: -        return chooseLocale(key);
>, <Line: -    };
>, <Line: -    // compare moment object
>, <Line: -    moment.isMoment = function (obj) {
>, <Line: -        return obj instanceof Moment ||
>, <Line: -            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
>, <Line: -    };
>, <Line: -    // for typechecking Duration objects
>, <Line: -    moment.isDuration = function (obj) {
>, <Line: -        return obj instanceof Duration;
>, <Line: -    };
>, <Line: -    for (i = lists.length - 1; i >= 0; --i) {
>, <Line: -        makeList(lists[i]);
>, <Line: -    }
>, <Line: -    moment.normalizeUnits = function (units) {
>, <Line: -        return normalizeUnits(units);
>, <Line: -    };
>, <Line: -    moment.invalid = function (flags) {
>, <Line: -        var m = moment.utc(NaN);
>, <Line: -        if (flags != null) {
>, <Line: -            extend(m._pf, flags);
>, <Line: -        }
>, <Line: -        else {
>, <Line: -            m._pf.userInvalidated = true;
>, <Line: -        }
>, <Line: -        return m;
>, <Line: -    };
>, <Line: -    moment.parseZone = function () {
>, <Line: -        return moment.apply(null, arguments).parseZone();
>, <Line: -    };
>, <Line: -    moment.parseTwoDigitYear = function (input) {
>, <Line: -        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
>, <Line: -    };
>, <Line: -    /************************************
>, <Line: -        Moment Prototype
>, <Line: -    ************************************/
>, <Line: -    extend(moment.fn = Moment.prototype, {
>, <Line: -        clone : function () {
>, <Line: -            return moment(this);
>, <Line: -        },
>, <Line: -        valueOf : function () {
>, <Line: -            return +this._d + ((this._offset || 0) * 60000);
>, <Line: -        },
>, <Line: -        unix : function () {
>, <Line: -            return Math.floor(+this / 1000);
>, <Line: -        },
>, <Line: -        toString : function () {
>, <Line: -            return this.clone().locale('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
>, <Line: -        },
>, <Line: -        toDate : function () {
>, <Line: -            return this._offset ? new Date(+this) : this._d;
>, <Line: -        },
>, <Line: -        toISOString : function () {
>, <Line: -            var m = moment(this).utc();
>, <Line: -            if (0 < m.year() && m.year() <= 9999) {
>, <Line: -                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
>, <Line: -            } else {
>, <Line: -                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
>, <Line: -            }
>, <Line: -        },
>, <Line: -        toArray : function () {
>, <Line: -            var m = this;
>, <Line: -            return [
>, <Line: -                m.year(),
>, <Line: -                m.month(),
>, <Line: -                m.date(),
>, <Line: -                m.hours(),
>, <Line: -                m.minutes(),
>, <Line: -                m.seconds(),
>, <Line: -                m.milliseconds()
>, <Line: -            ];
>, <Line: -        },
>, <Line: -        isValid : function () {
>, <Line: -            return isValid(this);
>, <Line: -        },
>, <Line: -        isDSTShifted : function () {
>, <Line: -            if (this._a) {
>, <Line: -                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
>, <Line: -            }
>, <Line: -            return false;
>, <Line: -        },
>, <Line: -        parsingFlags : function () {
>, <Line: -            return extend({}, this._pf);
>, <Line: -        },
>, <Line: -        invalidAt: function () {
>, <Line: -            return this._pf.overflow;
>, <Line: -        },
>, <Line: -        utc : function (keepLocalTime) {
>, <Line: -            return this.zone(0, keepLocalTime);
>, <Line: -        },
>, <Line: -        local : function (keepLocalTime) {
>, <Line: -            if (this._isUTC) {
>, <Line: -                this.zone(0, keepLocalTime);
>, <Line: -                this._isUTC = false;
>, <Line: -                if (keepLocalTime) {
>, <Line: -                    this.add(this._d.getTimezoneOffset(), 'm');
>, <Line: -                }
>, <Line: -            }
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        format : function (inputString) {
>, <Line: -            var output = formatMoment(this, inputString || moment.defaultFormat);
>, <Line: -            return this.localeData().postformat(output);
>, <Line: -        },
>, <Line: -        add : createAdder(1, 'add'),
>, <Line: -        subtract : createAdder(-1, 'subtract'),
>, <Line: -        diff : function (input, units, asFloat) {
>, <Line: -            var that = makeAs(input, this),
>, <Line: -                zoneDiff = (this.zone() - that.zone()) * 6e4,
>, <Line: -                diff, output;
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            if (units === 'year' || units === 'month') {
>, <Line: -                // average number of days in the months in the given dates
>, <Line: -                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
>, <Line: -                // difference in months
>, <Line: -                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
>, <Line: -                // adjust by taking difference in days, average number of days
>, <Line: -                // and dst in the given months.
>, <Line: -                output += ((this - moment(this).startOf('month')) -
>, <Line: -                        (that - moment(that).startOf('month'))) / diff;
>, <Line: -                // same as above but with zones, to negate all dst
>, <Line: -                output -= ((this.zone() - moment(this).startOf('month').zone()) -
>, <Line: -                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
>, <Line: -                if (units === 'year') {
>, <Line: -                    output = output / 12;
>, <Line: -                }
>, <Line: -            } else {
>, <Line: -                diff = (this - that);
>, <Line: -                output = units === 'second' ? diff / 1e3 : // 1000
>, <Line: -                    units === 'minute' ? diff / 6e4 : // 1000 * 60
>, <Line: -                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
>, <Line: -                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
>, <Line: -                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
>, <Line: -                    diff;
>, <Line: -            }
>, <Line: -            return asFloat ? output : absRound(output);
>, <Line: -        },
>, <Line: -        from : function (time, withoutSuffix) {
>, <Line: -            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
>, <Line: -        },
>, <Line: -        fromNow : function (withoutSuffix) {
>, <Line: -            return this.from(moment(), withoutSuffix);
>, <Line: -        },
>, <Line: -        calendar : function (time) {
>, <Line: -            // We want to compare the start of today, vs this.
>, <Line: -            // Getting start-of-today depends on whether we're zone'd or not.
>, <Line: -            var now = time || moment(),
>, <Line: -                sod = makeAs(now, this).startOf('day'),
>, <Line: -                diff = this.diff(sod, 'days', true),
>, <Line: -                format = diff < -6 ? 'sameElse' :
>, <Line: -                    diff < -1 ? 'lastWeek' :
>, <Line: -                    diff < 0 ? 'lastDay' :
>, <Line: -                    diff < 1 ? 'sameDay' :
>, <Line: -                    diff < 2 ? 'nextDay' :
>, <Line: -                    diff < 7 ? 'nextWeek' : 'sameElse';
>, <Line: -            return this.format(this.localeData().calendar(format, this));
>, <Line: -        },
>, <Line: -        isLeapYear : function () {
>, <Line: -            return isLeapYear(this.year());
>, <Line: -        },
>, <Line: -        isDST : function () {
>, <Line: -            return (this.zone() < this.clone().month(0).zone() ||
>, <Line: -                this.zone() < this.clone().month(5).zone());
>, <Line: -        },
>, <Line: -        day : function (input) {
>, <Line: -            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
>, <Line: -            if (input != null) {
>, <Line: -                input = parseWeekday(input, this.localeData());
>, <Line: -                return this.add(input - day, 'd');
>, <Line: -            } else {
>, <Line: -                return day;
>, <Line: -            }
>, <Line: -        },
>, <Line: -        month : makeAccessor('Month', true),
>, <Line: -        startOf : function (units) {
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            // the following switch intentionally omits break keywords
>, <Line: -            // to utilize falling through the cases.
>, <Line: -            switch (units) {
>, <Line: -            case 'year':
>, <Line: -                this.month(0);
>, <Line: -                /* falls through */
>, <Line: -            case 'quarter':
>, <Line: -            case 'month':
>, <Line: -                this.date(1);
>, <Line: -                /* falls through */
>, <Line: -            case 'week':
>, <Line: -            case 'isoWeek':
>, <Line: -            case 'day':
>, <Line: -                this.hours(0);
>, <Line: -                /* falls through */
>, <Line: -            case 'hour':
>, <Line: -                this.minutes(0);
>, <Line: -                /* falls through */
>, <Line: -            case 'minute':
>, <Line: -                this.seconds(0);
>, <Line: -                /* falls through */
>, <Line: -            case 'second':
>, <Line: -                this.milliseconds(0);
>, <Line: -                /* falls through */
>, <Line: -            }
>, <Line: -            // weeks are a special case
>, <Line: -            if (units === 'week') {
>, <Line: -                this.weekday(0);
>, <Line: -            } else if (units === 'isoWeek') {
>, <Line: -                this.isoWeekday(1);
>, <Line: -            }
>, <Line: -            // quarters are also special
>, <Line: -            if (units === 'quarter') {
>, <Line: -                this.month(Math.floor(this.month() / 3) * 3);
>, <Line: -            }
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        endOf: function (units) {
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
>, <Line: -        },
>, <Line: -        isAfter: function (input, units) {
>, <Line: -            units = typeof units !== 'undefined' ? units : 'millisecond';
>, <Line: -            return +this.clone().startOf(units) > +moment(input).startOf(units);
>, <Line: -        },
>, <Line: -        isBefore: function (input, units) {
>, <Line: -            units = typeof units !== 'undefined' ? units : 'millisecond';
>, <Line: -            return +this.clone().startOf(units) < +moment(input).startOf(units);
>, <Line: -        },
>, <Line: -        isSame: function (input, units) {
>, <Line: -            units = units || 'ms';
>, <Line: -            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
>, <Line: -        },
>, <Line: -        min: deprecate(
>, <Line: -                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
>, <Line: -                 function (other) {
>, <Line: -                     other = moment.apply(null, arguments);
>, <Line: -                     return other < this ? this : other;
>, <Line: -                 }
>, <Line: -         ),
>, <Line: -        max: deprecate(
>, <Line: -                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
>, <Line: -                function (other) {
>, <Line: -                    other = moment.apply(null, arguments);
>, <Line: -                    return other > this ? this : other;
>, <Line: -                }
>, <Line: -        ),
>, <Line: -        // keepLocalTime = true means only change the timezone, without
>, <Line: -        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
>, <Line: -        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
>, <Line: -        // +0200, so we adjust the time as needed, to be valid.
>, <Line: -        //
>, <Line: -        // Keeping the time actually adds/subtracts (one hour)
>, <Line: -        // from the actual represented time. That is why we call updateOffset
>, <Line: -        // a second time. In case it wants us to change the offset again
>, <Line: -        // _changeInProgress == true case, then we have to adjust, because
>, <Line: -        // there is no such time in the given timezone.
>, <Line: -        zone : function (input, keepLocalTime) {
>, <Line: -            var offset = this._offset || 0,
>, <Line: -                localAdjust;
>, <Line: -            if (input != null) {
>, <Line: -                if (typeof input === 'string') {
>, <Line: -                    input = timezoneMinutesFromString(input);
>, <Line: -                }
>, <Line: -                if (Math.abs(input) < 16) {
>, <Line: -                    input = input * 60;
>, <Line: -                }
>, <Line: -                if (!this._isUTC && keepLocalTime) {
>, <Line: -                    localAdjust = this._d.getTimezoneOffset();
>, <Line: -                }
>, <Line: -                this._offset = input;
>, <Line: -                this._isUTC = true;
>, <Line: -                if (localAdjust != null) {
>, <Line: -                    this.subtract(localAdjust, 'm');
>, <Line: -                }
>, <Line: -                if (offset !== input) {
>, <Line: -                    if (!keepLocalTime || this._changeInProgress) {
>, <Line: -                        addOrSubtractDurationFromMoment(this,
>, <Line: -                                moment.duration(offset - input, 'm'), 1, false);
>, <Line: -                    } else if (!this._changeInProgress) {
>, <Line: -                        this._changeInProgress = true;
>, <Line: -                        moment.updateOffset(this, true);
>, <Line: -                        this._changeInProgress = null;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            } else {
>, <Line: -                return this._isUTC ? offset : this._d.getTimezoneOffset();
>, <Line: -            }
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        zoneAbbr : function () {
>, <Line: -            return this._isUTC ? 'UTC' : '';
>, <Line: -        },
>, <Line: -        zoneName : function () {
>, <Line: -            return this._isUTC ? 'Coordinated Universal Time' : '';
>, <Line: -        },
>, <Line: -        parseZone : function () {
>, <Line: -            if (this._tzm) {
>, <Line: -                this.zone(this._tzm);
>, <Line: -            } else if (typeof this._i === 'string') {
>, <Line: -                this.zone(this._i);
>, <Line: -            }
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        hasAlignedHourOffset : function (input) {
>, <Line: -            if (!input) {
>, <Line: -                input = 0;
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                input = moment(input).zone();
>, <Line: -            }
>, <Line: -            return (this.zone() - input) % 60 === 0;
>, <Line: -        },
>, <Line: -        daysInMonth : function () {
>, <Line: -            return daysInMonth(this.year(), this.month());
>, <Line: -        },
>, <Line: -        dayOfYear : function (input) {
>, <Line: -            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
>, <Line: -            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
>, <Line: -        },
>, <Line: -        quarter : function (input) {
>, <Line: -            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
>, <Line: -        },
>, <Line: -        weekYear : function (input) {
>, <Line: -            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
>, <Line: -            return input == null ? year : this.add((input - year), 'y');
>, <Line: -        },
>, <Line: -        isoWeekYear : function (input) {
>, <Line: -            var year = weekOfYear(this, 1, 4).year;
>, <Line: -            return input == null ? year : this.add((input - year), 'y');
>, <Line: -        },
>, <Line: -        week : function (input) {
>, <Line: -            var week = this.localeData().week(this);
>, <Line: -            return input == null ? week : this.add((input - week) * 7, 'd');
>, <Line: -        },
>, <Line: -        isoWeek : function (input) {
>, <Line: -            var week = weekOfYear(this, 1, 4).week;
>, <Line: -            return input == null ? week : this.add((input - week) * 7, 'd');
>, <Line: -        },
>, <Line: -        weekday : function (input) {
>, <Line: -            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
>, <Line: -            return input == null ? weekday : this.add(input - weekday, 'd');
>, <Line: -        },
>, <Line: -        isoWeekday : function (input) {
>, <Line: -            // behaves the same as moment#day except
>, <Line: -            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
>, <Line: -            // as a setter, sunday should belong to the previous week.
>, <Line: -            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
>, <Line: -        },
>, <Line: -        isoWeeksInYear : function () {
>, <Line: -            return weeksInYear(this.year(), 1, 4);
>, <Line: -        },
>, <Line: -        weeksInYear : function () {
>, <Line: -            var weekInfo = this.localeData()._week;
>, <Line: -            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
>, <Line: -        },
>, <Line: -        get : function (units) {
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            return this[units]();
>, <Line: -        },
>, <Line: -        set : function (units, value) {
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            if (typeof this[units] === 'function') {
>, <Line: -                this[units](value);
>, <Line: -            }
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        // If passed a locale key, it will set the locale for this
>, <Line: -        // instance.  Otherwise, it will return the locale configuration
>, <Line: -        // variables for this instance.
>, <Line: -        locale : function (key) {
>, <Line: -            if (key === undefined) {
>, <Line: -                return this._locale._abbr;
>, <Line: -            } else {
>, <Line: -                this._locale = moment.localeData(key);
>, <Line: -                return this;
>, <Line: -            }
>, <Line: -        },
>, <Line: -        lang : deprecate(
>, <Line: -            "moment().lang() is deprecated. Use moment().localeData() instead.",
>, <Line: -            function (key) {
>, <Line: -                if (key === undefined) {
>, <Line: -                    return this.localeData();
>, <Line: -                } else {
>, <Line: -                    this._locale = moment.localeData(key);
>, <Line: -                    return this;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        ),
>, <Line: -        localeData : function () {
>, <Line: -            return this._locale;
>, <Line: -        }
>, <Line: -    });
>, <Line: -    function rawMonthSetter(mom, value) {
>, <Line: -        var dayOfMonth;
>, <Line: -        // TODO: Move this out of here!
>, <Line: -        if (typeof value === 'string') {
>, <Line: -            value = mom.localeData().monthsParse(value);
>, <Line: -            // TODO: Another silent failure?
>, <Line: -            if (typeof value !== 'number') {
>, <Line: -                return mom;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        dayOfMonth = Math.min(mom.date(),
>, <Line: -                daysInMonth(mom.year(), value));
>, <Line: -        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
>, <Line: -        return mom;
>, <Line: -    }
>, <Line: -    function rawGetter(mom, unit) {
>, <Line: -        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
>, <Line: -    }
>, <Line: -    function rawSetter(mom, unit, value) {
>, <Line: -        if (unit === 'Month') {
>, <Line: -            return rawMonthSetter(mom, value);
>, <Line: -        } else {
>, <Line: -            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function makeAccessor(unit, keepTime) {
>, <Line: -        return function (value) {
>, <Line: -            if (value != null) {
>, <Line: -                rawSetter(this, unit, value);
>, <Line: -                moment.updateOffset(this, keepTime);
>, <Line: -                return this;
>, <Line: -            } else {
>, <Line: -                return rawGetter(this, unit);
>, <Line: -            }
>, <Line: -        };
>, <Line: -    }
>, <Line: -    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
>, <Line: -    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
>, <Line: -    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
>, <Line: -    // Setting the hour should keep the time, because the user explicitly
>, <Line: -    // specified which hour he wants. So trying to maintain the same hour (in
>, <Line: -    // a new timezone) makes sense. Adding/subtracting hours does not follow
>, <Line: -    // this rule.
>, <Line: -    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
>, <Line: -    // moment.fn.month is defined separately
>, <Line: -    moment.fn.date = makeAccessor('Date', true);
>, <Line: -    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
>, <Line: -    moment.fn.year = makeAccessor('FullYear', true);
>, <Line: -    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));
>, <Line: -    // add plural methods
>, <Line: -    moment.fn.days = moment.fn.day;
>, <Line: -    moment.fn.months = moment.fn.month;
>, <Line: -    moment.fn.weeks = moment.fn.week;
>, <Line: -    moment.fn.isoWeeks = moment.fn.isoWeek;
>, <Line: -    moment.fn.quarters = moment.fn.quarter;
>, <Line: -    // add aliased format methods
>, <Line: -    moment.fn.toJSON = moment.fn.toISOString;
>, <Line: -    /************************************
>, <Line: -        Duration Prototype
>, <Line: -    ************************************/
>, <Line: -    function daysToYears (days) {
>, <Line: -        // 400 years have 146097 days (taking into account leap year rules)
>, <Line: -        return days * 400 / 146097;
>, <Line: -    }
>, <Line: -    function yearsToDays (years) {
>, <Line: -        // years * 365 + absRound(years / 4) -
>, <Line: -        //     absRound(years / 100) + absRound(years / 400);
>, <Line: -        return years * 146097 / 400;
>, <Line: -    }
>, <Line: -    extend(moment.duration.fn = Duration.prototype, {
>, <Line: -        _bubble : function () {
>, <Line: -            var milliseconds = this._milliseconds,
>, <Line: -                days = this._days,
>, <Line: -                months = this._months,
>, <Line: -                data = this._data,
>, <Line: -                seconds, minutes, hours, years = 0;
>, <Line: -            // The following code bubbles up values, see the tests for
>, <Line: -            // examples of what that means.
>, <Line: -            data.milliseconds = milliseconds % 1000;
>, <Line: -            seconds = absRound(milliseconds / 1000);
>, <Line: -            data.seconds = seconds % 60;
>, <Line: -            minutes = absRound(seconds / 60);
>, <Line: -            data.minutes = minutes % 60;
>, <Line: -            hours = absRound(minutes / 60);
>, <Line: -            data.hours = hours % 24;
>, <Line: -            days += absRound(hours / 24);
>, <Line: -            // Accurately convert days to years, assume start from year 0.
>, <Line: -            years = absRound(daysToYears(days));
>, <Line: -            days -= absRound(yearsToDays(years));
>, <Line: -            // 30 days to a month
>, <Line: -            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
>, <Line: -            months += absRound(days / 30);
>, <Line: -            days %= 30;
>, <Line: -            // 12 months -> 1 year
>, <Line: -            years += absRound(months / 12);
>, <Line: -            months %= 12;
>, <Line: -            data.days = days;
>, <Line: -            data.months = months;
>, <Line: -            data.years = years;
>, <Line: -        },
>, <Line: -        abs : function () {
>, <Line: -            this._milliseconds = Math.abs(this._milliseconds);
>, <Line: -            this._days = Math.abs(this._days);
>, <Line: -            this._months = Math.abs(this._months);
>, <Line: -            this._data.milliseconds = Math.abs(this._data.milliseconds);
>, <Line: -            this._data.seconds = Math.abs(this._data.seconds);
>, <Line: -            this._data.minutes = Math.abs(this._data.minutes);
>, <Line: -            this._data.hours = Math.abs(this._data.hours);
>, <Line: -            this._data.months = Math.abs(this._data.months);
>, <Line: -            this._data.years = Math.abs(this._data.years);
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        weeks : function () {
>, <Line: -            return absRound(this.days() / 7);
>, <Line: -        },
>, <Line: -        valueOf : function () {
>, <Line: -            return this._milliseconds +
>, <Line: -              this._days * 864e5 +
>, <Line: -              (this._months % 12) * 2592e6 +
>, <Line: -              toInt(this._months / 12) * 31536e6;
>, <Line: -        },
>, <Line: -        humanize : function (withSuffix) {
>, <Line: -            var output = relativeTime(this, !withSuffix, this.localeData());
>, <Line: -            if (withSuffix) {
>, <Line: -                output = this.localeData().pastFuture(+this, output);
>, <Line: -            }
>, <Line: -            return this.localeData().postformat(output);
>, <Line: -        },
>, <Line: -        add : function (input, val) {
>, <Line: -            // supports only 2.0-style add(1, 's') or add(moment)
>, <Line: -            var dur = moment.duration(input, val);
>, <Line: -            this._milliseconds += dur._milliseconds;
>, <Line: -            this._days += dur._days;
>, <Line: -            this._months += dur._months;
>, <Line: -            this._bubble();
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        subtract : function (input, val) {
>, <Line: -            var dur = moment.duration(input, val);
>, <Line: -            this._milliseconds -= dur._milliseconds;
>, <Line: -            this._days -= dur._days;
>, <Line: -            this._months -= dur._months;
>, <Line: -            this._bubble();
>, <Line: -            return this;
>, <Line: -        },
>, <Line: -        get : function (units) {
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            return this[units.toLowerCase() + 's']();
>, <Line: -        },
>, <Line: -        as : function (units) {
>, <Line: -            var days, months;
>, <Line: -            units = normalizeUnits(units);
>, <Line: -            days = this._days + this._milliseconds / 864e5;
>, <Line: -            if (units === 'month' || units === 'year') {
>, <Line: -                months = this._months + daysToYears(days) * 12;
>, <Line: -                return units === 'month' ? months : months / 12;
>, <Line: -            } else {
>, <Line: -                days += yearsToDays(this._months / 12);
>, <Line: -                switch (units) {
>, <Line: -                    case 'week': return days / 7;
>, <Line: -                    case 'day': return days;
>, <Line: -                    case 'hour': return days * 24;
>, <Line: -                    case 'minute': return days * 24 * 60;
>, <Line: -                    case 'second': return days * 24 * 60 * 60;
>, <Line: -                    case 'millisecond': return days * 24 * 60 * 60 * 1000;
>, <Line: -                    default: throw new Error('Unknown unit ' + units);
>, <Line: -                }
>, <Line: -            }
>, <Line: -        },
>, <Line: -        lang : moment.fn.lang,
>, <Line: -        locale : moment.fn.locale,
>, <Line: -        toIsoString : deprecate(
>, <Line: -            "toIsoString() is deprecated. Please use toISOString() instead " +
>, <Line: -            "(notice the capitals)",
>, <Line: -            function () {
>, <Line: -                return this.toISOString();
>, <Line: -            }
>, <Line: -        ),
>, <Line: -        toISOString : function () {
>, <Line: -            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
>, <Line: -            var years = Math.abs(this.years()),
>, <Line: -                months = Math.abs(this.months()),
>, <Line: -                days = Math.abs(this.days()),
>, <Line: -                hours = Math.abs(this.hours()),
>, <Line: -                minutes = Math.abs(this.minutes()),
>, <Line: -                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
>, <Line: -            if (!this.asSeconds()) {
>, <Line: -                // this is the same as C#'s (Noda) and python (isodate)...
>, <Line: -                // but not other JS (goog.date)
>, <Line: -                return 'P0D';
>, <Line: -            }
>, <Line: -            return (this.asSeconds() < 0 ? '-' : '') +
>, <Line: -                'P' +
>, <Line: -                (years ? years + 'Y' : '') +
>, <Line: -                (months ? months + 'M' : '') +
>, <Line: -                (days ? days + 'D' : '') +
>, <Line: -                ((hours || minutes || seconds) ? 'T' : '') +
>, <Line: -                (hours ? hours + 'H' : '') +
>, <Line: -                (minutes ? minutes + 'M' : '') +
>, <Line: -                (seconds ? seconds + 'S' : '');
>, <Line: -        },
>, <Line: -        localeData : function () {
>, <Line: -            return this._locale;
>, <Line: -        }
>, <Line: -    });
>, <Line: -    function makeDurationGetter(name) {
>, <Line: -        moment.duration.fn[name] = function () {
>, <Line: -            return this._data[name];
>, <Line: -        };
>, <Line: -    }
>, <Line: -    for (i in unitMillisecondFactors) {
>, <Line: -        if (unitMillisecondFactors.hasOwnProperty(i)) {
>, <Line: -            makeDurationGetter(i.toLowerCase());
>, <Line: -        }
>, <Line: -    }
>, <Line: -    moment.duration.fn.asMilliseconds = function () {
>, <Line: -        return this.as('ms');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asSeconds = function () {
>, <Line: -        return this.as('s');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asMinutes = function () {
>, <Line: -        return this.as('m');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asHours = function () {
>, <Line: -        return this.as('h');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asDays = function () {
>, <Line: -        return this.as('d');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asWeeks = function () {
>, <Line: -        return this.as('weeks');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asMonths = function () {
>, <Line: -        return this.as('M');
>, <Line: -    };
>, <Line: -    moment.duration.fn.asYears = function () {
>, <Line: -        return this.as('y');
>, <Line: -    };
>, <Line: -    /************************************
>, <Line: -        Default Locale
>, <Line: -    ************************************/
>, <Line: -    // Set default locale, other locale will inherit from English.
>, <Line: -    moment.locale('en', {
>, <Line: -        ordinal : function (number) {
>, <Line: -            var b = number % 10,
>, <Line: -                output = (toInt(number % 100 / 10) === 1) ? 'th' :
>, <Line: -                (b === 1) ? 'st' :
>, <Line: -                (b === 2) ? 'nd' :
>, <Line: -                (b === 3) ? 'rd' : 'th';
>, <Line: -            return number + output;
>, <Line: -        }
>, <Line: -    });
>, <Line: -    /* EMBED_LOCALES */
>, <Line: -    /************************************
>, <Line: -        Exposing Moment
>, <Line: -    ************************************/
>, <Line: -    function makeGlobal(shouldDeprecate) {
>, <Line: -        /*global ender:false */
>, <Line: -        if (typeof ender !== 'undefined') {
>, <Line: -            return;
>, <Line: -        }
>, <Line: -        oldGlobalMoment = globalScope.moment;
>, <Line: -        if (shouldDeprecate) {
>, <Line: -            globalScope.moment = deprecate(
>, <Line: -                    'Accessing Moment through the global scope is ' +
>, <Line: -                    'deprecated, and will be removed in an upcoming ' +
>, <Line: -                    'release.',
>, <Line: -                    moment);
>, <Line: -        } else {
>, <Line: -            globalScope.moment = moment;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    // CommonJS module is defined
>, <Line: -    if (hasModule) {
>, <Line: -        module.exports = moment;
>, <Line: -    } else if (typeof define === 'function' && define.amd) {
>, <Line: -        define('moment', function (require, exports, module) {
>, <Line: -            if (module.config && module.config() && module.config().noGlobal === true) {
>, <Line: -                // release the global variable
>, <Line: -                globalScope.moment = oldGlobalMoment;
>, <Line: -            }
>, <Line: -            return moment;
>, <Line: -        });
>, <Line: -        makeGlobal(true);
>, <Line: -    } else {
>, <Line: -        makeGlobal();
>, <Line: -    }
>]