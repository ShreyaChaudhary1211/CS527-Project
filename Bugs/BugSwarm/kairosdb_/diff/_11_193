[<Line: +		'angular',
>, <Line: +		'jquery',
>, <Line: +		'kbn',
>, <Line: +		'moment',
>, <Line: +		'lodash',
>, <Line: +		'./graph.tooltip',
>, <Line: +		'jquery.flot',
>, <Line: +		'jquery.flot.events',
>, <Line: +		'jquery.flot.selection',
>, <Line: +		'jquery.flot.time',
>, <Line: +		'jquery.flot.stack',
>, <Line: +		'jquery.flot.stackpercent',
>, <Line: +		'jquery.flot.fillbelow',
>, <Line: +		'jquery.flot.crosshair'
>, <Line: +	],
>, <Line: +	function (angular, $, kbn, moment, _, GraphTooltip) {
>, <Line: +		'use strict';
>, <Line: +		var module = angular.module('grafana.directives');
>, <Line: +		module.directive('grafanaGraph', function ($rootScope, timeSrv) {
>, <Line: +			return {
>, <Line: +				restrict: 'A',
>, <Line: +				template: '<div> </div>',
>, <Line: +				link: function (scope, elem) {
>, <Line: +					var dashboard = scope.dashboard;
>, <Line: +					var data, annotations;
>, <Line: +					var sortedSeries;
>, <Line: +					var legendSideLastValue = null;
>, <Line: +					scope.crosshairEmiter = false;
>, <Line: +					scope.onAppEvent('setCrosshair', function (event, info) {
>, <Line: +						// do not need to to this if event is from this panel
>, <Line: +						if (info.scope === scope) {
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						if (dashboard.sharedCrosshair) {
>, <Line: +							var plot = elem.data().plot;
>, <Line: +							if (plot) {
>, <Line: +								plot.setCrosshair({
>, <Line: +									x: info.pos.x,
>, <Line: +									y: info.pos.y
>, <Line: +								});
>, <Line: +							}
>, <Line: +						}
>, <Line: +					});
>, <Line: +					scope.onAppEvent('clearCrosshair', function () {
>, <Line: +						var plot = elem.data().plot;
>, <Line: +						if (plot) {
>, <Line: +							plot.clearCrosshair();
>, <Line: +						}
>, <Line: +					});
>, <Line: +					scope.$on('refresh', function () {
>, <Line: +						scope.get_data();
>, <Line: +					});
>, <Line: +					// Receive render events
>, <Line: +					scope.$on('render', function (event, renderData) {
>, <Line: +						data = renderData || data;
>, <Line: +						if (!data) {
>, <Line: +							scope.get_data();
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						annotations = data.annotations || annotations;
>, <Line: +						render_panel();
>, <Line: +					});
>, <Line: +					function setElementHeight() {
>, <Line: +						try {
>, <Line: +							var height = scope.height || scope.panel.height || scope.row.height;
>, <Line: +							if (_.isString(height)) {
>, <Line: +								height = parseInt(height.replace('px', ''), 10);
>, <Line: +							}
>, <Line: +							height -= 5; // padding
>, <Line: +							height -= scope.panel.title ? 24 : 9; // subtract panel title bar
>, <Line: +							if (scope.panel.legend.show && !scope.panel.legend.rightSide) {
>, <Line: +								height = height - 26; // subtract one line legend
>, <Line: +							}
>, <Line: +							elem.css('height', height + 'px');
>, <Line: +							return true;
>, <Line: +						} catch (e) { // IE throws errors sometimes
>, <Line: +							return false;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function shouldAbortRender() {
>, <Line: +						if (!data) {
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						if ($rootScope.fullscreen && !scope.fullscreen) {
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						if (!setElementHeight()) {
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						if (_.isString(data)) {
>, <Line: +							render_panel_as_graphite_png(data);
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						if (elem.width() === 0) {
>, <Line: +							return;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function updateLegendValues(plot) {
>, <Line: +						var yaxis = plot.getYAxes();
>, <Line: +						for (var i = 0; i < data.length; i++) {
>, <Line: +							var series = data[i];
>, <Line: +							var axis = yaxis[series.yaxis - 1];
>, <Line: +							var formater = kbn.valueFormats[scope.panel.y_formats[series.yaxis - 1]];
>, <Line: +							// legend and tooltip gets one more decimal precision
>, <Line: +							// than graph legend ticks
>, <Line: +							var tickDecimals = (axis.tickDecimals || -1) + 1;
>, <Line: +							series.updateLegendValues(formater, tickDecimals, axis.scaledDecimals + 2);
>, <Line: +							if (!scope.$$phase) {
>, <Line: +								scope.$digest();
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					// Function for rendering panel
>, <Line: +					function render_panel() {
>, <Line: +						if (shouldAbortRender()) {
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						var panel = scope.panel;
>, <Line: +						var stack = panel.stack ? true : null;
>, <Line: +						// Populate element
>, <Line: +						var options = {
>, <Line: +							hooks: {draw: [updateLegendValues]},
>, <Line: +							legend: {show: false},
>, <Line: +							series: {
>, <Line: +								stackpercent: panel.stack ? panel.percentage : false,
>, <Line: +								stack: panel.percentage ? null : stack,
>, <Line: +								lines: {
>, <Line: +									show: panel.lines,
>, <Line: +									zero: false,
>, <Line: +									fill: translateFillOption(panel.fill),
>, <Line: +									lineWidth: panel.linewidth,
>, <Line: +									steps: panel.steppedLine
>, <Line: +								},
>, <Line: +								bars: {
>, <Line: +									show: panel.bars,
>, <Line: +									fill: 1,
>, <Line: +									barWidth: 1,
>, <Line: +									zero: false,
>, <Line: +									lineWidth: 0
>, <Line: +								},
>, <Line: +								points: {
>, <Line: +									show: panel.points,
>, <Line: +									fill: 1,
>, <Line: +									fillColor: false,
>, <Line: +									radius: panel.points ? panel.pointradius : 2
>, <Line: +									// little points when highlight points
>, <Line: +								},
>, <Line: +								shadowSize: 1
>, <Line: +							},
>, <Line: +							yaxes: [],
>, <Line: +							xaxis: {},
>, <Line: +							grid: {
>, <Line: +								minBorderMargin: 0,
>, <Line: +								markings: [],
>, <Line: +								backgroundColor: null,
>, <Line: +								borderWidth: 0,
>, <Line: +								hoverable: true,
>, <Line: +								color: '#c8c8c8'
>, <Line: +							},
>, <Line: +							selection: {
>, <Line: +								mode: "x",
>, <Line: +								color: '#666'
>, <Line: +							},
>, <Line: +							crosshair: {
>, <Line: +								mode: panel.tooltip.shared || dashboard.sharedCrosshair ? "x" : null
>, <Line: +							}
>, <Line: +						};
>, <Line: +						for (var i = 0; i < data.length; i++) {
>, <Line: +							var series = data[i];
>, <Line: +							series.applySeriesOverrides(panel.seriesOverrides);
>, <Line: +							series.data = series.getFlotPairs(panel.nullPointMode, panel.y_formats);
>, <Line: +							// if hidden remove points and disable stack
>, <Line: +							if (scope.hiddenSeries[series.alias]) {
>, <Line: +								series.data = [];
>, <Line: +								series.stack = false;
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (data.length && data[0].stats.timeStep) {
>, <Line: +							options.series.bars.barWidth = data[0].stats.timeStep / 1.5;
>, <Line: +						}
>, <Line: +						addTimeAxis(options);
>, <Line: +						addGridThresholds(options, panel);
>, <Line: +						addAnnotations(options);
>, <Line: +						configureAxisOptions(data, options);
>, <Line: +						sortedSeries = _.sortBy(data, function (series) {
>, <Line: +							return series.zindex;
>, <Line: +						});
>, <Line: +						function callPlot() {
>, <Line: +							try {
>, <Line: +								$.plot(elem, sortedSeries, options);
>, <Line: +							} catch (e) {
>, <Line: +								console.log('flotcharts error', e);
>, <Line: +							}
>, <Line: +							addAxisLabels();
>, <Line: +						}
>, <Line: +						if (shouldDelayDraw(panel)) {
>, <Line: +							// temp fix for legends on the side, need to render twice to get dimensions right
>, <Line: +							callPlot();
>, <Line: +							setTimeout(callPlot, 50);
>, <Line: +							legendSideLastValue = panel.legend.rightSide;
>, <Line: +						}
>, <Line: +						else {
>, <Line: +							callPlot();
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function translateFillOption(fill) {
>, <Line: +						return fill === 0 ? 0.001 : fill / 10;
>, <Line: +					}
>, <Line: +					function shouldDelayDraw(panel) {
>, <Line: +						if (panel.legend.rightSide) {
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						if (legendSideLastValue !== null && panel.legend.rightSide !== legendSideLastValue) {
>, <Line: +							return true;
>, <Line: +						}
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +					function addTimeAxis(options) {
>, <Line: +						var ticks = elem.width() / 100;
>, <Line: +						var min = _.isUndefined(scope.range.from) ? null : scope.range.from.getTime();
>, <Line: +						var max = _.isUndefined(scope.range.to) ? null : scope.range.to.getTime();
>, <Line: +						options.xaxis = {
>, <Line: +							timezone: dashboard.timezone,
>, <Line: +							show: scope.panel['x-axis'],
>, <Line: +							mode: "time",
>, <Line: +							min: min,
>, <Line: +							max: max,
>, <Line: +							label: "Datetime",
>, <Line: +							ticks: ticks,
>, <Line: +							timeformat: time_format(scope.interval, ticks, min, max),
>, <Line: +						};
>, <Line: +					}
>, <Line: +					function addGridThresholds(options, panel) {
>, <Line: +						if (panel.grid.threshold1) {
>, <Line: +							var limit1 = panel.grid.thresholdLine ? panel.grid.threshold1 : (panel.grid.threshold2 || null);
>, <Line: +							options.grid.markings.push({
>, <Line: +								yaxis: {
>, <Line: +									from: panel.grid.threshold1,
>, <Line: +									to: limit1
>, <Line: +								},
>, <Line: +								color: panel.grid.threshold1Color
>, <Line: +							});
>, <Line: +							if (panel.grid.threshold2) {
>, <Line: +								var limit2;
>, <Line: +								if (panel.grid.thresholdLine) {
>, <Line: +									limit2 = panel.grid.threshold2;
>, <Line: +								} else {
>, <Line: +									limit2 = panel.grid.threshold1 > panel.grid.threshold2 ? -Infinity : +Infinity;
>, <Line: +								}
>, <Line: +								options.grid.markings.push({
>, <Line: +									yaxis: {
>, <Line: +										from: panel.grid.threshold2,
>, <Line: +										to: limit2
>, <Line: +									},
>, <Line: +									color: panel.grid.threshold2Color
>, <Line: +								});
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function addAnnotations(options) {
>, <Line: +						if (!annotations || annotations.length === 0) {
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						var types = {};
>, <Line: +						_.each(annotations, function (event) {
>, <Line: +							if (!types[event.annotation.name]) {
>, <Line: +								types[event.annotation.name] = {
>, <Line: +									level: _.keys(types).length + 1,
>, <Line: +									icon: {
>, <Line: +										icon: "icon-chevron-down",
>, <Line: +										size: event.annotation.iconSize,
>, <Line: +										color: event.annotation.iconColor,
>, <Line: +									}
>, <Line: +								};
>, <Line: +							}
>, <Line: +							if (event.annotation.showLine) {
>, <Line: +								options.grid.markings.push({
>, <Line: +									color: event.annotation.lineColor,
>, <Line: +									lineWidth: 1,
>, <Line: +									xaxis: {from: event.min, to: event.max}
>, <Line: +								});
>, <Line: +							}
>, <Line: +						});
>, <Line: +						options.events = {
>, <Line: +							levels: _.keys(types).length + 1,
>, <Line: +							data: annotations,
>, <Line: +							types: types
>, <Line: +						};
>, <Line: +					}
>, <Line: +					function addAxisLabels() {
>, <Line: +						if (scope.panel.leftYAxisLabel) {
>, <Line: +							elem.css('margin-left', '10px');
>, <Line: +							var yaxisLabel = $("<div class='axisLabel yaxisLabel'></div>")
>, <Line: +								.text(scope.panel.leftYAxisLabel)
>, <Line: +								.appendTo(elem);
>, <Line: +							yaxisLabel.css("margin-top", yaxisLabel.width() / 2 - 20);
>, <Line: +						} else if (elem.css('margin-left')) {
>, <Line: +							elem.css('margin-left', '');
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function configureAxisOptions(data, options) {
>, <Line: +						var defaults = {
>, <Line: +							position: 'left',
>, <Line: +							show: scope.panel['y-axis'],
>, <Line: +							min: scope.panel.grid.leftMin,
>, <Line: +							max: scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.leftMax,
>, <Line: +						};
>, <Line: +						options.yaxes.push(defaults);
>, <Line: +						if (_.findWhere(data, {yaxis: 2})) {
>, <Line: +							var secondY = _.clone(defaults);
>, <Line: +							secondY.position = 'right';
>, <Line: +							secondY.min = scope.panel.grid.rightMin;
>, <Line: +							secondY.max = scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.rightMax;
>, <Line: +							options.yaxes.push(secondY);
>, <Line: +							configureAxisMode(options.yaxes[1], scope.panel.y_formats[1]);
>, <Line: +						}
>, <Line: +						configureAxisMode(options.yaxes[0], scope.panel.y_formats[0]);
>, <Line: +					}
>, <Line: +					function configureAxisMode(axis, format) {
>, <Line: +						axis.tickFormatter = function (val, axis) {
>, <Line: +							return kbn.valueFormats[format](val, axis.tickDecimals, axis.scaledDecimals);
>, <Line: +						};
>, <Line: +					}
>, <Line: +					function time_format(interval, ticks, min, max) {
>, <Line: +						if (min && max && ticks) {
>, <Line: +							var secPerTick = ((max - min) / ticks) / 1000;
>, <Line: +							if (secPerTick <= 45) {
>, <Line: +								return "%H:%M:%S";
>, <Line: +							}
>, <Line: +							if (secPerTick <= 3600) {
>, <Line: +								return "%H:%M";
>, <Line: +							}
>, <Line: +							if (secPerTick <= 80000) {
>, <Line: +								return "%m/%d %H:%M";
>, <Line: +							}
>, <Line: +							if (secPerTick <= 2419200) {
>, <Line: +								return "%m/%d";
>, <Line: +							}
>, <Line: +							return "%Y-%m";
>, <Line: +						}
>, <Line: +						return "%H:%M";
>, <Line: +					}
>, <Line: +					function render_panel_as_graphite_png(url) {
>, <Line: +						url += '&width=' + elem.width();
>, <Line: +						url += '&height=' + elem.css('height').replace('px', '');
>, <Line: +						url += '&bgcolor=1f1f1f'; // @grayDarker & @grafanaPanelBackground
>, <Line: +						url += '&fgcolor=BBBFC2'; // @textColor & @grayLighter
>, <Line: +						url += scope.panel.stack ? '&areaMode=stacked' : '';
>, <Line: +						url += scope.panel.fill !== 0 ? ('&areaAlpha=' + (scope.panel.fill / 10).toFixed(1)) : '';
>, <Line: +						url += scope.panel.linewidth !== 0 ? '&lineWidth=' + scope.panel.linewidth : '';
>, <Line: +						url += scope.panel.legend.show ? '&hideLegend=false' : '&hideLegend=true';
>, <Line: +						url += scope.panel.grid.leftMin !== null ? '&yMin=' + scope.panel.grid.leftMin : '';
>, <Line: +						url += scope.panel.grid.leftMax !== null ? '&yMax=' + scope.panel.grid.leftMax : '';
>, <Line: +						url += scope.panel.grid.rightMin !== null ? '&yMin=' + scope.panel.grid.rightMin : '';
>, <Line: +						url += scope.panel.grid.rightMax !== null ? '&yMax=' + scope.panel.grid.rightMax : '';
>, <Line: +						url += scope.panel['x-axis'] ? '' : '&hideAxes=true';
>, <Line: +						url += scope.panel['y-axis'] ? '' : '&hideYAxis=true';
>, <Line: +						switch (scope.panel.y_formats[0]) {
>, <Line: +							case 'bytes':
>, <Line: +								url += '&yUnitSystem=binary';
>, <Line: +								break;
>, <Line: +							case 'bits':
>, <Line: +								url += '&yUnitSystem=binary';
>, <Line: +								break;
>, <Line: +							case 'bps':
>, <Line: +								url += '&yUnitSystem=si';
>, <Line: +								break;
>, <Line: +							case 'short':
>, <Line: +								url += '&yUnitSystem=si';
>, <Line: +								break;
>, <Line: +							case 'none':
>, <Line: +								url += '&yUnitSystem=none';
>, <Line: +								break;
>, <Line: +						}
>, <Line: +						switch (scope.panel.nullPointMode) {
>, <Line: +							case 'connected':
>, <Line: +								url += '&lineMode=connected';
>, <Line: +								break;
>, <Line: +							case 'null':
>, <Line: +								break; // graphite default lineMode
>, <Line: +							case 'null as zero':
>, <Line: +								url += "&drawNullAsZero=true";
>, <Line: +								break;
>, <Line: +						}
>, <Line: +						url += scope.panel.steppedLine ? '&lineMode=staircase' : '';
>, <Line: +						elem.html('<img src="' + url + '"></img>');
>, <Line: +					}
>, <Line: +					new GraphTooltip(elem, dashboard, scope, function () {
>, <Line: +						return sortedSeries;
>, <Line: +					});
>, <Line: +					elem.bind("plotselected", function (event, ranges) {
>, <Line: +						scope.$apply(function () {
>, <Line: +							timeSrv.setTime({
>, <Line: +								from: moment.utc(ranges.xaxis.from).toDate(),
>, <Line: +								to: moment.utc(ranges.xaxis.to).toDate(),
>, <Line: +							});
>, <Line: +						});
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +		});
>, <Line: +	});
>]
[<Line: -  'angular',
>, <Line: -  'jquery',
>, <Line: -  'kbn',
>, <Line: -  'moment',
>, <Line: -  'lodash',
>, <Line: -  './graph.tooltip',
>, <Line: -  'jquery.flot',
>, <Line: -  'jquery.flot.events',
>, <Line: -  'jquery.flot.selection',
>, <Line: -  'jquery.flot.time',
>, <Line: -  'jquery.flot.stack',
>, <Line: -  'jquery.flot.stackpercent',
>, <Line: -  'jquery.flot.fillbelow',
>, <Line: -  'jquery.flot.crosshair'
>, <Line: -],
>, <Line: -function (angular, $, kbn, moment, _, GraphTooltip) {
>, <Line: -  'use strict';
>, <Line: -  var module = angular.module('grafana.directives');
>, <Line: -  module.directive('grafanaGraph', function($rootScope, timeSrv) {
>, <Line: -    return {
>, <Line: -      restrict: 'A',
>, <Line: -      template: '<div> </div>',
>, <Line: -      link: function(scope, elem) {
>, <Line: -        var dashboard = scope.dashboard;
>, <Line: -        var data, annotations;
>, <Line: -        var sortedSeries;
>, <Line: -        var legendSideLastValue = null;
>, <Line: -        scope.crosshairEmiter = false;
>, <Line: -        scope.onAppEvent('setCrosshair', function(event, info) {
>, <Line: -          // do not need to to this if event is from this panel
>, <Line: -          if (info.scope === scope) {
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          if(dashboard.sharedCrosshair) {
>, <Line: -            var plot = elem.data().plot;
>, <Line: -            if (plot) {
>, <Line: -              plot.setCrosshair({ x: info.pos.x, y: info.pos.y });
>, <Line: -            }
>, <Line: -          }
>, <Line: -        });
>, <Line: -        scope.onAppEvent('clearCrosshair', function() {
>, <Line: -          var plot = elem.data().plot;
>, <Line: -          if (plot) {
>, <Line: -            plot.clearCrosshair();
>, <Line: -          }
>, <Line: -        });
>, <Line: -        scope.$on('refresh', function() {
>, <Line: -          scope.get_data();
>, <Line: -        });
>, <Line: -        // Receive render events
>, <Line: -        scope.$on('render',function(event, renderData) {
>, <Line: -          data = renderData || data;
>, <Line: -          if (!data) {
>, <Line: -            scope.get_data();
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          annotations = data.annotations || annotations;
>, <Line: -          render_panel();
>, <Line: -        });
>, <Line: -        function setElementHeight() {
>, <Line: -          try {
>, <Line: -            var height = scope.height || scope.panel.height || scope.row.height;
>, <Line: -            if (_.isString(height)) {
>, <Line: -              height = parseInt(height.replace('px', ''), 10);
>, <Line: -            }
>, <Line: -            height -= 5; // padding
>, <Line: -            height -= scope.panel.title ? 24 : 9; // subtract panel title bar
>, <Line: -            if (scope.panel.legend.show && !scope.panel.legend.rightSide) {
>, <Line: -              height = height - 26; // subtract one line legend
>, <Line: -            }
>, <Line: -            elem.css('height', height + 'px');
>, <Line: -            return true;
>, <Line: -          } catch(e) { // IE throws errors sometimes
>, <Line: -            return false;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function shouldAbortRender() {
>, <Line: -          if (!data) {
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -          if ($rootScope.fullscreen && !scope.fullscreen) {
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -          if (!setElementHeight()) { return true; }
>, <Line: -          if (_.isString(data)) {
>, <Line: -            render_panel_as_graphite_png(data);
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -          if (elem.width() === 0) {
>, <Line: -            return;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function updateLegendValues(plot) {
>, <Line: -          var yaxis = plot.getYAxes();
>, <Line: -          for (var i = 0; i < data.length; i++) {
>, <Line: -            var series = data[i];
>, <Line: -            var axis = yaxis[series.yaxis - 1];
>, <Line: -            var formater = kbn.valueFormats[scope.panel.y_formats[series.yaxis - 1]];
>, <Line: -            // legend and tooltip gets one more decimal precision
>, <Line: -            // than graph legend ticks
>, <Line: -            var tickDecimals = (axis.tickDecimals || -1) + 1;
>, <Line: -            series.updateLegendValues(formater, tickDecimals, axis.scaledDecimals + 2);
>, <Line: -            if(!scope.$$phase) { scope.$digest(); }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        // Function for rendering panel
>, <Line: -        function render_panel() {
>, <Line: -          if (shouldAbortRender()) {
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          var panel = scope.panel;
>, <Line: -          var stack = panel.stack ? true : null;
>, <Line: -          // Populate element
>, <Line: -          var options = {
>, <Line: -            hooks: { draw: [updateLegendValues] },
>, <Line: -            legend: { show: false },
>, <Line: -            series: {
>, <Line: -              stackpercent: panel.stack ? panel.percentage : false,
>, <Line: -              stack: panel.percentage ? null : stack,
>, <Line: -              lines:  {
>, <Line: -                show: panel.lines,
>, <Line: -                zero: false,
>, <Line: -                fill: translateFillOption(panel.fill),
>, <Line: -                lineWidth: panel.linewidth,
>, <Line: -                steps: panel.steppedLine
>, <Line: -              },
>, <Line: -              bars:   {
>, <Line: -                show: panel.bars,
>, <Line: -                fill: 1,
>, <Line: -                barWidth: 1,
>, <Line: -                zero: false,
>, <Line: -                lineWidth: 0
>, <Line: -              },
>, <Line: -              points: {
>, <Line: -                show: panel.points,
>, <Line: -                fill: 1,
>, <Line: -                fillColor: false,
>, <Line: -                radius: panel.points ? panel.pointradius : 2
>, <Line: -                // little points when highlight points
>, <Line: -              },
>, <Line: -              shadowSize: 1
>, <Line: -            },
>, <Line: -            yaxes: [],
>, <Line: -            xaxis: {},
>, <Line: -            grid: {
>, <Line: -              minBorderMargin: 0,
>, <Line: -              markings: [],
>, <Line: -              backgroundColor: null,
>, <Line: -              borderWidth: 0,
>, <Line: -              hoverable: true,
>, <Line: -              color: '#c8c8c8'
>, <Line: -            },
>, <Line: -            selection: {
>, <Line: -              mode: "x",
>, <Line: -              color: '#666'
>, <Line: -            },
>, <Line: -            crosshair: {
>, <Line: -              mode: panel.tooltip.shared || dashboard.sharedCrosshair ? "x" : null
>, <Line: -            }
>, <Line: -          };
>, <Line: -          for (var i = 0; i < data.length; i++) {
>, <Line: -            var series = data[i];
>, <Line: -            series.applySeriesOverrides(panel.seriesOverrides);
>, <Line: -            series.data = series.getFlotPairs(panel.nullPointMode, panel.y_formats);
>, <Line: -            // if hidden remove points and disable stack
>, <Line: -            if (scope.hiddenSeries[series.alias]) {
>, <Line: -              series.data = [];
>, <Line: -              series.stack = false;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          if (data.length && data[0].stats.timeStep) {
>, <Line: -            options.series.bars.barWidth = data[0].stats.timeStep / 1.5;
>, <Line: -          }
>, <Line: -          addTimeAxis(options);
>, <Line: -          addGridThresholds(options, panel);
>, <Line: -          addAnnotations(options);
>, <Line: -          configureAxisOptions(data, options);
>, <Line: -          sortedSeries = _.sortBy(data, function(series) { return series.zindex; });
>, <Line: -          function callPlot() {
>, <Line: -            try {
>, <Line: -              $.plot(elem, sortedSeries, options);
>, <Line: -            } catch (e) {
>, <Line: -              console.log('flotcharts error', e);
>, <Line: -            }
>, <Line: -            addAxisLabels();
>, <Line: -          }
>, <Line: -          if (shouldDelayDraw(panel)) {
>, <Line: -            // temp fix for legends on the side, need to render twice to get dimensions right
>, <Line: -            callPlot();
>, <Line: -            setTimeout(callPlot, 50);
>, <Line: -            legendSideLastValue = panel.legend.rightSide;
>, <Line: -          }
>, <Line: -          else {
>, <Line: -            callPlot();
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function translateFillOption(fill) {
>, <Line: -          return fill === 0 ? 0.001 : fill/10;
>, <Line: -        }
>, <Line: -        function shouldDelayDraw(panel) {
>, <Line: -          if (panel.legend.rightSide) {
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -          if (legendSideLastValue !== null && panel.legend.rightSide !== legendSideLastValue) {
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -        function addTimeAxis(options) {
>, <Line: -          var ticks = elem.width() / 100;
>, <Line: -          var min = _.isUndefined(scope.range.from) ? null : scope.range.from.getTime();
>, <Line: -          var max = _.isUndefined(scope.range.to) ? null : scope.range.to.getTime();
>, <Line: -          options.xaxis = {
>, <Line: -            timezone: dashboard.timezone,
>, <Line: -            show: scope.panel['x-axis'],
>, <Line: -            mode: "time",
>, <Line: -            min: min,
>, <Line: -            max: max,
>, <Line: -            label: "Datetime",
>, <Line: -            ticks: ticks,
>, <Line: -            timeformat: time_format(scope.interval, ticks, min, max),
>, <Line: -          };
>, <Line: -        }
>, <Line: -        function addGridThresholds(options, panel) {
>, <Line: -          if (panel.grid.threshold1) {
>, <Line: -            var limit1 = panel.grid.thresholdLine ? panel.grid.threshold1 : (panel.grid.threshold2 || null);
>, <Line: -            options.grid.markings.push({
>, <Line: -              yaxis: { from: panel.grid.threshold1, to: limit1 },
>, <Line: -              color: panel.grid.threshold1Color
>, <Line: -            });
>, <Line: -            if (panel.grid.threshold2) {
>, <Line: -              var limit2;
>, <Line: -              if (panel.grid.thresholdLine) {
>, <Line: -                limit2 = panel.grid.threshold2;
>, <Line: -              } else {
>, <Line: -                limit2 = panel.grid.threshold1 > panel.grid.threshold2 ?  -Infinity : +Infinity;
>, <Line: -              }
>, <Line: -              options.grid.markings.push({
>, <Line: -                yaxis: { from: panel.grid.threshold2, to: limit2 },
>, <Line: -                color: panel.grid.threshold2Color
>, <Line: -              });
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function addAnnotations(options) {
>, <Line: -          if(!annotations || annotations.length === 0) {
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          var types = {};
>, <Line: -          _.each(annotations, function(event) {
>, <Line: -            if (!types[event.annotation.name]) {
>, <Line: -              types[event.annotation.name] = {
>, <Line: -                level: _.keys(types).length + 1,
>, <Line: -                icon: {
>, <Line: -                  icon: "icon-chevron-down",
>, <Line: -                  size: event.annotation.iconSize,
>, <Line: -                  color: event.annotation.iconColor,
>, <Line: -                }
>, <Line: -              };
>, <Line: -            }
>, <Line: -            if (event.annotation.showLine) {
>, <Line: -              options.grid.markings.push({
>, <Line: -                color: event.annotation.lineColor,
>, <Line: -                lineWidth: 1,
>, <Line: -                xaxis: { from: event.min, to: event.max }
>, <Line: -              });
>, <Line: -            }
>, <Line: -          });
>, <Line: -          options.events = {
>, <Line: -            levels: _.keys(types).length + 1,
>, <Line: -            data: annotations,
>, <Line: -            types: types
>, <Line: -          };
>, <Line: -        }
>, <Line: -        function addAxisLabels() {
>, <Line: -          if (scope.panel.leftYAxisLabel) {
>, <Line: -            elem.css('margin-left', '10px');
>, <Line: -            var yaxisLabel = $("<div class='axisLabel yaxisLabel'></div>")
>, <Line: -              .text(scope.panel.leftYAxisLabel)
>, <Line: -              .appendTo(elem);
>, <Line: -            yaxisLabel.css("margin-top", yaxisLabel.width() / 2 - 20);
>, <Line: -          } else if (elem.css('margin-left')) {
>, <Line: -            elem.css('margin-left', '');
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function configureAxisOptions(data, options) {
>, <Line: -          var defaults = {
>, <Line: -            position: 'left',
>, <Line: -            show: scope.panel['y-axis'],
>, <Line: -            min: scope.panel.grid.leftMin,
>, <Line: -            max: scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.leftMax,
>, <Line: -          };
>, <Line: -          options.yaxes.push(defaults);
>, <Line: -          if (_.findWhere(data, {yaxis: 2})) {
>, <Line: -            var secondY = _.clone(defaults);
>, <Line: -            secondY.position = 'right';
>, <Line: -            secondY.min = scope.panel.grid.rightMin;
>, <Line: -            secondY.max = scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.rightMax;
>, <Line: -            options.yaxes.push(secondY);
>, <Line: -            configureAxisMode(options.yaxes[1], scope.panel.y_formats[1]);
>, <Line: -          }
>, <Line: -          configureAxisMode(options.yaxes[0], scope.panel.y_formats[0]);
>, <Line: -        }
>, <Line: -        function configureAxisMode(axis, format) {
>, <Line: -          axis.tickFormatter = function(val, axis) {
>, <Line: -            return kbn.valueFormats[format](val, axis.tickDecimals, axis.scaledDecimals);
>, <Line: -          };
>, <Line: -        }
>, <Line: -        function time_format(interval, ticks, min, max) {
>, <Line: -          if (min && max && ticks) {
>, <Line: -            var secPerTick = ((max - min) / ticks) / 1000;
>, <Line: -            if (secPerTick <= 45) {
>, <Line: -              return "%H:%M:%S";
>, <Line: -            }
>, <Line: -            if (secPerTick <= 3600) {
>, <Line: -              return "%H:%M";
>, <Line: -            }
>, <Line: -            if (secPerTick <= 80000) {
>, <Line: -              return "%m/%d %H:%M";
>, <Line: -            }
>, <Line: -            if (secPerTick <= 2419200) {
>, <Line: -              return "%m/%d";
>, <Line: -            }
>, <Line: -            return "%Y-%m";
>, <Line: -          }
>, <Line: -          return "%H:%M";
>, <Line: -        }
>, <Line: -        function render_panel_as_graphite_png(url) {
>, <Line: -          url += '&width=' + elem.width();
>, <Line: -          url += '&height=' + elem.css('height').replace('px', '');
>, <Line: -          url += '&bgcolor=1f1f1f'; // @grayDarker & @grafanaPanelBackground
>, <Line: -          url += '&fgcolor=BBBFC2'; // @textColor & @grayLighter
>, <Line: -          url += scope.panel.stack ? '&areaMode=stacked' : '';
>, <Line: -          url += scope.panel.fill !== 0 ? ('&areaAlpha=' + (scope.panel.fill/10).toFixed(1)) : '';
>, <Line: -          url += scope.panel.linewidth !== 0 ? '&lineWidth=' + scope.panel.linewidth : '';
>, <Line: -          url += scope.panel.legend.show ? '&hideLegend=false' : '&hideLegend=true';
>, <Line: -          url += scope.panel.grid.leftMin !== null ? '&yMin=' + scope.panel.grid.leftMin : '';
>, <Line: -          url += scope.panel.grid.leftMax !== null ? '&yMax=' + scope.panel.grid.leftMax : '';
>, <Line: -          url += scope.panel.grid.rightMin !== null ? '&yMin=' + scope.panel.grid.rightMin : '';
>, <Line: -          url += scope.panel.grid.rightMax !== null ? '&yMax=' + scope.panel.grid.rightMax : '';
>, <Line: -          url += scope.panel['x-axis'] ? '' : '&hideAxes=true';
>, <Line: -          url += scope.panel['y-axis'] ? '' : '&hideYAxis=true';
>, <Line: -          switch(scope.panel.y_formats[0]) {
>, <Line: -          case 'bytes':
>, <Line: -            url += '&yUnitSystem=binary';
>, <Line: -            break;
>, <Line: -          case 'bits':
>, <Line: -            url += '&yUnitSystem=binary';
>, <Line: -            break;
>, <Line: -          case 'bps':
>, <Line: -            url += '&yUnitSystem=si';
>, <Line: -            break;
>, <Line: -          case 'short':
>, <Line: -            url += '&yUnitSystem=si';
>, <Line: -            break;
>, <Line: -          case 'none':
>, <Line: -            url += '&yUnitSystem=none';
>, <Line: -            break;
>, <Line: -          }
>, <Line: -          switch(scope.panel.nullPointMode) {
>, <Line: -          case 'connected':
>, <Line: -            url += '&lineMode=connected';
>, <Line: -            break;
>, <Line: -          case 'null':
>, <Line: -            break; // graphite default lineMode
>, <Line: -          case 'null as zero':
>, <Line: -            url += "&drawNullAsZero=true";
>, <Line: -            break;
>, <Line: -          }
>, <Line: -          url += scope.panel.steppedLine ? '&lineMode=staircase' : '';
>, <Line: -          elem.html('<img src="' + url + '"></img>');
>, <Line: -        }
>, <Line: -        new GraphTooltip(elem, dashboard, scope, function() {
>, <Line: -          return sortedSeries;
>, <Line: -        });
>, <Line: -        elem.bind("plotselected", function (event, ranges) {
>, <Line: -          scope.$apply(function() {
>, <Line: -            timeSrv.setTime({
>, <Line: -              from  : moment.utc(ranges.xaxis.from).toDate(),
>, <Line: -              to    : moment.utc(ranges.xaxis.to).toDate(),
>, <Line: -            });
>, <Line: -          });
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -  });
>, <Line: -});
>]