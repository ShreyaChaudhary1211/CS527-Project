[<Line: +;
>, <Line: +(function () {
>, <Line: +	/** Used as a safe reference for `undefined` in pre ES5 environments */
>, <Line: +	var undefined;
>, <Line: +	/** Used to pool arrays and objects used internally */
>, <Line: +	var arrayPool = [],
>, <Line: +		objectPool = [];
>, <Line: +	/** Used to generate unique IDs */
>, <Line: +	var idCounter = 0;
>, <Line: +	/** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
>, <Line: +	var keyPrefix = +new Date + '';
>, <Line: +	/** Used as the size when optimizations are enabled for large arrays */
>, <Line: +	var largeArraySize = 75;
>, <Line: +	/** Used as the max size of the `arrayPool` and `objectPool` */
>, <Line: +	var maxPoolSize = 40;
>, <Line: +	/** Used to detect and test whitespace */
>, <Line: +	var whitespace = (
>, <Line: +		// whitespace
>, <Line: +		' \t\x0B\f\xA0\ufeff' +
>, <Line: +			// line terminators
>, <Line: +		'\n\r\u2028\u2029' +
>, <Line: +			// unicode category "Zs" space separators
>, <Line: +		'\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
>, <Line: +	);
>, <Line: +	/** Used to match empty string literals in compiled template source */
>, <Line: +	var reEmptyStringLeading = /\b__p \+= '';/g,
>, <Line: +		reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
>, <Line: +		reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
>, <Line: +	/**
>, <Line: +	 * Used to match ES6 template delimiters
>, <Line: +	 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
>, <Line: +	 */
>, <Line: +	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
>, <Line: +	/** Used to match regexp flags from their coerced string values */
>, <Line: +	var reFlags = /\w*$/;
>, <Line: +	/** Used to detected named functions */
>, <Line: +	var reFuncName = /^\s*function[ \n\r\t]+\w/;
>, <Line: +	/** Used to match "interpolate" template delimiters */
>, <Line: +	var reInterpolate = /<%=([\s\S]+?)%>/g;
>, <Line: +	/** Used to match leading whitespace and zeros to be removed */
>, <Line: +	var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
>, <Line: +	/** Used to ensure capturing order of template delimiters */
>, <Line: +	var reNoMatch = /($^)/;
>, <Line: +	/** Used to detect functions containing a `this` reference */
>, <Line: +	var reThis = /\bthis\b/;
>, <Line: +	/** Used to match unescaped characters in compiled string literals */
>, <Line: +	var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
>, <Line: +	/** Used to assign default `context` object properties */
>, <Line: +	var contextProps = [
>, <Line: +		'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
>, <Line: +		'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
>, <Line: +		'parseInt', 'setTimeout'
>, <Line: +	];
>, <Line: +	/** Used to make template sourceURLs easier to identify */
>, <Line: +	var templateCounter = 0;
>, <Line: +	/** `Object#toString` result shortcuts */
>, <Line: +	var argsClass = '[object Arguments]',
>, <Line: +		arrayClass = '[object Array]',
>, <Line: +		boolClass = '[object Boolean]',
>, <Line: +		dateClass = '[object Date]',
>, <Line: +		funcClass = '[object Function]',
>, <Line: +		numberClass = '[object Number]',
>, <Line: +		objectClass = '[object Object]',
>, <Line: +		regexpClass = '[object RegExp]',
>, <Line: +		stringClass = '[object String]';
>, <Line: +	/** Used to identify object classifications that `_.clone` supports */
>, <Line: +	var cloneableClasses = {};
>, <Line: +	cloneableClasses[funcClass] = false;
>, <Line: +	cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
>, <Line: +		cloneableClasses[boolClass] = cloneableClasses[dateClass] =
>, <Line: +			cloneableClasses[numberClass] = cloneableClasses[objectClass] =
>, <Line: +				cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
>, <Line: +	/** Used as an internal `_.debounce` options object */
>, <Line: +	var debounceOptions = {
>, <Line: +		'leading': false,
>, <Line: +		'maxWait': 0,
>, <Line: +		'trailing': false
>, <Line: +	};
>, <Line: +	/** Used as the property descriptor for `__bindData__` */
>, <Line: +	var descriptor = {
>, <Line: +		'configurable': false,
>, <Line: +		'enumerable': false,
>, <Line: +		'value': null,
>, <Line: +		'writable': false
>, <Line: +	};
>, <Line: +	/** Used to determine if values are of the language type Object */
>, <Line: +	var objectTypes = {
>, <Line: +		'boolean': false,
>, <Line: +		'function': true,
>, <Line: +		'object': true,
>, <Line: +		'number': false,
>, <Line: +		'string': false,
>, <Line: +		'undefined': false
>, <Line: +	};
>, <Line: +	/** Used to escape characters for inclusion in compiled string literals */
>, <Line: +	var stringEscapes = {
>, <Line: +		'\\': '\\',
>, <Line: +		"'": "'",
>, <Line: +		'\n': 'n',
>, <Line: +		'\r': 'r',
>, <Line: +		'\t': 't',
>, <Line: +		'\u2028': 'u2028',
>, <Line: +		'\u2029': 'u2029'
>, <Line: +	};
>, <Line: +	/** Used as a reference to the global object */
>, <Line: +	var root = (objectTypes[typeof window] && window) || this;
>, <Line: +	/** Detect free variable `exports` */
>, <Line: +	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
>, <Line: +	/** Detect free variable `module` */
>, <Line: +	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
>, <Line: +	/** Detect the popular CommonJS extension `module.exports` */
>, <Line: +	var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
>, <Line: +	/** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
>, <Line: +	var freeGlobal = objectTypes[typeof global] && global;
>, <Line: +	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
>, <Line: +		root = freeGlobal;
>, <Line: +	}
>, <Line: +	/*--------------------------------------------------------------------------*/
>, <Line: +	/**
>, <Line: +	 * The base implementation of `_.indexOf` without support for binary searches
>, <Line: +	 * or `fromIndex` constraints.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Array} array The array to search.
>, <Line: +	 * @param {*} value The value to search for.
>, <Line: +	 * @param {number} [fromIndex=0] The index to search from.
>, <Line: +	 * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: +	 */
>, <Line: +	function baseIndexOf(array, value, fromIndex) {
>, <Line: +		var index = (fromIndex || 0) - 1,
>, <Line: +			length = array ? array.length : 0;
>, <Line: +		while (++index < length) {
>, <Line: +			if (array[index] === value) {
>, <Line: +				return index;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return -1;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * An implementation of `_.contains` for cache objects that mimics the return
>, <Line: +	 * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Object} cache The cache object to inspect.
>, <Line: +	 * @param {*} value The value to search for.
>, <Line: +	 * @returns {number} Returns `0` if `value` is found, else `-1`.
>, <Line: +	 */
>, <Line: +	function cacheIndexOf(cache, value) {
>, <Line: +		var type = typeof value;
>, <Line: +		cache = cache.cache;
>, <Line: +		if (type == 'boolean' || value == null) {
>, <Line: +			return cache[value] ? 0 : -1;
>, <Line: +		}
>, <Line: +		if (type != 'number' && type != 'string') {
>, <Line: +			type = 'object';
>, <Line: +		}
>, <Line: +		var key = type == 'number' ? value : keyPrefix + value;
>, <Line: +		cache = (cache = cache[type]) && cache[key];
>, <Line: +		return type == 'object'
>, <Line: +			? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
>, <Line: +			: (cache ? 0 : -1);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Adds a given value to the corresponding cache object.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {*} value The value to add to the cache.
>, <Line: +	 */
>, <Line: +	function cachePush(value) {
>, <Line: +		var cache = this.cache,
>, <Line: +			type = typeof value;
>, <Line: +		if (type == 'boolean' || value == null) {
>, <Line: +			cache[value] = true;
>, <Line: +		} else {
>, <Line: +			if (type != 'number' && type != 'string') {
>, <Line: +				type = 'object';
>, <Line: +			}
>, <Line: +			var key = type == 'number' ? value : keyPrefix + value,
>, <Line: +				typeCache = cache[type] || (cache[type] = {});
>, <Line: +			if (type == 'object') {
>, <Line: +				(typeCache[key] || (typeCache[key] = [])).push(value);
>, <Line: +			} else {
>, <Line: +				typeCache[key] = true;
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Used by `_.max` and `_.min` as the default callback when a given
>, <Line: +	 * collection is a string value.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {string} value The character to inspect.
>, <Line: +	 * @returns {number} Returns the code unit of given character.
>, <Line: +	 */
>, <Line: +	function charAtCallback(value) {
>, <Line: +		return value.charCodeAt(0);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Used by `sortBy` to compare transformed `collection` elements, stable sorting
>, <Line: +	 * them in ascending order.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Object} a The object to compare to `b`.
>, <Line: +	 * @param {Object} b The object to compare to `a`.
>, <Line: +	 * @returns {number} Returns the sort order indicator of `1` or `-1`.
>, <Line: +	 */
>, <Line: +	function compareAscending(a, b) {
>, <Line: +		var ac = a.criteria,
>, <Line: +			bc = b.criteria,
>, <Line: +			index = -1,
>, <Line: +			length = ac.length;
>, <Line: +		while (++index < length) {
>, <Line: +			var value = ac[index],
>, <Line: +				other = bc[index];
>, <Line: +			if (value !== other) {
>, <Line: +				if (value > other || typeof value == 'undefined') {
>, <Line: +					return 1;
>, <Line: +				}
>, <Line: +				if (value < other || typeof other == 'undefined') {
>, <Line: +					return -1;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
>, <Line: +		// that causes it, under certain circumstances, to return the same value for
>, <Line: +		// `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
>, <Line: +		//
>, <Line: +		// This also ensures a stable sort in V8 and other engines.
>, <Line: +		// See http://code.google.com/p/v8/issues/detail?id=90
>, <Line: +		return a.index - b.index;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Creates a cache object to optimize linear searches of large arrays.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Array} [array=[]] The array to search.
>, <Line: +	 * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
>, <Line: +	 */
>, <Line: +	function createCache(array) {
>, <Line: +		var index = -1,
>, <Line: +			length = array.length,
>, <Line: +			first = array[0],
>, <Line: +			mid = array[(length / 2) | 0],
>, <Line: +			last = array[length - 1];
>, <Line: +		if (first && typeof first == 'object' &&
>, <Line: +			mid && typeof mid == 'object' && last && typeof last == 'object') {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		var cache = getObject();
>, <Line: +		cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
>, <Line: +		var result = getObject();
>, <Line: +		result.array = array;
>, <Line: +		result.cache = cache;
>, <Line: +		result.push = cachePush;
>, <Line: +		while (++index < length) {
>, <Line: +			result.push(array[index]);
>, <Line: +		}
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Used by `template` to escape characters for inclusion in compiled
>, <Line: +	 * string literals.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {string} match The matched character to escape.
>, <Line: +	 * @returns {string} Returns the escaped character.
>, <Line: +	 */
>, <Line: +	function escapeStringChar(match) {
>, <Line: +		return '\\' + stringEscapes[match];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Gets an array from the array pool or creates a new one if the pool is empty.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @returns {Array} The array from the pool.
>, <Line: +	 */
>, <Line: +	function getArray() {
>, <Line: +		return arrayPool.pop() || [];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Gets an object from the object pool or creates a new one if the pool is empty.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @returns {Object} The object from the pool.
>, <Line: +	 */
>, <Line: +	function getObject() {
>, <Line: +		return objectPool.pop() || {
>, <Line: +				'array': null,
>, <Line: +				'cache': null,
>, <Line: +				'criteria': null,
>, <Line: +				'false': false,
>, <Line: +				'index': 0,
>, <Line: +				'null': false,
>, <Line: +				'number': null,
>, <Line: +				'object': null,
>, <Line: +				'push': null,
>, <Line: +				'string': null,
>, <Line: +				'true': false,
>, <Line: +				'undefined': false,
>, <Line: +				'value': null
>, <Line: +			};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Releases the given array back to the array pool.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Array} [array] The array to release.
>, <Line: +	 */
>, <Line: +	function releaseArray(array) {
>, <Line: +		array.length = 0;
>, <Line: +		if (arrayPool.length < maxPoolSize) {
>, <Line: +			arrayPool.push(array);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Releases the given object back to the object pool.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Object} [object] The object to release.
>, <Line: +	 */
>, <Line: +	function releaseObject(object) {
>, <Line: +		var cache = object.cache;
>, <Line: +		if (cache) {
>, <Line: +			releaseObject(cache);
>, <Line: +		}
>, <Line: +		object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
>, <Line: +		if (objectPool.length < maxPoolSize) {
>, <Line: +			objectPool.push(object);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Slices the `collection` from the `start` index up to, but not including,
>, <Line: +	 * the `end` index.
>, <Line: +	 *
>, <Line: +	 * Note: This function is used instead of `Array#slice` to support node lists
>, <Line: +	 * in IE < 9 and to ensure dense arrays are returned.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {Array|Object|string} collection The collection to slice.
>, <Line: +	 * @param {number} start The start index.
>, <Line: +	 * @param {number} end The end index.
>, <Line: +	 * @returns {Array} Returns the new array.
>, <Line: +	 */
>, <Line: +	function slice(array, start, end) {
>, <Line: +		start || (start = 0);
>, <Line: +		if (typeof end == 'undefined') {
>, <Line: +			end = array ? array.length : 0;
>, <Line: +		}
>, <Line: +		var index = -1,
>, <Line: +			length = end - start || 0,
>, <Line: +			result = Array(length < 0 ? 0 : length);
>, <Line: +		while (++index < length) {
>, <Line: +			result[index] = array[start + index];
>, <Line: +		}
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +	/*--------------------------------------------------------------------------*/
>, <Line: +	/**
>, <Line: +	 * Create a new `lodash` function using the given context object.
>, <Line: +	 *
>, <Line: +	 * @static
>, <Line: +	 * @memberOf _
>, <Line: +	 * @category Utilities
>, <Line: +	 * @param {Object} [context=root] The context object.
>, <Line: +	 * @returns {Function} Returns the `lodash` function.
>, <Line: +	 */
>, <Line: +	function runInContext(context) {
>, <Line: +		// Avoid issues with some ES3 environments that attempt to use values, named
>, <Line: +		// after built-in constructors like `Object`, for the creation of literals.
>, <Line: +		// ES5 clears this up by stating that literals must use built-in constructors.
>, <Line: +		// See http://es5.github.io/#x11.1.5.
>, <Line: +		context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
>, <Line: +		/** Native constructor references */
>, <Line: +		var Array = context.Array,
>, <Line: +			Boolean = context.Boolean,
>, <Line: +			Date = context.Date,
>, <Line: +			Function = context.Function,
>, <Line: +			Math = context.Math,
>, <Line: +			Number = context.Number,
>, <Line: +			Object = context.Object,
>, <Line: +			RegExp = context.RegExp,
>, <Line: +			String = context.String,
>, <Line: +			TypeError = context.TypeError;
>, <Line: +		/**
>, <Line: +		 * Used for `Array` method references.
>, <Line: +		 *
>, <Line: +		 * Normally `Array.prototype` would suffice, however, using an array literal
>, <Line: +		 * avoids issues in Narwhal.
>, <Line: +		 */
>, <Line: +		var arrayRef = [];
>, <Line: +		/** Used for native method references */
>, <Line: +		var objectProto = Object.prototype;
>, <Line: +		/** Used to restore the original `_` reference in `noConflict` */
>, <Line: +		var oldDash = context._;
>, <Line: +		/** Used to resolve the internal [[Class]] of values */
>, <Line: +		var toString = objectProto.toString;
>, <Line: +		/** Used to detect if a method is native */
>, <Line: +		var reNative = RegExp('^' +
>, <Line: +			String(toString)
>, <Line: +				.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
>, <Line: +				.replace(/toString| for [^\]]+/g, '.*?') + '$'
>, <Line: +		);
>, <Line: +		/** Native method shortcuts */
>, <Line: +		var ceil = Math.ceil,
>, <Line: +			clearTimeout = context.clearTimeout,
>, <Line: +			floor = Math.floor,
>, <Line: +			fnToString = Function.prototype.toString,
>, <Line: +			getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
>, <Line: +			hasOwnProperty = objectProto.hasOwnProperty,
>, <Line: +			push = arrayRef.push,
>, <Line: +			setTimeout = context.setTimeout,
>, <Line: +			splice = arrayRef.splice,
>, <Line: +			unshift = arrayRef.unshift;
>, <Line: +		/** Used to set meta data on functions */
>, <Line: +		var defineProperty = (function () {
>, <Line: +			// IE 8 only accepts DOM elements
>, <Line: +			try {
>, <Line: +				var o = {},
>, <Line: +					func = isNative(func = Object.defineProperty) && func,
>, <Line: +					result = func(o, o, o) && func;
>, <Line: +			} catch (e) {
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}());
>, <Line: +		/* Native method shortcuts for methods with the same name as other `lodash` methods */
>, <Line: +		var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
>, <Line: +			nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
>, <Line: +			nativeIsFinite = context.isFinite,
>, <Line: +			nativeIsNaN = context.isNaN,
>, <Line: +			nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
>, <Line: +			nativeMax = Math.max,
>, <Line: +			nativeMin = Math.min,
>, <Line: +			nativeParseInt = context.parseInt,
>, <Line: +			nativeRandom = Math.random;
>, <Line: +		/** Used to lookup a built-in constructor by [[Class]] */
>, <Line: +		var ctorByClass = {};
>, <Line: +		ctorByClass[arrayClass] = Array;
>, <Line: +		ctorByClass[boolClass] = Boolean;
>, <Line: +		ctorByClass[dateClass] = Date;
>, <Line: +		ctorByClass[funcClass] = Function;
>, <Line: +		ctorByClass[objectClass] = Object;
>, <Line: +		ctorByClass[numberClass] = Number;
>, <Line: +		ctorByClass[regexpClass] = RegExp;
>, <Line: +		ctorByClass[stringClass] = String;
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates a `lodash` object which wraps the given value to enable intuitive
>, <Line: +		 * method chaining.
>, <Line: +		 *
>, <Line: +		 * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
>, <Line: +		 * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
>, <Line: +		 * and `unshift`
>, <Line: +		 *
>, <Line: +		 * Chaining is supported in custom builds as long as the `value` method is
>, <Line: +		 * implicitly or explicitly included in the build.
>, <Line: +		 *
>, <Line: +		 * The chainable wrapper functions are:
>, <Line: +		 * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
>, <Line: +		 * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
>, <Line: +		 * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
>, <Line: +		 * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
>, <Line: +		 * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
>, <Line: +		 * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
>, <Line: +		 * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
>, <Line: +		 * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
>, <Line: +		 * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
>, <Line: +		 * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
>, <Line: +		 * and `zip`
>, <Line: +		 *
>, <Line: +		 * The non-chainable wrapper functions are:
>, <Line: +		 * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
>, <Line: +		 * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
>, <Line: +		 * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
>, <Line: +		 * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
>, <Line: +		 * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
>, <Line: +		 * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
>, <Line: +		 * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
>, <Line: +		 * `template`, `unescape`, `uniqueId`, and `value`
>, <Line: +		 *
>, <Line: +		 * The wrapper functions `first` and `last` return wrapped values when `n` is
>, <Line: +		 * provided, otherwise they return unwrapped values.
>, <Line: +		 *
>, <Line: +		 * Explicit chaining can be enabled by using the `_.chain` method.
>, <Line: +		 *
>, <Line: +		 * @name _
>, <Line: +		 * @constructor
>, <Line: +		 * @category Chaining
>, <Line: +		 * @param {*} value The value to wrap in a `lodash` instance.
>, <Line: +		 * @returns {Object} Returns a `lodash` instance.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var wrapped = _([1, 2, 3]);
>, <Line: +		 *
>, <Line: +		 * // returns an unwrapped value
>, <Line: +		 * wrapped.reduce(function(sum, num) {
>, <Line: +		 * // => 6
>, <Line: +		 *
>, <Line: +		 * // returns a wrapped value
>, <Line: +		 * var squares = wrapped.map(function(num) {
>, <Line: +		 *
>, <Line: +		 * _.isArray(squares);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isArray(squares.value());
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function lodash(value) {
>, <Line: +			// don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
>, <Line: +			return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
>, <Line: +				? value
>, <Line: +				: new lodashWrapper(value);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * A fast path for creating `lodash` wrapper objects.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} value The value to wrap in a `lodash` instance.
>, <Line: +		 * @param {boolean} chainAll A flag to enable chaining for all methods
>, <Line: +		 * @returns {Object} Returns a `lodash` instance.
>, <Line: +		 */
>, <Line: +		function lodashWrapper(value, chainAll) {
>, <Line: +			this.__chain__ = !!chainAll;
>, <Line: +			this.__wrapped__ = value;
>, <Line: +		}
>, <Line: +		// ensure `new lodashWrapper` is an instance of `lodash`
>, <Line: +		lodashWrapper.prototype = lodash.prototype;
>, <Line: +		/**
>, <Line: +		 * An object used to flag environments features.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Object
>, <Line: +		 */
>, <Line: +		var support = lodash.support = {};
>, <Line: +		/**
>, <Line: +		 * Detect if functions can be decompiled by `Function#toString`
>, <Line: +		 * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
>, <Line: +		 *
>, <Line: +		 * @memberOf _.support
>, <Line: +		 * @type boolean
>, <Line: +		 */
>, <Line: +		support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
>, <Line: +		/**
>, <Line: +		 * Detect if `Function#name` is supported (all but IE).
>, <Line: +		 *
>, <Line: +		 * @memberOf _.support
>, <Line: +		 * @type boolean
>, <Line: +		 */
>, <Line: +		support.funcNames = typeof Function.name == 'string';
>, <Line: +		/**
>, <Line: +		 * By default, the template delimiters used by Lo-Dash are similar to those in
>, <Line: +		 * embedded Ruby (ERB). Change the following template settings to use alternative
>, <Line: +		 * delimiters.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Object
>, <Line: +		 */
>, <Line: +		lodash.templateSettings = {
>, <Line: +			/**
>, <Line: +			 * Used to detect `data` property values to be HTML-escaped.
>, <Line: +			 *
>, <Line: +			 * @memberOf _.templateSettings
>, <Line: +			 * @type RegExp
>, <Line: +			 */
>, <Line: +			'escape': /<%-([\s\S]+?)%>/g,
>, <Line: +			/**
>, <Line: +			 * Used to detect code to be evaluated.
>, <Line: +			 *
>, <Line: +			 * @memberOf _.templateSettings
>, <Line: +			 * @type RegExp
>, <Line: +			 */
>, <Line: +			'evaluate': /<%([\s\S]+?)%>/g,
>, <Line: +			/**
>, <Line: +			 * Used to detect `data` property values to inject.
>, <Line: +			 *
>, <Line: +			 * @memberOf _.templateSettings
>, <Line: +			 * @type RegExp
>, <Line: +			 */
>, <Line: +			'interpolate': reInterpolate,
>, <Line: +			/**
>, <Line: +			 * Used to reference the data object in the template text.
>, <Line: +			 *
>, <Line: +			 * @memberOf _.templateSettings
>, <Line: +			 * @type string
>, <Line: +			 */
>, <Line: +			'variable': '',
>, <Line: +			/**
>, <Line: +			 * Used to import variables into the compiled template.
>, <Line: +			 *
>, <Line: +			 * @memberOf _.templateSettings
>, <Line: +			 * @type Object
>, <Line: +			 */
>, <Line: +			'imports': {
>, <Line: +				/**
>, <Line: +				 * A reference to the `lodash` function.
>, <Line: +				 *
>, <Line: +				 * @memberOf _.templateSettings.imports
>, <Line: +				 * @type Function
>, <Line: +				 */
>, <Line: +				'_': lodash
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.bind` that creates the bound function and
>, <Line: +		 * sets its meta data.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Array} bindData The bind data array.
>, <Line: +		 * @returns {Function} Returns the new bound function.
>, <Line: +		 */
>, <Line: +		function baseBind(bindData) {
>, <Line: +			var func = bindData[0],
>, <Line: +				partialArgs = bindData[2],
>, <Line: +				thisArg = bindData[4];
>, <Line: +			function bound() {
>, <Line: +				// `Function#bind` spec
>, <Line: +				// http://es5.github.io/#x15.3.4.5
>, <Line: +				if (partialArgs) {
>, <Line: +					// avoid `arguments` object deoptimizations by using `slice` instead
>, <Line: +					// of `Array.prototype.slice.call` and not assigning `arguments` to a
>, <Line: +					// variable as a ternary expression
>, <Line: +					var args = slice(partialArgs);
>, <Line: +					push.apply(args, arguments);
>, <Line: +				}
>, <Line: +				// mimic the constructor's `return` behavior
>, <Line: +				// http://es5.github.io/#x13.2.2
>, <Line: +				if (this instanceof bound) {
>, <Line: +					// ensure `new bound` is an instance of `func`
>, <Line: +					var thisBinding = baseCreate(func.prototype),
>, <Line: +						result = func.apply(thisBinding, args || arguments);
>, <Line: +					return isObject(result) ? result : thisBinding;
>, <Line: +				}
>, <Line: +				return func.apply(thisArg, args || arguments);
>, <Line: +			}
>, <Line: +			setBindData(bound, bindData);
>, <Line: +			return bound;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.clone` without argument juggling or support
>, <Line: +		 * for `thisArg` binding.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} value The value to clone.
>, <Line: +		 * @param {boolean} [isDeep=false] Specify a deep clone.
>, <Line: +		 * @param {Function} [callback] The function to customize cloning values.
>, <Line: +		 * @param {Array} [stackA=[]] Tracks traversed source objects.
>, <Line: +		 * @param {Array} [stackB=[]] Associates clones with source counterparts.
>, <Line: +		 * @returns {*} Returns the cloned value.
>, <Line: +		 */
>, <Line: +		function baseClone(value, isDeep, callback, stackA, stackB) {
>, <Line: +			if (callback) {
>, <Line: +				var result = callback(value);
>, <Line: +				if (typeof result != 'undefined') {
>, <Line: +					return result;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// inspect [[Class]]
>, <Line: +			var isObj = isObject(value);
>, <Line: +			if (isObj) {
>, <Line: +				var className = toString.call(value);
>, <Line: +				if (!cloneableClasses[className]) {
>, <Line: +					return value;
>, <Line: +				}
>, <Line: +				var ctor = ctorByClass[className];
>, <Line: +				switch (className) {
>, <Line: +					case boolClass:
>, <Line: +					case dateClass:
>, <Line: +						return new ctor(+value);
>, <Line: +					case numberClass:
>, <Line: +					case stringClass:
>, <Line: +						return new ctor(value);
>, <Line: +					case regexpClass:
>, <Line: +						result = ctor(value.source, reFlags.exec(value));
>, <Line: +						result.lastIndex = value.lastIndex;
>, <Line: +						return result;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				return value;
>, <Line: +			}
>, <Line: +			var isArr = isArray(value);
>, <Line: +			if (isDeep) {
>, <Line: +				// check for circular references and return corresponding clone
>, <Line: +				var initedStack = !stackA;
>, <Line: +				stackA || (stackA = getArray());
>, <Line: +				stackB || (stackB = getArray());
>, <Line: +				var length = stackA.length;
>, <Line: +				while (length--) {
>, <Line: +					if (stackA[length] == value) {
>, <Line: +						return stackB[length];
>, <Line: +					}
>, <Line: +				}
>, <Line: +				result = isArr ? ctor(value.length) : {};
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				result = isArr ? slice(value) : assign({}, value);
>, <Line: +			}
>, <Line: +			// add array properties assigned by `RegExp#exec`
>, <Line: +			if (isArr) {
>, <Line: +				if (hasOwnProperty.call(value, 'index')) {
>, <Line: +					result.index = value.index;
>, <Line: +				}
>, <Line: +				if (hasOwnProperty.call(value, 'input')) {
>, <Line: +					result.input = value.input;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// exit for shallow clone
>, <Line: +			if (!isDeep) {
>, <Line: +				return result;
>, <Line: +			}
>, <Line: +			// add the source value to the stack of traversed objects
>, <Line: +			// and associate it with its clone
>, <Line: +			stackA.push(value);
>, <Line: +			stackB.push(result);
>, <Line: +			// recursively populate clone (susceptible to call stack limits)
>, <Line: +			(isArr ? forEach : forOwn)(value, function (objValue, key) {
>, <Line: +				result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
>, <Line: +			});
>, <Line: +			if (initedStack) {
>, <Line: +				releaseArray(stackA);
>, <Line: +				releaseArray(stackB);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.create` without support for assigning
>, <Line: +		 * properties to the created object.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Object} prototype The object to inherit from.
>, <Line: +		 * @returns {Object} Returns the new object.
>, <Line: +		 */
>, <Line: +		function baseCreate(prototype, properties) {
>, <Line: +			return isObject(prototype) ? nativeCreate(prototype) : {};
>, <Line: +		}
>, <Line: +		// fallback for browsers without `Object.create`
>, <Line: +		if (!nativeCreate) {
>, <Line: +			baseCreate = (function () {
>, <Line: +				function Object() {
>, <Line: +				}
>, <Line: +				return function (prototype) {
>, <Line: +					if (isObject(prototype)) {
>, <Line: +						Object.prototype = prototype;
>, <Line: +						var result = new Object;
>, <Line: +						Object.prototype = null;
>, <Line: +					}
>, <Line: +					return result || context.Object();
>, <Line: +				};
>, <Line: +			}());
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.createCallback` without support for creating
>, <Line: +		 * "_.pluck" or "_.where" style callbacks.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} [func=identity] The value to convert to a callback.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of the created callback.
>, <Line: +		 * @param {number} [argCount] The number of arguments the callback accepts.
>, <Line: +		 * @returns {Function} Returns a callback function.
>, <Line: +		 */
>, <Line: +		function baseCreateCallback(func, thisArg, argCount) {
>, <Line: +			if (typeof func != 'function') {
>, <Line: +				return identity;
>, <Line: +			}
>, <Line: +			// exit early for no `thisArg` or already bound by `Function#bind`
>, <Line: +			if (typeof thisArg == 'undefined' || !('prototype' in func)) {
>, <Line: +				return func;
>, <Line: +			}
>, <Line: +			var bindData = func.__bindData__;
>, <Line: +			if (typeof bindData == 'undefined') {
>, <Line: +				if (support.funcNames) {
>, <Line: +					bindData = !func.name;
>, <Line: +				}
>, <Line: +				bindData = bindData || !support.funcDecomp;
>, <Line: +				if (!bindData) {
>, <Line: +					var source = fnToString.call(func);
>, <Line: +					if (!support.funcNames) {
>, <Line: +						bindData = !reFuncName.test(source);
>, <Line: +					}
>, <Line: +					if (!bindData) {
>, <Line: +						// checks if `func` references the `this` keyword and stores the result
>, <Line: +						bindData = reThis.test(source);
>, <Line: +						setBindData(func, bindData);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// exit early if there are no `this` references or `func` is bound
>, <Line: +			if (bindData === false || (bindData !== true && bindData[1] & 1)) {
>, <Line: +				return func;
>, <Line: +			}
>, <Line: +			switch (argCount) {
>, <Line: +				case 1:
>, <Line: +					return function (value) {
>, <Line: +						return func.call(thisArg, value);
>, <Line: +					};
>, <Line: +				case 2:
>, <Line: +					return function (a, b) {
>, <Line: +						return func.call(thisArg, a, b);
>, <Line: +					};
>, <Line: +				case 3:
>, <Line: +					return function (value, index, collection) {
>, <Line: +						return func.call(thisArg, value, index, collection);
>, <Line: +					};
>, <Line: +				case 4:
>, <Line: +					return function (accumulator, value, index, collection) {
>, <Line: +						return func.call(thisArg, accumulator, value, index, collection);
>, <Line: +					};
>, <Line: +			}
>, <Line: +			return bind(func, thisArg);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `createWrapper` that creates the wrapper and
>, <Line: +		 * sets its meta data.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Array} bindData The bind data array.
>, <Line: +		 * @returns {Function} Returns the new function.
>, <Line: +		 */
>, <Line: +		function baseCreateWrapper(bindData) {
>, <Line: +			var func = bindData[0],
>, <Line: +				bitmask = bindData[1],
>, <Line: +				partialArgs = bindData[2],
>, <Line: +				partialRightArgs = bindData[3],
>, <Line: +				thisArg = bindData[4],
>, <Line: +				arity = bindData[5];
>, <Line: +			var isBind = bitmask & 1,
>, <Line: +				isBindKey = bitmask & 2,
>, <Line: +				isCurry = bitmask & 4,
>, <Line: +				isCurryBound = bitmask & 8,
>, <Line: +				key = func;
>, <Line: +			function bound() {
>, <Line: +				var thisBinding = isBind ? thisArg : this;
>, <Line: +				if (partialArgs) {
>, <Line: +					var args = slice(partialArgs);
>, <Line: +					push.apply(args, arguments);
>, <Line: +				}
>, <Line: +				if (partialRightArgs || isCurry) {
>, <Line: +					args || (args = slice(arguments));
>, <Line: +					if (partialRightArgs) {
>, <Line: +						push.apply(args, partialRightArgs);
>, <Line: +					}
>, <Line: +					if (isCurry && args.length < arity) {
>, <Line: +						bitmask |= 16 & ~32;
>, <Line: +						return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				args || (args = arguments);
>, <Line: +				if (isBindKey) {
>, <Line: +					func = thisBinding[key];
>, <Line: +				}
>, <Line: +				if (this instanceof bound) {
>, <Line: +					thisBinding = baseCreate(func.prototype);
>, <Line: +					var result = func.apply(thisBinding, args);
>, <Line: +					return isObject(result) ? result : thisBinding;
>, <Line: +				}
>, <Line: +				return func.apply(thisBinding, args);
>, <Line: +			}
>, <Line: +			setBindData(bound, bindData);
>, <Line: +			return bound;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.difference` that accepts a single array
>, <Line: +		 * of values to exclude.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Array} array The array to process.
>, <Line: +		 * @param {Array} [values] The array of values to exclude.
>, <Line: +		 * @returns {Array} Returns a new array of filtered values.
>, <Line: +		 */
>, <Line: +		function baseDifference(array, values) {
>, <Line: +			var index = -1,
>, <Line: +				indexOf = getIndexOf(),
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				isLarge = length >= largeArraySize && indexOf === baseIndexOf,
>, <Line: +				result = [];
>, <Line: +			if (isLarge) {
>, <Line: +				var cache = createCache(values);
>, <Line: +				if (cache) {
>, <Line: +					indexOf = cacheIndexOf;
>, <Line: +					values = cache;
>, <Line: +				} else {
>, <Line: +					isLarge = false;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			while (++index < length) {
>, <Line: +				var value = array[index];
>, <Line: +				if (indexOf(values, value) < 0) {
>, <Line: +					result.push(value);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (isLarge) {
>, <Line: +				releaseObject(values);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.flatten` without support for callback
>, <Line: +		 * shorthands or `thisArg` binding.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Array} array The array to flatten.
>, <Line: +		 * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
>, <Line: +		 * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
>, <Line: +		 * @param {number} [fromIndex=0] The index to start from.
>, <Line: +		 * @returns {Array} Returns a new flattened array.
>, <Line: +		 */
>, <Line: +		function baseFlatten(array, isShallow, isStrict, fromIndex) {
>, <Line: +			var index = (fromIndex || 0) - 1,
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				result = [];
>, <Line: +			while (++index < length) {
>, <Line: +				var value = array[index];
>, <Line: +				if (value && typeof value == 'object' && typeof value.length == 'number'
>, <Line: +					&& (isArray(value) || isArguments(value))) {
>, <Line: +					// recursively flatten arrays (susceptible to call stack limits)
>, <Line: +					if (!isShallow) {
>, <Line: +						value = baseFlatten(value, isShallow, isStrict);
>, <Line: +					}
>, <Line: +					var valIndex = -1,
>, <Line: +						valLength = value.length,
>, <Line: +						resIndex = result.length;
>, <Line: +					result.length += valLength;
>, <Line: +					while (++valIndex < valLength) {
>, <Line: +						result[resIndex++] = value[valIndex];
>, <Line: +					}
>, <Line: +				} else if (!isStrict) {
>, <Line: +					result.push(value);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.isEqual`, without support for `thisArg` binding,
>, <Line: +		 * that allows partial "_.where" style comparisons.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} a The value to compare.
>, <Line: +		 * @param {*} b The other value to compare.
>, <Line: +		 * @param {Function} [callback] The function to customize comparing values.
>, <Line: +		 * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
>, <Line: +		 * @param {Array} [stackA=[]] Tracks traversed `a` objects.
>, <Line: +		 * @param {Array} [stackB=[]] Tracks traversed `b` objects.
>, <Line: +		 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
>, <Line: +		 */
>, <Line: +		function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
>, <Line: +			// used to indicate that when comparing objects, `a` has at least the properties of `b`
>, <Line: +			if (callback) {
>, <Line: +				var result = callback(a, b);
>, <Line: +				if (typeof result != 'undefined') {
>, <Line: +					return !!result;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// exit early for identical values
>, <Line: +			if (a === b) {
>, <Line: +				// treat `+0` vs. `-0` as not equal
>, <Line: +				return a !== 0 || (1 / a == 1 / b);
>, <Line: +			}
>, <Line: +			var type = typeof a,
>, <Line: +				otherType = typeof b;
>, <Line: +			// exit early for unlike primitive values
>, <Line: +			if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			// exit early for `null` and `undefined` avoiding ES3's Function#call behavior
>, <Line: +			// http://es5.github.io/#x15.3.4.4
>, <Line: +			if (a == null || b == null) {
>, <Line: +				return a === b;
>, <Line: +			}
>, <Line: +			// compare [[Class]] names
>, <Line: +			var className = toString.call(a),
>, <Line: +				otherClass = toString.call(b);
>, <Line: +			if (className == argsClass) {
>, <Line: +				className = objectClass;
>, <Line: +			}
>, <Line: +			if (otherClass == argsClass) {
>, <Line: +				otherClass = objectClass;
>, <Line: +			}
>, <Line: +			if (className != otherClass) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			switch (className) {
>, <Line: +				case boolClass:
>, <Line: +				case dateClass:
>, <Line: +					// coerce dates and booleans to numbers, dates to milliseconds and booleans
>, <Line: +					// to `1` or `0` treating invalid dates coerced to `NaN` as not equal
>, <Line: +					return +a == +b;
>, <Line: +				case numberClass:
>, <Line: +					// treat `NaN` vs. `NaN` as equal
>, <Line: +					return (a != +a)
>, <Line: +						? b != +b
>, <Line: +						// but treat `+0` vs. `-0` as not equal
>, <Line: +						: (a == 0 ? (1 / a == 1 / b) : a == +b);
>, <Line: +				case regexpClass:
>, <Line: +				case stringClass:
>, <Line: +					// coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
>, <Line: +					// treat string primitives and their corresponding object instances as equal
>, <Line: +					return a == String(b);
>, <Line: +			}
>, <Line: +			var isArr = className == arrayClass;
>, <Line: +			if (!isArr) {
>, <Line: +				// unwrap any `lodash` wrapped values
>, <Line: +				var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
>, <Line: +					bWrapped = hasOwnProperty.call(b, '__wrapped__');
>, <Line: +				if (aWrapped || bWrapped) {
>, <Line: +					return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
>, <Line: +				}
>, <Line: +				// exit for functions and DOM nodes
>, <Line: +				if (className != objectClass) {
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				// in older versions of Opera, `arguments` objects have `Array` constructors
>, <Line: +				var ctorA = a.constructor,
>, <Line: +					ctorB = b.constructor;
>, <Line: +				// non `Object` object instances with different constructors are not equal
>, <Line: +				if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
>, <Line: +					('constructor' in a && 'constructor' in b)
>, <Line: +				) {
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// assume cyclic structures are equal
>, <Line: +			// the algorithm for detecting cyclic structures is adapted from ES 5.1
>, <Line: +			// section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
>, <Line: +			var initedStack = !stackA;
>, <Line: +			stackA || (stackA = getArray());
>, <Line: +			stackB || (stackB = getArray());
>, <Line: +			var length = stackA.length;
>, <Line: +			while (length--) {
>, <Line: +				if (stackA[length] == a) {
>, <Line: +					return stackB[length] == b;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var size = 0;
>, <Line: +			result = true;
>, <Line: +			// add `a` and `b` to the stack of traversed objects
>, <Line: +			stackA.push(a);
>, <Line: +			stackB.push(b);
>, <Line: +			// recursively compare objects and arrays (susceptible to call stack limits)
>, <Line: +			if (isArr) {
>, <Line: +				// compare lengths to determine if a deep comparison is necessary
>, <Line: +				length = a.length;
>, <Line: +				size = b.length;
>, <Line: +				result = size == length;
>, <Line: +				if (result || isWhere) {
>, <Line: +					// deep compare the contents, ignoring non-numeric properties
>, <Line: +					while (size--) {
>, <Line: +						var index = length,
>, <Line: +							value = b[size];
>, <Line: +						if (isWhere) {
>, <Line: +							while (index--) {
>, <Line: +								if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
>, <Line: +									break;
>, <Line: +								}
>, <Line: +							}
>, <Line: +						} else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				// deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
>, <Line: +				// which, in this case, is more costly
>, <Line: +				forIn(b, function (value, key, b) {
>, <Line: +					if (hasOwnProperty.call(b, key)) {
>, <Line: +						// count the number of properties.
>, <Line: +						size++;
>, <Line: +						// deep compare each property value.
>, <Line: +						return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
>, <Line: +					}
>, <Line: +				});
>, <Line: +				if (result && !isWhere) {
>, <Line: +					// ensure both objects have the same number of properties
>, <Line: +					forIn(a, function (value, key, a) {
>, <Line: +						if (hasOwnProperty.call(a, key)) {
>, <Line: +							// `size` will be `-1` if `a` has more properties than `b`
>, <Line: +							return (result = --size > -1);
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +			stackA.pop();
>, <Line: +			stackB.pop();
>, <Line: +			if (initedStack) {
>, <Line: +				releaseArray(stackA);
>, <Line: +				releaseArray(stackB);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.merge` without argument juggling or support
>, <Line: +		 * for `thisArg` binding.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Object} object The destination object.
>, <Line: +		 * @param {Object} source The source object.
>, <Line: +		 * @param {Function} [callback] The function to customize merging properties.
>, <Line: +		 * @param {Array} [stackA=[]] Tracks traversed source objects.
>, <Line: +		 * @param {Array} [stackB=[]] Associates values with source counterparts.
>, <Line: +		 */
>, <Line: +		function baseMerge(object, source, callback, stackA, stackB) {
>, <Line: +			(isArray(source) ? forEach : forOwn)(source, function (source, key) {
>, <Line: +				var found,
>, <Line: +					isArr,
>, <Line: +					result = source,
>, <Line: +					value = object[key];
>, <Line: +				if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
>, <Line: +					// avoid merging previously merged cyclic sources
>, <Line: +					var stackLength = stackA.length;
>, <Line: +					while (stackLength--) {
>, <Line: +						if ((found = stackA[stackLength] == source)) {
>, <Line: +							value = stackB[stackLength];
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (!found) {
>, <Line: +						var isShallow;
>, <Line: +						if (callback) {
>, <Line: +							result = callback(value, source);
>, <Line: +							if ((isShallow = typeof result != 'undefined')) {
>, <Line: +								value = result;
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (!isShallow) {
>, <Line: +							value = isArr
>, <Line: +								? (isArray(value) ? value : [])
>, <Line: +								: (isPlainObject(value) ? value : {});
>, <Line: +						}
>, <Line: +						// add `source` and associated `value` to the stack of traversed objects
>, <Line: +						stackA.push(source);
>, <Line: +						stackB.push(value);
>, <Line: +						// recursively merge objects and arrays (susceptible to call stack limits)
>, <Line: +						if (!isShallow) {
>, <Line: +							baseMerge(value, source, callback, stackA, stackB);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					if (callback) {
>, <Line: +						result = callback(value, source);
>, <Line: +						if (typeof result == 'undefined') {
>, <Line: +							result = source;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (typeof result != 'undefined') {
>, <Line: +						value = result;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				object[key] = value;
>, <Line: +			});
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.random` without argument juggling or support
>, <Line: +		 * for returning floating-point numbers.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {number} min The minimum possible value.
>, <Line: +		 * @param {number} max The maximum possible value.
>, <Line: +		 * @returns {number} Returns a random number.
>, <Line: +		 */
>, <Line: +		function baseRandom(min, max) {
>, <Line: +			return min + floor(nativeRandom() * (max - min + 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The base implementation of `_.uniq` without support for callback shorthands
>, <Line: +		 * or `thisArg` binding.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Array} array The array to process.
>, <Line: +		 * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
>, <Line: +		 * @param {Function} [callback] The function called per iteration.
>, <Line: +		 * @returns {Array} Returns a duplicate-value-free array.
>, <Line: +		 */
>, <Line: +		function baseUniq(array, isSorted, callback) {
>, <Line: +			var index = -1,
>, <Line: +				indexOf = getIndexOf(),
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				result = [];
>, <Line: +			var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
>, <Line: +				seen = (callback || isLarge) ? getArray() : result;
>, <Line: +			if (isLarge) {
>, <Line: +				var cache = createCache(seen);
>, <Line: +				indexOf = cacheIndexOf;
>, <Line: +				seen = cache;
>, <Line: +			}
>, <Line: +			while (++index < length) {
>, <Line: +				var value = array[index],
>, <Line: +					computed = callback ? callback(value, index, array) : value;
>, <Line: +				if (isSorted
>, <Line: +						? !index || seen[seen.length - 1] !== computed
>, <Line: +						: indexOf(seen, computed) < 0
>, <Line: +				) {
>, <Line: +					if (callback || isLarge) {
>, <Line: +						seen.push(computed);
>, <Line: +					}
>, <Line: +					result.push(value);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (isLarge) {
>, <Line: +				releaseArray(seen.array);
>, <Line: +				releaseObject(seen);
>, <Line: +			} else if (callback) {
>, <Line: +				releaseArray(seen);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that aggregates a collection, creating an object composed
>, <Line: +		 * of keys generated from the results of running each element of the collection
>, <Line: +		 * through a callback. The given `setter` function sets the keys and values
>, <Line: +		 * of the composed object.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Function} setter The setter function.
>, <Line: +		 * @returns {Function} Returns the new aggregator function.
>, <Line: +		 */
>, <Line: +		function createAggregator(setter) {
>, <Line: +			return function (collection, callback, thisArg) {
>, <Line: +				var result = {};
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				var index = -1,
>, <Line: +					length = collection ? collection.length : 0;
>, <Line: +				if (typeof length == 'number') {
>, <Line: +					while (++index < length) {
>, <Line: +						var value = collection[index];
>, <Line: +						setter(result, value, callback(value, index, collection), collection);
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					forOwn(collection, function (value, key, collection) {
>, <Line: +						setter(result, value, callback(value, key, collection), collection);
>, <Line: +					});
>, <Line: +				}
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that, when called, either curries or invokes `func`
>, <Line: +		 * with an optional `this` binding and partially applied arguments.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Function|string} func The function or method name to reference.
>, <Line: +		 * @param {number} bitmask The bitmask of method flags to compose.
>, <Line: +		 *  The bitmask may be composed of the following flags:
>, <Line: +		 *  1 - `_.bind`
>, <Line: +		 *  2 - `_.bindKey`
>, <Line: +		 *  4 - `_.curry`
>, <Line: +		 *  8 - `_.curry` (bound)
>, <Line: +		 *  16 - `_.partial`
>, <Line: +		 *  32 - `_.partialRight`
>, <Line: +		 * @param {Array} [partialArgs] An array of arguments to prepend to those
>, <Line: +		 *  provided to the new function.
>, <Line: +		 * @param {Array} [partialRightArgs] An array of arguments to append to those
>, <Line: +		 *  provided to the new function.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `func`.
>, <Line: +		 * @param {number} [arity] The arity of `func`.
>, <Line: +		 * @returns {Function} Returns the new function.
>, <Line: +		 */
>, <Line: +		function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
>, <Line: +			var isBind = bitmask & 1,
>, <Line: +				isBindKey = bitmask & 2,
>, <Line: +				isCurry = bitmask & 4,
>, <Line: +				isCurryBound = bitmask & 8,
>, <Line: +				isPartial = bitmask & 16,
>, <Line: +				isPartialRight = bitmask & 32;
>, <Line: +			if (!isBindKey && !isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			if (isPartial && !partialArgs.length) {
>, <Line: +				bitmask &= ~16;
>, <Line: +				isPartial = partialArgs = false;
>, <Line: +			}
>, <Line: +			if (isPartialRight && !partialRightArgs.length) {
>, <Line: +				bitmask &= ~32;
>, <Line: +				isPartialRight = partialRightArgs = false;
>, <Line: +			}
>, <Line: +			var bindData = func && func.__bindData__;
>, <Line: +			if (bindData && bindData !== true) {
>, <Line: +				// clone `bindData`
>, <Line: +				bindData = slice(bindData);
>, <Line: +				if (bindData[2]) {
>, <Line: +					bindData[2] = slice(bindData[2]);
>, <Line: +				}
>, <Line: +				if (bindData[3]) {
>, <Line: +					bindData[3] = slice(bindData[3]);
>, <Line: +				}
>, <Line: +				// set `thisBinding` is not previously bound
>, <Line: +				if (isBind && !(bindData[1] & 1)) {
>, <Line: +					bindData[4] = thisArg;
>, <Line: +				}
>, <Line: +				// set if previously bound but not currently (subsequent curried functions)
>, <Line: +				if (!isBind && bindData[1] & 1) {
>, <Line: +					bitmask |= 8;
>, <Line: +				}
>, <Line: +				// set curried arity if not yet set
>, <Line: +				if (isCurry && !(bindData[1] & 4)) {
>, <Line: +					bindData[5] = arity;
>, <Line: +				}
>, <Line: +				// append partial left arguments
>, <Line: +				if (isPartial) {
>, <Line: +					push.apply(bindData[2] || (bindData[2] = []), partialArgs);
>, <Line: +				}
>, <Line: +				// append partial right arguments
>, <Line: +				if (isPartialRight) {
>, <Line: +					unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
>, <Line: +				}
>, <Line: +				// merge flags
>, <Line: +				bindData[1] |= bitmask;
>, <Line: +				return createWrapper.apply(null, bindData);
>, <Line: +			}
>, <Line: +			// fast path for `_.bind`
>, <Line: +			var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
>, <Line: +			return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Used by `escape` to convert characters to HTML entities.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {string} match The matched character to escape.
>, <Line: +		 * @returns {string} Returns the escaped character.
>, <Line: +		 */
>, <Line: +		function escapeHtmlChar(match) {
>, <Line: +			return htmlEscapes[match];
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
>, <Line: +		 * customized, this method returns the custom method, otherwise it returns
>, <Line: +		 * the `baseIndexOf` function.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @returns {Function} Returns the "indexOf" function.
>, <Line: +		 */
>, <Line: +		function getIndexOf() {
>, <Line: +			var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a native function.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
>, <Line: +		 */
>, <Line: +		function isNative(value) {
>, <Line: +			return typeof value == 'function' && reNative.test(value);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Sets `this` binding data on a given function.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {Function} func The function to set data on.
>, <Line: +		 * @param {Array} value The data array to set.
>, <Line: +		 */
>, <Line: +		var setBindData = !defineProperty ? noop : function (func, value) {
>, <Line: +			descriptor.value = value;
>, <Line: +			defineProperty(func, '__bindData__', descriptor);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * A fallback implementation of `isPlainObject` which checks if a given value
>, <Line: +		 * is an object created by the `Object` constructor, assuming objects created
>, <Line: +		 * by the `Object` constructor have no inherited enumerable properties and that
>, <Line: +		 * there are no `Object.prototype` extensions.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
>, <Line: +		 */
>, <Line: +		function shimIsPlainObject(value) {
>, <Line: +			var ctor,
>, <Line: +				result;
>, <Line: +			// avoid non Object objects, `arguments` objects, and DOM elements
>, <Line: +			if (!(value && toString.call(value) == objectClass) ||
>, <Line: +				(ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			// In most environments an object's own properties are iterated before
>, <Line: +			// its inherited properties. If the last iterated property is an object's
>, <Line: +			// own property then there are no inherited enumerable properties.
>, <Line: +			forIn(value, function (value, key) {
>, <Line: +				result = key;
>, <Line: +			});
>, <Line: +			return typeof result == 'undefined' || hasOwnProperty.call(value, result);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Used by `unescape` to convert HTML entities to characters.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @param {string} match The matched character to unescape.
>, <Line: +		 * @returns {string} Returns the unescaped character.
>, <Line: +		 */
>, <Line: +		function unescapeHtmlChar(match) {
>, <Line: +			return htmlUnescapes[match];
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is an `arguments` object.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * (function() { return _.isArguments(arguments); })(1, 2, 3);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isArguments([1, 2, 3]);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isArguments(value) {
>, <Line: +			return value && typeof value == 'object' && typeof value.length == 'number' &&
>, <Line: +				toString.call(value) == argsClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is an array.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * (function() { return _.isArray(arguments); })();
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isArray([1, 2, 3]);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		var isArray = nativeIsArray || function (value) {
>, <Line: +				return value && typeof value == 'object' && typeof value.length == 'number' &&
>, <Line: +					toString.call(value) == arrayClass || false;
>, <Line: +			};
>, <Line: +		/**
>, <Line: +		 * A fallback implementation of `Object.keys` which produces an array of the
>, <Line: +		 * given object's own enumerable property names.
>, <Line: +		 *
>, <Line: +		 * @private
>, <Line: +		 * @type Function
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @returns {Array} Returns an array of property names.
>, <Line: +		 */
>, <Line: +		var shimKeys = function (object) {
>, <Line: +			var index, iterable = object, result = [];
>, <Line: +			if (!iterable) return result;
>, <Line: +			if (!(objectTypes[typeof object])) return result;
>, <Line: +			for (index in iterable) {
>, <Line: +				if (hasOwnProperty.call(iterable, index)) {
>, <Line: +					result.push(index);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Creates an array composed of the own enumerable property names of an object.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @returns {Array} Returns an array of property names.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: +		 * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		var keys = !nativeKeys ? shimKeys : function (object) {
>, <Line: +			if (!isObject(object)) {
>, <Line: +				return [];
>, <Line: +			}
>, <Line: +			return nativeKeys(object);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Used to convert characters to HTML entities:
>, <Line: +		 *
>, <Line: +		 * Though the `>` character is escaped for symmetry, characters like `>` and `/`
>, <Line: +		 * don't require escaping in HTML and have no special meaning unless they're part
>, <Line: +		 * of a tag or an unquoted attribute value.
>, <Line: +		 * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
>, <Line: +		 */
>, <Line: +		var htmlEscapes = {
>, <Line: +			'&': '&amp;',
>, <Line: +			'<': '&lt;',
>, <Line: +			'>': '&gt;',
>, <Line: +			'"': '&quot;',
>, <Line: +			"'": '&#39;'
>, <Line: +		};
>, <Line: +		/** Used to convert HTML entities to characters */
>, <Line: +		var htmlUnescapes = invert(htmlEscapes);
>, <Line: +		/** Used to match HTML entities and HTML characters */
>, <Line: +		var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
>, <Line: +			reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Assigns own enumerable properties of source object(s) to the destination
>, <Line: +		 * object. Subsequent sources will overwrite property assignments of previous
>, <Line: +		 * sources. If a callback is provided it will be executed to produce the
>, <Line: +		 * assigned values. The callback is bound to `thisArg` and invoked with two
>, <Line: +		 * arguments; (objectValue, sourceValue).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @alias extend
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The destination object.
>, <Line: +		 * @param {...Object} [source] The source objects.
>, <Line: +		 * @param {Function} [callback] The function to customize assigning values.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns the destination object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
>, <Line: +		 * // => { 'name': 'fred', 'employer': 'slate' }
>, <Line: +		 *
>, <Line: +		 * var defaults = _.partialRight(_.assign, function(a, b) {
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'barney' };
>, <Line: +		 * defaults(object, { 'name': 'fred', 'employer': 'slate' });
>, <Line: +		 * // => { 'name': 'barney', 'employer': 'slate' }
>, <Line: +		 */
>, <Line: +		var assign = function (object, source, guard) {
>, <Line: +			var index, iterable = object, result = iterable;
>, <Line: +			if (!iterable) return result;
>, <Line: +			var args = arguments,
>, <Line: +				argsIndex = 0,
>, <Line: +				argsLength = typeof guard == 'number' ? 2 : args.length;
>, <Line: +			if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
>, <Line: +				var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
>, <Line: +			} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
>, <Line: +				callback = args[--argsLength];
>, <Line: +			}
>, <Line: +			while (++argsIndex < argsLength) {
>, <Line: +				iterable = args[argsIndex];
>, <Line: +				if (iterable && objectTypes[typeof iterable]) {
>, <Line: +					var ownIndex = -1,
>, <Line: +						ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: +						length = ownProps ? ownProps.length : 0;
>, <Line: +					while (++ownIndex < length) {
>, <Line: +						index = ownProps[ownIndex];
>, <Line: +						result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
>, <Line: +		 * be cloned, otherwise they will be assigned by reference. If a callback
>, <Line: +		 * is provided it will be executed to produce the cloned values. If the
>, <Line: +		 * callback returns `undefined` cloning will be handled by the method instead.
>, <Line: +		 * The callback is bound to `thisArg` and invoked with one argument; (value).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to clone.
>, <Line: +		 * @param {boolean} [isDeep=false] Specify a deep clone.
>, <Line: +		 * @param {Function} [callback] The function to customize cloning values.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the cloned value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * var shallow = _.clone(characters);
>, <Line: +		 * shallow[0] === characters[0];
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * var deep = _.clone(characters, true);
>, <Line: +		 * deep[0] === characters[0];
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.mixin({
>, <Line: +		 *
>, <Line: +		 * var clone = _.clone(document.body);
>, <Line: +		 * clone.childNodes.length;
>, <Line: +		 * // => 0
>, <Line: +		 */
>, <Line: +		function clone(value, isDeep, callback, thisArg) {
>, <Line: +			// allows working with "Collections" methods without using their `index`
>, <Line: +			// and `collection` arguments for `isDeep` and `callback`
>, <Line: +			if (typeof isDeep != 'boolean' && isDeep != null) {
>, <Line: +				thisArg = callback;
>, <Line: +				callback = isDeep;
>, <Line: +				isDeep = false;
>, <Line: +			}
>, <Line: +			return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a deep clone of `value`. If a callback is provided it will be
>, <Line: +		 * executed to produce the cloned values. If the callback returns `undefined`
>, <Line: +		 * cloning will be handled by the method instead. The callback is bound to
>, <Line: +		 * `thisArg` and invoked with one argument; (value).
>, <Line: +		 *
>, <Line: +		 * Note: This method is loosely based on the structured clone algorithm. Functions
>, <Line: +		 * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
>, <Line: +		 * objects created by constructors other than `Object` are cloned to plain `Object` objects.
>, <Line: +		 * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to deep clone.
>, <Line: +		 * @param {Function} [callback] The function to customize cloning values.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the deep cloned value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * var deep = _.cloneDeep(characters);
>, <Line: +		 * deep[0] === characters[0];
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * var view = {
>, <Line: +		 *
>, <Line: +		 * var clone = _.cloneDeep(view, function(value) {
>, <Line: +		 *
>, <Line: +		 * clone.node == view.node;
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function cloneDeep(value, callback, thisArg) {
>, <Line: +			return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object that inherits from the given `prototype` object. If a
>, <Line: +		 * `properties` object is provided its own enumerable properties are assigned
>, <Line: +		 * to the created object.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} prototype The object to inherit from.
>, <Line: +		 * @param {Object} [properties] The properties to assign to the object.
>, <Line: +		 * @returns {Object} Returns the new object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * function Shape() {
>, <Line: +		 *
>, <Line: +		 * function Circle() {
>, <Line: +		 *
>, <Line: +		 * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
>, <Line: +		 *
>, <Line: +		 * var circle = new Circle;
>, <Line: +		 * circle instanceof Circle;
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * circle instanceof Shape;
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function create(prototype, properties) {
>, <Line: +			var result = baseCreate(prototype);
>, <Line: +			return properties ? assign(result, properties) : result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Assigns own enumerable properties of source object(s) to the destination
>, <Line: +		 * object for all destination properties that resolve to `undefined`. Once a
>, <Line: +		 * property is set, additional defaults of the same property will be ignored.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The destination object.
>, <Line: +		 * @param {...Object} [source] The source objects.
>, <Line: +		 * @param- {Object} [guard] Allows working with `_.reduce` without using its
>, <Line: +		 *  `key` and `object` arguments as sources.
>, <Line: +		 * @returns {Object} Returns the destination object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'barney' };
>, <Line: +		 * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
>, <Line: +		 * // => { 'name': 'barney', 'employer': 'slate' }
>, <Line: +		 */
>, <Line: +		var defaults = function (object, source, guard) {
>, <Line: +			var index, iterable = object, result = iterable;
>, <Line: +			if (!iterable) return result;
>, <Line: +			var args = arguments,
>, <Line: +				argsIndex = 0,
>, <Line: +				argsLength = typeof guard == 'number' ? 2 : args.length;
>, <Line: +			while (++argsIndex < argsLength) {
>, <Line: +				iterable = args[argsIndex];
>, <Line: +				if (iterable && objectTypes[typeof iterable]) {
>, <Line: +					var ownIndex = -1,
>, <Line: +						ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: +						length = ownProps ? ownProps.length : 0;
>, <Line: +					while (++ownIndex < length) {
>, <Line: +						index = ownProps[ownIndex];
>, <Line: +						if (typeof result[index] == 'undefined') result[index] = iterable[index];
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * This method is like `_.findIndex` except that it returns the key of the
>, <Line: +		 * first element that passes the callback check, instead of the element itself.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to search.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called per
>, <Line: +		 *  iteration. If a property name or object is provided it will be used to
>, <Line: +		 *  create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {string|undefined} Returns the key of the found element, else `undefined`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = {
>, <Line: +		 *
>, <Line: +		 * _.findKey(characters, function(chr) {
>, <Line: +		 * // => 'barney' (property order is not guaranteed across environments)
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.findKey(characters, { 'age': 1 });
>, <Line: +		 * // => 'pebbles'
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.findKey(characters, 'blocked');
>, <Line: +		 * // => 'fred'
>, <Line: +		 */
>, <Line: +		function findKey(object, callback, thisArg) {
>, <Line: +			var result;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			forOwn(object, function (value, key, object) {
>, <Line: +				if (callback(value, key, object)) {
>, <Line: +					result = key;
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.findKey` except that it iterates over elements
>, <Line: +		 * of a `collection` in the opposite order.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to search.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called per
>, <Line: +		 *  iteration. If a property name or object is provided it will be used to
>, <Line: +		 *  create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {string|undefined} Returns the key of the found element, else `undefined`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = {
>, <Line: +		 *
>, <Line: +		 * _.findLastKey(characters, function(chr) {
>, <Line: +		 * // => returns `pebbles`, assuming `_.findKey` returns `barney`
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.findLastKey(characters, { 'age': 40 });
>, <Line: +		 * // => 'fred'
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.findLastKey(characters, 'blocked');
>, <Line: +		 * // => 'pebbles'
>, <Line: +		 */
>, <Line: +		function findLastKey(object, callback, thisArg) {
>, <Line: +			var result;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			forOwnRight(object, function (value, key, object) {
>, <Line: +				if (callback(value, key, object)) {
>, <Line: +					result = key;
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Iterates over own and inherited enumerable properties of an object,
>, <Line: +		 * executing the callback for each property. The callback is bound to `thisArg`
>, <Line: +		 * and invoked with three arguments; (value, key, object). Callbacks may exit
>, <Line: +		 * iteration early by explicitly returning `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns `object`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * function Shape() {
>, <Line: +		 *
>, <Line: +		 * Shape.prototype.move = function(x, y) {
>, <Line: +		 *
>, <Line: +		 * _.forIn(new Shape, function(value, key) {
>, <Line: +		 * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		var forIn = function (collection, callback, thisArg) {
>, <Line: +			var index, iterable = collection, result = iterable;
>, <Line: +			if (!iterable) return result;
>, <Line: +			if (!objectTypes[typeof iterable]) return result;
>, <Line: +			callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: +			for (index in iterable) {
>, <Line: +				if (callback(iterable[index], index, collection) === false) return result;
>, <Line: +			}
>, <Line: +			return result
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * This method is like `_.forIn` except that it iterates over elements
>, <Line: +		 * of a `collection` in the opposite order.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns `object`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * function Shape() {
>, <Line: +		 *
>, <Line: +		 * Shape.prototype.move = function(x, y) {
>, <Line: +		 *
>, <Line: +		 * _.forInRight(new Shape, function(value, key) {
>, <Line: +		 * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
>, <Line: +		 */
>, <Line: +		function forInRight(object, callback, thisArg) {
>, <Line: +			var pairs = [];
>, <Line: +			forIn(object, function (value, key) {
>, <Line: +				pairs.push(key, value);
>, <Line: +			});
>, <Line: +			var length = pairs.length;
>, <Line: +			callback = baseCreateCallback(callback, thisArg, 3);
>, <Line: +			while (length--) {
>, <Line: +				if (callback(pairs[length--], pairs[length], object) === false) {
>, <Line: +					break;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return object;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Iterates over own enumerable properties of an object, executing the callback
>, <Line: +		 * for each property. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, key, object). Callbacks may exit iteration early by
>, <Line: +		 * explicitly returning `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns `object`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
>, <Line: +		 * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		var forOwn = function (collection, callback, thisArg) {
>, <Line: +			var index, iterable = collection, result = iterable;
>, <Line: +			if (!iterable) return result;
>, <Line: +			if (!objectTypes[typeof iterable]) return result;
>, <Line: +			callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: +			var ownIndex = -1,
>, <Line: +				ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: +				length = ownProps ? ownProps.length : 0;
>, <Line: +			while (++ownIndex < length) {
>, <Line: +				index = ownProps[ownIndex];
>, <Line: +				if (callback(iterable[index], index, collection) === false) return result;
>, <Line: +			}
>, <Line: +			return result
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * This method is like `_.forOwn` except that it iterates over elements
>, <Line: +		 * of a `collection` in the opposite order.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns `object`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
>, <Line: +		 * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
>, <Line: +		 */
>, <Line: +		function forOwnRight(object, callback, thisArg) {
>, <Line: +			var props = keys(object),
>, <Line: +				length = props.length;
>, <Line: +			callback = baseCreateCallback(callback, thisArg, 3);
>, <Line: +			while (length--) {
>, <Line: +				var key = props[length];
>, <Line: +				if (callback(object[key], key, object) === false) {
>, <Line: +					break;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return object;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a sorted array of property names of all enumerable properties,
>, <Line: +		 * own and inherited, of `object` that have function values.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias methods
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @returns {Array} Returns an array of property names that have function values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.functions(_);
>, <Line: +		 * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
>, <Line: +		 */
>, <Line: +		function functions(object) {
>, <Line: +			var result = [];
>, <Line: +			forIn(object, function (value, key) {
>, <Line: +				if (isFunction(value)) {
>, <Line: +					result.push(key);
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return result.sort();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if the specified property name exists as a direct property of `object`,
>, <Line: +		 * instead of an inherited property.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @param {string} key The name of the property to check.
>, <Line: +		 * @returns {boolean} Returns `true` if key is a direct property, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function has(object, key) {
>, <Line: +			return object ? hasOwnProperty.call(object, key) : false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object composed of the inverted keys and values of the given object.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to invert.
>, <Line: +		 * @returns {Object} Returns the created inverted object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.invert({ 'first': 'fred', 'second': 'barney' });
>, <Line: +		 * // => { 'fred': 'first', 'barney': 'second' }
>, <Line: +		 */
>, <Line: +		function invert(object) {
>, <Line: +			var index = -1,
>, <Line: +				props = keys(object),
>, <Line: +				length = props.length,
>, <Line: +				result = {};
>, <Line: +			while (++index < length) {
>, <Line: +				var key = props[index];
>, <Line: +				result[object[key]] = key;
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a boolean value.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isBoolean(null);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isBoolean(value) {
>, <Line: +			return value === true || value === false ||
>, <Line: +				value && typeof value == 'object' && toString.call(value) == boolClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a date.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isDate(new Date);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isDate(value) {
>, <Line: +			return value && typeof value == 'object' && toString.call(value) == dateClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a DOM element.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isElement(document.body);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isElement(value) {
>, <Line: +			return value && value.nodeType === 1 || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
>, <Line: +		 * length of `0` and objects with no own enumerable properties are considered
>, <Line: +		 * "empty".
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Array|Object|string} value The value to inspect.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isEmpty([1, 2, 3]);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isEmpty({});
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isEmpty('');
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isEmpty(value) {
>, <Line: +			var result = true;
>, <Line: +			if (!value) {
>, <Line: +				return result;
>, <Line: +			}
>, <Line: +			var className = toString.call(value),
>, <Line: +				length = value.length;
>, <Line: +			if ((className == arrayClass || className == stringClass || className == argsClass ) ||
>, <Line: +				(className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
>, <Line: +				return !length;
>, <Line: +			}
>, <Line: +			forOwn(value, function () {
>, <Line: +				return (result = false);
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Performs a deep comparison between two values to determine if they are
>, <Line: +		 * equivalent to each other. If a callback is provided it will be executed
>, <Line: +		 * to compare values. If the callback returns `undefined` comparisons will
>, <Line: +		 * be handled by the method instead. The callback is bound to `thisArg` and
>, <Line: +		 * invoked with two arguments; (a, b).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} a The value to compare.
>, <Line: +		 * @param {*} b The other value to compare.
>, <Line: +		 * @param {Function} [callback] The function to customize comparing values.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'fred' };
>, <Line: +		 * var copy = { 'name': 'fred' };
>, <Line: +		 *
>, <Line: +		 * object == copy;
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isEqual(object, copy);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * var words = ['hello', 'goodbye'];
>, <Line: +		 * var otherWords = ['hi', 'goodbye'];
>, <Line: +		 *
>, <Line: +		 * _.isEqual(words, otherWords, function(a, b) {
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isEqual(a, b, callback, thisArg) {
>, <Line: +			return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is, or can be coerced to, a finite number.
>, <Line: +		 *
>, <Line: +		 * Note: This is not the same as native `isFinite` which will return true for
>, <Line: +		 * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isFinite(-101);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isFinite('10');
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isFinite(true);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isFinite('');
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isFinite(Infinity);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isFinite(value) {
>, <Line: +			return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isFunction(_);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isFunction(value) {
>, <Line: +			return typeof value == 'function';
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is the language type of Object.
>, <Line: +		 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isObject({});
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isObject([1, 2, 3]);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isObject(1);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isObject(value) {
>, <Line: +			// check if the value is the ECMAScript language type of Object
>, <Line: +			// http://es5.github.io/#x8
>, <Line: +			// and avoid a V8 bug
>, <Line: +			// http://code.google.com/p/v8/issues/detail?id=2291
>, <Line: +			return !!(value && objectTypes[typeof value]);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is `NaN`.
>, <Line: +		 *
>, <Line: +		 * Note: This is not the same as native `isNaN` which will return `true` for
>, <Line: +		 * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isNaN(NaN);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isNaN(new Number(NaN));
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * isNaN(undefined);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isNaN(undefined);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isNaN(value) {
>, <Line: +			// `NaN` as a primitive is the only value that is not equal to itself
>, <Line: +			// (perform the [[Class]] check first to avoid errors with some host objects in IE)
>, <Line: +			return isNumber(value) && value != +value;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is `null`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isNull(null);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.isNull(undefined);
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function isNull(value) {
>, <Line: +			return value === null;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a number.
>, <Line: +		 *
>, <Line: +		 * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isNumber(8.4 * 5);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isNumber(value) {
>, <Line: +			return typeof value == 'number' ||
>, <Line: +				value && typeof value == 'object' && toString.call(value) == numberClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is an object created by the `Object` constructor.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * function Shape() {
>, <Line: +		 *
>, <Line: +		 * _.isPlainObject(new Shape);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isPlainObject([1, 2, 3]);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.isPlainObject({ 'x': 0, 'y': 0 });
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
>, <Line: +			if (!(value && toString.call(value) == objectClass)) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			var valueOf = value.valueOf,
>, <Line: +				objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
>, <Line: +			return objProto
>, <Line: +				? (value == objProto || getPrototypeOf(value) == objProto)
>, <Line: +				: shimIsPlainObject(value);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a regular expression.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isRegExp(/fred/);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isRegExp(value) {
>, <Line: +			return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is a string.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isString('fred');
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isString(value) {
>, <Line: +			return typeof value == 'string' ||
>, <Line: +				value && typeof value == 'object' && toString.call(value) == stringClass || false;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if `value` is `undefined`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {*} value The value to check.
>, <Line: +		 * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.isUndefined(void 0);
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function isUndefined(value) {
>, <Line: +			return typeof value == 'undefined';
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object with the same keys as `object` and values generated by
>, <Line: +		 * running each own enumerable property of `object` through the callback.
>, <Line: +		 * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, key, object).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new object with values of the results of each `callback` execution.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
>, <Line: +		 * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: +		 *
>, <Line: +		 * var characters = {
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.mapValues(characters, 'age');
>, <Line: +		 * // => { 'fred': 40, 'pebbles': 1 }
>, <Line: +		 */
>, <Line: +		function mapValues(object, callback, thisArg) {
>, <Line: +			var result = {};
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			forOwn(object, function (value, key, object) {
>, <Line: +				result[key] = callback(value, key, object);
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Recursively merges own enumerable properties of the source object(s), that
>, <Line: +		 * don't resolve to `undefined` into the destination object. Subsequent sources
>, <Line: +		 * will overwrite property assignments of previous sources. If a callback is
>, <Line: +		 * provided it will be executed to produce the merged values of the destination
>, <Line: +		 * and source properties. If the callback returns `undefined` merging will
>, <Line: +		 * be handled by the method instead. The callback is bound to `thisArg` and
>, <Line: +		 * invoked with two arguments; (objectValue, sourceValue).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The destination object.
>, <Line: +		 * @param {...Object} [source] The source objects.
>, <Line: +		 * @param {Function} [callback] The function to customize merging properties.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns the destination object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var names = {
>, <Line: +		 *
>, <Line: +		 * var ages = {
>, <Line: +		 *
>, <Line: +		 * _.merge(names, ages);
>, <Line: +		 * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
>, <Line: +		 *
>, <Line: +		 * var food = {
>, <Line: +		 *
>, <Line: +		 * var otherFood = {
>, <Line: +		 *
>, <Line: +		 * _.merge(food, otherFood, function(a, b) {
>, <Line: +		 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
>, <Line: +		 */
>, <Line: +		function merge(object) {
>, <Line: +			var args = arguments,
>, <Line: +				length = 2;
>, <Line: +			if (!isObject(object)) {
>, <Line: +				return object;
>, <Line: +			}
>, <Line: +			// allows working with `_.reduce` and `_.reduceRight` without using
>, <Line: +			// their `index` and `collection` arguments
>, <Line: +			if (typeof args[2] != 'number') {
>, <Line: +				length = args.length;
>, <Line: +			}
>, <Line: +			if (length > 3 && typeof args[length - 2] == 'function') {
>, <Line: +				var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
>, <Line: +			} else if (length > 2 && typeof args[length - 1] == 'function') {
>, <Line: +				callback = args[--length];
>, <Line: +			}
>, <Line: +			var sources = slice(arguments, 1, length),
>, <Line: +				index = -1,
>, <Line: +				stackA = getArray(),
>, <Line: +				stackB = getArray();
>, <Line: +			while (++index < length) {
>, <Line: +				baseMerge(object, sources[index], callback, stackA, stackB);
>, <Line: +			}
>, <Line: +			releaseArray(stackA);
>, <Line: +			releaseArray(stackB);
>, <Line: +			return object;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a shallow clone of `object` excluding the specified properties.
>, <Line: +		 * Property names may be specified as individual arguments or as arrays of
>, <Line: +		 * property names. If a callback is provided it will be executed for each
>, <Line: +		 * property of `object` omitting the properties the callback returns truey
>, <Line: +		 * for. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, key, object).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The source object.
>, <Line: +		 * @param {Function|...string|string[]} [callback] The properties to omit or the
>, <Line: +		 *  function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns an object without the omitted properties.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
>, <Line: +		 * // => { 'name': 'fred' }
>, <Line: +		 *
>, <Line: +		 * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
>, <Line: +		 * // => { 'name': 'fred' }
>, <Line: +		 */
>, <Line: +		function omit(object, callback, thisArg) {
>, <Line: +			var result = {};
>, <Line: +			if (typeof callback != 'function') {
>, <Line: +				var props = [];
>, <Line: +				forIn(object, function (value, key) {
>, <Line: +					props.push(key);
>, <Line: +				});
>, <Line: +				props = baseDifference(props, baseFlatten(arguments, true, false, 1));
>, <Line: +				var index = -1,
>, <Line: +					length = props.length;
>, <Line: +				while (++index < length) {
>, <Line: +					var key = props[index];
>, <Line: +					result[key] = object[key];
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				forIn(object, function (value, key, object) {
>, <Line: +					if (!callback(value, key, object)) {
>, <Line: +						result[key] = value;
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a two dimensional array of an object's key-value pairs,
>, <Line: +		 * i.e. `[[key1, value1], [key2, value2]]`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @returns {Array} Returns new array of key-value pairs.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.pairs({ 'barney': 36, 'fred': 40 });
>, <Line: +		 * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		function pairs(object) {
>, <Line: +			var index = -1,
>, <Line: +				props = keys(object),
>, <Line: +				length = props.length,
>, <Line: +				result = Array(length);
>, <Line: +			while (++index < length) {
>, <Line: +				var key = props[index];
>, <Line: +				result[index] = [key, object[key]];
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a shallow clone of `object` composed of the specified properties.
>, <Line: +		 * Property names may be specified as individual arguments or as arrays of
>, <Line: +		 * property names. If a callback is provided it will be executed for each
>, <Line: +		 * property of `object` picking the properties the callback returns truey
>, <Line: +		 * for. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, key, object).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The source object.
>, <Line: +		 * @param {Function|...string|string[]} [callback] The function called per
>, <Line: +		 *  iteration or property names to pick, specified as individual property
>, <Line: +		 *  names or arrays of property names.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns an object composed of the picked properties.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
>, <Line: +		 * // => { 'name': 'fred' }
>, <Line: +		 *
>, <Line: +		 * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
>, <Line: +		 * // => { 'name': 'fred' }
>, <Line: +		 */
>, <Line: +		function pick(object, callback, thisArg) {
>, <Line: +			var result = {};
>, <Line: +			if (typeof callback != 'function') {
>, <Line: +				var index = -1,
>, <Line: +					props = baseFlatten(arguments, true, false, 1),
>, <Line: +					length = isObject(object) ? props.length : 0;
>, <Line: +				while (++index < length) {
>, <Line: +					var key = props[index];
>, <Line: +					if (key in object) {
>, <Line: +						result[key] = object[key];
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				forIn(object, function (value, key, object) {
>, <Line: +					if (callback(value, key, object)) {
>, <Line: +						result[key] = value;
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * An alternative to `_.reduce` this method transforms `object` to a new
>, <Line: +		 * `accumulator` object which is the result of running each of its own
>, <Line: +		 * enumerable properties through a callback, with each callback execution
>, <Line: +		 * potentially mutating the `accumulator` object. The callback is bound to
>, <Line: +		 * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
>, <Line: +		 * Callbacks may exit iteration early by explicitly returning `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Array|Object} object The object to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [accumulator] The custom accumulator value.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the accumulated value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
>, <Line: +		 * // => [1, 9, 25]
>, <Line: +		 *
>, <Line: +		 * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
>, <Line: +		 * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: +		 */
>, <Line: +		function transform(object, callback, accumulator, thisArg) {
>, <Line: +			var isArr = isArray(object);
>, <Line: +			if (accumulator == null) {
>, <Line: +				if (isArr) {
>, <Line: +					accumulator = [];
>, <Line: +				} else {
>, <Line: +					var ctor = object && object.constructor,
>, <Line: +						proto = ctor && ctor.prototype;
>, <Line: +					accumulator = baseCreate(proto);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (callback) {
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: +				(isArr ? forEach : forOwn)(object, function (value, index, object) {
>, <Line: +					return callback(accumulator, value, index, object);
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return accumulator;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array composed of the own enumerable property values of `object`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Objects
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @returns {Array} Returns an array of property values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.values({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: +		 * // => [1, 2, 3] (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		function values(object) {
>, <Line: +			var index = -1,
>, <Line: +				props = keys(object),
>, <Line: +				length = props.length,
>, <Line: +				result = Array(length);
>, <Line: +			while (++index < length) {
>, <Line: +				result[index] = object[props[index]];
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates an array of elements from the specified indexes, or keys, of the
>, <Line: +		 * `collection`. Indexes may be specified as individual arguments or as arrays
>, <Line: +		 * of indexes.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
>, <Line: +		 *   to retrieve, specified as individual indexes or arrays of indexes.
>, <Line: +		 * @returns {Array} Returns a new array of elements corresponding to the
>, <Line: +		 *  provided indexes.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
>, <Line: +		 * // => ['a', 'c', 'e']
>, <Line: +		 *
>, <Line: +		 * _.at(['fred', 'barney', 'pebbles'], 0, 2);
>, <Line: +		 * // => ['fred', 'pebbles']
>, <Line: +		 */
>, <Line: +		function at(collection) {
>, <Line: +			var args = arguments,
>, <Line: +				index = -1,
>, <Line: +				props = baseFlatten(args, true, false, 1),
>, <Line: +				length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
>, <Line: +				result = Array(length);
>, <Line: +			while (++index < length) {
>, <Line: +				result[index] = collection[props[index]];
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if a given value is present in a collection using strict equality
>, <Line: +		 * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
>, <Line: +		 * offset from the end of the collection.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias include
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {*} target The value to check for.
>, <Line: +		 * @param {number} [fromIndex=0] The index to search from.
>, <Line: +		 * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.contains([1, 2, 3], 1);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.contains([1, 2, 3], 1, 2);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * _.contains('pebbles', 'eb');
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function contains(collection, target, fromIndex) {
>, <Line: +			var index = -1,
>, <Line: +				indexOf = getIndexOf(),
>, <Line: +				length = collection ? collection.length : 0,
>, <Line: +				result = false;
>, <Line: +			fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
>, <Line: +			if (isArray(collection)) {
>, <Line: +				result = indexOf(collection, target, fromIndex) > -1;
>, <Line: +			} else if (typeof length == 'number') {
>, <Line: +				result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
>, <Line: +			} else {
>, <Line: +				forOwn(collection, function (value) {
>, <Line: +					if (++index >= fromIndex) {
>, <Line: +						return !(result = value === target);
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object composed of keys generated from the results of running
>, <Line: +		 * each element of `collection` through the callback. The corresponding value
>, <Line: +		 * of each key is the number of times the key was returned by the callback.
>, <Line: +		 * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns the composed aggregate object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
>, <Line: +		 * // => { '4': 1, '6': 2 }
>, <Line: +		 *
>, <Line: +		 * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
>, <Line: +		 * // => { '4': 1, '6': 2 }
>, <Line: +		 *
>, <Line: +		 * _.countBy(['one', 'two', 'three'], 'length');
>, <Line: +		 * // => { '3': 2, '5': 1 }
>, <Line: +		 */
>, <Line: +		var countBy = createAggregator(function (result, value, key) {
>, <Line: +			(hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
>, <Line: +		});
>, <Line: +		/**
>, <Line: +		 * Checks if the given callback returns truey value for **all** elements of
>, <Line: +		 * a collection. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias all
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {boolean} Returns `true` if all elements passed the callback check,
>, <Line: +		 *  else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.every([true, 1, null, 'yes']);
>, <Line: +		 * // => false
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.every(characters, 'age');
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.every(characters, { 'age': 36 });
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function every(collection, callback, thisArg) {
>, <Line: +			var result = true;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (++index < length) {
>, <Line: +					if (!(result = !!callback(collection[index], index, collection))) {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				forOwn(collection, function (value, index, collection) {
>, <Line: +					return (result = !!callback(value, index, collection));
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Iterates over elements of a collection, returning an array of all elements
>, <Line: +		 * the callback returns truey for. The callback is bound to `thisArg` and
>, <Line: +		 * invoked with three arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias select
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new array of elements that passed the callback check.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
>, <Line: +		 * // => [2, 4, 6]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: +		 *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.filter(characters, 'blocked');
>, <Line: +		 * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.filter(characters, { 'age': 36 });
>, <Line: +		 * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
>, <Line: +		 */
>, <Line: +		function filter(collection, callback, thisArg) {
>, <Line: +			var result = [];
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (++index < length) {
>, <Line: +					var value = collection[index];
>, <Line: +					if (callback(value, index, collection)) {
>, <Line: +						result.push(value);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				forOwn(collection, function (value, index, collection) {
>, <Line: +					if (callback(value, index, collection)) {
>, <Line: +						result.push(value);
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Iterates over elements of a collection, returning the first element that
>, <Line: +		 * the callback returns truey for. The callback is bound to `thisArg` and
>, <Line: +		 * invoked with three arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias detect, findWhere
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the found element, else `undefined`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'age': 36, 'blocked': false },
>, <Line: +		 *   { 'name': 'fred',    'age': 40, 'blocked': true },
>, <Line: +		 *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.find(characters, function(chr) {
>, <Line: +		 * // => { 'name': 'barney', 'age': 36, 'blocked': false }
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.find(characters, { 'age': 1 });
>, <Line: +		 * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.find(characters, 'blocked');
>, <Line: +		 * // => { 'name': 'fred', 'age': 40, 'blocked': true }
>, <Line: +		 */
>, <Line: +		function find(collection, callback, thisArg) {
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (++index < length) {
>, <Line: +					var value = collection[index];
>, <Line: +					if (callback(value, index, collection)) {
>, <Line: +						return value;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				var result;
>, <Line: +				forOwn(collection, function (value, index, collection) {
>, <Line: +					if (callback(value, index, collection)) {
>, <Line: +						result = value;
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +				});
>, <Line: +				return result;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.find` except that it iterates over elements
>, <Line: +		 * of a `collection` from right to left.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the found element, else `undefined`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.findLast([1, 2, 3, 4], function(num) {
>, <Line: +		 * // => 3
>, <Line: +		 */
>, <Line: +		function findLast(collection, callback, thisArg) {
>, <Line: +			var result;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			forEachRight(collection, function (value, index, collection) {
>, <Line: +				if (callback(value, index, collection)) {
>, <Line: +					result = value;
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Iterates over elements of a collection, executing the callback for each
>, <Line: +		 * element. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, index|key, collection). Callbacks may exit iteration early by
>, <Line: +		 * explicitly returning `false`.
>, <Line: +		 *
>, <Line: +		 * Note: As with other "Collections" methods, objects with a `length` property
>, <Line: +		 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
>, <Line: +		 * may be used for object iteration.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias each
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array|Object|string} Returns `collection`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
>, <Line: +		 * // => logs each number and returns '1,2,3'
>, <Line: +		 *
>, <Line: +		 * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
>, <Line: +		 * // => logs each number and returns the object (property order is not guaranteed across environments)
>, <Line: +		 */
>, <Line: +		function forEach(collection, callback, thisArg) {
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (++index < length) {
>, <Line: +					if (callback(collection[index], index, collection) === false) {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				forOwn(collection, callback);
>, <Line: +			}
>, <Line: +			return collection;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.forEach` except that it iterates over elements
>, <Line: +		 * of a `collection` from right to left.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias eachRight
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array|Object|string} Returns `collection`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
>, <Line: +		 * // => logs each number from right to left and returns '3,2,1'
>, <Line: +		 */
>, <Line: +		function forEachRight(collection, callback, thisArg) {
>, <Line: +			var length = collection ? collection.length : 0;
>, <Line: +			callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (length--) {
>, <Line: +					if (callback(collection[length], length, collection) === false) {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				var props = keys(collection);
>, <Line: +				length = props.length;
>, <Line: +				forOwn(collection, function (value, key, collection) {
>, <Line: +					key = props ? props[--length] : --length;
>, <Line: +					return callback(collection[key], key, collection);
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return collection;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object composed of keys generated from the results of running
>, <Line: +		 * each element of a collection through the callback. The corresponding value
>, <Line: +		 * of each key is an array of the elements responsible for generating the key.
>, <Line: +		 * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns the composed aggregate object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
>, <Line: +		 * // => { '4': [4.2], '6': [6.1, 6.4] }
>, <Line: +		 *
>, <Line: +		 * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
>, <Line: +		 * // => { '4': [4.2], '6': [6.1, 6.4] }
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.groupBy(['one', 'two', 'three'], 'length');
>, <Line: +		 * // => { '3': ['one', 'two'], '5': ['three'] }
>, <Line: +		 */
>, <Line: +		var groupBy = createAggregator(function (result, value, key) {
>, <Line: +			(hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
>, <Line: +		});
>, <Line: +		/**
>, <Line: +		 * Creates an object composed of keys generated from the results of running
>, <Line: +		 * each element of the collection through the given callback. The corresponding
>, <Line: +		 * value of each key is the last element responsible for generating the key.
>, <Line: +		 * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: +		 * (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Object} Returns the composed aggregate object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var keys = [
>, <Line: +		 *   { 'dir': 'left', 'code': 97 },
>, <Line: +		 *   { 'dir': 'right', 'code': 100 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.indexBy(keys, 'dir');
>, <Line: +		 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
>, <Line: +		 *
>, <Line: +		 * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
>, <Line: +		 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
>, <Line: +		 *
>, <Line: +		 * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
>, <Line: +		 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
>, <Line: +		 */
>, <Line: +		var indexBy = createAggregator(function (result, value, key) {
>, <Line: +			result[key] = value;
>, <Line: +		});
>, <Line: +		/**
>, <Line: +		 * Invokes the method named by `methodName` on each element in the `collection`
>, <Line: +		 * returning an array of the results of each invoked method. Additional arguments
>, <Line: +		 * will be provided to each invoked method. If `methodName` is a function it
>, <Line: +		 * will be invoked for, and `this` bound to, each element in the `collection`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|string} methodName The name of the method to invoke or
>, <Line: +		 *  the function invoked per iteration.
>, <Line: +		 * @param {...*} [arg] Arguments to invoke the method with.
>, <Line: +		 * @returns {Array} Returns a new array of the results of each invoked method.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
>, <Line: +		 * // => [[1, 5, 7], [1, 2, 3]]
>, <Line: +		 *
>, <Line: +		 * _.invoke([123, 456], String.prototype.split, '');
>, <Line: +		 * // => [['1', '2', '3'], ['4', '5', '6']]
>, <Line: +		 */
>, <Line: +		function invoke(collection, methodName) {
>, <Line: +			var args = slice(arguments, 2),
>, <Line: +				index = -1,
>, <Line: +				isFunc = typeof methodName == 'function',
>, <Line: +				length = collection ? collection.length : 0,
>, <Line: +				result = Array(typeof length == 'number' ? length : 0);
>, <Line: +			forEach(collection, function (value) {
>, <Line: +				result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of values by running each element in the collection
>, <Line: +		 * through the callback. The callback is bound to `thisArg` and invoked with
>, <Line: +		 * three arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias collect
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new array of the results of each `callback` execution.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.map([1, 2, 3], function(num) { return num * 3; });
>, <Line: +		 * // => [3, 6, 9]
>, <Line: +		 *
>, <Line: +		 * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
>, <Line: +		 * // => [3, 6, 9] (property order is not guaranteed across environments)
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.map(characters, 'name');
>, <Line: +		 * // => ['barney', 'fred']
>, <Line: +		 */
>, <Line: +		function map(collection, callback, thisArg) {
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				var result = Array(length);
>, <Line: +				while (++index < length) {
>, <Line: +					result[index] = callback(collection[index], index, collection);
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				result = [];
>, <Line: +				forOwn(collection, function (value, key, collection) {
>, <Line: +					result[++index] = callback(value, key, collection);
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Retrieves the maximum value of a collection. If the collection is empty or
>, <Line: +		 * falsey `-Infinity` is returned. If a callback is provided it will be executed
>, <Line: +		 * for each value in the collection to generate the criterion by which the value
>, <Line: +		 * is ranked. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, index, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the maximum value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.max([4, 2, 8, 6]);
>, <Line: +		 * // => 8
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.max(characters, function(chr) { return chr.age; });
>, <Line: +		 * // => { 'name': 'fred', 'age': 40 };
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.max(characters, 'age');
>, <Line: +		 * // => { 'name': 'fred', 'age': 40 };
>, <Line: +		 */
>, <Line: +		function max(collection, callback, thisArg) {
>, <Line: +			var computed = -Infinity,
>, <Line: +				result = computed;
>, <Line: +			// allows working with functions like `_.map` without using
>, <Line: +			// their `index` argument as a callback
>, <Line: +			if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
>, <Line: +				callback = null;
>, <Line: +			}
>, <Line: +			if (callback == null && isArray(collection)) {
>, <Line: +				var index = -1,
>, <Line: +					length = collection.length;
>, <Line: +				while (++index < length) {
>, <Line: +					var value = collection[index];
>, <Line: +					if (value > result) {
>, <Line: +						result = value;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				callback = (callback == null && isString(collection))
>, <Line: +					? charAtCallback
>, <Line: +					: lodash.createCallback(callback, thisArg, 3);
>, <Line: +				forEach(collection, function (value, index, collection) {
>, <Line: +					var current = callback(value, index, collection);
>, <Line: +					if (current > computed) {
>, <Line: +						computed = current;
>, <Line: +						result = value;
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Retrieves the minimum value of a collection. If the collection is empty or
>, <Line: +		 * falsey `Infinity` is returned. If a callback is provided it will be executed
>, <Line: +		 * for each value in the collection to generate the criterion by which the value
>, <Line: +		 * is ranked. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, index, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the minimum value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.min([4, 2, 8, 6]);
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.min(characters, function(chr) { return chr.age; });
>, <Line: +		 * // => { 'name': 'barney', 'age': 36 };
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.min(characters, 'age');
>, <Line: +		 * // => { 'name': 'barney', 'age': 36 };
>, <Line: +		 */
>, <Line: +		function min(collection, callback, thisArg) {
>, <Line: +			var computed = Infinity,
>, <Line: +				result = computed;
>, <Line: +			// allows working with functions like `_.map` without using
>, <Line: +			// their `index` argument as a callback
>, <Line: +			if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
>, <Line: +				callback = null;
>, <Line: +			}
>, <Line: +			if (callback == null && isArray(collection)) {
>, <Line: +				var index = -1,
>, <Line: +					length = collection.length;
>, <Line: +				while (++index < length) {
>, <Line: +					var value = collection[index];
>, <Line: +					if (value < result) {
>, <Line: +						result = value;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				callback = (callback == null && isString(collection))
>, <Line: +					? charAtCallback
>, <Line: +					: lodash.createCallback(callback, thisArg, 3);
>, <Line: +				forEach(collection, function (value, index, collection) {
>, <Line: +					var current = callback(value, index, collection);
>, <Line: +					if (current < computed) {
>, <Line: +						computed = current;
>, <Line: +						result = value;
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Retrieves the value of a specified property from all elements in the collection.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {string} property The name of the property to pluck.
>, <Line: +		 * @returns {Array} Returns a new array of property values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.pluck(characters, 'name');
>, <Line: +		 * // => ['barney', 'fred']
>, <Line: +		 */
>, <Line: +		var pluck = map;
>, <Line: +		/**
>, <Line: +		 * Reduces a collection to a value which is the accumulated result of running
>, <Line: +		 * each element in the collection through the callback, where each successive
>, <Line: +		 * callback execution consumes the return value of the previous execution. If
>, <Line: +		 * `accumulator` is not provided the first element of the collection will be
>, <Line: +		 * used as the initial `accumulator` value. The callback is bound to `thisArg`
>, <Line: +		 * and invoked with four arguments; (accumulator, value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias foldl, inject
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [accumulator] Initial value of the accumulator.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the accumulated value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var sum = _.reduce([1, 2, 3], function(sum, num) {
>, <Line: +		 * // => 6
>, <Line: +		 *
>, <Line: +		 * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
>, <Line: +		 * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: +		 */
>, <Line: +		function reduce(collection, callback, accumulator, thisArg) {
>, <Line: +			if (!collection) return accumulator;
>, <Line: +			var noaccum = arguments.length < 3;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: +			var index = -1,
>, <Line: +				length = collection.length;
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				if (noaccum) {
>, <Line: +					accumulator = collection[++index];
>, <Line: +				}
>, <Line: +				while (++index < length) {
>, <Line: +					accumulator = callback(accumulator, collection[index], index, collection);
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				forOwn(collection, function (value, index, collection) {
>, <Line: +					accumulator = noaccum
>, <Line: +						? (noaccum = false, value)
>, <Line: +						: callback(accumulator, value, index, collection)
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return accumulator;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.reduce` except that it iterates over elements
>, <Line: +		 * of a `collection` from right to left.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias foldr
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function} [callback=identity] The function called per iteration.
>, <Line: +		 * @param {*} [accumulator] Initial value of the accumulator.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the accumulated value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var list = [[0, 1], [2, 3], [4, 5]];
>, <Line: +		 * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
>, <Line: +		 * // => [4, 5, 2, 3, 0, 1]
>, <Line: +		 */
>, <Line: +		function reduceRight(collection, callback, accumulator, thisArg) {
>, <Line: +			var noaccum = arguments.length < 3;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: +			forEachRight(collection, function (value, index, collection) {
>, <Line: +				accumulator = noaccum
>, <Line: +					? (noaccum = false, value)
>, <Line: +					: callback(accumulator, value, index, collection);
>, <Line: +			});
>, <Line: +			return accumulator;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The opposite of `_.filter` this method returns the elements of a
>, <Line: +		 * collection that the callback does **not** return truey for.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new array of elements that failed the callback check.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
>, <Line: +		 * // => [1, 3, 5]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: +		 *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.reject(characters, 'blocked');
>, <Line: +		 * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.reject(characters, { 'age': 36 });
>, <Line: +		 * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
>, <Line: +		 */
>, <Line: +		function reject(collection, callback, thisArg) {
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			return filter(collection, function (value, index, collection) {
>, <Line: +				return !callback(value, index, collection);
>, <Line: +			});
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Retrieves a random element or `n` random elements from a collection.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to sample.
>, <Line: +		 * @param {number} [n] The number of elements to sample.
>, <Line: +		 * @param- {Object} [guard] Allows working with functions like `_.map`
>, <Line: +		 *  without using their `index` arguments as `n`.
>, <Line: +		 * @returns {Array} Returns the random sample(s) of `collection`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.sample([1, 2, 3, 4]);
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * _.sample([1, 2, 3, 4], 2);
>, <Line: +		 * // => [3, 1]
>, <Line: +		 */
>, <Line: +		function sample(collection, n, guard) {
>, <Line: +			if (collection && typeof collection.length != 'number') {
>, <Line: +				collection = values(collection);
>, <Line: +			}
>, <Line: +			if (n == null || guard) {
>, <Line: +				return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
>, <Line: +			}
>, <Line: +			var result = shuffle(collection);
>, <Line: +			result.length = nativeMin(nativeMax(0, n), result.length);
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of shuffled values, using a version of the Fisher-Yates
>, <Line: +		 * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to shuffle.
>, <Line: +		 * @returns {Array} Returns a new shuffled collection.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.shuffle([1, 2, 3, 4, 5, 6]);
>, <Line: +		 * // => [4, 1, 6, 3, 5, 2]
>, <Line: +		 */
>, <Line: +		function shuffle(collection) {
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0,
>, <Line: +				result = Array(typeof length == 'number' ? length : 0);
>, <Line: +			forEach(collection, function (value) {
>, <Line: +				var rand = baseRandom(0, ++index);
>, <Line: +				result[index] = result[rand];
>, <Line: +				result[rand] = value;
>, <Line: +			});
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the size of the `collection` by returning `collection.length` for arrays
>, <Line: +		 * and array-like objects or the number of own enumerable properties for objects.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to inspect.
>, <Line: +		 * @returns {number} Returns `collection.length` or number of own enumerable properties.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.size([1, 2]);
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * _.size({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: +		 * // => 3
>, <Line: +		 *
>, <Line: +		 * _.size('pebbles');
>, <Line: +		 * // => 7
>, <Line: +		 */
>, <Line: +		function size(collection) {
>, <Line: +			var length = collection ? collection.length : 0;
>, <Line: +			return typeof length == 'number' ? length : keys(collection).length;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Checks if the callback returns a truey value for **any** element of a
>, <Line: +		 * collection. The function returns as soon as it finds a passing value and
>, <Line: +		 * does not iterate over the entire collection. The callback is bound to
>, <Line: +		 * `thisArg` and invoked with three arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias any
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {boolean} Returns `true` if any element passed the callback check,
>, <Line: +		 *  else `false`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.some([null, 0, 'yes', false], Boolean);
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: +		 *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.some(characters, 'blocked');
>, <Line: +		 * // => true
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.some(characters, { 'age': 1 });
>, <Line: +		 * // => false
>, <Line: +		 */
>, <Line: +		function some(collection, callback, thisArg) {
>, <Line: +			var result;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			var index = -1,
>, <Line: +				length = collection ? collection.length : 0;
>, <Line: +			if (typeof length == 'number') {
>, <Line: +				while (++index < length) {
>, <Line: +					if ((result = callback(collection[index], index, collection))) {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				forOwn(collection, function (value, index, collection) {
>, <Line: +					return !(result = callback(value, index, collection));
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return !!result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of elements, sorted in ascending order by the results of
>, <Line: +		 * running each element in a collection through the callback. This method
>, <Line: +		 * performs a stable sort, that is, it will preserve the original sort order
>, <Line: +		 * of equal elements. The callback is bound to `thisArg` and invoked with
>, <Line: +		 * three arguments; (value, index|key, collection).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an array of property names is provided for `callback` the collection
>, <Line: +		 * will be sorted by each property value.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Array|Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new array of sorted elements.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
>, <Line: +		 * // => [3, 1, 2]
>, <Line: +		 *
>, <Line: +		 * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
>, <Line: +		 * // => [3, 1, 2]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'age': 36 },
>, <Line: +		 *   { 'name': 'fred',    'age': 40 },
>, <Line: +		 *   { 'name': 'barney',  'age': 26 },
>, <Line: +		 *   { 'name': 'fred',    'age': 30 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.map(_.sortBy(characters, 'age'), _.values);
>, <Line: +		 * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
>, <Line: +		 *
>, <Line: +		 * // sorting by multiple properties
>, <Line: +		 * _.map(_.sortBy(characters, ['name', 'age']), _.values);
>, <Line: +		 * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
>, <Line: +		 */
>, <Line: +		function sortBy(collection, callback, thisArg) {
>, <Line: +			var index = -1,
>, <Line: +				isArr = isArray(callback),
>, <Line: +				length = collection ? collection.length : 0,
>, <Line: +				result = Array(typeof length == 'number' ? length : 0);
>, <Line: +			if (!isArr) {
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			}
>, <Line: +			forEach(collection, function (value, key, collection) {
>, <Line: +				var object = result[++index] = getObject();
>, <Line: +				if (isArr) {
>, <Line: +					object.criteria = map(callback, function (key) {
>, <Line: +						return value[key];
>, <Line: +					});
>, <Line: +				} else {
>, <Line: +					(object.criteria = getArray())[0] = callback(value, key, collection);
>, <Line: +				}
>, <Line: +				object.index = index;
>, <Line: +				object.value = value;
>, <Line: +			});
>, <Line: +			length = result.length;
>, <Line: +			result.sort(compareAscending);
>, <Line: +			while (length--) {
>, <Line: +				var object = result[length];
>, <Line: +				result[length] = object.value;
>, <Line: +				if (!isArr) {
>, <Line: +					releaseArray(object.criteria);
>, <Line: +				}
>, <Line: +				releaseObject(object);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Converts the `collection` to an array.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to convert.
>, <Line: +		 * @returns {Array} Returns the new converted array.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
>, <Line: +		 * // => [2, 3, 4]
>, <Line: +		 */
>, <Line: +		function toArray(collection) {
>, <Line: +			if (collection && typeof collection.length == 'number') {
>, <Line: +				return slice(collection);
>, <Line: +			}
>, <Line: +			return values(collection);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Performs a deep comparison of each element in a `collection` to the given
>, <Line: +		 * `properties` object, returning an array of all elements that have equivalent
>, <Line: +		 * property values.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type Function
>, <Line: +		 * @category Collections
>, <Line: +		 * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: +		 * @param {Object} props The object of property values to filter by.
>, <Line: +		 * @returns {Array} Returns a new array of elements that have the given properties.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
>, <Line: +		 *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.where(characters, { 'age': 36 });
>, <Line: +		 * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
>, <Line: +		 *
>, <Line: +		 * _.where(characters, { 'pets': ['dino'] });
>, <Line: +		 * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
>, <Line: +		 */
>, <Line: +		var where = filter;
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates an array with all falsey values removed. The values `false`, `null`,
>, <Line: +		 * `0`, `""`, `undefined`, and `NaN` are all falsey.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to compact.
>, <Line: +		 * @returns {Array} Returns a new array of filtered values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.compact([0, 1, false, 2, '', 3]);
>, <Line: +		 * // => [1, 2, 3]
>, <Line: +		 */
>, <Line: +		function compact(array) {
>, <Line: +			var index = -1,
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				result = [];
>, <Line: +			while (++index < length) {
>, <Line: +				var value = array[index];
>, <Line: +				if (value) {
>, <Line: +					result.push(value);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array excluding all values of the provided arrays using strict
>, <Line: +		 * equality for comparisons, i.e. `===`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to process.
>, <Line: +		 * @param {...Array} [values] The arrays of values to exclude.
>, <Line: +		 * @returns {Array} Returns a new array of filtered values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
>, <Line: +		 * // => [1, 3, 4]
>, <Line: +		 */
>, <Line: +		function difference(array) {
>, <Line: +			return baseDifference(array, baseFlatten(arguments, true, true, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.find` except that it returns the index of the first
>, <Line: +		 * element that passes the callback check, instead of the element itself.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to search.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {number} Returns the index of the found element, else `-1`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'age': 36, 'blocked': false },
>, <Line: +		 *   { 'name': 'fred',    'age': 40, 'blocked': true },
>, <Line: +		 *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.findIndex(characters, function(chr) {
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.findIndex(characters, { 'age': 36 });
>, <Line: +		 * // => 0
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.findIndex(characters, 'blocked');
>, <Line: +		 * // => 1
>, <Line: +		 */
>, <Line: +		function findIndex(array, callback, thisArg) {
>, <Line: +			var index = -1,
>, <Line: +				length = array ? array.length : 0;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			while (++index < length) {
>, <Line: +				if (callback(array[index], index, array)) {
>, <Line: +					return index;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return -1;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.findIndex` except that it iterates over elements
>, <Line: +		 * of a `collection` from right to left.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to search.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {number} Returns the index of the found element, else `-1`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'age': 36, 'blocked': true },
>, <Line: +		 *   { 'name': 'fred',    'age': 40, 'blocked': false },
>, <Line: +		 *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * _.findLastIndex(characters, function(chr) {
>, <Line: +		 * // => 1
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.findLastIndex(characters, { 'age': 36 });
>, <Line: +		 * // => 0
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.findLastIndex(characters, 'blocked');
>, <Line: +		 * // => 2
>, <Line: +		 */
>, <Line: +		function findLastIndex(array, callback, thisArg) {
>, <Line: +			var length = array ? array.length : 0;
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			while (length--) {
>, <Line: +				if (callback(array[length], length, array)) {
>, <Line: +					return length;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return -1;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the first element or first `n` elements of an array. If a callback
>, <Line: +		 * is provided elements at the beginning of the array are returned as long
>, <Line: +		 * as the callback returns truey. The callback is bound to `thisArg` and
>, <Line: +		 * invoked with three arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias head, take
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to query.
>, <Line: +		 * @param {Function|Object|number|string} [callback] The function called
>, <Line: +		 *  per element or the number of elements to return. If a property name or
>, <Line: +		 *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: +		 *  style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the first element(s) of `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.first([1, 2, 3]);
>, <Line: +		 * // => 1
>, <Line: +		 *
>, <Line: +		 * _.first([1, 2, 3], 2);
>, <Line: +		 * // => [1, 2]
>, <Line: +		 *
>, <Line: +		 * _.first([1, 2, 3], function(num) {
>, <Line: +		 * // => [1, 2]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
>, <Line: +		 *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
>, <Line: +		 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.first(characters, 'blocked');
>, <Line: +		 * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
>, <Line: +		 * // => ['barney', 'fred']
>, <Line: +		 */
>, <Line: +		function first(array, callback, thisArg) {
>, <Line: +			var n = 0,
>, <Line: +				length = array ? array.length : 0;
>, <Line: +			if (typeof callback != 'number' && callback != null) {
>, <Line: +				var index = -1;
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				while (++index < length && callback(array[index], index, array)) {
>, <Line: +					n++;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				n = callback;
>, <Line: +				if (n == null || thisArg) {
>, <Line: +					return array ? array[0] : undefined;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return slice(array, 0, nativeMin(nativeMax(0, n), length));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Flattens a nested array (the nesting can be to any depth). If `isShallow`
>, <Line: +		 * is truey, the array will only be flattened a single level. If a callback
>, <Line: +		 * is provided each element of the array is passed through the callback before
>, <Line: +		 * flattening. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to flatten.
>, <Line: +		 * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new flattened array.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.flatten([1, [2], [3, [[4]]]]);
>, <Line: +		 * // => [1, 2, 3, 4];
>, <Line: +		 *
>, <Line: +		 * _.flatten([1, [2], [3, [[4]]]], true);
>, <Line: +		 * // => [1, 2, 3, [[4]]];
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
>, <Line: +		 *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.flatten(characters, 'pets');
>, <Line: +		 * // => ['hoppy', 'baby puss', 'dino']
>, <Line: +		 */
>, <Line: +		function flatten(array, isShallow, callback, thisArg) {
>, <Line: +			// juggle arguments
>, <Line: +			if (typeof isShallow != 'boolean' && isShallow != null) {
>, <Line: +				thisArg = callback;
>, <Line: +				callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
>, <Line: +				isShallow = false;
>, <Line: +			}
>, <Line: +			if (callback != null) {
>, <Line: +				array = map(array, callback, thisArg);
>, <Line: +			}
>, <Line: +			return baseFlatten(array, isShallow);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the index at which the first occurrence of `value` is found using
>, <Line: +		 * strict equality for comparisons, i.e. `===`. If the array is already sorted
>, <Line: +		 * providing `true` for `fromIndex` will run a faster binary search.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to search.
>, <Line: +		 * @param {*} value The value to search for.
>, <Line: +		 * @param {boolean|number} [fromIndex=0] The index to search from or `true`
>, <Line: +		 *  to perform a binary search on a sorted array.
>, <Line: +		 * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.indexOf([1, 2, 3, 1, 2, 3], 2);
>, <Line: +		 * // => 1
>, <Line: +		 *
>, <Line: +		 * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
>, <Line: +		 * // => 4
>, <Line: +		 *
>, <Line: +		 * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
>, <Line: +		 * // => 2
>, <Line: +		 */
>, <Line: +		function indexOf(array, value, fromIndex) {
>, <Line: +			if (typeof fromIndex == 'number') {
>, <Line: +				var length = array ? array.length : 0;
>, <Line: +				fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
>, <Line: +			} else if (fromIndex) {
>, <Line: +				var index = sortedIndex(array, value);
>, <Line: +				return array[index] === value ? index : -1;
>, <Line: +			}
>, <Line: +			return baseIndexOf(array, value, fromIndex);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets all but the last element or last `n` elements of an array. If a
>, <Line: +		 * callback is provided elements at the end of the array are excluded from
>, <Line: +		 * the result as long as the callback returns truey. The callback is bound
>, <Line: +		 * to `thisArg` and invoked with three arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to query.
>, <Line: +		 * @param {Function|Object|number|string} [callback=1] The function called
>, <Line: +		 *  per element or the number of elements to exclude. If a property name or
>, <Line: +		 *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: +		 *  style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a slice of `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.initial([1, 2, 3]);
>, <Line: +		 * // => [1, 2]
>, <Line: +		 *
>, <Line: +		 * _.initial([1, 2, 3], 2);
>, <Line: +		 * // => [1]
>, <Line: +		 *
>, <Line: +		 * _.initial([1, 2, 3], function(num) {
>, <Line: +		 * // => [1]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
>, <Line: +		 *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
>, <Line: +		 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.initial(characters, 'blocked');
>, <Line: +		 * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
>, <Line: +		 * // => ['barney', 'fred']
>, <Line: +		 */
>, <Line: +		function initial(array, callback, thisArg) {
>, <Line: +			var n = 0,
>, <Line: +				length = array ? array.length : 0;
>, <Line: +			if (typeof callback != 'number' && callback != null) {
>, <Line: +				var index = length;
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				while (index-- && callback(array[index], index, array)) {
>, <Line: +					n++;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				n = (callback == null || thisArg) ? 1 : callback || n;
>, <Line: +			}
>, <Line: +			return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of unique values present in all provided arrays using
>, <Line: +		 * strict equality for comparisons, i.e. `===`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {...Array} [array] The arrays to inspect.
>, <Line: +		 * @returns {Array} Returns an array of shared values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
>, <Line: +		 * // => [1, 2]
>, <Line: +		 */
>, <Line: +		function intersection() {
>, <Line: +			var args = [],
>, <Line: +				argsIndex = -1,
>, <Line: +				argsLength = arguments.length,
>, <Line: +				caches = getArray(),
>, <Line: +				indexOf = getIndexOf(),
>, <Line: +				trustIndexOf = indexOf === baseIndexOf,
>, <Line: +				seen = getArray();
>, <Line: +			while (++argsIndex < argsLength) {
>, <Line: +				var value = arguments[argsIndex];
>, <Line: +				if (isArray(value) || isArguments(value)) {
>, <Line: +					args.push(value);
>, <Line: +					caches.push(trustIndexOf && value.length >= largeArraySize &&
>, <Line: +						createCache(argsIndex ? args[argsIndex] : seen));
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var array = args[0],
>, <Line: +				index = -1,
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				result = [];
>, <Line: +			outer:
>, <Line: +				while (++index < length) {
>, <Line: +					var cache = caches[0];
>, <Line: +					value = array[index];
>, <Line: +					if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
>, <Line: +						argsIndex = argsLength;
>, <Line: +						(cache || seen).push(value);
>, <Line: +						while (--argsIndex) {
>, <Line: +							cache = caches[argsIndex];
>, <Line: +							if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
>, <Line: +								continue outer;
>, <Line: +							}
>, <Line: +						}
>, <Line: +						result.push(value);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			while (argsLength--) {
>, <Line: +				cache = caches[argsLength];
>, <Line: +				if (cache) {
>, <Line: +					releaseObject(cache);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			releaseArray(caches);
>, <Line: +			releaseArray(seen);
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the last element or last `n` elements of an array. If a callback is
>, <Line: +		 * provided elements at the end of the array are returned as long as the
>, <Line: +		 * callback returns truey. The callback is bound to `thisArg` and invoked
>, <Line: +		 * with three arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to query.
>, <Line: +		 * @param {Function|Object|number|string} [callback] The function called
>, <Line: +		 *  per element or the number of elements to return. If a property name or
>, <Line: +		 *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: +		 *  style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {*} Returns the last element(s) of `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.last([1, 2, 3]);
>, <Line: +		 * // => 3
>, <Line: +		 *
>, <Line: +		 * _.last([1, 2, 3], 2);
>, <Line: +		 * // => [2, 3]
>, <Line: +		 *
>, <Line: +		 * _.last([1, 2, 3], function(num) {
>, <Line: +		 * // => [2, 3]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
>, <Line: +		 *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
>, <Line: +		 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.pluck(_.last(characters, 'blocked'), 'name');
>, <Line: +		 * // => ['fred', 'pebbles']
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.last(characters, { 'employer': 'na' });
>, <Line: +		 * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
>, <Line: +		 */
>, <Line: +		function last(array, callback, thisArg) {
>, <Line: +			var n = 0,
>, <Line: +				length = array ? array.length : 0;
>, <Line: +			if (typeof callback != 'number' && callback != null) {
>, <Line: +				var index = length;
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				while (index-- && callback(array[index], index, array)) {
>, <Line: +					n++;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				n = callback;
>, <Line: +				if (n == null || thisArg) {
>, <Line: +					return array ? array[length - 1] : undefined;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return slice(array, nativeMax(0, length - n));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the index at which the last occurrence of `value` is found using strict
>, <Line: +		 * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
>, <Line: +		 * as the offset from the end of the collection.
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to search.
>, <Line: +		 * @param {*} value The value to search for.
>, <Line: +		 * @param {number} [fromIndex=array.length-1] The index to search from.
>, <Line: +		 * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
>, <Line: +		 * // => 4
>, <Line: +		 *
>, <Line: +		 * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
>, <Line: +		 * // => 1
>, <Line: +		 */
>, <Line: +		function lastIndexOf(array, value, fromIndex) {
>, <Line: +			var index = array ? array.length : 0;
>, <Line: +			if (typeof fromIndex == 'number') {
>, <Line: +				index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
>, <Line: +			}
>, <Line: +			while (index--) {
>, <Line: +				if (array[index] === value) {
>, <Line: +					return index;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return -1;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Removes all provided values from the given array using strict equality for
>, <Line: +		 * comparisons, i.e. `===`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to modify.
>, <Line: +		 * @param {...*} [value] The values to remove.
>, <Line: +		 * @returns {Array} Returns `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var array = [1, 2, 3, 1, 2, 3];
>, <Line: +		 * _.pull(array, 2, 3);
>, <Line: +		 * console.log(array);
>, <Line: +		 * // => [1, 1]
>, <Line: +		 */
>, <Line: +		function pull(array) {
>, <Line: +			var args = arguments,
>, <Line: +				argsIndex = 0,
>, <Line: +				argsLength = args.length,
>, <Line: +				length = array ? array.length : 0;
>, <Line: +			while (++argsIndex < argsLength) {
>, <Line: +				var index = -1,
>, <Line: +					value = args[argsIndex];
>, <Line: +				while (++index < length) {
>, <Line: +					if (array[index] === value) {
>, <Line: +						splice.call(array, index--, 1);
>, <Line: +						length--;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return array;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of numbers (positive and/or negative) progressing from
>, <Line: +		 * `start` up to but not including `end`. If `start` is less than `stop` a
>, <Line: +		 * zero-length range is created unless a negative `step` is specified.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {number} [start=0] The start of the range.
>, <Line: +		 * @param {number} end The end of the range.
>, <Line: +		 * @param {number} [step=1] The value to increment or decrement by.
>, <Line: +		 * @returns {Array} Returns a new range array.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.range(4);
>, <Line: +		 * // => [0, 1, 2, 3]
>, <Line: +		 *
>, <Line: +		 * _.range(1, 5);
>, <Line: +		 * // => [1, 2, 3, 4]
>, <Line: +		 *
>, <Line: +		 * _.range(0, 20, 5);
>, <Line: +		 * // => [0, 5, 10, 15]
>, <Line: +		 *
>, <Line: +		 * _.range(0, -4, -1);
>, <Line: +		 * // => [0, -1, -2, -3]
>, <Line: +		 *
>, <Line: +		 * _.range(1, 4, 0);
>, <Line: +		 * // => [1, 1, 1]
>, <Line: +		 *
>, <Line: +		 * _.range(0);
>, <Line: +		 * // => []
>, <Line: +		 */
>, <Line: +		function range(start, end, step) {
>, <Line: +			start = +start || 0;
>, <Line: +			step = typeof step == 'number' ? step : (+step || 1);
>, <Line: +			if (end == null) {
>, <Line: +				end = start;
>, <Line: +				start = 0;
>, <Line: +			}
>, <Line: +			// use `Array(length)` so engines like Chakra and V8 avoid slower modes
>, <Line: +			// http://youtu.be/XAqIpGU8ZZk#t=17m25s
>, <Line: +			var index = -1,
>, <Line: +				length = nativeMax(0, ceil((end - start) / (step || 1))),
>, <Line: +				result = Array(length);
>, <Line: +			while (++index < length) {
>, <Line: +				result[index] = start;
>, <Line: +				start += step;
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Removes all elements from an array that the callback returns truey for
>, <Line: +		 * and returns an array of removed elements. The callback is bound to `thisArg`
>, <Line: +		 * and invoked with three arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to modify.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a new array of removed elements.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var array = [1, 2, 3, 4, 5, 6];
>, <Line: +		 * var evens = _.remove(array, function(num) { return num % 2 == 0; });
>, <Line: +		 *
>, <Line: +		 * console.log(array);
>, <Line: +		 * // => [1, 3, 5]
>, <Line: +		 *
>, <Line: +		 * console.log(evens);
>, <Line: +		 * // => [2, 4, 6]
>, <Line: +		 */
>, <Line: +		function remove(array, callback, thisArg) {
>, <Line: +			var index = -1,
>, <Line: +				length = array ? array.length : 0,
>, <Line: +				result = [];
>, <Line: +			callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			while (++index < length) {
>, <Line: +				var value = array[index];
>, <Line: +				if (callback(value, index, array)) {
>, <Line: +					result.push(value);
>, <Line: +					splice.call(array, index--, 1);
>, <Line: +					length--;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The opposite of `_.initial` this method gets all but the first element or
>, <Line: +		 * first `n` elements of an array. If a callback function is provided elements
>, <Line: +		 * at the beginning of the array are excluded from the result as long as the
>, <Line: +		 * callback returns truey. The callback is bound to `thisArg` and invoked
>, <Line: +		 * with three arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias drop, tail
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to query.
>, <Line: +		 * @param {Function|Object|number|string} [callback=1] The function called
>, <Line: +		 *  per element or the number of elements to exclude. If a property name or
>, <Line: +		 *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: +		 *  style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a slice of `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.rest([1, 2, 3]);
>, <Line: +		 * // => [2, 3]
>, <Line: +		 *
>, <Line: +		 * _.rest([1, 2, 3], 2);
>, <Line: +		 * // => [3]
>, <Line: +		 *
>, <Line: +		 * _.rest([1, 2, 3], function(num) {
>, <Line: +		 * // => [3]
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
>, <Line: +		 *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
>, <Line: +		 *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.pluck(_.rest(characters, 'blocked'), 'name');
>, <Line: +		 * // => ['fred', 'pebbles']
>, <Line: +		 *
>, <Line: +		 * // using "_.where" callback shorthand
>, <Line: +		 * _.rest(characters, { 'employer': 'slate' });
>, <Line: +		 * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
>, <Line: +		 */
>, <Line: +		function rest(array, callback, thisArg) {
>, <Line: +			if (typeof callback != 'number' && callback != null) {
>, <Line: +				var n = 0,
>, <Line: +					index = -1,
>, <Line: +					length = array ? array.length : 0;
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +				while (++index < length && callback(array[index], index, array)) {
>, <Line: +					n++;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
>, <Line: +			}
>, <Line: +			return slice(array, n);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Uses a binary search to determine the smallest index at which a value
>, <Line: +		 * should be inserted into a given sorted array in order to maintain the sort
>, <Line: +		 * order of the array. If a callback is provided it will be executed for
>, <Line: +		 * `value` and each element of `array` to compute their sort ranking. The
>, <Line: +		 * callback is bound to `thisArg` and invoked with one argument; (value).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to inspect.
>, <Line: +		 * @param {*} value The value to evaluate.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {number} Returns the index at which `value` should be inserted
>, <Line: +		 *  into `array`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.sortedIndex([20, 30, 50], 40);
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * var dict = {
>, <Line: +		 *
>, <Line: +		 * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
>, <Line: +		 * // => 2
>, <Line: +		 *
>, <Line: +		 * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
>, <Line: +		 * // => 2
>, <Line: +		 */
>, <Line: +		function sortedIndex(array, value, callback, thisArg) {
>, <Line: +			var low = 0,
>, <Line: +				high = array ? array.length : low;
>, <Line: +			// explicitly reference `identity` for better inlining in Firefox
>, <Line: +			callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
>, <Line: +			value = callback(value);
>, <Line: +			while (low < high) {
>, <Line: +				var mid = (low + high) >>> 1;
>, <Line: +				(callback(array[mid]) < value)
>, <Line: +					? low = mid + 1
>, <Line: +					: high = mid;
>, <Line: +			}
>, <Line: +			return low;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of unique values, in order, of the provided arrays using
>, <Line: +		 * strict equality for comparisons, i.e. `===`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {...Array} [array] The arrays to inspect.
>, <Line: +		 * @returns {Array} Returns an array of combined values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
>, <Line: +		 * // => [1, 2, 3, 5, 4]
>, <Line: +		 */
>, <Line: +		function union() {
>, <Line: +			return baseUniq(baseFlatten(arguments, true, true));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a duplicate-value-free version of an array using strict equality
>, <Line: +		 * for comparisons, i.e. `===`. If the array is sorted, providing
>, <Line: +		 * `true` for `isSorted` will use a faster algorithm. If a callback is provided
>, <Line: +		 * each element of `array` is passed through the callback before uniqueness
>, <Line: +		 * is computed. The callback is bound to `thisArg` and invoked with three
>, <Line: +		 * arguments; (value, index, array).
>, <Line: +		 *
>, <Line: +		 * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: +		 * callback will return the property value of the given element.
>, <Line: +		 *
>, <Line: +		 * If an object is provided for `callback` the created "_.where" style callback
>, <Line: +		 * will return `true` for elements that have the properties of the given object,
>, <Line: +		 * else `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias unique
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to process.
>, <Line: +		 * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
>, <Line: +		 * @param {Function|Object|string} [callback=identity] The function called
>, <Line: +		 *  per iteration. If a property name or object is provided it will be used
>, <Line: +		 *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns a duplicate-value-free array.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.uniq([1, 2, 1, 3, 1]);
>, <Line: +		 * // => [1, 2, 3]
>, <Line: +		 *
>, <Line: +		 * _.uniq([1, 1, 2, 2, 3], true);
>, <Line: +		 * // => [1, 2, 3]
>, <Line: +		 *
>, <Line: +		 * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
>, <Line: +		 * // => ['A', 'b', 'C']
>, <Line: +		 *
>, <Line: +		 * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
>, <Line: +		 * // => [1, 2.5, 3]
>, <Line: +		 *
>, <Line: +		 * // using "_.pluck" callback shorthand
>, <Line: +		 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
>, <Line: +		 * // => [{ 'x': 1 }, { 'x': 2 }]
>, <Line: +		 */
>, <Line: +		function uniq(array, isSorted, callback, thisArg) {
>, <Line: +			// juggle arguments
>, <Line: +			if (typeof isSorted != 'boolean' && isSorted != null) {
>, <Line: +				thisArg = callback;
>, <Line: +				callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
>, <Line: +				isSorted = false;
>, <Line: +			}
>, <Line: +			if (callback != null) {
>, <Line: +				callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: +			}
>, <Line: +			return baseUniq(array, isSorted, callback);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array excluding all provided values using strict equality for
>, <Line: +		 * comparisons, i.e. `===`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} array The array to filter.
>, <Line: +		 * @param {...*} [value] The values to exclude.
>, <Line: +		 * @returns {Array} Returns a new array of filtered values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
>, <Line: +		 * // => [2, 3, 4]
>, <Line: +		 */
>, <Line: +		function without(array) {
>, <Line: +			return baseDifference(array, slice(arguments, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array that is the symmetric difference of the provided arrays.
>, <Line: +		 * See http://en.wikipedia.org/wiki/Symmetric_difference.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {...Array} [array] The arrays to inspect.
>, <Line: +		 * @returns {Array} Returns an array of values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.xor([1, 2, 3], [5, 2, 1, 4]);
>, <Line: +		 * // => [3, 5, 4]
>, <Line: +		 *
>, <Line: +		 * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
>, <Line: +		 * // => [1, 4, 5]
>, <Line: +		 */
>, <Line: +		function xor() {
>, <Line: +			var index = -1,
>, <Line: +				length = arguments.length;
>, <Line: +			while (++index < length) {
>, <Line: +				var array = arguments[index];
>, <Line: +				if (isArray(array) || isArguments(array)) {
>, <Line: +					var result = result
>, <Line: +						? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
>, <Line: +						: array;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result || [];
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an array of grouped elements, the first of which contains the first
>, <Line: +		 * elements of the given arrays, the second of which contains the second
>, <Line: +		 * elements of the given arrays, and so on.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias unzip
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {...Array} [array] Arrays to process.
>, <Line: +		 * @returns {Array} Returns a new array of grouped elements.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
>, <Line: +		 * // => [['fred', 30, true], ['barney', 40, false]]
>, <Line: +		 */
>, <Line: +		function zip() {
>, <Line: +			var array = arguments.length > 1 ? arguments : arguments[0],
>, <Line: +				index = -1,
>, <Line: +				length = array ? max(pluck(array, 'length')) : 0,
>, <Line: +				result = Array(length < 0 ? 0 : length);
>, <Line: +			while (++index < length) {
>, <Line: +				result[index] = pluck(array, index);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates an object composed from arrays of `keys` and `values`. Provide
>, <Line: +		 * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
>, <Line: +		 * or two arrays, one of `keys` and one of corresponding `values`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias object
>, <Line: +		 * @category Arrays
>, <Line: +		 * @param {Array} keys The array of keys.
>, <Line: +		 * @param {Array} [values=[]] The array of values.
>, <Line: +		 * @returns {Object} Returns an object composed of the given keys and
>, <Line: +		 *  corresponding values.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.zipObject(['fred', 'barney'], [30, 40]);
>, <Line: +		 * // => { 'fred': 30, 'barney': 40 }
>, <Line: +		 */
>, <Line: +		function zipObject(keys, values) {
>, <Line: +			var index = -1,
>, <Line: +				length = keys ? keys.length : 0,
>, <Line: +				result = {};
>, <Line: +			if (!values && length && !isArray(keys[0])) {
>, <Line: +				values = [];
>, <Line: +			}
>, <Line: +			while (++index < length) {
>, <Line: +				var key = keys[index];
>, <Line: +				if (values) {
>, <Line: +					result[key] = values[index];
>, <Line: +				} else if (key) {
>, <Line: +					result[key[0]] = key[1];
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates a function that executes `func`, with  the `this` binding and
>, <Line: +		 * arguments of the created function, only after being called `n` times.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {number} n The number of times the function must be called before
>, <Line: +		 *  `func` is executed.
>, <Line: +		 * @param {Function} func The function to restrict.
>, <Line: +		 * @returns {Function} Returns the new restricted function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var saves = ['profile', 'settings'];
>, <Line: +		 *
>, <Line: +		 * var done = _.after(saves.length, function() {
>, <Line: +		 *
>, <Line: +		 * _.forEach(saves, function(type) {
>, <Line: +		 * // => logs 'Done saving!', after all saves have completed
>, <Line: +		 */
>, <Line: +		function after(n, func) {
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			return function () {
>, <Line: +				if (--n < 1) {
>, <Line: +					return func.apply(this, arguments);
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that, when called, invokes `func` with the `this`
>, <Line: +		 * binding of `thisArg` and prepends any additional `bind` arguments to those
>, <Line: +		 * provided to the bound function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to bind.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `func`.
>, <Line: +		 * @param {...*} [arg] Arguments to be partially applied.
>, <Line: +		 * @returns {Function} Returns the new bound function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var func = function(greeting) {
>, <Line: +		 *
>, <Line: +		 * func = _.bind(func, { 'name': 'fred' }, 'hi');
>, <Line: +		 * func();
>, <Line: +		 * // => 'hi fred'
>, <Line: +		 */
>, <Line: +		function bind(func, thisArg) {
>, <Line: +			return arguments.length > 2
>, <Line: +				? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
>, <Line: +				: createWrapper(func, 1, null, null, thisArg);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Binds methods of an object to the object itself, overwriting the existing
>, <Line: +		 * method. Method names may be specified as individual arguments or as arrays
>, <Line: +		 * of method names. If no method names are provided all the function properties
>, <Line: +		 * of `object` will be bound.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Object} object The object to bind and assign the bound methods to.
>, <Line: +		 * @param {...string} [methodName] The object method names to
>, <Line: +		 *  bind, specified as individual method names or arrays of method names.
>, <Line: +		 * @returns {Object} Returns `object`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var view = {
>, <Line: +		 *
>, <Line: +		 * _.bindAll(view);
>, <Line: +		 * jQuery('#docs').on('click', view.onClick);
>, <Line: +		 * // => logs 'clicked docs', when the button is clicked
>, <Line: +		 */
>, <Line: +		function bindAll(object) {
>, <Line: +			var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
>, <Line: +				index = -1,
>, <Line: +				length = funcs.length;
>, <Line: +			while (++index < length) {
>, <Line: +				var key = funcs[index];
>, <Line: +				object[key] = createWrapper(object[key], 1, null, null, object);
>, <Line: +			}
>, <Line: +			return object;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that, when called, invokes the method at `object[key]`
>, <Line: +		 * and prepends any additional `bindKey` arguments to those provided to the bound
>, <Line: +		 * function. This method differs from `_.bind` by allowing bound functions to
>, <Line: +		 * reference methods that will be redefined or don't yet exist.
>, <Line: +		 * See http://michaux.ca/articles/lazy-function-definition-pattern.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Object} object The object the method belongs to.
>, <Line: +		 * @param {string} key The key of the method.
>, <Line: +		 * @param {...*} [arg] Arguments to be partially applied.
>, <Line: +		 * @returns {Function} Returns the new bound function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = {
>, <Line: +		 *
>, <Line: +		 * var func = _.bindKey(object, 'greet', 'hi');
>, <Line: +		 * func();
>, <Line: +		 * // => 'hi fred'
>, <Line: +		 *
>, <Line: +		 * object.greet = function(greeting) {
>, <Line: +		 *
>, <Line: +		 * func();
>, <Line: +		 * // => 'hiya fred!'
>, <Line: +		 */
>, <Line: +		function bindKey(object, key) {
>, <Line: +			return arguments.length > 2
>, <Line: +				? createWrapper(key, 19, slice(arguments, 2), null, object)
>, <Line: +				: createWrapper(key, 3, null, null, object);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that is the composition of the provided functions,
>, <Line: +		 * where each function consumes the return value of the function that follows.
>, <Line: +		 * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
>, <Line: +		 * Each function is executed with the `this` binding of the composed function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {...Function} [func] Functions to compose.
>, <Line: +		 * @returns {Function} Returns the new composed function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var realNameMap = {
>, <Line: +		 *
>, <Line: +		 * var format = function(name) {
>, <Line: +		 *
>, <Line: +		 * var greet = function(formatted) {
>, <Line: +		 *
>, <Line: +		 * var welcome = _.compose(greet, format);
>, <Line: +		 * welcome('pebbles');
>, <Line: +		 * // => 'Hiya Penelope!'
>, <Line: +		 */
>, <Line: +		function compose() {
>, <Line: +			var funcs = arguments,
>, <Line: +				length = funcs.length;
>, <Line: +			while (length--) {
>, <Line: +				if (!isFunction(funcs[length])) {
>, <Line: +					throw new TypeError;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return function () {
>, <Line: +				var args = arguments,
>, <Line: +					length = funcs.length;
>, <Line: +				while (length--) {
>, <Line: +					args = [funcs[length].apply(this, args)];
>, <Line: +				}
>, <Line: +				return args[0];
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function which accepts one or more arguments of `func` that when
>, <Line: +		 * invoked either executes `func` returning its result, if all `func` arguments
>, <Line: +		 * have been provided, or returns a function that accepts one or more of the
>, <Line: +		 * remaining `func` arguments, and so on. The arity of `func` can be specified
>, <Line: +		 * if `func.length` is not sufficient.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to curry.
>, <Line: +		 * @param {number} [arity=func.length] The arity of `func`.
>, <Line: +		 * @returns {Function} Returns the new curried function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var curried = _.curry(function(a, b, c) {
>, <Line: +		 *
>, <Line: +		 * curried(1)(2)(3);
>, <Line: +		 * // => 6
>, <Line: +		 *
>, <Line: +		 * curried(1, 2)(3);
>, <Line: +		 * // => 6
>, <Line: +		 *
>, <Line: +		 * curried(1, 2, 3);
>, <Line: +		 * // => 6
>, <Line: +		 */
>, <Line: +		function curry(func, arity) {
>, <Line: +			arity = typeof arity == 'number' ? arity : (+arity || func.length);
>, <Line: +			return createWrapper(func, 4, null, null, null, arity);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that will delay the execution of `func` until after
>, <Line: +		 * `wait` milliseconds have elapsed since the last time it was invoked.
>, <Line: +		 * Provide an options object to indicate that `func` should be invoked on
>, <Line: +		 * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
>, <Line: +		 * to the debounced function will return the result of the last `func` call.
>, <Line: +		 *
>, <Line: +		 * Note: If `leading` and `trailing` options are `true` `func` will be called
>, <Line: +		 * on the trailing edge of the timeout only if the the debounced function is
>, <Line: +		 * invoked more than once during the `wait` timeout.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to debounce.
>, <Line: +		 * @param {number} wait The number of milliseconds to delay.
>, <Line: +		 * @param {Object} [options] The options object.
>, <Line: +		 * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
>, <Line: +		 * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
>, <Line: +		 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
>, <Line: +		 * @returns {Function} Returns the new debounced function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * // avoid costly calculations while the window size is in flux
>, <Line: +		 * var lazyLayout = _.debounce(calculateLayout, 150);
>, <Line: +		 * jQuery(window).on('resize', lazyLayout);
>, <Line: +		 *
>, <Line: +		 * // execute `sendMail` when the click event is fired, debouncing subsequent calls
>, <Line: +		 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
>, <Line: +		 *
>, <Line: +		 * // ensure `batchLog` is executed once after 1 second of debounced calls
>, <Line: +		 * var source = new EventSource('/stream');
>, <Line: +		 * source.addEventListener('message', _.debounce(batchLog, 250, {
>, <Line: +		 */
>, <Line: +		function debounce(func, wait, options) {
>, <Line: +			var args,
>, <Line: +				maxTimeoutId,
>, <Line: +				result,
>, <Line: +				stamp,
>, <Line: +				thisArg,
>, <Line: +				timeoutId,
>, <Line: +				trailingCall,
>, <Line: +				lastCalled = 0,
>, <Line: +				maxWait = false,
>, <Line: +				trailing = true;
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			wait = nativeMax(0, wait) || 0;
>, <Line: +			if (options === true) {
>, <Line: +				var leading = true;
>, <Line: +				trailing = false;
>, <Line: +			} else if (isObject(options)) {
>, <Line: +				leading = options.leading;
>, <Line: +				maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
>, <Line: +				trailing = 'trailing' in options ? options.trailing : trailing;
>, <Line: +			}
>, <Line: +			var delayed = function () {
>, <Line: +				var remaining = wait - (now() - stamp);
>, <Line: +				if (remaining <= 0) {
>, <Line: +					if (maxTimeoutId) {
>, <Line: +						clearTimeout(maxTimeoutId);
>, <Line: +					}
>, <Line: +					var isCalled = trailingCall;
>, <Line: +					maxTimeoutId = timeoutId = trailingCall = undefined;
>, <Line: +					if (isCalled) {
>, <Line: +						lastCalled = now();
>, <Line: +						result = func.apply(thisArg, args);
>, <Line: +						if (!timeoutId && !maxTimeoutId) {
>, <Line: +							args = thisArg = null;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					timeoutId = setTimeout(delayed, remaining);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			var maxDelayed = function () {
>, <Line: +				if (timeoutId) {
>, <Line: +					clearTimeout(timeoutId);
>, <Line: +				}
>, <Line: +				maxTimeoutId = timeoutId = trailingCall = undefined;
>, <Line: +				if (trailing || (maxWait !== wait)) {
>, <Line: +					lastCalled = now();
>, <Line: +					result = func.apply(thisArg, args);
>, <Line: +					if (!timeoutId && !maxTimeoutId) {
>, <Line: +						args = thisArg = null;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			return function () {
>, <Line: +				args = arguments;
>, <Line: +				stamp = now();
>, <Line: +				thisArg = this;
>, <Line: +				trailingCall = trailing && (timeoutId || !leading);
>, <Line: +				if (maxWait === false) {
>, <Line: +					var leadingCall = leading && !timeoutId;
>, <Line: +				} else {
>, <Line: +					if (!maxTimeoutId && !leading) {
>, <Line: +						lastCalled = stamp;
>, <Line: +					}
>, <Line: +					var remaining = maxWait - (stamp - lastCalled),
>, <Line: +						isCalled = remaining <= 0;
>, <Line: +					if (isCalled) {
>, <Line: +						if (maxTimeoutId) {
>, <Line: +							maxTimeoutId = clearTimeout(maxTimeoutId);
>, <Line: +						}
>, <Line: +						lastCalled = stamp;
>, <Line: +						result = func.apply(thisArg, args);
>, <Line: +					}
>, <Line: +					else if (!maxTimeoutId) {
>, <Line: +						maxTimeoutId = setTimeout(maxDelayed, remaining);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (isCalled && timeoutId) {
>, <Line: +					timeoutId = clearTimeout(timeoutId);
>, <Line: +				}
>, <Line: +				else if (!timeoutId && wait !== maxWait) {
>, <Line: +					timeoutId = setTimeout(delayed, wait);
>, <Line: +				}
>, <Line: +				if (leadingCall) {
>, <Line: +					isCalled = true;
>, <Line: +					result = func.apply(thisArg, args);
>, <Line: +				}
>, <Line: +				if (isCalled && !timeoutId && !maxTimeoutId) {
>, <Line: +					args = thisArg = null;
>, <Line: +				}
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Defers executing the `func` function until the current call stack has cleared.
>, <Line: +		 * Additional arguments will be provided to `func` when it is invoked.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to defer.
>, <Line: +		 * @param {...*} [arg] Arguments to invoke the function with.
>, <Line: +		 * @returns {number} Returns the timer id.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.defer(function(text) { console.log(text); }, 'deferred');
>, <Line: +		 * // logs 'deferred' after one or more milliseconds
>, <Line: +		 */
>, <Line: +		function defer(func) {
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			var args = slice(arguments, 1);
>, <Line: +			return setTimeout(function () {
>, <Line: +				func.apply(undefined, args);
>, <Line: +			}, 1);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Executes the `func` function after `wait` milliseconds. Additional arguments
>, <Line: +		 * will be provided to `func` when it is invoked.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to delay.
>, <Line: +		 * @param {number} wait The number of milliseconds to delay execution.
>, <Line: +		 * @param {...*} [arg] Arguments to invoke the function with.
>, <Line: +		 * @returns {number} Returns the timer id.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.delay(function(text) { console.log(text); }, 1000, 'later');
>, <Line: +		 * // => logs 'later' after one second
>, <Line: +		 */
>, <Line: +		function delay(func, wait) {
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			var args = slice(arguments, 2);
>, <Line: +			return setTimeout(function () {
>, <Line: +				func.apply(undefined, args);
>, <Line: +			}, wait);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that memoizes the result of `func`. If `resolver` is
>, <Line: +		 * provided it will be used to determine the cache key for storing the result
>, <Line: +		 * based on the arguments provided to the memoized function. By default, the
>, <Line: +		 * first argument provided to the memoized function is used as the cache key.
>, <Line: +		 * The `func` is executed with the `this` binding of the memoized function.
>, <Line: +		 * The result cache is exposed as the `cache` property on the memoized function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to have its output memoized.
>, <Line: +		 * @param {Function} [resolver] A function used to resolve the cache key.
>, <Line: +		 * @returns {Function} Returns the new memoizing function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var fibonacci = _.memoize(function(n) {
>, <Line: +		 *
>, <Line: +		 * fibonacci(9)
>, <Line: +		 * // => 34
>, <Line: +		 *
>, <Line: +		 * var data = {
>, <Line: +		 *
>, <Line: +		 * // modifying the result cache
>, <Line: +		 * var get = _.memoize(function(name) { return data[name]; }, _.identity);
>, <Line: +		 * get('pebbles');
>, <Line: +		 * // => { 'name': 'pebbles', 'age': 1 }
>, <Line: +		 *
>, <Line: +		 * get.cache.pebbles.name = 'penelope';
>, <Line: +		 * get('pebbles');
>, <Line: +		 * // => { 'name': 'penelope', 'age': 1 }
>, <Line: +		 */
>, <Line: +		function memoize(func, resolver) {
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			var memoized = function () {
>, <Line: +				var cache = memoized.cache,
>, <Line: +					key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
>, <Line: +				return hasOwnProperty.call(cache, key)
>, <Line: +					? cache[key]
>, <Line: +					: (cache[key] = func.apply(this, arguments));
>, <Line: +			}
>, <Line: +			memoized.cache = {};
>, <Line: +			return memoized;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that is restricted to execute `func` once. Repeat calls to
>, <Line: +		 * the function will return the value of the first call. The `func` is executed
>, <Line: +		 * with the `this` binding of the created function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to restrict.
>, <Line: +		 * @returns {Function} Returns the new restricted function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var initialize = _.once(createApplication);
>, <Line: +		 * initialize();
>, <Line: +		 * initialize();
>, <Line: +		 * // `initialize` executes `createApplication` once
>, <Line: +		 */
>, <Line: +		function once(func) {
>, <Line: +			var ran,
>, <Line: +				result;
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			return function () {
>, <Line: +				if (ran) {
>, <Line: +					return result;
>, <Line: +				}
>, <Line: +				ran = true;
>, <Line: +				result = func.apply(this, arguments);
>, <Line: +				// clear the `func` variable so the function may be garbage collected
>, <Line: +				func = null;
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that, when called, invokes `func` with any additional
>, <Line: +		 * `partial` arguments prepended to those provided to the new function. This
>, <Line: +		 * method is similar to `_.bind` except it does **not** alter the `this` binding.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to partially apply arguments to.
>, <Line: +		 * @param {...*} [arg] Arguments to be partially applied.
>, <Line: +		 * @returns {Function} Returns the new partially applied function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var greet = function(greeting, name) { return greeting + ' ' + name; };
>, <Line: +		 * var hi = _.partial(greet, 'hi');
>, <Line: +		 * hi('fred');
>, <Line: +		 * // => 'hi fred'
>, <Line: +		 */
>, <Line: +		function partial(func) {
>, <Line: +			return createWrapper(func, 16, slice(arguments, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method is like `_.partial` except that `partial` arguments are
>, <Line: +		 * appended to those provided to the new function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to partially apply arguments to.
>, <Line: +		 * @param {...*} [arg] Arguments to be partially applied.
>, <Line: +		 * @returns {Function} Returns the new partially applied function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var defaultsDeep = _.partialRight(_.merge, _.defaults);
>, <Line: +		 *
>, <Line: +		 * var options = {
>, <Line: +		 *
>, <Line: +		 * defaultsDeep(options, _.templateSettings);
>, <Line: +		 *
>, <Line: +		 * options.variable
>, <Line: +		 * // => 'data'
>, <Line: +		 *
>, <Line: +		 * options.imports
>, <Line: +		 * // => { '_': _, 'jq': $ }
>, <Line: +		 */
>, <Line: +		function partialRight(func) {
>, <Line: +			return createWrapper(func, 32, null, slice(arguments, 1));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that, when executed, will only call the `func` function
>, <Line: +		 * at most once per every `wait` milliseconds. Provide an options object to
>, <Line: +		 * indicate that `func` should be invoked on the leading and/or trailing edge
>, <Line: +		 * of the `wait` timeout. Subsequent calls to the throttled function will
>, <Line: +		 * return the result of the last `func` call.
>, <Line: +		 *
>, <Line: +		 * Note: If `leading` and `trailing` options are `true` `func` will be called
>, <Line: +		 * on the trailing edge of the timeout only if the the throttled function is
>, <Line: +		 * invoked more than once during the `wait` timeout.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {Function} func The function to throttle.
>, <Line: +		 * @param {number} wait The number of milliseconds to throttle executions to.
>, <Line: +		 * @param {Object} [options] The options object.
>, <Line: +		 * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
>, <Line: +		 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
>, <Line: +		 * @returns {Function} Returns the new throttled function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * // avoid excessively updating the position while scrolling
>, <Line: +		 * var throttled = _.throttle(updatePosition, 100);
>, <Line: +		 * jQuery(window).on('scroll', throttled);
>, <Line: +		 *
>, <Line: +		 * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
>, <Line: +		 * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
>, <Line: +		 */
>, <Line: +		function throttle(func, wait, options) {
>, <Line: +			var leading = true,
>, <Line: +				trailing = true;
>, <Line: +			if (!isFunction(func)) {
>, <Line: +				throw new TypeError;
>, <Line: +			}
>, <Line: +			if (options === false) {
>, <Line: +				leading = false;
>, <Line: +			} else if (isObject(options)) {
>, <Line: +				leading = 'leading' in options ? options.leading : leading;
>, <Line: +				trailing = 'trailing' in options ? options.trailing : trailing;
>, <Line: +			}
>, <Line: +			debounceOptions.leading = leading;
>, <Line: +			debounceOptions.maxWait = wait;
>, <Line: +			debounceOptions.trailing = trailing;
>, <Line: +			return debounce(func, wait, debounceOptions);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Creates a function that provides `value` to the wrapper function as its
>, <Line: +		 * first argument. Additional arguments provided to the function are appended
>, <Line: +		 * to those provided to the wrapper function. The wrapper is executed with
>, <Line: +		 * the `this` binding of the created function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Functions
>, <Line: +		 * @param {*} value The value to wrap.
>, <Line: +		 * @param {Function} wrapper The wrapper function.
>, <Line: +		 * @returns {Function} Returns the new function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var p = _.wrap(_.escape, function(func, text) {
>, <Line: +		 *
>, <Line: +		 * p('Fred, Wilma, & Pebbles');
>, <Line: +		 * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
>, <Line: +		 */
>, <Line: +		function wrap(value, wrapper) {
>, <Line: +			return createWrapper(wrapper, 16, [value]);
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates a function that returns `value`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {*} value The value to return from the new function.
>, <Line: +		 * @returns {Function} Returns the new function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'fred' };
>, <Line: +		 * var getter = _.constant(object);
>, <Line: +		 * getter() === object;
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function constant(value) {
>, <Line: +			return function () {
>, <Line: +				return value;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Produces a callback bound to an optional `thisArg`. If `func` is a property
>, <Line: +		 * name the created callback will return the property value for a given element.
>, <Line: +		 * If `func` is an object the created callback will return `true` for elements
>, <Line: +		 * that contain the equivalent object properties, otherwise it will return `false`.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {*} [func=identity] The value to convert to a callback.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of the created callback.
>, <Line: +		 * @param {number} [argCount] The number of arguments the callback accepts.
>, <Line: +		 * @returns {Function} Returns a callback function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // wrap to create custom callback shorthands
>, <Line: +		 * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
>, <Line: +		 *
>, <Line: +		 * _.filter(characters, 'age__gt38');
>, <Line: +		 * // => [{ 'name': 'fred', 'age': 40 }]
>, <Line: +		 */
>, <Line: +		function createCallback(func, thisArg, argCount) {
>, <Line: +			var type = typeof func;
>, <Line: +			if (func == null || type == 'function') {
>, <Line: +				return baseCreateCallback(func, thisArg, argCount);
>, <Line: +			}
>, <Line: +			// handle "_.pluck" style callback shorthands
>, <Line: +			if (type != 'object') {
>, <Line: +				return property(func);
>, <Line: +			}
>, <Line: +			var props = keys(func),
>, <Line: +				key = props[0],
>, <Line: +				a = func[key];
>, <Line: +			// handle "_.where" style callback shorthands
>, <Line: +			if (props.length == 1 && a === a && !isObject(a)) {
>, <Line: +				// fast path the common case of providing an object with a single
>, <Line: +				// property containing a primitive value
>, <Line: +				return function (object) {
>, <Line: +					var b = object[key];
>, <Line: +					return a === b && (a !== 0 || (1 / a == 1 / b));
>, <Line: +				};
>, <Line: +			}
>, <Line: +			return function (object) {
>, <Line: +				var length = props.length,
>, <Line: +					result = false;
>, <Line: +				while (length--) {
>, <Line: +					if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
>, <Line: +		 * corresponding HTML entities.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} string The string to escape.
>, <Line: +		 * @returns {string} Returns the escaped string.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.escape('Fred, Wilma, & Pebbles');
>, <Line: +		 * // => 'Fred, Wilma, &amp; Pebbles'
>, <Line: +		 */
>, <Line: +		function escape(string) {
>, <Line: +			return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * This method returns the first argument provided to it.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {*} value Any value.
>, <Line: +		 * @returns {*} Returns `value`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'fred' };
>, <Line: +		 * _.identity(object) === object;
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function identity(value) {
>, <Line: +			return value;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Adds function properties of a source object to the destination object.
>, <Line: +		 * If `object` is a function methods will be added to its prototype as well.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {Function|Object} [object=lodash] object The destination object.
>, <Line: +		 * @param {Object} source The object of functions to add.
>, <Line: +		 * @param {Object} [options] The options object.
>, <Line: +		 * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * function capitalize(string) {
>, <Line: +		 *
>, <Line: +		 * _.mixin({ 'capitalize': capitalize });
>, <Line: +		 * _.capitalize('fred');
>, <Line: +		 * // => 'Fred'
>, <Line: +		 *
>, <Line: +		 * _('fred').capitalize().value();
>, <Line: +		 * // => 'Fred'
>, <Line: +		 *
>, <Line: +		 * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
>, <Line: +		 * _('fred').capitalize();
>, <Line: +		 * // => 'Fred'
>, <Line: +		 */
>, <Line: +		function mixin(object, source, options) {
>, <Line: +			var chain = true,
>, <Line: +				methodNames = source && functions(source);
>, <Line: +			if (!source || (!options && !methodNames.length)) {
>, <Line: +				if (options == null) {
>, <Line: +					options = source;
>, <Line: +				}
>, <Line: +				ctor = lodashWrapper;
>, <Line: +				source = object;
>, <Line: +				object = lodash;
>, <Line: +				methodNames = functions(source);
>, <Line: +			}
>, <Line: +			if (options === false) {
>, <Line: +				chain = false;
>, <Line: +			} else if (isObject(options) && 'chain' in options) {
>, <Line: +				chain = options.chain;
>, <Line: +			}
>, <Line: +			var ctor = object,
>, <Line: +				isFunc = isFunction(ctor);
>, <Line: +			forEach(methodNames, function (methodName) {
>, <Line: +				var func = object[methodName] = source[methodName];
>, <Line: +				if (isFunc) {
>, <Line: +					ctor.prototype[methodName] = function () {
>, <Line: +						var chainAll = this.__chain__,
>, <Line: +							value = this.__wrapped__,
>, <Line: +							args = [value];
>, <Line: +						push.apply(args, arguments);
>, <Line: +						var result = func.apply(object, args);
>, <Line: +						if (chain || chainAll) {
>, <Line: +							if (value === result && isObject(result)) {
>, <Line: +								return this;
>, <Line: +							}
>, <Line: +							result = new ctor(result);
>, <Line: +							result.__chain__ = chainAll;
>, <Line: +						}
>, <Line: +						return result;
>, <Line: +					};
>, <Line: +				}
>, <Line: +			});
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Reverts the '_' variable to its previous value and returns a reference to
>, <Line: +		 * the `lodash` function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @returns {Function} Returns the `lodash` function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var lodash = _.noConflict();
>, <Line: +		 */
>, <Line: +		function noConflict() {
>, <Line: +			context._ = oldDash;
>, <Line: +			return this;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * A no-operation function.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = { 'name': 'fred' };
>, <Line: +		 * _.noop(object) === undefined;
>, <Line: +		 * // => true
>, <Line: +		 */
>, <Line: +		function noop() {
>, <Line: +			// no operation performed
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Gets the number of milliseconds that have elapsed since the Unix epoch
>, <Line: +		 * (1 January 1970 00:00:00 UTC).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var stamp = _.now();
>, <Line: +		 * _.defer(function() { console.log(_.now() - stamp); });
>, <Line: +		 * // => logs the number of milliseconds it took for the deferred function to be called
>, <Line: +		 */
>, <Line: +		var now = isNative(now = Date.now) && now || function () {
>, <Line: +				return new Date().getTime();
>, <Line: +			};
>, <Line: +		/**
>, <Line: +		 * Converts the given value into an integer of the specified radix.
>, <Line: +		 * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
>, <Line: +		 * `value` is a hexadecimal, in which case a `radix` of `16` is used.
>, <Line: +		 *
>, <Line: +		 * Note: This method avoids differences in native ES3 and ES5 `parseInt`
>, <Line: +		 * implementations. See http://es5.github.io/#E.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} value The value to parse.
>, <Line: +		 * @param {number} [radix] The radix used to interpret the value to parse.
>, <Line: +		 * @returns {number} Returns the new integer value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.parseInt('08');
>, <Line: +		 * // => 8
>, <Line: +		 */
>, <Line: +		var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
>, <Line: +			// Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
>, <Line: +			return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Creates a "_.pluck" style function, which returns the `key` value of a
>, <Line: +		 * given object.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} key The name of the property to retrieve.
>, <Line: +		 * @returns {Function} Returns the new function.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'fred',   'age': 40 },
>, <Line: +		 *   { 'name': 'barney', 'age': 36 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * var getName = _.property('name');
>, <Line: +		 *
>, <Line: +		 * _.map(characters, getName);
>, <Line: +		 * // => ['barney', 'fred']
>, <Line: +		 *
>, <Line: +		 * _.sortBy(characters, getName);
>, <Line: +		 * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
>, <Line: +		 */
>, <Line: +		function property(key) {
>, <Line: +			return function (object) {
>, <Line: +				return object[key];
>, <Line: +			};
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Produces a random number between `min` and `max` (inclusive). If only one
>, <Line: +		 * argument is provided a number between `0` and the given number will be
>, <Line: +		 * returned. If `floating` is truey or either `min` or `max` are floats a
>, <Line: +		 * floating-point number will be returned instead of an integer.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {number} [min=0] The minimum possible value.
>, <Line: +		 * @param {number} [max=1] The maximum possible value.
>, <Line: +		 * @param {boolean} [floating=false] Specify returning a floating-point number.
>, <Line: +		 * @returns {number} Returns a random number.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.random(0, 5);
>, <Line: +		 * // => an integer between 0 and 5
>, <Line: +		 *
>, <Line: +		 * _.random(5);
>, <Line: +		 * // => also an integer between 0 and 5
>, <Line: +		 *
>, <Line: +		 * _.random(5, true);
>, <Line: +		 * // => a floating-point number between 0 and 5
>, <Line: +		 *
>, <Line: +		 * _.random(1.2, 5.2);
>, <Line: +		 * // => a floating-point number between 1.2 and 5.2
>, <Line: +		 */
>, <Line: +		function random(min, max, floating) {
>, <Line: +			var noMin = min == null,
>, <Line: +				noMax = max == null;
>, <Line: +			if (floating == null) {
>, <Line: +				if (typeof min == 'boolean' && noMax) {
>, <Line: +					floating = min;
>, <Line: +					min = 1;
>, <Line: +				}
>, <Line: +				else if (!noMax && typeof max == 'boolean') {
>, <Line: +					floating = max;
>, <Line: +					noMax = true;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (noMin && noMax) {
>, <Line: +				max = 1;
>, <Line: +			}
>, <Line: +			min = +min || 0;
>, <Line: +			if (noMax) {
>, <Line: +				max = min;
>, <Line: +				min = 0;
>, <Line: +			} else {
>, <Line: +				max = +max || 0;
>, <Line: +			}
>, <Line: +			if (floating || min % 1 || max % 1) {
>, <Line: +				var rand = nativeRandom();
>, <Line: +				return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
>, <Line: +			}
>, <Line: +			return baseRandom(min, max);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Resolves the value of property `key` on `object`. If `key` is a function
>, <Line: +		 * it will be invoked with the `this` binding of `object` and its result returned,
>, <Line: +		 * else the property value is returned. If `object` is falsey then `undefined`
>, <Line: +		 * is returned.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {Object} object The object to inspect.
>, <Line: +		 * @param {string} key The name of the property to resolve.
>, <Line: +		 * @returns {*} Returns the resolved value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var object = {
>, <Line: +		 *
>, <Line: +		 * _.result(object, 'cheese');
>, <Line: +		 * // => 'crumpets'
>, <Line: +		 *
>, <Line: +		 * _.result(object, 'stuff');
>, <Line: +		 * // => 'nonsense'
>, <Line: +		 */
>, <Line: +		function result(object, key) {
>, <Line: +			if (object) {
>, <Line: +				var value = object[key];
>, <Line: +				return isFunction(value) ? object[key]() : value;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * A micro-templating method that handles arbitrary delimiters, preserves
>, <Line: +		 * whitespace, and correctly escapes quotes within interpolated code.
>, <Line: +		 *
>, <Line: +		 * Note: In the development build, `_.template` utilizes sourceURLs for easier
>, <Line: +		 * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
>, <Line: +		 *
>, <Line: +		 * For more information on precompiling templates see:
>, <Line: +		 * http://lodash.com/custom-builds
>, <Line: +		 *
>, <Line: +		 * For more information on Chrome extension sandboxes see:
>, <Line: +		 * http://developer.chrome.com/stable/extensions/sandboxingEval.html
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} text The template text.
>, <Line: +		 * @param {Object} data The data object used to populate the text.
>, <Line: +		 * @param {Object} [options] The options object.
>, <Line: +		 * @param {RegExp} [options.escape] The "escape" delimiter.
>, <Line: +		 * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
>, <Line: +		 * @param {Object} [options.imports] An object to import into the template as local variables.
>, <Line: +		 * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
>, <Line: +		 * @param {string} [sourceURL] The sourceURL of the template's compiled source.
>, <Line: +		 * @param {string} [variable] The data object variable name.
>, <Line: +		 * @returns {Function|string} Returns a compiled function when no `data` object
>, <Line: +		 *  is given, else it returns the interpolated text.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * // using the "interpolate" delimiter to create a compiled template
>, <Line: +		 * var compiled = _.template('hello <%= name %>');
>, <Line: +		 * compiled({ 'name': 'fred' });
>, <Line: +		 * // => 'hello fred'
>, <Line: +		 *
>, <Line: +		 * // using the "escape" delimiter to escape HTML in data property values
>, <Line: +		 * _.template('<b><%- value %></b>', { 'value': '<script>' });
>, <Line: +		 * // => '<b>&lt;script&gt;</b>'
>, <Line: +		 *
>, <Line: +		 * // using the "evaluate" delimiter to generate HTML
>, <Line: +		 * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
>, <Line: +		 * _.template(list, { 'people': ['fred', 'barney'] });
>, <Line: +		 * // => '<li>fred</li><li>barney</li>'
>, <Line: +		 *
>, <Line: +		 * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
>, <Line: +		 * _.template('hello ${ name }', { 'name': 'pebbles' });
>, <Line: +		 * // => 'hello pebbles'
>, <Line: +		 *
>, <Line: +		 * // using the internal `print` function in "evaluate" delimiters
>, <Line: +		 * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
>, <Line: +		 * // => 'hello barney!'
>, <Line: +		 *
>, <Line: +		 * // using a custom template delimiters
>, <Line: +		 * _.templateSettings = {
>, <Line: +		 *
>, <Line: +		 * _.template('hello {{ name }}!', { 'name': 'mustache' });
>, <Line: +		 * // => 'hello mustache!'
>, <Line: +		 *
>, <Line: +		 * // using the `imports` option to import jQuery
>, <Line: +		 * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
>, <Line: +		 * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
>, <Line: +		 * // => '<li>fred</li><li>barney</li>'
>, <Line: +		 *
>, <Line: +		 * // using the `sourceURL` option to specify a custom sourceURL for the template
>, <Line: +		 * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
>, <Line: +		 * compiled(data);
>, <Line: +		 * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
>, <Line: +		 *
>, <Line: +		 * // using the `variable` option to ensure a with-statement isn't used in the compiled template
>, <Line: +		 * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
>, <Line: +		 * compiled.source;
>, <Line: +		 * // => function(data) {
>, <Line: +		 *
>, <Line: +		 * // using the `source` property to inline compiled templates for meaningful
>, <Line: +		 * // line numbers in error messages and a stack trace
>, <Line: +		 * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
>, <Line: +		 *   var JST = {\
>, <Line: +		 * ');
>, <Line: +		 */
>, <Line: +		function template(text, data, options) {
>, <Line: +			// based on John Resig's `tmpl` implementation
>, <Line: +			// http://ejohn.org/blog/javascript-micro-templating/
>, <Line: +			// and Laura Doktorova's doT.js
>, <Line: +			// https://github.com/olado/doT
>, <Line: +			var settings = lodash.templateSettings;
>, <Line: +			text = String(text || '');
>, <Line: +			// avoid missing dependencies when `iteratorTemplate` is not defined
>, <Line: +			options = defaults({}, options, settings);
>, <Line: +			var imports = defaults({}, options.imports, settings.imports),
>, <Line: +				importsKeys = keys(imports),
>, <Line: +				importsValues = values(imports);
>, <Line: +			var isEvaluating,
>, <Line: +				index = 0,
>, <Line: +				interpolate = options.interpolate || reNoMatch,
>, <Line: +				source = "__p += '";
>, <Line: +			// compile the regexp to match each delimiter
>, <Line: +			var reDelimiters = RegExp(
>, <Line: +				(options.escape || reNoMatch).source + '|' +
>, <Line: +				interpolate.source + '|' +
>, <Line: +				(interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
>, <Line: +				(options.evaluate || reNoMatch).source + '|$'
>, <Line: +				, 'g');
>, <Line: +			text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
>, <Line: +				interpolateValue || (interpolateValue = esTemplateValue);
>, <Line: +				// escape characters that cannot be included in string literals
>, <Line: +				source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
>, <Line: +				// replace delimiters with snippets
>, <Line: +				if (escapeValue) {
>, <Line: +					source += "' +\n__e(" + escapeValue + ") +\n'";
>, <Line: +				}
>, <Line: +				if (evaluateValue) {
>, <Line: +					isEvaluating = true;
>, <Line: +					source += "';\n" + evaluateValue + ";\n__p += '";
>, <Line: +				}
>, <Line: +				if (interpolateValue) {
>, <Line: +					source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
>, <Line: +				}
>, <Line: +				index = offset + match.length;
>, <Line: +				// the JS engine embedded in Adobe products requires returning the `match`
>, <Line: +				// string in order to produce the correct `offset` value
>, <Line: +				return match;
>, <Line: +			});
>, <Line: +			source += "';\n";
>, <Line: +			// if `variable` is not specified, wrap a with-statement around the generated
>, <Line: +			// code to add the data object to the top of the scope chain
>, <Line: +			var variable = options.variable,
>, <Line: +				hasVariable = variable;
>, <Line: +			if (!hasVariable) {
>, <Line: +				variable = 'obj';
>, <Line: +				source = 'with (' + variable + ') {\n' + source + '\n}\n';
>, <Line: +			}
>, <Line: +			// cleanup code by stripping empty strings
>, <Line: +			source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
>, <Line: +				.replace(reEmptyStringMiddle, '$1')
>, <Line: +				.replace(reEmptyStringTrailing, '$1;');
>, <Line: +			// frame code as the function body
>, <Line: +			source = 'function(' + variable + ') {\n' +
>, <Line: +				(hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
>, <Line: +				"var __t, __p = '', __e = _.escape" +
>, <Line: +				(isEvaluating
>, <Line: +						? ', __j = Array.prototype.join;\n' +
>, <Line: +					"function print() { __p += __j.call(arguments, '') }\n"
>, <Line: +						: ';\n'
>, <Line: +				) +
>, <Line: +				source +
>, <Line: +				'return __p\n}';
>, <Line: +			// Use a sourceURL for easier debugging.
>, <Line: +			// http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
>, <Line: +			var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
>, <Line: +			try {
>, <Line: +				var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
>, <Line: +			} catch (e) {
>, <Line: +				e.source = source;
>, <Line: +				throw e;
>, <Line: +			}
>, <Line: +			if (data) {
>, <Line: +				return result(data);
>, <Line: +			}
>, <Line: +			// provide the compiled function's source by its `toString` method, in
>, <Line: +			// supported environments, or the `source` property as a convenience for
>, <Line: +			// inlining compiled templates during the build process
>, <Line: +			result.source = source;
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Executes the callback `n` times, returning an array of the results
>, <Line: +		 * of each callback execution. The callback is bound to `thisArg` and invoked
>, <Line: +		 * with one argument; (index).
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {number} n The number of times to execute the callback.
>, <Line: +		 * @param {Function} callback The function called per iteration.
>, <Line: +		 * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: +		 * @returns {Array} Returns an array of the results of each `callback` execution.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
>, <Line: +		 * // => [3, 6, 4]
>, <Line: +		 *
>, <Line: +		 * _.times(3, function(n) { mage.castSpell(n); });
>, <Line: +		 * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
>, <Line: +		 *
>, <Line: +		 * _.times(3, function(n) { this.cast(n); }, mage);
>, <Line: +		 * // => also calls `mage.castSpell(n)` three times
>, <Line: +		 */
>, <Line: +		function times(n, callback, thisArg) {
>, <Line: +			n = (n = +n) > -1 ? n : 0;
>, <Line: +			var index = -1,
>, <Line: +				result = Array(n);
>, <Line: +			callback = baseCreateCallback(callback, thisArg, 1);
>, <Line: +			while (++index < n) {
>, <Line: +				result[index] = callback(index);
>, <Line: +			}
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * The inverse of `_.escape` this method converts the HTML entities
>, <Line: +		 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
>, <Line: +		 * corresponding characters.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} string The string to unescape.
>, <Line: +		 * @returns {string} Returns the unescaped string.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.unescape('Fred, Barney &amp; Pebbles');
>, <Line: +		 * // => 'Fred, Barney & Pebbles'
>, <Line: +		 */
>, <Line: +		function unescape(string) {
>, <Line: +			return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Utilities
>, <Line: +		 * @param {string} [prefix] The value to prefix the ID with.
>, <Line: +		 * @returns {string} Returns the unique ID.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _.uniqueId('contact_');
>, <Line: +		 * // => 'contact_104'
>, <Line: +		 *
>, <Line: +		 * _.uniqueId();
>, <Line: +		 * // => '105'
>, <Line: +		 */
>, <Line: +		function uniqueId(prefix) {
>, <Line: +			var id = ++idCounter;
>, <Line: +			return String(prefix == null ? '' : prefix) + id;
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * Creates a `lodash` object that wraps the given value with explicit
>, <Line: +		 * method chaining enabled.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Chaining
>, <Line: +		 * @param {*} value The value to wrap.
>, <Line: +		 * @returns {Object} Returns the wrapper object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney',  'age': 36 },
>, <Line: +		 *   { 'name': 'fred',    'age': 40 },
>, <Line: +		 *   { 'name': 'pebbles', 'age': 1 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * var youngest = _.chain(characters)
>, <Line: +		 *     .sortBy('age')
>, <Line: +		 *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
>, <Line: +		 *     .first()
>, <Line: +		 *     .value();
>, <Line: +		 * // => 'pebbles is 1'
>, <Line: +		 */
>, <Line: +		function chain(value) {
>, <Line: +			value = new lodashWrapper(value);
>, <Line: +			value.__chain__ = true;
>, <Line: +			return value;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Invokes `interceptor` with the `value` as the first argument and then
>, <Line: +		 * returns `value`. The purpose of this method is to "tap into" a method
>, <Line: +		 * chain in order to perform operations on intermediate results within
>, <Line: +		 * the chain.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Chaining
>, <Line: +		 * @param {*} value The value to provide to `interceptor`.
>, <Line: +		 * @param {Function} interceptor The function to invoke.
>, <Line: +		 * @returns {*} Returns `value`.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _([1, 2, 3, 4])
>, <Line: +		 *  .tap(function(array) { array.pop(); })
>, <Line: +		 *  .reverse()
>, <Line: +		 *  .value();
>, <Line: +		 * // => [3, 2, 1]
>, <Line: +		 */
>, <Line: +		function tap(value, interceptor) {
>, <Line: +			interceptor(value);
>, <Line: +			return value;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Enables explicit method chaining on the wrapper object.
>, <Line: +		 *
>, <Line: +		 * @name chain
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Chaining
>, <Line: +		 * @returns {*} Returns the wrapper object.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * var characters = [
>, <Line: +		 *   { 'name': 'barney', 'age': 36 },
>, <Line: +		 *   { 'name': 'fred',   'age': 40 }
>, <Line: +		 * ];
>, <Line: +		 *
>, <Line: +		 * // without explicit chaining
>, <Line: +		 * _(characters).first();
>, <Line: +		 * // => { 'name': 'barney', 'age': 36 }
>, <Line: +		 *
>, <Line: +		 * // with explicit chaining
>, <Line: +		 * _(characters).chain()
>, <Line: +		 *   .first()
>, <Line: +		 *   .pick('age')
>, <Line: +		 *   .value();
>, <Line: +		 * // => { 'age': 36 }
>, <Line: +		 */
>, <Line: +		function wrapperChain() {
>, <Line: +			this.__chain__ = true;
>, <Line: +			return this;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Produces the `toString` result of the wrapped value.
>, <Line: +		 *
>, <Line: +		 * @name toString
>, <Line: +		 * @memberOf _
>, <Line: +		 * @category Chaining
>, <Line: +		 * @returns {string} Returns the string result.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _([1, 2, 3]).toString();
>, <Line: +		 * // => '1,2,3'
>, <Line: +		 */
>, <Line: +		function wrapperToString() {
>, <Line: +			return String(this.__wrapped__);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Extracts the wrapped value.
>, <Line: +		 *
>, <Line: +		 * @name valueOf
>, <Line: +		 * @memberOf _
>, <Line: +		 * @alias value
>, <Line: +		 * @category Chaining
>, <Line: +		 * @returns {*} Returns the wrapped value.
>, <Line: +		 * @example
>, <Line: +		 *
>, <Line: +		 * _([1, 2, 3]).valueOf();
>, <Line: +		 * // => [1, 2, 3]
>, <Line: +		 */
>, <Line: +		function wrapperValueOf() {
>, <Line: +			return this.__wrapped__;
>, <Line: +		}
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		// add functions that return wrapped values when chaining
>, <Line: +		lodash.after = after;
>, <Line: +		lodash.assign = assign;
>, <Line: +		lodash.at = at;
>, <Line: +		lodash.bind = bind;
>, <Line: +		lodash.bindAll = bindAll;
>, <Line: +		lodash.bindKey = bindKey;
>, <Line: +		lodash.chain = chain;
>, <Line: +		lodash.compact = compact;
>, <Line: +		lodash.compose = compose;
>, <Line: +		lodash.constant = constant;
>, <Line: +		lodash.countBy = countBy;
>, <Line: +		lodash.create = create;
>, <Line: +		lodash.createCallback = createCallback;
>, <Line: +		lodash.curry = curry;
>, <Line: +		lodash.debounce = debounce;
>, <Line: +		lodash.defaults = defaults;
>, <Line: +		lodash.defer = defer;
>, <Line: +		lodash.delay = delay;
>, <Line: +		lodash.difference = difference;
>, <Line: +		lodash.filter = filter;
>, <Line: +		lodash.flatten = flatten;
>, <Line: +		lodash.forEach = forEach;
>, <Line: +		lodash.forEachRight = forEachRight;
>, <Line: +		lodash.forIn = forIn;
>, <Line: +		lodash.forInRight = forInRight;
>, <Line: +		lodash.forOwn = forOwn;
>, <Line: +		lodash.forOwnRight = forOwnRight;
>, <Line: +		lodash.functions = functions;
>, <Line: +		lodash.groupBy = groupBy;
>, <Line: +		lodash.indexBy = indexBy;
>, <Line: +		lodash.initial = initial;
>, <Line: +		lodash.intersection = intersection;
>, <Line: +		lodash.invert = invert;
>, <Line: +		lodash.invoke = invoke;
>, <Line: +		lodash.keys = keys;
>, <Line: +		lodash.map = map;
>, <Line: +		lodash.mapValues = mapValues;
>, <Line: +		lodash.max = max;
>, <Line: +		lodash.memoize = memoize;
>, <Line: +		lodash.merge = merge;
>, <Line: +		lodash.min = min;
>, <Line: +		lodash.omit = omit;
>, <Line: +		lodash.once = once;
>, <Line: +		lodash.pairs = pairs;
>, <Line: +		lodash.partial = partial;
>, <Line: +		lodash.partialRight = partialRight;
>, <Line: +		lodash.pick = pick;
>, <Line: +		lodash.pluck = pluck;
>, <Line: +		lodash.property = property;
>, <Line: +		lodash.pull = pull;
>, <Line: +		lodash.range = range;
>, <Line: +		lodash.reject = reject;
>, <Line: +		lodash.remove = remove;
>, <Line: +		lodash.rest = rest;
>, <Line: +		lodash.shuffle = shuffle;
>, <Line: +		lodash.sortBy = sortBy;
>, <Line: +		lodash.tap = tap;
>, <Line: +		lodash.throttle = throttle;
>, <Line: +		lodash.times = times;
>, <Line: +		lodash.toArray = toArray;
>, <Line: +		lodash.transform = transform;
>, <Line: +		lodash.union = union;
>, <Line: +		lodash.uniq = uniq;
>, <Line: +		lodash.values = values;
>, <Line: +		lodash.where = where;
>, <Line: +		lodash.without = without;
>, <Line: +		lodash.wrap = wrap;
>, <Line: +		lodash.xor = xor;
>, <Line: +		lodash.zip = zip;
>, <Line: +		lodash.zipObject = zipObject;
>, <Line: +		// add aliases
>, <Line: +		lodash.collect = map;
>, <Line: +		lodash.drop = rest;
>, <Line: +		lodash.each = forEach;
>, <Line: +		lodash.eachRight = forEachRight;
>, <Line: +		lodash.extend = assign;
>, <Line: +		lodash.methods = functions;
>, <Line: +		lodash.object = zipObject;
>, <Line: +		lodash.select = filter;
>, <Line: +		lodash.tail = rest;
>, <Line: +		lodash.unique = uniq;
>, <Line: +		lodash.unzip = zip;
>, <Line: +		// add functions to `lodash.prototype`
>, <Line: +		mixin(lodash);
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		// add functions that return unwrapped values when chaining
>, <Line: +		lodash.clone = clone;
>, <Line: +		lodash.cloneDeep = cloneDeep;
>, <Line: +		lodash.contains = contains;
>, <Line: +		lodash.escape = escape;
>, <Line: +		lodash.every = every;
>, <Line: +		lodash.find = find;
>, <Line: +		lodash.findIndex = findIndex;
>, <Line: +		lodash.findKey = findKey;
>, <Line: +		lodash.findLast = findLast;
>, <Line: +		lodash.findLastIndex = findLastIndex;
>, <Line: +		lodash.findLastKey = findLastKey;
>, <Line: +		lodash.has = has;
>, <Line: +		lodash.identity = identity;
>, <Line: +		lodash.indexOf = indexOf;
>, <Line: +		lodash.isArguments = isArguments;
>, <Line: +		lodash.isArray = isArray;
>, <Line: +		lodash.isBoolean = isBoolean;
>, <Line: +		lodash.isDate = isDate;
>, <Line: +		lodash.isElement = isElement;
>, <Line: +		lodash.isEmpty = isEmpty;
>, <Line: +		lodash.isEqual = isEqual;
>, <Line: +		lodash.isFinite = isFinite;
>, <Line: +		lodash.isFunction = isFunction;
>, <Line: +		lodash.isNaN = isNaN;
>, <Line: +		lodash.isNull = isNull;
>, <Line: +		lodash.isNumber = isNumber;
>, <Line: +		lodash.isObject = isObject;
>, <Line: +		lodash.isPlainObject = isPlainObject;
>, <Line: +		lodash.isRegExp = isRegExp;
>, <Line: +		lodash.isString = isString;
>, <Line: +		lodash.isUndefined = isUndefined;
>, <Line: +		lodash.lastIndexOf = lastIndexOf;
>, <Line: +		lodash.mixin = mixin;
>, <Line: +		lodash.noConflict = noConflict;
>, <Line: +		lodash.noop = noop;
>, <Line: +		lodash.now = now;
>, <Line: +		lodash.parseInt = parseInt;
>, <Line: +		lodash.random = random;
>, <Line: +		lodash.reduce = reduce;
>, <Line: +		lodash.reduceRight = reduceRight;
>, <Line: +		lodash.result = result;
>, <Line: +		lodash.runInContext = runInContext;
>, <Line: +		lodash.size = size;
>, <Line: +		lodash.some = some;
>, <Line: +		lodash.sortedIndex = sortedIndex;
>, <Line: +		lodash.template = template;
>, <Line: +		lodash.unescape = unescape;
>, <Line: +		lodash.uniqueId = uniqueId;
>, <Line: +		// add aliases
>, <Line: +		lodash.all = every;
>, <Line: +		lodash.any = some;
>, <Line: +		lodash.detect = find;
>, <Line: +		lodash.findWhere = find;
>, <Line: +		lodash.foldl = reduce;
>, <Line: +		lodash.foldr = reduceRight;
>, <Line: +		lodash.include = contains;
>, <Line: +		lodash.inject = reduce;
>, <Line: +		mixin(function () {
>, <Line: +			var source = {}
>, <Line: +			forOwn(lodash, function (func, methodName) {
>, <Line: +				if (!lodash.prototype[methodName]) {
>, <Line: +					source[methodName] = func;
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return source;
>, <Line: +		}(), false);
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		// add functions capable of returning wrapped and unwrapped values when chaining
>, <Line: +		lodash.first = first;
>, <Line: +		lodash.last = last;
>, <Line: +		lodash.sample = sample;
>, <Line: +		// add aliases
>, <Line: +		lodash.take = first;
>, <Line: +		lodash.head = first;
>, <Line: +		forOwn(lodash, function (func, methodName) {
>, <Line: +			var callbackable = methodName !== 'sample';
>, <Line: +			if (!lodash.prototype[methodName]) {
>, <Line: +				lodash.prototype[methodName] = function (n, guard) {
>, <Line: +					var chainAll = this.__chain__,
>, <Line: +						result = func(this.__wrapped__, n, guard);
>, <Line: +					return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
>, <Line: +						? result
>, <Line: +						: new lodashWrapper(result, chainAll);
>, <Line: +				};
>, <Line: +			}
>, <Line: +		});
>, <Line: +		/*--------------------------------------------------------------------------*/
>, <Line: +		/**
>, <Line: +		 * The semantic version number.
>, <Line: +		 *
>, <Line: +		 * @static
>, <Line: +		 * @memberOf _
>, <Line: +		 * @type string
>, <Line: +		 */
>, <Line: +		lodash.VERSION = '2.4.1';
>, <Line: +		// add "Chaining" functions to the wrapper
>, <Line: +		lodash.prototype.chain = wrapperChain;
>, <Line: +		lodash.prototype.toString = wrapperToString;
>, <Line: +		lodash.prototype.value = wrapperValueOf;
>, <Line: +		lodash.prototype.valueOf = wrapperValueOf;
>, <Line: +		// add `Array` functions that return unwrapped values
>, <Line: +		forEach(['join', 'pop', 'shift'], function (methodName) {
>, <Line: +			var func = arrayRef[methodName];
>, <Line: +			lodash.prototype[methodName] = function () {
>, <Line: +				var chainAll = this.__chain__,
>, <Line: +					result = func.apply(this.__wrapped__, arguments);
>, <Line: +				return chainAll
>, <Line: +					? new lodashWrapper(result, chainAll)
>, <Line: +					: result;
>, <Line: +			};
>, <Line: +		});
>, <Line: +		// add `Array` functions that return the existing wrapped value
>, <Line: +		forEach(['push', 'reverse', 'sort', 'unshift'], function (methodName) {
>, <Line: +			var func = arrayRef[methodName];
>, <Line: +			lodash.prototype[methodName] = function () {
>, <Line: +				func.apply(this.__wrapped__, arguments);
>, <Line: +				return this;
>, <Line: +			};
>, <Line: +		});
>, <Line: +		// add `Array` functions that return new wrapped values
>, <Line: +		forEach(['concat', 'slice', 'splice'], function (methodName) {
>, <Line: +			var func = arrayRef[methodName];
>, <Line: +			lodash.prototype[methodName] = function () {
>, <Line: +				return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
>, <Line: +			};
>, <Line: +		});
>, <Line: +		return lodash;
>, <Line: +	}
>, <Line: +	/*--------------------------------------------------------------------------*/
>, <Line: +	// expose Lo-Dash
>, <Line: +	var _ = runInContext();
>, <Line: +	// some AMD build optimizers like r.js check for condition patterns like the following:
>, <Line: +	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
>, <Line: +		// Expose Lo-Dash to the global object even when an AMD loader is present in
>, <Line: +		// case Lo-Dash is loaded with a RequireJS shim config.
>, <Line: +		// See http://requirejs.org/docs/api.html#config-shim
>, <Line: +		root._ = _;
>, <Line: +		// define as an anonymous module so, through path mapping, it can be
>, <Line: +		// referenced as the "underscore" module
>, <Line: +		define(function () {
>, <Line: +			return _;
>, <Line: +		});
>, <Line: +	}
>, <Line: +	// check for `exports` after `define` in case a build optimizer adds an `exports` object
>, <Line: +	else if (freeExports && freeModule) {
>, <Line: +		// in Node.js or RingoJS
>, <Line: +		if (moduleExports) {
>, <Line: +			(freeModule.exports = _)._ = _;
>, <Line: +		}
>, <Line: +		// in Narwhal or Rhino -require
>, <Line: +		else {
>, <Line: +			freeExports._ = _;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	else {
>, <Line: +		// in a browser or Rhino
>, <Line: +		root._ = _;
>, <Line: +	}
>]
[<Line: -;(function() {
>, <Line: -  /** Used as a safe reference for `undefined` in pre ES5 environments */
>, <Line: -  var undefined;
>, <Line: -  /** Used to pool arrays and objects used internally */
>, <Line: -  var arrayPool = [],
>, <Line: -      objectPool = [];
>, <Line: -  /** Used to generate unique IDs */
>, <Line: -  var idCounter = 0;
>, <Line: -  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
>, <Line: -  var keyPrefix = +new Date + '';
>, <Line: -  /** Used as the size when optimizations are enabled for large arrays */
>, <Line: -  var largeArraySize = 75;
>, <Line: -  /** Used as the max size of the `arrayPool` and `objectPool` */
>, <Line: -  var maxPoolSize = 40;
>, <Line: -  /** Used to detect and test whitespace */
>, <Line: -  var whitespace = (
>, <Line: -    // whitespace
>, <Line: -    ' \t\x0B\f\xA0\ufeff' +
>, <Line: -    // line terminators
>, <Line: -    '\n\r\u2028\u2029' +
>, <Line: -    // unicode category "Zs" space separators
>, <Line: -    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
>, <Line: -  );
>, <Line: -  /** Used to match empty string literals in compiled template source */
>, <Line: -  var reEmptyStringLeading = /\b__p \+= '';/g,
>, <Line: -      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
>, <Line: -      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
>, <Line: -  /**
>, <Line: -   * Used to match ES6 template delimiters
>, <Line: -   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
>, <Line: -   */
>, <Line: -  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
>, <Line: -  /** Used to match regexp flags from their coerced string values */
>, <Line: -  var reFlags = /\w*$/;
>, <Line: -  /** Used to detected named functions */
>, <Line: -  var reFuncName = /^\s*function[ \n\r\t]+\w/;
>, <Line: -  /** Used to match "interpolate" template delimiters */
>, <Line: -  var reInterpolate = /<%=([\s\S]+?)%>/g;
>, <Line: -  /** Used to match leading whitespace and zeros to be removed */
>, <Line: -  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
>, <Line: -  /** Used to ensure capturing order of template delimiters */
>, <Line: -  var reNoMatch = /($^)/;
>, <Line: -  /** Used to detect functions containing a `this` reference */
>, <Line: -  var reThis = /\bthis\b/;
>, <Line: -  /** Used to match unescaped characters in compiled string literals */
>, <Line: -  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
>, <Line: -  /** Used to assign default `context` object properties */
>, <Line: -  var contextProps = [
>, <Line: -    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
>, <Line: -    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
>, <Line: -    'parseInt', 'setTimeout'
>, <Line: -  ];
>, <Line: -  /** Used to make template sourceURLs easier to identify */
>, <Line: -  var templateCounter = 0;
>, <Line: -  /** `Object#toString` result shortcuts */
>, <Line: -  var argsClass = '[object Arguments]',
>, <Line: -      arrayClass = '[object Array]',
>, <Line: -      boolClass = '[object Boolean]',
>, <Line: -      dateClass = '[object Date]',
>, <Line: -      funcClass = '[object Function]',
>, <Line: -      numberClass = '[object Number]',
>, <Line: -      objectClass = '[object Object]',
>, <Line: -      regexpClass = '[object RegExp]',
>, <Line: -      stringClass = '[object String]';
>, <Line: -  /** Used to identify object classifications that `_.clone` supports */
>, <Line: -  var cloneableClasses = {};
>, <Line: -  cloneableClasses[funcClass] = false;
>, <Line: -  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
>, <Line: -  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
>, <Line: -  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
>, <Line: -  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
>, <Line: -  /** Used as an internal `_.debounce` options object */
>, <Line: -  var debounceOptions = {
>, <Line: -    'leading': false,
>, <Line: -    'maxWait': 0,
>, <Line: -    'trailing': false
>, <Line: -  };
>, <Line: -  /** Used as the property descriptor for `__bindData__` */
>, <Line: -  var descriptor = {
>, <Line: -    'configurable': false,
>, <Line: -    'enumerable': false,
>, <Line: -    'value': null,
>, <Line: -    'writable': false
>, <Line: -  };
>, <Line: -  /** Used to determine if values are of the language type Object */
>, <Line: -  var objectTypes = {
>, <Line: -    'boolean': false,
>, <Line: -    'function': true,
>, <Line: -    'object': true,
>, <Line: -    'number': false,
>, <Line: -    'string': false,
>, <Line: -    'undefined': false
>, <Line: -  };
>, <Line: -  /** Used to escape characters for inclusion in compiled string literals */
>, <Line: -  var stringEscapes = {
>, <Line: -    '\\': '\\',
>, <Line: -    "'": "'",
>, <Line: -    '\n': 'n',
>, <Line: -    '\r': 'r',
>, <Line: -    '\t': 't',
>, <Line: -    '\u2028': 'u2028',
>, <Line: -    '\u2029': 'u2029'
>, <Line: -  };
>, <Line: -  /** Used as a reference to the global object */
>, <Line: -  var root = (objectTypes[typeof window] && window) || this;
>, <Line: -  /** Detect free variable `exports` */
>, <Line: -  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
>, <Line: -  /** Detect free variable `module` */
>, <Line: -  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
>, <Line: -  /** Detect the popular CommonJS extension `module.exports` */
>, <Line: -  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
>, <Line: -  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
>, <Line: -  var freeGlobal = objectTypes[typeof global] && global;
>, <Line: -  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
>, <Line: -    root = freeGlobal;
>, <Line: -  }
>, <Line: -  /*--------------------------------------------------------------------------*/
>, <Line: -  /**
>, <Line: -   * The base implementation of `_.indexOf` without support for binary searches
>, <Line: -   * or `fromIndex` constraints.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Array} array The array to search.
>, <Line: -   * @param {*} value The value to search for.
>, <Line: -   * @param {number} [fromIndex=0] The index to search from.
>, <Line: -   * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: -   */
>, <Line: -  function baseIndexOf(array, value, fromIndex) {
>, <Line: -    var index = (fromIndex || 0) - 1,
>, <Line: -        length = array ? array.length : 0;
>, <Line: -    while (++index < length) {
>, <Line: -      if (array[index] === value) {
>, <Line: -        return index;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return -1;
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * An implementation of `_.contains` for cache objects that mimics the return
>, <Line: -   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Object} cache The cache object to inspect.
>, <Line: -   * @param {*} value The value to search for.
>, <Line: -   * @returns {number} Returns `0` if `value` is found, else `-1`.
>, <Line: -   */
>, <Line: -  function cacheIndexOf(cache, value) {
>, <Line: -    var type = typeof value;
>, <Line: -    cache = cache.cache;
>, <Line: -    if (type == 'boolean' || value == null) {
>, <Line: -      return cache[value] ? 0 : -1;
>, <Line: -    }
>, <Line: -    if (type != 'number' && type != 'string') {
>, <Line: -      type = 'object';
>, <Line: -    }
>, <Line: -    var key = type == 'number' ? value : keyPrefix + value;
>, <Line: -    cache = (cache = cache[type]) && cache[key];
>, <Line: -    return type == 'object'
>, <Line: -      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
>, <Line: -      : (cache ? 0 : -1);
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Adds a given value to the corresponding cache object.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {*} value The value to add to the cache.
>, <Line: -   */
>, <Line: -  function cachePush(value) {
>, <Line: -    var cache = this.cache,
>, <Line: -        type = typeof value;
>, <Line: -    if (type == 'boolean' || value == null) {
>, <Line: -      cache[value] = true;
>, <Line: -    } else {
>, <Line: -      if (type != 'number' && type != 'string') {
>, <Line: -        type = 'object';
>, <Line: -      }
>, <Line: -      var key = type == 'number' ? value : keyPrefix + value,
>, <Line: -          typeCache = cache[type] || (cache[type] = {});
>, <Line: -      if (type == 'object') {
>, <Line: -        (typeCache[key] || (typeCache[key] = [])).push(value);
>, <Line: -      } else {
>, <Line: -        typeCache[key] = true;
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Used by `_.max` and `_.min` as the default callback when a given
>, <Line: -   * collection is a string value.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {string} value The character to inspect.
>, <Line: -   * @returns {number} Returns the code unit of given character.
>, <Line: -   */
>, <Line: -  function charAtCallback(value) {
>, <Line: -    return value.charCodeAt(0);
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
>, <Line: -   * them in ascending order.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Object} a The object to compare to `b`.
>, <Line: -   * @param {Object} b The object to compare to `a`.
>, <Line: -   * @returns {number} Returns the sort order indicator of `1` or `-1`.
>, <Line: -   */
>, <Line: -  function compareAscending(a, b) {
>, <Line: -    var ac = a.criteria,
>, <Line: -        bc = b.criteria,
>, <Line: -        index = -1,
>, <Line: -        length = ac.length;
>, <Line: -    while (++index < length) {
>, <Line: -      var value = ac[index],
>, <Line: -          other = bc[index];
>, <Line: -      if (value !== other) {
>, <Line: -        if (value > other || typeof value == 'undefined') {
>, <Line: -          return 1;
>, <Line: -        }
>, <Line: -        if (value < other || typeof other == 'undefined') {
>, <Line: -          return -1;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
>, <Line: -    // that causes it, under certain circumstances, to return the same value for
>, <Line: -    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
>, <Line: -    //
>, <Line: -    // This also ensures a stable sort in V8 and other engines.
>, <Line: -    // See http://code.google.com/p/v8/issues/detail?id=90
>, <Line: -    return a.index - b.index;
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Creates a cache object to optimize linear searches of large arrays.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Array} [array=[]] The array to search.
>, <Line: -   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
>, <Line: -   */
>, <Line: -  function createCache(array) {
>, <Line: -    var index = -1,
>, <Line: -        length = array.length,
>, <Line: -        first = array[0],
>, <Line: -        mid = array[(length / 2) | 0],
>, <Line: -        last = array[length - 1];
>, <Line: -    if (first && typeof first == 'object' &&
>, <Line: -        mid && typeof mid == 'object' && last && typeof last == 'object') {
>, <Line: -      return false;
>, <Line: -    }
>, <Line: -    var cache = getObject();
>, <Line: -    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
>, <Line: -    var result = getObject();
>, <Line: -    result.array = array;
>, <Line: -    result.cache = cache;
>, <Line: -    result.push = cachePush;
>, <Line: -    while (++index < length) {
>, <Line: -      result.push(array[index]);
>, <Line: -    }
>, <Line: -    return result;
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Used by `template` to escape characters for inclusion in compiled
>, <Line: -   * string literals.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {string} match The matched character to escape.
>, <Line: -   * @returns {string} Returns the escaped character.
>, <Line: -   */
>, <Line: -  function escapeStringChar(match) {
>, <Line: -    return '\\' + stringEscapes[match];
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Gets an array from the array pool or creates a new one if the pool is empty.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @returns {Array} The array from the pool.
>, <Line: -   */
>, <Line: -  function getArray() {
>, <Line: -    return arrayPool.pop() || [];
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Gets an object from the object pool or creates a new one if the pool is empty.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @returns {Object} The object from the pool.
>, <Line: -   */
>, <Line: -  function getObject() {
>, <Line: -    return objectPool.pop() || {
>, <Line: -      'array': null,
>, <Line: -      'cache': null,
>, <Line: -      'criteria': null,
>, <Line: -      'false': false,
>, <Line: -      'index': 0,
>, <Line: -      'null': false,
>, <Line: -      'number': null,
>, <Line: -      'object': null,
>, <Line: -      'push': null,
>, <Line: -      'string': null,
>, <Line: -      'true': false,
>, <Line: -      'undefined': false,
>, <Line: -      'value': null
>, <Line: -    };
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Releases the given array back to the array pool.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Array} [array] The array to release.
>, <Line: -   */
>, <Line: -  function releaseArray(array) {
>, <Line: -    array.length = 0;
>, <Line: -    if (arrayPool.length < maxPoolSize) {
>, <Line: -      arrayPool.push(array);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Releases the given object back to the object pool.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Object} [object] The object to release.
>, <Line: -   */
>, <Line: -  function releaseObject(object) {
>, <Line: -    var cache = object.cache;
>, <Line: -    if (cache) {
>, <Line: -      releaseObject(cache);
>, <Line: -    }
>, <Line: -    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
>, <Line: -    if (objectPool.length < maxPoolSize) {
>, <Line: -      objectPool.push(object);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Slices the `collection` from the `start` index up to, but not including,
>, <Line: -   * the `end` index.
>, <Line: -   *
>, <Line: -   * Note: This function is used instead of `Array#slice` to support node lists
>, <Line: -   * in IE < 9 and to ensure dense arrays are returned.
>, <Line: -   *
>, <Line: -   * @private
>, <Line: -   * @param {Array|Object|string} collection The collection to slice.
>, <Line: -   * @param {number} start The start index.
>, <Line: -   * @param {number} end The end index.
>, <Line: -   * @returns {Array} Returns the new array.
>, <Line: -   */
>, <Line: -  function slice(array, start, end) {
>, <Line: -    start || (start = 0);
>, <Line: -    if (typeof end == 'undefined') {
>, <Line: -      end = array ? array.length : 0;
>, <Line: -    }
>, <Line: -    var index = -1,
>, <Line: -        length = end - start || 0,
>, <Line: -        result = Array(length < 0 ? 0 : length);
>, <Line: -    while (++index < length) {
>, <Line: -      result[index] = array[start + index];
>, <Line: -    }
>, <Line: -    return result;
>, <Line: -  }
>, <Line: -  /*--------------------------------------------------------------------------*/
>, <Line: -  /**
>, <Line: -   * Create a new `lodash` function using the given context object.
>, <Line: -   *
>, <Line: -   * @static
>, <Line: -   * @memberOf _
>, <Line: -   * @category Utilities
>, <Line: -   * @param {Object} [context=root] The context object.
>, <Line: -   * @returns {Function} Returns the `lodash` function.
>, <Line: -   */
>, <Line: -  function runInContext(context) {
>, <Line: -    // Avoid issues with some ES3 environments that attempt to use values, named
>, <Line: -    // after built-in constructors like `Object`, for the creation of literals.
>, <Line: -    // ES5 clears this up by stating that literals must use built-in constructors.
>, <Line: -    // See http://es5.github.io/#x11.1.5.
>, <Line: -    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
>, <Line: -    /** Native constructor references */
>, <Line: -    var Array = context.Array,
>, <Line: -        Boolean = context.Boolean,
>, <Line: -        Date = context.Date,
>, <Line: -        Function = context.Function,
>, <Line: -        Math = context.Math,
>, <Line: -        Number = context.Number,
>, <Line: -        Object = context.Object,
>, <Line: -        RegExp = context.RegExp,
>, <Line: -        String = context.String,
>, <Line: -        TypeError = context.TypeError;
>, <Line: -    /**
>, <Line: -     * Used for `Array` method references.
>, <Line: -     *
>, <Line: -     * Normally `Array.prototype` would suffice, however, using an array literal
>, <Line: -     * avoids issues in Narwhal.
>, <Line: -     */
>, <Line: -    var arrayRef = [];
>, <Line: -    /** Used for native method references */
>, <Line: -    var objectProto = Object.prototype;
>, <Line: -    /** Used to restore the original `_` reference in `noConflict` */
>, <Line: -    var oldDash = context._;
>, <Line: -    /** Used to resolve the internal [[Class]] of values */
>, <Line: -    var toString = objectProto.toString;
>, <Line: -    /** Used to detect if a method is native */
>, <Line: -    var reNative = RegExp('^' +
>, <Line: -      String(toString)
>, <Line: -        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
>, <Line: -        .replace(/toString| for [^\]]+/g, '.*?') + '$'
>, <Line: -    );
>, <Line: -    /** Native method shortcuts */
>, <Line: -    var ceil = Math.ceil,
>, <Line: -        clearTimeout = context.clearTimeout,
>, <Line: -        floor = Math.floor,
>, <Line: -        fnToString = Function.prototype.toString,
>, <Line: -        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
>, <Line: -        hasOwnProperty = objectProto.hasOwnProperty,
>, <Line: -        push = arrayRef.push,
>, <Line: -        setTimeout = context.setTimeout,
>, <Line: -        splice = arrayRef.splice,
>, <Line: -        unshift = arrayRef.unshift;
>, <Line: -    /** Used to set meta data on functions */
>, <Line: -    var defineProperty = (function() {
>, <Line: -      // IE 8 only accepts DOM elements
>, <Line: -      try {
>, <Line: -        var o = {},
>, <Line: -            func = isNative(func = Object.defineProperty) && func,
>, <Line: -            result = func(o, o, o) && func;
>, <Line: -      } catch(e) { }
>, <Line: -      return result;
>, <Line: -    }());
>, <Line: -    /* Native method shortcuts for methods with the same name as other `lodash` methods */
>, <Line: -    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
>, <Line: -        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
>, <Line: -        nativeIsFinite = context.isFinite,
>, <Line: -        nativeIsNaN = context.isNaN,
>, <Line: -        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
>, <Line: -        nativeMax = Math.max,
>, <Line: -        nativeMin = Math.min,
>, <Line: -        nativeParseInt = context.parseInt,
>, <Line: -        nativeRandom = Math.random;
>, <Line: -    /** Used to lookup a built-in constructor by [[Class]] */
>, <Line: -    var ctorByClass = {};
>, <Line: -    ctorByClass[arrayClass] = Array;
>, <Line: -    ctorByClass[boolClass] = Boolean;
>, <Line: -    ctorByClass[dateClass] = Date;
>, <Line: -    ctorByClass[funcClass] = Function;
>, <Line: -    ctorByClass[objectClass] = Object;
>, <Line: -    ctorByClass[numberClass] = Number;
>, <Line: -    ctorByClass[regexpClass] = RegExp;
>, <Line: -    ctorByClass[stringClass] = String;
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates a `lodash` object which wraps the given value to enable intuitive
>, <Line: -     * method chaining.
>, <Line: -     *
>, <Line: -     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
>, <Line: -     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
>, <Line: -     * and `unshift`
>, <Line: -     *
>, <Line: -     * Chaining is supported in custom builds as long as the `value` method is
>, <Line: -     * implicitly or explicitly included in the build.
>, <Line: -     *
>, <Line: -     * The chainable wrapper functions are:
>, <Line: -     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
>, <Line: -     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
>, <Line: -     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
>, <Line: -     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
>, <Line: -     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
>, <Line: -     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
>, <Line: -     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
>, <Line: -     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
>, <Line: -     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
>, <Line: -     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
>, <Line: -     * and `zip`
>, <Line: -     *
>, <Line: -     * The non-chainable wrapper functions are:
>, <Line: -     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
>, <Line: -     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
>, <Line: -     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
>, <Line: -     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
>, <Line: -     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
>, <Line: -     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
>, <Line: -     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
>, <Line: -     * `template`, `unescape`, `uniqueId`, and `value`
>, <Line: -     *
>, <Line: -     * The wrapper functions `first` and `last` return wrapped values when `n` is
>, <Line: -     * provided, otherwise they return unwrapped values.
>, <Line: -     *
>, <Line: -     * Explicit chaining can be enabled by using the `_.chain` method.
>, <Line: -     *
>, <Line: -     * @name _
>, <Line: -     * @constructor
>, <Line: -     * @category Chaining
>, <Line: -     * @param {*} value The value to wrap in a `lodash` instance.
>, <Line: -     * @returns {Object} Returns a `lodash` instance.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var wrapped = _([1, 2, 3]);
>, <Line: -     *
>, <Line: -     * // returns an unwrapped value
>, <Line: -     * wrapped.reduce(function(sum, num) {
>, <Line: -     * // => 6
>, <Line: -     *
>, <Line: -     * // returns a wrapped value
>, <Line: -     * var squares = wrapped.map(function(num) {
>, <Line: -     *
>, <Line: -     * _.isArray(squares);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isArray(squares.value());
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function lodash(value) {
>, <Line: -      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
>, <Line: -      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
>, <Line: -       ? value
>, <Line: -       : new lodashWrapper(value);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * A fast path for creating `lodash` wrapper objects.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} value The value to wrap in a `lodash` instance.
>, <Line: -     * @param {boolean} chainAll A flag to enable chaining for all methods
>, <Line: -     * @returns {Object} Returns a `lodash` instance.
>, <Line: -     */
>, <Line: -    function lodashWrapper(value, chainAll) {
>, <Line: -      this.__chain__ = !!chainAll;
>, <Line: -      this.__wrapped__ = value;
>, <Line: -    }
>, <Line: -    // ensure `new lodashWrapper` is an instance of `lodash`
>, <Line: -    lodashWrapper.prototype = lodash.prototype;
>, <Line: -    /**
>, <Line: -     * An object used to flag environments features.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Object
>, <Line: -     */
>, <Line: -    var support = lodash.support = {};
>, <Line: -    /**
>, <Line: -     * Detect if functions can be decompiled by `Function#toString`
>, <Line: -     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
>, <Line: -     *
>, <Line: -     * @memberOf _.support
>, <Line: -     * @type boolean
>, <Line: -     */
>, <Line: -    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
>, <Line: -    /**
>, <Line: -     * Detect if `Function#name` is supported (all but IE).
>, <Line: -     *
>, <Line: -     * @memberOf _.support
>, <Line: -     * @type boolean
>, <Line: -     */
>, <Line: -    support.funcNames = typeof Function.name == 'string';
>, <Line: -    /**
>, <Line: -     * By default, the template delimiters used by Lo-Dash are similar to those in
>, <Line: -     * embedded Ruby (ERB). Change the following template settings to use alternative
>, <Line: -     * delimiters.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Object
>, <Line: -     */
>, <Line: -    lodash.templateSettings = {
>, <Line: -      /**
>, <Line: -       * Used to detect `data` property values to be HTML-escaped.
>, <Line: -       *
>, <Line: -       * @memberOf _.templateSettings
>, <Line: -       * @type RegExp
>, <Line: -       */
>, <Line: -      'escape': /<%-([\s\S]+?)%>/g,
>, <Line: -      /**
>, <Line: -       * Used to detect code to be evaluated.
>, <Line: -       *
>, <Line: -       * @memberOf _.templateSettings
>, <Line: -       * @type RegExp
>, <Line: -       */
>, <Line: -      'evaluate': /<%([\s\S]+?)%>/g,
>, <Line: -      /**
>, <Line: -       * Used to detect `data` property values to inject.
>, <Line: -       *
>, <Line: -       * @memberOf _.templateSettings
>, <Line: -       * @type RegExp
>, <Line: -       */
>, <Line: -      'interpolate': reInterpolate,
>, <Line: -      /**
>, <Line: -       * Used to reference the data object in the template text.
>, <Line: -       *
>, <Line: -       * @memberOf _.templateSettings
>, <Line: -       * @type string
>, <Line: -       */
>, <Line: -      'variable': '',
>, <Line: -      /**
>, <Line: -       * Used to import variables into the compiled template.
>, <Line: -       *
>, <Line: -       * @memberOf _.templateSettings
>, <Line: -       * @type Object
>, <Line: -       */
>, <Line: -      'imports': {
>, <Line: -        /**
>, <Line: -         * A reference to the `lodash` function.
>, <Line: -         *
>, <Line: -         * @memberOf _.templateSettings.imports
>, <Line: -         * @type Function
>, <Line: -         */
>, <Line: -        '_': lodash
>, <Line: -      }
>, <Line: -    };
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.bind` that creates the bound function and
>, <Line: -     * sets its meta data.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Array} bindData The bind data array.
>, <Line: -     * @returns {Function} Returns the new bound function.
>, <Line: -     */
>, <Line: -    function baseBind(bindData) {
>, <Line: -      var func = bindData[0],
>, <Line: -          partialArgs = bindData[2],
>, <Line: -          thisArg = bindData[4];
>, <Line: -      function bound() {
>, <Line: -        // `Function#bind` spec
>, <Line: -        // http://es5.github.io/#x15.3.4.5
>, <Line: -        if (partialArgs) {
>, <Line: -          // avoid `arguments` object deoptimizations by using `slice` instead
>, <Line: -          // of `Array.prototype.slice.call` and not assigning `arguments` to a
>, <Line: -          // variable as a ternary expression
>, <Line: -          var args = slice(partialArgs);
>, <Line: -          push.apply(args, arguments);
>, <Line: -        }
>, <Line: -        // mimic the constructor's `return` behavior
>, <Line: -        // http://es5.github.io/#x13.2.2
>, <Line: -        if (this instanceof bound) {
>, <Line: -          // ensure `new bound` is an instance of `func`
>, <Line: -          var thisBinding = baseCreate(func.prototype),
>, <Line: -              result = func.apply(thisBinding, args || arguments);
>, <Line: -          return isObject(result) ? result : thisBinding;
>, <Line: -        }
>, <Line: -        return func.apply(thisArg, args || arguments);
>, <Line: -      }
>, <Line: -      setBindData(bound, bindData);
>, <Line: -      return bound;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.clone` without argument juggling or support
>, <Line: -     * for `thisArg` binding.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} value The value to clone.
>, <Line: -     * @param {boolean} [isDeep=false] Specify a deep clone.
>, <Line: -     * @param {Function} [callback] The function to customize cloning values.
>, <Line: -     * @param {Array} [stackA=[]] Tracks traversed source objects.
>, <Line: -     * @param {Array} [stackB=[]] Associates clones with source counterparts.
>, <Line: -     * @returns {*} Returns the cloned value.
>, <Line: -     */
>, <Line: -    function baseClone(value, isDeep, callback, stackA, stackB) {
>, <Line: -      if (callback) {
>, <Line: -        var result = callback(value);
>, <Line: -        if (typeof result != 'undefined') {
>, <Line: -          return result;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // inspect [[Class]]
>, <Line: -      var isObj = isObject(value);
>, <Line: -      if (isObj) {
>, <Line: -        var className = toString.call(value);
>, <Line: -        if (!cloneableClasses[className]) {
>, <Line: -          return value;
>, <Line: -        }
>, <Line: -        var ctor = ctorByClass[className];
>, <Line: -        switch (className) {
>, <Line: -          case boolClass:
>, <Line: -          case dateClass:
>, <Line: -            return new ctor(+value);
>, <Line: -          case numberClass:
>, <Line: -          case stringClass:
>, <Line: -            return new ctor(value);
>, <Line: -          case regexpClass:
>, <Line: -            result = ctor(value.source, reFlags.exec(value));
>, <Line: -            result.lastIndex = value.lastIndex;
>, <Line: -            return result;
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        return value;
>, <Line: -      }
>, <Line: -      var isArr = isArray(value);
>, <Line: -      if (isDeep) {
>, <Line: -        // check for circular references and return corresponding clone
>, <Line: -        var initedStack = !stackA;
>, <Line: -        stackA || (stackA = getArray());
>, <Line: -        stackB || (stackB = getArray());
>, <Line: -        var length = stackA.length;
>, <Line: -        while (length--) {
>, <Line: -          if (stackA[length] == value) {
>, <Line: -            return stackB[length];
>, <Line: -          }
>, <Line: -        }
>, <Line: -        result = isArr ? ctor(value.length) : {};
>, <Line: -      }
>, <Line: -      else {
>, <Line: -        result = isArr ? slice(value) : assign({}, value);
>, <Line: -      }
>, <Line: -      // add array properties assigned by `RegExp#exec`
>, <Line: -      if (isArr) {
>, <Line: -        if (hasOwnProperty.call(value, 'index')) {
>, <Line: -          result.index = value.index;
>, <Line: -        }
>, <Line: -        if (hasOwnProperty.call(value, 'input')) {
>, <Line: -          result.input = value.input;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // exit for shallow clone
>, <Line: -      if (!isDeep) {
>, <Line: -        return result;
>, <Line: -      }
>, <Line: -      // add the source value to the stack of traversed objects
>, <Line: -      // and associate it with its clone
>, <Line: -      stackA.push(value);
>, <Line: -      stackB.push(result);
>, <Line: -      // recursively populate clone (susceptible to call stack limits)
>, <Line: -      (isArr ? forEach : forOwn)(value, function(objValue, key) {
>, <Line: -        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
>, <Line: -      });
>, <Line: -      if (initedStack) {
>, <Line: -        releaseArray(stackA);
>, <Line: -        releaseArray(stackB);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.create` without support for assigning
>, <Line: -     * properties to the created object.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Object} prototype The object to inherit from.
>, <Line: -     * @returns {Object} Returns the new object.
>, <Line: -     */
>, <Line: -    function baseCreate(prototype, properties) {
>, <Line: -      return isObject(prototype) ? nativeCreate(prototype) : {};
>, <Line: -    }
>, <Line: -    // fallback for browsers without `Object.create`
>, <Line: -    if (!nativeCreate) {
>, <Line: -      baseCreate = (function() {
>, <Line: -        function Object() {}
>, <Line: -        return function(prototype) {
>, <Line: -          if (isObject(prototype)) {
>, <Line: -            Object.prototype = prototype;
>, <Line: -            var result = new Object;
>, <Line: -            Object.prototype = null;
>, <Line: -          }
>, <Line: -          return result || context.Object();
>, <Line: -        };
>, <Line: -      }());
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.createCallback` without support for creating
>, <Line: -     * "_.pluck" or "_.where" style callbacks.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} [func=identity] The value to convert to a callback.
>, <Line: -     * @param {*} [thisArg] The `this` binding of the created callback.
>, <Line: -     * @param {number} [argCount] The number of arguments the callback accepts.
>, <Line: -     * @returns {Function} Returns a callback function.
>, <Line: -     */
>, <Line: -    function baseCreateCallback(func, thisArg, argCount) {
>, <Line: -      if (typeof func != 'function') {
>, <Line: -        return identity;
>, <Line: -      }
>, <Line: -      // exit early for no `thisArg` or already bound by `Function#bind`
>, <Line: -      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
>, <Line: -        return func;
>, <Line: -      }
>, <Line: -      var bindData = func.__bindData__;
>, <Line: -      if (typeof bindData == 'undefined') {
>, <Line: -        if (support.funcNames) {
>, <Line: -          bindData = !func.name;
>, <Line: -        }
>, <Line: -        bindData = bindData || !support.funcDecomp;
>, <Line: -        if (!bindData) {
>, <Line: -          var source = fnToString.call(func);
>, <Line: -          if (!support.funcNames) {
>, <Line: -            bindData = !reFuncName.test(source);
>, <Line: -          }
>, <Line: -          if (!bindData) {
>, <Line: -            // checks if `func` references the `this` keyword and stores the result
>, <Line: -            bindData = reThis.test(source);
>, <Line: -            setBindData(func, bindData);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // exit early if there are no `this` references or `func` is bound
>, <Line: -      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
>, <Line: -        return func;
>, <Line: -      }
>, <Line: -      switch (argCount) {
>, <Line: -        case 1: return function(value) {
>, <Line: -          return func.call(thisArg, value);
>, <Line: -        };
>, <Line: -        case 2: return function(a, b) {
>, <Line: -          return func.call(thisArg, a, b);
>, <Line: -        };
>, <Line: -        case 3: return function(value, index, collection) {
>, <Line: -          return func.call(thisArg, value, index, collection);
>, <Line: -        };
>, <Line: -        case 4: return function(accumulator, value, index, collection) {
>, <Line: -          return func.call(thisArg, accumulator, value, index, collection);
>, <Line: -        };
>, <Line: -      }
>, <Line: -      return bind(func, thisArg);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `createWrapper` that creates the wrapper and
>, <Line: -     * sets its meta data.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Array} bindData The bind data array.
>, <Line: -     * @returns {Function} Returns the new function.
>, <Line: -     */
>, <Line: -    function baseCreateWrapper(bindData) {
>, <Line: -      var func = bindData[0],
>, <Line: -          bitmask = bindData[1],
>, <Line: -          partialArgs = bindData[2],
>, <Line: -          partialRightArgs = bindData[3],
>, <Line: -          thisArg = bindData[4],
>, <Line: -          arity = bindData[5];
>, <Line: -      var isBind = bitmask & 1,
>, <Line: -          isBindKey = bitmask & 2,
>, <Line: -          isCurry = bitmask & 4,
>, <Line: -          isCurryBound = bitmask & 8,
>, <Line: -          key = func;
>, <Line: -      function bound() {
>, <Line: -        var thisBinding = isBind ? thisArg : this;
>, <Line: -        if (partialArgs) {
>, <Line: -          var args = slice(partialArgs);
>, <Line: -          push.apply(args, arguments);
>, <Line: -        }
>, <Line: -        if (partialRightArgs || isCurry) {
>, <Line: -          args || (args = slice(arguments));
>, <Line: -          if (partialRightArgs) {
>, <Line: -            push.apply(args, partialRightArgs);
>, <Line: -          }
>, <Line: -          if (isCurry && args.length < arity) {
>, <Line: -            bitmask |= 16 & ~32;
>, <Line: -            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        args || (args = arguments);
>, <Line: -        if (isBindKey) {
>, <Line: -          func = thisBinding[key];
>, <Line: -        }
>, <Line: -        if (this instanceof bound) {
>, <Line: -          thisBinding = baseCreate(func.prototype);
>, <Line: -          var result = func.apply(thisBinding, args);
>, <Line: -          return isObject(result) ? result : thisBinding;
>, <Line: -        }
>, <Line: -        return func.apply(thisBinding, args);
>, <Line: -      }
>, <Line: -      setBindData(bound, bindData);
>, <Line: -      return bound;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.difference` that accepts a single array
>, <Line: -     * of values to exclude.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Array} array The array to process.
>, <Line: -     * @param {Array} [values] The array of values to exclude.
>, <Line: -     * @returns {Array} Returns a new array of filtered values.
>, <Line: -     */
>, <Line: -    function baseDifference(array, values) {
>, <Line: -      var index = -1,
>, <Line: -          indexOf = getIndexOf(),
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
>, <Line: -          result = [];
>, <Line: -      if (isLarge) {
>, <Line: -        var cache = createCache(values);
>, <Line: -        if (cache) {
>, <Line: -          indexOf = cacheIndexOf;
>, <Line: -          values = cache;
>, <Line: -        } else {
>, <Line: -          isLarge = false;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      while (++index < length) {
>, <Line: -        var value = array[index];
>, <Line: -        if (indexOf(values, value) < 0) {
>, <Line: -          result.push(value);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (isLarge) {
>, <Line: -        releaseObject(values);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.flatten` without support for callback
>, <Line: -     * shorthands or `thisArg` binding.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Array} array The array to flatten.
>, <Line: -     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
>, <Line: -     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
>, <Line: -     * @param {number} [fromIndex=0] The index to start from.
>, <Line: -     * @returns {Array} Returns a new flattened array.
>, <Line: -     */
>, <Line: -    function baseFlatten(array, isShallow, isStrict, fromIndex) {
>, <Line: -      var index = (fromIndex || 0) - 1,
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          result = [];
>, <Line: -      while (++index < length) {
>, <Line: -        var value = array[index];
>, <Line: -        if (value && typeof value == 'object' && typeof value.length == 'number'
>, <Line: -            && (isArray(value) || isArguments(value))) {
>, <Line: -          // recursively flatten arrays (susceptible to call stack limits)
>, <Line: -          if (!isShallow) {
>, <Line: -            value = baseFlatten(value, isShallow, isStrict);
>, <Line: -          }
>, <Line: -          var valIndex = -1,
>, <Line: -              valLength = value.length,
>, <Line: -              resIndex = result.length;
>, <Line: -          result.length += valLength;
>, <Line: -          while (++valIndex < valLength) {
>, <Line: -            result[resIndex++] = value[valIndex];
>, <Line: -          }
>, <Line: -        } else if (!isStrict) {
>, <Line: -          result.push(value);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
>, <Line: -     * that allows partial "_.where" style comparisons.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} a The value to compare.
>, <Line: -     * @param {*} b The other value to compare.
>, <Line: -     * @param {Function} [callback] The function to customize comparing values.
>, <Line: -     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
>, <Line: -     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
>, <Line: -     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
>, <Line: -     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
>, <Line: -     */
>, <Line: -    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
>, <Line: -      // used to indicate that when comparing objects, `a` has at least the properties of `b`
>, <Line: -      if (callback) {
>, <Line: -        var result = callback(a, b);
>, <Line: -        if (typeof result != 'undefined') {
>, <Line: -          return !!result;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // exit early for identical values
>, <Line: -      if (a === b) {
>, <Line: -        // treat `+0` vs. `-0` as not equal
>, <Line: -        return a !== 0 || (1 / a == 1 / b);
>, <Line: -      }
>, <Line: -      var type = typeof a,
>, <Line: -          otherType = typeof b;
>, <Line: -      // exit early for unlike primitive values
>, <Line: -      if (a === a &&
>, <Line: -          !(a && objectTypes[type]) &&
>, <Line: -          !(b && objectTypes[otherType])) {
>, <Line: -        return false;
>, <Line: -      }
>, <Line: -      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
>, <Line: -      // http://es5.github.io/#x15.3.4.4
>, <Line: -      if (a == null || b == null) {
>, <Line: -        return a === b;
>, <Line: -      }
>, <Line: -      // compare [[Class]] names
>, <Line: -      var className = toString.call(a),
>, <Line: -          otherClass = toString.call(b);
>, <Line: -      if (className == argsClass) {
>, <Line: -        className = objectClass;
>, <Line: -      }
>, <Line: -      if (otherClass == argsClass) {
>, <Line: -        otherClass = objectClass;
>, <Line: -      }
>, <Line: -      if (className != otherClass) {
>, <Line: -        return false;
>, <Line: -      }
>, <Line: -      switch (className) {
>, <Line: -        case boolClass:
>, <Line: -        case dateClass:
>, <Line: -          // coerce dates and booleans to numbers, dates to milliseconds and booleans
>, <Line: -          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
>, <Line: -          return +a == +b;
>, <Line: -        case numberClass:
>, <Line: -          // treat `NaN` vs. `NaN` as equal
>, <Line: -          return (a != +a)
>, <Line: -            ? b != +b
>, <Line: -            // but treat `+0` vs. `-0` as not equal
>, <Line: -            : (a == 0 ? (1 / a == 1 / b) : a == +b);
>, <Line: -        case regexpClass:
>, <Line: -        case stringClass:
>, <Line: -          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
>, <Line: -          // treat string primitives and their corresponding object instances as equal
>, <Line: -          return a == String(b);
>, <Line: -      }
>, <Line: -      var isArr = className == arrayClass;
>, <Line: -      if (!isArr) {
>, <Line: -        // unwrap any `lodash` wrapped values
>, <Line: -        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
>, <Line: -            bWrapped = hasOwnProperty.call(b, '__wrapped__');
>, <Line: -        if (aWrapped || bWrapped) {
>, <Line: -          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
>, <Line: -        }
>, <Line: -        // exit for functions and DOM nodes
>, <Line: -        if (className != objectClass) {
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -        // in older versions of Opera, `arguments` objects have `Array` constructors
>, <Line: -        var ctorA = a.constructor,
>, <Line: -            ctorB = b.constructor;
>, <Line: -        // non `Object` object instances with different constructors are not equal
>, <Line: -        if (ctorA != ctorB &&
>, <Line: -              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
>, <Line: -              ('constructor' in a && 'constructor' in b)
>, <Line: -            ) {
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // assume cyclic structures are equal
>, <Line: -      // the algorithm for detecting cyclic structures is adapted from ES 5.1
>, <Line: -      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
>, <Line: -      var initedStack = !stackA;
>, <Line: -      stackA || (stackA = getArray());
>, <Line: -      stackB || (stackB = getArray());
>, <Line: -      var length = stackA.length;
>, <Line: -      while (length--) {
>, <Line: -        if (stackA[length] == a) {
>, <Line: -          return stackB[length] == b;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      var size = 0;
>, <Line: -      result = true;
>, <Line: -      // add `a` and `b` to the stack of traversed objects
>, <Line: -      stackA.push(a);
>, <Line: -      stackB.push(b);
>, <Line: -      // recursively compare objects and arrays (susceptible to call stack limits)
>, <Line: -      if (isArr) {
>, <Line: -        // compare lengths to determine if a deep comparison is necessary
>, <Line: -        length = a.length;
>, <Line: -        size = b.length;
>, <Line: -        result = size == length;
>, <Line: -        if (result || isWhere) {
>, <Line: -          // deep compare the contents, ignoring non-numeric properties
>, <Line: -          while (size--) {
>, <Line: -            var index = length,
>, <Line: -                value = b[size];
>, <Line: -            if (isWhere) {
>, <Line: -              while (index--) {
>, <Line: -                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
>, <Line: -                  break;
>, <Line: -                }
>, <Line: -              }
>, <Line: -            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
>, <Line: -              break;
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      else {
>, <Line: -        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
>, <Line: -        // which, in this case, is more costly
>, <Line: -        forIn(b, function(value, key, b) {
>, <Line: -          if (hasOwnProperty.call(b, key)) {
>, <Line: -            // count the number of properties.
>, <Line: -            size++;
>, <Line: -            // deep compare each property value.
>, <Line: -            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
>, <Line: -          }
>, <Line: -        });
>, <Line: -        if (result && !isWhere) {
>, <Line: -          // ensure both objects have the same number of properties
>, <Line: -          forIn(a, function(value, key, a) {
>, <Line: -            if (hasOwnProperty.call(a, key)) {
>, <Line: -              // `size` will be `-1` if `a` has more properties than `b`
>, <Line: -              return (result = --size > -1);
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -      }
>, <Line: -      stackA.pop();
>, <Line: -      stackB.pop();
>, <Line: -      if (initedStack) {
>, <Line: -        releaseArray(stackA);
>, <Line: -        releaseArray(stackB);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.merge` without argument juggling or support
>, <Line: -     * for `thisArg` binding.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Object} object The destination object.
>, <Line: -     * @param {Object} source The source object.
>, <Line: -     * @param {Function} [callback] The function to customize merging properties.
>, <Line: -     * @param {Array} [stackA=[]] Tracks traversed source objects.
>, <Line: -     * @param {Array} [stackB=[]] Associates values with source counterparts.
>, <Line: -     */
>, <Line: -    function baseMerge(object, source, callback, stackA, stackB) {
>, <Line: -      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
>, <Line: -        var found,
>, <Line: -            isArr,
>, <Line: -            result = source,
>, <Line: -            value = object[key];
>, <Line: -        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
>, <Line: -          // avoid merging previously merged cyclic sources
>, <Line: -          var stackLength = stackA.length;
>, <Line: -          while (stackLength--) {
>, <Line: -            if ((found = stackA[stackLength] == source)) {
>, <Line: -              value = stackB[stackLength];
>, <Line: -              break;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          if (!found) {
>, <Line: -            var isShallow;
>, <Line: -            if (callback) {
>, <Line: -              result = callback(value, source);
>, <Line: -              if ((isShallow = typeof result != 'undefined')) {
>, <Line: -                value = result;
>, <Line: -              }
>, <Line: -            }
>, <Line: -            if (!isShallow) {
>, <Line: -              value = isArr
>, <Line: -                ? (isArray(value) ? value : [])
>, <Line: -                : (isPlainObject(value) ? value : {});
>, <Line: -            }
>, <Line: -            // add `source` and associated `value` to the stack of traversed objects
>, <Line: -            stackA.push(source);
>, <Line: -            stackB.push(value);
>, <Line: -            // recursively merge objects and arrays (susceptible to call stack limits)
>, <Line: -            if (!isShallow) {
>, <Line: -              baseMerge(value, source, callback, stackA, stackB);
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        else {
>, <Line: -          if (callback) {
>, <Line: -            result = callback(value, source);
>, <Line: -            if (typeof result == 'undefined') {
>, <Line: -              result = source;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          if (typeof result != 'undefined') {
>, <Line: -            value = result;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        object[key] = value;
>, <Line: -      });
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.random` without argument juggling or support
>, <Line: -     * for returning floating-point numbers.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {number} min The minimum possible value.
>, <Line: -     * @param {number} max The maximum possible value.
>, <Line: -     * @returns {number} Returns a random number.
>, <Line: -     */
>, <Line: -    function baseRandom(min, max) {
>, <Line: -      return min + floor(nativeRandom() * (max - min + 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The base implementation of `_.uniq` without support for callback shorthands
>, <Line: -     * or `thisArg` binding.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Array} array The array to process.
>, <Line: -     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
>, <Line: -     * @param {Function} [callback] The function called per iteration.
>, <Line: -     * @returns {Array} Returns a duplicate-value-free array.
>, <Line: -     */
>, <Line: -    function baseUniq(array, isSorted, callback) {
>, <Line: -      var index = -1,
>, <Line: -          indexOf = getIndexOf(),
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          result = [];
>, <Line: -      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
>, <Line: -          seen = (callback || isLarge) ? getArray() : result;
>, <Line: -      if (isLarge) {
>, <Line: -        var cache = createCache(seen);
>, <Line: -        indexOf = cacheIndexOf;
>, <Line: -        seen = cache;
>, <Line: -      }
>, <Line: -      while (++index < length) {
>, <Line: -        var value = array[index],
>, <Line: -            computed = callback ? callback(value, index, array) : value;
>, <Line: -        if (isSorted
>, <Line: -              ? !index || seen[seen.length - 1] !== computed
>, <Line: -              : indexOf(seen, computed) < 0
>, <Line: -            ) {
>, <Line: -          if (callback || isLarge) {
>, <Line: -            seen.push(computed);
>, <Line: -          }
>, <Line: -          result.push(value);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (isLarge) {
>, <Line: -        releaseArray(seen.array);
>, <Line: -        releaseObject(seen);
>, <Line: -      } else if (callback) {
>, <Line: -        releaseArray(seen);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that aggregates a collection, creating an object composed
>, <Line: -     * of keys generated from the results of running each element of the collection
>, <Line: -     * through a callback. The given `setter` function sets the keys and values
>, <Line: -     * of the composed object.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Function} setter The setter function.
>, <Line: -     * @returns {Function} Returns the new aggregator function.
>, <Line: -     */
>, <Line: -    function createAggregator(setter) {
>, <Line: -      return function(collection, callback, thisArg) {
>, <Line: -        var result = {};
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        var index = -1,
>, <Line: -            length = collection ? collection.length : 0;
>, <Line: -        if (typeof length == 'number') {
>, <Line: -          while (++index < length) {
>, <Line: -            var value = collection[index];
>, <Line: -            setter(result, value, callback(value, index, collection), collection);
>, <Line: -          }
>, <Line: -        } else {
>, <Line: -          forOwn(collection, function(value, key, collection) {
>, <Line: -            setter(result, value, callback(value, key, collection), collection);
>, <Line: -          });
>, <Line: -        }
>, <Line: -        return result;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that, when called, either curries or invokes `func`
>, <Line: -     * with an optional `this` binding and partially applied arguments.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Function|string} func The function or method name to reference.
>, <Line: -     * @param {number} bitmask The bitmask of method flags to compose.
>, <Line: -     *  The bitmask may be composed of the following flags:
>, <Line: -     *  1 - `_.bind`
>, <Line: -     *  2 - `_.bindKey`
>, <Line: -     *  4 - `_.curry`
>, <Line: -     *  8 - `_.curry` (bound)
>, <Line: -     *  16 - `_.partial`
>, <Line: -     *  32 - `_.partialRight`
>, <Line: -     * @param {Array} [partialArgs] An array of arguments to prepend to those
>, <Line: -     *  provided to the new function.
>, <Line: -     * @param {Array} [partialRightArgs] An array of arguments to append to those
>, <Line: -     *  provided to the new function.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `func`.
>, <Line: -     * @param {number} [arity] The arity of `func`.
>, <Line: -     * @returns {Function} Returns the new function.
>, <Line: -     */
>, <Line: -    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
>, <Line: -      var isBind = bitmask & 1,
>, <Line: -          isBindKey = bitmask & 2,
>, <Line: -          isCurry = bitmask & 4,
>, <Line: -          isCurryBound = bitmask & 8,
>, <Line: -          isPartial = bitmask & 16,
>, <Line: -          isPartialRight = bitmask & 32;
>, <Line: -      if (!isBindKey && !isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      if (isPartial && !partialArgs.length) {
>, <Line: -        bitmask &= ~16;
>, <Line: -        isPartial = partialArgs = false;
>, <Line: -      }
>, <Line: -      if (isPartialRight && !partialRightArgs.length) {
>, <Line: -        bitmask &= ~32;
>, <Line: -        isPartialRight = partialRightArgs = false;
>, <Line: -      }
>, <Line: -      var bindData = func && func.__bindData__;
>, <Line: -      if (bindData && bindData !== true) {
>, <Line: -        // clone `bindData`
>, <Line: -        bindData = slice(bindData);
>, <Line: -        if (bindData[2]) {
>, <Line: -          bindData[2] = slice(bindData[2]);
>, <Line: -        }
>, <Line: -        if (bindData[3]) {
>, <Line: -          bindData[3] = slice(bindData[3]);
>, <Line: -        }
>, <Line: -        // set `thisBinding` is not previously bound
>, <Line: -        if (isBind && !(bindData[1] & 1)) {
>, <Line: -          bindData[4] = thisArg;
>, <Line: -        }
>, <Line: -        // set if previously bound but not currently (subsequent curried functions)
>, <Line: -        if (!isBind && bindData[1] & 1) {
>, <Line: -          bitmask |= 8;
>, <Line: -        }
>, <Line: -        // set curried arity if not yet set
>, <Line: -        if (isCurry && !(bindData[1] & 4)) {
>, <Line: -          bindData[5] = arity;
>, <Line: -        }
>, <Line: -        // append partial left arguments
>, <Line: -        if (isPartial) {
>, <Line: -          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
>, <Line: -        }
>, <Line: -        // append partial right arguments
>, <Line: -        if (isPartialRight) {
>, <Line: -          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
>, <Line: -        }
>, <Line: -        // merge flags
>, <Line: -        bindData[1] |= bitmask;
>, <Line: -        return createWrapper.apply(null, bindData);
>, <Line: -      }
>, <Line: -      // fast path for `_.bind`
>, <Line: -      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
>, <Line: -      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Used by `escape` to convert characters to HTML entities.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {string} match The matched character to escape.
>, <Line: -     * @returns {string} Returns the escaped character.
>, <Line: -     */
>, <Line: -    function escapeHtmlChar(match) {
>, <Line: -      return htmlEscapes[match];
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
>, <Line: -     * customized, this method returns the custom method, otherwise it returns
>, <Line: -     * the `baseIndexOf` function.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @returns {Function} Returns the "indexOf" function.
>, <Line: -     */
>, <Line: -    function getIndexOf() {
>, <Line: -      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a native function.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
>, <Line: -     */
>, <Line: -    function isNative(value) {
>, <Line: -      return typeof value == 'function' && reNative.test(value);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Sets `this` binding data on a given function.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {Function} func The function to set data on.
>, <Line: -     * @param {Array} value The data array to set.
>, <Line: -     */
>, <Line: -    var setBindData = !defineProperty ? noop : function(func, value) {
>, <Line: -      descriptor.value = value;
>, <Line: -      defineProperty(func, '__bindData__', descriptor);
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * A fallback implementation of `isPlainObject` which checks if a given value
>, <Line: -     * is an object created by the `Object` constructor, assuming objects created
>, <Line: -     * by the `Object` constructor have no inherited enumerable properties and that
>, <Line: -     * there are no `Object.prototype` extensions.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
>, <Line: -     */
>, <Line: -    function shimIsPlainObject(value) {
>, <Line: -      var ctor,
>, <Line: -          result;
>, <Line: -      // avoid non Object objects, `arguments` objects, and DOM elements
>, <Line: -      if (!(value && toString.call(value) == objectClass) ||
>, <Line: -          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
>, <Line: -        return false;
>, <Line: -      }
>, <Line: -      // In most environments an object's own properties are iterated before
>, <Line: -      // its inherited properties. If the last iterated property is an object's
>, <Line: -      // own property then there are no inherited enumerable properties.
>, <Line: -      forIn(value, function(value, key) {
>, <Line: -        result = key;
>, <Line: -      });
>, <Line: -      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Used by `unescape` to convert HTML entities to characters.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @param {string} match The matched character to unescape.
>, <Line: -     * @returns {string} Returns the unescaped character.
>, <Line: -     */
>, <Line: -    function unescapeHtmlChar(match) {
>, <Line: -      return htmlUnescapes[match];
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Checks if `value` is an `arguments` object.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * (function() { return _.isArguments(arguments); })(1, 2, 3);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isArguments([1, 2, 3]);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isArguments(value) {
>, <Line: -      return value && typeof value == 'object' && typeof value.length == 'number' &&
>, <Line: -        toString.call(value) == argsClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is an array.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * (function() { return _.isArray(arguments); })();
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isArray([1, 2, 3]);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    var isArray = nativeIsArray || function(value) {
>, <Line: -      return value && typeof value == 'object' && typeof value.length == 'number' &&
>, <Line: -        toString.call(value) == arrayClass || false;
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * A fallback implementation of `Object.keys` which produces an array of the
>, <Line: -     * given object's own enumerable property names.
>, <Line: -     *
>, <Line: -     * @private
>, <Line: -     * @type Function
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @returns {Array} Returns an array of property names.
>, <Line: -     */
>, <Line: -    var shimKeys = function(object) {
>, <Line: -      var index, iterable = object, result = [];
>, <Line: -      if (!iterable) return result;
>, <Line: -      if (!(objectTypes[typeof object])) return result;
>, <Line: -        for (index in iterable) {
>, <Line: -          if (hasOwnProperty.call(iterable, index)) {
>, <Line: -            result.push(index);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      return result
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Creates an array composed of the own enumerable property names of an object.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @returns {Array} Returns an array of property names.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: -     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    var keys = !nativeKeys ? shimKeys : function(object) {
>, <Line: -      if (!isObject(object)) {
>, <Line: -        return [];
>, <Line: -      }
>, <Line: -      return nativeKeys(object);
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Used to convert characters to HTML entities:
>, <Line: -     *
>, <Line: -     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
>, <Line: -     * don't require escaping in HTML and have no special meaning unless they're part
>, <Line: -     * of a tag or an unquoted attribute value.
>, <Line: -     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
>, <Line: -     */
>, <Line: -    var htmlEscapes = {
>, <Line: -      '&': '&amp;',
>, <Line: -      '<': '&lt;',
>, <Line: -      '>': '&gt;',
>, <Line: -      '"': '&quot;',
>, <Line: -      "'": '&#39;'
>, <Line: -    };
>, <Line: -    /** Used to convert HTML entities to characters */
>, <Line: -    var htmlUnescapes = invert(htmlEscapes);
>, <Line: -    /** Used to match HTML entities and HTML characters */
>, <Line: -    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
>, <Line: -        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Assigns own enumerable properties of source object(s) to the destination
>, <Line: -     * object. Subsequent sources will overwrite property assignments of previous
>, <Line: -     * sources. If a callback is provided it will be executed to produce the
>, <Line: -     * assigned values. The callback is bound to `thisArg` and invoked with two
>, <Line: -     * arguments; (objectValue, sourceValue).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @alias extend
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The destination object.
>, <Line: -     * @param {...Object} [source] The source objects.
>, <Line: -     * @param {Function} [callback] The function to customize assigning values.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns the destination object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
>, <Line: -     * // => { 'name': 'fred', 'employer': 'slate' }
>, <Line: -     *
>, <Line: -     * var defaults = _.partialRight(_.assign, function(a, b) {
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'barney' };
>, <Line: -     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
>, <Line: -     * // => { 'name': 'barney', 'employer': 'slate' }
>, <Line: -     */
>, <Line: -    var assign = function(object, source, guard) {
>, <Line: -      var index, iterable = object, result = iterable;
>, <Line: -      if (!iterable) return result;
>, <Line: -      var args = arguments,
>, <Line: -          argsIndex = 0,
>, <Line: -          argsLength = typeof guard == 'number' ? 2 : args.length;
>, <Line: -      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
>, <Line: -        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
>, <Line: -      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
>, <Line: -        callback = args[--argsLength];
>, <Line: -      }
>, <Line: -      while (++argsIndex < argsLength) {
>, <Line: -        iterable = args[argsIndex];
>, <Line: -        if (iterable && objectTypes[typeof iterable]) {
>, <Line: -        var ownIndex = -1,
>, <Line: -            ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: -            length = ownProps ? ownProps.length : 0;
>, <Line: -        while (++ownIndex < length) {
>, <Line: -          index = ownProps[ownIndex];
>, <Line: -          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
>, <Line: -        }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
>, <Line: -     * be cloned, otherwise they will be assigned by reference. If a callback
>, <Line: -     * is provided it will be executed to produce the cloned values. If the
>, <Line: -     * callback returns `undefined` cloning will be handled by the method instead.
>, <Line: -     * The callback is bound to `thisArg` and invoked with one argument; (value).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to clone.
>, <Line: -     * @param {boolean} [isDeep=false] Specify a deep clone.
>, <Line: -     * @param {Function} [callback] The function to customize cloning values.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the cloned value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * var shallow = _.clone(characters);
>, <Line: -     * shallow[0] === characters[0];
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * var deep = _.clone(characters, true);
>, <Line: -     * deep[0] === characters[0];
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.mixin({
>, <Line: -     *
>, <Line: -     * var clone = _.clone(document.body);
>, <Line: -     * clone.childNodes.length;
>, <Line: -     * // => 0
>, <Line: -     */
>, <Line: -    function clone(value, isDeep, callback, thisArg) {
>, <Line: -      // allows working with "Collections" methods without using their `index`
>, <Line: -      // and `collection` arguments for `isDeep` and `callback`
>, <Line: -      if (typeof isDeep != 'boolean' && isDeep != null) {
>, <Line: -        thisArg = callback;
>, <Line: -        callback = isDeep;
>, <Line: -        isDeep = false;
>, <Line: -      }
>, <Line: -      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a deep clone of `value`. If a callback is provided it will be
>, <Line: -     * executed to produce the cloned values. If the callback returns `undefined`
>, <Line: -     * cloning will be handled by the method instead. The callback is bound to
>, <Line: -     * `thisArg` and invoked with one argument; (value).
>, <Line: -     *
>, <Line: -     * Note: This method is loosely based on the structured clone algorithm. Functions
>, <Line: -     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
>, <Line: -     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
>, <Line: -     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to deep clone.
>, <Line: -     * @param {Function} [callback] The function to customize cloning values.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the deep cloned value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * var deep = _.cloneDeep(characters);
>, <Line: -     * deep[0] === characters[0];
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * var view = {
>, <Line: -     *
>, <Line: -     * var clone = _.cloneDeep(view, function(value) {
>, <Line: -     *
>, <Line: -     * clone.node == view.node;
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function cloneDeep(value, callback, thisArg) {
>, <Line: -      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object that inherits from the given `prototype` object. If a
>, <Line: -     * `properties` object is provided its own enumerable properties are assigned
>, <Line: -     * to the created object.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} prototype The object to inherit from.
>, <Line: -     * @param {Object} [properties] The properties to assign to the object.
>, <Line: -     * @returns {Object} Returns the new object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * function Shape() {
>, <Line: -     *
>, <Line: -     * function Circle() {
>, <Line: -     *
>, <Line: -     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
>, <Line: -     *
>, <Line: -     * var circle = new Circle;
>, <Line: -     * circle instanceof Circle;
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * circle instanceof Shape;
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function create(prototype, properties) {
>, <Line: -      var result = baseCreate(prototype);
>, <Line: -      return properties ? assign(result, properties) : result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Assigns own enumerable properties of source object(s) to the destination
>, <Line: -     * object for all destination properties that resolve to `undefined`. Once a
>, <Line: -     * property is set, additional defaults of the same property will be ignored.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The destination object.
>, <Line: -     * @param {...Object} [source] The source objects.
>, <Line: -     * @param- {Object} [guard] Allows working with `_.reduce` without using its
>, <Line: -     *  `key` and `object` arguments as sources.
>, <Line: -     * @returns {Object} Returns the destination object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'barney' };
>, <Line: -     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
>, <Line: -     * // => { 'name': 'barney', 'employer': 'slate' }
>, <Line: -     */
>, <Line: -    var defaults = function(object, source, guard) {
>, <Line: -      var index, iterable = object, result = iterable;
>, <Line: -      if (!iterable) return result;
>, <Line: -      var args = arguments,
>, <Line: -          argsIndex = 0,
>, <Line: -          argsLength = typeof guard == 'number' ? 2 : args.length;
>, <Line: -      while (++argsIndex < argsLength) {
>, <Line: -        iterable = args[argsIndex];
>, <Line: -        if (iterable && objectTypes[typeof iterable]) {
>, <Line: -        var ownIndex = -1,
>, <Line: -            ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: -            length = ownProps ? ownProps.length : 0;
>, <Line: -        while (++ownIndex < length) {
>, <Line: -          index = ownProps[ownIndex];
>, <Line: -          if (typeof result[index] == 'undefined') result[index] = iterable[index];
>, <Line: -        }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * This method is like `_.findIndex` except that it returns the key of the
>, <Line: -     * first element that passes the callback check, instead of the element itself.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to search.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called per
>, <Line: -     *  iteration. If a property name or object is provided it will be used to
>, <Line: -     *  create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = {
>, <Line: -     *
>, <Line: -     * _.findKey(characters, function(chr) {
>, <Line: -     * // => 'barney' (property order is not guaranteed across environments)
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.findKey(characters, { 'age': 1 });
>, <Line: -     * // => 'pebbles'
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.findKey(characters, 'blocked');
>, <Line: -     * // => 'fred'
>, <Line: -     */
>, <Line: -    function findKey(object, callback, thisArg) {
>, <Line: -      var result;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      forOwn(object, function(value, key, object) {
>, <Line: -        if (callback(value, key, object)) {
>, <Line: -          result = key;
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.findKey` except that it iterates over elements
>, <Line: -     * of a `collection` in the opposite order.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to search.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called per
>, <Line: -     *  iteration. If a property name or object is provided it will be used to
>, <Line: -     *  create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = {
>, <Line: -     *
>, <Line: -     * _.findLastKey(characters, function(chr) {
>, <Line: -     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.findLastKey(characters, { 'age': 40 });
>, <Line: -     * // => 'fred'
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.findLastKey(characters, 'blocked');
>, <Line: -     * // => 'pebbles'
>, <Line: -     */
>, <Line: -    function findLastKey(object, callback, thisArg) {
>, <Line: -      var result;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      forOwnRight(object, function(value, key, object) {
>, <Line: -        if (callback(value, key, object)) {
>, <Line: -          result = key;
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Iterates over own and inherited enumerable properties of an object,
>, <Line: -     * executing the callback for each property. The callback is bound to `thisArg`
>, <Line: -     * and invoked with three arguments; (value, key, object). Callbacks may exit
>, <Line: -     * iteration early by explicitly returning `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns `object`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * function Shape() {
>, <Line: -     *
>, <Line: -     * Shape.prototype.move = function(x, y) {
>, <Line: -     *
>, <Line: -     * _.forIn(new Shape, function(value, key) {
>, <Line: -     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    var forIn = function(collection, callback, thisArg) {
>, <Line: -      var index, iterable = collection, result = iterable;
>, <Line: -      if (!iterable) return result;
>, <Line: -      if (!objectTypes[typeof iterable]) return result;
>, <Line: -      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: -        for (index in iterable) {
>, <Line: -          if (callback(iterable[index], index, collection) === false) return result;
>, <Line: -        }
>, <Line: -      return result
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * This method is like `_.forIn` except that it iterates over elements
>, <Line: -     * of a `collection` in the opposite order.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns `object`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * function Shape() {
>, <Line: -     *
>, <Line: -     * Shape.prototype.move = function(x, y) {
>, <Line: -     *
>, <Line: -     * _.forInRight(new Shape, function(value, key) {
>, <Line: -     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
>, <Line: -     */
>, <Line: -    function forInRight(object, callback, thisArg) {
>, <Line: -      var pairs = [];
>, <Line: -      forIn(object, function(value, key) {
>, <Line: -        pairs.push(key, value);
>, <Line: -      });
>, <Line: -      var length = pairs.length;
>, <Line: -      callback = baseCreateCallback(callback, thisArg, 3);
>, <Line: -      while (length--) {
>, <Line: -        if (callback(pairs[length--], pairs[length], object) === false) {
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return object;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Iterates over own enumerable properties of an object, executing the callback
>, <Line: -     * for each property. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, key, object). Callbacks may exit iteration early by
>, <Line: -     * explicitly returning `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns `object`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
>, <Line: -     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    var forOwn = function(collection, callback, thisArg) {
>, <Line: -      var index, iterable = collection, result = iterable;
>, <Line: -      if (!iterable) return result;
>, <Line: -      if (!objectTypes[typeof iterable]) return result;
>, <Line: -      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: -        var ownIndex = -1,
>, <Line: -            ownProps = objectTypes[typeof iterable] && keys(iterable),
>, <Line: -            length = ownProps ? ownProps.length : 0;
>, <Line: -        while (++ownIndex < length) {
>, <Line: -          index = ownProps[ownIndex];
>, <Line: -          if (callback(iterable[index], index, collection) === false) return result;
>, <Line: -        }
>, <Line: -      return result
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * This method is like `_.forOwn` except that it iterates over elements
>, <Line: -     * of a `collection` in the opposite order.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns `object`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
>, <Line: -     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
>, <Line: -     */
>, <Line: -    function forOwnRight(object, callback, thisArg) {
>, <Line: -      var props = keys(object),
>, <Line: -          length = props.length;
>, <Line: -      callback = baseCreateCallback(callback, thisArg, 3);
>, <Line: -      while (length--) {
>, <Line: -        var key = props[length];
>, <Line: -        if (callback(object[key], key, object) === false) {
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return object;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a sorted array of property names of all enumerable properties,
>, <Line: -     * own and inherited, of `object` that have function values.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias methods
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @returns {Array} Returns an array of property names that have function values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.functions(_);
>, <Line: -     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
>, <Line: -     */
>, <Line: -    function functions(object) {
>, <Line: -      var result = [];
>, <Line: -      forIn(object, function(value, key) {
>, <Line: -        if (isFunction(value)) {
>, <Line: -          result.push(key);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return result.sort();
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if the specified property name exists as a direct property of `object`,
>, <Line: -     * instead of an inherited property.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @param {string} key The name of the property to check.
>, <Line: -     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function has(object, key) {
>, <Line: -      return object ? hasOwnProperty.call(object, key) : false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object composed of the inverted keys and values of the given object.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to invert.
>, <Line: -     * @returns {Object} Returns the created inverted object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.invert({ 'first': 'fred', 'second': 'barney' });
>, <Line: -     * // => { 'fred': 'first', 'barney': 'second' }
>, <Line: -     */
>, <Line: -    function invert(object) {
>, <Line: -      var index = -1,
>, <Line: -          props = keys(object),
>, <Line: -          length = props.length,
>, <Line: -          result = {};
>, <Line: -      while (++index < length) {
>, <Line: -        var key = props[index];
>, <Line: -        result[object[key]] = key;
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a boolean value.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isBoolean(null);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isBoolean(value) {
>, <Line: -      return value === true || value === false ||
>, <Line: -        value && typeof value == 'object' && toString.call(value) == boolClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a date.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isDate(new Date);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isDate(value) {
>, <Line: -      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a DOM element.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isElement(document.body);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isElement(value) {
>, <Line: -      return value && value.nodeType === 1 || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
>, <Line: -     * length of `0` and objects with no own enumerable properties are considered
>, <Line: -     * "empty".
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Array|Object|string} value The value to inspect.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isEmpty([1, 2, 3]);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isEmpty({});
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isEmpty('');
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isEmpty(value) {
>, <Line: -      var result = true;
>, <Line: -      if (!value) {
>, <Line: -        return result;
>, <Line: -      }
>, <Line: -      var className = toString.call(value),
>, <Line: -          length = value.length;
>, <Line: -      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
>, <Line: -          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
>, <Line: -        return !length;
>, <Line: -      }
>, <Line: -      forOwn(value, function() {
>, <Line: -        return (result = false);
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Performs a deep comparison between two values to determine if they are
>, <Line: -     * equivalent to each other. If a callback is provided it will be executed
>, <Line: -     * to compare values. If the callback returns `undefined` comparisons will
>, <Line: -     * be handled by the method instead. The callback is bound to `thisArg` and
>, <Line: -     * invoked with two arguments; (a, b).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} a The value to compare.
>, <Line: -     * @param {*} b The other value to compare.
>, <Line: -     * @param {Function} [callback] The function to customize comparing values.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'fred' };
>, <Line: -     * var copy = { 'name': 'fred' };
>, <Line: -     *
>, <Line: -     * object == copy;
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isEqual(object, copy);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * var words = ['hello', 'goodbye'];
>, <Line: -     * var otherWords = ['hi', 'goodbye'];
>, <Line: -     *
>, <Line: -     * _.isEqual(words, otherWords, function(a, b) {
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isEqual(a, b, callback, thisArg) {
>, <Line: -      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is, or can be coerced to, a finite number.
>, <Line: -     *
>, <Line: -     * Note: This is not the same as native `isFinite` which will return true for
>, <Line: -     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isFinite(-101);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isFinite('10');
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isFinite(true);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isFinite('');
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isFinite(Infinity);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isFinite(value) {
>, <Line: -      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isFunction(_);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isFunction(value) {
>, <Line: -      return typeof value == 'function';
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is the language type of Object.
>, <Line: -     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isObject({});
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isObject([1, 2, 3]);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isObject(1);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isObject(value) {
>, <Line: -      // check if the value is the ECMAScript language type of Object
>, <Line: -      // http://es5.github.io/#x8
>, <Line: -      // and avoid a V8 bug
>, <Line: -      // http://code.google.com/p/v8/issues/detail?id=2291
>, <Line: -      return !!(value && objectTypes[typeof value]);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is `NaN`.
>, <Line: -     *
>, <Line: -     * Note: This is not the same as native `isNaN` which will return `true` for
>, <Line: -     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isNaN(NaN);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isNaN(new Number(NaN));
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * isNaN(undefined);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isNaN(undefined);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isNaN(value) {
>, <Line: -      // `NaN` as a primitive is the only value that is not equal to itself
>, <Line: -      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
>, <Line: -      return isNumber(value) && value != +value;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is `null`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isNull(null);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.isNull(undefined);
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function isNull(value) {
>, <Line: -      return value === null;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a number.
>, <Line: -     *
>, <Line: -     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isNumber(8.4 * 5);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isNumber(value) {
>, <Line: -      return typeof value == 'number' ||
>, <Line: -        value && typeof value == 'object' && toString.call(value) == numberClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is an object created by the `Object` constructor.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * function Shape() {
>, <Line: -     *
>, <Line: -     * _.isPlainObject(new Shape);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isPlainObject([1, 2, 3]);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.isPlainObject({ 'x': 0, 'y': 0 });
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
>, <Line: -      if (!(value && toString.call(value) == objectClass)) {
>, <Line: -        return false;
>, <Line: -      }
>, <Line: -      var valueOf = value.valueOf,
>, <Line: -          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
>, <Line: -      return objProto
>, <Line: -        ? (value == objProto || getPrototypeOf(value) == objProto)
>, <Line: -        : shimIsPlainObject(value);
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a regular expression.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isRegExp(/fred/);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isRegExp(value) {
>, <Line: -      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is a string.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isString('fred');
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isString(value) {
>, <Line: -      return typeof value == 'string' ||
>, <Line: -        value && typeof value == 'object' && toString.call(value) == stringClass || false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if `value` is `undefined`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {*} value The value to check.
>, <Line: -     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.isUndefined(void 0);
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function isUndefined(value) {
>, <Line: -      return typeof value == 'undefined';
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object with the same keys as `object` and values generated by
>, <Line: -     * running each own enumerable property of `object` through the callback.
>, <Line: -     * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, key, object).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
>, <Line: -     * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: -     *
>, <Line: -     * var characters = {
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.mapValues(characters, 'age');
>, <Line: -     * // => { 'fred': 40, 'pebbles': 1 }
>, <Line: -     */
>, <Line: -    function mapValues(object, callback, thisArg) {
>, <Line: -      var result = {};
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      forOwn(object, function(value, key, object) {
>, <Line: -        result[key] = callback(value, key, object);
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Recursively merges own enumerable properties of the source object(s), that
>, <Line: -     * don't resolve to `undefined` into the destination object. Subsequent sources
>, <Line: -     * will overwrite property assignments of previous sources. If a callback is
>, <Line: -     * provided it will be executed to produce the merged values of the destination
>, <Line: -     * and source properties. If the callback returns `undefined` merging will
>, <Line: -     * be handled by the method instead. The callback is bound to `thisArg` and
>, <Line: -     * invoked with two arguments; (objectValue, sourceValue).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The destination object.
>, <Line: -     * @param {...Object} [source] The source objects.
>, <Line: -     * @param {Function} [callback] The function to customize merging properties.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns the destination object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var names = {
>, <Line: -     *
>, <Line: -     * var ages = {
>, <Line: -     *
>, <Line: -     * _.merge(names, ages);
>, <Line: -     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
>, <Line: -     *
>, <Line: -     * var food = {
>, <Line: -     *
>, <Line: -     * var otherFood = {
>, <Line: -     *
>, <Line: -     * _.merge(food, otherFood, function(a, b) {
>, <Line: -     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
>, <Line: -     */
>, <Line: -    function merge(object) {
>, <Line: -      var args = arguments,
>, <Line: -          length = 2;
>, <Line: -      if (!isObject(object)) {
>, <Line: -        return object;
>, <Line: -      }
>, <Line: -      // allows working with `_.reduce` and `_.reduceRight` without using
>, <Line: -      // their `index` and `collection` arguments
>, <Line: -      if (typeof args[2] != 'number') {
>, <Line: -        length = args.length;
>, <Line: -      }
>, <Line: -      if (length > 3 && typeof args[length - 2] == 'function') {
>, <Line: -        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
>, <Line: -      } else if (length > 2 && typeof args[length - 1] == 'function') {
>, <Line: -        callback = args[--length];
>, <Line: -      }
>, <Line: -      var sources = slice(arguments, 1, length),
>, <Line: -          index = -1,
>, <Line: -          stackA = getArray(),
>, <Line: -          stackB = getArray();
>, <Line: -      while (++index < length) {
>, <Line: -        baseMerge(object, sources[index], callback, stackA, stackB);
>, <Line: -      }
>, <Line: -      releaseArray(stackA);
>, <Line: -      releaseArray(stackB);
>, <Line: -      return object;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a shallow clone of `object` excluding the specified properties.
>, <Line: -     * Property names may be specified as individual arguments or as arrays of
>, <Line: -     * property names. If a callback is provided it will be executed for each
>, <Line: -     * property of `object` omitting the properties the callback returns truey
>, <Line: -     * for. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, key, object).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The source object.
>, <Line: -     * @param {Function|...string|string[]} [callback] The properties to omit or the
>, <Line: -     *  function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns an object without the omitted properties.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
>, <Line: -     * // => { 'name': 'fred' }
>, <Line: -     *
>, <Line: -     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
>, <Line: -     * // => { 'name': 'fred' }
>, <Line: -     */
>, <Line: -    function omit(object, callback, thisArg) {
>, <Line: -      var result = {};
>, <Line: -      if (typeof callback != 'function') {
>, <Line: -        var props = [];
>, <Line: -        forIn(object, function(value, key) {
>, <Line: -          props.push(key);
>, <Line: -        });
>, <Line: -        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
>, <Line: -        var index = -1,
>, <Line: -            length = props.length;
>, <Line: -        while (++index < length) {
>, <Line: -          var key = props[index];
>, <Line: -          result[key] = object[key];
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        forIn(object, function(value, key, object) {
>, <Line: -          if (!callback(value, key, object)) {
>, <Line: -            result[key] = value;
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a two dimensional array of an object's key-value pairs,
>, <Line: -     * i.e. `[[key1, value1], [key2, value2]]`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @returns {Array} Returns new array of key-value pairs.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.pairs({ 'barney': 36, 'fred': 40 });
>, <Line: -     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    function pairs(object) {
>, <Line: -      var index = -1,
>, <Line: -          props = keys(object),
>, <Line: -          length = props.length,
>, <Line: -          result = Array(length);
>, <Line: -      while (++index < length) {
>, <Line: -        var key = props[index];
>, <Line: -        result[index] = [key, object[key]];
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a shallow clone of `object` composed of the specified properties.
>, <Line: -     * Property names may be specified as individual arguments or as arrays of
>, <Line: -     * property names. If a callback is provided it will be executed for each
>, <Line: -     * property of `object` picking the properties the callback returns truey
>, <Line: -     * for. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, key, object).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The source object.
>, <Line: -     * @param {Function|...string|string[]} [callback] The function called per
>, <Line: -     *  iteration or property names to pick, specified as individual property
>, <Line: -     *  names or arrays of property names.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns an object composed of the picked properties.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
>, <Line: -     * // => { 'name': 'fred' }
>, <Line: -     *
>, <Line: -     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
>, <Line: -     * // => { 'name': 'fred' }
>, <Line: -     */
>, <Line: -    function pick(object, callback, thisArg) {
>, <Line: -      var result = {};
>, <Line: -      if (typeof callback != 'function') {
>, <Line: -        var index = -1,
>, <Line: -            props = baseFlatten(arguments, true, false, 1),
>, <Line: -            length = isObject(object) ? props.length : 0;
>, <Line: -        while (++index < length) {
>, <Line: -          var key = props[index];
>, <Line: -          if (key in object) {
>, <Line: -            result[key] = object[key];
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        forIn(object, function(value, key, object) {
>, <Line: -          if (callback(value, key, object)) {
>, <Line: -            result[key] = value;
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * An alternative to `_.reduce` this method transforms `object` to a new
>, <Line: -     * `accumulator` object which is the result of running each of its own
>, <Line: -     * enumerable properties through a callback, with each callback execution
>, <Line: -     * potentially mutating the `accumulator` object. The callback is bound to
>, <Line: -     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
>, <Line: -     * Callbacks may exit iteration early by explicitly returning `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Array|Object} object The object to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [accumulator] The custom accumulator value.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the accumulated value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
>, <Line: -     * // => [1, 9, 25]
>, <Line: -     *
>, <Line: -     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
>, <Line: -     * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: -     */
>, <Line: -    function transform(object, callback, accumulator, thisArg) {
>, <Line: -      var isArr = isArray(object);
>, <Line: -      if (accumulator == null) {
>, <Line: -        if (isArr) {
>, <Line: -          accumulator = [];
>, <Line: -        } else {
>, <Line: -          var ctor = object && object.constructor,
>, <Line: -              proto = ctor && ctor.prototype;
>, <Line: -          accumulator = baseCreate(proto);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (callback) {
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: -        (isArr ? forEach : forOwn)(object, function(value, index, object) {
>, <Line: -          return callback(accumulator, value, index, object);
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return accumulator;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array composed of the own enumerable property values of `object`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Objects
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @returns {Array} Returns an array of property values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: -     * // => [1, 2, 3] (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    function values(object) {
>, <Line: -      var index = -1,
>, <Line: -          props = keys(object),
>, <Line: -          length = props.length,
>, <Line: -          result = Array(length);
>, <Line: -      while (++index < length) {
>, <Line: -        result[index] = object[props[index]];
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates an array of elements from the specified indexes, or keys, of the
>, <Line: -     * `collection`. Indexes may be specified as individual arguments or as arrays
>, <Line: -     * of indexes.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
>, <Line: -     *   to retrieve, specified as individual indexes or arrays of indexes.
>, <Line: -     * @returns {Array} Returns a new array of elements corresponding to the
>, <Line: -     *  provided indexes.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
>, <Line: -     * // => ['a', 'c', 'e']
>, <Line: -     *
>, <Line: -     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
>, <Line: -     * // => ['fred', 'pebbles']
>, <Line: -     */
>, <Line: -    function at(collection) {
>, <Line: -      var args = arguments,
>, <Line: -          index = -1,
>, <Line: -          props = baseFlatten(args, true, false, 1),
>, <Line: -          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
>, <Line: -          result = Array(length);
>, <Line: -      while(++index < length) {
>, <Line: -        result[index] = collection[props[index]];
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if a given value is present in a collection using strict equality
>, <Line: -     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
>, <Line: -     * offset from the end of the collection.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias include
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {*} target The value to check for.
>, <Line: -     * @param {number} [fromIndex=0] The index to search from.
>, <Line: -     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.contains([1, 2, 3], 1);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.contains([1, 2, 3], 1, 2);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * _.contains('pebbles', 'eb');
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function contains(collection, target, fromIndex) {
>, <Line: -      var index = -1,
>, <Line: -          indexOf = getIndexOf(),
>, <Line: -          length = collection ? collection.length : 0,
>, <Line: -          result = false;
>, <Line: -      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
>, <Line: -      if (isArray(collection)) {
>, <Line: -        result = indexOf(collection, target, fromIndex) > -1;
>, <Line: -      } else if (typeof length == 'number') {
>, <Line: -        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
>, <Line: -      } else {
>, <Line: -        forOwn(collection, function(value) {
>, <Line: -          if (++index >= fromIndex) {
>, <Line: -            return !(result = value === target);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object composed of keys generated from the results of running
>, <Line: -     * each element of `collection` through the callback. The corresponding value
>, <Line: -     * of each key is the number of times the key was returned by the callback.
>, <Line: -     * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns the composed aggregate object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
>, <Line: -     * // => { '4': 1, '6': 2 }
>, <Line: -     *
>, <Line: -     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
>, <Line: -     * // => { '4': 1, '6': 2 }
>, <Line: -     *
>, <Line: -     * _.countBy(['one', 'two', 'three'], 'length');
>, <Line: -     * // => { '3': 2, '5': 1 }
>, <Line: -     */
>, <Line: -    var countBy = createAggregator(function(result, value, key) {
>, <Line: -      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
>, <Line: -    });
>, <Line: -    /**
>, <Line: -     * Checks if the given callback returns truey value for **all** elements of
>, <Line: -     * a collection. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias all
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {boolean} Returns `true` if all elements passed the callback check,
>, <Line: -     *  else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.every([true, 1, null, 'yes']);
>, <Line: -     * // => false
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.every(characters, 'age');
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.every(characters, { 'age': 36 });
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function every(collection, callback, thisArg) {
>, <Line: -      var result = true;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (++index < length) {
>, <Line: -          if (!(result = !!callback(collection[index], index, collection))) {
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        forOwn(collection, function(value, index, collection) {
>, <Line: -          return (result = !!callback(value, index, collection));
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Iterates over elements of a collection, returning an array of all elements
>, <Line: -     * the callback returns truey for. The callback is bound to `thisArg` and
>, <Line: -     * invoked with three arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias select
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new array of elements that passed the callback check.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
>, <Line: -     * // => [2, 4, 6]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: -     *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.filter(characters, 'blocked');
>, <Line: -     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.filter(characters, { 'age': 36 });
>, <Line: -     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
>, <Line: -     */
>, <Line: -    function filter(collection, callback, thisArg) {
>, <Line: -      var result = [];
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (++index < length) {
>, <Line: -          var value = collection[index];
>, <Line: -          if (callback(value, index, collection)) {
>, <Line: -            result.push(value);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        forOwn(collection, function(value, index, collection) {
>, <Line: -          if (callback(value, index, collection)) {
>, <Line: -            result.push(value);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Iterates over elements of a collection, returning the first element that
>, <Line: -     * the callback returns truey for. The callback is bound to `thisArg` and
>, <Line: -     * invoked with three arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias detect, findWhere
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the found element, else `undefined`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'age': 36, 'blocked': false },
>, <Line: -     *   { 'name': 'fred',    'age': 40, 'blocked': true },
>, <Line: -     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.find(characters, function(chr) {
>, <Line: -     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.find(characters, { 'age': 1 });
>, <Line: -     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.find(characters, 'blocked');
>, <Line: -     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
>, <Line: -     */
>, <Line: -    function find(collection, callback, thisArg) {
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (++index < length) {
>, <Line: -          var value = collection[index];
>, <Line: -          if (callback(value, index, collection)) {
>, <Line: -            return value;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        var result;
>, <Line: -        forOwn(collection, function(value, index, collection) {
>, <Line: -          if (callback(value, index, collection)) {
>, <Line: -            result = value;
>, <Line: -            return false;
>, <Line: -          }
>, <Line: -        });
>, <Line: -        return result;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.find` except that it iterates over elements
>, <Line: -     * of a `collection` from right to left.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the found element, else `undefined`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.findLast([1, 2, 3, 4], function(num) {
>, <Line: -     * // => 3
>, <Line: -     */
>, <Line: -    function findLast(collection, callback, thisArg) {
>, <Line: -      var result;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      forEachRight(collection, function(value, index, collection) {
>, <Line: -        if (callback(value, index, collection)) {
>, <Line: -          result = value;
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Iterates over elements of a collection, executing the callback for each
>, <Line: -     * element. The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, index|key, collection). Callbacks may exit iteration early by
>, <Line: -     * explicitly returning `false`.
>, <Line: -     *
>, <Line: -     * Note: As with other "Collections" methods, objects with a `length` property
>, <Line: -     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
>, <Line: -     * may be used for object iteration.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias each
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array|Object|string} Returns `collection`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
>, <Line: -     * // => logs each number and returns '1,2,3'
>, <Line: -     *
>, <Line: -     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
>, <Line: -     * // => logs each number and returns the object (property order is not guaranteed across environments)
>, <Line: -     */
>, <Line: -    function forEach(collection, callback, thisArg) {
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (++index < length) {
>, <Line: -          if (callback(collection[index], index, collection) === false) {
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        forOwn(collection, callback);
>, <Line: -      }
>, <Line: -      return collection;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.forEach` except that it iterates over elements
>, <Line: -     * of a `collection` from right to left.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias eachRight
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array|Object|string} Returns `collection`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
>, <Line: -     * // => logs each number from right to left and returns '3,2,1'
>, <Line: -     */
>, <Line: -    function forEachRight(collection, callback, thisArg) {
>, <Line: -      var length = collection ? collection.length : 0;
>, <Line: -      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (length--) {
>, <Line: -          if (callback(collection[length], length, collection) === false) {
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        var props = keys(collection);
>, <Line: -        length = props.length;
>, <Line: -        forOwn(collection, function(value, key, collection) {
>, <Line: -          key = props ? props[--length] : --length;
>, <Line: -          return callback(collection[key], key, collection);
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return collection;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object composed of keys generated from the results of running
>, <Line: -     * each element of a collection through the callback. The corresponding value
>, <Line: -     * of each key is an array of the elements responsible for generating the key.
>, <Line: -     * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns the composed aggregate object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
>, <Line: -     * // => { '4': [4.2], '6': [6.1, 6.4] }
>, <Line: -     *
>, <Line: -     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
>, <Line: -     * // => { '4': [4.2], '6': [6.1, 6.4] }
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.groupBy(['one', 'two', 'three'], 'length');
>, <Line: -     * // => { '3': ['one', 'two'], '5': ['three'] }
>, <Line: -     */
>, <Line: -    var groupBy = createAggregator(function(result, value, key) {
>, <Line: -      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
>, <Line: -    });
>, <Line: -    /**
>, <Line: -     * Creates an object composed of keys generated from the results of running
>, <Line: -     * each element of the collection through the given callback. The corresponding
>, <Line: -     * value of each key is the last element responsible for generating the key.
>, <Line: -     * The callback is bound to `thisArg` and invoked with three arguments;
>, <Line: -     * (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Object} Returns the composed aggregate object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var keys = [
>, <Line: -     *   { 'dir': 'left', 'code': 97 },
>, <Line: -     *   { 'dir': 'right', 'code': 100 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.indexBy(keys, 'dir');
>, <Line: -     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
>, <Line: -     *
>, <Line: -     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
>, <Line: -     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
>, <Line: -     *
>, <Line: -     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
>, <Line: -     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
>, <Line: -     */
>, <Line: -    var indexBy = createAggregator(function(result, value, key) {
>, <Line: -      result[key] = value;
>, <Line: -    });
>, <Line: -    /**
>, <Line: -     * Invokes the method named by `methodName` on each element in the `collection`
>, <Line: -     * returning an array of the results of each invoked method. Additional arguments
>, <Line: -     * will be provided to each invoked method. If `methodName` is a function it
>, <Line: -     * will be invoked for, and `this` bound to, each element in the `collection`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|string} methodName The name of the method to invoke or
>, <Line: -     *  the function invoked per iteration.
>, <Line: -     * @param {...*} [arg] Arguments to invoke the method with.
>, <Line: -     * @returns {Array} Returns a new array of the results of each invoked method.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
>, <Line: -     * // => [[1, 5, 7], [1, 2, 3]]
>, <Line: -     *
>, <Line: -     * _.invoke([123, 456], String.prototype.split, '');
>, <Line: -     * // => [['1', '2', '3'], ['4', '5', '6']]
>, <Line: -     */
>, <Line: -    function invoke(collection, methodName) {
>, <Line: -      var args = slice(arguments, 2),
>, <Line: -          index = -1,
>, <Line: -          isFunc = typeof methodName == 'function',
>, <Line: -          length = collection ? collection.length : 0,
>, <Line: -          result = Array(typeof length == 'number' ? length : 0);
>, <Line: -      forEach(collection, function(value) {
>, <Line: -        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of values by running each element in the collection
>, <Line: -     * through the callback. The callback is bound to `thisArg` and invoked with
>, <Line: -     * three arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias collect
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new array of the results of each `callback` execution.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.map([1, 2, 3], function(num) { return num * 3; });
>, <Line: -     * // => [3, 6, 9]
>, <Line: -     *
>, <Line: -     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
>, <Line: -     * // => [3, 6, 9] (property order is not guaranteed across environments)
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.map(characters, 'name');
>, <Line: -     * // => ['barney', 'fred']
>, <Line: -     */
>, <Line: -    function map(collection, callback, thisArg) {
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        var result = Array(length);
>, <Line: -        while (++index < length) {
>, <Line: -          result[index] = callback(collection[index], index, collection);
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        result = [];
>, <Line: -        forOwn(collection, function(value, key, collection) {
>, <Line: -          result[++index] = callback(value, key, collection);
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Retrieves the maximum value of a collection. If the collection is empty or
>, <Line: -     * falsey `-Infinity` is returned. If a callback is provided it will be executed
>, <Line: -     * for each value in the collection to generate the criterion by which the value
>, <Line: -     * is ranked. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, index, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the maximum value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.max([4, 2, 8, 6]);
>, <Line: -     * // => 8
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.max(characters, function(chr) { return chr.age; });
>, <Line: -     * // => { 'name': 'fred', 'age': 40 };
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.max(characters, 'age');
>, <Line: -     * // => { 'name': 'fred', 'age': 40 };
>, <Line: -     */
>, <Line: -    function max(collection, callback, thisArg) {
>, <Line: -      var computed = -Infinity,
>, <Line: -          result = computed;
>, <Line: -      // allows working with functions like `_.map` without using
>, <Line: -      // their `index` argument as a callback
>, <Line: -      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
>, <Line: -        callback = null;
>, <Line: -      }
>, <Line: -      if (callback == null && isArray(collection)) {
>, <Line: -        var index = -1,
>, <Line: -            length = collection.length;
>, <Line: -        while (++index < length) {
>, <Line: -          var value = collection[index];
>, <Line: -          if (value > result) {
>, <Line: -            result = value;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        callback = (callback == null && isString(collection))
>, <Line: -          ? charAtCallback
>, <Line: -          : lodash.createCallback(callback, thisArg, 3);
>, <Line: -        forEach(collection, function(value, index, collection) {
>, <Line: -          var current = callback(value, index, collection);
>, <Line: -          if (current > computed) {
>, <Line: -            computed = current;
>, <Line: -            result = value;
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Retrieves the minimum value of a collection. If the collection is empty or
>, <Line: -     * falsey `Infinity` is returned. If a callback is provided it will be executed
>, <Line: -     * for each value in the collection to generate the criterion by which the value
>, <Line: -     * is ranked. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, index, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the minimum value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.min([4, 2, 8, 6]);
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.min(characters, function(chr) { return chr.age; });
>, <Line: -     * // => { 'name': 'barney', 'age': 36 };
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.min(characters, 'age');
>, <Line: -     * // => { 'name': 'barney', 'age': 36 };
>, <Line: -     */
>, <Line: -    function min(collection, callback, thisArg) {
>, <Line: -      var computed = Infinity,
>, <Line: -          result = computed;
>, <Line: -      // allows working with functions like `_.map` without using
>, <Line: -      // their `index` argument as a callback
>, <Line: -      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
>, <Line: -        callback = null;
>, <Line: -      }
>, <Line: -      if (callback == null && isArray(collection)) {
>, <Line: -        var index = -1,
>, <Line: -            length = collection.length;
>, <Line: -        while (++index < length) {
>, <Line: -          var value = collection[index];
>, <Line: -          if (value < result) {
>, <Line: -            result = value;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        callback = (callback == null && isString(collection))
>, <Line: -          ? charAtCallback
>, <Line: -          : lodash.createCallback(callback, thisArg, 3);
>, <Line: -        forEach(collection, function(value, index, collection) {
>, <Line: -          var current = callback(value, index, collection);
>, <Line: -          if (current < computed) {
>, <Line: -            computed = current;
>, <Line: -            result = value;
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Retrieves the value of a specified property from all elements in the collection.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {string} property The name of the property to pluck.
>, <Line: -     * @returns {Array} Returns a new array of property values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.pluck(characters, 'name');
>, <Line: -     * // => ['barney', 'fred']
>, <Line: -     */
>, <Line: -    var pluck = map;
>, <Line: -    /**
>, <Line: -     * Reduces a collection to a value which is the accumulated result of running
>, <Line: -     * each element in the collection through the callback, where each successive
>, <Line: -     * callback execution consumes the return value of the previous execution. If
>, <Line: -     * `accumulator` is not provided the first element of the collection will be
>, <Line: -     * used as the initial `accumulator` value. The callback is bound to `thisArg`
>, <Line: -     * and invoked with four arguments; (accumulator, value, index|key, collection).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias foldl, inject
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [accumulator] Initial value of the accumulator.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the accumulated value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var sum = _.reduce([1, 2, 3], function(sum, num) {
>, <Line: -     * // => 6
>, <Line: -     *
>, <Line: -     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
>, <Line: -     * // => { 'a': 3, 'b': 6, 'c': 9 }
>, <Line: -     */
>, <Line: -    function reduce(collection, callback, accumulator, thisArg) {
>, <Line: -      if (!collection) return accumulator;
>, <Line: -      var noaccum = arguments.length < 3;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: -      var index = -1,
>, <Line: -          length = collection.length;
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        if (noaccum) {
>, <Line: -          accumulator = collection[++index];
>, <Line: -        }
>, <Line: -        while (++index < length) {
>, <Line: -          accumulator = callback(accumulator, collection[index], index, collection);
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        forOwn(collection, function(value, index, collection) {
>, <Line: -          accumulator = noaccum
>, <Line: -            ? (noaccum = false, value)
>, <Line: -            : callback(accumulator, value, index, collection)
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return accumulator;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.reduce` except that it iterates over elements
>, <Line: -     * of a `collection` from right to left.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias foldr
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function} [callback=identity] The function called per iteration.
>, <Line: -     * @param {*} [accumulator] Initial value of the accumulator.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the accumulated value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var list = [[0, 1], [2, 3], [4, 5]];
>, <Line: -     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
>, <Line: -     * // => [4, 5, 2, 3, 0, 1]
>, <Line: -     */
>, <Line: -    function reduceRight(collection, callback, accumulator, thisArg) {
>, <Line: -      var noaccum = arguments.length < 3;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 4);
>, <Line: -      forEachRight(collection, function(value, index, collection) {
>, <Line: -        accumulator = noaccum
>, <Line: -          ? (noaccum = false, value)
>, <Line: -          : callback(accumulator, value, index, collection);
>, <Line: -      });
>, <Line: -      return accumulator;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The opposite of `_.filter` this method returns the elements of a
>, <Line: -     * collection that the callback does **not** return truey for.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new array of elements that failed the callback check.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
>, <Line: -     * // => [1, 3, 5]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: -     *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.reject(characters, 'blocked');
>, <Line: -     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.reject(characters, { 'age': 36 });
>, <Line: -     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
>, <Line: -     */
>, <Line: -    function reject(collection, callback, thisArg) {
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      return filter(collection, function(value, index, collection) {
>, <Line: -        return !callback(value, index, collection);
>, <Line: -      });
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Retrieves a random element or `n` random elements from a collection.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to sample.
>, <Line: -     * @param {number} [n] The number of elements to sample.
>, <Line: -     * @param- {Object} [guard] Allows working with functions like `_.map`
>, <Line: -     *  without using their `index` arguments as `n`.
>, <Line: -     * @returns {Array} Returns the random sample(s) of `collection`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.sample([1, 2, 3, 4]);
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * _.sample([1, 2, 3, 4], 2);
>, <Line: -     * // => [3, 1]
>, <Line: -     */
>, <Line: -    function sample(collection, n, guard) {
>, <Line: -      if (collection && typeof collection.length != 'number') {
>, <Line: -        collection = values(collection);
>, <Line: -      }
>, <Line: -      if (n == null || guard) {
>, <Line: -        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
>, <Line: -      }
>, <Line: -      var result = shuffle(collection);
>, <Line: -      result.length = nativeMin(nativeMax(0, n), result.length);
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of shuffled values, using a version of the Fisher-Yates
>, <Line: -     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to shuffle.
>, <Line: -     * @returns {Array} Returns a new shuffled collection.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.shuffle([1, 2, 3, 4, 5, 6]);
>, <Line: -     * // => [4, 1, 6, 3, 5, 2]
>, <Line: -     */
>, <Line: -    function shuffle(collection) {
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0,
>, <Line: -          result = Array(typeof length == 'number' ? length : 0);
>, <Line: -      forEach(collection, function(value) {
>, <Line: -        var rand = baseRandom(0, ++index);
>, <Line: -        result[index] = result[rand];
>, <Line: -        result[rand] = value;
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the size of the `collection` by returning `collection.length` for arrays
>, <Line: -     * and array-like objects or the number of own enumerable properties for objects.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to inspect.
>, <Line: -     * @returns {number} Returns `collection.length` or number of own enumerable properties.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.size([1, 2]);
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
>, <Line: -     * // => 3
>, <Line: -     *
>, <Line: -     * _.size('pebbles');
>, <Line: -     * // => 7
>, <Line: -     */
>, <Line: -    function size(collection) {
>, <Line: -      var length = collection ? collection.length : 0;
>, <Line: -      return typeof length == 'number' ? length : keys(collection).length;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Checks if the callback returns a truey value for **any** element of a
>, <Line: -     * collection. The function returns as soon as it finds a passing value and
>, <Line: -     * does not iterate over the entire collection. The callback is bound to
>, <Line: -     * `thisArg` and invoked with three arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias any
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {boolean} Returns `true` if any element passed the callback check,
>, <Line: -     *  else `false`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.some([null, 0, 'yes', false], Boolean);
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36, 'blocked': false },
>, <Line: -     *   { 'name': 'fred',   'age': 40, 'blocked': true }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.some(characters, 'blocked');
>, <Line: -     * // => true
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.some(characters, { 'age': 1 });
>, <Line: -     * // => false
>, <Line: -     */
>, <Line: -    function some(collection, callback, thisArg) {
>, <Line: -      var result;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      var index = -1,
>, <Line: -          length = collection ? collection.length : 0;
>, <Line: -      if (typeof length == 'number') {
>, <Line: -        while (++index < length) {
>, <Line: -          if ((result = callback(collection[index], index, collection))) {
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        forOwn(collection, function(value, index, collection) {
>, <Line: -          return !(result = callback(value, index, collection));
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return !!result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of elements, sorted in ascending order by the results of
>, <Line: -     * running each element in a collection through the callback. This method
>, <Line: -     * performs a stable sort, that is, it will preserve the original sort order
>, <Line: -     * of equal elements. The callback is bound to `thisArg` and invoked with
>, <Line: -     * three arguments; (value, index|key, collection).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an array of property names is provided for `callback` the collection
>, <Line: -     * will be sorted by each property value.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Array|Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new array of sorted elements.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
>, <Line: -     * // => [3, 1, 2]
>, <Line: -     *
>, <Line: -     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
>, <Line: -     * // => [3, 1, 2]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'age': 36 },
>, <Line: -     *   { 'name': 'fred',    'age': 40 },
>, <Line: -     *   { 'name': 'barney',  'age': 26 },
>, <Line: -     *   { 'name': 'fred',    'age': 30 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.map(_.sortBy(characters, 'age'), _.values);
>, <Line: -     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
>, <Line: -     *
>, <Line: -     * // sorting by multiple properties
>, <Line: -     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
>, <Line: -     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
>, <Line: -     */
>, <Line: -    function sortBy(collection, callback, thisArg) {
>, <Line: -      var index = -1,
>, <Line: -          isArr = isArray(callback),
>, <Line: -          length = collection ? collection.length : 0,
>, <Line: -          result = Array(typeof length == 'number' ? length : 0);
>, <Line: -      if (!isArr) {
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      }
>, <Line: -      forEach(collection, function(value, key, collection) {
>, <Line: -        var object = result[++index] = getObject();
>, <Line: -        if (isArr) {
>, <Line: -          object.criteria = map(callback, function(key) { return value[key]; });
>, <Line: -        } else {
>, <Line: -          (object.criteria = getArray())[0] = callback(value, key, collection);
>, <Line: -        }
>, <Line: -        object.index = index;
>, <Line: -        object.value = value;
>, <Line: -      });
>, <Line: -      length = result.length;
>, <Line: -      result.sort(compareAscending);
>, <Line: -      while (length--) {
>, <Line: -        var object = result[length];
>, <Line: -        result[length] = object.value;
>, <Line: -        if (!isArr) {
>, <Line: -          releaseArray(object.criteria);
>, <Line: -        }
>, <Line: -        releaseObject(object);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Converts the `collection` to an array.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to convert.
>, <Line: -     * @returns {Array} Returns the new converted array.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
>, <Line: -     * // => [2, 3, 4]
>, <Line: -     */
>, <Line: -    function toArray(collection) {
>, <Line: -      if (collection && typeof collection.length == 'number') {
>, <Line: -        return slice(collection);
>, <Line: -      }
>, <Line: -      return values(collection);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Performs a deep comparison of each element in a `collection` to the given
>, <Line: -     * `properties` object, returning an array of all elements that have equivalent
>, <Line: -     * property values.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type Function
>, <Line: -     * @category Collections
>, <Line: -     * @param {Array|Object|string} collection The collection to iterate over.
>, <Line: -     * @param {Object} props The object of property values to filter by.
>, <Line: -     * @returns {Array} Returns a new array of elements that have the given properties.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
>, <Line: -     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.where(characters, { 'age': 36 });
>, <Line: -     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
>, <Line: -     *
>, <Line: -     * _.where(characters, { 'pets': ['dino'] });
>, <Line: -     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
>, <Line: -     */
>, <Line: -    var where = filter;
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates an array with all falsey values removed. The values `false`, `null`,
>, <Line: -     * `0`, `""`, `undefined`, and `NaN` are all falsey.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to compact.
>, <Line: -     * @returns {Array} Returns a new array of filtered values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.compact([0, 1, false, 2, '', 3]);
>, <Line: -     * // => [1, 2, 3]
>, <Line: -     */
>, <Line: -    function compact(array) {
>, <Line: -      var index = -1,
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          result = [];
>, <Line: -      while (++index < length) {
>, <Line: -        var value = array[index];
>, <Line: -        if (value) {
>, <Line: -          result.push(value);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array excluding all values of the provided arrays using strict
>, <Line: -     * equality for comparisons, i.e. `===`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to process.
>, <Line: -     * @param {...Array} [values] The arrays of values to exclude.
>, <Line: -     * @returns {Array} Returns a new array of filtered values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
>, <Line: -     * // => [1, 3, 4]
>, <Line: -     */
>, <Line: -    function difference(array) {
>, <Line: -      return baseDifference(array, baseFlatten(arguments, true, true, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.find` except that it returns the index of the first
>, <Line: -     * element that passes the callback check, instead of the element itself.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to search.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {number} Returns the index of the found element, else `-1`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'age': 36, 'blocked': false },
>, <Line: -     *   { 'name': 'fred',    'age': 40, 'blocked': true },
>, <Line: -     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.findIndex(characters, function(chr) {
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.findIndex(characters, { 'age': 36 });
>, <Line: -     * // => 0
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.findIndex(characters, 'blocked');
>, <Line: -     * // => 1
>, <Line: -     */
>, <Line: -    function findIndex(array, callback, thisArg) {
>, <Line: -      var index = -1,
>, <Line: -          length = array ? array.length : 0;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      while (++index < length) {
>, <Line: -        if (callback(array[index], index, array)) {
>, <Line: -          return index;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return -1;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.findIndex` except that it iterates over elements
>, <Line: -     * of a `collection` from right to left.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to search.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {number} Returns the index of the found element, else `-1`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'age': 36, 'blocked': true },
>, <Line: -     *   { 'name': 'fred',    'age': 40, 'blocked': false },
>, <Line: -     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * _.findLastIndex(characters, function(chr) {
>, <Line: -     * // => 1
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.findLastIndex(characters, { 'age': 36 });
>, <Line: -     * // => 0
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.findLastIndex(characters, 'blocked');
>, <Line: -     * // => 2
>, <Line: -     */
>, <Line: -    function findLastIndex(array, callback, thisArg) {
>, <Line: -      var length = array ? array.length : 0;
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      while (length--) {
>, <Line: -        if (callback(array[length], length, array)) {
>, <Line: -          return length;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return -1;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the first element or first `n` elements of an array. If a callback
>, <Line: -     * is provided elements at the beginning of the array are returned as long
>, <Line: -     * as the callback returns truey. The callback is bound to `thisArg` and
>, <Line: -     * invoked with three arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias head, take
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to query.
>, <Line: -     * @param {Function|Object|number|string} [callback] The function called
>, <Line: -     *  per element or the number of elements to return. If a property name or
>, <Line: -     *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: -     *  style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the first element(s) of `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.first([1, 2, 3]);
>, <Line: -     * // => 1
>, <Line: -     *
>, <Line: -     * _.first([1, 2, 3], 2);
>, <Line: -     * // => [1, 2]
>, <Line: -     *
>, <Line: -     * _.first([1, 2, 3], function(num) {
>, <Line: -     * // => [1, 2]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
>, <Line: -     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
>, <Line: -     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.first(characters, 'blocked');
>, <Line: -     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
>, <Line: -     * // => ['barney', 'fred']
>, <Line: -     */
>, <Line: -    function first(array, callback, thisArg) {
>, <Line: -      var n = 0,
>, <Line: -          length = array ? array.length : 0;
>, <Line: -      if (typeof callback != 'number' && callback != null) {
>, <Line: -        var index = -1;
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        while (++index < length && callback(array[index], index, array)) {
>, <Line: -          n++;
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        n = callback;
>, <Line: -        if (n == null || thisArg) {
>, <Line: -          return array ? array[0] : undefined;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return slice(array, 0, nativeMin(nativeMax(0, n), length));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
>, <Line: -     * is truey, the array will only be flattened a single level. If a callback
>, <Line: -     * is provided each element of the array is passed through the callback before
>, <Line: -     * flattening. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to flatten.
>, <Line: -     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new flattened array.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.flatten([1, [2], [3, [[4]]]]);
>, <Line: -     * // => [1, 2, 3, 4];
>, <Line: -     *
>, <Line: -     * _.flatten([1, [2], [3, [[4]]]], true);
>, <Line: -     * // => [1, 2, 3, [[4]]];
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
>, <Line: -     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.flatten(characters, 'pets');
>, <Line: -     * // => ['hoppy', 'baby puss', 'dino']
>, <Line: -     */
>, <Line: -    function flatten(array, isShallow, callback, thisArg) {
>, <Line: -      // juggle arguments
>, <Line: -      if (typeof isShallow != 'boolean' && isShallow != null) {
>, <Line: -        thisArg = callback;
>, <Line: -        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
>, <Line: -        isShallow = false;
>, <Line: -      }
>, <Line: -      if (callback != null) {
>, <Line: -        array = map(array, callback, thisArg);
>, <Line: -      }
>, <Line: -      return baseFlatten(array, isShallow);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the index at which the first occurrence of `value` is found using
>, <Line: -     * strict equality for comparisons, i.e. `===`. If the array is already sorted
>, <Line: -     * providing `true` for `fromIndex` will run a faster binary search.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to search.
>, <Line: -     * @param {*} value The value to search for.
>, <Line: -     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
>, <Line: -     *  to perform a binary search on a sorted array.
>, <Line: -     * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
>, <Line: -     * // => 1
>, <Line: -     *
>, <Line: -     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
>, <Line: -     * // => 4
>, <Line: -     *
>, <Line: -     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
>, <Line: -     * // => 2
>, <Line: -     */
>, <Line: -    function indexOf(array, value, fromIndex) {
>, <Line: -      if (typeof fromIndex == 'number') {
>, <Line: -        var length = array ? array.length : 0;
>, <Line: -        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
>, <Line: -      } else if (fromIndex) {
>, <Line: -        var index = sortedIndex(array, value);
>, <Line: -        return array[index] === value ? index : -1;
>, <Line: -      }
>, <Line: -      return baseIndexOf(array, value, fromIndex);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets all but the last element or last `n` elements of an array. If a
>, <Line: -     * callback is provided elements at the end of the array are excluded from
>, <Line: -     * the result as long as the callback returns truey. The callback is bound
>, <Line: -     * to `thisArg` and invoked with three arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to query.
>, <Line: -     * @param {Function|Object|number|string} [callback=1] The function called
>, <Line: -     *  per element or the number of elements to exclude. If a property name or
>, <Line: -     *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: -     *  style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a slice of `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.initial([1, 2, 3]);
>, <Line: -     * // => [1, 2]
>, <Line: -     *
>, <Line: -     * _.initial([1, 2, 3], 2);
>, <Line: -     * // => [1]
>, <Line: -     *
>, <Line: -     * _.initial([1, 2, 3], function(num) {
>, <Line: -     * // => [1]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
>, <Line: -     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
>, <Line: -     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.initial(characters, 'blocked');
>, <Line: -     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
>, <Line: -     * // => ['barney', 'fred']
>, <Line: -     */
>, <Line: -    function initial(array, callback, thisArg) {
>, <Line: -      var n = 0,
>, <Line: -          length = array ? array.length : 0;
>, <Line: -      if (typeof callback != 'number' && callback != null) {
>, <Line: -        var index = length;
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        while (index-- && callback(array[index], index, array)) {
>, <Line: -          n++;
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        n = (callback == null || thisArg) ? 1 : callback || n;
>, <Line: -      }
>, <Line: -      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of unique values present in all provided arrays using
>, <Line: -     * strict equality for comparisons, i.e. `===`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {...Array} [array] The arrays to inspect.
>, <Line: -     * @returns {Array} Returns an array of shared values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
>, <Line: -     * // => [1, 2]
>, <Line: -     */
>, <Line: -    function intersection() {
>, <Line: -      var args = [],
>, <Line: -          argsIndex = -1,
>, <Line: -          argsLength = arguments.length,
>, <Line: -          caches = getArray(),
>, <Line: -          indexOf = getIndexOf(),
>, <Line: -          trustIndexOf = indexOf === baseIndexOf,
>, <Line: -          seen = getArray();
>, <Line: -      while (++argsIndex < argsLength) {
>, <Line: -        var value = arguments[argsIndex];
>, <Line: -        if (isArray(value) || isArguments(value)) {
>, <Line: -          args.push(value);
>, <Line: -          caches.push(trustIndexOf && value.length >= largeArraySize &&
>, <Line: -            createCache(argsIndex ? args[argsIndex] : seen));
>, <Line: -        }
>, <Line: -      }
>, <Line: -      var array = args[0],
>, <Line: -          index = -1,
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          result = [];
>, <Line: -      outer:
>, <Line: -      while (++index < length) {
>, <Line: -        var cache = caches[0];
>, <Line: -        value = array[index];
>, <Line: -        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
>, <Line: -          argsIndex = argsLength;
>, <Line: -          (cache || seen).push(value);
>, <Line: -          while (--argsIndex) {
>, <Line: -            cache = caches[argsIndex];
>, <Line: -            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
>, <Line: -              continue outer;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          result.push(value);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      while (argsLength--) {
>, <Line: -        cache = caches[argsLength];
>, <Line: -        if (cache) {
>, <Line: -          releaseObject(cache);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      releaseArray(caches);
>, <Line: -      releaseArray(seen);
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the last element or last `n` elements of an array. If a callback is
>, <Line: -     * provided elements at the end of the array are returned as long as the
>, <Line: -     * callback returns truey. The callback is bound to `thisArg` and invoked
>, <Line: -     * with three arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to query.
>, <Line: -     * @param {Function|Object|number|string} [callback] The function called
>, <Line: -     *  per element or the number of elements to return. If a property name or
>, <Line: -     *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: -     *  style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {*} Returns the last element(s) of `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.last([1, 2, 3]);
>, <Line: -     * // => 3
>, <Line: -     *
>, <Line: -     * _.last([1, 2, 3], 2);
>, <Line: -     * // => [2, 3]
>, <Line: -     *
>, <Line: -     * _.last([1, 2, 3], function(num) {
>, <Line: -     * // => [2, 3]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
>, <Line: -     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
>, <Line: -     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.pluck(_.last(characters, 'blocked'), 'name');
>, <Line: -     * // => ['fred', 'pebbles']
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.last(characters, { 'employer': 'na' });
>, <Line: -     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
>, <Line: -     */
>, <Line: -    function last(array, callback, thisArg) {
>, <Line: -      var n = 0,
>, <Line: -          length = array ? array.length : 0;
>, <Line: -      if (typeof callback != 'number' && callback != null) {
>, <Line: -        var index = length;
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        while (index-- && callback(array[index], index, array)) {
>, <Line: -          n++;
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        n = callback;
>, <Line: -        if (n == null || thisArg) {
>, <Line: -          return array ? array[length - 1] : undefined;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return slice(array, nativeMax(0, length - n));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the index at which the last occurrence of `value` is found using strict
>, <Line: -     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
>, <Line: -     * as the offset from the end of the collection.
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to search.
>, <Line: -     * @param {*} value The value to search for.
>, <Line: -     * @param {number} [fromIndex=array.length-1] The index to search from.
>, <Line: -     * @returns {number} Returns the index of the matched value or `-1`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
>, <Line: -     * // => 4
>, <Line: -     *
>, <Line: -     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
>, <Line: -     * // => 1
>, <Line: -     */
>, <Line: -    function lastIndexOf(array, value, fromIndex) {
>, <Line: -      var index = array ? array.length : 0;
>, <Line: -      if (typeof fromIndex == 'number') {
>, <Line: -        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
>, <Line: -      }
>, <Line: -      while (index--) {
>, <Line: -        if (array[index] === value) {
>, <Line: -          return index;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return -1;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Removes all provided values from the given array using strict equality for
>, <Line: -     * comparisons, i.e. `===`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to modify.
>, <Line: -     * @param {...*} [value] The values to remove.
>, <Line: -     * @returns {Array} Returns `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var array = [1, 2, 3, 1, 2, 3];
>, <Line: -     * _.pull(array, 2, 3);
>, <Line: -     * console.log(array);
>, <Line: -     * // => [1, 1]
>, <Line: -     */
>, <Line: -    function pull(array) {
>, <Line: -      var args = arguments,
>, <Line: -          argsIndex = 0,
>, <Line: -          argsLength = args.length,
>, <Line: -          length = array ? array.length : 0;
>, <Line: -      while (++argsIndex < argsLength) {
>, <Line: -        var index = -1,
>, <Line: -            value = args[argsIndex];
>, <Line: -        while (++index < length) {
>, <Line: -          if (array[index] === value) {
>, <Line: -            splice.call(array, index--, 1);
>, <Line: -            length--;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return array;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of numbers (positive and/or negative) progressing from
>, <Line: -     * `start` up to but not including `end`. If `start` is less than `stop` a
>, <Line: -     * zero-length range is created unless a negative `step` is specified.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {number} [start=0] The start of the range.
>, <Line: -     * @param {number} end The end of the range.
>, <Line: -     * @param {number} [step=1] The value to increment or decrement by.
>, <Line: -     * @returns {Array} Returns a new range array.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.range(4);
>, <Line: -     * // => [0, 1, 2, 3]
>, <Line: -     *
>, <Line: -     * _.range(1, 5);
>, <Line: -     * // => [1, 2, 3, 4]
>, <Line: -     *
>, <Line: -     * _.range(0, 20, 5);
>, <Line: -     * // => [0, 5, 10, 15]
>, <Line: -     *
>, <Line: -     * _.range(0, -4, -1);
>, <Line: -     * // => [0, -1, -2, -3]
>, <Line: -     *
>, <Line: -     * _.range(1, 4, 0);
>, <Line: -     * // => [1, 1, 1]
>, <Line: -     *
>, <Line: -     * _.range(0);
>, <Line: -     * // => []
>, <Line: -     */
>, <Line: -    function range(start, end, step) {
>, <Line: -      start = +start || 0;
>, <Line: -      step = typeof step == 'number' ? step : (+step || 1);
>, <Line: -      if (end == null) {
>, <Line: -        end = start;
>, <Line: -        start = 0;
>, <Line: -      }
>, <Line: -      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
>, <Line: -      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
>, <Line: -      var index = -1,
>, <Line: -          length = nativeMax(0, ceil((end - start) / (step || 1))),
>, <Line: -          result = Array(length);
>, <Line: -      while (++index < length) {
>, <Line: -        result[index] = start;
>, <Line: -        start += step;
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Removes all elements from an array that the callback returns truey for
>, <Line: -     * and returns an array of removed elements. The callback is bound to `thisArg`
>, <Line: -     * and invoked with three arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to modify.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a new array of removed elements.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var array = [1, 2, 3, 4, 5, 6];
>, <Line: -     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
>, <Line: -     *
>, <Line: -     * console.log(array);
>, <Line: -     * // => [1, 3, 5]
>, <Line: -     *
>, <Line: -     * console.log(evens);
>, <Line: -     * // => [2, 4, 6]
>, <Line: -     */
>, <Line: -    function remove(array, callback, thisArg) {
>, <Line: -      var index = -1,
>, <Line: -          length = array ? array.length : 0,
>, <Line: -          result = [];
>, <Line: -      callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      while (++index < length) {
>, <Line: -        var value = array[index];
>, <Line: -        if (callback(value, index, array)) {
>, <Line: -          result.push(value);
>, <Line: -          splice.call(array, index--, 1);
>, <Line: -          length--;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The opposite of `_.initial` this method gets all but the first element or
>, <Line: -     * first `n` elements of an array. If a callback function is provided elements
>, <Line: -     * at the beginning of the array are excluded from the result as long as the
>, <Line: -     * callback returns truey. The callback is bound to `thisArg` and invoked
>, <Line: -     * with three arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias drop, tail
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to query.
>, <Line: -     * @param {Function|Object|number|string} [callback=1] The function called
>, <Line: -     *  per element or the number of elements to exclude. If a property name or
>, <Line: -     *  object is provided it will be used to create a "_.pluck" or "_.where"
>, <Line: -     *  style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a slice of `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.rest([1, 2, 3]);
>, <Line: -     * // => [2, 3]
>, <Line: -     *
>, <Line: -     * _.rest([1, 2, 3], 2);
>, <Line: -     * // => [3]
>, <Line: -     *
>, <Line: -     * _.rest([1, 2, 3], function(num) {
>, <Line: -     * // => [3]
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
>, <Line: -     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
>, <Line: -     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.pluck(_.rest(characters, 'blocked'), 'name');
>, <Line: -     * // => ['fred', 'pebbles']
>, <Line: -     *
>, <Line: -     * // using "_.where" callback shorthand
>, <Line: -     * _.rest(characters, { 'employer': 'slate' });
>, <Line: -     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
>, <Line: -     */
>, <Line: -    function rest(array, callback, thisArg) {
>, <Line: -      if (typeof callback != 'number' && callback != null) {
>, <Line: -        var n = 0,
>, <Line: -            index = -1,
>, <Line: -            length = array ? array.length : 0;
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -        while (++index < length && callback(array[index], index, array)) {
>, <Line: -          n++;
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
>, <Line: -      }
>, <Line: -      return slice(array, n);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Uses a binary search to determine the smallest index at which a value
>, <Line: -     * should be inserted into a given sorted array in order to maintain the sort
>, <Line: -     * order of the array. If a callback is provided it will be executed for
>, <Line: -     * `value` and each element of `array` to compute their sort ranking. The
>, <Line: -     * callback is bound to `thisArg` and invoked with one argument; (value).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to inspect.
>, <Line: -     * @param {*} value The value to evaluate.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {number} Returns the index at which `value` should be inserted
>, <Line: -     *  into `array`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.sortedIndex([20, 30, 50], 40);
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * var dict = {
>, <Line: -     *
>, <Line: -     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
>, <Line: -     * // => 2
>, <Line: -     *
>, <Line: -     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
>, <Line: -     * // => 2
>, <Line: -     */
>, <Line: -    function sortedIndex(array, value, callback, thisArg) {
>, <Line: -      var low = 0,
>, <Line: -          high = array ? array.length : low;
>, <Line: -      // explicitly reference `identity` for better inlining in Firefox
>, <Line: -      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
>, <Line: -      value = callback(value);
>, <Line: -      while (low < high) {
>, <Line: -        var mid = (low + high) >>> 1;
>, <Line: -        (callback(array[mid]) < value)
>, <Line: -          ? low = mid + 1
>, <Line: -          : high = mid;
>, <Line: -      }
>, <Line: -      return low;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of unique values, in order, of the provided arrays using
>, <Line: -     * strict equality for comparisons, i.e. `===`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {...Array} [array] The arrays to inspect.
>, <Line: -     * @returns {Array} Returns an array of combined values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
>, <Line: -     * // => [1, 2, 3, 5, 4]
>, <Line: -     */
>, <Line: -    function union() {
>, <Line: -      return baseUniq(baseFlatten(arguments, true, true));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a duplicate-value-free version of an array using strict equality
>, <Line: -     * for comparisons, i.e. `===`. If the array is sorted, providing
>, <Line: -     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
>, <Line: -     * each element of `array` is passed through the callback before uniqueness
>, <Line: -     * is computed. The callback is bound to `thisArg` and invoked with three
>, <Line: -     * arguments; (value, index, array).
>, <Line: -     *
>, <Line: -     * If a property name is provided for `callback` the created "_.pluck" style
>, <Line: -     * callback will return the property value of the given element.
>, <Line: -     *
>, <Line: -     * If an object is provided for `callback` the created "_.where" style callback
>, <Line: -     * will return `true` for elements that have the properties of the given object,
>, <Line: -     * else `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias unique
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to process.
>, <Line: -     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
>, <Line: -     * @param {Function|Object|string} [callback=identity] The function called
>, <Line: -     *  per iteration. If a property name or object is provided it will be used
>, <Line: -     *  to create a "_.pluck" or "_.where" style callback, respectively.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns a duplicate-value-free array.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.uniq([1, 2, 1, 3, 1]);
>, <Line: -     * // => [1, 2, 3]
>, <Line: -     *
>, <Line: -     * _.uniq([1, 1, 2, 2, 3], true);
>, <Line: -     * // => [1, 2, 3]
>, <Line: -     *
>, <Line: -     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
>, <Line: -     * // => ['A', 'b', 'C']
>, <Line: -     *
>, <Line: -     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
>, <Line: -     * // => [1, 2.5, 3]
>, <Line: -     *
>, <Line: -     * // using "_.pluck" callback shorthand
>, <Line: -     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
>, <Line: -     * // => [{ 'x': 1 }, { 'x': 2 }]
>, <Line: -     */
>, <Line: -    function uniq(array, isSorted, callback, thisArg) {
>, <Line: -      // juggle arguments
>, <Line: -      if (typeof isSorted != 'boolean' && isSorted != null) {
>, <Line: -        thisArg = callback;
>, <Line: -        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
>, <Line: -        isSorted = false;
>, <Line: -      }
>, <Line: -      if (callback != null) {
>, <Line: -        callback = lodash.createCallback(callback, thisArg, 3);
>, <Line: -      }
>, <Line: -      return baseUniq(array, isSorted, callback);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array excluding all provided values using strict equality for
>, <Line: -     * comparisons, i.e. `===`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} array The array to filter.
>, <Line: -     * @param {...*} [value] The values to exclude.
>, <Line: -     * @returns {Array} Returns a new array of filtered values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
>, <Line: -     * // => [2, 3, 4]
>, <Line: -     */
>, <Line: -    function without(array) {
>, <Line: -      return baseDifference(array, slice(arguments, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array that is the symmetric difference of the provided arrays.
>, <Line: -     * See http://en.wikipedia.org/wiki/Symmetric_difference.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Arrays
>, <Line: -     * @param {...Array} [array] The arrays to inspect.
>, <Line: -     * @returns {Array} Returns an array of values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.xor([1, 2, 3], [5, 2, 1, 4]);
>, <Line: -     * // => [3, 5, 4]
>, <Line: -     *
>, <Line: -     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
>, <Line: -     * // => [1, 4, 5]
>, <Line: -     */
>, <Line: -    function xor() {
>, <Line: -      var index = -1,
>, <Line: -          length = arguments.length;
>, <Line: -      while (++index < length) {
>, <Line: -        var array = arguments[index];
>, <Line: -        if (isArray(array) || isArguments(array)) {
>, <Line: -          var result = result
>, <Line: -            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
>, <Line: -            : array;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result || [];
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an array of grouped elements, the first of which contains the first
>, <Line: -     * elements of the given arrays, the second of which contains the second
>, <Line: -     * elements of the given arrays, and so on.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias unzip
>, <Line: -     * @category Arrays
>, <Line: -     * @param {...Array} [array] Arrays to process.
>, <Line: -     * @returns {Array} Returns a new array of grouped elements.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
>, <Line: -     * // => [['fred', 30, true], ['barney', 40, false]]
>, <Line: -     */
>, <Line: -    function zip() {
>, <Line: -      var array = arguments.length > 1 ? arguments : arguments[0],
>, <Line: -          index = -1,
>, <Line: -          length = array ? max(pluck(array, 'length')) : 0,
>, <Line: -          result = Array(length < 0 ? 0 : length);
>, <Line: -      while (++index < length) {
>, <Line: -        result[index] = pluck(array, index);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates an object composed from arrays of `keys` and `values`. Provide
>, <Line: -     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
>, <Line: -     * or two arrays, one of `keys` and one of corresponding `values`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @alias object
>, <Line: -     * @category Arrays
>, <Line: -     * @param {Array} keys The array of keys.
>, <Line: -     * @param {Array} [values=[]] The array of values.
>, <Line: -     * @returns {Object} Returns an object composed of the given keys and
>, <Line: -     *  corresponding values.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.zipObject(['fred', 'barney'], [30, 40]);
>, <Line: -     * // => { 'fred': 30, 'barney': 40 }
>, <Line: -     */
>, <Line: -    function zipObject(keys, values) {
>, <Line: -      var index = -1,
>, <Line: -          length = keys ? keys.length : 0,
>, <Line: -          result = {};
>, <Line: -      if (!values && length && !isArray(keys[0])) {
>, <Line: -        values = [];
>, <Line: -      }
>, <Line: -      while (++index < length) {
>, <Line: -        var key = keys[index];
>, <Line: -        if (values) {
>, <Line: -          result[key] = values[index];
>, <Line: -        } else if (key) {
>, <Line: -          result[key[0]] = key[1];
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates a function that executes `func`, with  the `this` binding and
>, <Line: -     * arguments of the created function, only after being called `n` times.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {number} n The number of times the function must be called before
>, <Line: -     *  `func` is executed.
>, <Line: -     * @param {Function} func The function to restrict.
>, <Line: -     * @returns {Function} Returns the new restricted function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var saves = ['profile', 'settings'];
>, <Line: -     *
>, <Line: -     * var done = _.after(saves.length, function() {
>, <Line: -     *
>, <Line: -     * _.forEach(saves, function(type) {
>, <Line: -     * // => logs 'Done saving!', after all saves have completed
>, <Line: -     */
>, <Line: -    function after(n, func) {
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      return function() {
>, <Line: -        if (--n < 1) {
>, <Line: -          return func.apply(this, arguments);
>, <Line: -        }
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that, when called, invokes `func` with the `this`
>, <Line: -     * binding of `thisArg` and prepends any additional `bind` arguments to those
>, <Line: -     * provided to the bound function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to bind.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `func`.
>, <Line: -     * @param {...*} [arg] Arguments to be partially applied.
>, <Line: -     * @returns {Function} Returns the new bound function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var func = function(greeting) {
>, <Line: -     *
>, <Line: -     * func = _.bind(func, { 'name': 'fred' }, 'hi');
>, <Line: -     * func();
>, <Line: -     * // => 'hi fred'
>, <Line: -     */
>, <Line: -    function bind(func, thisArg) {
>, <Line: -      return arguments.length > 2
>, <Line: -        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
>, <Line: -        : createWrapper(func, 1, null, null, thisArg);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Binds methods of an object to the object itself, overwriting the existing
>, <Line: -     * method. Method names may be specified as individual arguments or as arrays
>, <Line: -     * of method names. If no method names are provided all the function properties
>, <Line: -     * of `object` will be bound.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Object} object The object to bind and assign the bound methods to.
>, <Line: -     * @param {...string} [methodName] The object method names to
>, <Line: -     *  bind, specified as individual method names or arrays of method names.
>, <Line: -     * @returns {Object} Returns `object`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var view = {
>, <Line: -     *
>, <Line: -     * _.bindAll(view);
>, <Line: -     * jQuery('#docs').on('click', view.onClick);
>, <Line: -     * // => logs 'clicked docs', when the button is clicked
>, <Line: -     */
>, <Line: -    function bindAll(object) {
>, <Line: -      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
>, <Line: -          index = -1,
>, <Line: -          length = funcs.length;
>, <Line: -      while (++index < length) {
>, <Line: -        var key = funcs[index];
>, <Line: -        object[key] = createWrapper(object[key], 1, null, null, object);
>, <Line: -      }
>, <Line: -      return object;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that, when called, invokes the method at `object[key]`
>, <Line: -     * and prepends any additional `bindKey` arguments to those provided to the bound
>, <Line: -     * function. This method differs from `_.bind` by allowing bound functions to
>, <Line: -     * reference methods that will be redefined or don't yet exist.
>, <Line: -     * See http://michaux.ca/articles/lazy-function-definition-pattern.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Object} object The object the method belongs to.
>, <Line: -     * @param {string} key The key of the method.
>, <Line: -     * @param {...*} [arg] Arguments to be partially applied.
>, <Line: -     * @returns {Function} Returns the new bound function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = {
>, <Line: -     *
>, <Line: -     * var func = _.bindKey(object, 'greet', 'hi');
>, <Line: -     * func();
>, <Line: -     * // => 'hi fred'
>, <Line: -     *
>, <Line: -     * object.greet = function(greeting) {
>, <Line: -     *
>, <Line: -     * func();
>, <Line: -     * // => 'hiya fred!'
>, <Line: -     */
>, <Line: -    function bindKey(object, key) {
>, <Line: -      return arguments.length > 2
>, <Line: -        ? createWrapper(key, 19, slice(arguments, 2), null, object)
>, <Line: -        : createWrapper(key, 3, null, null, object);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that is the composition of the provided functions,
>, <Line: -     * where each function consumes the return value of the function that follows.
>, <Line: -     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
>, <Line: -     * Each function is executed with the `this` binding of the composed function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {...Function} [func] Functions to compose.
>, <Line: -     * @returns {Function} Returns the new composed function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var realNameMap = {
>, <Line: -     *
>, <Line: -     * var format = function(name) {
>, <Line: -     *
>, <Line: -     * var greet = function(formatted) {
>, <Line: -     *
>, <Line: -     * var welcome = _.compose(greet, format);
>, <Line: -     * welcome('pebbles');
>, <Line: -     * // => 'Hiya Penelope!'
>, <Line: -     */
>, <Line: -    function compose() {
>, <Line: -      var funcs = arguments,
>, <Line: -          length = funcs.length;
>, <Line: -      while (length--) {
>, <Line: -        if (!isFunction(funcs[length])) {
>, <Line: -          throw new TypeError;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return function() {
>, <Line: -        var args = arguments,
>, <Line: -            length = funcs.length;
>, <Line: -        while (length--) {
>, <Line: -          args = [funcs[length].apply(this, args)];
>, <Line: -        }
>, <Line: -        return args[0];
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function which accepts one or more arguments of `func` that when
>, <Line: -     * invoked either executes `func` returning its result, if all `func` arguments
>, <Line: -     * have been provided, or returns a function that accepts one or more of the
>, <Line: -     * remaining `func` arguments, and so on. The arity of `func` can be specified
>, <Line: -     * if `func.length` is not sufficient.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to curry.
>, <Line: -     * @param {number} [arity=func.length] The arity of `func`.
>, <Line: -     * @returns {Function} Returns the new curried function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var curried = _.curry(function(a, b, c) {
>, <Line: -     *
>, <Line: -     * curried(1)(2)(3);
>, <Line: -     * // => 6
>, <Line: -     *
>, <Line: -     * curried(1, 2)(3);
>, <Line: -     * // => 6
>, <Line: -     *
>, <Line: -     * curried(1, 2, 3);
>, <Line: -     * // => 6
>, <Line: -     */
>, <Line: -    function curry(func, arity) {
>, <Line: -      arity = typeof arity == 'number' ? arity : (+arity || func.length);
>, <Line: -      return createWrapper(func, 4, null, null, null, arity);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that will delay the execution of `func` until after
>, <Line: -     * `wait` milliseconds have elapsed since the last time it was invoked.
>, <Line: -     * Provide an options object to indicate that `func` should be invoked on
>, <Line: -     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
>, <Line: -     * to the debounced function will return the result of the last `func` call.
>, <Line: -     *
>, <Line: -     * Note: If `leading` and `trailing` options are `true` `func` will be called
>, <Line: -     * on the trailing edge of the timeout only if the the debounced function is
>, <Line: -     * invoked more than once during the `wait` timeout.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to debounce.
>, <Line: -     * @param {number} wait The number of milliseconds to delay.
>, <Line: -     * @param {Object} [options] The options object.
>, <Line: -     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
>, <Line: -     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
>, <Line: -     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
>, <Line: -     * @returns {Function} Returns the new debounced function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * // avoid costly calculations while the window size is in flux
>, <Line: -     * var lazyLayout = _.debounce(calculateLayout, 150);
>, <Line: -     * jQuery(window).on('resize', lazyLayout);
>, <Line: -     *
>, <Line: -     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
>, <Line: -     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
>, <Line: -     *
>, <Line: -     * // ensure `batchLog` is executed once after 1 second of debounced calls
>, <Line: -     * var source = new EventSource('/stream');
>, <Line: -     * source.addEventListener('message', _.debounce(batchLog, 250, {
>, <Line: -     */
>, <Line: -    function debounce(func, wait, options) {
>, <Line: -      var args,
>, <Line: -          maxTimeoutId,
>, <Line: -          result,
>, <Line: -          stamp,
>, <Line: -          thisArg,
>, <Line: -          timeoutId,
>, <Line: -          trailingCall,
>, <Line: -          lastCalled = 0,
>, <Line: -          maxWait = false,
>, <Line: -          trailing = true;
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      wait = nativeMax(0, wait) || 0;
>, <Line: -      if (options === true) {
>, <Line: -        var leading = true;
>, <Line: -        trailing = false;
>, <Line: -      } else if (isObject(options)) {
>, <Line: -        leading = options.leading;
>, <Line: -        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
>, <Line: -        trailing = 'trailing' in options ? options.trailing : trailing;
>, <Line: -      }
>, <Line: -      var delayed = function() {
>, <Line: -        var remaining = wait - (now() - stamp);
>, <Line: -        if (remaining <= 0) {
>, <Line: -          if (maxTimeoutId) {
>, <Line: -            clearTimeout(maxTimeoutId);
>, <Line: -          }
>, <Line: -          var isCalled = trailingCall;
>, <Line: -          maxTimeoutId = timeoutId = trailingCall = undefined;
>, <Line: -          if (isCalled) {
>, <Line: -            lastCalled = now();
>, <Line: -            result = func.apply(thisArg, args);
>, <Line: -            if (!timeoutId && !maxTimeoutId) {
>, <Line: -              args = thisArg = null;
>, <Line: -            }
>, <Line: -          }
>, <Line: -        } else {
>, <Line: -          timeoutId = setTimeout(delayed, remaining);
>, <Line: -        }
>, <Line: -      };
>, <Line: -      var maxDelayed = function() {
>, <Line: -        if (timeoutId) {
>, <Line: -          clearTimeout(timeoutId);
>, <Line: -        }
>, <Line: -        maxTimeoutId = timeoutId = trailingCall = undefined;
>, <Line: -        if (trailing || (maxWait !== wait)) {
>, <Line: -          lastCalled = now();
>, <Line: -          result = func.apply(thisArg, args);
>, <Line: -          if (!timeoutId && !maxTimeoutId) {
>, <Line: -            args = thisArg = null;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      };
>, <Line: -      return function() {
>, <Line: -        args = arguments;
>, <Line: -        stamp = now();
>, <Line: -        thisArg = this;
>, <Line: -        trailingCall = trailing && (timeoutId || !leading);
>, <Line: -        if (maxWait === false) {
>, <Line: -          var leadingCall = leading && !timeoutId;
>, <Line: -        } else {
>, <Line: -          if (!maxTimeoutId && !leading) {
>, <Line: -            lastCalled = stamp;
>, <Line: -          }
>, <Line: -          var remaining = maxWait - (stamp - lastCalled),
>, <Line: -              isCalled = remaining <= 0;
>, <Line: -          if (isCalled) {
>, <Line: -            if (maxTimeoutId) {
>, <Line: -              maxTimeoutId = clearTimeout(maxTimeoutId);
>, <Line: -            }
>, <Line: -            lastCalled = stamp;
>, <Line: -            result = func.apply(thisArg, args);
>, <Line: -          }
>, <Line: -          else if (!maxTimeoutId) {
>, <Line: -            maxTimeoutId = setTimeout(maxDelayed, remaining);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (isCalled && timeoutId) {
>, <Line: -          timeoutId = clearTimeout(timeoutId);
>, <Line: -        }
>, <Line: -        else if (!timeoutId && wait !== maxWait) {
>, <Line: -          timeoutId = setTimeout(delayed, wait);
>, <Line: -        }
>, <Line: -        if (leadingCall) {
>, <Line: -          isCalled = true;
>, <Line: -          result = func.apply(thisArg, args);
>, <Line: -        }
>, <Line: -        if (isCalled && !timeoutId && !maxTimeoutId) {
>, <Line: -          args = thisArg = null;
>, <Line: -        }
>, <Line: -        return result;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Defers executing the `func` function until the current call stack has cleared.
>, <Line: -     * Additional arguments will be provided to `func` when it is invoked.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to defer.
>, <Line: -     * @param {...*} [arg] Arguments to invoke the function with.
>, <Line: -     * @returns {number} Returns the timer id.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.defer(function(text) { console.log(text); }, 'deferred');
>, <Line: -     * // logs 'deferred' after one or more milliseconds
>, <Line: -     */
>, <Line: -    function defer(func) {
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      var args = slice(arguments, 1);
>, <Line: -      return setTimeout(function() { func.apply(undefined, args); }, 1);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Executes the `func` function after `wait` milliseconds. Additional arguments
>, <Line: -     * will be provided to `func` when it is invoked.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to delay.
>, <Line: -     * @param {number} wait The number of milliseconds to delay execution.
>, <Line: -     * @param {...*} [arg] Arguments to invoke the function with.
>, <Line: -     * @returns {number} Returns the timer id.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.delay(function(text) { console.log(text); }, 1000, 'later');
>, <Line: -     * // => logs 'later' after one second
>, <Line: -     */
>, <Line: -    function delay(func, wait) {
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      var args = slice(arguments, 2);
>, <Line: -      return setTimeout(function() { func.apply(undefined, args); }, wait);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that memoizes the result of `func`. If `resolver` is
>, <Line: -     * provided it will be used to determine the cache key for storing the result
>, <Line: -     * based on the arguments provided to the memoized function. By default, the
>, <Line: -     * first argument provided to the memoized function is used as the cache key.
>, <Line: -     * The `func` is executed with the `this` binding of the memoized function.
>, <Line: -     * The result cache is exposed as the `cache` property on the memoized function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to have its output memoized.
>, <Line: -     * @param {Function} [resolver] A function used to resolve the cache key.
>, <Line: -     * @returns {Function} Returns the new memoizing function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var fibonacci = _.memoize(function(n) {
>, <Line: -     *
>, <Line: -     * fibonacci(9)
>, <Line: -     * // => 34
>, <Line: -     *
>, <Line: -     * var data = {
>, <Line: -     *
>, <Line: -     * // modifying the result cache
>, <Line: -     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
>, <Line: -     * get('pebbles');
>, <Line: -     * // => { 'name': 'pebbles', 'age': 1 }
>, <Line: -     *
>, <Line: -     * get.cache.pebbles.name = 'penelope';
>, <Line: -     * get('pebbles');
>, <Line: -     * // => { 'name': 'penelope', 'age': 1 }
>, <Line: -     */
>, <Line: -    function memoize(func, resolver) {
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      var memoized = function() {
>, <Line: -        var cache = memoized.cache,
>, <Line: -            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
>, <Line: -        return hasOwnProperty.call(cache, key)
>, <Line: -          ? cache[key]
>, <Line: -          : (cache[key] = func.apply(this, arguments));
>, <Line: -      }
>, <Line: -      memoized.cache = {};
>, <Line: -      return memoized;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that is restricted to execute `func` once. Repeat calls to
>, <Line: -     * the function will return the value of the first call. The `func` is executed
>, <Line: -     * with the `this` binding of the created function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to restrict.
>, <Line: -     * @returns {Function} Returns the new restricted function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var initialize = _.once(createApplication);
>, <Line: -     * initialize();
>, <Line: -     * initialize();
>, <Line: -     * // `initialize` executes `createApplication` once
>, <Line: -     */
>, <Line: -    function once(func) {
>, <Line: -      var ran,
>, <Line: -          result;
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      return function() {
>, <Line: -        if (ran) {
>, <Line: -          return result;
>, <Line: -        }
>, <Line: -        ran = true;
>, <Line: -        result = func.apply(this, arguments);
>, <Line: -        // clear the `func` variable so the function may be garbage collected
>, <Line: -        func = null;
>, <Line: -        return result;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that, when called, invokes `func` with any additional
>, <Line: -     * `partial` arguments prepended to those provided to the new function. This
>, <Line: -     * method is similar to `_.bind` except it does **not** alter the `this` binding.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to partially apply arguments to.
>, <Line: -     * @param {...*} [arg] Arguments to be partially applied.
>, <Line: -     * @returns {Function} Returns the new partially applied function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var greet = function(greeting, name) { return greeting + ' ' + name; };
>, <Line: -     * var hi = _.partial(greet, 'hi');
>, <Line: -     * hi('fred');
>, <Line: -     * // => 'hi fred'
>, <Line: -     */
>, <Line: -    function partial(func) {
>, <Line: -      return createWrapper(func, 16, slice(arguments, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method is like `_.partial` except that `partial` arguments are
>, <Line: -     * appended to those provided to the new function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to partially apply arguments to.
>, <Line: -     * @param {...*} [arg] Arguments to be partially applied.
>, <Line: -     * @returns {Function} Returns the new partially applied function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
>, <Line: -     *
>, <Line: -     * var options = {
>, <Line: -     *
>, <Line: -     * defaultsDeep(options, _.templateSettings);
>, <Line: -     *
>, <Line: -     * options.variable
>, <Line: -     * // => 'data'
>, <Line: -     *
>, <Line: -     * options.imports
>, <Line: -     * // => { '_': _, 'jq': $ }
>, <Line: -     */
>, <Line: -    function partialRight(func) {
>, <Line: -      return createWrapper(func, 32, null, slice(arguments, 1));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that, when executed, will only call the `func` function
>, <Line: -     * at most once per every `wait` milliseconds. Provide an options object to
>, <Line: -     * indicate that `func` should be invoked on the leading and/or trailing edge
>, <Line: -     * of the `wait` timeout. Subsequent calls to the throttled function will
>, <Line: -     * return the result of the last `func` call.
>, <Line: -     *
>, <Line: -     * Note: If `leading` and `trailing` options are `true` `func` will be called
>, <Line: -     * on the trailing edge of the timeout only if the the throttled function is
>, <Line: -     * invoked more than once during the `wait` timeout.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {Function} func The function to throttle.
>, <Line: -     * @param {number} wait The number of milliseconds to throttle executions to.
>, <Line: -     * @param {Object} [options] The options object.
>, <Line: -     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
>, <Line: -     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
>, <Line: -     * @returns {Function} Returns the new throttled function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * // avoid excessively updating the position while scrolling
>, <Line: -     * var throttled = _.throttle(updatePosition, 100);
>, <Line: -     * jQuery(window).on('scroll', throttled);
>, <Line: -     *
>, <Line: -     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
>, <Line: -     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
>, <Line: -     */
>, <Line: -    function throttle(func, wait, options) {
>, <Line: -      var leading = true,
>, <Line: -          trailing = true;
>, <Line: -      if (!isFunction(func)) {
>, <Line: -        throw new TypeError;
>, <Line: -      }
>, <Line: -      if (options === false) {
>, <Line: -        leading = false;
>, <Line: -      } else if (isObject(options)) {
>, <Line: -        leading = 'leading' in options ? options.leading : leading;
>, <Line: -        trailing = 'trailing' in options ? options.trailing : trailing;
>, <Line: -      }
>, <Line: -      debounceOptions.leading = leading;
>, <Line: -      debounceOptions.maxWait = wait;
>, <Line: -      debounceOptions.trailing = trailing;
>, <Line: -      return debounce(func, wait, debounceOptions);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Creates a function that provides `value` to the wrapper function as its
>, <Line: -     * first argument. Additional arguments provided to the function are appended
>, <Line: -     * to those provided to the wrapper function. The wrapper is executed with
>, <Line: -     * the `this` binding of the created function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Functions
>, <Line: -     * @param {*} value The value to wrap.
>, <Line: -     * @param {Function} wrapper The wrapper function.
>, <Line: -     * @returns {Function} Returns the new function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var p = _.wrap(_.escape, function(func, text) {
>, <Line: -     *
>, <Line: -     * p('Fred, Wilma, & Pebbles');
>, <Line: -     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
>, <Line: -     */
>, <Line: -    function wrap(value, wrapper) {
>, <Line: -      return createWrapper(wrapper, 16, [value]);
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates a function that returns `value`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {*} value The value to return from the new function.
>, <Line: -     * @returns {Function} Returns the new function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'fred' };
>, <Line: -     * var getter = _.constant(object);
>, <Line: -     * getter() === object;
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function constant(value) {
>, <Line: -      return function() {
>, <Line: -        return value;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Produces a callback bound to an optional `thisArg`. If `func` is a property
>, <Line: -     * name the created callback will return the property value for a given element.
>, <Line: -     * If `func` is an object the created callback will return `true` for elements
>, <Line: -     * that contain the equivalent object properties, otherwise it will return `false`.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {*} [func=identity] The value to convert to a callback.
>, <Line: -     * @param {*} [thisArg] The `this` binding of the created callback.
>, <Line: -     * @param {number} [argCount] The number of arguments the callback accepts.
>, <Line: -     * @returns {Function} Returns a callback function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // wrap to create custom callback shorthands
>, <Line: -     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
>, <Line: -     *
>, <Line: -     * _.filter(characters, 'age__gt38');
>, <Line: -     * // => [{ 'name': 'fred', 'age': 40 }]
>, <Line: -     */
>, <Line: -    function createCallback(func, thisArg, argCount) {
>, <Line: -      var type = typeof func;
>, <Line: -      if (func == null || type == 'function') {
>, <Line: -        return baseCreateCallback(func, thisArg, argCount);
>, <Line: -      }
>, <Line: -      // handle "_.pluck" style callback shorthands
>, <Line: -      if (type != 'object') {
>, <Line: -        return property(func);
>, <Line: -      }
>, <Line: -      var props = keys(func),
>, <Line: -          key = props[0],
>, <Line: -          a = func[key];
>, <Line: -      // handle "_.where" style callback shorthands
>, <Line: -      if (props.length == 1 && a === a && !isObject(a)) {
>, <Line: -        // fast path the common case of providing an object with a single
>, <Line: -        // property containing a primitive value
>, <Line: -        return function(object) {
>, <Line: -          var b = object[key];
>, <Line: -          return a === b && (a !== 0 || (1 / a == 1 / b));
>, <Line: -        };
>, <Line: -      }
>, <Line: -      return function(object) {
>, <Line: -        var length = props.length,
>, <Line: -            result = false;
>, <Line: -        while (length--) {
>, <Line: -          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        return result;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
>, <Line: -     * corresponding HTML entities.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} string The string to escape.
>, <Line: -     * @returns {string} Returns the escaped string.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.escape('Fred, Wilma, & Pebbles');
>, <Line: -     * // => 'Fred, Wilma, &amp; Pebbles'
>, <Line: -     */
>, <Line: -    function escape(string) {
>, <Line: -      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This method returns the first argument provided to it.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {*} value Any value.
>, <Line: -     * @returns {*} Returns `value`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'fred' };
>, <Line: -     * _.identity(object) === object;
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function identity(value) {
>, <Line: -      return value;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Adds function properties of a source object to the destination object.
>, <Line: -     * If `object` is a function methods will be added to its prototype as well.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {Function|Object} [object=lodash] object The destination object.
>, <Line: -     * @param {Object} source The object of functions to add.
>, <Line: -     * @param {Object} [options] The options object.
>, <Line: -     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * function capitalize(string) {
>, <Line: -     *
>, <Line: -     * _.mixin({ 'capitalize': capitalize });
>, <Line: -     * _.capitalize('fred');
>, <Line: -     * // => 'Fred'
>, <Line: -     *
>, <Line: -     * _('fred').capitalize().value();
>, <Line: -     * // => 'Fred'
>, <Line: -     *
>, <Line: -     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
>, <Line: -     * _('fred').capitalize();
>, <Line: -     * // => 'Fred'
>, <Line: -     */
>, <Line: -    function mixin(object, source, options) {
>, <Line: -      var chain = true,
>, <Line: -          methodNames = source && functions(source);
>, <Line: -      if (!source || (!options && !methodNames.length)) {
>, <Line: -        if (options == null) {
>, <Line: -          options = source;
>, <Line: -        }
>, <Line: -        ctor = lodashWrapper;
>, <Line: -        source = object;
>, <Line: -        object = lodash;
>, <Line: -        methodNames = functions(source);
>, <Line: -      }
>, <Line: -      if (options === false) {
>, <Line: -        chain = false;
>, <Line: -      } else if (isObject(options) && 'chain' in options) {
>, <Line: -        chain = options.chain;
>, <Line: -      }
>, <Line: -      var ctor = object,
>, <Line: -          isFunc = isFunction(ctor);
>, <Line: -      forEach(methodNames, function(methodName) {
>, <Line: -        var func = object[methodName] = source[methodName];
>, <Line: -        if (isFunc) {
>, <Line: -          ctor.prototype[methodName] = function() {
>, <Line: -            var chainAll = this.__chain__,
>, <Line: -                value = this.__wrapped__,
>, <Line: -                args = [value];
>, <Line: -            push.apply(args, arguments);
>, <Line: -            var result = func.apply(object, args);
>, <Line: -            if (chain || chainAll) {
>, <Line: -              if (value === result && isObject(result)) {
>, <Line: -                return this;
>, <Line: -              }
>, <Line: -              result = new ctor(result);
>, <Line: -              result.__chain__ = chainAll;
>, <Line: -            }
>, <Line: -            return result;
>, <Line: -          };
>, <Line: -        }
>, <Line: -      });
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Reverts the '_' variable to its previous value and returns a reference to
>, <Line: -     * the `lodash` function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @returns {Function} Returns the `lodash` function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var lodash = _.noConflict();
>, <Line: -     */
>, <Line: -    function noConflict() {
>, <Line: -      context._ = oldDash;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * A no-operation function.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = { 'name': 'fred' };
>, <Line: -     * _.noop(object) === undefined;
>, <Line: -     * // => true
>, <Line: -     */
>, <Line: -    function noop() {
>, <Line: -      // no operation performed
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Gets the number of milliseconds that have elapsed since the Unix epoch
>, <Line: -     * (1 January 1970 00:00:00 UTC).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var stamp = _.now();
>, <Line: -     * _.defer(function() { console.log(_.now() - stamp); });
>, <Line: -     * // => logs the number of milliseconds it took for the deferred function to be called
>, <Line: -     */
>, <Line: -    var now = isNative(now = Date.now) && now || function() {
>, <Line: -      return new Date().getTime();
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Converts the given value into an integer of the specified radix.
>, <Line: -     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
>, <Line: -     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
>, <Line: -     *
>, <Line: -     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
>, <Line: -     * implementations. See http://es5.github.io/#E.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} value The value to parse.
>, <Line: -     * @param {number} [radix] The radix used to interpret the value to parse.
>, <Line: -     * @returns {number} Returns the new integer value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.parseInt('08');
>, <Line: -     * // => 8
>, <Line: -     */
>, <Line: -    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
>, <Line: -      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
>, <Line: -      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * Creates a "_.pluck" style function, which returns the `key` value of a
>, <Line: -     * given object.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} key The name of the property to retrieve.
>, <Line: -     * @returns {Function} Returns the new function.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'fred',   'age': 40 },
>, <Line: -     *   { 'name': 'barney', 'age': 36 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * var getName = _.property('name');
>, <Line: -     *
>, <Line: -     * _.map(characters, getName);
>, <Line: -     * // => ['barney', 'fred']
>, <Line: -     *
>, <Line: -     * _.sortBy(characters, getName);
>, <Line: -     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
>, <Line: -     */
>, <Line: -    function property(key) {
>, <Line: -      return function(object) {
>, <Line: -        return object[key];
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Produces a random number between `min` and `max` (inclusive). If only one
>, <Line: -     * argument is provided a number between `0` and the given number will be
>, <Line: -     * returned. If `floating` is truey or either `min` or `max` are floats a
>, <Line: -     * floating-point number will be returned instead of an integer.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {number} [min=0] The minimum possible value.
>, <Line: -     * @param {number} [max=1] The maximum possible value.
>, <Line: -     * @param {boolean} [floating=false] Specify returning a floating-point number.
>, <Line: -     * @returns {number} Returns a random number.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.random(0, 5);
>, <Line: -     * // => an integer between 0 and 5
>, <Line: -     *
>, <Line: -     * _.random(5);
>, <Line: -     * // => also an integer between 0 and 5
>, <Line: -     *
>, <Line: -     * _.random(5, true);
>, <Line: -     * // => a floating-point number between 0 and 5
>, <Line: -     *
>, <Line: -     * _.random(1.2, 5.2);
>, <Line: -     * // => a floating-point number between 1.2 and 5.2
>, <Line: -     */
>, <Line: -    function random(min, max, floating) {
>, <Line: -      var noMin = min == null,
>, <Line: -          noMax = max == null;
>, <Line: -      if (floating == null) {
>, <Line: -        if (typeof min == 'boolean' && noMax) {
>, <Line: -          floating = min;
>, <Line: -          min = 1;
>, <Line: -        }
>, <Line: -        else if (!noMax && typeof max == 'boolean') {
>, <Line: -          floating = max;
>, <Line: -          noMax = true;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (noMin && noMax) {
>, <Line: -        max = 1;
>, <Line: -      }
>, <Line: -      min = +min || 0;
>, <Line: -      if (noMax) {
>, <Line: -        max = min;
>, <Line: -        min = 0;
>, <Line: -      } else {
>, <Line: -        max = +max || 0;
>, <Line: -      }
>, <Line: -      if (floating || min % 1 || max % 1) {
>, <Line: -        var rand = nativeRandom();
>, <Line: -        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
>, <Line: -      }
>, <Line: -      return baseRandom(min, max);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Resolves the value of property `key` on `object`. If `key` is a function
>, <Line: -     * it will be invoked with the `this` binding of `object` and its result returned,
>, <Line: -     * else the property value is returned. If `object` is falsey then `undefined`
>, <Line: -     * is returned.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {Object} object The object to inspect.
>, <Line: -     * @param {string} key The name of the property to resolve.
>, <Line: -     * @returns {*} Returns the resolved value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var object = {
>, <Line: -     *
>, <Line: -     * _.result(object, 'cheese');
>, <Line: -     * // => 'crumpets'
>, <Line: -     *
>, <Line: -     * _.result(object, 'stuff');
>, <Line: -     * // => 'nonsense'
>, <Line: -     */
>, <Line: -    function result(object, key) {
>, <Line: -      if (object) {
>, <Line: -        var value = object[key];
>, <Line: -        return isFunction(value) ? object[key]() : value;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * A micro-templating method that handles arbitrary delimiters, preserves
>, <Line: -     * whitespace, and correctly escapes quotes within interpolated code.
>, <Line: -     *
>, <Line: -     * Note: In the development build, `_.template` utilizes sourceURLs for easier
>, <Line: -     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
>, <Line: -     *
>, <Line: -     * For more information on precompiling templates see:
>, <Line: -     * http://lodash.com/custom-builds
>, <Line: -     *
>, <Line: -     * For more information on Chrome extension sandboxes see:
>, <Line: -     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} text The template text.
>, <Line: -     * @param {Object} data The data object used to populate the text.
>, <Line: -     * @param {Object} [options] The options object.
>, <Line: -     * @param {RegExp} [options.escape] The "escape" delimiter.
>, <Line: -     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
>, <Line: -     * @param {Object} [options.imports] An object to import into the template as local variables.
>, <Line: -     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
>, <Line: -     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
>, <Line: -     * @param {string} [variable] The data object variable name.
>, <Line: -     * @returns {Function|string} Returns a compiled function when no `data` object
>, <Line: -     *  is given, else it returns the interpolated text.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * // using the "interpolate" delimiter to create a compiled template
>, <Line: -     * var compiled = _.template('hello <%= name %>');
>, <Line: -     * compiled({ 'name': 'fred' });
>, <Line: -     * // => 'hello fred'
>, <Line: -     *
>, <Line: -     * // using the "escape" delimiter to escape HTML in data property values
>, <Line: -     * _.template('<b><%- value %></b>', { 'value': '<script>' });
>, <Line: -     * // => '<b>&lt;script&gt;</b>'
>, <Line: -     *
>, <Line: -     * // using the "evaluate" delimiter to generate HTML
>, <Line: -     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
>, <Line: -     * _.template(list, { 'people': ['fred', 'barney'] });
>, <Line: -     * // => '<li>fred</li><li>barney</li>'
>, <Line: -     *
>, <Line: -     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
>, <Line: -     * _.template('hello ${ name }', { 'name': 'pebbles' });
>, <Line: -     * // => 'hello pebbles'
>, <Line: -     *
>, <Line: -     * // using the internal `print` function in "evaluate" delimiters
>, <Line: -     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
>, <Line: -     * // => 'hello barney!'
>, <Line: -     *
>, <Line: -     * // using a custom template delimiters
>, <Line: -     * _.templateSettings = {
>, <Line: -     *
>, <Line: -     * _.template('hello {{ name }}!', { 'name': 'mustache' });
>, <Line: -     * // => 'hello mustache!'
>, <Line: -     *
>, <Line: -     * // using the `imports` option to import jQuery
>, <Line: -     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
>, <Line: -     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
>, <Line: -     * // => '<li>fred</li><li>barney</li>'
>, <Line: -     *
>, <Line: -     * // using the `sourceURL` option to specify a custom sourceURL for the template
>, <Line: -     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
>, <Line: -     * compiled(data);
>, <Line: -     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
>, <Line: -     *
>, <Line: -     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
>, <Line: -     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
>, <Line: -     * compiled.source;
>, <Line: -     * // => function(data) {
>, <Line: -     *
>, <Line: -     * // using the `source` property to inline compiled templates for meaningful
>, <Line: -     * // line numbers in error messages and a stack trace
>, <Line: -     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
>, <Line: -     *   var JST = {\
>, <Line: -     * ');
>, <Line: -     */
>, <Line: -    function template(text, data, options) {
>, <Line: -      // based on John Resig's `tmpl` implementation
>, <Line: -      // http://ejohn.org/blog/javascript-micro-templating/
>, <Line: -      // and Laura Doktorova's doT.js
>, <Line: -      // https://github.com/olado/doT
>, <Line: -      var settings = lodash.templateSettings;
>, <Line: -      text = String(text || '');
>, <Line: -      // avoid missing dependencies when `iteratorTemplate` is not defined
>, <Line: -      options = defaults({}, options, settings);
>, <Line: -      var imports = defaults({}, options.imports, settings.imports),
>, <Line: -          importsKeys = keys(imports),
>, <Line: -          importsValues = values(imports);
>, <Line: -      var isEvaluating,
>, <Line: -          index = 0,
>, <Line: -          interpolate = options.interpolate || reNoMatch,
>, <Line: -          source = "__p += '";
>, <Line: -      // compile the regexp to match each delimiter
>, <Line: -      var reDelimiters = RegExp(
>, <Line: -        (options.escape || reNoMatch).source + '|' +
>, <Line: -        interpolate.source + '|' +
>, <Line: -        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
>, <Line: -        (options.evaluate || reNoMatch).source + '|$'
>, <Line: -      , 'g');
>, <Line: -      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
>, <Line: -        interpolateValue || (interpolateValue = esTemplateValue);
>, <Line: -        // escape characters that cannot be included in string literals
>, <Line: -        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
>, <Line: -        // replace delimiters with snippets
>, <Line: -        if (escapeValue) {
>, <Line: -          source += "' +\n__e(" + escapeValue + ") +\n'";
>, <Line: -        }
>, <Line: -        if (evaluateValue) {
>, <Line: -          isEvaluating = true;
>, <Line: -          source += "';\n" + evaluateValue + ";\n__p += '";
>, <Line: -        }
>, <Line: -        if (interpolateValue) {
>, <Line: -          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
>, <Line: -        }
>, <Line: -        index = offset + match.length;
>, <Line: -        // the JS engine embedded in Adobe products requires returning the `match`
>, <Line: -        // string in order to produce the correct `offset` value
>, <Line: -        return match;
>, <Line: -      });
>, <Line: -      source += "';\n";
>, <Line: -      // if `variable` is not specified, wrap a with-statement around the generated
>, <Line: -      // code to add the data object to the top of the scope chain
>, <Line: -      var variable = options.variable,
>, <Line: -          hasVariable = variable;
>, <Line: -      if (!hasVariable) {
>, <Line: -        variable = 'obj';
>, <Line: -        source = 'with (' + variable + ') {\n' + source + '\n}\n';
>, <Line: -      }
>, <Line: -      // cleanup code by stripping empty strings
>, <Line: -      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
>, <Line: -        .replace(reEmptyStringMiddle, '$1')
>, <Line: -        .replace(reEmptyStringTrailing, '$1;');
>, <Line: -      // frame code as the function body
>, <Line: -      source = 'function(' + variable + ') {\n' +
>, <Line: -        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
>, <Line: -        "var __t, __p = '', __e = _.escape" +
>, <Line: -        (isEvaluating
>, <Line: -          ? ', __j = Array.prototype.join;\n' +
>, <Line: -            "function print() { __p += __j.call(arguments, '') }\n"
>, <Line: -          : ';\n'
>, <Line: -        ) +
>, <Line: -        source +
>, <Line: -        'return __p\n}';
>, <Line: -      // Use a sourceURL for easier debugging.
>, <Line: -      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
>, <Line: -      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
>, <Line: -      try {
>, <Line: -        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
>, <Line: -      } catch(e) {
>, <Line: -        e.source = source;
>, <Line: -        throw e;
>, <Line: -      }
>, <Line: -      if (data) {
>, <Line: -        return result(data);
>, <Line: -      }
>, <Line: -      // provide the compiled function's source by its `toString` method, in
>, <Line: -      // supported environments, or the `source` property as a convenience for
>, <Line: -      // inlining compiled templates during the build process
>, <Line: -      result.source = source;
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Executes the callback `n` times, returning an array of the results
>, <Line: -     * of each callback execution. The callback is bound to `thisArg` and invoked
>, <Line: -     * with one argument; (index).
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {number} n The number of times to execute the callback.
>, <Line: -     * @param {Function} callback The function called per iteration.
>, <Line: -     * @param {*} [thisArg] The `this` binding of `callback`.
>, <Line: -     * @returns {Array} Returns an array of the results of each `callback` execution.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
>, <Line: -     * // => [3, 6, 4]
>, <Line: -     *
>, <Line: -     * _.times(3, function(n) { mage.castSpell(n); });
>, <Line: -     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
>, <Line: -     *
>, <Line: -     * _.times(3, function(n) { this.cast(n); }, mage);
>, <Line: -     * // => also calls `mage.castSpell(n)` three times
>, <Line: -     */
>, <Line: -    function times(n, callback, thisArg) {
>, <Line: -      n = (n = +n) > -1 ? n : 0;
>, <Line: -      var index = -1,
>, <Line: -          result = Array(n);
>, <Line: -      callback = baseCreateCallback(callback, thisArg, 1);
>, <Line: -      while (++index < n) {
>, <Line: -        result[index] = callback(index);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * The inverse of `_.escape` this method converts the HTML entities
>, <Line: -     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
>, <Line: -     * corresponding characters.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} string The string to unescape.
>, <Line: -     * @returns {string} Returns the unescaped string.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.unescape('Fred, Barney &amp; Pebbles');
>, <Line: -     * // => 'Fred, Barney & Pebbles'
>, <Line: -     */
>, <Line: -    function unescape(string) {
>, <Line: -      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Utilities
>, <Line: -     * @param {string} [prefix] The value to prefix the ID with.
>, <Line: -     * @returns {string} Returns the unique ID.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _.uniqueId('contact_');
>, <Line: -     * // => 'contact_104'
>, <Line: -     *
>, <Line: -     * _.uniqueId();
>, <Line: -     * // => '105'
>, <Line: -     */
>, <Line: -    function uniqueId(prefix) {
>, <Line: -      var id = ++idCounter;
>, <Line: -      return String(prefix == null ? '' : prefix) + id;
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * Creates a `lodash` object that wraps the given value with explicit
>, <Line: -     * method chaining enabled.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Chaining
>, <Line: -     * @param {*} value The value to wrap.
>, <Line: -     * @returns {Object} Returns the wrapper object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney',  'age': 36 },
>, <Line: -     *   { 'name': 'fred',    'age': 40 },
>, <Line: -     *   { 'name': 'pebbles', 'age': 1 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * var youngest = _.chain(characters)
>, <Line: -     *     .sortBy('age')
>, <Line: -     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
>, <Line: -     *     .first()
>, <Line: -     *     .value();
>, <Line: -     * // => 'pebbles is 1'
>, <Line: -     */
>, <Line: -    function chain(value) {
>, <Line: -      value = new lodashWrapper(value);
>, <Line: -      value.__chain__ = true;
>, <Line: -      return value;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Invokes `interceptor` with the `value` as the first argument and then
>, <Line: -     * returns `value`. The purpose of this method is to "tap into" a method
>, <Line: -     * chain in order to perform operations on intermediate results within
>, <Line: -     * the chain.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @category Chaining
>, <Line: -     * @param {*} value The value to provide to `interceptor`.
>, <Line: -     * @param {Function} interceptor The function to invoke.
>, <Line: -     * @returns {*} Returns `value`.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _([1, 2, 3, 4])
>, <Line: -     *  .tap(function(array) { array.pop(); })
>, <Line: -     *  .reverse()
>, <Line: -     *  .value();
>, <Line: -     * // => [3, 2, 1]
>, <Line: -     */
>, <Line: -    function tap(value, interceptor) {
>, <Line: -      interceptor(value);
>, <Line: -      return value;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Enables explicit method chaining on the wrapper object.
>, <Line: -     *
>, <Line: -     * @name chain
>, <Line: -     * @memberOf _
>, <Line: -     * @category Chaining
>, <Line: -     * @returns {*} Returns the wrapper object.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * var characters = [
>, <Line: -     *   { 'name': 'barney', 'age': 36 },
>, <Line: -     *   { 'name': 'fred',   'age': 40 }
>, <Line: -     * ];
>, <Line: -     *
>, <Line: -     * // without explicit chaining
>, <Line: -     * _(characters).first();
>, <Line: -     * // => { 'name': 'barney', 'age': 36 }
>, <Line: -     *
>, <Line: -     * // with explicit chaining
>, <Line: -     * _(characters).chain()
>, <Line: -     *   .first()
>, <Line: -     *   .pick('age')
>, <Line: -     *   .value();
>, <Line: -     * // => { 'age': 36 }
>, <Line: -     */
>, <Line: -    function wrapperChain() {
>, <Line: -      this.__chain__ = true;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Produces the `toString` result of the wrapped value.
>, <Line: -     *
>, <Line: -     * @name toString
>, <Line: -     * @memberOf _
>, <Line: -     * @category Chaining
>, <Line: -     * @returns {string} Returns the string result.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _([1, 2, 3]).toString();
>, <Line: -     * // => '1,2,3'
>, <Line: -     */
>, <Line: -    function wrapperToString() {
>, <Line: -      return String(this.__wrapped__);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Extracts the wrapped value.
>, <Line: -     *
>, <Line: -     * @name valueOf
>, <Line: -     * @memberOf _
>, <Line: -     * @alias value
>, <Line: -     * @category Chaining
>, <Line: -     * @returns {*} Returns the wrapped value.
>, <Line: -     * @example
>, <Line: -     *
>, <Line: -     * _([1, 2, 3]).valueOf();
>, <Line: -     * // => [1, 2, 3]
>, <Line: -     */
>, <Line: -    function wrapperValueOf() {
>, <Line: -      return this.__wrapped__;
>, <Line: -    }
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    // add functions that return wrapped values when chaining
>, <Line: -    lodash.after = after;
>, <Line: -    lodash.assign = assign;
>, <Line: -    lodash.at = at;
>, <Line: -    lodash.bind = bind;
>, <Line: -    lodash.bindAll = bindAll;
>, <Line: -    lodash.bindKey = bindKey;
>, <Line: -    lodash.chain = chain;
>, <Line: -    lodash.compact = compact;
>, <Line: -    lodash.compose = compose;
>, <Line: -    lodash.constant = constant;
>, <Line: -    lodash.countBy = countBy;
>, <Line: -    lodash.create = create;
>, <Line: -    lodash.createCallback = createCallback;
>, <Line: -    lodash.curry = curry;
>, <Line: -    lodash.debounce = debounce;
>, <Line: -    lodash.defaults = defaults;
>, <Line: -    lodash.defer = defer;
>, <Line: -    lodash.delay = delay;
>, <Line: -    lodash.difference = difference;
>, <Line: -    lodash.filter = filter;
>, <Line: -    lodash.flatten = flatten;
>, <Line: -    lodash.forEach = forEach;
>, <Line: -    lodash.forEachRight = forEachRight;
>, <Line: -    lodash.forIn = forIn;
>, <Line: -    lodash.forInRight = forInRight;
>, <Line: -    lodash.forOwn = forOwn;
>, <Line: -    lodash.forOwnRight = forOwnRight;
>, <Line: -    lodash.functions = functions;
>, <Line: -    lodash.groupBy = groupBy;
>, <Line: -    lodash.indexBy = indexBy;
>, <Line: -    lodash.initial = initial;
>, <Line: -    lodash.intersection = intersection;
>, <Line: -    lodash.invert = invert;
>, <Line: -    lodash.invoke = invoke;
>, <Line: -    lodash.keys = keys;
>, <Line: -    lodash.map = map;
>, <Line: -    lodash.mapValues = mapValues;
>, <Line: -    lodash.max = max;
>, <Line: -    lodash.memoize = memoize;
>, <Line: -    lodash.merge = merge;
>, <Line: -    lodash.min = min;
>, <Line: -    lodash.omit = omit;
>, <Line: -    lodash.once = once;
>, <Line: -    lodash.pairs = pairs;
>, <Line: -    lodash.partial = partial;
>, <Line: -    lodash.partialRight = partialRight;
>, <Line: -    lodash.pick = pick;
>, <Line: -    lodash.pluck = pluck;
>, <Line: -    lodash.property = property;
>, <Line: -    lodash.pull = pull;
>, <Line: -    lodash.range = range;
>, <Line: -    lodash.reject = reject;
>, <Line: -    lodash.remove = remove;
>, <Line: -    lodash.rest = rest;
>, <Line: -    lodash.shuffle = shuffle;
>, <Line: -    lodash.sortBy = sortBy;
>, <Line: -    lodash.tap = tap;
>, <Line: -    lodash.throttle = throttle;
>, <Line: -    lodash.times = times;
>, <Line: -    lodash.toArray = toArray;
>, <Line: -    lodash.transform = transform;
>, <Line: -    lodash.union = union;
>, <Line: -    lodash.uniq = uniq;
>, <Line: -    lodash.values = values;
>, <Line: -    lodash.where = where;
>, <Line: -    lodash.without = without;
>, <Line: -    lodash.wrap = wrap;
>, <Line: -    lodash.xor = xor;
>, <Line: -    lodash.zip = zip;
>, <Line: -    lodash.zipObject = zipObject;
>, <Line: -    // add aliases
>, <Line: -    lodash.collect = map;
>, <Line: -    lodash.drop = rest;
>, <Line: -    lodash.each = forEach;
>, <Line: -    lodash.eachRight = forEachRight;
>, <Line: -    lodash.extend = assign;
>, <Line: -    lodash.methods = functions;
>, <Line: -    lodash.object = zipObject;
>, <Line: -    lodash.select = filter;
>, <Line: -    lodash.tail = rest;
>, <Line: -    lodash.unique = uniq;
>, <Line: -    lodash.unzip = zip;
>, <Line: -    // add functions to `lodash.prototype`
>, <Line: -    mixin(lodash);
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    // add functions that return unwrapped values when chaining
>, <Line: -    lodash.clone = clone;
>, <Line: -    lodash.cloneDeep = cloneDeep;
>, <Line: -    lodash.contains = contains;
>, <Line: -    lodash.escape = escape;
>, <Line: -    lodash.every = every;
>, <Line: -    lodash.find = find;
>, <Line: -    lodash.findIndex = findIndex;
>, <Line: -    lodash.findKey = findKey;
>, <Line: -    lodash.findLast = findLast;
>, <Line: -    lodash.findLastIndex = findLastIndex;
>, <Line: -    lodash.findLastKey = findLastKey;
>, <Line: -    lodash.has = has;
>, <Line: -    lodash.identity = identity;
>, <Line: -    lodash.indexOf = indexOf;
>, <Line: -    lodash.isArguments = isArguments;
>, <Line: -    lodash.isArray = isArray;
>, <Line: -    lodash.isBoolean = isBoolean;
>, <Line: -    lodash.isDate = isDate;
>, <Line: -    lodash.isElement = isElement;
>, <Line: -    lodash.isEmpty = isEmpty;
>, <Line: -    lodash.isEqual = isEqual;
>, <Line: -    lodash.isFinite = isFinite;
>, <Line: -    lodash.isFunction = isFunction;
>, <Line: -    lodash.isNaN = isNaN;
>, <Line: -    lodash.isNull = isNull;
>, <Line: -    lodash.isNumber = isNumber;
>, <Line: -    lodash.isObject = isObject;
>, <Line: -    lodash.isPlainObject = isPlainObject;
>, <Line: -    lodash.isRegExp = isRegExp;
>, <Line: -    lodash.isString = isString;
>, <Line: -    lodash.isUndefined = isUndefined;
>, <Line: -    lodash.lastIndexOf = lastIndexOf;
>, <Line: -    lodash.mixin = mixin;
>, <Line: -    lodash.noConflict = noConflict;
>, <Line: -    lodash.noop = noop;
>, <Line: -    lodash.now = now;
>, <Line: -    lodash.parseInt = parseInt;
>, <Line: -    lodash.random = random;
>, <Line: -    lodash.reduce = reduce;
>, <Line: -    lodash.reduceRight = reduceRight;
>, <Line: -    lodash.result = result;
>, <Line: -    lodash.runInContext = runInContext;
>, <Line: -    lodash.size = size;
>, <Line: -    lodash.some = some;
>, <Line: -    lodash.sortedIndex = sortedIndex;
>, <Line: -    lodash.template = template;
>, <Line: -    lodash.unescape = unescape;
>, <Line: -    lodash.uniqueId = uniqueId;
>, <Line: -    // add aliases
>, <Line: -    lodash.all = every;
>, <Line: -    lodash.any = some;
>, <Line: -    lodash.detect = find;
>, <Line: -    lodash.findWhere = find;
>, <Line: -    lodash.foldl = reduce;
>, <Line: -    lodash.foldr = reduceRight;
>, <Line: -    lodash.include = contains;
>, <Line: -    lodash.inject = reduce;
>, <Line: -    mixin(function() {
>, <Line: -      var source = {}
>, <Line: -      forOwn(lodash, function(func, methodName) {
>, <Line: -        if (!lodash.prototype[methodName]) {
>, <Line: -          source[methodName] = func;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return source;
>, <Line: -    }(), false);
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    // add functions capable of returning wrapped and unwrapped values when chaining
>, <Line: -    lodash.first = first;
>, <Line: -    lodash.last = last;
>, <Line: -    lodash.sample = sample;
>, <Line: -    // add aliases
>, <Line: -    lodash.take = first;
>, <Line: -    lodash.head = first;
>, <Line: -    forOwn(lodash, function(func, methodName) {
>, <Line: -      var callbackable = methodName !== 'sample';
>, <Line: -      if (!lodash.prototype[methodName]) {
>, <Line: -        lodash.prototype[methodName]= function(n, guard) {
>, <Line: -          var chainAll = this.__chain__,
>, <Line: -              result = func(this.__wrapped__, n, guard);
>, <Line: -          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
>, <Line: -            ? result
>, <Line: -            : new lodashWrapper(result, chainAll);
>, <Line: -        };
>, <Line: -      }
>, <Line: -    });
>, <Line: -    /*--------------------------------------------------------------------------*/
>, <Line: -    /**
>, <Line: -     * The semantic version number.
>, <Line: -     *
>, <Line: -     * @static
>, <Line: -     * @memberOf _
>, <Line: -     * @type string
>, <Line: -     */
>, <Line: -    lodash.VERSION = '2.4.1';
>, <Line: -    // add "Chaining" functions to the wrapper
>, <Line: -    lodash.prototype.chain = wrapperChain;
>, <Line: -    lodash.prototype.toString = wrapperToString;
>, <Line: -    lodash.prototype.value = wrapperValueOf;
>, <Line: -    lodash.prototype.valueOf = wrapperValueOf;
>, <Line: -    // add `Array` functions that return unwrapped values
>, <Line: -    forEach(['join', 'pop', 'shift'], function(methodName) {
>, <Line: -      var func = arrayRef[methodName];
>, <Line: -      lodash.prototype[methodName] = function() {
>, <Line: -        var chainAll = this.__chain__,
>, <Line: -            result = func.apply(this.__wrapped__, arguments);
>, <Line: -        return chainAll
>, <Line: -          ? new lodashWrapper(result, chainAll)
>, <Line: -          : result;
>, <Line: -      };
>, <Line: -    });
>, <Line: -    // add `Array` functions that return the existing wrapped value
>, <Line: -    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
>, <Line: -      var func = arrayRef[methodName];
>, <Line: -      lodash.prototype[methodName] = function() {
>, <Line: -        func.apply(this.__wrapped__, arguments);
>, <Line: -        return this;
>, <Line: -      };
>, <Line: -    });
>, <Line: -    // add `Array` functions that return new wrapped values
>, <Line: -    forEach(['concat', 'slice', 'splice'], function(methodName) {
>, <Line: -      var func = arrayRef[methodName];
>, <Line: -      lodash.prototype[methodName] = function() {
>, <Line: -        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
>, <Line: -      };
>, <Line: -    });
>, <Line: -    return lodash;
>, <Line: -  }
>, <Line: -  /*--------------------------------------------------------------------------*/
>, <Line: -  // expose Lo-Dash
>, <Line: -  var _ = runInContext();
>, <Line: -  // some AMD build optimizers like r.js check for condition patterns like the following:
>, <Line: -  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
>, <Line: -    // Expose Lo-Dash to the global object even when an AMD loader is present in
>, <Line: -    // case Lo-Dash is loaded with a RequireJS shim config.
>, <Line: -    // See http://requirejs.org/docs/api.html#config-shim
>, <Line: -    root._ = _;
>, <Line: -    // define as an anonymous module so, through path mapping, it can be
>, <Line: -    // referenced as the "underscore" module
>, <Line: -    define(function() {
>, <Line: -      return _;
>, <Line: -    });
>, <Line: -  }
>, <Line: -  // check for `exports` after `define` in case a build optimizer adds an `exports` object
>, <Line: -  else if (freeExports && freeModule) {
>, <Line: -    // in Node.js or RingoJS
>, <Line: -    if (moduleExports) {
>, <Line: -      (freeModule.exports = _)._ = _;
>, <Line: -    }
>, <Line: -    // in Narwhal or Rhino -require
>, <Line: -    else {
>, <Line: -      freeExports._ = _;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  else {
>, <Line: -    // in a browser or Rhino
>, <Line: -    root._ = _;
>, <Line: -  }
>]