[<Line: +		'angular',
>, <Line: +		'lodash',
>, <Line: +		'config',
>, <Line: +		'../services/graphite/gfunc',
>, <Line: +		'../services/graphite/parser'
>, <Line: +	],
>, <Line: +	function (angular, _, config, gfunc, Parser) {
>, <Line: +		'use strict';
>, <Line: +		var module = angular.module('grafana.controllers');
>, <Line: +		var targetLetters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
>, <Line: +		module.controller('GraphiteTargetCtrl', function ($scope, $sce, templateSrv) {
>, <Line: +			$scope.init = function () {
>, <Line: +				$scope.target.target = $scope.target.target || '';
>, <Line: +				$scope.targetLetters = targetLetters;
>, <Line: +				parseTarget();
>, <Line: +			};
>, <Line: +			// The way parsing and the target editor works needs
>, <Line: +			// to be rewritten to handle functions that take multiple series
>, <Line: +			function parseTarget() {
>, <Line: +				$scope.functions = [];
>, <Line: +				$scope.segments = [];
>, <Line: +				$scope.showTextEditor = false;
>, <Line: +				delete $scope.parserError;
>, <Line: +				var parser = new Parser($scope.target.target);
>, <Line: +				var astNode = parser.getAst();
>, <Line: +				if (astNode === null) {
>, <Line: +					checkOtherSegments(0);
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				if (astNode.type === 'error') {
>, <Line: +					$scope.parserError = astNode.message + " at position: " + astNode.pos;
>, <Line: +					$scope.showTextEditor = true;
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				try {
>, <Line: +					parseTargeRecursive(astNode);
>, <Line: +				}
>, <Line: +				catch (err) {
>, <Line: +					console.log('error parsing target:', err.message);
>, <Line: +					$scope.parserError = err.message;
>, <Line: +					$scope.showTextEditor = true;
>, <Line: +				}
>, <Line: +				checkOtherSegments($scope.segments.length - 1);
>, <Line: +			}
>, <Line: +			function addFunctionParameter(func, value, index, shiftBack) {
>, <Line: +				if (shiftBack) {
>, <Line: +					index = Math.max(index - 1, 0);
>, <Line: +				}
>, <Line: +				func.params[index] = value;
>, <Line: +			}
>, <Line: +			function parseTargeRecursive(astNode, func, index) {
>, <Line: +				if (astNode === null) {
>, <Line: +					return null;
>, <Line: +				}
>, <Line: +				switch (astNode.type) {
>, <Line: +					case 'function':
>, <Line: +						var innerFunc = gfunc.createFuncInstance(astNode.name, {withDefaultParams: false});
>, <Line: +						_.each(astNode.params, function (param, index) {
>, <Line: +							parseTargeRecursive(param, innerFunc, index);
>, <Line: +						});
>, <Line: +						innerFunc.updateText();
>, <Line: +						$scope.functions.push(innerFunc);
>, <Line: +						break;
>, <Line: +					case 'series-ref':
>, <Line: +						addFunctionParameter(func, astNode.value, index, $scope.segments.length > 0);
>, <Line: +						break;
>, <Line: +					case 'string':
>, <Line: +					case 'number':
>, <Line: +						if ((index - 1) >= func.def.params.length) {
>, <Line: +							throw {message: 'invalid number of parameters to method ' + func.def.name};
>, <Line: +						}
>, <Line: +						addFunctionParameter(func, astNode.value, index, true);
>, <Line: +						break;
>, <Line: +					case 'metric':
>, <Line: +						if ($scope.segments.length > 0) {
>, <Line: +							if (astNode.segments.length !== 1) {
>, <Line: +								throw {message: 'Multiple metric params not supported, use text editor.'};
>, <Line: +							}
>, <Line: +							addFunctionParameter(func, astNode.segments[0].value, index, true);
>, <Line: +							break;
>, <Line: +						}
>, <Line: +						$scope.segments = _.map(astNode.segments, function (segment) {
>, <Line: +							return new MetricSegment(segment);
>, <Line: +						});
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function getSegmentPathUpTo(index) {
>, <Line: +				var arr = $scope.segments.slice(0, index);
>, <Line: +				return _.reduce(arr, function (result, segment) {
>, <Line: +					return result ? (result + "." + segment.value) : segment.value;
>, <Line: +				}, "");
>, <Line: +			}
>, <Line: +			function checkOtherSegments(fromIndex) {
>, <Line: +				if (fromIndex === 0) {
>, <Line: +					$scope.segments.push(new MetricSegment('select metric'));
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				var path = getSegmentPathUpTo(fromIndex + 1);
>, <Line: +				return $scope.datasource.metricFindQuery(path)
>, <Line: +					.then(function (segments) {
>, <Line: +						if (segments.length === 0) {
>, <Line: +							if (path !== '') {
>, <Line: +								$scope.segments = $scope.segments.splice(0, fromIndex);
>, <Line: +								$scope.segments.push(new MetricSegment('select metric'));
>, <Line: +							}
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						if (segments[0].expandable) {
>, <Line: +							if ($scope.segments.length === fromIndex) {
>, <Line: +								$scope.segments.push(new MetricSegment('select metric'));
>, <Line: +							}
>, <Line: +							else {
>, <Line: +								return checkOtherSegments(fromIndex + 1);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					})
>, <Line: +					.then(null, function (err) {
>, <Line: +						$scope.parserError = err.message || 'Failed to issue metric query';
>, <Line: +					});
>, <Line: +			}
>, <Line: +			function setSegmentFocus(segmentIndex) {
>, <Line: +				_.each($scope.segments, function (segment, index) {
>, <Line: +					segment.focus = segmentIndex === index;
>, <Line: +				});
>, <Line: +			}
>, <Line: +			function wrapFunction(target, func) {
>, <Line: +				return func.render(target);
>, <Line: +			}
>, <Line: +			$scope.getAltSegments = function (index) {
>, <Line: +				$scope.altSegments = [];
>, <Line: +				var query = index === 0 ? '*' : getSegmentPathUpTo(index) + '.*';
>, <Line: +				return $scope.datasource.metricFindQuery(query)
>, <Line: +					.then(function (segments) {
>, <Line: +						$scope.altSegments = _.map(segments, function (segment) {
>, <Line: +							return new MetricSegment({
>, <Line: +								value: segment.text,
>, <Line: +								expandable: segment.expandable
>, <Line: +							});
>, <Line: +						});
>, <Line: +						if ($scope.altSegments.length === 0) {
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						// add template variables
>, <Line: +						_.each(templateSrv.variables, function (variable) {
>, <Line: +							$scope.altSegments.unshift(new MetricSegment({
>, <Line: +								type: 'template',
>, <Line: +								value: '$' + variable.name,
>, <Line: +								expandable: true,
>, <Line: +							}));
>, <Line: +						});
>, <Line: +						// add wildcard option
>, <Line: +						$scope.altSegments.unshift(new MetricSegment('*'));
>, <Line: +					})
>, <Line: +					.then(null, function (err) {
>, <Line: +						$scope.parserError = err.message || 'Failed to issue metric query';
>, <Line: +					});
>, <Line: +			};
>, <Line: +			$scope.segmentValueChanged = function (segment, segmentIndex) {
>, <Line: +				delete $scope.parserError;
>, <Line: +				if ($scope.functions.length > 0 && $scope.functions[0].def.fake) {
>, <Line: +					$scope.functions = [];
>, <Line: +				}
>, <Line: +				if (segment.expandable) {
>, <Line: +					return checkOtherSegments(segmentIndex + 1)
>, <Line: +						.then(function () {
>, <Line: +							setSegmentFocus(segmentIndex + 1);
>, <Line: +							$scope.targetChanged();
>, <Line: +						});
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					$scope.segments = $scope.segments.splice(0, segmentIndex + 1);
>, <Line: +				}
>, <Line: +				setSegmentFocus(segmentIndex + 1);
>, <Line: +				$scope.targetChanged();
>, <Line: +			};
>, <Line: +			$scope.targetTextChanged = function () {
>, <Line: +				parseTarget();
>, <Line: +				$scope.get_data();
>, <Line: +			};
>, <Line: +			$scope.targetChanged = function () {
>, <Line: +				if ($scope.parserError) {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				var oldTarget = $scope.target.target;
>, <Line: +				var target = getSegmentPathUpTo($scope.segments.length);
>, <Line: +				$scope.target.target = _.reduce($scope.functions, wrapFunction, target);
>, <Line: +				if ($scope.target.target !== oldTarget) {
>, <Line: +					$scope.$parent.get_data();
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$scope.removeFunction = function (func) {
>, <Line: +				$scope.functions = _.without($scope.functions, func);
>, <Line: +				$scope.targetChanged();
>, <Line: +			};
>, <Line: +			$scope.addFunction = function (funcDef) {
>, <Line: +				var newFunc = gfunc.createFuncInstance(funcDef, {withDefaultParams: true});
>, <Line: +				newFunc.added = true;
>, <Line: +				$scope.functions.push(newFunc);
>, <Line: +				$scope.moveAliasFuncLast();
>, <Line: +				$scope.smartlyHandleNewAliasByNode(newFunc);
>, <Line: +				if ($scope.segments.length === 1 && $scope.segments[0].value === 'select metric') {
>, <Line: +					$scope.segments = [];
>, <Line: +				}
>, <Line: +				if (!newFunc.params.length && newFunc.added) {
>, <Line: +					$scope.targetChanged();
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$scope.moveAliasFuncLast = function () {
>, <Line: +				var aliasFunc = _.find($scope.functions, function (func) {
>, <Line: +					return func.def.name === 'alias' ||
>, <Line: +						func.def.name === 'aliasByNode' ||
>, <Line: +						func.def.name === 'aliasByMetric';
>, <Line: +				});
>, <Line: +				if (aliasFunc) {
>, <Line: +					$scope.functions = _.without($scope.functions, aliasFunc);
>, <Line: +					$scope.functions.push(aliasFunc);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$scope.smartlyHandleNewAliasByNode = function (func) {
>, <Line: +				if (func.def.name !== 'aliasByNode') {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				for (var i = 0; i < $scope.segments.length; i++) {
>, <Line: +					if ($scope.segments[i].value.indexOf('*') >= 0) {
>, <Line: +						func.params[0] = i;
>, <Line: +						func.added = false;
>, <Line: +						$scope.targetChanged();
>, <Line: +						return;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$scope.toggleMetricOptions = function () {
>, <Line: +				$scope.panel.metricOptionsEnabled = !$scope.panel.metricOptionsEnabled;
>, <Line: +				if (!$scope.panel.metricOptionsEnabled) {
>, <Line: +					delete $scope.panel.cacheTimeout;
>, <Line: +				}
>, <Line: +			};
>, <Line: +			$scope.moveMetricQuery = function (fromIndex, toIndex) {
>, <Line: +				_.move($scope.panel.targets, fromIndex, toIndex);
>, <Line: +			};
>, <Line: +			$scope.duplicate = function () {
>, <Line: +				var clone = angular.copy($scope.target);
>, <Line: +				$scope.panel.targets.push(clone);
>, <Line: +			};
>, <Line: +			function MetricSegment(options) {
>, <Line: +				if (options === '*' || options.value === '*') {
>, <Line: +					this.value = '*';
>, <Line: +					this.html = $sce.trustAsHtml('<i class="icon-asterisk"><i>');
>, <Line: +					this.expandable = true;
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				if (_.isString(options)) {
>, <Line: +					this.value = options;
>, <Line: +					this.html = $sce.trustAsHtml(this.value);
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				this.value = options.value;
>, <Line: +				this.type = options.type;
>, <Line: +				this.expandable = options.expandable;
>, <Line: +				this.html = $sce.trustAsHtml(templateSrv.highlightVariablesAsHtml(this.value));
>, <Line: +			}
>, <Line: +		});
>, <Line: +		module.directive('focusMe', function ($timeout, $parse) {
>, <Line: +			return {
>, <Line: +				//scope: true,   // optionally create a child scope
>, <Line: +				link: function (scope, element, attrs) {
>, <Line: +					var model = $parse(attrs.focusMe);
>, <Line: +					scope.$watch(model, function (value) {
>, <Line: +						if (value === true) {
>, <Line: +							$timeout(function () {
>, <Line: +								element[0].focus();
>, <Line: +							});
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +		});
>, <Line: +	});
>]
[<Line: -  'angular',
>, <Line: -  'lodash',
>, <Line: -  'config',
>, <Line: -  '../services/graphite/gfunc',
>, <Line: -  '../services/graphite/parser'
>, <Line: -],
>, <Line: -function (angular, _, config, gfunc, Parser) {
>, <Line: -  'use strict';
>, <Line: -  var module = angular.module('grafana.controllers');
>, <Line: -  var targetLetters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
>, <Line: -  module.controller('GraphiteTargetCtrl', function($scope, $sce, templateSrv) {
>, <Line: -    $scope.init = function() {
>, <Line: -      $scope.target.target = $scope.target.target || '';
>, <Line: -      $scope.targetLetters = targetLetters;
>, <Line: -      parseTarget();
>, <Line: -    };
>, <Line: -    // The way parsing and the target editor works needs
>, <Line: -    // to be rewritten to handle functions that take multiple series
>, <Line: -    function parseTarget() {
>, <Line: -      $scope.functions = [];
>, <Line: -      $scope.segments = [];
>, <Line: -      $scope.showTextEditor = false;
>, <Line: -      delete $scope.parserError;
>, <Line: -      var parser = new Parser($scope.target.target);
>, <Line: -      var astNode = parser.getAst();
>, <Line: -      if (astNode === null) {
>, <Line: -        checkOtherSegments(0);
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      if (astNode.type === 'error') {
>, <Line: -        $scope.parserError = astNode.message + " at position: " + astNode.pos;
>, <Line: -        $scope.showTextEditor = true;
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      try {
>, <Line: -        parseTargeRecursive(astNode);
>, <Line: -      }
>, <Line: -      catch (err) {
>, <Line: -        console.log('error parsing target:', err.message);
>, <Line: -        $scope.parserError = err.message;
>, <Line: -        $scope.showTextEditor = true;
>, <Line: -      }
>, <Line: -      checkOtherSegments($scope.segments.length - 1);
>, <Line: -    }
>, <Line: -    function addFunctionParameter(func, value, index, shiftBack) {
>, <Line: -      if (shiftBack) {
>, <Line: -        index = Math.max(index - 1, 0);
>, <Line: -      }
>, <Line: -      func.params[index] = value;
>, <Line: -    }
>, <Line: -    function parseTargeRecursive(astNode, func, index) {
>, <Line: -      if (astNode === null) {
>, <Line: -        return null;
>, <Line: -      }
>, <Line: -      switch(astNode.type) {
>, <Line: -      case 'function':
>, <Line: -        var innerFunc = gfunc.createFuncInstance(astNode.name, { withDefaultParams: false });
>, <Line: -        _.each(astNode.params, function(param, index) {
>, <Line: -          parseTargeRecursive(param, innerFunc, index);
>, <Line: -        });
>, <Line: -        innerFunc.updateText();
>, <Line: -        $scope.functions.push(innerFunc);
>, <Line: -        break;
>, <Line: -      case 'series-ref':
>, <Line: -        addFunctionParameter(func, astNode.value, index, $scope.segments.length > 0);
>, <Line: -        break;
>, <Line: -      case 'string':
>, <Line: -      case 'number':
>, <Line: -        if ((index-1) >= func.def.params.length) {
>, <Line: -          throw { message: 'invalid number of parameters to method ' + func.def.name };
>, <Line: -        }
>, <Line: -        addFunctionParameter(func, astNode.value, index, true);
>, <Line: -        break;
>, <Line: -      case 'metric':
>, <Line: -        if ($scope.segments.length > 0) {
>, <Line: -          if (astNode.segments.length !== 1) {
>, <Line: -            throw { message: 'Multiple metric params not supported, use text editor.' };
>, <Line: -          }
>, <Line: -          addFunctionParameter(func, astNode.segments[0].value, index, true);
>, <Line: -          break;
>, <Line: -        }
>, <Line: -        $scope.segments = _.map(astNode.segments, function(segment) {
>, <Line: -          return new MetricSegment(segment);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function getSegmentPathUpTo(index) {
>, <Line: -      var arr = $scope.segments.slice(0, index);
>, <Line: -      return _.reduce(arr, function(result, segment) {
>, <Line: -        return result ? (result + "." + segment.value) : segment.value;
>, <Line: -      }, "");
>, <Line: -    }
>, <Line: -    function checkOtherSegments(fromIndex) {
>, <Line: -      if (fromIndex === 0) {
>, <Line: -        $scope.segments.push(new MetricSegment('select metric'));
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      var path = getSegmentPathUpTo(fromIndex + 1);
>, <Line: -      return $scope.datasource.metricFindQuery(path)
>, <Line: -        .then(function(segments) {
>, <Line: -          if (segments.length === 0) {
>, <Line: -            if (path !== '') {
>, <Line: -              $scope.segments = $scope.segments.splice(0, fromIndex);
>, <Line: -              $scope.segments.push(new MetricSegment('select metric'));
>, <Line: -            }
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          if (segments[0].expandable) {
>, <Line: -            if ($scope.segments.length === fromIndex) {
>, <Line: -              $scope.segments.push(new MetricSegment('select metric'));
>, <Line: -            }
>, <Line: -            else {
>, <Line: -              return checkOtherSegments(fromIndex + 1);
>, <Line: -            }
>, <Line: -          }
>, <Line: -        })
>, <Line: -        .then(null, function(err) {
>, <Line: -          $scope.parserError = err.message || 'Failed to issue metric query';
>, <Line: -        });
>, <Line: -    }
>, <Line: -    function setSegmentFocus(segmentIndex) {
>, <Line: -      _.each($scope.segments, function(segment, index) {
>, <Line: -        segment.focus = segmentIndex === index;
>, <Line: -      });
>, <Line: -    }
>, <Line: -    function wrapFunction(target, func) {
>, <Line: -      return func.render(target);
>, <Line: -    }
>, <Line: -    $scope.getAltSegments = function (index) {
>, <Line: -      $scope.altSegments = [];
>, <Line: -      var query = index === 0 ?  '*' : getSegmentPathUpTo(index) + '.*';
>, <Line: -      return $scope.datasource.metricFindQuery(query)
>, <Line: -        .then(function(segments) {
>, <Line: -          $scope.altSegments = _.map(segments, function(segment) {
>, <Line: -            return new MetricSegment({ value: segment.text, expandable: segment.expandable });
>, <Line: -          });
>, <Line: -          if ($scope.altSegments.length === 0) {
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          // add template variables
>, <Line: -          _.each(templateSrv.variables, function(variable) {
>, <Line: -            $scope.altSegments.unshift(new MetricSegment({
>, <Line: -              type: 'template',
>, <Line: -              value: '$' + variable.name,
>, <Line: -              expandable: true,
>, <Line: -            }));
>, <Line: -          });
>, <Line: -          // add wildcard option
>, <Line: -          $scope.altSegments.unshift(new MetricSegment('*'));
>, <Line: -        })
>, <Line: -        .then(null, function(err) {
>, <Line: -          $scope.parserError = err.message || 'Failed to issue metric query';
>, <Line: -        });
>, <Line: -    };
>, <Line: -    $scope.segmentValueChanged = function (segment, segmentIndex) {
>, <Line: -      delete $scope.parserError;
>, <Line: -      if ($scope.functions.length > 0 && $scope.functions[0].def.fake) {
>, <Line: -        $scope.functions = [];
>, <Line: -      }
>, <Line: -      if (segment.expandable) {
>, <Line: -        return checkOtherSegments(segmentIndex + 1)
>, <Line: -          .then(function () {
>, <Line: -            setSegmentFocus(segmentIndex + 1);
>, <Line: -            $scope.targetChanged();
>, <Line: -          });
>, <Line: -      }
>, <Line: -      else {
>, <Line: -        $scope.segments = $scope.segments.splice(0, segmentIndex + 1);
>, <Line: -      }
>, <Line: -      setSegmentFocus(segmentIndex + 1);
>, <Line: -      $scope.targetChanged();
>, <Line: -    };
>, <Line: -    $scope.targetTextChanged = function() {
>, <Line: -      parseTarget();
>, <Line: -      $scope.get_data();
>, <Line: -    };
>, <Line: -    $scope.targetChanged = function() {
>, <Line: -      if ($scope.parserError) {
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      var oldTarget = $scope.target.target;
>, <Line: -      var target = getSegmentPathUpTo($scope.segments.length);
>, <Line: -      $scope.target.target = _.reduce($scope.functions, wrapFunction, target);
>, <Line: -      if ($scope.target.target !== oldTarget) {
>, <Line: -        $scope.$parent.get_data();
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $scope.removeFunction = function(func) {
>, <Line: -      $scope.functions = _.without($scope.functions, func);
>, <Line: -      $scope.targetChanged();
>, <Line: -    };
>, <Line: -    $scope.addFunction = function(funcDef) {
>, <Line: -      var newFunc = gfunc.createFuncInstance(funcDef, { withDefaultParams: true });
>, <Line: -      newFunc.added = true;
>, <Line: -      $scope.functions.push(newFunc);
>, <Line: -      $scope.moveAliasFuncLast();
>, <Line: -      $scope.smartlyHandleNewAliasByNode(newFunc);
>, <Line: -      if ($scope.segments.length === 1 && $scope.segments[0].value === 'select metric') {
>, <Line: -        $scope.segments = [];
>, <Line: -      }
>, <Line: -      if (!newFunc.params.length && newFunc.added) {
>, <Line: -        $scope.targetChanged();
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $scope.moveAliasFuncLast = function() {
>, <Line: -      var aliasFunc = _.find($scope.functions, function(func) {
>, <Line: -        return func.def.name === 'alias' ||
>, <Line: -               func.def.name === 'aliasByNode' ||
>, <Line: -               func.def.name === 'aliasByMetric';
>, <Line: -      });
>, <Line: -      if (aliasFunc) {
>, <Line: -        $scope.functions = _.without($scope.functions, aliasFunc);
>, <Line: -        $scope.functions.push(aliasFunc);
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $scope.smartlyHandleNewAliasByNode = function(func) {
>, <Line: -      if (func.def.name !== 'aliasByNode') {
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      for(var i = 0; i < $scope.segments.length; i++) {
>, <Line: -        if ($scope.segments[i].value.indexOf('*') >= 0)  {
>, <Line: -          func.params[0] = i;
>, <Line: -          func.added = false;
>, <Line: -          $scope.targetChanged();
>, <Line: -          return;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $scope.toggleMetricOptions = function() {
>, <Line: -      $scope.panel.metricOptionsEnabled = !$scope.panel.metricOptionsEnabled;
>, <Line: -      if (!$scope.panel.metricOptionsEnabled) {
>, <Line: -        delete $scope.panel.cacheTimeout;
>, <Line: -      }
>, <Line: -    };
>, <Line: -    $scope.moveMetricQuery = function(fromIndex, toIndex) {
>, <Line: -      _.move($scope.panel.targets, fromIndex, toIndex);
>, <Line: -    };
>, <Line: -    $scope.duplicate = function() {
>, <Line: -      var clone = angular.copy($scope.target);
>, <Line: -      $scope.panel.targets.push(clone);
>, <Line: -    };
>, <Line: -    function MetricSegment(options) {
>, <Line: -      if (options === '*' || options.value === '*') {
>, <Line: -        this.value = '*';
>, <Line: -        this.html = $sce.trustAsHtml('<i class="icon-asterisk"><i>');
>, <Line: -        this.expandable = true;
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      if (_.isString(options)) {
>, <Line: -        this.value = options;
>, <Line: -        this.html = $sce.trustAsHtml(this.value);
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      this.value = options.value;
>, <Line: -      this.type = options.type;
>, <Line: -      this.expandable = options.expandable;
>, <Line: -      this.html = $sce.trustAsHtml(templateSrv.highlightVariablesAsHtml(this.value));
>, <Line: -    }
>, <Line: -  });
>, <Line: -  module.directive('focusMe', function($timeout, $parse) {
>, <Line: -    return {
>, <Line: -      //scope: true,   // optionally create a child scope
>, <Line: -      link: function(scope, element, attrs) {
>, <Line: -        var model = $parse(attrs.focusMe);
>, <Line: -        scope.$watch(model, function(value) {
>, <Line: -          if(value === true) {
>, <Line: -            $timeout(function() {
>, <Line: -              element[0].focus();
>, <Line: -            });
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -  });
>, <Line: -});
>]