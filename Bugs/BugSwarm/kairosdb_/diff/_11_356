[<Line: +	var defaultOpts = {
>, <Line: +			// Callbacks
>, <Line: +			beforeShow: noop,
>, <Line: +			move: noop,
>, <Line: +			change: noop,
>, <Line: +			show: noop,
>, <Line: +			hide: noop,
>, <Line: +			// Options
>, <Line: +			color: false,
>, <Line: +			flat: false,
>, <Line: +			showInput: false,
>, <Line: +			allowEmpty: false,
>, <Line: +			showButtons: true,
>, <Line: +			clickoutFiresChange: false,
>, <Line: +			showInitial: false,
>, <Line: +			showPalette: false,
>, <Line: +			showPaletteOnly: false,
>, <Line: +			showSelectionPalette: true,
>, <Line: +			localStorageKey: false,
>, <Line: +			appendTo: "body",
>, <Line: +			maxSelectionSize: 7,
>, <Line: +			cancelText: "cancel",
>, <Line: +			chooseText: "choose",
>, <Line: +			clearText: "Clear Color Selection",
>, <Line: +			preferredFormat: false,
>, <Line: +			className: "",
>, <Line: +			showAlpha: false,
>, <Line: +			theme: "sp-light",
>, <Line: +			palette: ['fff', '000'],
>, <Line: +			selectionPalette: [],
>, <Line: +			disabled: false
>, <Line: +		},
>, <Line: +		spectrums = [],
>, <Line: +		IE = !!/msie/i.exec(window.navigator.userAgent),
>, <Line: +		rgbaSupport = (function () {
>, <Line: +			function contains(str, substr) {
>, <Line: +				return !!~('' + str).indexOf(substr);
>, <Line: +			}
>, <Line: +			var elem = document.createElement('div');
>, <Line: +			var style = elem.style;
>, <Line: +			style.cssText = 'background-color:rgba(0,0,0,.5)';
>, <Line: +			return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
>, <Line: +		})(),
>, <Line: +		inputTypeColorSupport = (function () {
>, <Line: +			var colorInput = $("<input type='color' value='!' />")[0];
>, <Line: +			return colorInput.type === "color" && colorInput.value !== "!";
>, <Line: +		})(),
>, <Line: +		replaceInput = [
>, <Line: +			"<div class='sp-replacer'>",
>, <Line: +			"<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
>, <Line: +			"<div class='sp-dd'>&#9660;</div>",
>, <Line: +			"</div>"
>, <Line: +		].join(''),
>, <Line: +		markup = (function () {
>, <Line: +			// IE does not support gradients with multiple stops, so we need to simulate
>, <Line: +			//  that for the rainbow slider with 8 divs that each have a single gradient
>, <Line: +			var gradientFix = "";
>, <Line: +			if (IE) {
>, <Line: +				for (var i = 1; i <= 6; i++) {
>, <Line: +					gradientFix += "<div class='sp-" + i + "'></div>";
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return [
>, <Line: +				"<div class='sp-container sp-hidden'>",
>, <Line: +				"<div class='sp-palette-container'>",
>, <Line: +				"<div class='sp-palette sp-thumb sp-cf'></div>",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-picker-container'>",
>, <Line: +				"<div class='sp-top sp-cf'>",
>, <Line: +				"<div class='sp-fill'></div>",
>, <Line: +				"<div class='sp-top-inner'>",
>, <Line: +				"<div class='sp-color'>",
>, <Line: +				"<div class='sp-sat'>",
>, <Line: +				"<div class='sp-val'>",
>, <Line: +				"<div class='sp-dragger'></div>",
>, <Line: +				"</div>",
>, <Line: +				"</div>",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-clear sp-clear-display'>",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-hue'>",
>, <Line: +				"<div class='sp-slider'></div>",
>, <Line: +				gradientFix,
>, <Line: +				"</div>",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-input-container sp-cf'>",
>, <Line: +				"<input class='sp-input' type='text' spellcheck='false'  />",
>, <Line: +				"</div>",
>, <Line: +				"<div class='sp-initial sp-thumb sp-cf'></div>",
>, <Line: +				"<div class='sp-button-container sp-cf'>",
>, <Line: +				"<a class='sp-cancel' href='#'></a>",
>, <Line: +				"<button class='sp-choose'></button>",
>, <Line: +				"</div>",
>, <Line: +				"</div>",
>, <Line: +				"</div>"
>, <Line: +			].join("");
>, <Line: +		})();
>, <Line: +	function paletteTemplate(p, color, className) {
>, <Line: +		var html = [];
>, <Line: +		for (var i = 0; i < p.length; i++) {
>, <Line: +			var current = p[i];
>, <Line: +			if (current) {
>, <Line: +				var tiny = tinycolor(current);
>, <Line: +				var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
>, <Line: +				c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
>, <Line: +				var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
>, <Line: +				html.push('<span title="' + tiny.toRgbString() + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
>, <Line: +			} else {
>, <Line: +				var cls = 'sp-clear-display';
>, <Line: +				html.push('<span title="No Color Selected" data-color="" style="background-color:transparent;" class="' + cls + '"></span>');
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
>, <Line: +	}
>, <Line: +	function hideAll() {
>, <Line: +		for (var i = 0; i < spectrums.length; i++) {
>, <Line: +			if (spectrums[i]) {
>, <Line: +				spectrums[i].hide();
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function instanceOptions(o, callbackContext) {
>, <Line: +		var opts = $.extend({}, defaultOpts, o);
>, <Line: +		opts.callbacks = {
>, <Line: +			'move': bind(opts.move, callbackContext),
>, <Line: +			'change': bind(opts.change, callbackContext),
>, <Line: +			'show': bind(opts.show, callbackContext),
>, <Line: +			'hide': bind(opts.hide, callbackContext),
>, <Line: +			'beforeShow': bind(opts.beforeShow, callbackContext)
>, <Line: +		};
>, <Line: +		return opts;
>, <Line: +	}
>, <Line: +	function spectrum(element, o) {
>, <Line: +		var opts = instanceOptions(o, element),
>, <Line: +			flat = opts.flat,
>, <Line: +			showSelectionPalette = opts.showSelectionPalette,
>, <Line: +			localStorageKey = opts.localStorageKey,
>, <Line: +			theme = opts.theme,
>, <Line: +			callbacks = opts.callbacks,
>, <Line: +			resize = throttle(reflow, 10),
>, <Line: +			visible = false,
>, <Line: +			dragWidth = 0,
>, <Line: +			dragHeight = 0,
>, <Line: +			dragHelperHeight = 0,
>, <Line: +			slideHeight = 0,
>, <Line: +			slideWidth = 0,
>, <Line: +			alphaWidth = 0,
>, <Line: +			alphaSlideHelperWidth = 0,
>, <Line: +			slideHelperHeight = 0,
>, <Line: +			currentHue = 0,
>, <Line: +			currentSaturation = 0,
>, <Line: +			currentValue = 0,
>, <Line: +			currentAlpha = 1,
>, <Line: +			palette = [],
>, <Line: +			paletteArray = [],
>, <Line: +			selectionPalette = opts.selectionPalette.slice(0),
>, <Line: +			maxSelectionSize = opts.maxSelectionSize,
>, <Line: +			draggingClass = "sp-dragging",
>, <Line: +			shiftMovementDirection = null;
>, <Line: +		var doc = element.ownerDocument,
>, <Line: +			body = doc.body,
>, <Line: +			boundElement = $(element),
>, <Line: +			disabled = false,
>, <Line: +			container = $(markup, doc).addClass(theme),
>, <Line: +			dragger = container.find(".sp-color"),
>, <Line: +			dragHelper = container.find(".sp-dragger"),
>, <Line: +			slider = container.find(".sp-hue"),
>, <Line: +			slideHelper = container.find(".sp-slider"),
>, <Line: +			alphaSliderInner = container.find(".sp-alpha-inner"),
>, <Line: +			alphaSlider = container.find(".sp-alpha"),
>, <Line: +			alphaSlideHelper = container.find(".sp-alpha-handle"),
>, <Line: +			textInput = container.find(".sp-input"),
>, <Line: +			paletteContainer = container.find(".sp-palette"),
>, <Line: +			initialColorContainer = container.find(".sp-initial"),
>, <Line: +			cancelButton = container.find(".sp-cancel"),
>, <Line: +			clearButton = container.find(".sp-clear"),
>, <Line: +			chooseButton = container.find(".sp-choose"),
>, <Line: +			isInput = boundElement.is("input"),
>, <Line: +			isInputTypeColor = isInput && inputTypeColorSupport && boundElement.attr("type") === "color",
>, <Line: +			shouldReplace = isInput && !flat,
>, <Line: +			replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className) : $([]),
>, <Line: +			offsetElement = (shouldReplace) ? replacer : boundElement,
>, <Line: +			previewElement = replacer.find(".sp-preview-inner"),
>, <Line: +			initialColor = opts.color || (isInput && boundElement.val()),
>, <Line: +			colorOnShow = false,
>, <Line: +			preferredFormat = opts.preferredFormat,
>, <Line: +			currentPreferredFormat = preferredFormat,
>, <Line: +			clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
>, <Line: +			isEmpty = !initialColor,
>, <Line: +			allowEmpty = opts.allowEmpty && !isInputTypeColor;
>, <Line: +		function applyOptions() {
>, <Line: +			if (opts.showPaletteOnly) {
>, <Line: +				opts.showPalette = true;
>, <Line: +			}
>, <Line: +			if (opts.palette) {
>, <Line: +				palette = opts.palette.slice(0);
>, <Line: +				paletteArray = $.isArray(palette[0]) ? palette : [palette];
>, <Line: +			}
>, <Line: +			container.toggleClass("sp-flat", flat);
>, <Line: +			container.toggleClass("sp-input-disabled", !opts.showInput);
>, <Line: +			container.toggleClass("sp-alpha-enabled", opts.showAlpha);
>, <Line: +			container.toggleClass("sp-clear-enabled", allowEmpty);
>, <Line: +			container.toggleClass("sp-buttons-disabled", !opts.showButtons);
>, <Line: +			container.toggleClass("sp-palette-disabled", !opts.showPalette);
>, <Line: +			container.toggleClass("sp-palette-only", opts.showPaletteOnly);
>, <Line: +			container.toggleClass("sp-initial-disabled", !opts.showInitial);
>, <Line: +			container.addClass(opts.className);
>, <Line: +			reflow();
>, <Line: +		}
>, <Line: +		function initialize() {
>, <Line: +			if (IE) {
>, <Line: +				container.find("*:not(input)").attr("unselectable", "on");
>, <Line: +			}
>, <Line: +			applyOptions();
>, <Line: +			if (shouldReplace) {
>, <Line: +				boundElement.after(replacer).hide();
>, <Line: +			}
>, <Line: +			if (!allowEmpty) {
>, <Line: +				clearButton.hide();
>, <Line: +			}
>, <Line: +			if (flat) {
>, <Line: +				boundElement.after(container).hide();
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
>, <Line: +				if (appendTo.length !== 1) {
>, <Line: +					appendTo = $("body");
>, <Line: +				}
>, <Line: +				appendTo.append(container);
>, <Line: +			}
>, <Line: +			if (localStorageKey && window.localStorage) {
>, <Line: +				// Migrate old palettes over to new format.  May want to remove this eventually.
>, <Line: +				try {
>, <Line: +					var oldPalette = window.localStorage[localStorageKey].split(",#");
>, <Line: +					if (oldPalette.length > 1) {
>, <Line: +						delete window.localStorage[localStorageKey];
>, <Line: +						$.each(oldPalette, function (i, c) {
>, <Line: +							addColorToSelectionPalette(c);
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}
>, <Line: +				catch (e) {
>, <Line: +				}
>, <Line: +				try {
>, <Line: +					selectionPalette = window.localStorage[localStorageKey].split(";");
>, <Line: +				}
>, <Line: +				catch (e) {
>, <Line: +				}
>, <Line: +			}
>, <Line: +			offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
>, <Line: +				if (!disabled) {
>, <Line: +					toggle();
>, <Line: +				}
>, <Line: +				e.stopPropagation();
>, <Line: +				if (!$(e.target).is("input")) {
>, <Line: +					e.preventDefault();
>, <Line: +				}
>, <Line: +			});
>, <Line: +			if (boundElement.is(":disabled") || (opts.disabled === true)) {
>, <Line: +				disable();
>, <Line: +			}
>, <Line: +			// Prevent clicks from bubbling up to document.  This would cause it to be hidden.
>, <Line: +			container.click(stopPropagation);
>, <Line: +			// Handle user typed input
>, <Line: +			textInput.change(setFromTextInput);
>, <Line: +			textInput.bind("paste", function () {
>, <Line: +				setTimeout(setFromTextInput, 1);
>, <Line: +			});
>, <Line: +			textInput.keydown(function (e) {
>, <Line: +				if (e.keyCode == 13) {
>, <Line: +					setFromTextInput();
>, <Line: +				}
>, <Line: +			});
>, <Line: +			cancelButton.text(opts.cancelText);
>, <Line: +			cancelButton.bind("click.spectrum", function (e) {
>, <Line: +				e.stopPropagation();
>, <Line: +				e.preventDefault();
>, <Line: +				hide("cancel");
>, <Line: +			});
>, <Line: +			clearButton.attr("title", opts.clearText);
>, <Line: +			clearButton.bind("click.spectrum", function (e) {
>, <Line: +				e.stopPropagation();
>, <Line: +				e.preventDefault();
>, <Line: +				isEmpty = true;
>, <Line: +				move();
>, <Line: +				if (flat) {
>, <Line: +					//for the flat style, this is a change event
>, <Line: +					updateOriginalInput(true);
>, <Line: +				}
>, <Line: +			});
>, <Line: +			chooseButton.text(opts.chooseText);
>, <Line: +			chooseButton.bind("click.spectrum", function (e) {
>, <Line: +				e.stopPropagation();
>, <Line: +				e.preventDefault();
>, <Line: +				if (isValid()) {
>, <Line: +					updateOriginalInput(true);
>, <Line: +					hide();
>, <Line: +				}
>, <Line: +			});
>, <Line: +			draggable(alphaSlider, function (dragX, dragY, e) {
>, <Line: +				currentAlpha = (dragX / alphaWidth);
>, <Line: +				isEmpty = false;
>, <Line: +				if (e.shiftKey) {
>, <Line: +					currentAlpha = Math.round(currentAlpha * 10) / 10;
>, <Line: +				}
>, <Line: +				move();
>, <Line: +			}, dragStart, dragStop);
>, <Line: +			draggable(slider, function (dragX, dragY) {
>, <Line: +				currentHue = parseFloat(dragY / slideHeight);
>, <Line: +				isEmpty = false;
>, <Line: +				if (!opts.showAlpha) {
>, <Line: +					currentAlpha = 1;
>, <Line: +				}
>, <Line: +				move();
>, <Line: +			}, dragStart, dragStop);
>, <Line: +			draggable(dragger, function (dragX, dragY, e) {
>, <Line: +				// shift+drag should snap the movement to either the x or y axis.
>, <Line: +				if (!e.shiftKey) {
>, <Line: +					shiftMovementDirection = null;
>, <Line: +				}
>, <Line: +				else if (!shiftMovementDirection) {
>, <Line: +					var oldDragX = currentSaturation * dragWidth;
>, <Line: +					var oldDragY = dragHeight - (currentValue * dragHeight);
>, <Line: +					var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
>, <Line: +					shiftMovementDirection = furtherFromX ? "x" : "y";
>, <Line: +				}
>, <Line: +				var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
>, <Line: +				var setValue = !shiftMovementDirection || shiftMovementDirection === "y";
>, <Line: +				if (setSaturation) {
>, <Line: +					currentSaturation = parseFloat(dragX / dragWidth);
>, <Line: +				}
>, <Line: +				if (setValue) {
>, <Line: +					currentValue = parseFloat((dragHeight - dragY) / dragHeight);
>, <Line: +				}
>, <Line: +				isEmpty = false;
>, <Line: +				if (!opts.showAlpha) {
>, <Line: +					currentAlpha = 1;
>, <Line: +				}
>, <Line: +				move();
>, <Line: +			}, dragStart, dragStop);
>, <Line: +			if (!!initialColor) {
>, <Line: +				set(initialColor);
>, <Line: +				// In case color was black - update the preview UI and set the format
>, <Line: +				// since the set function will not run (default color is black).
>, <Line: +				updateUI();
>, <Line: +				currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;
>, <Line: +				addColorToSelectionPalette(initialColor);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				updateUI();
>, <Line: +			}
>, <Line: +			if (flat) {
>, <Line: +				show();
>, <Line: +			}
>, <Line: +			function palletElementClick(e) {
>, <Line: +				if (e.data && e.data.ignore) {
>, <Line: +					set($(this).data("color"));
>, <Line: +					move();
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					set($(this).data("color"));
>, <Line: +					updateOriginalInput(true);
>, <Line: +					move();
>, <Line: +					hide();
>, <Line: +				}
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
>, <Line: +			paletteContainer.delegate(".sp-thumb-el", paletteEvent, palletElementClick);
>, <Line: +			initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, {ignore: true}, palletElementClick);
>, <Line: +		}
>, <Line: +		function addColorToSelectionPalette(color) {
>, <Line: +			if (showSelectionPalette) {
>, <Line: +				var colorRgb = tinycolor(color).toRgbString();
>, <Line: +				if ($.inArray(colorRgb, selectionPalette) === -1) {
>, <Line: +					selectionPalette.push(colorRgb);
>, <Line: +					while (selectionPalette.length > maxSelectionSize) {
>, <Line: +						selectionPalette.shift();
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (localStorageKey && window.localStorage) {
>, <Line: +					try {
>, <Line: +						window.localStorage[localStorageKey] = selectionPalette.join(";");
>, <Line: +					}
>, <Line: +					catch (e) {
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function getUniqueSelectionPalette() {
>, <Line: +			var unique = [];
>, <Line: +			var p = selectionPalette;
>, <Line: +			var paletteLookup = {};
>, <Line: +			var rgb;
>, <Line: +			if (opts.showPalette) {
>, <Line: +				for (var i = 0; i < paletteArray.length; i++) {
>, <Line: +					for (var j = 0; j < paletteArray[i].length; j++) {
>, <Line: +						rgb = tinycolor(paletteArray[i][j]).toRgbString();
>, <Line: +						paletteLookup[rgb] = true;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				for (i = 0; i < p.length; i++) {
>, <Line: +					rgb = tinycolor(p[i]).toRgbString();
>, <Line: +					if (!paletteLookup.hasOwnProperty(rgb)) {
>, <Line: +						unique.push(p[i]);
>, <Line: +						paletteLookup[rgb] = true;
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return unique.reverse().slice(0, opts.maxSelectionSize);
>, <Line: +		}
>, <Line: +		function drawPalette() {
>, <Line: +			var currentColor = get();
>, <Line: +			var html = $.map(paletteArray, function (palette, i) {
>, <Line: +				return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i);
>, <Line: +			});
>, <Line: +			if (selectionPalette) {
>, <Line: +				html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection"));
>, <Line: +			}
>, <Line: +			paletteContainer.html(html.join(""));
>, <Line: +		}
>, <Line: +		function drawInitial() {
>, <Line: +			if (opts.showInitial) {
>, <Line: +				var initial = colorOnShow;
>, <Line: +				var current = get();
>, <Line: +				initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial"));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function dragStart() {
>, <Line: +			if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
>, <Line: +				reflow();
>, <Line: +			}
>, <Line: +			container.addClass(draggingClass);
>, <Line: +			shiftMovementDirection = null;
>, <Line: +			boundElement.trigger('dragstart.spectrum', [get()]);
>, <Line: +		}
>, <Line: +		function dragStop() {
>, <Line: +			container.removeClass(draggingClass);
>, <Line: +			boundElement.trigger('dragstop.spectrum', [get()]);
>, <Line: +		}
>, <Line: +		function setFromTextInput() {
>, <Line: +			var value = textInput.val();
>, <Line: +			if ((value === null || value === "") && allowEmpty) {
>, <Line: +				set(null);
>, <Line: +				updateOriginalInput(true);
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				var tiny = tinycolor(value);
>, <Line: +				if (tiny.ok) {
>, <Line: +					set(tiny);
>, <Line: +					updateOriginalInput(true);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					textInput.addClass("sp-validation-error");
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function toggle() {
>, <Line: +			if (visible) {
>, <Line: +				hide();
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				show();
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function show() {
>, <Line: +			var event = $.Event('beforeShow.spectrum');
>, <Line: +			if (visible) {
>, <Line: +				reflow();
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			boundElement.trigger(event, [get()]);
>, <Line: +			if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			hideAll();
>, <Line: +			visible = true;
>, <Line: +			$(doc).bind("click.spectrum", hide);
>, <Line: +			$(window).bind("resize.spectrum", resize);
>, <Line: +			replacer.addClass("sp-active");
>, <Line: +			container.removeClass("sp-hidden");
>, <Line: +			reflow();
>, <Line: +			updateUI();
>, <Line: +			colorOnShow = get();
>, <Line: +			drawInitial();
>, <Line: +			callbacks.show(colorOnShow);
>, <Line: +			boundElement.trigger('show.spectrum', [colorOnShow]);
>, <Line: +		}
>, <Line: +		function hide(e) {
>, <Line: +			// Return on right click
>, <Line: +			if (e && e.type == "click" && e.button == 2) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			// Return if hiding is unnecessary
>, <Line: +			if (!visible || flat) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			visible = false;
>, <Line: +			$(doc).unbind("click.spectrum", hide);
>, <Line: +			$(window).unbind("resize.spectrum", resize);
>, <Line: +			replacer.removeClass("sp-active");
>, <Line: +			container.addClass("sp-hidden");
>, <Line: +			var colorHasChanged = !tinycolor.equals(get(), colorOnShow);
>, <Line: +			if (colorHasChanged) {
>, <Line: +				if (clickoutFiresChange && e !== "cancel") {
>, <Line: +					updateOriginalInput(true);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					revert();
>, <Line: +				}
>, <Line: +			}
>, <Line: +			callbacks.hide(get());
>, <Line: +			boundElement.trigger('hide.spectrum', [get()]);
>, <Line: +		}
>, <Line: +		function revert() {
>, <Line: +			set(colorOnShow, true);
>, <Line: +		}
>, <Line: +		function set(color, ignoreFormatChange) {
>, <Line: +			if (tinycolor.equals(color, get())) {
>, <Line: +				// Update UI just in case a validation error needs
>, <Line: +				// to be cleared.
>, <Line: +				updateUI();
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			var newColor, newHsv;
>, <Line: +			if (!color && allowEmpty) {
>, <Line: +				isEmpty = true;
>, <Line: +			} else {
>, <Line: +				isEmpty = false;
>, <Line: +				newColor = tinycolor(color);
>, <Line: +				newHsv = newColor.toHsv();
>, <Line: +				currentHue = (newHsv.h % 360) / 360;
>, <Line: +				currentSaturation = newHsv.s;
>, <Line: +				currentValue = newHsv.v;
>, <Line: +				currentAlpha = newHsv.a;
>, <Line: +			}
>, <Line: +			updateUI();
>, <Line: +			if (newColor && newColor.ok && !ignoreFormatChange) {
>, <Line: +				currentPreferredFormat = preferredFormat || newColor.format;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function get(opts) {
>, <Line: +			opts = opts || {};
>, <Line: +			if (allowEmpty && isEmpty) {
>, <Line: +				return null;
>, <Line: +			}
>, <Line: +			return tinycolor.fromRatio({
>, <Line: +				h: currentHue,
>, <Line: +				s: currentSaturation,
>, <Line: +				v: currentValue,
>, <Line: +				a: Math.round(currentAlpha * 100) / 100
>, <Line: +			}, {format: opts.format || currentPreferredFormat});
>, <Line: +		}
>, <Line: +		function isValid() {
>, <Line: +			return !textInput.hasClass("sp-validation-error");
>, <Line: +		}
>, <Line: +		function move() {
>, <Line: +			updateUI();
>, <Line: +			callbacks.move(get());
>, <Line: +			boundElement.trigger('move.spectrum', [get()]);
>, <Line: +		}
>, <Line: +		function updateUI() {
>, <Line: +			textInput.removeClass("sp-validation-error");
>, <Line: +			updateHelperLocations();
>, <Line: +			// Update dragger background color (gradients take care of saturation and value).
>, <Line: +			var flatColor = tinycolor.fromRatio({h: currentHue, s: 1, v: 1});
>, <Line: +			dragger.css("background-color", flatColor.toHexString());
>, <Line: +			// Get a format that alpha will be included in (hex and names ignore alpha)
>, <Line: +			var format = currentPreferredFormat;
>, <Line: +			if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
>, <Line: +				if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
>, <Line: +					format = "rgb";
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var realColor = get({format: format}),
>, <Line: +				displayColor = '';
>, <Line: +			//reset background info for preview element
>, <Line: +			previewElement.removeClass("sp-clear-display");
>, <Line: +			previewElement.css('background-color', 'transparent');
>, <Line: +			if (!realColor && allowEmpty) {
>, <Line: +				// Update the replaced elements background with icon indicating no color selection
>, <Line: +				previewElement.addClass("sp-clear-display");
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				var realHex = realColor.toHexString(),
>, <Line: +					realRgb = realColor.toRgbString();
>, <Line: +				// Update the replaced elements background color (with actual selected color)
>, <Line: +				if (rgbaSupport || realColor.alpha === 1) {
>, <Line: +					previewElement.css("background-color", realRgb);
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					previewElement.css("background-color", "transparent");
>, <Line: +					previewElement.css("filter", realColor.toFilter());
>, <Line: +				}
>, <Line: +				if (opts.showAlpha) {
>, <Line: +					var rgb = realColor.toRgb();
>, <Line: +					rgb.a = 0;
>, <Line: +					var realAlpha = tinycolor(rgb).toRgbString();
>, <Line: +					var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";
>, <Line: +					if (IE) {
>, <Line: +						alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({gradientType: 1}, realHex));
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						alphaSliderInner.css("background", "-webkit-" + gradient);
>, <Line: +						alphaSliderInner.css("background", "-moz-" + gradient);
>, <Line: +						alphaSliderInner.css("background", "-ms-" + gradient);
>, <Line: +						alphaSliderInner.css("background", gradient);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				displayColor = realColor.toString(format);
>, <Line: +			}
>, <Line: +			// Update the text entry input as it changes happen
>, <Line: +			if (opts.showInput) {
>, <Line: +				textInput.val(displayColor);
>, <Line: +			}
>, <Line: +			if (opts.showPalette) {
>, <Line: +				drawPalette();
>, <Line: +			}
>, <Line: +			drawInitial();
>, <Line: +		}
>, <Line: +		function updateHelperLocations() {
>, <Line: +			var s = currentSaturation;
>, <Line: +			var v = currentValue;
>, <Line: +			if (allowEmpty && isEmpty) {
>, <Line: +				//if selected color is empty, hide the helpers
>, <Line: +				alphaSlideHelper.hide();
>, <Line: +				slideHelper.hide();
>, <Line: +				dragHelper.hide();
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				//make sure helpers are visible
>, <Line: +				alphaSlideHelper.show();
>, <Line: +				slideHelper.show();
>, <Line: +				dragHelper.show();
>, <Line: +				// Where to show the little circle in that displays your current selected color
>, <Line: +				var dragX = s * dragWidth;
>, <Line: +				var dragY = dragHeight - (v * dragHeight);
>, <Line: +				dragX = Math.max(
>, <Line: +					-dragHelperHeight,
>, <Line: +					Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
>, <Line: +				);
>, <Line: +				dragY = Math.max(
>, <Line: +					-dragHelperHeight,
>, <Line: +					Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
>, <Line: +				);
>, <Line: +				dragHelper.css({
>, <Line: +					"top": dragY + "px",
>, <Line: +					"left": dragX + "px"
>, <Line: +				});
>, <Line: +				var alphaX = currentAlpha * alphaWidth;
>, <Line: +				alphaSlideHelper.css({
>, <Line: +					"left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
>, <Line: +				});
>, <Line: +				// Where to show the bar that displays your current selected hue
>, <Line: +				var slideY = (currentHue) * slideHeight;
>, <Line: +				slideHelper.css({
>, <Line: +					"top": (slideY - slideHelperHeight) + "px"
>, <Line: +				});
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function updateOriginalInput(fireCallback) {
>, <Line: +			var color = get(),
>, <Line: +				displayColor = '',
>, <Line: +				hasChanged = !tinycolor.equals(color, colorOnShow);
>, <Line: +			if (color) {
>, <Line: +				displayColor = color.toString(currentPreferredFormat);
>, <Line: +				// Update the selection palette with the current color
>, <Line: +				addColorToSelectionPalette(color);
>, <Line: +			}
>, <Line: +			if (isInput) {
>, <Line: +				boundElement.val(displayColor);
>, <Line: +			}
>, <Line: +			colorOnShow = color;
>, <Line: +			if (fireCallback && hasChanged) {
>, <Line: +				callbacks.change(color);
>, <Line: +				boundElement.trigger('change', [color]);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function reflow() {
>, <Line: +			dragWidth = dragger.width();
>, <Line: +			dragHeight = dragger.height();
>, <Line: +			dragHelperHeight = dragHelper.height();
>, <Line: +			slideWidth = slider.width();
>, <Line: +			slideHeight = slider.height();
>, <Line: +			slideHelperHeight = slideHelper.height();
>, <Line: +			alphaWidth = alphaSlider.width();
>, <Line: +			alphaSlideHelperWidth = alphaSlideHelper.width();
>, <Line: +			if (!flat) {
>, <Line: +				container.css("position", "absolute");
>, <Line: +				container.offset(getOffset(container, offsetElement));
>, <Line: +			}
>, <Line: +			updateHelperLocations();
>, <Line: +			if (opts.showPalette) {
>, <Line: +				drawPalette();
>, <Line: +			}
>, <Line: +			boundElement.trigger('reflow.spectrum');
>, <Line: +		}
>, <Line: +		function destroy() {
>, <Line: +			boundElement.show();
>, <Line: +			offsetElement.unbind("click.spectrum touchstart.spectrum");
>, <Line: +			container.remove();
>, <Line: +			replacer.remove();
>, <Line: +			spectrums[spect.id] = null;
>, <Line: +		}
>, <Line: +		function option(optionName, optionValue) {
>, <Line: +			if (optionName === undefined) {
>, <Line: +				return $.extend({}, opts);
>, <Line: +			}
>, <Line: +			if (optionValue === undefined) {
>, <Line: +				return opts[optionName];
>, <Line: +			}
>, <Line: +			opts[optionName] = optionValue;
>, <Line: +			applyOptions();
>, <Line: +		}
>, <Line: +		function enable() {
>, <Line: +			disabled = false;
>, <Line: +			boundElement.attr("disabled", false);
>, <Line: +			offsetElement.removeClass("sp-disabled");
>, <Line: +		}
>, <Line: +		function disable() {
>, <Line: +			hide();
>, <Line: +			disabled = true;
>, <Line: +			boundElement.attr("disabled", true);
>, <Line: +			offsetElement.addClass("sp-disabled");
>, <Line: +		}
>, <Line: +		initialize();
>, <Line: +		var spect = {
>, <Line: +			show: show,
>, <Line: +			hide: hide,
>, <Line: +			toggle: toggle,
>, <Line: +			reflow: reflow,
>, <Line: +			option: option,
>, <Line: +			enable: enable,
>, <Line: +			disable: disable,
>, <Line: +			set: function (c) {
>, <Line: +				set(c);
>, <Line: +				updateOriginalInput();
>, <Line: +			},
>, <Line: +			get: get,
>, <Line: +			destroy: destroy,
>, <Line: +			container: container
>, <Line: +		};
>, <Line: +		spect.id = spectrums.push(spect) - 1;
>, <Line: +		return spect;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * checkOffset - get the offset below/above and left/right element depending on screen position
>, <Line: +	 * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
>, <Line: +	 */
>, <Line: +	function getOffset(picker, input) {
>, <Line: +		var extraY = 0;
>, <Line: +		var dpWidth = picker.outerWidth();
>, <Line: +		var dpHeight = picker.outerHeight();
>, <Line: +		var inputHeight = input.outerHeight();
>, <Line: +		var doc = picker[0].ownerDocument;
>, <Line: +		var docElem = doc.documentElement;
>, <Line: +		var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
>, <Line: +		var viewHeight = docElem.clientHeight + $(doc).scrollTop();
>, <Line: +		var offset = input.offset();
>, <Line: +		offset.top += inputHeight;
>, <Line: +		offset.left -=
>, <Line: +			Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
>, <Line: +				Math.abs(offset.left + dpWidth - viewWidth) : 0);
>, <Line: +		offset.top -=
>, <Line: +			Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
>, <Line: +				Math.abs(dpHeight + inputHeight - extraY) : extraY));
>, <Line: +		return offset;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * noop - do nothing
>, <Line: +	 */
>, <Line: +	function noop() {
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * stopPropagation - makes the code only doing this a little easier to read in line
>, <Line: +	 */
>, <Line: +	function stopPropagation(e) {
>, <Line: +		e.stopPropagation();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Create a function bound to a given object
>, <Line: +	 * Thanks to underscore.js
>, <Line: +	 */
>, <Line: +	function bind(func, obj) {
>, <Line: +		var slice = Array.prototype.slice;
>, <Line: +		var args = slice.call(arguments, 2);
>, <Line: +		return function () {
>, <Line: +			return func.apply(obj, args.concat(slice.call(arguments)));
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Lightweight drag helper.  Handles containment within the element, so that
>, <Line: +	 * when dragging, the x is within [0,element.width] and y is within [0,element.height]
>, <Line: +	 */
>, <Line: +	function draggable(element, onmove, onstart, onstop) {
>, <Line: +		onmove = onmove || function () {
>, <Line: +			};
>, <Line: +		onstart = onstart || function () {
>, <Line: +			};
>, <Line: +		onstop = onstop || function () {
>, <Line: +			};
>, <Line: +		var doc = element.ownerDocument || document;
>, <Line: +		var dragging = false;
>, <Line: +		var offset = {};
>, <Line: +		var maxHeight = 0;
>, <Line: +		var maxWidth = 0;
>, <Line: +		var hasTouch = ('ontouchstart' in window);
>, <Line: +		var duringDragEvents = {};
>, <Line: +		duringDragEvents["selectstart"] = prevent;
>, <Line: +		duringDragEvents["dragstart"] = prevent;
>, <Line: +		duringDragEvents["touchmove mousemove"] = move;
>, <Line: +		duringDragEvents["touchend mouseup"] = stop;
>, <Line: +		function prevent(e) {
>, <Line: +			if (e.stopPropagation) {
>, <Line: +				e.stopPropagation();
>, <Line: +			}
>, <Line: +			if (e.preventDefault) {
>, <Line: +				e.preventDefault();
>, <Line: +			}
>, <Line: +			e.returnValue = false;
>, <Line: +		}
>, <Line: +		function move(e) {
>, <Line: +			if (dragging) {
>, <Line: +				// Mouseup happened outside of window
>, <Line: +				if (IE && document.documentMode < 9 && !e.button) {
>, <Line: +					return stop();
>, <Line: +				}
>, <Line: +				var touches = e.originalEvent.touches;
>, <Line: +				var pageX = touches ? touches[0].pageX : e.pageX;
>, <Line: +				var pageY = touches ? touches[0].pageY : e.pageY;
>, <Line: +				var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
>, <Line: +				var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
>, <Line: +				if (hasTouch) {
>, <Line: +					// Stop scrolling in iOS
>, <Line: +					prevent(e);
>, <Line: +				}
>, <Line: +				onmove.apply(element, [dragX, dragY, e]);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function start(e) {
>, <Line: +			var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);
>, <Line: +			var touches = e.originalEvent.touches;
>, <Line: +			if (!rightclick && !dragging) {
>, <Line: +				if (onstart.apply(element, arguments) !== false) {
>, <Line: +					dragging = true;
>, <Line: +					maxHeight = $(element).height();
>, <Line: +					maxWidth = $(element).width();
>, <Line: +					offset = $(element).offset();
>, <Line: +					$(doc).bind(duringDragEvents);
>, <Line: +					$(doc.body).addClass("sp-dragging");
>, <Line: +					if (!hasTouch) {
>, <Line: +						move(e);
>, <Line: +					}
>, <Line: +					prevent(e);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function stop() {
>, <Line: +			if (dragging) {
>, <Line: +				$(doc).unbind(duringDragEvents);
>, <Line: +				$(doc.body).removeClass("sp-dragging");
>, <Line: +				onstop.apply(element, arguments);
>, <Line: +			}
>, <Line: +			dragging = false;
>, <Line: +		}
>, <Line: +		$(element).bind("touchstart mousedown", start);
>, <Line: +	}
>, <Line: +	function throttle(func, wait, debounce) {
>, <Line: +		var timeout;
>, <Line: +		return function () {
>, <Line: +			var context = this, args = arguments;
>, <Line: +			var throttler = function () {
>, <Line: +				timeout = null;
>, <Line: +				func.apply(context, args);
>, <Line: +			};
>, <Line: +			if (debounce) clearTimeout(timeout);
>, <Line: +			if (debounce || !timeout) timeout = setTimeout(throttler, wait);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function log() {/* jshint -W021 */
>, <Line: +		if (window.console) {
>, <Line: +			if (Function.prototype.bind)log = Function.prototype.bind.call(console.log, console); else log = function () {
>, <Line: +				Function.prototype.apply.call(console.log, console, arguments);
>, <Line: +			};
>, <Line: +			log.apply(this, arguments);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Define a jQuery plugin
>, <Line: +	 */
>, <Line: +	var dataID = "spectrum.id";
>, <Line: +	$.fn.spectrum = function (opts, extra) {
>, <Line: +		if (typeof opts == "string") {
>, <Line: +			var returnValue = this;
>, <Line: +			var args = Array.prototype.slice.call(arguments, 1);
>, <Line: +			this.each(function () {
>, <Line: +				var spect = spectrums[$(this).data(dataID)];
>, <Line: +				if (spect) {
>, <Line: +					var method = spect[opts];
>, <Line: +					if (!method) {
>, <Line: +						throw new Error("Spectrum: no such method: '" + opts + "'");
>, <Line: +					}
>, <Line: +					if (opts == "get") {
>, <Line: +						returnValue = spect.get();
>, <Line: +					}
>, <Line: +					else if (opts == "container") {
>, <Line: +						returnValue = spect.container;
>, <Line: +					}
>, <Line: +					else if (opts == "option") {
>, <Line: +						returnValue = spect.option.apply(spect, args);
>, <Line: +					}
>, <Line: +					else if (opts == "destroy") {
>, <Line: +						spect.destroy();
>, <Line: +						$(this).removeData(dataID);
>, <Line: +					}
>, <Line: +					else {
>, <Line: +						method.apply(spect, args);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return returnValue;
>, <Line: +		}
>, <Line: +		// Initializing a new instance of spectrum
>, <Line: +		return this.spectrum("destroy").each(function () {
>, <Line: +			var options = $.extend({}, opts, $(this).data());
>, <Line: +			var spect = spectrum(this, options);
>, <Line: +			$(this).data(dataID, spect.id);
>, <Line: +		});
>, <Line: +	};
>, <Line: +	$.fn.spectrum.load = true;
>, <Line: +	$.fn.spectrum.loadOpts = {};
>, <Line: +	$.fn.spectrum.draggable = draggable;
>, <Line: +	$.fn.spectrum.defaults = defaultOpts;
>, <Line: +	$.spectrum = {};
>, <Line: +	$.spectrum.localization = {};
>, <Line: +	$.spectrum.palettes = {};
>, <Line: +	$.fn.spectrum.processNativeColorInputs = function () {
>, <Line: +		if (!inputTypeColorSupport) {
>, <Line: +			$("input[type=color]").spectrum({
>, <Line: +				preferredFormat: "hex6"
>, <Line: +			});
>, <Line: +		}
>, <Line: +	};
>, <Line: +	// TinyColor v0.9.16
>, <Line: +	// https://github.com/bgrins/TinyColor
>, <Line: +	// 2013-08-10, Brian Grinstead, MIT License
>, <Line: +	(function () {
>, <Line: +		var trimLeft = /^[\s,#]+/,
>, <Line: +			trimRight = /\s+$/,
>, <Line: +			tinyCounter = 0,
>, <Line: +			math = Math,
>, <Line: +			mathRound = math.round,
>, <Line: +			mathMin = math.min,
>, <Line: +			mathMax = math.max,
>, <Line: +			mathRandom = math.random;
>, <Line: +		function tinycolor(color, opts) {
>, <Line: +			color = (color) ? color : '';
>, <Line: +			opts = opts || {};
>, <Line: +			// If input is already a tinycolor, return itself
>, <Line: +			if (typeof color == "object" && color.hasOwnProperty("_tc_id")) {
>, <Line: +				return color;
>, <Line: +			}
>, <Line: +			var rgb = inputToRGB(color);
>, <Line: +			var r = rgb.r,
>, <Line: +				g = rgb.g,
>, <Line: +				b = rgb.b,
>, <Line: +				a = rgb.a,
>, <Line: +				roundA = mathRound(100 * a) / 100,
>, <Line: +				format = opts.format || rgb.format;
>, <Line: +			// Don't let the range of [0,255] come back in [0,1].
>, <Line: +			// Potentially lose a little bit of precision here, but will fix issues where
>, <Line: +			// .5 gets interpreted as half of the total, instead of half of 1
>, <Line: +			// If it was supposed to be 128, this was already taken care of by `inputToRgb`
>, <Line: +			if (r < 1) {
>, <Line: +				r = mathRound(r);
>, <Line: +			}
>, <Line: +			if (g < 1) {
>, <Line: +				g = mathRound(g);
>, <Line: +			}
>, <Line: +			if (b < 1) {
>, <Line: +				b = mathRound(b);
>, <Line: +			}
>, <Line: +			return {
>, <Line: +				ok: rgb.ok,
>, <Line: +				format: format,
>, <Line: +				_tc_id: tinyCounter++,
>, <Line: +				alpha: a,
>, <Line: +				getAlpha: function () {
>, <Line: +					return a;
>, <Line: +				},
>, <Line: +				setAlpha: function (value) {
>, <Line: +					a = boundAlpha(value);
>, <Line: +					roundA = mathRound(100 * a) / 100;
>, <Line: +				},
>, <Line: +				toHsv: function () {
>, <Line: +					var hsv = rgbToHsv(r, g, b);
>, <Line: +					return {h: hsv.h * 360, s: hsv.s, v: hsv.v, a: a};
>, <Line: +				},
>, <Line: +				toHsvString: function () {
>, <Line: +					var hsv = rgbToHsv(r, g, b);
>, <Line: +					var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
>, <Line: +					return (a == 1) ?
>, <Line: +					"hsv(" + h + ", " + s + "%, " + v + "%)" :
>, <Line: +					"hsva(" + h + ", " + s + "%, " + v + "%, " + roundA + ")";
>, <Line: +				},
>, <Line: +				toHsl: function () {
>, <Line: +					var hsl = rgbToHsl(r, g, b);
>, <Line: +					return {h: hsl.h * 360, s: hsl.s, l: hsl.l, a: a};
>, <Line: +				},
>, <Line: +				toHslString: function () {
>, <Line: +					var hsl = rgbToHsl(r, g, b);
>, <Line: +					var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
>, <Line: +					return (a == 1) ?
>, <Line: +					"hsl(" + h + ", " + s + "%, " + l + "%)" :
>, <Line: +					"hsla(" + h + ", " + s + "%, " + l + "%, " + roundA + ")";
>, <Line: +				},
>, <Line: +				toHex: function (allow3Char) {
>, <Line: +					return rgbToHex(r, g, b, allow3Char);
>, <Line: +				},
>, <Line: +				toHexString: function (allow3Char) {
>, <Line: +					return '#' + rgbToHex(r, g, b, allow3Char);
>, <Line: +				},
>, <Line: +				toRgb: function () {
>, <Line: +					return {
>, <Line: +						r: mathRound(r),
>, <Line: +						g: mathRound(g),
>, <Line: +						b: mathRound(b),
>, <Line: +						a: a
>, <Line: +					};
>, <Line: +				},
>, <Line: +				toRgbString: function () {
>, <Line: +					return (a == 1) ?
>, <Line: +					"rgb(" + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ")" :
>, <Line: +					"rgba(" + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ", " + roundA + ")";
>, <Line: +				},
>, <Line: +				toPercentageRgb: function () {
>, <Line: +					return {
>, <Line: +						r: mathRound(bound01(r, 255) * 100) + "%",
>, <Line: +						g: mathRound(bound01(g, 255) * 100) + "%",
>, <Line: +						b: mathRound(bound01(b, 255) * 100) + "%",
>, <Line: +						a: a
>, <Line: +					};
>, <Line: +				},
>, <Line: +				toPercentageRgbString: function () {
>, <Line: +					return (a == 1) ?
>, <Line: +					"rgb(" + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%)" :
>, <Line: +					"rgba(" + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%, " + roundA + ")";
>, <Line: +				},
>, <Line: +				toName: function () {
>, <Line: +					if (a === 0) {
>, <Line: +						return "transparent";
>, <Line: +					}
>, <Line: +					return hexNames[rgbToHex(r, g, b, true)] || false;
>, <Line: +				},
>, <Line: +				toFilter: function (secondColor) {
>, <Line: +					var hex = rgbToHex(r, g, b);
>, <Line: +					var secondHex = hex;
>, <Line: +					var alphaHex = Math.round(parseFloat(a) * 255).toString(16);
>, <Line: +					var secondAlphaHex = alphaHex;
>, <Line: +					var gradientType = opts && opts.gradientType ? "GradientType = 1, " : "";
>, <Line: +					if (secondColor) {
>, <Line: +						var s = tinycolor(secondColor);
>, <Line: +						secondHex = s.toHex();
>, <Line: +						secondAlphaHex = Math.round(parseFloat(s.alpha) * 255).toString(16);
>, <Line: +					}
>, <Line: +					return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=#" + pad2(alphaHex) + hex + ",endColorstr=#" + pad2(secondAlphaHex) + secondHex + ")";
>, <Line: +				},
>, <Line: +				toString: function (format) {
>, <Line: +					var formatSet = !!format;
>, <Line: +					format = format || this.format;
>, <Line: +					var formattedString = false;
>, <Line: +					var hasAlphaAndFormatNotSet = !formatSet && a < 1 && a > 0;
>, <Line: +					var formatWithAlpha = hasAlphaAndFormatNotSet && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
>, <Line: +					if (format === "rgb") {
>, <Line: +						formattedString = this.toRgbString();
>, <Line: +					}
>, <Line: +					if (format === "prgb") {
>, <Line: +						formattedString = this.toPercentageRgbString();
>, <Line: +					}
>, <Line: +					if (format === "hex" || format === "hex6") {
>, <Line: +						formattedString = this.toHexString();
>, <Line: +					}
>, <Line: +					if (format === "hex3") {
>, <Line: +						formattedString = this.toHexString(true);
>, <Line: +					}
>, <Line: +					if (format === "name") {
>, <Line: +						formattedString = this.toName();
>, <Line: +					}
>, <Line: +					if (format === "hsl") {
>, <Line: +						formattedString = this.toHslString();
>, <Line: +					}
>, <Line: +					if (format === "hsv") {
>, <Line: +						formattedString = this.toHsvString();
>, <Line: +					}
>, <Line: +					if (formatWithAlpha) {
>, <Line: +						return this.toRgbString();
>, <Line: +					}
>, <Line: +					return formattedString || this.toHexString();
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}
>, <Line: +		// If input is an object, force 1 into "1.0" to handle ratios properly
>, <Line: +		// String input requires "1.0" as input, so 1 will be treated as 1
>, <Line: +		tinycolor.fromRatio = function (color, opts) {
>, <Line: +			if (typeof color == "object") {
>, <Line: +				var newColor = {};
>, <Line: +				for (var i in color) {
>, <Line: +					if (color.hasOwnProperty(i)) {
>, <Line: +						if (i === "a") {
>, <Line: +							newColor[i] = color[i];
>, <Line: +						}
>, <Line: +						else {
>, <Line: +							newColor[i] = convertToPercentage(color[i]);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				color = newColor;
>, <Line: +			}
>, <Line: +			return tinycolor(color, opts);
>, <Line: +		};
>, <Line: +		// Given a string or object, convert that input to RGB
>, <Line: +		// Possible string inputs:
>, <Line: +		//
>, <Line: +		//     "red"
>, <Line: +		//     "#f00" or "f00"
>, <Line: +		//     "#ff0000" or "ff0000"
>, <Line: +		//     "rgb 255 0 0" or "rgb (255, 0, 0)"
>, <Line: +		//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
>, <Line: +		//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
>, <Line: +		//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
>, <Line: +		//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
>, <Line: +		//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
>, <Line: +		//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
>, <Line: +		//
>, <Line: +		function inputToRGB(color) {
>, <Line: +			var rgb = {r: 0, g: 0, b: 0};
>, <Line: +			var a = 1;
>, <Line: +			var ok = false;
>, <Line: +			var format = false;
>, <Line: +			if (typeof color == "string") {
>, <Line: +				color = stringInputToObject(color);
>, <Line: +			}
>, <Line: +			if (typeof color == "object") {
>, <Line: +				if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
>, <Line: +					rgb = rgbToRgb(color.r, color.g, color.b);
>, <Line: +					ok = true;
>, <Line: +					format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
>, <Line: +				}
>, <Line: +				else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
>, <Line: +					color.s = convertToPercentage(color.s);
>, <Line: +					color.v = convertToPercentage(color.v);
>, <Line: +					rgb = hsvToRgb(color.h, color.s, color.v);
>, <Line: +					ok = true;
>, <Line: +					format = "hsv";
>, <Line: +				}
>, <Line: +				else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
>, <Line: +					color.s = convertToPercentage(color.s);
>, <Line: +					color.l = convertToPercentage(color.l);
>, <Line: +					rgb = hslToRgb(color.h, color.s, color.l);
>, <Line: +					ok = true;
>, <Line: +					format = "hsl";
>, <Line: +				}
>, <Line: +				if (color.hasOwnProperty("a")) {
>, <Line: +					a = color.a;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			a = boundAlpha(a);
>, <Line: +			return {
>, <Line: +				ok: ok,
>, <Line: +				format: color.format || format,
>, <Line: +				r: mathMin(255, mathMax(rgb.r, 0)),
>, <Line: +				g: mathMin(255, mathMax(rgb.g, 0)),
>, <Line: +				b: mathMin(255, mathMax(rgb.b, 0)),
>, <Line: +				a: a
>, <Line: +			};
>, <Line: +		}
>, <Line: +		// Conversion Functions
>, <Line: +		// --------------------
>, <Line: +		// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
>, <Line: +		// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
>, <Line: +		// `rgbToRgb`
>, <Line: +		// Handle bounds / percentage checking to conform to CSS color spec
>, <Line: +		// <http://www.w3.org/TR/css3-color/>
>, <Line: +		// *Assumes:* r, g, b in [0, 255] or [0, 1]
>, <Line: +		// *Returns:* { r, g, b } in [0, 255]
>, <Line: +		function rgbToRgb(r, g, b) {
>, <Line: +			return {
>, <Line: +				r: bound01(r, 255) * 255,
>, <Line: +				g: bound01(g, 255) * 255,
>, <Line: +				b: bound01(b, 255) * 255
>, <Line: +			};
>, <Line: +		}
>, <Line: +		// `rgbToHsl`
>, <Line: +		// Converts an RGB color value to HSL.
>, <Line: +		// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
>, <Line: +		// *Returns:* { h, s, l } in [0,1]
>, <Line: +		function rgbToHsl(r, g, b) {
>, <Line: +			r = bound01(r, 255);
>, <Line: +			g = bound01(g, 255);
>, <Line: +			b = bound01(b, 255);
>, <Line: +			var max = mathMax(r, g, b), min = mathMin(r, g, b);
>, <Line: +			var h, s, l = (max + min) / 2;
>, <Line: +			if (max == min) {
>, <Line: +				h = s = 0; // achromatic
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				var d = max - min;
>, <Line: +				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
>, <Line: +				switch (max) {
>, <Line: +					case r:
>, <Line: +						h = (g - b) / d + (g < b ? 6 : 0);
>, <Line: +						break;
>, <Line: +					case g:
>, <Line: +						h = (b - r) / d + 2;
>, <Line: +						break;
>, <Line: +					case b:
>, <Line: +						h = (r - g) / d + 4;
>, <Line: +						break;
>, <Line: +				}
>, <Line: +				h /= 6;
>, <Line: +			}
>, <Line: +			return {h: h, s: s, l: l};
>, <Line: +		}
>, <Line: +		// `hslToRgb`
>, <Line: +		// Converts an HSL color value to RGB.
>, <Line: +		// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
>, <Line: +		// *Returns:* { r, g, b } in the set [0, 255]
>, <Line: +		function hslToRgb(h, s, l) {
>, <Line: +			var r, g, b;
>, <Line: +			h = bound01(h, 360);
>, <Line: +			s = bound01(s, 100);
>, <Line: +			l = bound01(l, 100);
>, <Line: +			function hue2rgb(p, q, t) {
>, <Line: +				if (t < 0) t += 1;
>, <Line: +				if (t > 1) t -= 1;
>, <Line: +				if (t < 1 / 6) return p + (q - p) * 6 * t;
>, <Line: +				if (t < 1 / 2) return q;
>, <Line: +				if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
>, <Line: +				return p;
>, <Line: +			}
>, <Line: +			if (s === 0) {
>, <Line: +				r = g = b = l; // achromatic
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
>, <Line: +				var p = 2 * l - q;
>, <Line: +				r = hue2rgb(p, q, h + 1 / 3);
>, <Line: +				g = hue2rgb(p, q, h);
>, <Line: +				b = hue2rgb(p, q, h - 1 / 3);
>, <Line: +			}
>, <Line: +			return {r: r * 255, g: g * 255, b: b * 255};
>, <Line: +		}
>, <Line: +		// `rgbToHsv`
>, <Line: +		// Converts an RGB color value to HSV
>, <Line: +		// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
>, <Line: +		// *Returns:* { h, s, v } in [0,1]
>, <Line: +		function rgbToHsv(r, g, b) {
>, <Line: +			r = bound01(r, 255);
>, <Line: +			g = bound01(g, 255);
>, <Line: +			b = bound01(b, 255);
>, <Line: +			var max = mathMax(r, g, b), min = mathMin(r, g, b);
>, <Line: +			var h, s, v = max;
>, <Line: +			var d = max - min;
>, <Line: +			s = max === 0 ? 0 : d / max;
>, <Line: +			if (max == min) {
>, <Line: +				h = 0; // achromatic
>, <Line: +			}
>, <Line: +			else {
>, <Line: +				switch (max) {
>, <Line: +					case r:
>, <Line: +						h = (g - b) / d + (g < b ? 6 : 0);
>, <Line: +						break;
>, <Line: +					case g:
>, <Line: +						h = (b - r) / d + 2;
>, <Line: +						break;
>, <Line: +					case b:
>, <Line: +						h = (r - g) / d + 4;
>, <Line: +						break;
>, <Line: +				}
>, <Line: +				h /= 6;
>, <Line: +			}
>, <Line: +			return {h: h, s: s, v: v};
>, <Line: +		}
>, <Line: +		// `hsvToRgb`
>, <Line: +		// Converts an HSV color value to RGB.
>, <Line: +		// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
>, <Line: +		// *Returns:* { r, g, b } in the set [0, 255]
>, <Line: +		function hsvToRgb(h, s, v) {
>, <Line: +			h = bound01(h, 360) * 6;
>, <Line: +			s = bound01(s, 100);
>, <Line: +			v = bound01(v, 100);
>, <Line: +			var i = math.floor(h),
>, <Line: +				f = h - i,
>, <Line: +				p = v * (1 - s),
>, <Line: +				q = v * (1 - f * s),
>, <Line: +				t = v * (1 - (1 - f) * s),
>, <Line: +				mod = i % 6,
>, <Line: +				r = [v, q, p, p, t, v][mod],
>, <Line: +				g = [t, v, v, q, p, p][mod],
>, <Line: +				b = [p, p, t, v, v, q][mod];
>, <Line: +			return {r: r * 255, g: g * 255, b: b * 255};
>, <Line: +		}
>, <Line: +		// `rgbToHex`
>, <Line: +		// Converts an RGB color to hex
>, <Line: +		// Assumes r, g, and b are contained in the set [0, 255]
>, <Line: +		// Returns a 3 or 6 character hex
>, <Line: +		function rgbToHex(r, g, b, allow3Char) {
>, <Line: +			var hex = [
>, <Line: +				pad2(mathRound(r).toString(16)),
>, <Line: +				pad2(mathRound(g).toString(16)),
>, <Line: +				pad2(mathRound(b).toString(16))
>, <Line: +			];
>, <Line: +			// Return a 3 character hex if possible
>, <Line: +			if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
>, <Line: +				return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
>, <Line: +			}
>, <Line: +			return hex.join("");
>, <Line: +		}
>, <Line: +		// `equals`
>, <Line: +		// Can be called with any tinycolor input
>, <Line: +		tinycolor.equals = function (color1, color2) {
>, <Line: +			if (!color1 || !color2) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
>, <Line: +		};
>, <Line: +		tinycolor.random = function () {
>, <Line: +			return tinycolor.fromRatio({
>, <Line: +				r: mathRandom(),
>, <Line: +				g: mathRandom(),
>, <Line: +				b: mathRandom()
>, <Line: +			});
>, <Line: +		};
>, <Line: +		// Modification Functions
>, <Line: +		// ----------------------
>, <Line: +		// Thanks to less.js for some of the basics here
>, <Line: +		// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>
>, <Line: +		tinycolor.desaturate = function (color, amount) {
>, <Line: +			amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			hsl.s -= amount / 100;
>, <Line: +			hsl.s = clamp01(hsl.s);
>, <Line: +			return tinycolor(hsl);
>, <Line: +		};
>, <Line: +		tinycolor.saturate = function (color, amount) {
>, <Line: +			amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			hsl.s += amount / 100;
>, <Line: +			hsl.s = clamp01(hsl.s);
>, <Line: +			return tinycolor(hsl);
>, <Line: +		};
>, <Line: +		tinycolor.greyscale = function (color) {
>, <Line: +			return tinycolor.desaturate(color, 100);
>, <Line: +		};
>, <Line: +		tinycolor.lighten = function (color, amount) {
>, <Line: +			amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			hsl.l += amount / 100;
>, <Line: +			hsl.l = clamp01(hsl.l);
>, <Line: +			return tinycolor(hsl);
>, <Line: +		};
>, <Line: +		tinycolor.darken = function (color, amount) {
>, <Line: +			amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			hsl.l -= amount / 100;
>, <Line: +			hsl.l = clamp01(hsl.l);
>, <Line: +			return tinycolor(hsl);
>, <Line: +		};
>, <Line: +		tinycolor.complement = function (color) {
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			hsl.h = (hsl.h + 180) % 360;
>, <Line: +			return tinycolor(hsl);
>, <Line: +		};
>, <Line: +		// Combination Functions
>, <Line: +		// ---------------------
>, <Line: +		// Thanks to jQuery xColor for some of the ideas behind these
>, <Line: +		// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>
>, <Line: +		tinycolor.triad = function (color) {
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			var h = hsl.h;
>, <Line: +			return [
>, <Line: +				tinycolor(color),
>, <Line: +				tinycolor({h: (h + 120) % 360, s: hsl.s, l: hsl.l}),
>, <Line: +				tinycolor({h: (h + 240) % 360, s: hsl.s, l: hsl.l})
>, <Line: +			];
>, <Line: +		};
>, <Line: +		tinycolor.tetrad = function (color) {
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			var h = hsl.h;
>, <Line: +			return [
>, <Line: +				tinycolor(color),
>, <Line: +				tinycolor({h: (h + 90) % 360, s: hsl.s, l: hsl.l}),
>, <Line: +				tinycolor({h: (h + 180) % 360, s: hsl.s, l: hsl.l}),
>, <Line: +				tinycolor({h: (h + 270) % 360, s: hsl.s, l: hsl.l})
>, <Line: +			];
>, <Line: +		};
>, <Line: +		tinycolor.splitcomplement = function (color) {
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			var h = hsl.h;
>, <Line: +			return [
>, <Line: +				tinycolor(color),
>, <Line: +				tinycolor({h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
>, <Line: +				tinycolor({h: (h + 216) % 360, s: hsl.s, l: hsl.l})
>, <Line: +			];
>, <Line: +		};
>, <Line: +		tinycolor.analogous = function (color, results, slices) {
>, <Line: +			results = results || 6;
>, <Line: +			slices = slices || 30;
>, <Line: +			var hsl = tinycolor(color).toHsl();
>, <Line: +			var part = 360 / slices;
>, <Line: +			var ret = [tinycolor(color)];
>, <Line: +			for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results;) {
>, <Line: +				hsl.h = (hsl.h + part) % 360;
>, <Line: +				ret.push(tinycolor(hsl));
>, <Line: +			}
>, <Line: +			return ret;
>, <Line: +		};
>, <Line: +		tinycolor.monochromatic = function (color, results) {
>, <Line: +			results = results || 6;
>, <Line: +			var hsv = tinycolor(color).toHsv();
>, <Line: +			var h = hsv.h, s = hsv.s, v = hsv.v;
>, <Line: +			var ret = [];
>, <Line: +			var modification = 1 / results;
>, <Line: +			while (results--) {
>, <Line: +				ret.push(tinycolor({h: h, s: s, v: v}));
>, <Line: +				v = (v + modification) % 1;
>, <Line: +			}
>, <Line: +			return ret;
>, <Line: +		};
>, <Line: +		// Readability Functions
>, <Line: +		// ---------------------
>, <Line: +		// <http://www.w3.org/TR/AERT#color-contrast>
>, <Line: +		// `readability`
>, <Line: +		// Analyze the 2 colors and returns an object with the following properties:
>, <Line: +		//    `brightness`: difference in brightness between the two colors
>, <Line: +		//    `color`: difference in color/hue between the two colors
>, <Line: +		tinycolor.readability = function (color1, color2) {
>, <Line: +			var a = tinycolor(color1).toRgb();
>, <Line: +			var b = tinycolor(color2).toRgb();
>, <Line: +			var brightnessA = (a.r * 299 + a.g * 587 + a.b * 114) / 1000;
>, <Line: +			var brightnessB = (b.r * 299 + b.g * 587 + b.b * 114) / 1000;
>, <Line: +			var colorDiff = (
>, <Line: +				Math.max(a.r, b.r) - Math.min(a.r, b.r) +
>, <Line: +				Math.max(a.g, b.g) - Math.min(a.g, b.g) +
>, <Line: +				Math.max(a.b, b.b) - Math.min(a.b, b.b)
>, <Line: +			);
>, <Line: +			return {
>, <Line: +				brightness: Math.abs(brightnessA - brightnessB),
>, <Line: +				color: colorDiff
>, <Line: +			};
>, <Line: +		};
>, <Line: +		// `readable`
>, <Line: +		// http://www.w3.org/TR/AERT#color-contrast
>, <Line: +		// Ensure that foreground and background color combinations provide sufficient contrast.
>, <Line: +		// *Example*
>, <Line: +		//    tinycolor.readable("#000", "#111") => false
>, <Line: +		tinycolor.readable = function (color1, color2) {
>, <Line: +			var readability = tinycolor.readability(color1, color2);
>, <Line: +			return readability.brightness > 125 && readability.color > 500;
>, <Line: +		};
>, <Line: +		// `mostReadable`
>, <Line: +		// Given a base color and a list of possible foreground or background
>, <Line: +		// colors for that base, returns the most readable color.
>, <Line: +		// *Example*
>, <Line: +		//    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
>, <Line: +		tinycolor.mostReadable = function (baseColor, colorList) {
>, <Line: +			var bestColor = null;
>, <Line: +			var bestScore = 0;
>, <Line: +			var bestIsReadable = false;
>, <Line: +			for (var i = 0; i < colorList.length; i++) {
>, <Line: +				// We normalize both around the "acceptable" breaking point,
>, <Line: +				// but rank brightness constrast higher than hue.
>, <Line: +				var readability = tinycolor.readability(baseColor, colorList[i]);
>, <Line: +				var readable = readability.brightness > 125 && readability.color > 500;
>, <Line: +				var score = 3 * (readability.brightness / 125) + (readability.color / 500);
>, <Line: +				if ((readable && !bestIsReadable) ||
>, <Line: +					(readable && bestIsReadable && score > bestScore) ||
>, <Line: +					((!readable) && (!bestIsReadable) && score > bestScore)) {
>, <Line: +					bestIsReadable = readable;
>, <Line: +					bestScore = score;
>, <Line: +					bestColor = tinycolor(colorList[i]);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return bestColor;
>, <Line: +		};
>, <Line: +		// Big List of Colors
>, <Line: +		// ------------------
>, <Line: +		// <http://www.w3.org/TR/css3-color/#svg-color>
>, <Line: +		var names = tinycolor.names = {
>, <Line: +			aliceblue: "f0f8ff",
>, <Line: +			antiquewhite: "faebd7",
>, <Line: +			aqua: "0ff",
>, <Line: +			aquamarine: "7fffd4",
>, <Line: +			azure: "f0ffff",
>, <Line: +			beige: "f5f5dc",
>, <Line: +			bisque: "ffe4c4",
>, <Line: +			black: "000",
>, <Line: +			blanchedalmond: "ffebcd",
>, <Line: +			blue: "00f",
>, <Line: +			blueviolet: "8a2be2",
>, <Line: +			brown: "a52a2a",
>, <Line: +			burlywood: "deb887",
>, <Line: +			burntsienna: "ea7e5d",
>, <Line: +			cadetblue: "5f9ea0",
>, <Line: +			chartreuse: "7fff00",
>, <Line: +			chocolate: "d2691e",
>, <Line: +			coral: "ff7f50",
>, <Line: +			cornflowerblue: "6495ed",
>, <Line: +			cornsilk: "fff8dc",
>, <Line: +			crimson: "dc143c",
>, <Line: +			cyan: "0ff",
>, <Line: +			darkblue: "00008b",
>, <Line: +			darkcyan: "008b8b",
>, <Line: +			darkgoldenrod: "b8860b",
>, <Line: +			darkgray: "a9a9a9",
>, <Line: +			darkgreen: "006400",
>, <Line: +			darkgrey: "a9a9a9",
>, <Line: +			darkkhaki: "bdb76b",
>, <Line: +			darkmagenta: "8b008b",
>, <Line: +			darkolivegreen: "556b2f",
>, <Line: +			darkorange: "ff8c00",
>, <Line: +			darkorchid: "9932cc",
>, <Line: +			darkred: "8b0000",
>, <Line: +			darksalmon: "e9967a",
>, <Line: +			darkseagreen: "8fbc8f",
>, <Line: +			darkslateblue: "483d8b",
>, <Line: +			darkslategray: "2f4f4f",
>, <Line: +			darkslategrey: "2f4f4f",
>, <Line: +			darkturquoise: "00ced1",
>, <Line: +			darkviolet: "9400d3",
>, <Line: +			deeppink: "ff1493",
>, <Line: +			deepskyblue: "00bfff",
>, <Line: +			dimgray: "696969",
>, <Line: +			dimgrey: "696969",
>, <Line: +			dodgerblue: "1e90ff",
>, <Line: +			firebrick: "b22222",
>, <Line: +			floralwhite: "fffaf0",
>, <Line: +			forestgreen: "228b22",
>, <Line: +			fuchsia: "f0f",
>, <Line: +			gainsboro: "dcdcdc",
>, <Line: +			ghostwhite: "f8f8ff",
>, <Line: +			gold: "ffd700",
>, <Line: +			goldenrod: "daa520",
>, <Line: +			gray: "808080",
>, <Line: +			green: "008000",
>, <Line: +			greenyellow: "adff2f",
>, <Line: +			grey: "808080",
>, <Line: +			honeydew: "f0fff0",
>, <Line: +			hotpink: "ff69b4",
>, <Line: +			indianred: "cd5c5c",
>, <Line: +			indigo: "4b0082",
>, <Line: +			ivory: "fffff0",
>, <Line: +			khaki: "f0e68c",
>, <Line: +			lavender: "e6e6fa",
>, <Line: +			lavenderblush: "fff0f5",
>, <Line: +			lawngreen: "7cfc00",
>, <Line: +			lemonchiffon: "fffacd",
>, <Line: +			lightblue: "add8e6",
>, <Line: +			lightcoral: "f08080",
>, <Line: +			lightcyan: "e0ffff",
>, <Line: +			lightgoldenrodyellow: "fafad2",
>, <Line: +			lightgray: "d3d3d3",
>, <Line: +			lightgreen: "90ee90",
>, <Line: +			lightgrey: "d3d3d3",
>, <Line: +			lightpink: "ffb6c1",
>, <Line: +			lightsalmon: "ffa07a",
>, <Line: +			lightseagreen: "20b2aa",
>, <Line: +			lightskyblue: "87cefa",
>, <Line: +			lightslategray: "789",
>, <Line: +			lightslategrey: "789",
>, <Line: +			lightsteelblue: "b0c4de",
>, <Line: +			lightyellow: "ffffe0",
>, <Line: +			lime: "0f0",
>, <Line: +			limegreen: "32cd32",
>, <Line: +			linen: "faf0e6",
>, <Line: +			magenta: "f0f",
>, <Line: +			maroon: "800000",
>, <Line: +			mediumaquamarine: "66cdaa",
>, <Line: +			mediumblue: "0000cd",
>, <Line: +			mediumorchid: "ba55d3",
>, <Line: +			mediumpurple: "9370db",
>, <Line: +			mediumseagreen: "3cb371",
>, <Line: +			mediumslateblue: "7b68ee",
>, <Line: +			mediumspringgreen: "00fa9a",
>, <Line: +			mediumturquoise: "48d1cc",
>, <Line: +			mediumvioletred: "c71585",
>, <Line: +			midnightblue: "191970",
>, <Line: +			mintcream: "f5fffa",
>, <Line: +			mistyrose: "ffe4e1",
>, <Line: +			moccasin: "ffe4b5",
>, <Line: +			navajowhite: "ffdead",
>, <Line: +			navy: "000080",
>, <Line: +			oldlace: "fdf5e6",
>, <Line: +			olive: "808000",
>, <Line: +			olivedrab: "6b8e23",
>, <Line: +			orange: "ffa500",
>, <Line: +			orangered: "ff4500",
>, <Line: +			orchid: "da70d6",
>, <Line: +			palegoldenrod: "eee8aa",
>, <Line: +			palegreen: "98fb98",
>, <Line: +			paleturquoise: "afeeee",
>, <Line: +			palevioletred: "db7093",
>, <Line: +			papayawhip: "ffefd5",
>, <Line: +			peachpuff: "ffdab9",
>, <Line: +			peru: "cd853f",
>, <Line: +			pink: "ffc0cb",
>, <Line: +			plum: "dda0dd",
>, <Line: +			powderblue: "b0e0e6",
>, <Line: +			purple: "800080",
>, <Line: +			red: "f00",
>, <Line: +			rosybrown: "bc8f8f",
>, <Line: +			royalblue: "4169e1",
>, <Line: +			saddlebrown: "8b4513",
>, <Line: +			salmon: "fa8072",
>, <Line: +			sandybrown: "f4a460",
>, <Line: +			seagreen: "2e8b57",
>, <Line: +			seashell: "fff5ee",
>, <Line: +			sienna: "a0522d",
>, <Line: +			silver: "c0c0c0",
>, <Line: +			skyblue: "87ceeb",
>, <Line: +			slateblue: "6a5acd",
>, <Line: +			slategray: "708090",
>, <Line: +			slategrey: "708090",
>, <Line: +			snow: "fffafa",
>, <Line: +			springgreen: "00ff7f",
>, <Line: +			steelblue: "4682b4",
>, <Line: +			tan: "d2b48c",
>, <Line: +			teal: "008080",
>, <Line: +			thistle: "d8bfd8",
>, <Line: +			tomato: "ff6347",
>, <Line: +			turquoise: "40e0d0",
>, <Line: +			violet: "ee82ee",
>, <Line: +			wheat: "f5deb3",
>, <Line: +			white: "fff",
>, <Line: +			whitesmoke: "f5f5f5",
>, <Line: +			yellow: "ff0",
>, <Line: +			yellowgreen: "9acd32"
>, <Line: +		};
>, <Line: +		// Make it easy to access colors via `hexNames[hex]`
>, <Line: +		var hexNames = tinycolor.hexNames = flip(names);
>, <Line: +		// Utilities
>, <Line: +		// ---------
>, <Line: +		// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
>, <Line: +		function flip(o) {
>, <Line: +			var flipped = {};
>, <Line: +			for (var i in o) {
>, <Line: +				if (o.hasOwnProperty(i)) {
>, <Line: +					flipped[o[i]] = i;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return flipped;
>, <Line: +		}
>, <Line: +		// Return a valid alpha value [0,1] with all invalid values being set to 1
>, <Line: +		function boundAlpha(a) {
>, <Line: +			a = parseFloat(a);
>, <Line: +			if (isNaN(a) || a < 0 || a > 1) {
>, <Line: +				a = 1;
>, <Line: +			}
>, <Line: +			return a;
>, <Line: +		}
>, <Line: +		// Take input from [0, n] and return it as [0, 1]
>, <Line: +		function bound01(n, max) {
>, <Line: +			if (isOnePointZero(n)) {
>, <Line: +				n = "100%";
>, <Line: +			}
>, <Line: +			var processPercent = isPercentage(n);
>, <Line: +			n = mathMin(max, mathMax(0, parseFloat(n)));
>, <Line: +			// Automatically convert percentage into number
>, <Line: +			if (processPercent) {
>, <Line: +				n = parseInt(n * max, 10) / 100;
>, <Line: +			}
>, <Line: +			// Handle floating point rounding errors
>, <Line: +			if ((math.abs(n - max) < 0.000001)) {
>, <Line: +				return 1;
>, <Line: +			}
>, <Line: +			// Convert into [0, 1] range if it isn't already
>, <Line: +			return (n % max) / parseFloat(max);
>, <Line: +		}
>, <Line: +		// Force a number between 0 and 1
>, <Line: +		function clamp01(val) {
>, <Line: +			return mathMin(1, mathMax(0, val));
>, <Line: +		}
>, <Line: +		// Parse an integer into hex
>, <Line: +		function parseHex(val) {
>, <Line: +			return parseInt(val, 16);
>, <Line: +		}
>, <Line: +		// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
>, <Line: +		// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
>, <Line: +		function isOnePointZero(n) {
>, <Line: +			return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
>, <Line: +		}
>, <Line: +		// Check to see if string passed in is a percentage
>, <Line: +		function isPercentage(n) {
>, <Line: +			return typeof n === "string" && n.indexOf('%') != -1;
>, <Line: +		}
>, <Line: +		// Force a hex value to have 2 characters
>, <Line: +		function pad2(c) {
>, <Line: +			return c.length == 1 ? '0' + c : '' + c;
>, <Line: +		}
>, <Line: +		// Replace a decimal with it's percentage value
>, <Line: +		function convertToPercentage(n) {
>, <Line: +			if (n <= 1) {
>, <Line: +				n = (n * 100) + "%";
>, <Line: +			}
>, <Line: +			return n;
>, <Line: +		}
>, <Line: +		var matchers = (function () {
>, <Line: +			// <http://www.w3.org/TR/css3-values/#integers>
>, <Line: +			var CSS_INTEGER = "[-\\+]?\\d+%?";
>, <Line: +			// <http://www.w3.org/TR/css3-values/#number-value>
>, <Line: +			var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
>, <Line: +			// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
>, <Line: +			var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
>, <Line: +			// Actual matching.
>, <Line: +			// Parentheses and commas are optional, but not required.
>, <Line: +			// Whitespace can take the place of commas or opening paren
>, <Line: +			var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
>, <Line: +			var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
>, <Line: +			return {
>, <Line: +				rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
>, <Line: +				rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
>, <Line: +				hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
>, <Line: +				hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
>, <Line: +				hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
>, <Line: +				hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
>, <Line: +				hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
>, <Line: +			};
>, <Line: +		})();
>, <Line: +		// `stringInputToObject`
>, <Line: +		// Permissive string parsing.  Take in a number of formats, and output an object
>, <Line: +		// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
>, <Line: +		function stringInputToObject(color) {
>, <Line: +			color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
>, <Line: +			var named = false;
>, <Line: +			if (names[color]) {
>, <Line: +				color = names[color];
>, <Line: +				named = true;
>, <Line: +			}
>, <Line: +			else if (color == 'transparent') {
>, <Line: +				return {r: 0, g: 0, b: 0, a: 0, format: "name"};
>, <Line: +			}
>, <Line: +			// Try to match string input using regular expressions.
>, <Line: +			// Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
>, <Line: +			// Just return an object and let the conversion functions handle that.
>, <Line: +			// This way the result will be the same whether the tinycolor is initialized with string or object.
>, <Line: +			var match;
>, <Line: +			if ((match = matchers.rgb.exec(color))) {
>, <Line: +				return {r: match[1], g: match[2], b: match[3]};
>, <Line: +			}
>, <Line: +			if ((match = matchers.rgba.exec(color))) {
>, <Line: +				return {r: match[1], g: match[2], b: match[3], a: match[4]};
>, <Line: +			}
>, <Line: +			if ((match = matchers.hsl.exec(color))) {
>, <Line: +				return {h: match[1], s: match[2], l: match[3]};
>, <Line: +			}
>, <Line: +			if ((match = matchers.hsla.exec(color))) {
>, <Line: +				return {h: match[1], s: match[2], l: match[3], a: match[4]};
>, <Line: +			}
>, <Line: +			if ((match = matchers.hsv.exec(color))) {
>, <Line: +				return {h: match[1], s: match[2], v: match[3]};
>, <Line: +			}
>, <Line: +			if ((match = matchers.hex6.exec(color))) {
>, <Line: +				return {
>, <Line: +					r: parseHex(match[1]),
>, <Line: +					g: parseHex(match[2]),
>, <Line: +					b: parseHex(match[3]),
>, <Line: +					format: named ? "name" : "hex"
>, <Line: +				};
>, <Line: +			}
>, <Line: +			if ((match = matchers.hex3.exec(color))) {
>, <Line: +				return {
>, <Line: +					r: parseHex(match[1] + '' + match[1]),
>, <Line: +					g: parseHex(match[2] + '' + match[2]),
>, <Line: +					b: parseHex(match[3] + '' + match[3]),
>, <Line: +					format: named ? "name" : "hex"
>, <Line: +				};
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		// Expose tinycolor to window, does not need to run in non-browser context.
>, <Line: +		window.tinycolor = tinycolor;
>, <Line: +	})();
>, <Line: +	$(function () {
>, <Line: +		if ($.fn.spectrum.load) {
>, <Line: +			$.fn.spectrum.processNativeColorInputs();
>, <Line: +		}
>, <Line: +	});
>]
[<Line: -    var defaultOpts = {
>, <Line: -        // Callbacks
>, <Line: -        beforeShow: noop,
>, <Line: -        move: noop,
>, <Line: -        change: noop,
>, <Line: -        show: noop,
>, <Line: -        hide: noop,
>, <Line: -        // Options
>, <Line: -        color: false,
>, <Line: -        flat: false,
>, <Line: -        showInput: false,
>, <Line: -        allowEmpty: false,
>, <Line: -        showButtons: true,
>, <Line: -        clickoutFiresChange: false,
>, <Line: -        showInitial: false,
>, <Line: -        showPalette: false,
>, <Line: -        showPaletteOnly: false,
>, <Line: -        showSelectionPalette: true,
>, <Line: -        localStorageKey: false,
>, <Line: -        appendTo: "body",
>, <Line: -        maxSelectionSize: 7,
>, <Line: -        cancelText: "cancel",
>, <Line: -        chooseText: "choose",
>, <Line: -        clearText: "Clear Color Selection",
>, <Line: -        preferredFormat: false,
>, <Line: -        className: "",
>, <Line: -        showAlpha: false,
>, <Line: -        theme: "sp-light",
>, <Line: -        palette: ['fff', '000'],
>, <Line: -        selectionPalette: [],
>, <Line: -        disabled: false
>, <Line: -    },
>, <Line: -    spectrums = [],
>, <Line: -    IE = !!/msie/i.exec( window.navigator.userAgent ),
>, <Line: -    rgbaSupport = (function() {
>, <Line: -        function contains( str, substr ) {
>, <Line: -            return !!~('' + str).indexOf(substr);
>, <Line: -        }
>, <Line: -        var elem = document.createElement('div');
>, <Line: -        var style = elem.style;
>, <Line: -        style.cssText = 'background-color:rgba(0,0,0,.5)';
>, <Line: -        return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
>, <Line: -    })(),
>, <Line: -    inputTypeColorSupport = (function() {
>, <Line: -        var colorInput = $("<input type='color' value='!' />")[0];
>, <Line: -        return colorInput.type === "color" && colorInput.value !== "!";
>, <Line: -    })(),
>, <Line: -    replaceInput = [
>, <Line: -        "<div class='sp-replacer'>",
>, <Line: -            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
>, <Line: -            "<div class='sp-dd'>&#9660;</div>",
>, <Line: -        "</div>"
>, <Line: -    ].join(''),
>, <Line: -    markup = (function () {
>, <Line: -        // IE does not support gradients with multiple stops, so we need to simulate
>, <Line: -        //  that for the rainbow slider with 8 divs that each have a single gradient
>, <Line: -        var gradientFix = "";
>, <Line: -        if (IE) {
>, <Line: -            for (var i = 1; i <= 6; i++) {
>, <Line: -                gradientFix += "<div class='sp-" + i + "'></div>";
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return [
>, <Line: -            "<div class='sp-container sp-hidden'>",
>, <Line: -                "<div class='sp-palette-container'>",
>, <Line: -                    "<div class='sp-palette sp-thumb sp-cf'></div>",
>, <Line: -                "</div>",
>, <Line: -                "<div class='sp-picker-container'>",
>, <Line: -                    "<div class='sp-top sp-cf'>",
>, <Line: -                        "<div class='sp-fill'></div>",
>, <Line: -                        "<div class='sp-top-inner'>",
>, <Line: -                            "<div class='sp-color'>",
>, <Line: -                                "<div class='sp-sat'>",
>, <Line: -                                    "<div class='sp-val'>",
>, <Line: -                                        "<div class='sp-dragger'></div>",
>, <Line: -                                    "</div>",
>, <Line: -                                "</div>",
>, <Line: -                            "</div>",
>, <Line: -                            "<div class='sp-clear sp-clear-display'>",
>, <Line: -                            "</div>",
>, <Line: -                            "<div class='sp-hue'>",
>, <Line: -                                "<div class='sp-slider'></div>",
>, <Line: -                                gradientFix,
>, <Line: -                            "</div>",
>, <Line: -                        "</div>",
>, <Line: -                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
>, <Line: -                    "</div>",
>, <Line: -                    "<div class='sp-input-container sp-cf'>",
>, <Line: -                        "<input class='sp-input' type='text' spellcheck='false'  />",
>, <Line: -                    "</div>",
>, <Line: -                    "<div class='sp-initial sp-thumb sp-cf'></div>",
>, <Line: -                    "<div class='sp-button-container sp-cf'>",
>, <Line: -                        "<a class='sp-cancel' href='#'></a>",
>, <Line: -                        "<button class='sp-choose'></button>",
>, <Line: -                    "</div>",
>, <Line: -                "</div>",
>, <Line: -            "</div>"
>, <Line: -        ].join("");
>, <Line: -    })();
>, <Line: -    function paletteTemplate (p, color, className) {
>, <Line: -        var html = [];
>, <Line: -        for (var i = 0; i < p.length; i++) {
>, <Line: -            var current = p[i];
>, <Line: -            if(current) {
>, <Line: -                var tiny = tinycolor(current);
>, <Line: -                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
>, <Line: -                c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
>, <Line: -                var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
>, <Line: -                html.push('<span title="' + tiny.toRgbString() + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
>, <Line: -            } else {
>, <Line: -                var cls = 'sp-clear-display';
>, <Line: -                html.push('<span title="No Color Selected" data-color="" style="background-color:transparent;" class="' + cls + '"></span>');
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
>, <Line: -    }
>, <Line: -    function hideAll() {
>, <Line: -        for (var i = 0; i < spectrums.length; i++) {
>, <Line: -            if (spectrums[i]) {
>, <Line: -                spectrums[i].hide();
>, <Line: -            }
>, <Line: -        }
>, <Line: -    }
>, <Line: -    function instanceOptions(o, callbackContext) {
>, <Line: -        var opts = $.extend({}, defaultOpts, o);
>, <Line: -        opts.callbacks = {
>, <Line: -            'move': bind(opts.move, callbackContext),
>, <Line: -            'change': bind(opts.change, callbackContext),
>, <Line: -            'show': bind(opts.show, callbackContext),
>, <Line: -            'hide': bind(opts.hide, callbackContext),
>, <Line: -            'beforeShow': bind(opts.beforeShow, callbackContext)
>, <Line: -        };
>, <Line: -        return opts;
>, <Line: -    }
>, <Line: -    function spectrum(element, o) {
>, <Line: -        var opts = instanceOptions(o, element),
>, <Line: -            flat = opts.flat,
>, <Line: -            showSelectionPalette = opts.showSelectionPalette,
>, <Line: -            localStorageKey = opts.localStorageKey,
>, <Line: -            theme = opts.theme,
>, <Line: -            callbacks = opts.callbacks,
>, <Line: -            resize = throttle(reflow, 10),
>, <Line: -            visible = false,
>, <Line: -            dragWidth = 0,
>, <Line: -            dragHeight = 0,
>, <Line: -            dragHelperHeight = 0,
>, <Line: -            slideHeight = 0,
>, <Line: -            slideWidth = 0,
>, <Line: -            alphaWidth = 0,
>, <Line: -            alphaSlideHelperWidth = 0,
>, <Line: -            slideHelperHeight = 0,
>, <Line: -            currentHue = 0,
>, <Line: -            currentSaturation = 0,
>, <Line: -            currentValue = 0,
>, <Line: -            currentAlpha = 1,
>, <Line: -            palette = [],
>, <Line: -            paletteArray = [],
>, <Line: -            selectionPalette = opts.selectionPalette.slice(0),
>, <Line: -            maxSelectionSize = opts.maxSelectionSize,
>, <Line: -            draggingClass = "sp-dragging",
>, <Line: -            shiftMovementDirection = null;
>, <Line: -        var doc = element.ownerDocument,
>, <Line: -            body = doc.body,
>, <Line: -            boundElement = $(element),
>, <Line: -            disabled = false,
>, <Line: -            container = $(markup, doc).addClass(theme),
>, <Line: -            dragger = container.find(".sp-color"),
>, <Line: -            dragHelper = container.find(".sp-dragger"),
>, <Line: -            slider = container.find(".sp-hue"),
>, <Line: -            slideHelper = container.find(".sp-slider"),
>, <Line: -            alphaSliderInner = container.find(".sp-alpha-inner"),
>, <Line: -            alphaSlider = container.find(".sp-alpha"),
>, <Line: -            alphaSlideHelper = container.find(".sp-alpha-handle"),
>, <Line: -            textInput = container.find(".sp-input"),
>, <Line: -            paletteContainer = container.find(".sp-palette"),
>, <Line: -            initialColorContainer = container.find(".sp-initial"),
>, <Line: -            cancelButton = container.find(".sp-cancel"),
>, <Line: -            clearButton = container.find(".sp-clear"),
>, <Line: -            chooseButton = container.find(".sp-choose"),
>, <Line: -            isInput = boundElement.is("input"),
>, <Line: -            isInputTypeColor = isInput && inputTypeColorSupport && boundElement.attr("type") === "color",
>, <Line: -            shouldReplace = isInput && !flat,
>, <Line: -            replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className) : $([]),
>, <Line: -            offsetElement = (shouldReplace) ? replacer : boundElement,
>, <Line: -            previewElement = replacer.find(".sp-preview-inner"),
>, <Line: -            initialColor = opts.color || (isInput && boundElement.val()),
>, <Line: -            colorOnShow = false,
>, <Line: -            preferredFormat = opts.preferredFormat,
>, <Line: -            currentPreferredFormat = preferredFormat,
>, <Line: -            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
>, <Line: -            isEmpty = !initialColor,
>, <Line: -            allowEmpty = opts.allowEmpty && !isInputTypeColor;
>, <Line: -        function applyOptions() {
>, <Line: -            if (opts.showPaletteOnly) {
>, <Line: -                opts.showPalette = true;
>, <Line: -            }
>, <Line: -            if (opts.palette) {
>, <Line: -                palette = opts.palette.slice(0);
>, <Line: -                paletteArray = $.isArray(palette[0]) ? palette : [palette];
>, <Line: -            }
>, <Line: -            container.toggleClass("sp-flat", flat);
>, <Line: -            container.toggleClass("sp-input-disabled", !opts.showInput);
>, <Line: -            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
>, <Line: -            container.toggleClass("sp-clear-enabled", allowEmpty);
>, <Line: -            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
>, <Line: -            container.toggleClass("sp-palette-disabled", !opts.showPalette);
>, <Line: -            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
>, <Line: -            container.toggleClass("sp-initial-disabled", !opts.showInitial);
>, <Line: -            container.addClass(opts.className);
>, <Line: -            reflow();
>, <Line: -        }
>, <Line: -        function initialize() {
>, <Line: -            if (IE) {
>, <Line: -                container.find("*:not(input)").attr("unselectable", "on");
>, <Line: -            }
>, <Line: -            applyOptions();
>, <Line: -            if (shouldReplace) {
>, <Line: -                boundElement.after(replacer).hide();
>, <Line: -            }
>, <Line: -            if (!allowEmpty) {
>, <Line: -                clearButton.hide();
>, <Line: -            }
>, <Line: -            if (flat) {
>, <Line: -                boundElement.after(container).hide();
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
>, <Line: -                if (appendTo.length !== 1) {
>, <Line: -                    appendTo = $("body");
>, <Line: -                }
>, <Line: -                appendTo.append(container);
>, <Line: -            }
>, <Line: -            if (localStorageKey && window.localStorage) {
>, <Line: -                // Migrate old palettes over to new format.  May want to remove this eventually.
>, <Line: -                try {
>, <Line: -                    var oldPalette = window.localStorage[localStorageKey].split(",#");
>, <Line: -                    if (oldPalette.length > 1) {
>, <Line: -                        delete window.localStorage[localStorageKey];
>, <Line: -                        $.each(oldPalette, function(i, c) {
>, <Line: -                             addColorToSelectionPalette(c);
>, <Line: -                        });
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                catch(e) { }
>, <Line: -                try {
>, <Line: -                    selectionPalette = window.localStorage[localStorageKey].split(";");
>, <Line: -                }
>, <Line: -                catch (e) { }
>, <Line: -            }
>, <Line: -            offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
>, <Line: -                if (!disabled) {
>, <Line: -                    toggle();
>, <Line: -                }
>, <Line: -                e.stopPropagation();
>, <Line: -                if (!$(e.target).is("input")) {
>, <Line: -                    e.preventDefault();
>, <Line: -                }
>, <Line: -            });
>, <Line: -            if(boundElement.is(":disabled") || (opts.disabled === true)) {
>, <Line: -                disable();
>, <Line: -            }
>, <Line: -            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
>, <Line: -            container.click(stopPropagation);
>, <Line: -            // Handle user typed input
>, <Line: -            textInput.change(setFromTextInput);
>, <Line: -            textInput.bind("paste", function () {
>, <Line: -                setTimeout(setFromTextInput, 1);
>, <Line: -            });
>, <Line: -            textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });
>, <Line: -            cancelButton.text(opts.cancelText);
>, <Line: -            cancelButton.bind("click.spectrum", function (e) {
>, <Line: -                e.stopPropagation();
>, <Line: -                e.preventDefault();
>, <Line: -                hide("cancel");
>, <Line: -            });
>, <Line: -            clearButton.attr("title", opts.clearText);
>, <Line: -            clearButton.bind("click.spectrum", function (e) {
>, <Line: -                e.stopPropagation();
>, <Line: -                e.preventDefault();
>, <Line: -                isEmpty = true;
>, <Line: -                move();
>, <Line: -                if(flat) {
>, <Line: -                    //for the flat style, this is a change event
>, <Line: -                    updateOriginalInput(true);
>, <Line: -                }
>, <Line: -            });
>, <Line: -            chooseButton.text(opts.chooseText);
>, <Line: -            chooseButton.bind("click.spectrum", function (e) {
>, <Line: -                e.stopPropagation();
>, <Line: -                e.preventDefault();
>, <Line: -                if (isValid()) {
>, <Line: -                    updateOriginalInput(true);
>, <Line: -                    hide();
>, <Line: -                }
>, <Line: -            });
>, <Line: -            draggable(alphaSlider, function (dragX, dragY, e) {
>, <Line: -                currentAlpha = (dragX / alphaWidth);
>, <Line: -                isEmpty = false;
>, <Line: -                if (e.shiftKey) {
>, <Line: -                    currentAlpha = Math.round(currentAlpha * 10) / 10;
>, <Line: -                }
>, <Line: -                move();
>, <Line: -            }, dragStart, dragStop);
>, <Line: -            draggable(slider, function (dragX, dragY) {
>, <Line: -                currentHue = parseFloat(dragY / slideHeight);
>, <Line: -                isEmpty = false;
>, <Line: -                if (!opts.showAlpha) {
>, <Line: -                    currentAlpha = 1;
>, <Line: -                }
>, <Line: -                move();
>, <Line: -            }, dragStart, dragStop);
>, <Line: -            draggable(dragger, function (dragX, dragY, e) {
>, <Line: -                // shift+drag should snap the movement to either the x or y axis.
>, <Line: -                if (!e.shiftKey) {
>, <Line: -                    shiftMovementDirection = null;
>, <Line: -                }
>, <Line: -                else if (!shiftMovementDirection) {
>, <Line: -                    var oldDragX = currentSaturation * dragWidth;
>, <Line: -                    var oldDragY = dragHeight - (currentValue * dragHeight);
>, <Line: -                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
>, <Line: -                    shiftMovementDirection = furtherFromX ? "x" : "y";
>, <Line: -                }
>, <Line: -                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
>, <Line: -                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";
>, <Line: -                if (setSaturation) {
>, <Line: -                    currentSaturation = parseFloat(dragX / dragWidth);
>, <Line: -                }
>, <Line: -                if (setValue) {
>, <Line: -                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
>, <Line: -                }
>, <Line: -                isEmpty = false;
>, <Line: -                if (!opts.showAlpha) {
>, <Line: -                    currentAlpha = 1;
>, <Line: -                }
>, <Line: -                move();
>, <Line: -            }, dragStart, dragStop);
>, <Line: -            if (!!initialColor) {
>, <Line: -                set(initialColor);
>, <Line: -                // In case color was black - update the preview UI and set the format
>, <Line: -                // since the set function will not run (default color is black).
>, <Line: -                updateUI();
>, <Line: -                currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;
>, <Line: -                addColorToSelectionPalette(initialColor);
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                updateUI();
>, <Line: -            }
>, <Line: -            if (flat) {
>, <Line: -                show();
>, <Line: -            }
>, <Line: -            function palletElementClick(e) {
>, <Line: -                if (e.data && e.data.ignore) {
>, <Line: -                    set($(this).data("color"));
>, <Line: -                    move();
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    set($(this).data("color"));
>, <Line: -                    updateOriginalInput(true);
>, <Line: -                    move();
>, <Line: -                    hide();
>, <Line: -                }
>, <Line: -                return false;
>, <Line: -            }
>, <Line: -            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
>, <Line: -            paletteContainer.delegate(".sp-thumb-el", paletteEvent, palletElementClick);
>, <Line: -            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, palletElementClick);
>, <Line: -        }
>, <Line: -        function addColorToSelectionPalette(color) {
>, <Line: -            if (showSelectionPalette) {
>, <Line: -                var colorRgb = tinycolor(color).toRgbString();
>, <Line: -                if ($.inArray(colorRgb, selectionPalette) === -1) {
>, <Line: -                    selectionPalette.push(colorRgb);
>, <Line: -                    while(selectionPalette.length > maxSelectionSize) {
>, <Line: -                        selectionPalette.shift();
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                if (localStorageKey && window.localStorage) {
>, <Line: -                    try {
>, <Line: -                        window.localStorage[localStorageKey] = selectionPalette.join(";");
>, <Line: -                    }
>, <Line: -                    catch(e) { }
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function getUniqueSelectionPalette() {
>, <Line: -            var unique = [];
>, <Line: -            var p = selectionPalette;
>, <Line: -            var paletteLookup = {};
>, <Line: -            var rgb;
>, <Line: -            if (opts.showPalette) {
>, <Line: -                for (var i = 0; i < paletteArray.length; i++) {
>, <Line: -                    for (var j = 0; j < paletteArray[i].length; j++) {
>, <Line: -                        rgb = tinycolor(paletteArray[i][j]).toRgbString();
>, <Line: -                        paletteLookup[rgb] = true;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                for (i = 0; i < p.length; i++) {
>, <Line: -                    rgb = tinycolor(p[i]).toRgbString();
>, <Line: -                    if (!paletteLookup.hasOwnProperty(rgb)) {
>, <Line: -                        unique.push(p[i]);
>, <Line: -                        paletteLookup[rgb] = true;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            return unique.reverse().slice(0, opts.maxSelectionSize);
>, <Line: -        }
>, <Line: -        function drawPalette() {
>, <Line: -            var currentColor = get();
>, <Line: -            var html = $.map(paletteArray, function (palette, i) {
>, <Line: -                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i);
>, <Line: -            });
>, <Line: -            if (selectionPalette) {
>, <Line: -                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection"));
>, <Line: -            }
>, <Line: -            paletteContainer.html(html.join(""));
>, <Line: -        }
>, <Line: -        function drawInitial() {
>, <Line: -            if (opts.showInitial) {
>, <Line: -                var initial = colorOnShow;
>, <Line: -                var current = get();
>, <Line: -                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial"));
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function dragStart() {
>, <Line: -            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
>, <Line: -                reflow();
>, <Line: -            }
>, <Line: -            container.addClass(draggingClass);
>, <Line: -            shiftMovementDirection = null;
>, <Line: -            boundElement.trigger('dragstart.spectrum', [ get() ]);
>, <Line: -        }
>, <Line: -        function dragStop() {
>, <Line: -            container.removeClass(draggingClass);
>, <Line: -            boundElement.trigger('dragstop.spectrum', [ get() ]);
>, <Line: -        }
>, <Line: -        function setFromTextInput() {
>, <Line: -            var value = textInput.val();
>, <Line: -            if ((value === null || value === "") && allowEmpty) {
>, <Line: -                set(null);
>, <Line: -                updateOriginalInput(true);
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                var tiny = tinycolor(value);
>, <Line: -                if (tiny.ok) {
>, <Line: -                    set(tiny);
>, <Line: -                    updateOriginalInput(true);
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    textInput.addClass("sp-validation-error");
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function toggle() {
>, <Line: -            if (visible) {
>, <Line: -                hide();
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                show();
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function show() {
>, <Line: -            var event = $.Event('beforeShow.spectrum');
>, <Line: -            if (visible) {
>, <Line: -                reflow();
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            boundElement.trigger(event, [ get() ]);
>, <Line: -            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            hideAll();
>, <Line: -            visible = true;
>, <Line: -            $(doc).bind("click.spectrum", hide);
>, <Line: -            $(window).bind("resize.spectrum", resize);
>, <Line: -            replacer.addClass("sp-active");
>, <Line: -            container.removeClass("sp-hidden");
>, <Line: -            reflow();
>, <Line: -            updateUI();
>, <Line: -            colorOnShow = get();
>, <Line: -            drawInitial();
>, <Line: -            callbacks.show(colorOnShow);
>, <Line: -            boundElement.trigger('show.spectrum', [ colorOnShow ]);
>, <Line: -        }
>, <Line: -        function hide(e) {
>, <Line: -            // Return on right click
>, <Line: -            if (e && e.type == "click" && e.button == 2) { return; }
>, <Line: -            // Return if hiding is unnecessary
>, <Line: -            if (!visible || flat) { return; }
>, <Line: -            visible = false;
>, <Line: -            $(doc).unbind("click.spectrum", hide);
>, <Line: -            $(window).unbind("resize.spectrum", resize);
>, <Line: -            replacer.removeClass("sp-active");
>, <Line: -            container.addClass("sp-hidden");
>, <Line: -            var colorHasChanged = !tinycolor.equals(get(), colorOnShow);
>, <Line: -            if (colorHasChanged) {
>, <Line: -                if (clickoutFiresChange && e !== "cancel") {
>, <Line: -                    updateOriginalInput(true);
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    revert();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            callbacks.hide(get());
>, <Line: -            boundElement.trigger('hide.spectrum', [ get() ]);
>, <Line: -        }
>, <Line: -        function revert() {
>, <Line: -            set(colorOnShow, true);
>, <Line: -        }
>, <Line: -        function set(color, ignoreFormatChange) {
>, <Line: -            if (tinycolor.equals(color, get())) {
>, <Line: -                // Update UI just in case a validation error needs
>, <Line: -                // to be cleared.
>, <Line: -                updateUI();
>, <Line: -                return;
>, <Line: -            }
>, <Line: -            var newColor, newHsv;
>, <Line: -            if (!color && allowEmpty) {
>, <Line: -                isEmpty = true;
>, <Line: -            } else {
>, <Line: -                isEmpty = false;
>, <Line: -                newColor = tinycolor(color);
>, <Line: -                newHsv = newColor.toHsv();
>, <Line: -                currentHue = (newHsv.h % 360) / 360;
>, <Line: -                currentSaturation = newHsv.s;
>, <Line: -                currentValue = newHsv.v;
>, <Line: -                currentAlpha = newHsv.a;
>, <Line: -            }
>, <Line: -            updateUI();
>, <Line: -            if (newColor && newColor.ok && !ignoreFormatChange) {
>, <Line: -                currentPreferredFormat = preferredFormat || newColor.format;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function get(opts) {
>, <Line: -            opts = opts || { };
>, <Line: -            if (allowEmpty && isEmpty) {
>, <Line: -                return null;
>, <Line: -            }
>, <Line: -            return tinycolor.fromRatio({
>, <Line: -                h: currentHue,
>, <Line: -                s: currentSaturation,
>, <Line: -                v: currentValue,
>, <Line: -                a: Math.round(currentAlpha * 100) / 100
>, <Line: -            }, { format: opts.format || currentPreferredFormat });
>, <Line: -        }
>, <Line: -        function isValid() {
>, <Line: -            return !textInput.hasClass("sp-validation-error");
>, <Line: -        }
>, <Line: -        function move() {
>, <Line: -            updateUI();
>, <Line: -            callbacks.move(get());
>, <Line: -            boundElement.trigger('move.spectrum', [ get() ]);
>, <Line: -        }
>, <Line: -        function updateUI() {
>, <Line: -            textInput.removeClass("sp-validation-error");
>, <Line: -            updateHelperLocations();
>, <Line: -            // Update dragger background color (gradients take care of saturation and value).
>, <Line: -            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
>, <Line: -            dragger.css("background-color", flatColor.toHexString());
>, <Line: -            // Get a format that alpha will be included in (hex and names ignore alpha)
>, <Line: -            var format = currentPreferredFormat;
>, <Line: -            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
>, <Line: -                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
>, <Line: -                    format = "rgb";
>, <Line: -                }
>, <Line: -            }
>, <Line: -            var realColor = get({ format: format }),
>, <Line: -                displayColor = '';
>, <Line: -             //reset background info for preview element
>, <Line: -            previewElement.removeClass("sp-clear-display");
>, <Line: -            previewElement.css('background-color', 'transparent');
>, <Line: -            if (!realColor && allowEmpty) {
>, <Line: -                // Update the replaced elements background with icon indicating no color selection
>, <Line: -                previewElement.addClass("sp-clear-display");
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                var realHex = realColor.toHexString(),
>, <Line: -                    realRgb = realColor.toRgbString();
>, <Line: -                // Update the replaced elements background color (with actual selected color)
>, <Line: -                if (rgbaSupport || realColor.alpha === 1) {
>, <Line: -                    previewElement.css("background-color", realRgb);
>, <Line: -                }
>, <Line: -                else {
>, <Line: -                    previewElement.css("background-color", "transparent");
>, <Line: -                    previewElement.css("filter", realColor.toFilter());
>, <Line: -                }
>, <Line: -                if (opts.showAlpha) {
>, <Line: -                    var rgb = realColor.toRgb();
>, <Line: -                    rgb.a = 0;
>, <Line: -                    var realAlpha = tinycolor(rgb).toRgbString();
>, <Line: -                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";
>, <Line: -                    if (IE) {
>, <Line: -                        alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        alphaSliderInner.css("background", "-webkit-" + gradient);
>, <Line: -                        alphaSliderInner.css("background", "-moz-" + gradient);
>, <Line: -                        alphaSliderInner.css("background", "-ms-" + gradient);
>, <Line: -                        alphaSliderInner.css("background", gradient);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                displayColor = realColor.toString(format);
>, <Line: -            }
>, <Line: -            // Update the text entry input as it changes happen
>, <Line: -            if (opts.showInput) {
>, <Line: -                textInput.val(displayColor);
>, <Line: -            }
>, <Line: -            if (opts.showPalette) {
>, <Line: -                drawPalette();
>, <Line: -            }
>, <Line: -            drawInitial();
>, <Line: -        }
>, <Line: -        function updateHelperLocations() {
>, <Line: -            var s = currentSaturation;
>, <Line: -            var v = currentValue;
>, <Line: -            if(allowEmpty && isEmpty) {
>, <Line: -                //if selected color is empty, hide the helpers
>, <Line: -                alphaSlideHelper.hide();
>, <Line: -                slideHelper.hide();
>, <Line: -                dragHelper.hide();
>, <Line: -            }
>, <Line: -            else {
>, <Line: -                //make sure helpers are visible
>, <Line: -                alphaSlideHelper.show();
>, <Line: -                slideHelper.show();
>, <Line: -                dragHelper.show();
>, <Line: -                // Where to show the little circle in that displays your current selected color
>, <Line: -                var dragX = s * dragWidth;
>, <Line: -                var dragY = dragHeight - (v * dragHeight);
>, <Line: -                dragX = Math.max(
>, <Line: -                    -dragHelperHeight,
>, <Line: -                    Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
>, <Line: -                );
>, <Line: -                dragY = Math.max(
>, <Line: -                    -dragHelperHeight,
>, <Line: -                    Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
>, <Line: -                );
>, <Line: -                dragHelper.css({
>, <Line: -                    "top": dragY + "px",
>, <Line: -                    "left": dragX + "px"
>, <Line: -                });
>, <Line: -                var alphaX = currentAlpha * alphaWidth;
>, <Line: -                alphaSlideHelper.css({
>, <Line: -                    "left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
>, <Line: -                });
>, <Line: -                // Where to show the bar that displays your current selected hue
>, <Line: -                var slideY = (currentHue) * slideHeight;
>, <Line: -                slideHelper.css({
>, <Line: -                    "top": (slideY - slideHelperHeight) + "px"
>, <Line: -                });
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function updateOriginalInput(fireCallback) {
>, <Line: -            var color = get(),
>, <Line: -                displayColor = '',
>, <Line: -                hasChanged = !tinycolor.equals(color, colorOnShow);
>, <Line: -            if (color) {
>, <Line: -                displayColor = color.toString(currentPreferredFormat);
>, <Line: -                // Update the selection palette with the current color
>, <Line: -                addColorToSelectionPalette(color);
>, <Line: -            }
>, <Line: -            if (isInput) {
>, <Line: -                boundElement.val(displayColor);
>, <Line: -            }
>, <Line: -            colorOnShow = color;
>, <Line: -            if (fireCallback && hasChanged) {
>, <Line: -                callbacks.change(color);
>, <Line: -                boundElement.trigger('change', [ color ]);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function reflow() {
>, <Line: -            dragWidth = dragger.width();
>, <Line: -            dragHeight = dragger.height();
>, <Line: -            dragHelperHeight = dragHelper.height();
>, <Line: -            slideWidth = slider.width();
>, <Line: -            slideHeight = slider.height();
>, <Line: -            slideHelperHeight = slideHelper.height();
>, <Line: -            alphaWidth = alphaSlider.width();
>, <Line: -            alphaSlideHelperWidth = alphaSlideHelper.width();
>, <Line: -            if (!flat) {
>, <Line: -                container.css("position", "absolute");
>, <Line: -                container.offset(getOffset(container, offsetElement));
>, <Line: -            }
>, <Line: -            updateHelperLocations();
>, <Line: -            if (opts.showPalette) {
>, <Line: -                drawPalette();
>, <Line: -            }
>, <Line: -            boundElement.trigger('reflow.spectrum');
>, <Line: -        }
>, <Line: -        function destroy() {
>, <Line: -            boundElement.show();
>, <Line: -            offsetElement.unbind("click.spectrum touchstart.spectrum");
>, <Line: -            container.remove();
>, <Line: -            replacer.remove();
>, <Line: -            spectrums[spect.id] = null;
>, <Line: -        }
>, <Line: -        function option(optionName, optionValue) {
>, <Line: -            if (optionName === undefined) {
>, <Line: -                return $.extend({}, opts);
>, <Line: -            }
>, <Line: -            if (optionValue === undefined) {
>, <Line: -                return opts[optionName];
>, <Line: -            }
>, <Line: -            opts[optionName] = optionValue;
>, <Line: -            applyOptions();
>, <Line: -        }
>, <Line: -        function enable() {
>, <Line: -            disabled = false;
>, <Line: -            boundElement.attr("disabled", false);
>, <Line: -            offsetElement.removeClass("sp-disabled");
>, <Line: -        }
>, <Line: -        function disable() {
>, <Line: -            hide();
>, <Line: -            disabled = true;
>, <Line: -            boundElement.attr("disabled", true);
>, <Line: -            offsetElement.addClass("sp-disabled");
>, <Line: -        }
>, <Line: -        initialize();
>, <Line: -        var spect = {
>, <Line: -            show: show,
>, <Line: -            hide: hide,
>, <Line: -            toggle: toggle,
>, <Line: -            reflow: reflow,
>, <Line: -            option: option,
>, <Line: -            enable: enable,
>, <Line: -            disable: disable,
>, <Line: -            set: function (c) {
>, <Line: -                set(c);
>, <Line: -                updateOriginalInput();
>, <Line: -            },
>, <Line: -            get: get,
>, <Line: -            destroy: destroy,
>, <Line: -            container: container
>, <Line: -        };
>, <Line: -        spect.id = spectrums.push(spect) - 1;
>, <Line: -        return spect;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -    * checkOffset - get the offset below/above and left/right element depending on screen position
>, <Line: -    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
>, <Line: -    */
>, <Line: -    function getOffset(picker, input) {
>, <Line: -        var extraY = 0;
>, <Line: -        var dpWidth = picker.outerWidth();
>, <Line: -        var dpHeight = picker.outerHeight();
>, <Line: -        var inputHeight = input.outerHeight();
>, <Line: -        var doc = picker[0].ownerDocument;
>, <Line: -        var docElem = doc.documentElement;
>, <Line: -        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
>, <Line: -        var viewHeight = docElem.clientHeight + $(doc).scrollTop();
>, <Line: -        var offset = input.offset();
>, <Line: -        offset.top += inputHeight;
>, <Line: -        offset.left -=
>, <Line: -            Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
>, <Line: -            Math.abs(offset.left + dpWidth - viewWidth) : 0);
>, <Line: -        offset.top -=
>, <Line: -            Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
>, <Line: -            Math.abs(dpHeight + inputHeight - extraY) : extraY));
>, <Line: -        return offset;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -    * noop - do nothing
>, <Line: -    */
>, <Line: -    function noop() {
>, <Line: -    }
>, <Line: -    /**
>, <Line: -    * stopPropagation - makes the code only doing this a little easier to read in line
>, <Line: -    */
>, <Line: -    function stopPropagation(e) {
>, <Line: -        e.stopPropagation();
>, <Line: -    }
>, <Line: -    /**
>, <Line: -    * Create a function bound to a given object
>, <Line: -    * Thanks to underscore.js
>, <Line: -    */
>, <Line: -    function bind(func, obj) {
>, <Line: -        var slice = Array.prototype.slice;
>, <Line: -        var args = slice.call(arguments, 2);
>, <Line: -        return function () {
>, <Line: -            return func.apply(obj, args.concat(slice.call(arguments)));
>, <Line: -        };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -    * Lightweight drag helper.  Handles containment within the element, so that
>, <Line: -    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
>, <Line: -    */
>, <Line: -    function draggable(element, onmove, onstart, onstop) {
>, <Line: -        onmove = onmove || function () { };
>, <Line: -        onstart = onstart || function () { };
>, <Line: -        onstop = onstop || function () { };
>, <Line: -        var doc = element.ownerDocument || document;
>, <Line: -        var dragging = false;
>, <Line: -        var offset = {};
>, <Line: -        var maxHeight = 0;
>, <Line: -        var maxWidth = 0;
>, <Line: -        var hasTouch = ('ontouchstart' in window);
>, <Line: -        var duringDragEvents = {};
>, <Line: -        duringDragEvents["selectstart"] = prevent;
>, <Line: -        duringDragEvents["dragstart"] = prevent;
>, <Line: -        duringDragEvents["touchmove mousemove"] = move;
>, <Line: -        duringDragEvents["touchend mouseup"] = stop;
>, <Line: -        function prevent(e) {
>, <Line: -            if (e.stopPropagation) {
>, <Line: -                e.stopPropagation();
>, <Line: -            }
>, <Line: -            if (e.preventDefault) {
>, <Line: -                e.preventDefault();
>, <Line: -            }
>, <Line: -            e.returnValue = false;
>, <Line: -        }
>, <Line: -        function move(e) {
>, <Line: -            if (dragging) {
>, <Line: -                // Mouseup happened outside of window
>, <Line: -                if (IE && document.documentMode < 9 && !e.button) {
>, <Line: -                    return stop();
>, <Line: -                }
>, <Line: -                var touches = e.originalEvent.touches;
>, <Line: -                var pageX = touches ? touches[0].pageX : e.pageX;
>, <Line: -                var pageY = touches ? touches[0].pageY : e.pageY;
>, <Line: -                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
>, <Line: -                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
>, <Line: -                if (hasTouch) {
>, <Line: -                    // Stop scrolling in iOS
>, <Line: -                    prevent(e);
>, <Line: -                }
>, <Line: -                onmove.apply(element, [dragX, dragY, e]);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function start(e) {
>, <Line: -            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);
>, <Line: -            var touches = e.originalEvent.touches;
>, <Line: -            if (!rightclick && !dragging) {
>, <Line: -                if (onstart.apply(element, arguments) !== false) {
>, <Line: -                    dragging = true;
>, <Line: -                    maxHeight = $(element).height();
>, <Line: -                    maxWidth = $(element).width();
>, <Line: -                    offset = $(element).offset();
>, <Line: -                    $(doc).bind(duringDragEvents);
>, <Line: -                    $(doc.body).addClass("sp-dragging");
>, <Line: -                    if (!hasTouch) {
>, <Line: -                        move(e);
>, <Line: -                    }
>, <Line: -                    prevent(e);
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        function stop() {
>, <Line: -            if (dragging) {
>, <Line: -                $(doc).unbind(duringDragEvents);
>, <Line: -                $(doc.body).removeClass("sp-dragging");
>, <Line: -                onstop.apply(element, arguments);
>, <Line: -            }
>, <Line: -            dragging = false;
>, <Line: -        }
>, <Line: -        $(element).bind("touchstart mousedown", start);
>, <Line: -    }
>, <Line: -    function throttle(func, wait, debounce) {
>, <Line: -        var timeout;
>, <Line: -        return function () {
>, <Line: -            var context = this, args = arguments;
>, <Line: -            var throttler = function () {
>, <Line: -                timeout = null;
>, <Line: -                func.apply(context, args);
>, <Line: -            };
>, <Line: -            if (debounce) clearTimeout(timeout);
>, <Line: -            if (debounce || !timeout) timeout = setTimeout(throttler, wait);
>, <Line: -        };
>, <Line: -    }
>, <Line: -    function log(){/* jshint -W021 */if(window.console){if(Function.prototype.bind)log=Function.prototype.bind.call(console.log,console);else log=function(){Function.prototype.apply.call(console.log,console,arguments);};log.apply(this,arguments);}}
>, <Line: -    /**
>, <Line: -    * Define a jQuery plugin
>, <Line: -    */
>, <Line: -    var dataID = "spectrum.id";
>, <Line: -    $.fn.spectrum = function (opts, extra) {
>, <Line: -        if (typeof opts == "string") {
>, <Line: -            var returnValue = this;
>, <Line: -            var args = Array.prototype.slice.call( arguments, 1 );
>, <Line: -            this.each(function () {
>, <Line: -                var spect = spectrums[$(this).data(dataID)];
>, <Line: -                if (spect) {
>, <Line: -                    var method = spect[opts];
>, <Line: -                    if (!method) {
>, <Line: -                        throw new Error( "Spectrum: no such method: '" + opts + "'" );
>, <Line: -                    }
>, <Line: -                    if (opts == "get") {
>, <Line: -                        returnValue = spect.get();
>, <Line: -                    }
>, <Line: -                    else if (opts == "container") {
>, <Line: -                        returnValue = spect.container;
>, <Line: -                    }
>, <Line: -                    else if (opts == "option") {
>, <Line: -                        returnValue = spect.option.apply(spect, args);
>, <Line: -                    }
>, <Line: -                    else if (opts == "destroy") {
>, <Line: -                        spect.destroy();
>, <Line: -                        $(this).removeData(dataID);
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        method.apply(spect, args);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            });
>, <Line: -            return returnValue;
>, <Line: -        }
>, <Line: -        // Initializing a new instance of spectrum
>, <Line: -        return this.spectrum("destroy").each(function () {
>, <Line: -            var options = $.extend({}, opts, $(this).data());
>, <Line: -            var spect = spectrum(this, options);
>, <Line: -            $(this).data(dataID, spect.id);
>, <Line: -        });
>, <Line: -    };
>, <Line: -    $.fn.spectrum.load = true;
>, <Line: -    $.fn.spectrum.loadOpts = {};
>, <Line: -    $.fn.spectrum.draggable = draggable;
>, <Line: -    $.fn.spectrum.defaults = defaultOpts;
>, <Line: -    $.spectrum = { };
>, <Line: -    $.spectrum.localization = { };
>, <Line: -    $.spectrum.palettes = { };
>, <Line: -    $.fn.spectrum.processNativeColorInputs = function () {
>, <Line: -        if (!inputTypeColorSupport) {
>, <Line: -            $("input[type=color]").spectrum({
>, <Line: -                preferredFormat: "hex6"
>, <Line: -            });
>, <Line: -        }
>, <Line: -    };
>, <Line: -    // TinyColor v0.9.16
>, <Line: -    // https://github.com/bgrins/TinyColor
>, <Line: -    // 2013-08-10, Brian Grinstead, MIT License
>, <Line: -    (function() {
>, <Line: -    var trimLeft = /^[\s,#]+/,
>, <Line: -        trimRight = /\s+$/,
>, <Line: -        tinyCounter = 0,
>, <Line: -        math = Math,
>, <Line: -        mathRound = math.round,
>, <Line: -        mathMin = math.min,
>, <Line: -        mathMax = math.max,
>, <Line: -        mathRandom = math.random;
>, <Line: -    function tinycolor (color, opts) {
>, <Line: -        color = (color) ? color : '';
>, <Line: -        opts = opts || { };
>, <Line: -        // If input is already a tinycolor, return itself
>, <Line: -        if (typeof color == "object" && color.hasOwnProperty("_tc_id")) {
>, <Line: -           return color;
>, <Line: -        }
>, <Line: -        var rgb = inputToRGB(color);
>, <Line: -        var r = rgb.r,
>, <Line: -            g = rgb.g,
>, <Line: -            b = rgb.b,
>, <Line: -            a = rgb.a,
>, <Line: -            roundA = mathRound(100*a) / 100,
>, <Line: -            format = opts.format || rgb.format;
>, <Line: -        // Don't let the range of [0,255] come back in [0,1].
>, <Line: -        // Potentially lose a little bit of precision here, but will fix issues where
>, <Line: -        // .5 gets interpreted as half of the total, instead of half of 1
>, <Line: -        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
>, <Line: -        if (r < 1) { r = mathRound(r); }
>, <Line: -        if (g < 1) { g = mathRound(g); }
>, <Line: -        if (b < 1) { b = mathRound(b); }
>, <Line: -        return {
>, <Line: -            ok: rgb.ok,
>, <Line: -            format: format,
>, <Line: -            _tc_id: tinyCounter++,
>, <Line: -            alpha: a,
>, <Line: -            getAlpha: function() {
>, <Line: -                return a;
>, <Line: -            },
>, <Line: -            setAlpha: function(value) {
>, <Line: -                a = boundAlpha(value);
>, <Line: -                roundA = mathRound(100*a) / 100;
>, <Line: -            },
>, <Line: -            toHsv: function() {
>, <Line: -                var hsv = rgbToHsv(r, g, b);
>, <Line: -                return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: a };
>, <Line: -            },
>, <Line: -            toHsvString: function() {
>, <Line: -                var hsv = rgbToHsv(r, g, b);
>, <Line: -                var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
>, <Line: -                return (a == 1) ?
>, <Line: -                  "hsv("  + h + ", " + s + "%, " + v + "%)" :
>, <Line: -                  "hsva(" + h + ", " + s + "%, " + v + "%, "+ roundA + ")";
>, <Line: -            },
>, <Line: -            toHsl: function() {
>, <Line: -                var hsl = rgbToHsl(r, g, b);
>, <Line: -                return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: a };
>, <Line: -            },
>, <Line: -            toHslString: function() {
>, <Line: -                var hsl = rgbToHsl(r, g, b);
>, <Line: -                var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
>, <Line: -                return (a == 1) ?
>, <Line: -                  "hsl("  + h + ", " + s + "%, " + l + "%)" :
>, <Line: -                  "hsla(" + h + ", " + s + "%, " + l + "%, "+ roundA + ")";
>, <Line: -            },
>, <Line: -            toHex: function(allow3Char) {
>, <Line: -                return rgbToHex(r, g, b, allow3Char);
>, <Line: -            },
>, <Line: -            toHexString: function(allow3Char) {
>, <Line: -                return '#' + rgbToHex(r, g, b, allow3Char);
>, <Line: -            },
>, <Line: -            toRgb: function() {
>, <Line: -                return { r: mathRound(r), g: mathRound(g), b: mathRound(b), a: a };
>, <Line: -            },
>, <Line: -            toRgbString: function() {
>, <Line: -                return (a == 1) ?
>, <Line: -                  "rgb("  + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ")" :
>, <Line: -                  "rgba(" + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ", " + roundA + ")";
>, <Line: -            },
>, <Line: -            toPercentageRgb: function() {
>, <Line: -                return { r: mathRound(bound01(r, 255) * 100) + "%", g: mathRound(bound01(g, 255) * 100) + "%", b: mathRound(bound01(b, 255) * 100) + "%", a: a };
>, <Line: -            },
>, <Line: -            toPercentageRgbString: function() {
>, <Line: -                return (a == 1) ?
>, <Line: -                  "rgb("  + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%)" :
>, <Line: -                  "rgba(" + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%, " + roundA + ")";
>, <Line: -            },
>, <Line: -            toName: function() {
>, <Line: -                if (a === 0) {
>, <Line: -                    return "transparent";
>, <Line: -                }
>, <Line: -                return hexNames[rgbToHex(r, g, b, true)] || false;
>, <Line: -            },
>, <Line: -            toFilter: function(secondColor) {
>, <Line: -                var hex = rgbToHex(r, g, b);
>, <Line: -                var secondHex = hex;
>, <Line: -                var alphaHex = Math.round(parseFloat(a) * 255).toString(16);
>, <Line: -                var secondAlphaHex = alphaHex;
>, <Line: -                var gradientType = opts && opts.gradientType ? "GradientType = 1, " : "";
>, <Line: -                if (secondColor) {
>, <Line: -                    var s = tinycolor(secondColor);
>, <Line: -                    secondHex = s.toHex();
>, <Line: -                    secondAlphaHex = Math.round(parseFloat(s.alpha) * 255).toString(16);
>, <Line: -                }
>, <Line: -                return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr=#" + pad2(alphaHex) + hex + ",endColorstr=#" + pad2(secondAlphaHex) + secondHex + ")";
>, <Line: -            },
>, <Line: -            toString: function(format) {
>, <Line: -                var formatSet = !!format;
>, <Line: -                format = format || this.format;
>, <Line: -                var formattedString = false;
>, <Line: -                var hasAlphaAndFormatNotSet = !formatSet && a < 1 && a > 0;
>, <Line: -                var formatWithAlpha = hasAlphaAndFormatNotSet && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
>, <Line: -                if (format === "rgb") {
>, <Line: -                    formattedString = this.toRgbString();
>, <Line: -                }
>, <Line: -                if (format === "prgb") {
>, <Line: -                    formattedString = this.toPercentageRgbString();
>, <Line: -                }
>, <Line: -                if (format === "hex" || format === "hex6") {
>, <Line: -                    formattedString = this.toHexString();
>, <Line: -                }
>, <Line: -                if (format === "hex3") {
>, <Line: -                    formattedString = this.toHexString(true);
>, <Line: -                }
>, <Line: -                if (format === "name") {
>, <Line: -                    formattedString = this.toName();
>, <Line: -                }
>, <Line: -                if (format === "hsl") {
>, <Line: -                    formattedString = this.toHslString();
>, <Line: -                }
>, <Line: -                if (format === "hsv") {
>, <Line: -                    formattedString = this.toHsvString();
>, <Line: -                }
>, <Line: -                if (formatWithAlpha) {
>, <Line: -                    return this.toRgbString();
>, <Line: -                }
>, <Line: -                return formattedString || this.toHexString();
>, <Line: -            }
>, <Line: -        };
>, <Line: -    }
>, <Line: -    // If input is an object, force 1 into "1.0" to handle ratios properly
>, <Line: -    // String input requires "1.0" as input, so 1 will be treated as 1
>, <Line: -    tinycolor.fromRatio = function(color, opts) {
>, <Line: -        if (typeof color == "object") {
>, <Line: -            var newColor = {};
>, <Line: -            for (var i in color) {
>, <Line: -                if (color.hasOwnProperty(i)) {
>, <Line: -                    if (i === "a") {
>, <Line: -                        newColor[i] = color[i];
>, <Line: -                    }
>, <Line: -                    else {
>, <Line: -                        newColor[i] = convertToPercentage(color[i]);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -            }
>, <Line: -            color = newColor;
>, <Line: -        }
>, <Line: -        return tinycolor(color, opts);
>, <Line: -    };
>, <Line: -    // Given a string or object, convert that input to RGB
>, <Line: -    // Possible string inputs:
>, <Line: -    //
>, <Line: -    //     "red"
>, <Line: -    //     "#f00" or "f00"
>, <Line: -    //     "#ff0000" or "ff0000"
>, <Line: -    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
>, <Line: -    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
>, <Line: -    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
>, <Line: -    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
>, <Line: -    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
>, <Line: -    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
>, <Line: -    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
>, <Line: -    //
>, <Line: -    function inputToRGB(color) {
>, <Line: -        var rgb = { r: 0, g: 0, b: 0 };
>, <Line: -        var a = 1;
>, <Line: -        var ok = false;
>, <Line: -        var format = false;
>, <Line: -        if (typeof color == "string") {
>, <Line: -            color = stringInputToObject(color);
>, <Line: -        }
>, <Line: -        if (typeof color == "object") {
>, <Line: -            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
>, <Line: -                rgb = rgbToRgb(color.r, color.g, color.b);
>, <Line: -                ok = true;
>, <Line: -                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
>, <Line: -            }
>, <Line: -            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
>, <Line: -                color.s = convertToPercentage(color.s);
>, <Line: -                color.v = convertToPercentage(color.v);
>, <Line: -                rgb = hsvToRgb(color.h, color.s, color.v);
>, <Line: -                ok = true;
>, <Line: -                format = "hsv";
>, <Line: -            }
>, <Line: -            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
>, <Line: -                color.s = convertToPercentage(color.s);
>, <Line: -                color.l = convertToPercentage(color.l);
>, <Line: -                rgb = hslToRgb(color.h, color.s, color.l);
>, <Line: -                ok = true;
>, <Line: -                format = "hsl";
>, <Line: -            }
>, <Line: -            if (color.hasOwnProperty("a")) {
>, <Line: -                a = color.a;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        a = boundAlpha(a);
>, <Line: -        return {
>, <Line: -            ok: ok,
>, <Line: -            format: color.format || format,
>, <Line: -            r: mathMin(255, mathMax(rgb.r, 0)),
>, <Line: -            g: mathMin(255, mathMax(rgb.g, 0)),
>, <Line: -            b: mathMin(255, mathMax(rgb.b, 0)),
>, <Line: -            a: a
>, <Line: -        };
>, <Line: -    }
>, <Line: -    // Conversion Functions
>, <Line: -    // --------------------
>, <Line: -    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
>, <Line: -    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
>, <Line: -    // `rgbToRgb`
>, <Line: -    // Handle bounds / percentage checking to conform to CSS color spec
>, <Line: -    // <http://www.w3.org/TR/css3-color/>
>, <Line: -    // *Assumes:* r, g, b in [0, 255] or [0, 1]
>, <Line: -    // *Returns:* { r, g, b } in [0, 255]
>, <Line: -    function rgbToRgb(r, g, b){
>, <Line: -        return {
>, <Line: -            r: bound01(r, 255) * 255,
>, <Line: -            g: bound01(g, 255) * 255,
>, <Line: -            b: bound01(b, 255) * 255
>, <Line: -        };
>, <Line: -    }
>, <Line: -    // `rgbToHsl`
>, <Line: -    // Converts an RGB color value to HSL.
>, <Line: -    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
>, <Line: -    // *Returns:* { h, s, l } in [0,1]
>, <Line: -    function rgbToHsl(r, g, b) {
>, <Line: -        r = bound01(r, 255);
>, <Line: -        g = bound01(g, 255);
>, <Line: -        b = bound01(b, 255);
>, <Line: -        var max = mathMax(r, g, b), min = mathMin(r, g, b);
>, <Line: -        var h, s, l = (max + min) / 2;
>, <Line: -        if(max == min) {
>, <Line: -            h = s = 0; // achromatic
>, <Line: -        }
>, <Line: -        else {
>, <Line: -            var d = max - min;
>, <Line: -            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
>, <Line: -            switch(max) {
>, <Line: -                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
>, <Line: -                case g: h = (b - r) / d + 2; break;
>, <Line: -                case b: h = (r - g) / d + 4; break;
>, <Line: -            }
>, <Line: -            h /= 6;
>, <Line: -        }
>, <Line: -        return { h: h, s: s, l: l };
>, <Line: -    }
>, <Line: -    // `hslToRgb`
>, <Line: -    // Converts an HSL color value to RGB.
>, <Line: -    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
>, <Line: -    // *Returns:* { r, g, b } in the set [0, 255]
>, <Line: -    function hslToRgb(h, s, l) {
>, <Line: -        var r, g, b;
>, <Line: -        h = bound01(h, 360);
>, <Line: -        s = bound01(s, 100);
>, <Line: -        l = bound01(l, 100);
>, <Line: -        function hue2rgb(p, q, t) {
>, <Line: -            if(t < 0) t += 1;
>, <Line: -            if(t > 1) t -= 1;
>, <Line: -            if(t < 1/6) return p + (q - p) * 6 * t;
>, <Line: -            if(t < 1/2) return q;
>, <Line: -            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
>, <Line: -            return p;
>, <Line: -        }
>, <Line: -        if(s === 0) {
>, <Line: -            r = g = b = l; // achromatic
>, <Line: -        }
>, <Line: -        else {
>, <Line: -            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
>, <Line: -            var p = 2 * l - q;
>, <Line: -            r = hue2rgb(p, q, h + 1/3);
>, <Line: -            g = hue2rgb(p, q, h);
>, <Line: -            b = hue2rgb(p, q, h - 1/3);
>, <Line: -        }
>, <Line: -        return { r: r * 255, g: g * 255, b: b * 255 };
>, <Line: -    }
>, <Line: -    // `rgbToHsv`
>, <Line: -    // Converts an RGB color value to HSV
>, <Line: -    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
>, <Line: -    // *Returns:* { h, s, v } in [0,1]
>, <Line: -    function rgbToHsv(r, g, b) {
>, <Line: -        r = bound01(r, 255);
>, <Line: -        g = bound01(g, 255);
>, <Line: -        b = bound01(b, 255);
>, <Line: -        var max = mathMax(r, g, b), min = mathMin(r, g, b);
>, <Line: -        var h, s, v = max;
>, <Line: -        var d = max - min;
>, <Line: -        s = max === 0 ? 0 : d / max;
>, <Line: -        if(max == min) {
>, <Line: -            h = 0; // achromatic
>, <Line: -        }
>, <Line: -        else {
>, <Line: -            switch(max) {
>, <Line: -                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
>, <Line: -                case g: h = (b - r) / d + 2; break;
>, <Line: -                case b: h = (r - g) / d + 4; break;
>, <Line: -            }
>, <Line: -            h /= 6;
>, <Line: -        }
>, <Line: -        return { h: h, s: s, v: v };
>, <Line: -    }
>, <Line: -    // `hsvToRgb`
>, <Line: -    // Converts an HSV color value to RGB.
>, <Line: -    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
>, <Line: -    // *Returns:* { r, g, b } in the set [0, 255]
>, <Line: -     function hsvToRgb(h, s, v) {
>, <Line: -        h = bound01(h, 360) * 6;
>, <Line: -        s = bound01(s, 100);
>, <Line: -        v = bound01(v, 100);
>, <Line: -        var i = math.floor(h),
>, <Line: -            f = h - i,
>, <Line: -            p = v * (1 - s),
>, <Line: -            q = v * (1 - f * s),
>, <Line: -            t = v * (1 - (1 - f) * s),
>, <Line: -            mod = i % 6,
>, <Line: -            r = [v, q, p, p, t, v][mod],
>, <Line: -            g = [t, v, v, q, p, p][mod],
>, <Line: -            b = [p, p, t, v, v, q][mod];
>, <Line: -        return { r: r * 255, g: g * 255, b: b * 255 };
>, <Line: -    }
>, <Line: -    // `rgbToHex`
>, <Line: -    // Converts an RGB color to hex
>, <Line: -    // Assumes r, g, and b are contained in the set [0, 255]
>, <Line: -    // Returns a 3 or 6 character hex
>, <Line: -    function rgbToHex(r, g, b, allow3Char) {
>, <Line: -        var hex = [
>, <Line: -            pad2(mathRound(r).toString(16)),
>, <Line: -            pad2(mathRound(g).toString(16)),
>, <Line: -            pad2(mathRound(b).toString(16))
>, <Line: -        ];
>, <Line: -        // Return a 3 character hex if possible
>, <Line: -        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
>, <Line: -            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
>, <Line: -        }
>, <Line: -        return hex.join("");
>, <Line: -    }
>, <Line: -    // `equals`
>, <Line: -    // Can be called with any tinycolor input
>, <Line: -    tinycolor.equals = function (color1, color2) {
>, <Line: -        if (!color1 || !color2) { return false; }
>, <Line: -        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
>, <Line: -    };
>, <Line: -    tinycolor.random = function() {
>, <Line: -        return tinycolor.fromRatio({
>, <Line: -            r: mathRandom(),
>, <Line: -            g: mathRandom(),
>, <Line: -            b: mathRandom()
>, <Line: -        });
>, <Line: -    };
>, <Line: -    // Modification Functions
>, <Line: -    // ----------------------
>, <Line: -    // Thanks to less.js for some of the basics here
>, <Line: -    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>
>, <Line: -    tinycolor.desaturate = function (color, amount) {
>, <Line: -        amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        hsl.s -= amount / 100;
>, <Line: -        hsl.s = clamp01(hsl.s);
>, <Line: -        return tinycolor(hsl);
>, <Line: -    };
>, <Line: -    tinycolor.saturate = function (color, amount) {
>, <Line: -        amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        hsl.s += amount / 100;
>, <Line: -        hsl.s = clamp01(hsl.s);
>, <Line: -        return tinycolor(hsl);
>, <Line: -    };
>, <Line: -    tinycolor.greyscale = function(color) {
>, <Line: -        return tinycolor.desaturate(color, 100);
>, <Line: -    };
>, <Line: -    tinycolor.lighten = function(color, amount) {
>, <Line: -        amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        hsl.l += amount / 100;
>, <Line: -        hsl.l = clamp01(hsl.l);
>, <Line: -        return tinycolor(hsl);
>, <Line: -    };
>, <Line: -    tinycolor.darken = function (color, amount) {
>, <Line: -        amount = (amount === 0) ? 0 : (amount || 10);
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        hsl.l -= amount / 100;
>, <Line: -        hsl.l = clamp01(hsl.l);
>, <Line: -        return tinycolor(hsl);
>, <Line: -    };
>, <Line: -    tinycolor.complement = function(color) {
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        hsl.h = (hsl.h + 180) % 360;
>, <Line: -        return tinycolor(hsl);
>, <Line: -    };
>, <Line: -    // Combination Functions
>, <Line: -    // ---------------------
>, <Line: -    // Thanks to jQuery xColor for some of the ideas behind these
>, <Line: -    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>
>, <Line: -    tinycolor.triad = function(color) {
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        var h = hsl.h;
>, <Line: -        return [
>, <Line: -            tinycolor(color),
>, <Line: -            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
>, <Line: -            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
>, <Line: -        ];
>, <Line: -    };
>, <Line: -    tinycolor.tetrad = function(color) {
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        var h = hsl.h;
>, <Line: -        return [
>, <Line: -            tinycolor(color),
>, <Line: -            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
>, <Line: -            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
>, <Line: -            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
>, <Line: -        ];
>, <Line: -    };
>, <Line: -    tinycolor.splitcomplement = function(color) {
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        var h = hsl.h;
>, <Line: -        return [
>, <Line: -            tinycolor(color),
>, <Line: -            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
>, <Line: -            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
>, <Line: -        ];
>, <Line: -    };
>, <Line: -    tinycolor.analogous = function(color, results, slices) {
>, <Line: -        results = results || 6;
>, <Line: -        slices = slices || 30;
>, <Line: -        var hsl = tinycolor(color).toHsl();
>, <Line: -        var part = 360 / slices;
>, <Line: -        var ret = [tinycolor(color)];
>, <Line: -        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
>, <Line: -            hsl.h = (hsl.h + part) % 360;
>, <Line: -            ret.push(tinycolor(hsl));
>, <Line: -        }
>, <Line: -        return ret;
>, <Line: -    };
>, <Line: -    tinycolor.monochromatic = function(color, results) {
>, <Line: -        results = results || 6;
>, <Line: -        var hsv = tinycolor(color).toHsv();
>, <Line: -        var h = hsv.h, s = hsv.s, v = hsv.v;
>, <Line: -        var ret = [];
>, <Line: -        var modification = 1 / results;
>, <Line: -        while (results--) {
>, <Line: -            ret.push(tinycolor({ h: h, s: s, v: v}));
>, <Line: -            v = (v + modification) % 1;
>, <Line: -        }
>, <Line: -        return ret;
>, <Line: -    };
>, <Line: -    // Readability Functions
>, <Line: -    // ---------------------
>, <Line: -    // <http://www.w3.org/TR/AERT#color-contrast>
>, <Line: -    // `readability`
>, <Line: -    // Analyze the 2 colors and returns an object with the following properties:
>, <Line: -    //    `brightness`: difference in brightness between the two colors
>, <Line: -    //    `color`: difference in color/hue between the two colors
>, <Line: -    tinycolor.readability = function(color1, color2) {
>, <Line: -        var a = tinycolor(color1).toRgb();
>, <Line: -        var b = tinycolor(color2).toRgb();
>, <Line: -        var brightnessA = (a.r * 299 + a.g * 587 + a.b * 114) / 1000;
>, <Line: -        var brightnessB = (b.r * 299 + b.g * 587 + b.b * 114) / 1000;
>, <Line: -        var colorDiff = (
>, <Line: -            Math.max(a.r, b.r) - Math.min(a.r, b.r) +
>, <Line: -            Math.max(a.g, b.g) - Math.min(a.g, b.g) +
>, <Line: -            Math.max(a.b, b.b) - Math.min(a.b, b.b)
>, <Line: -        );
>, <Line: -        return {
>, <Line: -            brightness: Math.abs(brightnessA - brightnessB),
>, <Line: -            color: colorDiff
>, <Line: -        };
>, <Line: -    };
>, <Line: -    // `readable`
>, <Line: -    // http://www.w3.org/TR/AERT#color-contrast
>, <Line: -    // Ensure that foreground and background color combinations provide sufficient contrast.
>, <Line: -    // *Example*
>, <Line: -    //    tinycolor.readable("#000", "#111") => false
>, <Line: -    tinycolor.readable = function(color1, color2) {
>, <Line: -        var readability = tinycolor.readability(color1, color2);
>, <Line: -        return readability.brightness > 125 && readability.color > 500;
>, <Line: -    };
>, <Line: -    // `mostReadable`
>, <Line: -    // Given a base color and a list of possible foreground or background
>, <Line: -    // colors for that base, returns the most readable color.
>, <Line: -    // *Example*
>, <Line: -    //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
>, <Line: -    tinycolor.mostReadable = function(baseColor, colorList) {
>, <Line: -        var bestColor = null;
>, <Line: -        var bestScore = 0;
>, <Line: -        var bestIsReadable = false;
>, <Line: -        for (var i=0; i < colorList.length; i++) {
>, <Line: -            // We normalize both around the "acceptable" breaking point,
>, <Line: -            // but rank brightness constrast higher than hue.
>, <Line: -            var readability = tinycolor.readability(baseColor, colorList[i]);
>, <Line: -            var readable = readability.brightness > 125 && readability.color > 500;
>, <Line: -            var score = 3 * (readability.brightness / 125) + (readability.color / 500);
>, <Line: -            if ((readable && ! bestIsReadable) ||
>, <Line: -                (readable && bestIsReadable && score > bestScore) ||
>, <Line: -                ((! readable) && (! bestIsReadable) && score > bestScore)) {
>, <Line: -                bestIsReadable = readable;
>, <Line: -                bestScore = score;
>, <Line: -                bestColor = tinycolor(colorList[i]);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return bestColor;
>, <Line: -    };
>, <Line: -    // Big List of Colors
>, <Line: -    // ------------------
>, <Line: -    // <http://www.w3.org/TR/css3-color/#svg-color>
>, <Line: -    var names = tinycolor.names = {
>, <Line: -        aliceblue: "f0f8ff",
>, <Line: -        antiquewhite: "faebd7",
>, <Line: -        aqua: "0ff",
>, <Line: -        aquamarine: "7fffd4",
>, <Line: -        azure: "f0ffff",
>, <Line: -        beige: "f5f5dc",
>, <Line: -        bisque: "ffe4c4",
>, <Line: -        black: "000",
>, <Line: -        blanchedalmond: "ffebcd",
>, <Line: -        blue: "00f",
>, <Line: -        blueviolet: "8a2be2",
>, <Line: -        brown: "a52a2a",
>, <Line: -        burlywood: "deb887",
>, <Line: -        burntsienna: "ea7e5d",
>, <Line: -        cadetblue: "5f9ea0",
>, <Line: -        chartreuse: "7fff00",
>, <Line: -        chocolate: "d2691e",
>, <Line: -        coral: "ff7f50",
>, <Line: -        cornflowerblue: "6495ed",
>, <Line: -        cornsilk: "fff8dc",
>, <Line: -        crimson: "dc143c",
>, <Line: -        cyan: "0ff",
>, <Line: -        darkblue: "00008b",
>, <Line: -        darkcyan: "008b8b",
>, <Line: -        darkgoldenrod: "b8860b",
>, <Line: -        darkgray: "a9a9a9",
>, <Line: -        darkgreen: "006400",
>, <Line: -        darkgrey: "a9a9a9",
>, <Line: -        darkkhaki: "bdb76b",
>, <Line: -        darkmagenta: "8b008b",
>, <Line: -        darkolivegreen: "556b2f",
>, <Line: -        darkorange: "ff8c00",
>, <Line: -        darkorchid: "9932cc",
>, <Line: -        darkred: "8b0000",
>, <Line: -        darksalmon: "e9967a",
>, <Line: -        darkseagreen: "8fbc8f",
>, <Line: -        darkslateblue: "483d8b",
>, <Line: -        darkslategray: "2f4f4f",
>, <Line: -        darkslategrey: "2f4f4f",
>, <Line: -        darkturquoise: "00ced1",
>, <Line: -        darkviolet: "9400d3",
>, <Line: -        deeppink: "ff1493",
>, <Line: -        deepskyblue: "00bfff",
>, <Line: -        dimgray: "696969",
>, <Line: -        dimgrey: "696969",
>, <Line: -        dodgerblue: "1e90ff",
>, <Line: -        firebrick: "b22222",
>, <Line: -        floralwhite: "fffaf0",
>, <Line: -        forestgreen: "228b22",
>, <Line: -        fuchsia: "f0f",
>, <Line: -        gainsboro: "dcdcdc",
>, <Line: -        ghostwhite: "f8f8ff",
>, <Line: -        gold: "ffd700",
>, <Line: -        goldenrod: "daa520",
>, <Line: -        gray: "808080",
>, <Line: -        green: "008000",
>, <Line: -        greenyellow: "adff2f",
>, <Line: -        grey: "808080",
>, <Line: -        honeydew: "f0fff0",
>, <Line: -        hotpink: "ff69b4",
>, <Line: -        indianred: "cd5c5c",
>, <Line: -        indigo: "4b0082",
>, <Line: -        ivory: "fffff0",
>, <Line: -        khaki: "f0e68c",
>, <Line: -        lavender: "e6e6fa",
>, <Line: -        lavenderblush: "fff0f5",
>, <Line: -        lawngreen: "7cfc00",
>, <Line: -        lemonchiffon: "fffacd",
>, <Line: -        lightblue: "add8e6",
>, <Line: -        lightcoral: "f08080",
>, <Line: -        lightcyan: "e0ffff",
>, <Line: -        lightgoldenrodyellow: "fafad2",
>, <Line: -        lightgray: "d3d3d3",
>, <Line: -        lightgreen: "90ee90",
>, <Line: -        lightgrey: "d3d3d3",
>, <Line: -        lightpink: "ffb6c1",
>, <Line: -        lightsalmon: "ffa07a",
>, <Line: -        lightseagreen: "20b2aa",
>, <Line: -        lightskyblue: "87cefa",
>, <Line: -        lightslategray: "789",
>, <Line: -        lightslategrey: "789",
>, <Line: -        lightsteelblue: "b0c4de",
>, <Line: -        lightyellow: "ffffe0",
>, <Line: -        lime: "0f0",
>, <Line: -        limegreen: "32cd32",
>, <Line: -        linen: "faf0e6",
>, <Line: -        magenta: "f0f",
>, <Line: -        maroon: "800000",
>, <Line: -        mediumaquamarine: "66cdaa",
>, <Line: -        mediumblue: "0000cd",
>, <Line: -        mediumorchid: "ba55d3",
>, <Line: -        mediumpurple: "9370db",
>, <Line: -        mediumseagreen: "3cb371",
>, <Line: -        mediumslateblue: "7b68ee",
>, <Line: -        mediumspringgreen: "00fa9a",
>, <Line: -        mediumturquoise: "48d1cc",
>, <Line: -        mediumvioletred: "c71585",
>, <Line: -        midnightblue: "191970",
>, <Line: -        mintcream: "f5fffa",
>, <Line: -        mistyrose: "ffe4e1",
>, <Line: -        moccasin: "ffe4b5",
>, <Line: -        navajowhite: "ffdead",
>, <Line: -        navy: "000080",
>, <Line: -        oldlace: "fdf5e6",
>, <Line: -        olive: "808000",
>, <Line: -        olivedrab: "6b8e23",
>, <Line: -        orange: "ffa500",
>, <Line: -        orangered: "ff4500",
>, <Line: -        orchid: "da70d6",
>, <Line: -        palegoldenrod: "eee8aa",
>, <Line: -        palegreen: "98fb98",
>, <Line: -        paleturquoise: "afeeee",
>, <Line: -        palevioletred: "db7093",
>, <Line: -        papayawhip: "ffefd5",
>, <Line: -        peachpuff: "ffdab9",
>, <Line: -        peru: "cd853f",
>, <Line: -        pink: "ffc0cb",
>, <Line: -        plum: "dda0dd",
>, <Line: -        powderblue: "b0e0e6",
>, <Line: -        purple: "800080",
>, <Line: -        red: "f00",
>, <Line: -        rosybrown: "bc8f8f",
>, <Line: -        royalblue: "4169e1",
>, <Line: -        saddlebrown: "8b4513",
>, <Line: -        salmon: "fa8072",
>, <Line: -        sandybrown: "f4a460",
>, <Line: -        seagreen: "2e8b57",
>, <Line: -        seashell: "fff5ee",
>, <Line: -        sienna: "a0522d",
>, <Line: -        silver: "c0c0c0",
>, <Line: -        skyblue: "87ceeb",
>, <Line: -        slateblue: "6a5acd",
>, <Line: -        slategray: "708090",
>, <Line: -        slategrey: "708090",
>, <Line: -        snow: "fffafa",
>, <Line: -        springgreen: "00ff7f",
>, <Line: -        steelblue: "4682b4",
>, <Line: -        tan: "d2b48c",
>, <Line: -        teal: "008080",
>, <Line: -        thistle: "d8bfd8",
>, <Line: -        tomato: "ff6347",
>, <Line: -        turquoise: "40e0d0",
>, <Line: -        violet: "ee82ee",
>, <Line: -        wheat: "f5deb3",
>, <Line: -        white: "fff",
>, <Line: -        whitesmoke: "f5f5f5",
>, <Line: -        yellow: "ff0",
>, <Line: -        yellowgreen: "9acd32"
>, <Line: -    };
>, <Line: -    // Make it easy to access colors via `hexNames[hex]`
>, <Line: -    var hexNames = tinycolor.hexNames = flip(names);
>, <Line: -    // Utilities
>, <Line: -    // ---------
>, <Line: -    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
>, <Line: -    function flip(o) {
>, <Line: -        var flipped = { };
>, <Line: -        for (var i in o) {
>, <Line: -            if (o.hasOwnProperty(i)) {
>, <Line: -                flipped[o[i]] = i;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        return flipped;
>, <Line: -    }
>, <Line: -    // Return a valid alpha value [0,1] with all invalid values being set to 1
>, <Line: -    function boundAlpha(a) {
>, <Line: -        a = parseFloat(a);
>, <Line: -        if (isNaN(a) || a < 0 || a > 1) {
>, <Line: -            a = 1;
>, <Line: -        }
>, <Line: -        return a;
>, <Line: -    }
>, <Line: -    // Take input from [0, n] and return it as [0, 1]
>, <Line: -    function bound01(n, max) {
>, <Line: -        if (isOnePointZero(n)) { n = "100%"; }
>, <Line: -        var processPercent = isPercentage(n);
>, <Line: -        n = mathMin(max, mathMax(0, parseFloat(n)));
>, <Line: -        // Automatically convert percentage into number
>, <Line: -        if (processPercent) {
>, <Line: -            n = parseInt(n * max, 10) / 100;
>, <Line: -        }
>, <Line: -        // Handle floating point rounding errors
>, <Line: -        if ((math.abs(n - max) < 0.000001)) {
>, <Line: -            return 1;
>, <Line: -        }
>, <Line: -        // Convert into [0, 1] range if it isn't already
>, <Line: -        return (n % max) / parseFloat(max);
>, <Line: -    }
>, <Line: -    // Force a number between 0 and 1
>, <Line: -    function clamp01(val) {
>, <Line: -        return mathMin(1, mathMax(0, val));
>, <Line: -    }
>, <Line: -    // Parse an integer into hex
>, <Line: -    function parseHex(val) {
>, <Line: -        return parseInt(val, 16);
>, <Line: -    }
>, <Line: -    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
>, <Line: -    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
>, <Line: -    function isOnePointZero(n) {
>, <Line: -        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
>, <Line: -    }
>, <Line: -    // Check to see if string passed in is a percentage
>, <Line: -    function isPercentage(n) {
>, <Line: -        return typeof n === "string" && n.indexOf('%') != -1;
>, <Line: -    }
>, <Line: -    // Force a hex value to have 2 characters
>, <Line: -    function pad2(c) {
>, <Line: -        return c.length == 1 ? '0' + c : '' + c;
>, <Line: -    }
>, <Line: -    // Replace a decimal with it's percentage value
>, <Line: -    function convertToPercentage(n) {
>, <Line: -        if (n <= 1) {
>, <Line: -            n = (n * 100) + "%";
>, <Line: -        }
>, <Line: -        return n;
>, <Line: -    }
>, <Line: -    var matchers = (function() {
>, <Line: -        // <http://www.w3.org/TR/css3-values/#integers>
>, <Line: -        var CSS_INTEGER = "[-\\+]?\\d+%?";
>, <Line: -        // <http://www.w3.org/TR/css3-values/#number-value>
>, <Line: -        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
>, <Line: -        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
>, <Line: -        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
>, <Line: -        // Actual matching.
>, <Line: -        // Parentheses and commas are optional, but not required.
>, <Line: -        // Whitespace can take the place of commas or opening paren
>, <Line: -        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
>, <Line: -        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
>, <Line: -        return {
>, <Line: -            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
>, <Line: -            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
>, <Line: -            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
>, <Line: -            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
>, <Line: -            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
>, <Line: -            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
>, <Line: -            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
>, <Line: -        };
>, <Line: -    })();
>, <Line: -    // `stringInputToObject`
>, <Line: -    // Permissive string parsing.  Take in a number of formats, and output an object
>, <Line: -    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
>, <Line: -    function stringInputToObject(color) {
>, <Line: -        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
>, <Line: -        var named = false;
>, <Line: -        if (names[color]) {
>, <Line: -            color = names[color];
>, <Line: -            named = true;
>, <Line: -        }
>, <Line: -        else if (color == 'transparent') {
>, <Line: -            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
>, <Line: -        }
>, <Line: -        // Try to match string input using regular expressions.
>, <Line: -        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
>, <Line: -        // Just return an object and let the conversion functions handle that.
>, <Line: -        // This way the result will be the same whether the tinycolor is initialized with string or object.
>, <Line: -        var match;
>, <Line: -        if ((match = matchers.rgb.exec(color))) {
>, <Line: -            return { r: match[1], g: match[2], b: match[3] };
>, <Line: -        }
>, <Line: -        if ((match = matchers.rgba.exec(color))) {
>, <Line: -            return { r: match[1], g: match[2], b: match[3], a: match[4] };
>, <Line: -        }
>, <Line: -        if ((match = matchers.hsl.exec(color))) {
>, <Line: -            return { h: match[1], s: match[2], l: match[3] };
>, <Line: -        }
>, <Line: -        if ((match = matchers.hsla.exec(color))) {
>, <Line: -            return { h: match[1], s: match[2], l: match[3], a: match[4] };
>, <Line: -        }
>, <Line: -        if ((match = matchers.hsv.exec(color))) {
>, <Line: -            return { h: match[1], s: match[2], v: match[3] };
>, <Line: -        }
>, <Line: -        if ((match = matchers.hex6.exec(color))) {
>, <Line: -            return {
>, <Line: -                r: parseHex(match[1]),
>, <Line: -                g: parseHex(match[2]),
>, <Line: -                b: parseHex(match[3]),
>, <Line: -                format: named ? "name" : "hex"
>, <Line: -            };
>, <Line: -        }
>, <Line: -        if ((match = matchers.hex3.exec(color))) {
>, <Line: -            return {
>, <Line: -                r: parseHex(match[1] + '' + match[1]),
>, <Line: -                g: parseHex(match[2] + '' + match[2]),
>, <Line: -                b: parseHex(match[3] + '' + match[3]),
>, <Line: -                format: named ? "name" : "hex"
>, <Line: -            };
>, <Line: -        }
>, <Line: -        return false;
>, <Line: -    }
>, <Line: -    // Expose tinycolor to window, does not need to run in non-browser context.
>, <Line: -    window.tinycolor = tinycolor;
>, <Line: -    })();
>, <Line: -    $(function () {
>, <Line: -        if ($.fn.spectrum.load) {
>, <Line: -            $.fn.spectrum.processNativeColorInputs();
>, <Line: -        }
>, <Line: -    });
>]