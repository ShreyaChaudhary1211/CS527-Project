[<Line: +	"use strict";
>, <Line: +	var defaultOptions = {
>, <Line: +		tagClass: function (item) {
>, <Line: +			return 'label label-info';
>, <Line: +		},
>, <Line: +		itemValue: function (item) {
>, <Line: +			return item ? item.toString() : item;
>, <Line: +		},
>, <Line: +		itemText: function (item) {
>, <Line: +			return this.itemValue(item);
>, <Line: +		},
>, <Line: +		freeInput: true,
>, <Line: +		maxTags: undefined,
>, <Line: +		confirmKeys: [13],
>, <Line: +		onTagExists: function (item, $tag) {
>, <Line: +			$tag.hide().fadeIn();
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * Constructor function
>, <Line: +	 */
>, <Line: +	function TagsInput(element, options) {
>, <Line: +		this.itemsArray = [];
>, <Line: +		this.$element = $(element);
>, <Line: +		this.$element.hide();
>, <Line: +		this.isSelect = (element.tagName === 'SELECT');
>, <Line: +		this.multiple = (this.isSelect && element.hasAttribute('multiple'));
>, <Line: +		this.objectItems = options && options.itemValue;
>, <Line: +		this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
>, <Line: +		this.inputSize = Math.max(1, this.placeholderText.length);
>, <Line: +		this.$container = $('<div class="bootstrap-tagsinput"></div>');
>, <Line: +		this.$input = $('<input size="' + this.inputSize + '" type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);
>, <Line: +		this.$element.after(this.$container);
>, <Line: +		this.build(options);
>, <Line: +	}
>, <Line: +	TagsInput.prototype = {
>, <Line: +		constructor: TagsInput,
>, <Line: +		/**
>, <Line: +		 * Adds the given item as a new tag. Pass true to dontPushVal to prevent
>, <Line: +		 * updating the elements val()
>, <Line: +		 */
>, <Line: +		add: function (item, dontPushVal) {
>, <Line: +			var self = this;
>, <Line: +			if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
>, <Line: +				return;
>, <Line: +			// Ignore falsey values, except false
>, <Line: +			if (item !== false && !item)
>, <Line: +				return;
>, <Line: +			// Throw an error when trying to add an object while the itemValue option was not set
>, <Line: +			if (typeof item === "object" && !self.objectItems)
>, <Line: +				throw("Can't add objects when itemValue option is not set");
>, <Line: +			// Ignore strings only containg whitespace
>, <Line: +			if (item.toString().match(/^\s*$/))
>, <Line: +				return;
>, <Line: +			// If SELECT but not multiple, remove current tag
>, <Line: +			if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
>, <Line: +				self.remove(self.itemsArray[0]);
>, <Line: +			if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
>, <Line: +				var items = item.split(',');
>, <Line: +				if (items.length > 1) {
>, <Line: +					for (var i = 0; i < items.length; i++) {
>, <Line: +						this.add(items[i], true);
>, <Line: +					}
>, <Line: +					if (!dontPushVal)
>, <Line: +						self.pushVal();
>, <Line: +					return;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var itemValue = self.options.itemValue(item),
>, <Line: +				itemText = self.options.itemText(item),
>, <Line: +				tagClass = self.options.tagClass(item);
>, <Line: +			// Ignore items allready added
>, <Line: +			var existing = $.grep(self.itemsArray, function (item) {
>, <Line: +				return self.options.itemValue(item) === itemValue;
>, <Line: +			})[0];
>, <Line: +			if (existing) {
>, <Line: +				// Invoke onTagExists
>, <Line: +				if (self.options.onTagExists) {
>, <Line: +					var $existingTag = $(".tag", self.$container).filter(function () {
>, <Line: +						return $(this).data("item") === existing;
>, <Line: +					});
>, <Line: +					self.options.onTagExists(item, $existingTag);
>, <Line: +				}
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			// register item in internal array and map
>, <Line: +			self.itemsArray.push(item);
>, <Line: +			// add a tag element
>, <Line: +			var $tag = $('<span class="tag ' + htmlEncode(tagClass) + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
>, <Line: +			$tag.data('item', item);
>, <Line: +			self.findInputWrapper().before($tag);
>, <Line: +			$tag.after(' ');
>, <Line: +			// add <option /> if item represents a value not present in one of the <select />'s options
>, <Line: +			if (self.isSelect && !$('option[value="' + escape(itemValue) + '"]', self.$element)[0]) {
>, <Line: +				var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
>, <Line: +				$option.data('item', item);
>, <Line: +				$option.attr('value', itemValue);
>, <Line: +				self.$element.append($option);
>, <Line: +			}
>, <Line: +			if (!dontPushVal)
>, <Line: +				self.pushVal();
>, <Line: +			// Add class when reached maxTags
>, <Line: +			if (self.options.maxTags === self.itemsArray.length)
>, <Line: +				self.$container.addClass('bootstrap-tagsinput-max');
>, <Line: +			self.$element.trigger($.Event('itemAdded', {item: item}));
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Removes the given item. Pass true to dontPushVal to prevent updating the
>, <Line: +		 * elements val()
>, <Line: +		 */
>, <Line: +		remove: function (item, dontPushVal) {
>, <Line: +			var self = this;
>, <Line: +			if (self.objectItems) {
>, <Line: +				if (typeof item === "object")
>, <Line: +					item = $.grep(self.itemsArray, function (other) {
>, <Line: +						return self.options.itemValue(other) == self.options.itemValue(item);
>, <Line: +					})[0];
>, <Line: +				else
>, <Line: +					item = $.grep(self.itemsArray, function (other) {
>, <Line: +						return self.options.itemValue(other) == item;
>, <Line: +					})[0];
>, <Line: +			}
>, <Line: +			if (item) {
>, <Line: +				$('.tag', self.$container).filter(function () {
>, <Line: +					return $(this).data('item') === item;
>, <Line: +				}).remove();
>, <Line: +				$('option', self.$element).filter(function () {
>, <Line: +					return $(this).data('item') === item;
>, <Line: +				}).remove();
>, <Line: +				self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
>, <Line: +			}
>, <Line: +			if (!dontPushVal)
>, <Line: +				self.pushVal();
>, <Line: +			// Remove class when reached maxTags
>, <Line: +			if (self.options.maxTags > self.itemsArray.length)
>, <Line: +				self.$container.removeClass('bootstrap-tagsinput-max');
>, <Line: +			self.$element.trigger($.Event('itemRemoved', {item: item}));
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Removes all items
>, <Line: +		 */
>, <Line: +		removeAll: function () {
>, <Line: +			var self = this;
>, <Line: +			$('.tag', self.$container).remove();
>, <Line: +			$('option', self.$element).remove();
>, <Line: +			while (self.itemsArray.length > 0)
>, <Line: +				self.itemsArray.pop();
>, <Line: +			self.pushVal();
>, <Line: +			if (self.options.maxTags && !this.isEnabled())
>, <Line: +				this.enable();
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Refreshes the tags so they match the text/value of their corresponding
>, <Line: +		 * item.
>, <Line: +		 */
>, <Line: +		refresh: function () {
>, <Line: +			var self = this;
>, <Line: +			$('.tag', self.$container).each(function () {
>, <Line: +				var $tag = $(this),
>, <Line: +					item = $tag.data('item'),
>, <Line: +					itemValue = self.options.itemValue(item),
>, <Line: +					itemText = self.options.itemText(item),
>, <Line: +					tagClass = self.options.tagClass(item);
>, <Line: +				// Update tag's class and inner text
>, <Line: +				$tag.attr('class', null);
>, <Line: +				$tag.addClass('tag ' + htmlEncode(tagClass));
>, <Line: +				$tag.contents().filter(function () {
>, <Line: +					return this.nodeType == 3;
>, <Line: +				})[0].nodeValue = htmlEncode(itemText);
>, <Line: +				if (self.isSelect) {
>, <Line: +					var option = $('option', self.$element).filter(function () {
>, <Line: +						return $(this).data('item') === item;
>, <Line: +					});
>, <Line: +					option.attr('value', itemValue);
>, <Line: +				}
>, <Line: +			});
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Returns the items added as tags
>, <Line: +		 */
>, <Line: +		items: function () {
>, <Line: +			return this.itemsArray;
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Assembly value by retrieving the value of each item, and set it on the
>, <Line: +		 * element.
>, <Line: +		 */
>, <Line: +		pushVal: function () {
>, <Line: +			var self = this,
>, <Line: +				val = $.map(self.items(), function (item) {
>, <Line: +					return self.options.itemValue(item).toString();
>, <Line: +				});
>, <Line: +			self.$element.val(val, true).trigger('change');
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Initializes the tags input behaviour on the element
>, <Line: +		 */
>, <Line: +		build: function (options) {
>, <Line: +			var self = this;
>, <Line: +			self.options = $.extend({}, defaultOptions, options);
>, <Line: +			var typeahead = self.options.typeahead || {};
>, <Line: +			// When itemValue is set, freeInput should always be false
>, <Line: +			if (self.objectItems)
>, <Line: +				self.options.freeInput = false;
>, <Line: +			makeOptionItemFunction(self.options, 'itemValue');
>, <Line: +			makeOptionItemFunction(self.options, 'itemText');
>, <Line: +			makeOptionItemFunction(self.options, 'tagClass');
>, <Line: +			// for backwards compatibility, self.options.source is deprecated
>, <Line: +			if (self.options.source)
>, <Line: +				typeahead.source = self.options.source;
>, <Line: +			if (typeahead.source && $.fn.typeahead) {
>, <Line: +				makeOptionFunction(typeahead, 'source');
>, <Line: +				self.$input.typeahead({
>, <Line: +					source: function (query, process) {
>, <Line: +						function processItems(items) {
>, <Line: +							var texts = [];
>, <Line: +							for (var i = 0; i < items.length; i++) {
>, <Line: +								var text = self.options.itemText(items[i]);
>, <Line: +								map[text] = items[i];
>, <Line: +								texts.push(text);
>, <Line: +							}
>, <Line: +							process(texts);
>, <Line: +						}
>, <Line: +						this.map = {};
>, <Line: +						var map = this.map,
>, <Line: +							data = typeahead.source(query);
>, <Line: +						if ($.isFunction(data.success)) {
>, <Line: +							// support for Angular promises
>, <Line: +							data.success(processItems);
>, <Line: +						} else {
>, <Line: +							// support for functions and jquery promises
>, <Line: +							$.when(data)
>, <Line: +								.then(processItems);
>, <Line: +						}
>, <Line: +					},
>, <Line: +					updater: function (text) {
>, <Line: +						self.add(this.map[text]);
>, <Line: +					},
>, <Line: +					matcher: function (text) {
>, <Line: +						return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
>, <Line: +					},
>, <Line: +					sorter: function (texts) {
>, <Line: +						return texts.sort();
>, <Line: +					},
>, <Line: +					highlighter: function (text) {
>, <Line: +						var regex = new RegExp('(' + this.query + ')', 'gi');
>, <Line: +						return text.replace(regex, "<strong>$1</strong>");
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +			self.$container.on('click', $.proxy(function (event) {
>, <Line: +				self.$input.focus();
>, <Line: +			}, self));
>, <Line: +			self.$container.on('keydown', 'input', $.proxy(function (event) {
>, <Line: +				var $input = $(event.target),
>, <Line: +					$inputWrapper = self.findInputWrapper();
>, <Line: +				switch (event.which) {
>, <Line: +					// BACKSPACE
>, <Line: +					case 8:
>, <Line: +						if (doGetCaretPosition($input[0]) === 0) {
>, <Line: +							var prev = $inputWrapper.prev();
>, <Line: +							if (prev) {
>, <Line: +								self.remove(prev.data('item'));
>, <Line: +							}
>, <Line: +						}
>, <Line: +						break;
>, <Line: +					// DELETE
>, <Line: +					case 46:
>, <Line: +						if (doGetCaretPosition($input[0]) === 0) {
>, <Line: +							var next = $inputWrapper.next();
>, <Line: +							if (next) {
>, <Line: +								self.remove(next.data('item'));
>, <Line: +							}
>, <Line: +						}
>, <Line: +						break;
>, <Line: +					// LEFT ARROW
>, <Line: +					case 37:
>, <Line: +						// Try to move the input before the previous tag
>, <Line: +						var $prevTag = $inputWrapper.prev();
>, <Line: +						if ($input.val().length === 0 && $prevTag[0]) {
>, <Line: +							$prevTag.before($inputWrapper);
>, <Line: +							$input.focus();
>, <Line: +						}
>, <Line: +						break;
>, <Line: +					// RIGHT ARROW
>, <Line: +					case 39:
>, <Line: +						// Try to move the input after the next tag
>, <Line: +						var $nextTag = $inputWrapper.next();
>, <Line: +						if ($input.val().length === 0 && $nextTag[0]) {
>, <Line: +							$nextTag.after($inputWrapper);
>, <Line: +							$input.focus();
>, <Line: +						}
>, <Line: +						break;
>, <Line: +					default:
>, <Line: +						// When key corresponds one of the confirmKeys, add current input
>, <Line: +						// as a new tag
>, <Line: +						if (self.options.freeInput && $.inArray(event.which, self.options.confirmKeys) >= 0) {
>, <Line: +							self.add($input.val());
>, <Line: +							$input.val('');
>, <Line: +							event.preventDefault();
>, <Line: +						}
>, <Line: +				}
>, <Line: +				// Reset internal input's size
>, <Line: +				$input.attr('size', Math.max(this.inputSize, $input.val().length));
>, <Line: +			}, self));
>, <Line: +			// Remove icon clicked
>, <Line: +			self.$container.on('click', '[data-role=remove]', $.proxy(function (event) {
>, <Line: +				self.remove($(event.target).closest('.tag').data('item'));
>, <Line: +			}, self));
>, <Line: +			// Only add existing value as tags when using strings as tags
>, <Line: +			if (self.options.itemValue === defaultOptions.itemValue) {
>, <Line: +				if (self.$element[0].tagName === 'INPUT') {
>, <Line: +					self.add(self.$element.val());
>, <Line: +				} else {
>, <Line: +					$('option', self.$element).each(function () {
>, <Line: +						self.add($(this).attr('value'), true);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Removes all tagsinput behaviour and unregsiter all event handlers
>, <Line: +		 */
>, <Line: +		destroy: function () {
>, <Line: +			var self = this;
>, <Line: +			// Unbind events
>, <Line: +			self.$container.off('keypress', 'input');
>, <Line: +			self.$container.off('click', '[role=remove]');
>, <Line: +			self.$container.remove();
>, <Line: +			self.$element.removeData('tagsinput');
>, <Line: +			self.$element.show();
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Sets focus on the tagsinput
>, <Line: +		 */
>, <Line: +		focus: function () {
>, <Line: +			this.$input.focus();
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Returns the internal input element
>, <Line: +		 */
>, <Line: +		input: function () {
>, <Line: +			return this.$input;
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Returns the element which is wrapped around the internal input. This
>, <Line: +		 * is normally the $container, but typeahead.js moves the $input element.
>, <Line: +		 */
>, <Line: +		findInputWrapper: function () {
>, <Line: +			var elt = this.$input[0],
>, <Line: +				container = this.$container[0];
>, <Line: +			while (elt && elt.parentNode !== container)
>, <Line: +				elt = elt.parentNode;
>, <Line: +			return $(elt);
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * Register JQuery plugin
>, <Line: +	 */
>, <Line: +	$.fn.tagsinput = function (arg1, arg2) {
>, <Line: +		var results = [];
>, <Line: +		this.each(function () {
>, <Line: +			var tagsinput = $(this).data('tagsinput');
>, <Line: +			// Initialize a new tags input
>, <Line: +			if (!tagsinput) {
>, <Line: +				tagsinput = new TagsInput(this, arg1);
>, <Line: +				$(this).data('tagsinput', tagsinput);
>, <Line: +				results.push(tagsinput);
>, <Line: +				if (this.tagName === 'SELECT') {
>, <Line: +					$('option', $(this)).attr('selected', 'selected');
>, <Line: +				}
>, <Line: +				// Init tags from $(this).val()
>, <Line: +				$(this).val($(this).val());
>, <Line: +			} else {
>, <Line: +				// Invoke function on existing tags input
>, <Line: +				var retVal = tagsinput[arg1](arg2);
>, <Line: +				if (retVal !== undefined)
>, <Line: +					results.push(retVal);
>, <Line: +			}
>, <Line: +		});
>, <Line: +		if (typeof arg1 == 'string') {
>, <Line: +			// Return the results from the invoked function calls
>, <Line: +			return results.length > 1 ? results : results[0];
>, <Line: +		} else {
>, <Line: +			return results;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$.fn.tagsinput.Constructor = TagsInput;
>, <Line: +	/**
>, <Line: +	 * Most options support both a string or number as well as a function as
>, <Line: +	 * option value. This function makes sure that the option with the given
>, <Line: +	 * key in the given options is wrapped in a function
>, <Line: +	 */
>, <Line: +	function makeOptionItemFunction(options, key) {
>, <Line: +		if (typeof options[key] !== 'function') {
>, <Line: +			var propertyName = options[key];
>, <Line: +			options[key] = function (item) {
>, <Line: +				return item[propertyName];
>, <Line: +			};
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function makeOptionFunction(options, key) {
>, <Line: +		if (typeof options[key] !== 'function') {
>, <Line: +			var value = options[key];
>, <Line: +			options[key] = function () {
>, <Line: +				return value;
>, <Line: +			};
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * HtmlEncodes the given value
>, <Line: +	 */
>, <Line: +	var htmlEncodeContainer = $('<div />');
>, <Line: +	function htmlEncode(value) {
>, <Line: +		if (value) {
>, <Line: +			return htmlEncodeContainer.text(value).html();
>, <Line: +		} else {
>, <Line: +			return '';
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Returns the position of the caret in the given input field
>, <Line: +	 * http://flightschool.acylt.com/devnotes/caret-position-woes/
>, <Line: +	 */
>, <Line: +	function doGetCaretPosition(oField) {
>, <Line: +		var iCaretPos = 0;
>, <Line: +		if (document.selection) {
>, <Line: +			oField.focus();
>, <Line: +			var oSel = document.selection.createRange();
>, <Line: +			oSel.moveStart('character', -oField.value.length);
>, <Line: +			iCaretPos = oSel.text.length;
>, <Line: +		} else if (oField.selectionStart || oField.selectionStart == '0') {
>, <Line: +			iCaretPos = oField.selectionStart;
>, <Line: +		}
>, <Line: +		return (iCaretPos);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Initialize tagsinput behaviour on inputs and selects which have
>, <Line: +	 * data-role=tagsinput
>, <Line: +	 */
>, <Line: +	$(function () {
>, <Line: +		$("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
>, <Line: +	});
>]
[<Line: -  "use strict";
>, <Line: -  var defaultOptions = {
>, <Line: -    tagClass: function(item) {
>, <Line: -      return 'label label-info';
>, <Line: -    },
>, <Line: -    itemValue: function(item) {
>, <Line: -      return item ? item.toString() : item;
>, <Line: -    },
>, <Line: -    itemText: function(item) {
>, <Line: -      return this.itemValue(item);
>, <Line: -    },
>, <Line: -    freeInput: true,
>, <Line: -    maxTags: undefined,
>, <Line: -    confirmKeys: [13],
>, <Line: -    onTagExists: function(item, $tag) {
>, <Line: -      $tag.hide().fadeIn();
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * Constructor function
>, <Line: -   */
>, <Line: -  function TagsInput(element, options) {
>, <Line: -    this.itemsArray = [];
>, <Line: -    this.$element = $(element);
>, <Line: -    this.$element.hide();
>, <Line: -    this.isSelect = (element.tagName === 'SELECT');
>, <Line: -    this.multiple = (this.isSelect && element.hasAttribute('multiple'));
>, <Line: -    this.objectItems = options && options.itemValue;
>, <Line: -    this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
>, <Line: -    this.inputSize = Math.max(1, this.placeholderText.length);
>, <Line: -    this.$container = $('<div class="bootstrap-tagsinput"></div>');
>, <Line: -    this.$input = $('<input size="' + this.inputSize + '" type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);
>, <Line: -    this.$element.after(this.$container);
>, <Line: -    this.build(options);
>, <Line: -  }
>, <Line: -  TagsInput.prototype = {
>, <Line: -    constructor: TagsInput,
>, <Line: -    /**
>, <Line: -     * Adds the given item as a new tag. Pass true to dontPushVal to prevent
>, <Line: -     * updating the elements val()
>, <Line: -     */
>, <Line: -    add: function(item, dontPushVal) {
>, <Line: -      var self = this;
>, <Line: -      if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
>, <Line: -        return;
>, <Line: -      // Ignore falsey values, except false
>, <Line: -      if (item !== false && !item)
>, <Line: -        return;
>, <Line: -      // Throw an error when trying to add an object while the itemValue option was not set
>, <Line: -      if (typeof item === "object" && !self.objectItems)
>, <Line: -        throw("Can't add objects when itemValue option is not set");
>, <Line: -      // Ignore strings only containg whitespace
>, <Line: -      if (item.toString().match(/^\s*$/))
>, <Line: -        return;
>, <Line: -      // If SELECT but not multiple, remove current tag
>, <Line: -      if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
>, <Line: -        self.remove(self.itemsArray[0]);
>, <Line: -      if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
>, <Line: -        var items = item.split(',');
>, <Line: -        if (items.length > 1) {
>, <Line: -          for (var i = 0; i < items.length; i++) {
>, <Line: -            this.add(items[i], true);
>, <Line: -          }
>, <Line: -          if (!dontPushVal)
>, <Line: -            self.pushVal();
>, <Line: -          return;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      var itemValue = self.options.itemValue(item),
>, <Line: -          itemText = self.options.itemText(item),
>, <Line: -          tagClass = self.options.tagClass(item);
>, <Line: -      // Ignore items allready added
>, <Line: -      var existing = $.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];
>, <Line: -      if (existing) {
>, <Line: -        // Invoke onTagExists
>, <Line: -        if (self.options.onTagExists) {
>, <Line: -          var $existingTag = $(".tag", self.$container).filter(function() { return $(this).data("item") === existing; });
>, <Line: -          self.options.onTagExists(item, $existingTag);
>, <Line: -        }
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      // register item in internal array and map
>, <Line: -      self.itemsArray.push(item);
>, <Line: -      // add a tag element
>, <Line: -      var $tag = $('<span class="tag ' + htmlEncode(tagClass) + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
>, <Line: -      $tag.data('item', item);
>, <Line: -      self.findInputWrapper().before($tag);
>, <Line: -      $tag.after(' ');
>, <Line: -      // add <option /> if item represents a value not present in one of the <select />'s options
>, <Line: -      if (self.isSelect && !$('option[value="' + escape(itemValue) + '"]',self.$element)[0]) {
>, <Line: -        var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
>, <Line: -        $option.data('item', item);
>, <Line: -        $option.attr('value', itemValue);
>, <Line: -        self.$element.append($option);
>, <Line: -      }
>, <Line: -      if (!dontPushVal)
>, <Line: -        self.pushVal();
>, <Line: -      // Add class when reached maxTags
>, <Line: -      if (self.options.maxTags === self.itemsArray.length)
>, <Line: -        self.$container.addClass('bootstrap-tagsinput-max');
>, <Line: -      self.$element.trigger($.Event('itemAdded', { item: item }));
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Removes the given item. Pass true to dontPushVal to prevent updating the
>, <Line: -     * elements val()
>, <Line: -     */
>, <Line: -    remove: function(item, dontPushVal) {
>, <Line: -      var self = this;
>, <Line: -      if (self.objectItems) {
>, <Line: -        if (typeof item === "object")
>, <Line: -          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } )[0];
>, <Line: -        else
>, <Line: -          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } )[0];
>, <Line: -      }
>, <Line: -      if (item) {
>, <Line: -        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();
>, <Line: -        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();
>, <Line: -        self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
>, <Line: -      }
>, <Line: -      if (!dontPushVal)
>, <Line: -        self.pushVal();
>, <Line: -      // Remove class when reached maxTags
>, <Line: -      if (self.options.maxTags > self.itemsArray.length)
>, <Line: -        self.$container.removeClass('bootstrap-tagsinput-max');
>, <Line: -      self.$element.trigger($.Event('itemRemoved',  { item: item }));
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Removes all items
>, <Line: -     */
>, <Line: -    removeAll: function() {
>, <Line: -      var self = this;
>, <Line: -      $('.tag', self.$container).remove();
>, <Line: -      $('option', self.$element).remove();
>, <Line: -      while(self.itemsArray.length > 0)
>, <Line: -        self.itemsArray.pop();
>, <Line: -      self.pushVal();
>, <Line: -      if (self.options.maxTags && !this.isEnabled())
>, <Line: -        this.enable();
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Refreshes the tags so they match the text/value of their corresponding
>, <Line: -     * item.
>, <Line: -     */
>, <Line: -    refresh: function() {
>, <Line: -      var self = this;
>, <Line: -      $('.tag', self.$container).each(function() {
>, <Line: -        var $tag = $(this),
>, <Line: -            item = $tag.data('item'),
>, <Line: -            itemValue = self.options.itemValue(item),
>, <Line: -            itemText = self.options.itemText(item),
>, <Line: -            tagClass = self.options.tagClass(item);
>, <Line: -          // Update tag's class and inner text
>, <Line: -          $tag.attr('class', null);
>, <Line: -          $tag.addClass('tag ' + htmlEncode(tagClass));
>, <Line: -          $tag.contents().filter(function() {
>, <Line: -            return this.nodeType == 3;
>, <Line: -          })[0].nodeValue = htmlEncode(itemText);
>, <Line: -          if (self.isSelect) {
>, <Line: -            var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });
>, <Line: -            option.attr('value', itemValue);
>, <Line: -          }
>, <Line: -      });
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Returns the items added as tags
>, <Line: -     */
>, <Line: -    items: function() {
>, <Line: -      return this.itemsArray;
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Assembly value by retrieving the value of each item, and set it on the
>, <Line: -     * element.
>, <Line: -     */
>, <Line: -    pushVal: function() {
>, <Line: -      var self = this,
>, <Line: -          val = $.map(self.items(), function(item) {
>, <Line: -            return self.options.itemValue(item).toString();
>, <Line: -          });
>, <Line: -      self.$element.val(val, true).trigger('change');
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Initializes the tags input behaviour on the element
>, <Line: -     */
>, <Line: -    build: function(options) {
>, <Line: -      var self = this;
>, <Line: -      self.options = $.extend({}, defaultOptions, options);
>, <Line: -      var typeahead = self.options.typeahead || {};
>, <Line: -      // When itemValue is set, freeInput should always be false
>, <Line: -      if (self.objectItems)
>, <Line: -        self.options.freeInput = false;
>, <Line: -      makeOptionItemFunction(self.options, 'itemValue');
>, <Line: -      makeOptionItemFunction(self.options, 'itemText');
>, <Line: -      makeOptionItemFunction(self.options, 'tagClass');
>, <Line: -      // for backwards compatibility, self.options.source is deprecated
>, <Line: -      if (self.options.source)
>, <Line: -        typeahead.source = self.options.source;
>, <Line: -      if (typeahead.source && $.fn.typeahead) {
>, <Line: -        makeOptionFunction(typeahead, 'source');
>, <Line: -        self.$input.typeahead({
>, <Line: -          source: function (query, process) {
>, <Line: -            function processItems(items) {
>, <Line: -              var texts = [];
>, <Line: -              for (var i = 0; i < items.length; i++) {
>, <Line: -                var text = self.options.itemText(items[i]);
>, <Line: -                map[text] = items[i];
>, <Line: -                texts.push(text);
>, <Line: -              }
>, <Line: -              process(texts);
>, <Line: -            }
>, <Line: -            this.map = {};
>, <Line: -            var map = this.map,
>, <Line: -                data = typeahead.source(query);
>, <Line: -            if ($.isFunction(data.success)) {
>, <Line: -              // support for Angular promises
>, <Line: -              data.success(processItems);
>, <Line: -            } else {
>, <Line: -              // support for functions and jquery promises
>, <Line: -              $.when(data)
>, <Line: -               .then(processItems);
>, <Line: -            }
>, <Line: -          },
>, <Line: -          updater: function (text) {
>, <Line: -            self.add(this.map[text]);
>, <Line: -          },
>, <Line: -          matcher: function (text) {
>, <Line: -            return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
>, <Line: -          },
>, <Line: -          sorter: function (texts) {
>, <Line: -            return texts.sort();
>, <Line: -          },
>, <Line: -          highlighter: function (text) {
>, <Line: -            var regex = new RegExp( '(' + this.query + ')', 'gi' );
>, <Line: -            return text.replace( regex, "<strong>$1</strong>" );
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      self.$container.on('click', $.proxy(function(event) {
>, <Line: -        self.$input.focus();
>, <Line: -      }, self));
>, <Line: -      self.$container.on('keydown', 'input', $.proxy(function(event) {
>, <Line: -        var $input = $(event.target),
>, <Line: -            $inputWrapper = self.findInputWrapper();
>, <Line: -        switch (event.which) {
>, <Line: -          // BACKSPACE
>, <Line: -          case 8:
>, <Line: -            if (doGetCaretPosition($input[0]) === 0) {
>, <Line: -              var prev = $inputWrapper.prev();
>, <Line: -              if (prev) {
>, <Line: -                self.remove(prev.data('item'));
>, <Line: -              }
>, <Line: -            }
>, <Line: -            break;
>, <Line: -          // DELETE
>, <Line: -          case 46:
>, <Line: -            if (doGetCaretPosition($input[0]) === 0) {
>, <Line: -              var next = $inputWrapper.next();
>, <Line: -              if (next) {
>, <Line: -                self.remove(next.data('item'));
>, <Line: -              }
>, <Line: -            }
>, <Line: -            break;
>, <Line: -          // LEFT ARROW
>, <Line: -          case 37:
>, <Line: -            // Try to move the input before the previous tag
>, <Line: -            var $prevTag = $inputWrapper.prev();
>, <Line: -            if ($input.val().length === 0 && $prevTag[0]) {
>, <Line: -              $prevTag.before($inputWrapper);
>, <Line: -              $input.focus();
>, <Line: -            }
>, <Line: -            break;
>, <Line: -          // RIGHT ARROW
>, <Line: -          case 39:
>, <Line: -            // Try to move the input after the next tag
>, <Line: -            var $nextTag = $inputWrapper.next();
>, <Line: -            if ($input.val().length === 0 && $nextTag[0]) {
>, <Line: -              $nextTag.after($inputWrapper);
>, <Line: -              $input.focus();
>, <Line: -            }
>, <Line: -            break;
>, <Line: -         default:
>, <Line: -            // When key corresponds one of the confirmKeys, add current input
>, <Line: -            // as a new tag
>, <Line: -            if (self.options.freeInput && $.inArray(event.which, self.options.confirmKeys) >= 0) {
>, <Line: -              self.add($input.val());
>, <Line: -              $input.val('');
>, <Line: -              event.preventDefault();
>, <Line: -            }
>, <Line: -        }
>, <Line: -        // Reset internal input's size
>, <Line: -        $input.attr('size', Math.max(this.inputSize, $input.val().length));
>, <Line: -      }, self));
>, <Line: -      // Remove icon clicked
>, <Line: -      self.$container.on('click', '[data-role=remove]', $.proxy(function(event) {
>, <Line: -        self.remove($(event.target).closest('.tag').data('item'));
>, <Line: -      }, self));
>, <Line: -      // Only add existing value as tags when using strings as tags
>, <Line: -      if (self.options.itemValue === defaultOptions.itemValue) {
>, <Line: -        if (self.$element[0].tagName === 'INPUT') {
>, <Line: -            self.add(self.$element.val());
>, <Line: -        } else {
>, <Line: -          $('option', self.$element).each(function() {
>, <Line: -            self.add($(this).attr('value'), true);
>, <Line: -          });
>, <Line: -        }
>, <Line: -      }
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Removes all tagsinput behaviour and unregsiter all event handlers
>, <Line: -     */
>, <Line: -    destroy: function() {
>, <Line: -      var self = this;
>, <Line: -      // Unbind events
>, <Line: -      self.$container.off('keypress', 'input');
>, <Line: -      self.$container.off('click', '[role=remove]');
>, <Line: -      self.$container.remove();
>, <Line: -      self.$element.removeData('tagsinput');
>, <Line: -      self.$element.show();
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Sets focus on the tagsinput
>, <Line: -     */
>, <Line: -    focus: function() {
>, <Line: -      this.$input.focus();
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Returns the internal input element
>, <Line: -     */
>, <Line: -    input: function() {
>, <Line: -      return this.$input;
>, <Line: -    },
>, <Line: -    /**
>, <Line: -     * Returns the element which is wrapped around the internal input. This
>, <Line: -     * is normally the $container, but typeahead.js moves the $input element.
>, <Line: -     */
>, <Line: -    findInputWrapper: function() {
>, <Line: -      var elt = this.$input[0],
>, <Line: -          container = this.$container[0];
>, <Line: -      while(elt && elt.parentNode !== container)
>, <Line: -        elt = elt.parentNode;
>, <Line: -      return $(elt);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * Register JQuery plugin
>, <Line: -   */
>, <Line: -  $.fn.tagsinput = function(arg1, arg2) {
>, <Line: -    var results = [];
>, <Line: -    this.each(function() {
>, <Line: -      var tagsinput = $(this).data('tagsinput');
>, <Line: -      // Initialize a new tags input
>, <Line: -      if (!tagsinput) {
>, <Line: -        tagsinput = new TagsInput(this, arg1);
>, <Line: -        $(this).data('tagsinput', tagsinput);
>, <Line: -        results.push(tagsinput);
>, <Line: -        if (this.tagName === 'SELECT') {
>, <Line: -          $('option', $(this)).attr('selected', 'selected');
>, <Line: -        }
>, <Line: -        // Init tags from $(this).val()
>, <Line: -        $(this).val($(this).val());
>, <Line: -      } else {
>, <Line: -        // Invoke function on existing tags input
>, <Line: -        var retVal = tagsinput[arg1](arg2);
>, <Line: -        if (retVal !== undefined)
>, <Line: -          results.push(retVal);
>, <Line: -      }
>, <Line: -    });
>, <Line: -    if ( typeof arg1 == 'string') {
>, <Line: -      // Return the results from the invoked function calls
>, <Line: -      return results.length > 1 ? results : results[0];
>, <Line: -    } else {
>, <Line: -      return results;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  $.fn.tagsinput.Constructor = TagsInput;
>, <Line: -  /**
>, <Line: -   * Most options support both a string or number as well as a function as
>, <Line: -   * option value. This function makes sure that the option with the given
>, <Line: -   * key in the given options is wrapped in a function
>, <Line: -   */
>, <Line: -  function makeOptionItemFunction(options, key) {
>, <Line: -    if (typeof options[key] !== 'function') {
>, <Line: -      var propertyName = options[key];
>, <Line: -      options[key] = function(item) { return item[propertyName]; };
>, <Line: -    }
>, <Line: -  }
>, <Line: -  function makeOptionFunction(options, key) {
>, <Line: -    if (typeof options[key] !== 'function') {
>, <Line: -      var value = options[key];
>, <Line: -      options[key] = function() { return value; };
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * HtmlEncodes the given value
>, <Line: -   */
>, <Line: -  var htmlEncodeContainer = $('<div />');
>, <Line: -  function htmlEncode(value) {
>, <Line: -    if (value) {
>, <Line: -      return htmlEncodeContainer.text(value).html();
>, <Line: -    } else {
>, <Line: -      return '';
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Returns the position of the caret in the given input field
>, <Line: -   * http://flightschool.acylt.com/devnotes/caret-position-woes/
>, <Line: -   */
>, <Line: -  function doGetCaretPosition(oField) {
>, <Line: -    var iCaretPos = 0;
>, <Line: -    if (document.selection) {
>, <Line: -      oField.focus ();
>, <Line: -      var oSel = document.selection.createRange();
>, <Line: -      oSel.moveStart ('character', -oField.value.length);
>, <Line: -      iCaretPos = oSel.text.length;
>, <Line: -    } else if (oField.selectionStart || oField.selectionStart == '0') {
>, <Line: -      iCaretPos = oField.selectionStart;
>, <Line: -    }
>, <Line: -    return (iCaretPos);
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * Initialize tagsinput behaviour on inputs and selects which have
>, <Line: -   * data-role=tagsinput
>, <Line: -   */
>, <Line: -  $(function() {
>, <Line: -    $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
>, <Line: -  });
>]