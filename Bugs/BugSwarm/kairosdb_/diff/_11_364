[<Line: +var ROLLUP_URL = "/api/v1/rollups/";
>, <Line: +var semaphore = false;
>, <Line: +var metricList = null;
>, <Line: +module.controller('rollupController', ['$scope', '$http', '$uibModal', 'orderByFilter', 'KairosDBDatasource', simpleController]);
>, <Line: +function simpleController($scope, $http, $uibModal, orderByFilter, KairosDBDatasource) {
>, <Line: +	$scope.TOOLTIP_ADD_ROLL_UP = "Add new roll-up";
>, <Line: +	$scope.TOOLTIP_PASTE_QUERY = "Paste query to create a roll-up";
>, <Line: +	$scope.TOOLTIP_DELETE_ROLLUP = "Delete roll-up";
>, <Line: +	$scope.TOOLTIP_SAMPLING_HELP = "Sampling help";
>, <Line: +	$scope.TOOLTIP_TASK_NAME = "The name of the roll-up name";
>, <Line: +	$scope.TOOLTIP_METRIC_NAME = "The metric the roll-up will query";
>, <Line: +	$scope.TOOLTIP_SAVE_AS = "The new metric that will be created by the roll-up";
>, <Line: +	$scope.TOOLTIP_EXECUTE = "How often the roll-up will be executed";
>, <Line: +	$scope.TOOLTIP_GROUP_BY = "Groups the roll-up query by the tags";
>, <Line: +	$scope.TOOLTIP_TAGS = "Narrows query down by tags";
>, <Line: +	$scope.TOOLTIP_AGGREGATOR = "Aggregators perform an operation on data points and down samples";
>, <Line: +	$scope.TOOLTIP_AGGREGATOR_SAMPLING = "Down sampling for the aggregator";
>, <Line: +	$scope.TOOLTIP_INCOMPLETE = "Roll-up is not complete. Complete all grey-out fields.";
>, <Line: +	$scope.TOOLTIP_COMPLEX = "This roll-up is a complex roll-up and cannot be managed from this UI.";
>, <Line: +	$scope.EXECUTION_TYPES = ["Hourly", "Daily", "Weekly", "Monthly", "Yearly"];
>, <Line: +	$scope.GROUP_BY_TYPES = ["tag", "time"];
>, <Line: +	$scope.AGGREGATORS = ['avg', 'dev', 'max', 'min', 'sum', 'least_squares', 'count', 'percentile'];
>, <Line: +	$scope.DEFAULT_TASK_NAME = "<roll-up name>";
>, <Line: +	$scope.DEFAULT_METRIC_NAME = "<metric name>";
>, <Line: +	$scope.DEFAULT_SAVE_AS = "<new metric name>";
>, <Line: +	$scope.DEFAULT_EXECUTE = $scope.EXECUTION_TYPES[1];
>, <Line: +	$scope.DEFAULT_AGGREGATOR = $scope.AGGREGATORS[4];
>, <Line: +	$scope.METRIC_NAME_LIST_MAX_LENGTH = 20;
>, <Line: +	$scope.DEFAULT_AGGREGATOR_SAMPLING = "1h";
>, <Line: +	$scope.DEFAULT_GROUP_BY_TYPE = "tag";
>, <Line: +	$scope.tasks = [];
>, <Line: +	$http.get(ROLLUP_URL)
>, <Line: +		.success(function (response) {
>, <Line: +			if (response) {
>, <Line: +				_.each(response, function(rollupTask){
>, <Line: +					// convert to a simpler model
>, <Line: +					var task = $scope.toSimpleTask(rollupTask);
>, <Line: +					$scope.tasks.push(task);
>, <Line: +					$scope.checkForIncompleteTask(task)
>, <Line: +				});
>, <Line: +				$scope.tasks = orderByFilter($scope.tasks, "name");
>, <Line: +			}
>, <Line: +		})
>, <Line: +		.error(function (data, status, headers, config) {
>, <Line: +			$scope.alert("Could not read list of roll-ups from server.", status, data);
>, <Line: +		});
>, <Line: +	$scope.onBlur = function (task) {
>, <Line: +		$scope.errors = $scope.validate(task);
>, <Line: +		$scope.checkForIncompleteTask(task);
>, <Line: +		if (!$scope.hasErrors()) {
>, <Line: +			$scope.saveTask(task)
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.deleteSelected = function() {
>, <Line: +		bootbox.confirm({
>, <Line: +			size: 'medium',
>, <Line: +			message: "Are you sure you want to delete the selected rollups?",
>, <Line: +			callback: function (result) {
>, <Line: +				if (result) {
>, <Line: +					_.each($scope.tasks, function (task) {
>, <Line: +						if (task.selected) {
>, <Line: +							$scope.deleteTask(task)
>, <Line: +						}
>, <Line: +					});
>, <Line: +					$scope.displayLastSaved();
>, <Line: +				}
>, <Line: +			}
>, <Line: +		});
>, <Line: +	};
>, <Line: +	$scope.anyTasksSelected = function(){
>, <Line: +		for(var i = 0; i < $scope.tasks.length; i++)
>, <Line: +		{
>, <Line: +			if ($scope.tasks[i].selected)
>, <Line: +			{
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.selectAllTasks = function(){
>, <Line: +		_.each($scope.tasks, function(task){task.selected = true;});
>, <Line: +	};
>, <Line: +	$scope.selectNoTasks = function() {
>, <Line: +		_.each($scope.tasks, function(task){task.selected = false;});
>, <Line: +	};
>, <Line: +	$scope.setExecution = function (task, type) {
>, <Line: +		task.executionType = type;
>, <Line: +		$scope.onBlur(task);
>, <Line: +	};
>, <Line: +	$scope.setGroupBy = function (task, type) {
>, <Line: +		task.groupByType = type;
>, <Line: +		$scope.onBlur(task);
>, <Line: +	};
>, <Line: +	$scope.setAggregator = function (task, aggregator) {
>, <Line: +		task.aggregator = aggregator;
>, <Line: +		$scope.onBlur(task);
>, <Line: +	};
>, <Line: +	$scope.toHumanReadableTimeUnit = function (timeUnit) {
>, <Line: +		if (timeUnit) {
>, <Line: +			if (timeUnit.value == 1)
>, <Line: +				return timeUnit.value + " " + timeUnit.unit.substring(0, timeUnit.unit.length - 1);
>, <Line: +			else
>, <Line: +				return timeUnit.value + " " + timeUnit.unit;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.addTask = function () {
>, <Line: +		var task = {
>, <Line: +			name: $scope.DEFAULT_TASK_NAME,
>, <Line: +			metric_name: $scope.DEFAULT_METRIC_NAME,
>, <Line: +			save_as: $scope.DEFAULT_SAVE_AS,
>, <Line: +			executionType: $scope.DEFAULT_EXECUTE,
>, <Line: +			aggregator: $scope.DEFAULT_AGGREGATOR,
>, <Line: +			aggregator_sampling: $scope.DEFAULT_AGGREGATOR_SAMPLING,
>, <Line: +			group_by_type: $scope.DEFAULT_GROUP_BY_TYPE
>, <Line: +		};
>, <Line: +		task.incomplete = true;
>, <Line: +		$scope.tasks.push(task);
>, <Line: +		return task;
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 Convert a task to the simple model used by the UI
>, <Line: +	 */
>, <Line: +	$scope.toSimpleTask = function (task) {
>, <Line: +		var newTask = {};
>, <Line: +		newTask.id = task.id;
>, <Line: +		newTask.name = task.name;
>, <Line: +		newTask.executionType = $scope.convertFromExecutionInterval(task.execution_interval);
>, <Line: +		if (task.rollups.length > 1){
>, <Line: +			newTask.complex = true;
>, <Line: +		}
>, <Line: +		if (task.rollups.length > 0) {
>, <Line: +			newTask.save_as = task.rollups[0].save_as;
>, <Line: +			var query = task.rollups[0].query;
>, <Line: +			if (query) {
>, <Line: +				$scope.toSimpleQuery(query, newTask, task);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return newTask;
>, <Line: +	};
>, <Line: +	$scope.toSimpleQuery = function(query, newTask) {
>, <Line: +		if (query.metrics) {
>, <Line: +			if (query.metrics.length > 0) {
>, <Line: +				newTask.metric_name = query.metrics[0].name;
>, <Line: +				if (query.metrics[0].group_by && query.metrics[0].group_by.length > 0) {
>, <Line: +					newTask.group_by_type = query.metrics[0].group_by[0].name;
>, <Line: +					newTask.group_by_values = query.metrics[0].group_by[0].tags.join(", ");
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					newTask.group_by_type = $scope.DEFAULT_GROUP_BY_TYPE;
>, <Line: +				}
>, <Line: +				if (query.metrics[0].aggregators.length > 0) {
>, <Line: +					newTask.aggregator = query.metrics[0].aggregators[0].name;
>, <Line: +					newTask.aggregator_sampling = KairosDBDatasource.convertToShortTimeUnit(query.metrics[0].aggregators[0].sampling);
>, <Line: +				}
>, <Line: +				if (query.metrics[0].tags){
>, <Line: +					newTask.tags = query.metrics[0].tags;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 Converts a task from the simple module used by the UI to a the
>, <Line: +	 real representation of a task.
>, <Line: +	 */
>, <Line: +	$scope.toRealTask = function (task) {
>, <Line: +		var newTask = {};
>, <Line: +		var rollups = [];
>, <Line: +		var rollup = {};
>, <Line: +		var query = {};
>, <Line: +		var metrics = [];
>, <Line: +		var metric = {};
>, <Line: +		newTask.id = task.id;
>, <Line: +		newTask.name = task.name;
>, <Line: +		rollup.save_as = task.save_as;
>, <Line: +		metric.name = task.metric_name;
>, <Line: +		if (task.tags){
>, <Line: +			metric.tags = task.tags;
>, <Line: +		}
>, <Line: +		if (task.group_by_type && task.group_by_values && task.group_by_values.length > 0) {
>, <Line: +			var group_by = [];
>, <Line: +			group_by.push({
>, <Line: +				name: task.group_by_type,
>, <Line: +				tags: task.group_by_values.split(", ")
>, <Line: +			});
>, <Line: +			metric.group_by = group_by;
>, <Line: +		}
>, <Line: +		var aggregators = [];
>, <Line: +		var aggregator = {
>, <Line: +			name: task.aggregator,
>, <Line: +			sampling: KairosDBDatasource.convertToKairosInterval(task.aggregator_sampling)
>, <Line: +		};
>, <Line: +		aggregators.push(aggregator);
>, <Line: +		metric.aggregators = aggregators;
>, <Line: +		metrics.push(metric);
>, <Line: +		query.metrics = metrics;
>, <Line: +		rollup.query = query;
>, <Line: +		rollups.push(rollup);
>, <Line: +		newTask.rollups = rollups;
>, <Line: +		newTask.execution_interval = {value: 1, unit: $scope.convertToExecutionInterval(task.executionType)};
>, <Line: +		query.start_relative = {value: 1, unit: "hours"};
>, <Line: +		return newTask;
>, <Line: +	};
>, <Line: +	$scope.convertFromExecutionInterval = function(executionInterval){
>, <Line: +		switch(executionInterval.unit.toLowerCase()){
>, <Line: +			case 'milliseconds':
>, <Line: +			case 'seconds':
>, <Line: +			case 'minutes':
>, <Line: +			case 'hours':
>, <Line: +				return $scope.EXECUTION_TYPES[0];
>, <Line: +			case 'days':
>, <Line: +				return $scope.EXECUTION_TYPES[1];
>, <Line: +			case 'weeks':
>, <Line: +				return $scope.EXECUTION_TYPES[2];
>, <Line: +			case 'months':
>, <Line: +				return $scope.EXECUTION_TYPES[3];
>, <Line: +			case 'years':
>, <Line: +				return $scope.EXECUTION_TYPES[4];
>, <Line: +			default:
>, <Line: +				$scope.alert("Invalid execution interval specified: " + executionInterval.unit);
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.convertToExecutionInterval = function(executionType){
>, <Line: +		switch(executionType){
>, <Line: +			case $scope.EXECUTION_TYPES[0]:
>, <Line: +				return 'hours';
>, <Line: +			case $scope.EXECUTION_TYPES[1]:
>, <Line: +				return "days";
>, <Line: +			case $scope.EXECUTION_TYPES[2]:
>, <Line: +				return "weeks";
>, <Line: +			case $scope.EXECUTION_TYPES[3]:
>, <Line: +				return "months";
>, <Line: +			case $scope.EXECUTION_TYPES[4]:
>, <Line: +				return "years";
>, <Line: +			default:
>, <Line: +				$scope.alert("Invalid execution interval specified: " + executionInterval.unit);
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.displayLastSaved = function()
>, <Line: +	{
>, <Line: +		currentDate = new Date();
>, <Line: +		$scope.lastSaved = (currentDate.getHours() < 10 ? "0" + currentDate.getHours() : currentDate.getHours()) + ":" +
>, <Line: +			(currentDate.getMinutes() < 10 ? "0" + currentDate.getMinutes() : currentDate.getMinutes()) + ":" +
>, <Line: +			(currentDate.getSeconds() < 10 ? "0" + currentDate.getSeconds() : currentDate.getSeconds());
>, <Line: +		// Flash Last Saved message
>, <Line: +		$('#lastSaved').fadeOut('slow').fadeIn('slow').animate({opacity: 1.0}, 1000);
>, <Line: +	};
>, <Line: +	$scope.saveTask = function (task) {
>, <Line: +		var realTask = $scope.toRealTask(task);
>, <Line: +		var res = $http.post(ROLLUP_URL, realTask);
>, <Line: +		res.success(function (data, status, headers, config) {
>, <Line: +			task.id = data.id;
>, <Line: +			$scope.displayLastSaved();
>, <Line: +		});
>, <Line: +		res.error(function (data, status, headers, config) {
>, <Line: +			$scope.alert("Could not save query.", status, data);
>, <Line: +		});
>, <Line: +	};
>, <Line: +	$scope.deleteTask = function (task) {
>, <Line: +		if (task.id) {
>, <Line: +			var res = $http.delete(ROLLUP_URL + task.id);
>, <Line: +			res.success(function (data, status, headers, config) {
>, <Line: +				$scope.removeTaskFromTasks(task);
>, <Line: +			});
>, <Line: +			res.error(function (data, status, headers, config) {
>, <Line: +				$scope.alert("Failed to delete roll-up.", status, data);
>, <Line: +			});
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			// Task has never been saved
>, <Line: +			$scope.removeTaskFromTasks(task);
>, <Line: +			$scope.$apply();
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.deleteTaskWithConfirm = function (task) {
>, <Line: +		bootbox.confirm({
>, <Line: +			size: 'medium',
>, <Line: +			message: "Are you sure you want to delete the rollup?",
>, <Line: +			callback: function (result) {
>, <Line: +				if (result) {
>, <Line: +					$scope.deleteTask(task);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		});
>, <Line: +	};
>, <Line: +	$scope.removeTaskFromTasks = function(task) {
>, <Line: +		for(var i = 0; i < $scope.tasks.length; i++){
>, <Line: +			if (_.isEqual($scope.tasks[i], task)){
>, <Line: +				$scope.tasks.splice(i, 1);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.suggestSaveAs = function (task) {
>, <Line: +		if (!$scope.isMetricOrDefault(task) && $scope.isSaveAsEmptyOrDefault(task)) {
>, <Line: +			task.save_as = task.metric_name + "_rollup";
>, <Line: +		}
>, <Line: +		$scope.onBlur(task);
>, <Line: +	};
>, <Line: +	$scope.isMetricOrDefault = function (task) {
>, <Line: +		return !task.metric_name || task.metric_name == $scope.DEFAULT_METRIC_NAME;
>, <Line: +	};
>, <Line: +	$scope.isSaveAsEmptyOrDefault = function (task) {
>, <Line: +		return !task.save_as || task.save_as == $scope.DEFAULT_SAVE_AS;
>, <Line: +	};
>, <Line: +	$scope.alert = function (message, status, data) {
>, <Line: +		if (status) {
>, <Line: +			var error = "";
>, <Line: +			if (data && data.errors)
>, <Line: +				error = data.errors;
>, <Line: +			bootbox.alert({
>, <Line: +				title: message,
>, <Line: +				message: status + ":" + (error ? error : "" )
>, <Line: +			});
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			bootbox.alert({
>, <Line: +				message: message
>, <Line: +			});
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.suggestMetrics = function (metricName) {
>, <Line: +		if (semaphore) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		var matcher = new RegExp($scope.escapeRegex(metricName), 'i');
>, <Line: +		if (!metricList) {
>, <Line: +			$scope.updateMetricList();
>, <Line: +		}
>, <Line: +		if (_.isEmpty(metricName)) {
>, <Line: +			return metricList;
>, <Line: +		}
>, <Line: +		var sublist = new Array($scope.METRIC_NAME_LIST_MAX_LENGTH);
>, <Line: +		var j = 0;
>, <Line: +		for (var i = 0; i < metricList.length; i++) {
>, <Line: +			if (matcher.test(metricList[i])) {
>, <Line: +				sublist[j] = metricList[i];
>, <Line: +				j++;
>, <Line: +				if (j === $scope.METRIC_NAME_LIST_MAX_LENGTH - 1) {
>, <Line: +					break;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return sublist.slice(0, j);
>, <Line: +	};
>, <Line: +	$scope.updateMetricList = function (callback) {
>, <Line: +		$scope.metricListLoading = true;
>, <Line: +		semaphore = true;
>, <Line: +		metricList = [];
>, <Line: +		KairosDBDatasource.performMetricSuggestQuery().then(function (series) {
>, <Line: +			metricList = series;
>, <Line: +			$scope.metricListLoading = false;
>, <Line: +			semaphore = false;
>, <Line: +			if (callback) {
>, <Line: +				callback();
>, <Line: +			}
>, <Line: +		});
>, <Line: +	};
>, <Line: +	$scope.suggestTagKeys = function (task) {
>, <Line: +		return KairosDBDatasource.performTagSuggestQuery(task.metric_name, 'key', '');
>, <Line: +	};
>, <Line: +	$scope.suggestTagValues = function (task) {
>, <Line: +		return KairosDBDatasource.performTagSuggestQuery(task.metric_name, 'value', task.currentTagKey);
>, <Line: +	};
>, <Line: +	$scope.escapeRegex = function (e) {
>, <Line: +		if (e) {
>, <Line: +			return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
>, <Line: +		}
>, <Line: +		return '';
>, <Line: +	};
>, <Line: +	$scope.pasteQuery = function (task, rollup, edit) {
>, <Line: +		var modalInstance = $uibModal.open({
>, <Line: +			templateUrl: 'rollup-paste-query.html?cacheBust=' + Math.random().toString(36).slice(2), //keep dialog from caching
>, <Line: +			controller: 'PasteQueryCtrl',
>, <Line: +			size: 'md',
>, <Line: +			backdrop: 'static', // disable closing of dialog with click away
>, <Line: +			keyboard: false // disable closing dialog with ESC
>, <Line: +		});
>, <Line: +		modalInstance.result.then(
>, <Line: +			function (response) {
>, <Line: +				var newTask = $scope.addTask();
>, <Line: +				newTask.name = response.name;
>, <Line: +				newTask.executionType = response.executionType;
>, <Line: +				$scope.toSimpleQuery(response.query, newTask);
>, <Line: +				$scope.suggestSaveAs(newTask);
>, <Line: +			});
>, <Line: +	};
>, <Line: +	$scope.checkForIncompleteTask = function(task){
>, <Line: +		if (!task.name || _.isEmpty(task.name) || task.name == $scope.DEFAULT_TASK_NAME) {
>, <Line: +			task.incomplete = true;
>, <Line: +		}
>, <Line: +		else if (!task.metric_name|| _.isEmpty(task.metric_name) || task.metric_name == $scope.DEFAULT_METRIC_NAME) {
>, <Line: +			task.incomplete = true;
>, <Line: +		}
>, <Line: +		else if (!task.save_as|| _.isEmpty(task.save_as) || task.save_as == $scope.DEFAULT_SAVE_AS) {
>, <Line: +			task.incomplete = true;
>, <Line: +		}
>, <Line: +		else if (!task.aggregator_sampling || _.isEmpty(task.aggregator_sampling)) {
>, <Line: +			task.incomplete = true;
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			task.incomplete = false;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	$scope.hasErrors = function () {
>, <Line: +		return !_.isEmpty($scope.errors);
>, <Line: +	};
>, <Line: +	$scope.validate = function(task) {
>, <Line: +		var errs = {};
>, <Line: +		if (!task.name || _.isEmpty(task.name)) {
>, <Line: +			errs.name = "Name cannot be empty.";
>, <Line: +			task.name = $scope.DEFAULT_TASK_NAME;
>, <Line: +			$scope.alert(errs.name);
>, <Line: +		}
>, <Line: +		if (!task.metric_name|| _.isEmpty(task.metric_name)) {
>, <Line: +			errs.name = "Metric cannot be empty.";
>, <Line: +			task.metric_name = $scope.DEFAULT_METRIC_NAME;
>, <Line: +			$scope.alert(errs.name);
>, <Line: +		}
>, <Line: +		if (!task.save_as|| _.isEmpty(task.save_as)) {
>, <Line: +			errs.name = "Save As cannot be empty.";
>, <Line: +			task.save_as = $scope.DEFAULT_SAVE_AS;
>, <Line: +			$scope.alert(errs.name);
>, <Line: +		}
>, <Line: +		if (!task.aggregator_sampling|| _.isEmpty(task.aggregator_sampling)) {
>, <Line: +			errs.name = "aggregator Sampling cannot be empty.";
>, <Line: +			task.aggregator_sampling =  $scope.DEFAULT_AGGREGATOR_SAMPLING;
>, <Line: +			$scope.alert(errs.name);
>, <Line: +		}
>, <Line: +		if (task.aggregator_sampling) {
>, <Line: +			try {
>, <Line: +				KairosDBDatasource.convertToKairosInterval(task.aggregator_sampling);
>, <Line: +			}
>, <Line: +			catch(err){
>, <Line: +				errs.name = "Invalid aggregator Sampling: " + err.message;
>, <Line: +				$scope.alert(errs.name);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return errs;
>, <Line: +	}
>, <Line: +}
>]
[]