[<Line: +var tagList = null;
>, <Line: +module.factory('KairosDBDatasource', function ($q, $http) {
>, <Line: +	function KairosDBDatasource() {
>, <Line: +	}
>, <Line: +	KairosDBDatasource.query = function (options) {
>, <Line: +		var start = options.range.from;
>, <Line: +		var end = options.range.to;
>, <Line: +		var queries = _.compact(_.map(options.targets, _.partial(convertTargetToQuery, options)));
>, <Line: +		// No valid targets, return the empty result to save a round trip.
>, <Line: +		if (_.isEmpty(queries)) {
>, <Line: +			var d = $q.defer();
>, <Line: +			d.resolve({data: []});
>, <Line: +			return d.promise;
>, <Line: +		}
>, <Line: +		return this.performTimeSeriesQuery(queries, start, end).then(handleKairosDBQueryResponse, handleQueryError);
>, <Line: +	};
>, <Line: +	///////////////////////////////////////////////////////////////////////
>, <Line: +	/// Query methods
>, <Line: +	///////////////////////////////////////////////////////////////////////
>, <Line: +	KairosDBDatasource.performTimeSeriesQuery = function (queries, start, end) {
>, <Line: +		var reqBody = {
>, <Line: +			metrics: queries
>, <Line: +		};
>, <Line: +		reqBody.cache_time = 0;
>, <Line: +		convertToKairosTime(start, reqBody, 'start');
>, <Line: +		convertToKairosTime(end, reqBody, 'end');
>, <Line: +		var options = {
>, <Line: +			method: 'POST',
>, <Line: +			url: '/api/v1/datapoints/query',
>, <Line: +			data: reqBody
>, <Line: +		};
>, <Line: +		return $http(options);
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * Gets the list of metrics
>, <Line: +	 * @returns {*|Promise}
>, <Line: +	 */
>, <Line: +	KairosDBDatasource.performMetricSuggestQuery = function () {
>, <Line: +		var options = {
>, <Line: +			url: '/api/v1/metricnames',
>, <Line: +			method: 'GET'
>, <Line: +		};
>, <Line: +		return $http(options).then(function (results) {
>, <Line: +			if (!results.data) {
>, <Line: +				return [];
>, <Line: +			}
>, <Line: +			return results.data.results;
>, <Line: +		});
>, <Line: +	};
>, <Line: +	KairosDBDatasource.performTagSuggestQuery = function (metricname, type, keyValue) {
>, <Line: +		if (!metricname || _.isEmpty(metricname)) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		if (tagList && tagList.results && (metricname === tagList.metricName)) /*&& (range.from === tagList.range.from) &&	(range.to === tagList.range.to))*/
>, <Line: +		{
>, <Line: +			return getTagListFromResponse(tagList.results, type, keyValue);
>, <Line: +		}
>, <Line: +		tagList = {
>, <Line: +			metricName: metricname
>, <Line: +		};
>, <Line: +		var body = {
>, <Line: +			metrics: [{name: metricname}],
>, <Line: +			start_absolute: 0
>, <Line: +		};
>, <Line: +		//convertToKairosTime(range.from, body, 'start');
>, <Line: +		//convertToKairosTime(range.to, body, 'end');
>, <Line: +		var options = {
>, <Line: +			url: '/api/v1/datapoints/query/tags',
>, <Line: +			method: 'POST',
>, <Line: +			data: body
>, <Line: +		};
>, <Line: +		return $http(options).then(function (results) {
>, <Line: +				tagList.results = results;
>, <Line: +				return getTagListFromResponse(results, type, keyValue);
>, <Line: +			},
>, <Line: +			function errorCallback(response) {
>, <Line: +				console.log(response);  // todo do something better
>, <Line: +			});
>, <Line: +	};
>, <Line: +	/////////////////////////////////////////////////////////////////////////
>, <Line: +	/// Formatting methods
>, <Line: +	////////////////////////////////////////////////////////////////////////
>, <Line: +	function getTagListFromResponse(results, type, keyValue) {
>, <Line: +		if (!results.data) {
>, <Line: +			return [];
>, <Line: +		}
>, <Line: +		if (type === "key") {
>, <Line: +			return _.keys(results.data.queries[0].results[0].tags);
>, <Line: +		}
>, <Line: +		else if (type === "value" && _.has(results.data.queries[0].results[0].tags, keyValue)) {
>, <Line: +			return results.data.queries[0].results[0].tags[keyValue];
>, <Line: +		}
>, <Line: +		return [];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Requires a verion of KairosDB with every CORS defects fixed
>, <Line: +	 * @param results
>, <Line: +	 * @returns {*}
>, <Line: +	 */
>, <Line: +	function handleQueryError(results) {
>, <Line: +		if (results.data.errors && !_.isEmpty(results.data.errors)) {
>, <Line: +			var errors = {
>, <Line: +				message: results.data.errors[0]
>, <Line: +			};
>, <Line: +			return $q.reject(errors);
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			return $q.reject(results);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function handleKairosDBQueryResponse(results) {
>, <Line: +		var output = [];
>, <Line: +		_.each(results.data.queries, function (series) {
>, <Line: +			//var sample_size = series.sample_size;
>, <Line: +			//console.log("sample_size:" + sample_size + " samples");
>, <Line: +			_.each(series.results, function (result) {
>, <Line: +				var target = result.name;
>, <Line: +				if (result.group_by) {
>, <Line: +					target += " ( ";
>, <Line: +					_.each(result.group_by, function (element) {
>, <Line: +						if (element.name === "tag") {
>, <Line: +							_.each(element.group, function (value, key) {
>, <Line: +								target += key + "=" + value + " ";
>, <Line: +							});
>, <Line: +						}
>, <Line: +						else if (element.name === "value") {
>, <Line: +							target += 'value_group=' + element.group.group_number + " ";
>, <Line: +						}
>, <Line: +						else if (element.name === "time") {
>, <Line: +							target += 'time_group=' + element.group.group_number + " ";
>, <Line: +						}
>, <Line: +					});
>, <Line: +					target += ") ";
>, <Line: +				}
>, <Line: +				var datapoints = [];
>, <Line: +				for (var i = 0; i < result.values.length; i++) {
>, <Line: +					var t = result.values[i][0];
>, <Line: +					var v = result.values[i][1];
>, <Line: +					datapoints[i] = [v, t];
>, <Line: +				}
>, <Line: +				output.push({target: target, datapoints: datapoints});
>, <Line: +			});
>, <Line: +		});
>, <Line: +		return {data: _.flatten(output)};
>, <Line: +	}
>, <Line: +	KairosDBDatasource.convertTargetToQuery = function (options, target) {
>, <Line: +		if (!target.metric || target.hide) {
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +		var query = {
>, <Line: +			name: target.metric
>, <Line: +		};
>, <Line: +		query.aggregators = [];
>, <Line: +		if (target.downsampling !== '(NONE)') {
>, <Line: +			query.aggregators.push({
>, <Line: +				name: target.downsampling,
>, <Line: +				align_sampling: true,
>, <Line: +				sampling: KairosDBDatasource.convertToKairosInterval(target.sampling || options.interval)
>, <Line: +			});
>, <Line: +			if (target.samplingAlignStartTime) {
>, <Line: +				query.aggregators[0].align_start_time = true;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (target.horizontalAggregators) {
>, <Line: +			_.each(target.horizontalAggregators, function (chosenAggregator) {
>, <Line: +				var returnedAggregator = {
>, <Line: +					name: chosenAggregator.name
>, <Line: +				};
>, <Line: +				if (chosenAggregator.sampling_rate) {
>, <Line: +					returnedAggregator.sampling = KairosDBDatasource.convertToKairosInterval(chosenAggregator.sampling_rate);
>, <Line: +					returnedAggregator.align_sampling = true;
>, <Line: +					if (chosenAggregator.align_start_time) {
>, <Line: +						returnedAggregator.align_start_time = true;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (chosenAggregator.unit) {
>, <Line: +					returnedAggregator.unit = chosenAggregator.unit + 's';
>, <Line: +				}
>, <Line: +				if (chosenAggregator.factor && chosenAggregator.name === 'div') {
>, <Line: +					returnedAggregator.divisor = chosenAggregator.factor;
>, <Line: +				}
>, <Line: +				else if (chosenAggregator.factor && chosenAggregator.name === 'scale') {
>, <Line: +					returnedAggregator.factor = chosenAggregator.factor;
>, <Line: +				}
>, <Line: +				if (chosenAggregator.percentile) {
>, <Line: +					returnedAggregator.percentile = chosenAggregator.percentile;
>, <Line: +				}
>, <Line: +				query.aggregators.push(returnedAggregator);
>, <Line: +			});
>, <Line: +		}
>, <Line: +		if (_.isEmpty(query.aggregators)) {
>, <Line: +			delete query.aggregators;
>, <Line: +		}
>, <Line: +		if (target.tags) {
>, <Line: +			query.tags = angular.copy(target.tags);
>, <Line: +		}
>, <Line: +		if (target.groupByTags || target.nonTagGroupBys) {
>, <Line: +			query.group_by = [];
>, <Line: +			if (target.groupByTags) {
>, <Line: +				query.group_by.push({
>, <Line: +					name: "tag",
>, <Line: +					tags: angular.copy(target.groupByTags)
>, <Line: +				});
>, <Line: +			}
>, <Line: +			if (target.nonTagGroupBys) {
>, <Line: +				_.each(target.nonTagGroupBys, function (rawGroupBy) {
>, <Line: +					var formattedGroupBy = angular.copy(rawGroupBy);
>, <Line: +					if (formattedGroupBy.name === 'time') {
>, <Line: +						formattedGroupBy.range_size = KairosDBDatasource.convertToKairosInterval(formattedGroupBy.range_size);
>, <Line: +					}
>, <Line: +					query.group_by.push(formattedGroupBy);
>, <Line: +				});
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return query;
>, <Line: +	};
>, <Line: +	///////////////////////////////////////////////////////////////////////
>, <Line: +	/// Time conversion functions specifics to KairosDB
>, <Line: +	//////////////////////////////////////////////////////////////////////
>, <Line: +	/// "10 seconds" -> {value: 10, unit: "seconds"
>, <Line: +	KairosDBDatasource.convertLongFormatToKairosUnit = function (time) {
>, <Line: +		// todo add validation
>, <Line: +		var timeArray = time.split(" ");
>, <Line: +		var unit = endsWith(timeArray[1], "s") ? timeArray[1] : timeArray[1] + "s";
>, <Line: +		return {
>, <Line: +			"value": timeArray[0],
>, <Line: +			"unit": unit
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/// "10 seconds" -> {value: 10, unit: "seconds"
>, <Line: +	KairosDBDatasource.convertKairosUnitToLongFormat = function (timeUnit) {
>, <Line: +		// todo add validation
>, <Line: +		if (timeUnit.value == 1)
>, <Line: +			return timeUnit.value + " " + timeUnit.unit.substring(0, timeUnit.unit.length - 1);
>, <Line: +		else
>, <Line: +			return timeUnit.value + " " + timeUnit.unit;
>, <Line: +	};
>, <Line: +	KairosDBDatasource.convertToKairosInterval = function (intervalString) {
>, <Line: +		var interval_regex = /(\d+(?:\.\d+)?)([Mwdhmsy])/;
>, <Line: +		var interval_regex_ms = /(\d+(?:\.\d+)?)(ms)/;
>, <Line: +		var matches = intervalString.match(interval_regex_ms);
>, <Line: +		if (!matches) {
>, <Line: +			matches = intervalString.match(interval_regex);
>, <Line: +		}
>, <Line: +		if (!matches) {
>, <Line: +			throw new Error('Expecting a number followed by one of "y M w d h m s ms"');
>, <Line: +		}
>, <Line: +		var value = matches[1];
>, <Line: +		var unit = matches[2];
>, <Line: +		if (value % 1 !== 0) {
>, <Line: +			if (unit === 'ms') {
>, <Line: +				throw new Error('Cannot be smaller than the millisecond');
>, <Line: +			}
>, <Line: +			value = Math.round(kbn.intervals_in_seconds[unit] * value * 1000);
>, <Line: +			unit = 'ms';
>, <Line: +		}
>, <Line: +		switch (unit) {
>, <Line: +			case 'ms':
>, <Line: +				unit = 'milliseconds';
>, <Line: +				break;
>, <Line: +			case 's':
>, <Line: +				unit = 'seconds';
>, <Line: +				break;
>, <Line: +			case 'm':
>, <Line: +				unit = 'minutes';
>, <Line: +				break;
>, <Line: +			case 'h':
>, <Line: +				unit = 'hours';
>, <Line: +				break;
>, <Line: +			case 'd':
>, <Line: +				unit = 'days';
>, <Line: +				break;
>, <Line: +			case 'w':
>, <Line: +				unit = 'weeks';
>, <Line: +				break;
>, <Line: +			case 'M':
>, <Line: +				unit = 'months';
>, <Line: +				break;
>, <Line: +			case 'y':
>, <Line: +				unit = 'years';
>, <Line: +				break;
>, <Line: +			default:
>, <Line: +				//console.log("Unknown interval ", intervalString);
>, <Line: +				break;
>, <Line: +		}
>, <Line: +		return {
>, <Line: +			"value": value,
>, <Line: +			"unit": unit
>, <Line: +		};
>, <Line: +	};
>, <Line: +	KairosDBDatasource.convertToShortTimeUnit = function (timeUnit) {
>, <Line: +		var unit = timeUnit.unit;
>, <Line: +		switch (unit) {
>, <Line: +			case 'milliseconds':
>, <Line: +				unit = 'ms';
>, <Line: +				break;
>, <Line: +			case 'seconds':
>, <Line: +				unit = 's';
>, <Line: +				break;
>, <Line: +			case 'minutes':
>, <Line: +				unit = 'm';
>, <Line: +				break;
>, <Line: +			case 'hours':
>, <Line: +				unit = 'h';
>, <Line: +				break;
>, <Line: +			case 'days':
>, <Line: +				unit = 'd';
>, <Line: +				break;
>, <Line: +			case 'weeks':
>, <Line: +				unit = 'w';
>, <Line: +				break;
>, <Line: +			case 'months':
>, <Line: +				unit = 'M';
>, <Line: +				break;
>, <Line: +			case 'years':
>, <Line: +				unit = 'y';
>, <Line: +				break;
>, <Line: +			default:
>, <Line: +				//console.log("Unknown interval ", intervalString);
>, <Line: +				break;
>, <Line: +		}
>, <Line: +		return timeUnit.value + unit;
>, <Line: +	};
>, <Line: +	function convertToKairosTime(date, response_obj, start_stop_name) {
>, <Line: +		var name;
>, <Line: +		if (_.isString(date)) {
>, <Line: +			if (date === 'now') {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			else if (date.indexOf('now-') >= 0) {
>, <Line: +				name = start_stop_name + "_relative";
>, <Line: +				date = date.substring(4);
>, <Line: +				var re_date = /(\d+)\s*(\D+)/;
>, <Line: +				var result = re_date.exec(date);
>, <Line: +				if (result) {
>, <Line: +					var value = result[1];
>, <Line: +					var unit = result[2];
>, <Line: +					switch (unit) {
>, <Line: +						case 'ms':
>, <Line: +							unit = 'milliseconds';
>, <Line: +							break;
>, <Line: +						case 's':
>, <Line: +							unit = 'seconds';
>, <Line: +							break;
>, <Line: +						case 'm':
>, <Line: +							unit = 'minutes';
>, <Line: +							break;
>, <Line: +						case 'h':
>, <Line: +							unit = 'hours';
>, <Line: +							break;
>, <Line: +						case 'd':
>, <Line: +							unit = 'days';
>, <Line: +							break;
>, <Line: +						case 'w':
>, <Line: +							unit = 'weeks';
>, <Line: +							break;
>, <Line: +						case 'M':
>, <Line: +							unit = 'months';
>, <Line: +							break;
>, <Line: +						case 'y':
>, <Line: +							unit = 'years';
>, <Line: +							break;
>, <Line: +						default:
>, <Line: +							//console.log("Unknown date ", date);
>, <Line: +							break;
>, <Line: +					}
>, <Line: +					response_obj[name] = {
>, <Line: +						"value": value,
>, <Line: +						"unit": unit
>, <Line: +					};
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				//console.log("Unparseable date", date);
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			date = kbn.parseDate(date);
>, <Line: +		}
>, <Line: +		if (_.isDate(date)) {
>, <Line: +			name = start_stop_name + "_absolute";
>, <Line: +			response_obj[name] = date.getTime();
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		//console.log("Date is neither string nor date");
>, <Line: +	}
>, <Line: +	function endsWith(str, suffix) {
>, <Line: +		return str.match(suffix + "$") == suffix;
>, <Line: +	}
>, <Line: +	////////////////////////////////////////////////////////////////////////
>, <Line: +	return KairosDBDatasource;
>, <Line: +});
>]
[]