[<Line: +/*
>, <Line: + * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
>, <Line: + *
>, <Line: + * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: + * you may not use this file except in compliance with the License.
>, <Line: + * You may obtain a copy of the License at
>, <Line: + *
>, <Line: + *         http://www.apache.org/licenses/LICENSE-2.0
>, <Line: + *
>, <Line: + * Unless required by applicable law or agreed to in writing, software
>, <Line: + * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: + * See the License for the specific language governing permissions and
>, <Line: + * limitations under the License.
>, <Line: + */
>, <Line: +package com.github.rinde.rinsim.experiment.base;
>, <Line: +import static com.google.common.base.Preconditions.checkArgument;
>, <Line: +import static com.google.common.base.Preconditions.checkNotNull;
>, <Line: +import static com.google.common.base.Preconditions.checkState;
>, <Line: +import static com.google.common.collect.Lists.newArrayList;
>, <Line: +import static com.google.common.collect.Maps.newLinkedHashMap;
>, <Line: +import java.io.Serializable;
>, <Line: +import java.math.RoundingMode;
>, <Line: +import java.util.Collections;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Map;
>, <Line: +import java.util.Objects;
>, <Line: +import java.util.Set;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
>, <Line: +import org.jppf.JPPFException;
>, <Line: +import org.jppf.client.JPPFClient;
>, <Line: +import org.jppf.client.JPPFJob;
>, <Line: +import org.jppf.client.event.TaskResultEvent;
>, <Line: +import org.jppf.client.event.TaskResultListener;
>, <Line: +import org.jppf.node.protocol.AbstractTask;
>, <Line: +import org.jppf.node.protocol.Task;
>, <Line: +import org.jppf.task.storage.DataProvider;
>, <Line: +import org.jppf.task.storage.MemoryMapDataProvider;
>, <Line: +import com.google.common.base.Function;
>, <Line: +import com.google.common.base.Joiner;
>, <Line: +import com.google.common.base.Optional;
>, <Line: +import com.google.common.base.Supplier;
>, <Line: +import com.google.common.collect.BiMap;
>, <Line: +import com.google.common.collect.ComparisonChain;
>, <Line: +import com.google.common.collect.HashBiMap;
>, <Line: +import com.google.common.collect.ImmutableSet;
>, <Line: +import com.google.common.math.DoubleMath;
>, <Line: +import com.google.common.primitives.Ints;
>, <Line: +final class JppfComputer implements Computer {
>, <Line: +  private static Optional<JPPFClient> client = Optional.absent();
>, <Line: +  private static final String JOB_NAME = "RinSim - Experiment";
>, <Line: +  private static final long THREAD_SLEEP_MS = 1000L;
>, <Line: +  static JPPFClient getJPPFClient() {
>, <Line: +    if (!client.isPresent()) {
>, <Line: +      client = Optional.of(new JPPFClient());
>, <Line: +    }
>, <Line: +    return client.get();
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public ExperimentResults compute(ExperimentBuilder<?> builder,
>, <Line: +      Set<SimArgs> inputs) {
>, <Line: +    final IdMap<Configuration> configMap = new IdMap<>("c",
>, <Line: +        Configuration.class);
>, <Line: +    final IdMap<ScenarioProvider> scenarioMap = new IdMap<>("s",
>, <Line: +        ScenarioProvider.class);
>, <Line: +    final IdMap<ObjectiveFunction> objFuncMap = new IdMap<>("o",
>, <Line: +        ObjectiveFunction.class);
>, <Line: +    final List<ResultListener> listeners = newArrayList(builder.resultListeners);
>, <Line: +    @SuppressWarnings("rawtypes")
>, <Line: +    final IdMap<PostProcessor> ppMap = new IdMap<>("p", PostProcessor.class);
>, <Line: +    final Map<String, Scenario> scenariosMap = newLinkedHashMap();
>, <Line: +    // create tasks
>, <Line: +    final List<SimulationTask> tasks = newArrayList();
>, <Line: +    for (final SimArgs args : inputs) {
>, <Line: +      final String configId = configMap.storeAndGenerateId(
>, <Line: +          args.configuration);
>, <Line: +      final String scenId = scenarioMap.storeAndGenerateId(
>, <Line: +          null);
>, <Line: +      // FIXME find some generic way to (de)serialize scenarios
>, <Line: +      // new ScenarioProvider(ScenarioIO.write(args.scenario),
>, <Line: +      // args.scenario.getClass()));
>, <Line: +      scenariosMap.put(scenId, args.scenario);
>, <Line: +      // final String objFuncId = objFuncMap.storeAndGenerateId(
>, <Line: +      // args.objectiveFunction);
>, <Line: +      // final Optional<String> postProcId;
>, <Line: +      // if (args.postProcessor.isPresent()) {
>, <Line: +      // postProcId = Optional.of(ppMap.storeAndGenerateId(args.postProcessor
>, <Line: +      // .get()));
>, <Line: +      // } else {
>, <Line: +      // postProcId = Optional.absent();
>, <Line: +      // }
>, <Line: +      tasks.add(new SimulationTask(tasks.size(), args.randomSeed, scenId,
>, <Line: +          configId));
>, <Line: +    }
>, <Line: +    // this sorts tasks using this chain: scenario, configuration, objective
>, <Line: +    // function, postprocessor, seed
>, <Line: +    Collections.sort(tasks);
>, <Line: +    // determine size of batches
>, <Line: +    final int numBatches = Math.min(tasks.size(), builder.numBatches);
>, <Line: +    final int batchSize = DoubleMath.roundToInt(tasks.size()
>, <Line: +        / (double) numBatches, RoundingMode.CEILING);
>, <Line: +    final Map<Task<?>, JPPFJob> taskJobMap = newLinkedHashMap();
>, <Line: +    final ResultsCollector res = new ResultsCollector(tasks.size(),
>, <Line: +        scenariosMap, taskJobMap, listeners);
>, <Line: +    final List<JPPFJob> jobs = newArrayList();
>, <Line: +    for (int i = 0; i < numBatches; i++) {
>, <Line: +      final JPPFJob job = new JPPFJob(new MemoryMapDataProvider(), res);
>, <Line: +      job.setName(Joiner.on("").join(JOB_NAME, " ", i + 1, "/", numBatches));
>, <Line: +      jobs.add(job);
>, <Line: +      for (final SimulationTask t : tasks.subList(i * batchSize, (i + 1)
>, <Line: +          * batchSize)) {
>, <Line: +        try {
>, <Line: +          final Configuration config = configMap.getValue(t
>, <Line: +              .getConfigurationId());
>, <Line: +          final ScenarioProvider scenario = scenarioMap.getValue(t
>, <Line: +              .getScenarioId());
>, <Line: +          // final ObjectiveFunction objFunc = objFuncMap.getValue(t
>, <Line: +          // .getObjectiveFunctionId());
>, <Line: +          // if (t.getPostProcessorId().isPresent()) {
>, <Line: +          // job.getDataProvider().setParameter(t.getPostProcessorId().get(),
>, <Line: +          // ppMap.getValue(t.getPostProcessorId().get()));
>, <Line: +          // }
>, <Line: +          job.getDataProvider().setParameter(t.getConfigurationId(), config);
>, <Line: +          job.getDataProvider().setParameter(t.getScenarioId(), scenario);
>, <Line: +          // job.getDataProvider().setParameter(t.getObjectiveFunctionId(),
>, <Line: +          // objFunc);
>, <Line: +          job.add(t);
>, <Line: +        } catch (final JPPFException e) {
>, <Line: +          throw new IllegalStateException(e);
>, <Line: +        }
>, <Line: +        taskJobMap.put(t, job);
>, <Line: +      }
>, <Line: +    }
>, <Line: +    for (final ResultListener l : listeners) {
>, <Line: +      l.startComputing(tasks.size());
>, <Line: +    }
>, <Line: +    checkState(!getJPPFClient().isClosed());
>, <Line: +    try {
>, <Line: +      for (final JPPFJob job : jobs) {
>, <Line: +        getJPPFClient().submitJob(job);
>, <Line: +      }
>, <Line: +    } catch (final Exception e) {
>, <Line: +      throw new IllegalStateException(e);
>, <Line: +    }
>, <Line: +    res.awaitResults();
>, <Line: +    for (final ResultListener l : listeners) {
>, <Line: +      l.doneComputing();
>, <Line: +    }
>, <Line: +    return new ExperimentResults(builder, res.buildResults());
>, <Line: +  }
>, <Line: +  static SimResult processResult(SimulationTask simTask,
>, <Line: +      final Map<String, Scenario> scenariosMap,
>, <Line: +      final Map<Task<?>, JPPFJob> jobMap) {
>, <Line: +    checkNotNull(simTask);
>, <Line: +    if (simTask.getThrowable() != null) {
>, <Line: +      throw new IllegalArgumentException(simTask.getThrowable());
>, <Line: +    }
>, <Line: +    // final SimTaskResult result = simTask.getResult();
>, <Line: +    final Scenario scen = scenariosMap.get(simTask.getScenarioId());
>, <Line: +    final Configuration conf = jobMap.get(simTask).getDataProvider()
>, <Line: +        .getParameter(simTask.getConfigurationId());
>, <Line: +    return null;
>, <Line: +    // return new SimResult(result.getStats(), scen, conf, simTask
>, <Line: +    // .getSeed(), result.getData());
>, <Line: +  }
>, <Line: +  static class ResultsCollector implements TaskResultListener {
>, <Line: +    private final ImmutableSet.Builder<SimResult> results;
>, <Line: +    private final Map<String, Scenario> scenariosMap;
>, <Line: +    private final Map<Task<?>, JPPFJob> taskJobMap;
>, <Line: +    private final List<ResultListener> listeners;
>, <Line: +    private final int expectedNumResults;
>, <Line: +    private int receivedNumResults;
>, <Line: +    private Optional<IllegalArgumentException> exception;
>, <Line: +    ResultsCollector(int expectedNumberOfResults,
>, <Line: +        final Map<String, Scenario> scenMap,
>, <Line: +        final Map<Task<?>, JPPFJob> tjMap, List<ResultListener> list) {
>, <Line: +      results = ImmutableSet.builder();
>, <Line: +      scenariosMap = scenMap;
>, <Line: +      taskJobMap = tjMap;
>, <Line: +      listeners = list;
>, <Line: +      expectedNumResults = expectedNumberOfResults;
>, <Line: +      receivedNumResults = 0;
>, <Line: +      exception = Optional.absent();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public void resultsReceived(@Nullable TaskResultEvent event) {
>, <Line: +      checkNotNull(event);
>, <Line: +      for (final Task<?> t : event.getTasks()) {
>, <Line: +        final SimulationTask simTask = (SimulationTask) t;
>, <Line: +        try {
>, <Line: +          final SimResult res = processResult(simTask, scenariosMap,
>, <Line: +              taskJobMap);
>, <Line: +          results.add(res);
>, <Line: +          for (final ResultListener l : listeners) {
>, <Line: +            l.receive(res);
>, <Line: +          }
>, <Line: +        } catch (final IllegalArgumentException iae) {
>, <Line: +          exception = Optional.of(iae);
>, <Line: +        }
>, <Line: +      }
>, <Line: +      receivedNumResults += event.getTasks().size();
>, <Line: +    }
>, <Line: +    void awaitResults() {
>, <Line: +      while (!isComplete() && !exception.isPresent()) {
>, <Line: +        try {
>, <Line: +          Thread.sleep(THREAD_SLEEP_MS);
>, <Line: +        } catch (final InterruptedException e) {
>, <Line: +          throw new IllegalStateException(e);
>, <Line: +        }
>, <Line: +      }
>, <Line: +      if (exception.isPresent()) {
>, <Line: +        throw exception.get();
>, <Line: +      }
>, <Line: +    }
>, <Line: +    boolean isComplete() {
>, <Line: +      return receivedNumResults == expectedNumResults;
>, <Line: +    }
>, <Line: +    ImmutableSet<SimResult> buildResults() {
>, <Line: +      return results.build();
>, <Line: +    }
>, <Line: +  }
>, <Line: +  static final class SimResultWrapper implements Comparable<SimResultWrapper> {
>, <Line: +    final SimResult result;
>, <Line: +    final int index;
>, <Line: +    SimResultWrapper(SimResult r, int i) {
>, <Line: +      result = r;
>, <Line: +      index = i;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int compareTo(@Nullable SimResultWrapper o) {
>, <Line: +      return Ints.compare(index, checkNotNull(o).index);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean equals(@Nullable Object o) {
>, <Line: +      if (o == null || o.getClass() != getClass()) {
>, <Line: +        return false;
>, <Line: +      }
>, <Line: +      final SimResultWrapper srw = (SimResultWrapper) o;
>, <Line: +      return Objects.equals(srw.result, result)
>, <Line: +          && Objects.equals(srw.index, index);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int hashCode() {
>, <Line: +      return Objects.hash(result, index);
>, <Line: +    }
>, <Line: +  }
>, <Line: +  static class IdMap<T> {
>, <Line: +    private final BiMap<T, String> configMap;
>, <Line: +    private int idNum;
>, <Line: +    private final String prefix;
>, <Line: +    private final Class<T> clazz;
>, <Line: +    IdMap(String idPrefix, Class<T> cls) {
>, <Line: +      clazz = cls;
>, <Line: +      configMap = HashBiMap.create();
>, <Line: +      idNum = 0;
>, <Line: +      prefix = idPrefix;
>, <Line: +    }
>, <Line: +    String storeAndGenerateId(T value) {
>, <Line: +      checkArgument(
>, <Line: +          value instanceof Serializable,
>, <Line: +          "When using JPPF, instances of %s must implement Serializable, found: '%s' of class: %s.",
>, <Line: +          clazz, value, value.getClass());
>, <Line: +      final String id;
>, <Line: +      if (configMap.containsKey(value)) {
>, <Line: +        id = configMap.get(value);
>, <Line: +      } else {
>, <Line: +        id = prefix + idNum++;
>, <Line: +        configMap.put(value, id);
>, <Line: +      }
>, <Line: +      return id;
>, <Line: +    }
>, <Line: +    T getValue(String id) {
>, <Line: +      return configMap.inverse().get(id);
>, <Line: +    }
>, <Line: +    String getKey(T value) {
>, <Line: +      return configMap.get(value);
>, <Line: +    }
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * This class provides instances of {@link Scenario}. This class equals
>, <Line: +   * another if the provided scenarios are equal.
>, <Line: +   * 
>, <Line: +   * @author Rinde van Lon
>, <Line: +   */
>, <Line: +  static final class ScenarioProvider implements Supplier<Scenario>,
>, <Line: +      Serializable {
>, <Line: +    private static final long serialVersionUID = 1738175155810322872L;
>, <Line: +    private final Function<String, ? extends Scenario> scenarioReader;
>, <Line: +    private final String serializedScenario;
>, <Line: +    private final Class<?> scenarioClass;
>, <Line: +    @Nullable
>, <Line: +    private transient Scenario localCache;
>, <Line: +    ScenarioProvider(Function<String, ? extends Scenario> reader,
>, <Line: +        String serialScen, Class<?> clz) {
>, <Line: +      scenarioReader = reader;
>, <Line: +      serializedScenario = serialScen;
>, <Line: +      scenarioClass = clz;
>, <Line: +      localCache = null;
>, <Line: +    }
>, <Line: +    @SuppressWarnings("null")
>, <Line: +    @Override
>, <Line: +    public Scenario get() {
>, <Line: +      if (localCache == null) {
>, <Line: +        // localCache = (Scenario) ScenarioIO.read(
>, <Line: +        // serializedScenario, scenarioClass);
>, <Line: +      }
>, <Line: +      return localCache;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int hashCode() {
>, <Line: +      return serializedScenario.hashCode();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean equals(@Nullable Object other) {
>, <Line: +      if (other == null || other.getClass() != getClass()) {
>, <Line: +        return false;
>, <Line: +      }
>, <Line: +      final ScenarioProvider sp = (ScenarioProvider) other;
>, <Line: +      return Objects.equals(serializedScenario, sp.serializedScenario);
>, <Line: +    }
>, <Line: +  }
>, <Line: +  static final class SimulationTask extends AbstractTask<SimResult>
>, <Line: +      implements Comparable<SimulationTask> {
>, <Line: +    private static final long serialVersionUID = 5298683984670600238L;
>, <Line: +    private final long seed;
>, <Line: +    private final String scenarioId;
>, <Line: +    private final String configurationId;
>, <Line: +    // private final String objectiveFunctionId;
>, <Line: +    // private final Optional<String> postProcessorId;
>, <Line: +    private final String id;
>, <Line: +    private final int hashCode;
>, <Line: +    private final int index;
>, <Line: +    SimulationTask(int ind, long randomSeed, String scenId, String configId) {
>, <Line: +      index = ind;
>, <Line: +      seed = randomSeed;
>, <Line: +      scenarioId = scenId;
>, <Line: +      configurationId = configId;
>, <Line: +      // objectiveFunctionId = objFuncId;
>, <Line: +      // postProcessorId = postProcId;
>, <Line: +      id = Joiner.on("-").join(seed, scenarioId, configurationId);
>, <Line: +      // objectiveFunctionId, postProcessorId);
>, <Line: +      hashCode = Objects.hash(seed, scenarioId, configurationId);
>, <Line: +      // objectiveFunctionId, postProcessorId);
>, <Line: +    }
>, <Line: +    int getIndex() {
>, <Line: +      return index;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public void run() {
>, <Line: +      // gather data from provider
>, <Line: +      final DataProvider dataProvider = getDataProvider();
>, <Line: +      checkNotNull(
>, <Line: +          dataProvider,
>, <Line: +          "Probable problem: your MASConfiguration/ObjectiveFunction/PostProcessor is not fully serializable.");
>, <Line: +      final Supplier<Scenario> scenario = getDataProvider().getParameter(
>, <Line: +          scenarioId);
>, <Line: +      final Configuration configuration = getDataProvider().getParameter(
>, <Line: +          configurationId);
>, <Line: +      // final ObjectiveFunction objectiveFunction = getDataProvider()
>, <Line: +      // .getParameter(objectiveFunctionId);
>, <Line: +      SimResult res;
>, <Line: +      // setResult(new SimTaskResult(res));
>, <Line: +    }
>, <Line: +    long getSeed() {
>, <Line: +      return seed;
>, <Line: +    }
>, <Line: +    String getScenarioId() {
>, <Line: +      return scenarioId;
>, <Line: +    }
>, <Line: +    String getConfigurationId() {
>, <Line: +      return configurationId;
>, <Line: +    }
>, <Line: +    // String getObjectiveFunctionId() {
>, <Line: +    // return objectiveFunctionId;
>, <Line: +    // }
>, <Line: +    //
>, <Line: +    // Optional<String> getPostProcessorId() {
>, <Line: +    // return postProcessorId;
>, <Line: +    // }
>, <Line: +    @Override
>, <Line: +    public String getId() {
>, <Line: +      return id;
>, <Line: +    }
>, <Line: +    @Deprecated
>, <Line: +    @Override
>, <Line: +    public void setId(@Nullable String id) {
>, <Line: +      throw new UnsupportedOperationException();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int hashCode() {
>, <Line: +      return hashCode;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean equals(@Nullable Object o) {
>, <Line: +      if (o == null || o.getClass() != this.getClass()) {
>, <Line: +        return false;
>, <Line: +      }
>, <Line: +      final SimulationTask t = (SimulationTask) o;
>, <Line: +      return Objects.equals(t.seed, seed) &&
>, <Line: +          Objects.equals(t.scenarioId, scenarioId) &&
>, <Line: +          Objects.equals(t.configurationId, configurationId); // &&
>, <Line: +      // Objects.equals(t.objectiveFunctionId, objectiveFunctionId) &&
>, <Line: +      // Objects.equals(t.postProcessorId, postProcessorId);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int compareTo(@Nullable SimulationTask o) {
>, <Line: +      checkNotNull(o);
>, <Line: +      return ComparisonChain.start()
>, <Line: +          .compare(scenarioId, o.scenarioId)
>, <Line: +          .compare(configurationId, o.configurationId)
>, <Line: +          // .compare(objectiveFunctionId, o.objectiveFunctionId)
>, <Line: +          // .compare(postProcessorId.orNull(), o.postProcessorId.orNull(),
>, <Line: +          // Ordering.natural().nullsLast())
>, <Line: +          .compare(seed, o.seed)
>, <Line: +          .result();
>, <Line: +    }
>, <Line: +  }
>, <Line: +  // static class SimTaskResult implements Serializable {
>, <Line: +  // private static final long serialVersionUID = -631947579134555016L;
>, <Line: +  // private final StatisticsDTO stats;
>, <Line: +  // private final Optional<?> data;
>, <Line: +  //
>, <Line: +  // SimTaskResult(StatisticsDTO stat, Optional<?> d) {
>, <Line: +  // stats = stat;
>, <Line: +  // data = d;
>, <Line: +  // }
>, <Line: +  //
>, <Line: +  // StatisticsDTO getStats() {
>, <Line: +  // return stats;
>, <Line: +  // }
>, <Line: +  //
>, <Line: +  // Optional<?> getData() {
>, <Line: +  // return data;
>, <Line: +  // }
>, <Line: +  // }
>, <Line: +}>]
[]