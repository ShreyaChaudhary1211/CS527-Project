[<Line: +/*
>, <Line: + * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
>, <Line: + *
>, <Line: + * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: + * you may not use this file except in compliance with the License.
>, <Line: + * You may obtain a copy of the License at
>, <Line: + *
>, <Line: + *         http://www.apache.org/licenses/LICENSE-2.0
>, <Line: + *
>, <Line: + * Unless required by applicable law or agreed to in writing, software
>, <Line: + * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: + * See the License for the specific language governing permissions and
>, <Line: + * limitations under the License.
>, <Line: + */
>, <Line: +package com.github.rinde.rinsim.ui.renderers;
>, <Line: +import org.eclipse.swt.graphics.GC;
>, <Line: +import org.eclipse.swt.graphics.Path;
>, <Line: +import com.github.rinde.rinsim.geom.Point;
>, <Line: +import com.google.common.base.Optional;
>, <Line: +class RenderHelper {
>, <Line: +  private Optional<GC> gc;
>, <Line: +  private Optional<ViewPort> vp;
>, <Line: +  RenderHelper() {
>, <Line: +    gc = Optional.absent();
>, <Line: +    vp = Optional.absent();
>, <Line: +  }
>, <Line: +  void adapt(GC g, ViewPort v) {
>, <Line: +    gc = Optional.of(g);
>, <Line: +    vp = Optional.of(v);
>, <Line: +  }
>, <Line: +  void drawLine(Point p1, Point p2) {
>, <Line: +    gc.get().drawLine(
>, <Line: +        vp.get().toCoordX(p1.x), vp.get().toCoordY(p1.y),
>, <Line: +        vp.get().toCoordX(p2.x), vp.get().toCoordY(p2.y));
>, <Line: +  }
>, <Line: +  void setForegroundSysCol(int next) {
>, <Line: +    gc.get().setForeground(gc.get().getDevice().getSystemColor(next));
>, <Line: +  }
>, <Line: +  void setBackgroundSysCol(int next) {
>, <Line: +    gc.get().setBackground(gc.get().getDevice().getSystemColor(next));
>, <Line: +  }
>, <Line: +  void drawCurve(Point p1, Point p2, Point control) {
>, <Line: +    final Path path = new Path(gc.get().getDevice());
>, <Line: +    path.moveTo(vp.get().toCoordX(p1.x), vp.get().toCoordY(p1.y));
>, <Line: +    path.quadTo(
>, <Line: +        vp.get().toCoordX(control.x), vp.get().toCoordY(control.y),
>, <Line: +        vp.get().toCoordX(p2.x), vp.get().toCoordY(p2.y));
>, <Line: +    gc.get().drawPath(path);
>, <Line: +    path.dispose();
>, <Line: +  }
>, <Line: +  void drawCircle(Point p, double radius) {
>, <Line: +    gc.get().drawOval(
>, <Line: +        vp.get().toCoordX(p.x - radius),
>, <Line: +        vp.get().toCoordY(p.y - radius),
>, <Line: +        vp.get().scale(radius * 2),
>, <Line: +        vp.get().scale(radius * 2)
>, <Line: +        );
>, <Line: +  }
>, <Line: +  void fillCircle(Point p, double radius) {
>, <Line: +    gc.get().fillOval(
>, <Line: +        vp.get().toCoordX(p.x - radius),
>, <Line: +        vp.get().toCoordY(p.y - radius),
>, <Line: +        vp.get().scale(radius * 2),
>, <Line: +        vp.get().scale(radius * 2)
>, <Line: +        );
>, <Line: +  }
>, <Line: +  void drawCircle(Point p, int radius) {
>, <Line: +    gc.get().drawOval(
>, <Line: +        vp.get().toCoordX(p.x) - radius,
>, <Line: +        vp.get().toCoordY(p.y) - radius,
>, <Line: +        radius * 2,
>, <Line: +        radius * 2);
>, <Line: +  }
>, <Line: +  void drawRect(Point corner1, Point corner2) {
>, <Line: +    final int x1 = vp.get().toCoordX(corner1.x);
>, <Line: +    final int y1 = vp.get().toCoordY(corner1.y);
>, <Line: +    final int x2 = vp.get().toCoordX(corner2.x);
>, <Line: +    final int y2 = vp.get().toCoordY(corner2.y);
>, <Line: +    gc.get().drawPolygon(new int[] { x1, y1, x2, y1, x2, y2, x1, y2 });
>, <Line: +  }
>, <Line: +  void fillRect(Point corner1, Point corner2) {
>, <Line: +    final int x1 = vp.get().toCoordX(corner1.x);
>, <Line: +    final int y1 = vp.get().toCoordY(corner1.y);
>, <Line: +    final int x2 = vp.get().toCoordX(corner2.x);
>, <Line: +    final int y2 = vp.get().toCoordY(corner2.y);
>, <Line: +    gc.get().fillPolygon(new int[] { x1, y1, x2, y1, x2, y2, x1, y2 });
>, <Line: +  }
>, <Line: +  int[] toCoordinates(Point... points) {
>, <Line: +    final int[] coordinates = new int[points.length * 2];
>, <Line: +    for (int i = 0; i < points.length; i++) {
>, <Line: +      coordinates[i * 2] = vp.get().toCoordX(points[i].x);
>, <Line: +      coordinates[i * 2 + 1] = vp.get().toCoordY(points[i].y);
>, <Line: +    }
>, <Line: +    return coordinates;
>, <Line: +  }
>, <Line: +  void fillPolygon(Point... points) {
>, <Line: +    gc.get().fillPolygon(toCoordinates(points));
>, <Line: +  }
>, <Line: +  void drawPolygon(Point... points) {
>, <Line: +    gc.get().drawPolygon(toCoordinates(points));
>, <Line: +  }
>, <Line: +  void drawArrow(Point from, Point to, double width, double height) {
>, <Line: +    final Point left = PointUtil.perp(to, from, height, width / 2d);
>, <Line: +    final Point right = PointUtil.perp(to, from, height, width / -2d);
>, <Line: +    drawLine(from, to);
>, <Line: +    fillPolygon(left, right, to);
>, <Line: +  }
>, <Line: +}
>]
[]