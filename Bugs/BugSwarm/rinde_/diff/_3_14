[<Line: +import static java.util.Objects.requireNonNull;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import com.github.rinde.rinsim.experiment.base.ExperimentBuilder.FunctionRunner;
>, <Line: +import com.google.common.util.concurrent.FutureCallback;
>, <Line: +  public ExperimentResults compute(ExperimentBuilder<?> builder,
>, <Line: +    final ImmutableList<ResultListener> listeners = ImmutableList
>, <Line: +        .copyOf(builder.resultListeners);
>, <Line: +    final ImmutableList.Builder<SimTask> tasksBuilder = ImmutableList
>, <Line: +      tasksBuilder.add(new FunctionRunner(args, builder.computeFunction));
>, <Line: +    final List<SimTask> tasks = tasksBuilder.build();
>, <Line: +    for (final ResultListener l : listeners) {
>, <Line: +      l.startComputing(tasks.size());
>, <Line: +    }
>, <Line: +    final int threads = Math.min(builder.numThreads, tasks.size());
>, <Line: +    final List<SimResult> results;
>, <Line: +      final List<ListenableFuture<SimResult>> futures = (List) executor
>, <Line: +          .invokeAll(tasks);
>, <Line: +      if (!listeners.isEmpty()) {
>, <Line: +        for (ListenableFuture<SimResult> fut : futures) {
>, <Line: +          Futures.addCallback(fut, new FutureCallback<SimResult>() {
>, <Line: +            @Override
>, <Line: +            public void onSuccess(@Nullable SimResult result) {
>, <Line: +              requireNonNull(result);
>, <Line: +              for (ResultListener list : listeners) {
>, <Line: +                list.receive(result);
>, <Line: +              }
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void onFailure(Throwable t) {
>, <Line: +              // FIXME need some way to gracefully handle this error. All data
>, <Line: +              // should be saved to reproduce this simulation.
>, <Line: +              throw new IllegalStateException(t);
>, <Line: +            }
>, <Line: +          });
>, <Line: +        }
>, <Line: +      }
>, <Line: +    for (final ResultListener l : listeners) {
>, <Line: +      l.doneComputing();
>, <Line: +    }
>]
[<Line: -  public ExperimentResults compute(AbstractExperimentBuilder<?> builder,
>, <Line: -    final ImmutableList.Builder<ExperimentRunner> runnerBuilder = ImmutableList
>, <Line: -      runnerBuilder.add(builder.createRunner(args));
>, <Line: -    final List<ExperimentRunner> runners = runnerBuilder.build();
>, <Line: -    final int threads = Math.min(builder.numThreads, runners.size());
>, <Line: -    final List<SimulationResult> results;
>, <Line: -      final List<ListenableFuture<SimulationResult>> futures = (List) executor
>, <Line: -          .invokeAll(runners);
>]