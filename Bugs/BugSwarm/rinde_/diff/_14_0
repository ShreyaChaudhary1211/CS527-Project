[]
[<Line: -/*
>, <Line: - * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
>, <Line: - *
>, <Line: - * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: - * you may not use this file except in compliance with the License.
>, <Line: - * You may obtain a copy of the License at
>, <Line: - *
>, <Line: - *         http://www.apache.org/licenses/LICENSE-2.0
>, <Line: - *
>, <Line: - * Unless required by applicable law or agreed to in writing, software
>, <Line: - * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: - * See the License for the specific language governing permissions and
>, <Line: - * limitations under the License.
>, <Line: - */
>, <Line: -package com.github.rinde.rinsim.core.model.road;
>, <Line: -import static com.google.common.base.Preconditions.checkArgument;
>, <Line: -import static com.google.common.base.Preconditions.checkElementIndex;
>, <Line: -import static com.google.common.collect.Maps.newLinkedHashMap;
>, <Line: -import static java.util.Arrays.asList;
>, <Line: -import java.math.RoundingMode;
>, <Line: -import java.util.LinkedHashMap;
>, <Line: -import java.util.List;
>, <Line: -import java.util.Map;
>, <Line: -import java.util.Queue;
>, <Line: -import javax.measure.Measure;
>, <Line: -import javax.measure.quantity.Duration;
>, <Line: -import javax.measure.quantity.Length;
>, <Line: -import javax.measure.quantity.Velocity;
>, <Line: -import javax.measure.unit.SI;
>, <Line: -import javax.measure.unit.Unit;
>, <Line: -import org.apache.commons.math3.random.RandomGenerator;
>, <Line: -import com.github.rinde.rinsim.core.TimeLapse;
>, <Line: -import com.github.rinde.rinsim.core.model.road.GridRoadModel.Position;
>, <Line: -import com.github.rinde.rinsim.geom.Point;
>, <Line: -import com.google.auto.value.AutoValue;
>, <Line: -import com.google.common.base.Supplier;
>, <Line: -import com.google.common.collect.ImmutableList;
>, <Line: -import com.google.common.math.DoubleMath;
>, <Line: -public class GridRoadModel extends AbstractRoadModel<Position> {
>, <Line: -  private final double cellSize;
>, <Line: -  private final int numXCells;
>, <Line: -  private final int numYCells;
>, <Line: -  private final Map<Position, RoadUser> locationMap;
>, <Line: -  GridRoadModel(Builder b) {
>, <Line: -    super(b.distanceUnit, b.speedUnit);
>, <Line: -    cellSize = b.cellSize;
>, <Line: -    numXCells = b.numXCells;
>, <Line: -    numYCells = b.numYCells;
>, <Line: -    locationMap = new LinkedHashMap<>();
>, <Line: -  }
>, <Line: -  enum Obstacle implements RoadUser {
>, <Line: -    INSTANCE {
>, <Line: -      @Override
>, <Line: -      public void initRoadUser(RoadModel model) {}
>, <Line: -    }
>, <Line: -  }
>, <Line: -  @AutoValue
>, <Line: -  static abstract class Position {
>, <Line: -    abstract int x();
>, <Line: -    abstract int y();
>, <Line: -    static Position create(int x, int y) {
>, <Line: -      return new AutoValue_GridRoadModel_Position(x, y);
>, <Line: -    }
>, <Line: -    static boolean areNeighbors(Position p1, Position p2) {
>, <Line: -      return Math.abs(p1.x() - p2.x()) + Math.abs(p1.y() - p2.y()) == 1;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  public void addObstacle(Point pos) {
>, <Line: -  }
>, <Line: -  public void addObstacleRect(Point corner1, Point corner2) {
>, <Line: -  }
>, <Line: -  public void clear(Point pos) {
>, <Line: -    locationMap.remove(point2LocObj(pos));
>, <Line: -  }
>, <Line: -  public void clearRect(Point corner1, Point corner2) {
>, <Line: -  }
>, <Line: -  public boolean isOccupied(Point pos) {
>, <Line: -    return locationMap.containsKey(point2LocObj(pos));
>, <Line: -  }
>, <Line: -  public boolean areNeighbors(Point p1, Point p2) {
>, <Line: -    return Position.areNeighbors(point2LocObj(p1), point2LocObj(p2));
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  public void addObjectAt(RoadUser newObj, Point pos) {
>, <Line: -    checkArgument(!isOccupied(pos));
>, <Line: -    super.addObjectAt(newObj, pos);
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  protected MoveProgress doFollowPath(MovingRoadUser obj, Queue<Point> path,
>, <Line: -      TimeLapse time) {
>, <Line: -    final Point origin = getPosition(obj);
>, <Line: -    final Point dest = path.peek();
>, <Line: -    checkArgument(time.getTimeConsumed() == 0);
>, <Line: -    checkArgument(!isOccupied(dest), "The destination %s is occupied.", dest);
>, <Line: -    checkArgument(
>, <Line: -        areNeighbors(origin, dest),
>, <Line: -        "The destination %s is not a neighbor of the current position %s of %s.",
>, <Line: -        dest, origin, obj);
>, <Line: -    path.remove();
>, <Line: -    objLocs.put(obj, point2LocObj(dest));
>, <Line: -    final Measure<Double, Length> distTraveled = unitConversion
>, <Line: -        .toExDistMeasure(cellSize);
>, <Line: -    final Measure<Long, Duration> timeConsumed = Measure.valueOf(
>, <Line: -        time.getTimeConsumed(), time.getTimeUnit());
>, <Line: -    return MoveProgress.create(distTraveled, timeConsumed, asList(origin));
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  public ImmutableList<Point> getBounds() {
>, <Line: -    final Point min = new Point(cellSize / -2, cellSize / -2);
>, <Line: -    final Point max = new Point(numXCells * cellSize - cellSize / 2, numYCells
>, <Line: -        * cellSize - cellSize / 2);
>, <Line: -    return ImmutableList.of(min, max);
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  protected Position point2LocObj(Point point) {
>, <Line: -    final int x = DoubleMath.roundToInt(point.x / cellSize,
>, <Line: -        RoundingMode.HALF_UP);
>, <Line: -    final int y = DoubleMath.roundToInt(point.y / cellSize,
>, <Line: -        RoundingMode.HALF_UP);
>, <Line: -    return Position.create(x, y);
>, <Line: -  }
>, <Line: -  void checkBounds(Position pos) {
>, <Line: -    checkElementIndex(pos.x(), numXCells);
>, <Line: -    checkElementIndex(pos.y(), numYCells);
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  protected Point locObj2point(Position locObj) {
>, <Line: -    return new Point(locObj.x() * cellSize, locObj.y() * cellSize);
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  public Point getRandomPosition(RandomGenerator rnd) {
>, <Line: -    // TODO Auto-generated method stub
>, <Line: -    return null;
>, <Line: -  }
>, <Line: -  @Override
>, <Line: -  public List<Point> getShortestPathTo(Point from, Point to) {
>, <Line: -    // TODO Auto-generated method stub
>, <Line: -    return null;
>, <Line: -  }
>, <Line: -  public double getCellSize() {
>, <Line: -    return cellSize;
>, <Line: -  }
>, <Line: -  public int getNumXCells() {
>, <Line: -    return numXCells;
>, <Line: -  }
>, <Line: -  public int getNumYCells() {
>, <Line: -    return numYCells;
>, <Line: -  }
>, <Line: -  public static Builder builder() {
>, <Line: -    return new Builder();
>, <Line: -  }
>, <Line: -  public static class Builder {
>, <Line: -    Unit<Length> distanceUnit;
>, <Line: -    Unit<Velocity> speedUnit;
>, <Line: -    double cellSize;
>, <Line: -    int numXCells;
>, <Line: -    int numYCells;
>, <Line: -    Builder() {
>, <Line: -      distanceUnit = SI.METER;
>, <Line: -      speedUnit = SI.METERS_PER_SECOND;
>, <Line: -      cellSize = 1d;
>, <Line: -      numXCells = 20;
>, <Line: -      numYCells = 20;
>, <Line: -    }
>, <Line: -    public Builder setDistanceUnit(Unit<Length> distanceUnit) {
>, <Line: -      this.distanceUnit = distanceUnit;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    public Builder setSpeedUnit(Unit<Velocity> speedUnit) {
>, <Line: -      this.speedUnit = speedUnit;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    public Builder setCellSize(double cellSize) {
>, <Line: -      this.cellSize = cellSize;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    public Builder setNumXCells(int numXCells) {
>, <Line: -      this.numXCells = numXCells;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    public Builder setNumYCells(int numYCells) {
>, <Line: -      this.numYCells = numYCells;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    public GridRoadModel build() {
>, <Line: -      return new GridRoadModel(this);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  private static final class Factory implements
>, <Line: -      Supplier<Map<Integer, RoadUser>> {
>, <Line: -    Factory() {}
>, <Line: -    @Override
>, <Line: -    public Map<Integer, RoadUser> get() {
>, <Line: -      return newLinkedHashMap();
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>]