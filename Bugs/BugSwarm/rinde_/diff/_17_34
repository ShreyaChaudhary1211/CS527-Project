[<Line: +import java.util.LinkedHashMap;
>, <Line: +import com.google.common.base.Optional;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.Table;
>, <Line: +import com.google.common.collect.Tables;
>, <Line: +  private final Multimap<Point, Point> multimap;
>, <Line: +  private final Table<Point, Point, Connection<E>> lazyConnectionTable;
>, <Line: +    this(LinkedHashMultimap.<Point, Point> create());
>, <Line: +    multimap = LinkedHashMultimap.create(map);
>, <Line: +    lazyConnectionTable = Tables.newCustomTable(
>, <Line: +        new LinkedHashMap<Point, Map<Point, Connection<E>>>(),
>, <Line: +        new LinkedHashMapFactory<Connection<E>>());
>, <Line: +    deadEndNodes = new HashSet<>();
>, <Line: +    deadEndNodes.addAll(multimap.values());
>, <Line: +    deadEndNodes.removeAll(multimap.keySet());
>, <Line: +    return multimap.containsKey(node) || deadEndNodes.contains(node);
>, <Line: +    return multimap.get(node);
>, <Line: +    return multimap.containsEntry(from, to);
>, <Line: +    return multimap.size();
>, <Line: +    return multimap.keySet().size() + deadEndNodes.size();
>, <Line: +  protected Optional<E> doChangeConnectionData(Point from, Point to,
>, <Line: +      Optional<E> connData) {
>, <Line: +    Optional<E> dat;
>, <Line: +    if (lazyConnectionTable.contains(from, to)) {
>, <Line: +      dat = lazyConnectionTable.get(from, to).data();
>, <Line: +    } else {
>, <Line: +      dat = Optional.absent();
>, <Line: +    lazyConnectionTable.put(from, to, Connection.create(from, to, connData));
>, <Line: +    return dat;
>, <Line: +  public Optional<E> connectionData(Point from, Point to) {
>, <Line: +    if (lazyConnectionTable.contains(from, to)) {
>, <Line: +      return lazyConnectionTable.get(from, to).data();
>, <Line: +    }
>, <Line: +    return Optional.absent();
>, <Line: +    final Set<Point> nodes = new LinkedHashSet<>(multimap.keySet());
>, <Line: +    for (final Entry<Point, Point> p : multimap.entries()) {
>, <Line: +      if (!lazyConnectionTable.contains(p.getKey(), p.getValue())) {
>, <Line: +        lazyConnectionTable.put(p.getKey(), p.getValue(),
>, <Line: +            Connection.<E> create(p.getKey(), p.getValue()));
>, <Line: +      }
>, <Line: +    return ImmutableList.copyOf(lazyConnectionTable.values());
>, <Line: +    return Multimaps.unmodifiableMultimap(multimap);
>, <Line: +    return multimap.isEmpty();
>, <Line: +    for (final Entry<Point, Point> entry : multimap.entries()) {
>, <Line: +    multimap.remove(from, to);
>, <Line: +    if (!multimap.containsKey(to)) {
>, <Line: +    lazyConnectionTable.remove(from, to);
>, <Line: +    return Objects.hashCode(multimap, deadEndNodes, lazyConnectionTable);
>, <Line: +  protected void doAddConnection(Point from, Point to, Optional<E> connData) {
>, <Line: +    multimap.put(from, to);
>, <Line: +    if (!multimap.containsKey(to)) {
>, <Line: +    if (connData.isPresent()) {
>, <Line: +      this.lazyConnectionTable.put(from, to,
>, <Line: +          Connection.create(from, to, connData));
>]
[<Line: -import java.util.HashMap;
>, <Line: -  private final Multimap<Point, Point> data;
>, <Line: -  private final Map<Connection<E>, E> edgeData;
>, <Line: -    data = LinkedHashMultimap.create();
>, <Line: -    this.edgeData = new HashMap<>();
>, <Line: -    deadEndNodes = new LinkedHashSet<>();
>, <Line: -    this.data = LinkedHashMultimap.create(map);
>, <Line: -    this.edgeData = new HashMap<>();
>, <Line: -    this.deadEndNodes = new HashSet<>();
>, <Line: -    deadEndNodes.addAll(data.values());
>, <Line: -    deadEndNodes.removeAll(data.keySet());
>, <Line: -    return data.containsKey(node) || deadEndNodes.contains(node);
>, <Line: -    return data.get(node);
>, <Line: -    return data.containsEntry(from, to);
>, <Line: -    return data.size();
>, <Line: -    return data.keySet().size() + deadEndNodes.size();
>, <Line: -  @Nullable
>, <Line: -  public E setConnectionData(Point from, Point to, @Nullable E connData) {
>, <Line: -    if (!hasConnection(from, to)) {
>, <Line: -      throw new IllegalArgumentException("the connection " + from + " -> " + to
>, <Line: -          + "does not exist");
>, <Line: -    return this.edgeData.put(new Connection<E>(from, to, null), connData);
>, <Line: -  @Nullable
>, <Line: -  public E connectionData(Point from, Point to) {
>, <Line: -    return edgeData.get(new Connection<E>(from, to, null));
>, <Line: -    final Set<Point> nodes = new LinkedHashSet<>(data.keySet());
>, <Line: -    final List<Connection<E>> res = new ArrayList<>(
>, <Line: -        edgeData.size());
>, <Line: -    for (final Entry<Point, Point> p : data.entries()) {
>, <Line: -      final Connection<E> connection = new Connection<>(p.getKey(),
>, <Line: -          p.getValue(), null);
>, <Line: -      final E eD = edgeData.get(connection);
>, <Line: -      connection.setData(eD);
>, <Line: -      res.add(connection);
>, <Line: -    return res;
>, <Line: -    return Multimaps.unmodifiableMultimap(data);
>, <Line: -    return data.isEmpty();
>, <Line: -    for (final Entry<Point, Point> entry : data.entries()) {
>, <Line: -    data.remove(from, to);
>, <Line: -    if (!data.containsKey(to)) {
>, <Line: -    edgeData.remove(new Connection<>(from, to, null));
>, <Line: -    return Objects.hashCode(data, deadEndNodes, edgeData);
>, <Line: -  protected void doAddConnection(Point from, Point to, @Nullable E connData) {
>, <Line: -    data.put(from, to);
>, <Line: -    if (!data.containsKey(to)) {
>, <Line: -    if (connData != null) {
>, <Line: -      this.edgeData.put(new Connection<E>(from, to, null), connData);
>]