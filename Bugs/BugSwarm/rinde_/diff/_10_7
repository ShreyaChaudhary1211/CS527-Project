[<Line: +/*
>, <Line: + * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
>, <Line: + *
>, <Line: + * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: + * you may not use this file except in compliance with the License.
>, <Line: + * You may obtain a copy of the License at
>, <Line: + *
>, <Line: + *         http://www.apache.org/licenses/LICENSE-2.0
>, <Line: + *
>, <Line: + * Unless required by applicable law or agreed to in writing, software
>, <Line: + * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: + * See the License for the specific language governing permissions and
>, <Line: + * limitations under the License.
>, <Line: + */
>, <Line: +package com.github.rinde.rinsim.experiment.base;
>, <Line: +import static com.google.common.base.Preconditions.checkArgument;
>, <Line: +import static com.google.common.collect.Lists.newArrayList;
>, <Line: +import static com.google.common.collect.Sets.newLinkedHashSet;
>, <Line: +import java.io.PrintStream;
>, <Line: +import java.nio.file.Path;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Set;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import org.apache.commons.math3.random.MersenneTwister;
>, <Line: +import org.apache.commons.math3.random.RandomGenerator;
>, <Line: +import com.github.rinde.rinsim.io.FileProvider;
>, <Line: +import com.google.common.base.Function;
>, <Line: +import com.google.common.base.Optional;
>, <Line: +import com.google.common.base.Supplier;
>, <Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import com.google.common.collect.ImmutableSet;
>, <Line: +import com.google.common.collect.Sets;
>, <Line: +public abstract class AbstractExperimentBuilder<T extends AbstractExperimentBuilder<T>> {
>, <Line: +  enum Computers implements Supplier<Computer> {
>, <Line: +    LOCAL {
>, <Line: +      @Override
>, <Line: +      public Computer get() {
>, <Line: +        return new LocalComputer();
>, <Line: +      }
>, <Line: +    },
>, <Line: +    DISTRIBUTED {
>, <Line: +      @Override
>, <Line: +      public Computer get() {
>, <Line: +        throw new UnsupportedOperationException();
>, <Line: +        // return new JppfComputer();
>, <Line: +      }
>, <Line: +    };
>, <Line: +  }
>, <Line: +  final Object objectiveFunction;
>, <Line: +  final Set<Configuration> configurationsSet;
>, <Line: +  final ImmutableSet.Builder<Scenario> scenariosBuilder;
>, <Line: +  Optional<FileProvider.Builder> scenarioProviderBuilder;
>, <Line: +  Function<Path, ? extends Scenario> fileReader;
>, <Line: +  final List<ResultListener> resultListeners;
>, <Line: +  // @Nullable
>, <Line: +  // UICreator uiCreator;
>, <Line: +  @Nullable
>, <Line: +  PostProcessor<?, ?> postProc;
>, <Line: +  boolean showGui;
>, <Line: +  int repetitions;
>, <Line: +  long masterSeed;
>, <Line: +  int numThreads;
>, <Line: +  int numBatches;
>, <Line: +  private Supplier<Computer> computerType;
>, <Line: +  AbstractExperimentBuilder(Object objectiveFunction) {
>, <Line: +    this.objectiveFunction = objectiveFunction;
>, <Line: +    configurationsSet = newLinkedHashSet();
>, <Line: +    scenariosBuilder = ImmutableSet.builder();
>, <Line: +    scenarioProviderBuilder = Optional.absent();
>, <Line: +    fileReader = null;// ScenarioIO.reader();
>, <Line: +    resultListeners = newArrayList();
>, <Line: +    showGui = false;
>, <Line: +    repetitions = 1;
>, <Line: +    masterSeed = 0L;
>, <Line: +    numThreads = Runtime.getRuntime().availableProcessors();
>, <Line: +    numBatches = 1;
>, <Line: +    computerType = Computers.LOCAL;
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Should return 'this', the builder.
>, <Line: +   * @return 'this'.
>, <Line: +   */
>, <Line: +  protected abstract T self();
>, <Line: +  abstract ExperimentRunner createRunner(SimArgs args);
>, <Line: +  /**
>, <Line: +   * Set the number of repetitions for each simulation.
>, <Line: +   * @param times The number of repetitions.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T repeat(int times) {
>, <Line: +    checkArgument(times > 0,
>, <Line: +        "The number of repetitions must be strictly positive, was %s.", times);
>, <Line: +    repetitions = times;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Enable the GUI for each simulation. When a large number of simulations is
>, <Line: +   * performed this may slow down the experiment significantly. The GUI can not
>, <Line: +   * be shown when more than one thread is used.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T showGui() {
>, <Line: +    showGui = true;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /*
>, <Line: +   * Enable the GUI using the specified creator for each simulation. When a
>, <Line: +   * large number of simulations is performed this may slow down the experiment
>, <Line: +   * significantly. The GUI can not be shown when more than one thread is used.
>, <Line: +   * @param uic The {@link UICreator} to use for creating the GUI.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  // public T showGui(Object uic) {
>, <Line: +  // uiCreator = uic;
>, <Line: +  // return showGui();
>, <Line: +  // }
>, <Line: +  /*
>, <Line: +   * Add a configuration to the experiment. For each simulation {@link
>, <Line: +   * StochasticSupplier#get(long)} is called and the resulting {@link
>, <Line: +   * MASConfiguration} is used for a <i>single</i> simulation.
>, <Line: +   * @param config The configuration to add.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T addConfiguration(Configuration config) {
>, <Line: +    checkArgument(!configurationsSet.contains(config));
>, <Line: +    configurationsSet.add(config);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /*
>, <Line: +   * Adds all configurations to the experiment. For each simulation {@link
>, <Line: +   * StochasticSupplier#get(long)} is called and the resulting {@link
>, <Line: +   * MASConfiguration} is used for a <i>single</i> simulation.
>, <Line: +   * @param configs The configurations to add.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T addConfigurations(Iterable<Configuration> configs) {
>, <Line: +    final Set<Configuration> newConfigs = ImmutableSet.copyOf(configs);
>, <Line: +    checkArgument(Sets.intersection(configurationsSet, newConfigs)
>, <Line: +        .isEmpty());
>, <Line: +    configurationsSet.addAll(newConfigs);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Add a scenario to the set of scenarios.
>, <Line: +   * @param scenario The scenario to add.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T addScenario(Scenario scenario) {
>, <Line: +    scenariosBuilder.add(scenario);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Add all scenarios to the set of scenarios.
>, <Line: +   * @param scenarios The scenarios to add.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T addScenarios(List<? extends Scenario> scenarios) {
>, <Line: +    scenariosBuilder.addAll(scenarios);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Adds a {@link com.github.rinde.rinsim.io.FileProvider.Builder} to the
>, <Line: +   * experiment.
>, <Line: +   * @param providerBuilder This builder will be used create a
>, <Line: +   *          {@link FileProvider} instance to load scenarios.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   * @see #setScenarioReader(Function)
>, <Line: +   */
>, <Line: +  public T addScenarios(FileProvider.Builder providerBuilder) {
>, <Line: +    scenarioProviderBuilder = Optional.of(providerBuilder);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Change the scenario reader which defines how {@link Path} instances are
>, <Line: +   * converted to {@link Scenario} instances. By default ScenarioIO#reader() is
>, <Line: +   * used as a scenario reader.
>, <Line: +   * @param reader The reader to use.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T setScenarioReader(
>, <Line: +      Function<Path, ? extends Scenario> reader) {
>, <Line: +    // fileReader = reader;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Specify the number of threads to use for computing the experiments, the
>, <Line: +   * default is <code>1</code>.
>, <Line: +   * @param threads The number of threads to use.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T withThreads(int threads) {
>, <Line: +    checkArgument(threads > 0,
>, <Line: +        "Only a positive number of threads is allowed, was %s.", threads);
>, <Line: +    numThreads = threads;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Set the master random seed for the experiments.
>, <Line: +   * @param seed The seed to use.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T withRandomSeed(long seed) {
>, <Line: +    masterSeed = seed;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /*
>, <Line: +   * Specify a {@link PostProcessor} which is used to gather additional results
>, <Line: +   * from a simulation. The data gathered by the post-processor ends up in
>, <Line: +   * {@link SimulationResult#simulationData}.
>, <Line: +   * @param postProcessor The post-processor to use, by default there is no
>, <Line: +   * post-processor.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T usePostProcessor(PostProcessor<?, ?> postProcessor) {
>, <Line: +    postProc = postProcessor;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Sets the number of batches that should be used when using the
>, <Line: +   * {@link #computeDistributed()} setting.
>, <Line: +   * @param num The number of batches to use.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T numBatches(int num) {
>, <Line: +    checkArgument(num > 0,
>, <Line: +        "The number of batches must be strictly positive, was %s.", num);
>, <Line: +    numBatches = num;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /*
>, <Line: +   * When this method is called the experiment will be performed in a
>, <Line: +   * distributed fashion using the <a href="http://www.jppf.org/">JPPF</a>
>, <Line: +   * framework. By default JPPF will attempt to connect to a driver on
>, <Line: +   * <code>localhost</code>. For changing the JPPF settings, please consult the
>, <Line: +   * <a href="http://www.jppf.org/doc/">JPPF documentation</a>. <p>
>, <Line: +   * <b>Requirements:</b> {@link ..}, {@link ..} and {@link PostProcessor} (if
>, <Line: +   * used) must implement {@link java.io.Serializable}. <p> <b>Incompatible
>, <Line: +   * settings</b><br> The following settings will be ignored when computing is
>, <Line: +   * done in a distributed fashion: <ul> <li>{@link #withThreads(int)}</li>
>, <Line: +   * <li>{@link #showGui()}</li> <li>{@link #showGui(UICreator)}</li> </ul>
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T computeDistributed() {
>, <Line: +    computerType = Computers.DISTRIBUTED;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * This setting will perform the experiment locally (this is the default).
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T computeLocal() {
>, <Line: +    computerType = Computers.LOCAL;
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * This setting will perform a 'dry-run' experiment. No computations will be
>, <Line: +   * done. Note that this must be called <i>after</i> any calls to
>, <Line: +   * {@link #computeDistributed()} or {@link #computeLocal()}, otherwise it has
>, <Line: +   * no effect.
>, <Line: +   * @param verbose If <code>true</code> additional information is printed.
>, <Line: +   * @param stream The stream to write to.
>, <Line: +   * @param error The error stream to write to.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T dryRun(final boolean verbose, final PrintStream stream,
>, <Line: +      final PrintStream error) {
>, <Line: +    final Supplier<Computer> originalComputerType = computerType;
>, <Line: +    computerType = new Supplier<Computer>() {
>, <Line: +      @Override
>, <Line: +      public Computer get() {
>, <Line: +        return new DryRunComputer(originalComputerType, verbose, stream,
>, <Line: +            error);
>, <Line: +      }
>, <Line: +    };
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Adds the specified {@link ResultListener} to the experiment. This listener
>, <Line: +   * will be called each time a simulation is done. <b>Currently only works for
>, <Line: +   * distributed computation</b>.
>, <Line: +   * @param listener The listener to add.
>, <Line: +   * @return This, as per the builder pattern.
>, <Line: +   */
>, <Line: +  public T addResultListener(ResultListener listener) {
>, <Line: +    resultListeners.add(listener);
>, <Line: +    return self();
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Perform the experiment. For every scenario every configuration is used
>, <Line: +   * <code>n</code> times. Where <code>n</code> is the number of repetitions as
>, <Line: +   * specified.
>, <Line: +   * @return An {@link ExperimentResults} instance which contains all experiment
>, <Line: +   *         parameters and the corresponding results.
>, <Line: +   */
>, <Line: +  public ExperimentResults perform() {
>, <Line: +    checkArgument(numThreads == 1 || !showGui,
>, <Line: +        "The GUI can not be shown when using more than one thread.");
>, <Line: +    final List<Long> seeds = generateSeeds();
>, <Line: +    // run Forrest run!
>, <Line: +    final ImmutableSet<SimArgs> runners = createFactorialSetup(seeds);
>, <Line: +    return computerType.get().compute(this, runners);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Parses the command line arguments. Performs the experiment using
>, <Line: +   * {@link #perform()} if the arguments allow it.
>, <Line: +   * @param out The print stream to write the feedback from the cli system to.
>, <Line: +   * @param args The arguments to parse.
>, <Line: +   * @return {@link Optional} containing {@link ExperimentResults} if the
>, <Line: +   *         experiment was performed, {@link Optional#absent()} otherwise.
>, <Line: +   */
>, <Line: +  // public Optional<ExperimentResults> perform(PrintStream out, String... args)
>, <Line: +  // {
>, <Line: +  // final Optional<String> error = ExperimentCli.safeExecute(this, args);
>, <Line: +  // if (error.isPresent()) {
>, <Line: +  // out.println(error.get());
>, <Line: +  // return Optional.absent();
>, <Line: +  // }
>, <Line: +  // return Optional.of(perform());
>, <Line: +  // }
>, <Line: +  private ImmutableList<Long> generateSeeds() {
>, <Line: +    if (repetitions > 1) {
>, <Line: +      final RandomGenerator rng = new MersenneTwister(masterSeed);
>, <Line: +      return generateDistinct(rng, repetitions);
>, <Line: +    }
>, <Line: +    return ImmutableList.of(masterSeed);
>, <Line: +  }
>, <Line: +  Supplier<Computer> getComputer() {
>, <Line: +    return computerType;
>, <Line: +  }
>, <Line: +  ImmutableSet<Scenario> getAllScenarios() {
>, <Line: +    final Set<Scenario> scenarios = newLinkedHashSet(scenariosBuilder
>, <Line: +        .build());
>, <Line: +    if (scenarioProviderBuilder.isPresent()) {
>, <Line: +      scenarios.addAll(scenarioProviderBuilder.get().build(fileReader).get());
>, <Line: +    }
>, <Line: +    return ImmutableSet.copyOf(scenarios);
>, <Line: +  }
>, <Line: +  int getNumScenarios() {
>, <Line: +    final Set<Scenario> scenarios = scenariosBuilder.build();
>, <Line: +    if (scenarioProviderBuilder.isPresent()) {
>, <Line: +      return scenarios.size()
>, <Line: +          + scenarioProviderBuilder.get().build().get().size();
>, <Line: +    }
>, <Line: +    return scenarios.size();
>, <Line: +  }
>, <Line: +  private ImmutableSet<SimArgs> createFactorialSetup(List<Long> seeds) {
>, <Line: +    final Set<Scenario> scenarios = getAllScenarios();
>, <Line: +    final ImmutableSet<Configuration> conf = ImmutableSet
>, <Line: +        .copyOf(configurationsSet);
>, <Line: +    checkArgument(!scenarios.isEmpty(), "At least one scenario is required.");
>, <Line: +    checkArgument(!conf.isEmpty(), "At least one configuration is required.");
>, <Line: +    final ImmutableSet.Builder<SimArgs> runnerBuilder = ImmutableSet
>, <Line: +        .builder();
>, <Line: +    for (final Configuration configuration : conf) {
>, <Line: +      for (final Scenario scenario : scenarios) {
>, <Line: +        for (int i = 0; i < repetitions; i++) {
>, <Line: +          final long seed = seeds.get(i);
>, <Line: +          runnerBuilder
>, <Line: +              .add(new SimArgs(scenario, configuration,
>, <Line: +                  seed, objectiveFunction, showGui, postProc));
>, <Line: +        }
>, <Line: +      }
>, <Line: +    }
>, <Line: +    return runnerBuilder.build();
>, <Line: +  }
>, <Line: +  static ImmutableList<Long> generateDistinct(RandomGenerator rng, int size) {
>, <Line: +    final Set<Long> numbers = newLinkedHashSet();
>, <Line: +    while (numbers.size() < size) {
>, <Line: +      numbers.add(rng.nextLong());
>, <Line: +    }
>, <Line: +    return ImmutableList.copyOf(numbers);
>, <Line: +  }
>, <Line: +}
>]
[]