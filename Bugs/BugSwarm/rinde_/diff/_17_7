[<Line: +import org.junit.Ignore;
>, <Line: + * Tests for {@link CollisionGraphRoadModel}.
>, <Line: +    graph = new ListenableGraph<>(new TableGraph<LengthData>());
>, <Line: +   * Adding an object to an occupied node is not allowed, but when the node is
>, <Line: +   * free it is allowed.
>, <Line: +  @Ignore
>, <Line: +  public void testAddObject() {
>, <Line: +    // max distance to travel while still staying within node area
>, <Line: +    model.moveTo(agv1, NW, meter(0.9997222222));
>, <Line: +    fail = false;
>, <Line: +    try {
>, <Line: +      model.addObjectAt(agv2, SW);
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +    // exiting node area, adding to SW is allowed now
>, <Line: +    model.moveTo(agv1, NW, meter(0.0002777777778));
>, <Line: +    model.addObjectAt(agv2, SW);
>, <Line: +    assertEquals(SW, model.getPosition(agv2));
>, <Line: +  /**
>, <Line: +   * Test for detection of a dead lock situation between two AGVs. The AGVs
>, <Line: +   * drive on the same connection from opposite ends. An
>, <Line: +   * {@link IllegalArgumentException} should be thrown at the moment the second
>, <Line: +   * AGV tries to enter the connection.
>, <Line: +   */
>, <Line: +  @Ignore
>, <Line: +    model.moveTo(agv1, NW, meter(5));
>, <Line: +      model.moveTo(agv2, SW, meter(1));
>, <Line: +  /**
>, <Line: +   * Test for checking that an AGV can not overtake another AGV on the same
>, <Line: +   * connection. The AGV that is behind should be forced to stay behind.
>, <Line: +   */
>, <Line: +  @Ignore
>, <Line: +  public void testHeadTailCollisionAvoidance() {
>, <Line: +    // moving is not allowed
>, <Line: +    checkNoMovement(model.moveTo(agv2, SE, meter(20)));
>, <Line: +    // when the object is removed, moving is allowed
>, <Line: +    model.removeObject(agv1);
>, <Line: +    model.moveTo(agv2, SE, meter(20));
>, <Line: +    assertPointEquals(SE, model.getPosition(agv2), GraphRoadModel.DELTA);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Test for avoidance of a collision on a node. When one AGV comes near ( < of
>, <Line: +   * its length) a node, this node becomes blocked for any other node.
>, <Line: +   */
>, <Line: +  @Ignore
>, <Line: +  @Test
>, <Line: +  public void testNodeCollisionAvoidance() {
>, <Line: +    final Point X = new Point(0, -10);
>, <Line: +    model.getGraph().addConnection(SW, X);
>, <Line: +    final MovingRoadUser agv1 = new TestRoadUser();
>, <Line: +    final MovingRoadUser agv2 = new TestRoadUser();
>, <Line: +    model.addObjectAt(agv1, SE);
>, <Line: +    model.addObjectAt(agv2, NW);
>, <Line: +    // this represents the smallest travelable distance to come within the area
>, <Line: +    // of a node.
>, <Line: +    final TimeLapse tl = meter(9.0002777777778);
>, <Line: +    assertEquals(32401L, tl.getTimeLeft());
>, <Line: +    // agv1 is within the node area of SW now.
>, <Line: +    model.moveTo(agv1, SW, tl);
>, <Line: +    model.moveTo(agv2, SW, meter(10));
>, <Line: +    assertPointEquals(new Point(1, 0), model.getPosition(agv1),
>, <Line: +        GraphRoadModel.DELTA);
>, <Line: +    assertPointEquals(new Point(0, 1.25), model.getPosition(agv2),
>, <Line: +        GraphRoadModel.DELTA);
>, <Line: +    // moving agv2 is not allowed
>, <Line: +    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
>, <Line: +    // agv1 moves to center of node, moving agv2 is still not allowed
>, <Line: +    model.moveTo(agv1, SW, meter(1));
>, <Line: +    assertEquals(SW, model.getPosition(agv1));
>, <Line: +    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
>, <Line: +    // this represents the maximum distance to travel while still staying within
>, <Line: +    // the node's area, moving agv2 is still not allowed
>, <Line: +    final TimeLapse tl2 = meter(0.9997222222);
>, <Line: +    assertEquals(3599L, tl2.getTimeLeft());
>, <Line: +    model.moveTo(agv1, X, tl2);
>, <Line: +    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
>, <Line: +    // this represents the distance to travel to get outside of the node's area,
>, <Line: +    // moving agv2 is now allowed
>, <Line: +    final TimeLapse tl3 = meter(0.0002777777778);
>, <Line: +    assertEquals(1L, tl3.getTimeLeft());
>, <Line: +    model.moveTo(agv1, X, tl3);
>, <Line: +    assertPointEquals(new Point(0, -1), model.getPosition(agv1),
>, <Line: +        GraphRoadModel.DELTA);
>, <Line: +    model.moveTo(agv2, SW, meter(2));
>, <Line: +    assertEquals(SW, model.getPosition(agv2));
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Tests valid and invalid values for vehicleLength.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testBuilderVehicleLength() {
>, <Line: +    // vehicle length must be > 0
>, <Line: +    boolean fail = false;
>, <Line: +    try {
>, <Line: +      CollisionGraphRoadModel.builder(graph)
>, <Line: +          .setVehicleLength(0d);
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +    // vehicle length may not be infinite
>, <Line: +    fail = false;
>, <Line: +    try {
>, <Line: +      CollisionGraphRoadModel.builder(graph)
>, <Line: +          .setVehicleLength(Double.POSITIVE_INFINITY);
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +    final CollisionGraphRoadModel cgr1 = CollisionGraphRoadModel.builder(graph)
>, <Line: +        .setVehicleLength(5d)
>, <Line: +        .build();
>, <Line: +    assertEquals(5d, cgr1.getVehicleLength(), 0);
>, <Line: +  /**
>, <Line: +   * Tests valid and invalid values for minDistance.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testBuilderMinDistance() {
>, <Line: +    assertEquals(0d, CollisionGraphRoadModel.builder(graph)
>, <Line: +        .setMinDistance(0d)
>, <Line: +        .build()
>, <Line: +        .getMinDistance(),
>, <Line: +        0);
>, <Line: +    assertEquals(2d, CollisionGraphRoadModel.builder(graph)
>, <Line: +        .setMinDistance(2d)
>, <Line: +        .build()
>, <Line: +        .getMinDistance(),
>, <Line: +        0);
>, <Line: +    // min distance may not be > 2 * vehicle length
>, <Line: +    boolean fail = false;
>, <Line: +    try {
>, <Line: +      CollisionGraphRoadModel.builder(graph)
>, <Line: +          .setMinDistance(2.000000001)
>, <Line: +          .build();
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +    // min distance may not be negative
>, <Line: +    fail = false;
>, <Line: +    try {
>, <Line: +      CollisionGraphRoadModel.builder(graph)
>, <Line: +          .setMinDistance(-1d);
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Some graphs are not compatible with {@link CollisionGraphRoadModel}.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testDetectInvalidConnAtConstruction() {
>, <Line: +    final ListenableGraph<?> g = new ListenableGraph<>(
>, <Line: +        new TableGraph<LengthData>());
>, <Line: +    // this connection is allowed:
>, <Line: +    g.addConnection(new Point(0, 0), new Point(2, 0));
>, <Line: +    // this connection is not allowed:
>, <Line: +    g.addConnection(new Point(0, 0), new Point(1.99, 0));
>, <Line: +    boolean fail = false;
>, <Line: +    try {
>, <Line: +      CollisionGraphRoadModel.builder(g)
>, <Line: +          .setVehicleLength(1d)
>, <Line: +          .setMinDistance(.25)
>, <Line: +          .build();
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Test the addition of a connection that is too short.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testDetectAddInvalidConnLive() {
>, <Line: +    final Point a = new Point(0, 0);
>, <Line: +    final Point b = new Point(2, 0);
>, <Line: +    model.getGraph().addConnection(a, b);
>, <Line: +    assertTrue(model.getGraph().hasConnection(a, b));
>, <Line: +    boolean fail = false;
>, <Line: +    try {
>, <Line: +      model.getGraph().addConnection(new Point(0, 0), new Point(1.99, 0));
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Test a change of a conn such that it becomes too short.
>, <Line: +   */
>, <Line: +  @Test
>, <Line: +  public void testDetectChangeConnInvalidLive() {
>, <Line: +    // this is allowed
>, <Line: +    graph.setConnectionData(SW, NW, LengthData.create(2d));
>, <Line: +    boolean fail = false;
>, <Line: +    try {
>, <Line: +      // this is too short
>, <Line: +      graph.setConnectionData(SW, NW, LengthData.create(1.99));
>, <Line: +    } catch (final IllegalArgumentException e) {
>, <Line: +      fail = true;
>, <Line: +    }
>, <Line: +    assertTrue(fail);
>, <Line: +  }
>, <Line: +  /**
>, <Line: +   * Helper function that constructs {@link TimeLapse} instances that allow
>, <Line: +   * traveling <code>n</code> meters.
>, <Line: +   * @param m
>, <Line: +   * @return
>, <Line: +   */
>, <Line: +  static void checkNoMovement(MoveProgress mp) {
>, <Line: +    assertTrue(mp.travelledNodes.isEmpty());
>, <Line: +    assertEquals(0L, mp.time.getValue().longValue());
>, <Line: +    assertEquals(0d, mp.distance.getValue().doubleValue(), 0);
>, <Line: +  }
>]
[<Line: -import static com.github.rinde.rinsim.core.TimeLapseFactory.hour;
>, <Line: - *
>, <Line: -    graph = new ListenableGraph<>(new TableGraph<LengthData>(LengthData.EMPTY));
>, <Line: -   * Adding an object at the same position is not allowed.
>, <Line: -  public void testAddObjectAtSamePos() {
>, <Line: -    model.moveTo(agv1, NW, hour(5));
>, <Line: -      model.moveTo(agv2, SW, hour(6));
>, <Line: -  public void testTailCollisionAvoidance() {
>]