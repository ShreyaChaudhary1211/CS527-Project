[<Line: +import net.bytebuddy.implementation.bytecode.assign.Assigner;
>, <Line: +    /**
>, <Line: +     * Compiles this method delegation binder for a target method.
>, <Line: +     *
>, <Line: +     * @param candidate The target method to bind.
>, <Line: +     * @return A compiled target for binding.
>, <Line: +     */
>, <Line: +    Record compile(MethodDescription candidate);
>, <Line: +    /**
>, <Line: +     * A method delegation that was compiled to a target method.
>, <Line: +     */
>, <Line: +    interface Record {
>, <Line: +         * Attempts a binding of a source method to this compiled target.
>, <Line: +         * @param terminationHandler   Ther termination handler to apply.
>, <Line: +         * @param methodInvoker        The method invoker to use.
>, <Line: +         * @param assigner             The assigner to use.
>, <Line: +        MethodBinding bind(Implementation.Target implementationTarget,
>, <Line: +                           MethodDescription source,
>, <Line: +                           TerminationHandler terminationHandler,
>, <Line: +                           MethodInvoker methodInvoker,
>, <Line: +                           Assigner assigner);
>, <Line: +        /**
>, <Line: +         * A compiled method delegation binder that only yields illegal bindings.
>, <Line: +         */
>, <Line: +        enum Illegal implements Record {
>, <Line: +            /**
>, <Line: +             * The singleton instance.
>, <Line: +             */
>, <Line: +            public MethodBinding bind(Implementation.Target implementationTarget,
>, <Line: +                                      MethodDescription source,
>, <Line: +                                      TerminationHandler terminationHandler,
>, <Line: +                                      MethodInvoker methodInvoker,
>, <Line: +                                      Assigner assigner) {
>, <Line: +            @Override
>, <Line: +            public String toString() {
>, <Line: +                return "MethodDelegationBinder.Record.Illegal." + name();
>, <Line: +            }
>, <Line: +            private final MethodDescription candidate;
>, <Line: +             * @param methodInvoker The method invoker that is used to create the method invocation of the {@code target} method.
>, <Line: +             * @param candidate     The target method that is target of the binding.
>, <Line: +            public Builder(MethodInvoker methodInvoker, MethodDescription candidate) {
>, <Line: +                this.candidate = candidate;
>, <Line: +                parameterStackManipulations = new ArrayList<StackManipulation>(candidate.getParameters().size());
>, <Line: +                if (candidate.getParameters().size() != nextParameterIndex) {
>, <Line: +                return new Build(candidate,
>, <Line: +                        methodInvoker.invoke(candidate),
>, <Line: +                        ", candidate=" + candidate +
>, <Line: +    /**
>, <Line: +     * A termination handler is responsible for terminating a method delegation.
>, <Line: +     */
>, <Line: +    interface TerminationHandler {
>, <Line: +        /**
>, <Line: +         * Creates a stack manipulation that is to be applied after the method return.
>, <Line: +         *
>, <Line: +         * @param assigner The supplied assigner.
>, <Line: +         * @param source   The source method that is bound to the {@code target} method.
>, <Line: +         * @param target   The target method that is subject to be bound by the {@code source} method.
>, <Line: +         * @return A stack manipulation that is applied after the method return.
>, <Line: +         */
>, <Line: +        StackManipulation resolve(Assigner assigner, MethodDescription source, MethodDescription target);
>, <Line: +    }
>, <Line: +    class Processor implements MethodDelegationBinder.Record {
>, <Line: +         * The delegation records to consider.
>, <Line: +        private final List<? extends Record> records;
>, <Line: +         * Creates a new processor.
>, <Line: +         * @param records           The delegation records to consider.
>, <Line: +         * @param ambiguityResolver The ambiguity resolver to apply.
>, <Line: +        public Processor(List<? extends Record> records, AmbiguityResolver ambiguityResolver) {
>, <Line: +            this.records = records;
>, <Line: +        @Override
>, <Line: +        public MethodBinding bind(Implementation.Target implementationTarget,
>, <Line: +                                  MethodDescription source,
>, <Line: +                                  TerminationHandler terminationHandler,
>, <Line: +                                  MethodInvoker methodInvoker,
>, <Line: +                                  Assigner assigner) {
>, <Line: +            List<MethodBinding> targets = new ArrayList<MethodBinding>();
>, <Line: +            for (Record record : records) {
>, <Line: +                MethodBinding methodBinding = record.bind(implementationTarget, source, terminationHandler, methodInvoker, assigner);
>, <Line: +                    targets.add(methodBinding);
>, <Line: +            if (targets.isEmpty()) {
>, <Line: +                throw new IllegalArgumentException("None of " + records + " allows for delegation from " + source);
>, <Line: +            }
>, <Line: +            return resolve(source, targets);
>, <Line: +                            throw new IllegalStateException("Unexpected targets: " + targets);
>, <Line: +                    && records.equals(((Processor) other).records);
>, <Line: +            return 31 * records.hashCode() + ambiguityResolver.hashCode();
>, <Line: +                    + "records=" + records
>, <Line: +                    + ", ambiguityResolver=" + ambiguityResolver
>, <Line: +                    + '}';
>]
[<Line: -import net.bytebuddy.description.method.MethodList;
>, <Line: -import static net.bytebuddy.matcher.ElementMatchers.isVisibleTo;
>, <Line: -    Compiled compile(MethodDescription target);
>, <Line: -    interface Compiled {
>, <Line: -         * Attempts a binding of a source method to a given target method.
>, <Line: -        MethodBinding bind(Implementation.Target implementationTarget, MethodDescription source);
>, <Line: -        enum Ignored implements Compiled {
>, <Line: -            public MethodBinding bind(Implementation.Target implementationTarget, MethodDescription source) {
>, <Line: -            private final MethodDescription target;
>, <Line: -             * @param methodInvoker The method invoker that is used to create the method invocation of the {@code target}
>, <Line: -             *                      method.
>, <Line: -             * @param target        The target method that is target of the binding.
>, <Line: -            public Builder(MethodInvoker methodInvoker, MethodDescription target) {
>, <Line: -                this.target = target;
>, <Line: -                parameterStackManipulations = new ArrayList<StackManipulation>(target.getParameters().size());
>, <Line: -                if (target.getParameters().size() != nextParameterIndex) {
>, <Line: -                return new Build(target,
>, <Line: -                        methodInvoker.invoke(target),
>, <Line: -                        ", target=" + target +
>, <Line: -    class Processor {
>, <Line: -         * This processor's method delegation binder.
>, <Line: -        private final MethodDelegationBinder methodDelegationBinder;
>, <Line: -         * Creates a new processor for a method delegation binder.
>, <Line: -         * @param methodDelegationBinder This processor's method delegation binder.
>, <Line: -         * @param ambiguityResolver      The processor's ambiguity resolver.
>, <Line: -        public Processor(MethodDelegationBinder methodDelegationBinder, AmbiguityResolver ambiguityResolver) {
>, <Line: -            this.methodDelegationBinder = methodDelegationBinder;
>, <Line: -        /**
>, <Line: -         * @param implementationTarget The implementation target for binding the {@code source} method to.
>, <Line: -         * @param source               The source method that is to be bound.
>, <Line: -         * @param targetCandidates     All possible targets for the delegation binding that are to be considered.
>, <Line: -         * @return The best binding that was identified. If no such binding can be identified, an exception is thrown.
>, <Line: -         */
>, <Line: -        public MethodBinding process(Implementation.Target implementationTarget, MethodDescription source, MethodList<?> targetCandidates) {
>, <Line: -            List<MethodBinding> possibleDelegations = bind(implementationTarget, source, targetCandidates);
>, <Line: -            if (possibleDelegations.isEmpty()) {
>, <Line: -                throw new IllegalArgumentException("None of " + targetCandidates + " allows for delegation from " + source);
>, <Line: -            }
>, <Line: -            return resolve(source, possibleDelegations);
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * Creates a list of method bindings for any legal target method.
>, <Line: -         *
>, <Line: -         * @param implementationTarget The implementation target for binding the {@code source} method to.
>, <Line: -         * @param source               The method that is to be bound to any {@code targets} method.
>, <Line: -         * @param targetCandidates     All possible targets for the delegation binding that are to be considered.
>, <Line: -         * @return A list of valid method bindings representing a subset of the given target methods.
>, <Line: -         */
>, <Line: -        private List<MethodBinding> bind(Implementation.Target implementationTarget, MethodDescription source, MethodList<?> targetCandidates) {
>, <Line: -            List<MethodBinding> possibleDelegations = new ArrayList<MethodBinding>();
>, <Line: -            for (MethodDescription targetCandidate : targetCandidates.filter(isVisibleTo(implementationTarget.getInstrumentedType()))) {
>, <Line: -                MethodBinding methodBinding = methodDelegationBinder.compile(targetCandidate).bind(implementationTarget, source);
>, <Line: -                    possibleDelegations.add(methodBinding);
>, <Line: -            return possibleDelegations;
>, <Line: -                            throw new AssertionError();
>, <Line: -                    && methodDelegationBinder.equals(((Processor) other).methodDelegationBinder);
>, <Line: -            return 31 * methodDelegationBinder.hashCode() + ambiguityResolver.hashCode();
>, <Line: -                    + "methodDelegationBinder=" + methodDelegationBinder
>, <Line: -                    + ", ambiguityResolver=" + ambiguityResolver + '}';
>]