[<Line: +package net.bytebuddy.implementation.bytecode.member;
>, <Line: +import net.bytebuddy.description.method.MethodDescription;
>, <Line: +import net.bytebuddy.description.method.ParameterList;
>, <Line: +import net.bytebuddy.description.type.TypeDescription;
>, <Line: +import net.bytebuddy.implementation.Implementation;
>, <Line: +import net.bytebuddy.implementation.bytecode.StackManipulation;
>, <Line: +import net.bytebuddy.implementation.bytecode.StackSize;
>, <Line: +import net.bytebuddy.test.utility.MockitoRule;
>, <Line: +import org.junit.Before;
>, <Line: +import org.junit.Rule;
>, <Line: +import org.junit.Test;
>, <Line: +import org.junit.rules.TestRule;
>, <Line: +import org.mockito.Mock;
>, <Line: +import org.objectweb.asm.MethodVisitor;
>, <Line: +import org.objectweb.asm.Opcodes;
>, <Line: +import static org.hamcrest.CoreMatchers.is;
>, <Line: +import static org.hamcrest.MatcherAssert.assertThat;
>, <Line: +import static org.mockito.Mockito.verify;
>, <Line: +import static org.mockito.Mockito.when;
>, <Line: +public class MethodInvocationHandleTest {
>, <Line: +    private static final String FOO = "foo", BAR = "bar", QUX = "qux", BAZ = "baz";
>, <Line: +    @Rule
>, <Line: +    public TestRule mockitoRule = new MockitoRule(this);
>, <Line: +    @Mock
>, <Line: +    private MethodDescription.InDefinedShape methodDescription;
>, <Line: +    @Mock
>, <Line: +    private TypeDescription.Generic returnType;
>, <Line: +    @Mock
>, <Line: +    private TypeDescription declaringType, firstType, secondType;
>, <Line: +    @Mock
>, <Line: +    private Implementation.Context implementationContext;
>, <Line: +    @Mock
>, <Line: +    private MethodVisitor methodVisitor;
>, <Line: +    @Before
>, <Line: +    public void setUp() throws Exception {
>, <Line: +        when(methodDescription.asDefined()).thenReturn(methodDescription);
>, <Line: +        when(methodDescription.getReturnType()).thenReturn(returnType);
>, <Line: +        when(methodDescription.getDeclaringType()).thenReturn(declaringType);
>, <Line: +        when(returnType.getStackSize()).thenReturn(StackSize.ZERO);
>, <Line: +        when(firstType.getStackSize()).thenReturn(StackSize.ZERO);
>, <Line: +        when(firstType.getDescriptor()).thenReturn(FOO);
>, <Line: +        when(secondType.getDescriptor()).thenReturn(BAR);
>, <Line: +        when(secondType.getStackSize()).thenReturn(StackSize.ZERO);
>, <Line: +        when(returnType.getStackSize()).thenReturn(StackSize.ZERO);
>, <Line: +        when(methodDescription.getInternalName()).thenReturn(QUX);
>, <Line: +        when(methodDescription.getDescriptor()).thenReturn(BAZ);
>, <Line: +        when(declaringType.getDescriptor()).thenReturn(BAR);
>, <Line: +        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, firstType, secondType));
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testExactHandleStatic() throws Exception {
>, <Line: +        when(methodDescription.isStatic()).thenReturn(true);
>, <Line: +        StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).onHandle(MethodInvocation.HandleType.EXACT);
>, <Line: +        assertThat(stackManipulation.isValid(), is(true));
>, <Line: +        StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
>, <Line: +        assertThat(size.getSizeImpact(), is(-1));
>, <Line: +        assertThat(size.getMaximalSize(), is(0));
>, <Line: +        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandle", "invokeExact", BAZ, false);
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testExactHandleConstructor() throws Exception {
>, <Line: +        when(methodDescription.isConstructor()).thenReturn(true);
>, <Line: +        StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).onHandle(MethodInvocation.HandleType.EXACT);
>, <Line: +        assertThat(stackManipulation.isValid(), is(true));
>, <Line: +        StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
>, <Line: +        assertThat(size.getSizeImpact(), is(-1));
>, <Line: +        assertThat(size.getMaximalSize(), is(0));
>, <Line: +        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandle", "invokeExact", BAZ, false);
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testExactHandleNonStatic() throws Exception {
>, <Line: +        StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).onHandle(MethodInvocation.HandleType.EXACT);
>, <Line: +        assertThat(stackManipulation.isValid(), is(true));
>, <Line: +        StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
>, <Line: +        assertThat(size.getSizeImpact(), is(-1));
>, <Line: +        assertThat(size.getMaximalSize(), is(0));
>, <Line: +        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandle", "invokeExact", "(" + BAR + BAZ.substring(1), false);
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testMethodNames() throws Exception {
>, <Line: +        assertThat(MethodInvocation.HandleType.EXACT.getMethodName(), is("invokeExact"));
>, <Line: +        assertThat(MethodInvocation.HandleType.REGULAR.getMethodName(), is("invoke"));
>, <Line: +    }
>, <Line: +}
>]
[]