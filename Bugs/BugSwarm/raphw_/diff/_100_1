[<Line: +import static net.bytebuddy.matcher.ElementMatchers.*;
>, <Line: +import static org.hamcrest.CoreMatchers.is;
>, <Line: +    @Test
>, <Line: +    public void testTrivialAdviceWithSuppression() throws Exception {
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdviceWithSuppression.class).on(named(FOO)))
>, <Line: +                .make()
>, <Line: +                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
>, <Line: +                .getLoaded();
>, <Line: +        assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) FOO));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
>, <Line: +    }
>, <Line: +                .visit(Advice.to(TrivialAdvice.class).on(isMethod()))
>, <Line: +                .make()
>, <Line: +                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
>, <Line: +                .getLoaded();
>, <Line: +        assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) FOO));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
>, <Line: +        assertThat(type.getDeclaredMethod(BAZ).invoke(null), is((Object) FOO));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 2));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 2));
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testTrivialAdviceMultipleMethodsWithSuppression() throws Exception {
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdviceWithSuppression.class).on(isMethod()))
>, <Line: +    @Test
>, <Line: +    public void testTrivialAdviceNestedWithSuppression() throws Exception {
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdviceWithSuppression.class).on(named(FOO)))
>, <Line: +                .visit(Advice.to(TrivialAdviceWithSuppression.class).on(named(FOO)))
>, <Line: +                .make()
>, <Line: +                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
>, <Line: +                .getLoaded();
>, <Line: +        assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) FOO));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 2));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 2));
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testTrivialAdviceWithHandlerAndSuppression() throws Exception {
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdviceWithSuppression.class).on(named(FOO + BAZ)))
>, <Line: +                .make()
>, <Line: +                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
>, <Line: +                .getLoaded();
>, <Line: +        assertThat(type.getDeclaredMethod(FOO + BAZ).invoke(type.newInstance()), is((Object) FOO));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
>, <Line: +    }
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +    @Test
>, <Line: +    public void testAdviceOnConstructorExitAdviceWithSuppression() throws Exception {
>, <Line: +        Class<?> type = new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdviceSkipExceptionWithSuppression.class).on(isConstructor()))
>, <Line: +                .make()
>, <Line: +                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
>, <Line: +                .getLoaded();
>, <Line: +        assertThat(type.newInstance(), notNullValue(Object.class));
>, <Line: +        assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
>, <Line: +        assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
>, <Line: +    }
>, <Line: +    @Test(expected = IllegalStateException.class)
>, <Line: +    public void testAdviceOnConstructorWithSuppressionNotLegal() throws Exception {
>, <Line: +        new ByteBuddy()
>, <Line: +                .redefine(Sample.class)
>, <Line: +                .visit(Advice.to(TrivialAdvice.class).on(isConstructor()))
>, <Line: +                .make();
>, <Line: +    }
>, <Line: +        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.NoOp.class).apply();
>, <Line: +        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.Suppressing.class).apply();
>, <Line: +        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.Suppressing.Bound.class).applyBasic();
>, <Line: +    @SuppressWarnings("unused")
>, <Line: +    public static class TrivialAdviceWithSuppression {
>, <Line: +        @Advice.OnMethodEnter(suppress = Exception.class)
>, <Line: +        private static void enter() {
>, <Line: +            Sample.enter++;
>, <Line: +        }
>, <Line: +        @Advice.OnMethodExit(suppress = Exception.class)
>, <Line: +        private static void exit() {
>, <Line: +            Sample.exit++;
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @SuppressWarnings("unused")
>, <Line: +    public static class TrivialAdviceSkipExceptionWithSuppression {
>, <Line: +        @Advice.OnMethodEnter(suppress = Exception.class)
>, <Line: +        private static void enter() {
>, <Line: +            Sample.enter++;
>, <Line: +        }
>, <Line: +        @Advice.OnMethodExit(onThrowable = false, suppress = Exception.class)
>, <Line: +        private static void exit() {
>, <Line: +            Sample.exit++;
>, <Line: +        }
>, <Line: +    }
>]
[<Line: -import net.bytebuddy.description.annotation.AbstractAnnotationDescriptionTest;
>, <Line: -import net.bytebuddy.description.annotation.AnnotationList;
>, <Line: -import net.bytebuddy.description.method.ParameterList;
>, <Line: -import net.bytebuddy.implementation.bytecode.StackSize;
>, <Line: -import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
>, <Line: -import static net.bytebuddy.matcher.ElementMatchers.named;
>, <Line: -                .visit(Advice.to(TrivialAdvice.class).on(named(FOO).or(named(BAZ))))
>, <Line: -        Class<?> type = new ByteBuddy() // TODO: Exception when constructor for certain types and throwable
>, <Line: -        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.SuppressionHandler.NoOp.class).apply();
>, <Line: -        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.SuppressionHandler.Suppressing.class).apply();
>]