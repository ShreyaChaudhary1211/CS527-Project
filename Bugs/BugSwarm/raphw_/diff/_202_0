[<Line: +                /**
>, <Line: +                 * A target for an offset mapping to load a type constant onto the operand stack.
>, <Line: +                 */
>, <Line: +                class ForType implements Target {
>, <Line: +                    /**
>, <Line: +                     * The type to load onto the operand stack.
>, <Line: +                     */
>, <Line: +                    private final TypeDescription typeDescription;
>, <Line: +                    /**
>, <Line: +                     * Creates a new target for an offset mapping for a type constant.
>, <Line: +                     *
>, <Line: +                     * @param typeDescription The type to load onto the operand stack.
>, <Line: +                     */
>, <Line: +                    public ForType(TypeDescription typeDescription) {
>, <Line: +                        this.typeDescription = typeDescription;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int resolveAccess(MethodVisitor methodVisitor, int opcode) {
>, <Line: +                        switch (opcode) {
>, <Line: +                            case Opcodes.ALOAD:
>, <Line: +                                load(methodVisitor, typeDescription);
>, <Line: +                                return NO_PADDING;
>, <Line: +                            default:
>, <Line: +                                throw new IllegalStateException("Cannot write to fixed value: " + typeDescription);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Loads a type constant onto the operand stack.
>, <Line: +                     *
>, <Line: +                     * @param methodVisitor   The method visitor to use.
>, <Line: +                     * @param typeDescription The type to load into the operand stack.
>, <Line: +                     */
>, <Line: +                    protected static void load(MethodVisitor methodVisitor, TypeDescription typeDescription) {
>, <Line: +                        methodVisitor.visitLdcInsn(typeDescription.getName());
>, <Line: +                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,
>, <Line: +                                TypeDescription.CLASS.getInternalName(),
>, <Line: +                                "forName",
>, <Line: +                                Type.getMethodDescriptor(Type.getType(Class.class), Type.getType(String.class)),
>, <Line: +                                false);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int resolveIncrement(MethodVisitor methodVisitor, int increment) {
>, <Line: +                        throw new IllegalStateException("Unexpected increment");
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object object) {
>, <Line: +                        if (this == object) return true;
>, <Line: +                        if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                        ForType forType = (ForType) object;
>, <Line: +                        return typeDescription.equals(forType.typeDescription);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return typeDescription.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "Advice.Dispatcher.OffsetMapping.Target.ForType{" +
>, <Line: +                                "typeDescription=" + typeDescription +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                                ForType.load(methodVisitor, methodDescription.getDeclaringType());
>, <Line: +                                        ForType.load(methodVisitor, parameter.getType().asErasure());
>, <Line: +                    return new Target.ForType(instrumentedMethod.getDeclaringType());
>]
[<Line: -                                methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().getDescriptor()));
>, <Line: -                                        methodVisitor.visitLdcInsn(Type.getType(parameter.getType().asErasure().getDescriptor()));
>, <Line: -                    return new Target.ForConstantPoolValue(Type.getType(instrumentedMethod.getDeclaringType().getDescriptor()));
>]