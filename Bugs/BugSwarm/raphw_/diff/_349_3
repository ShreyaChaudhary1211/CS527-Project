[<Line: +import net.bytebuddy.implementation.FixedValue;
>, <Line: +    @Test(expected = IllegalStateException.class)
>, <Line: +    public void testBridgeResolutionAmbiguous() throws Exception {
>, <Line: +        createPlain()
>, <Line: +                .defineMethod(QUX, String.class)
>, <Line: +                .intercept(FixedValue.value(FOO))
>, <Line: +                .defineMethod(QUX, Object.class)
>, <Line: +                .intercept(FixedValue.value(BAR))
>, <Line: +                .make();
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testCanOverloadMethodByReturnType() throws Exception {
>, <Line: +        Class<?> type = createPlain()
>, <Line: +                .defineMethod(QUX, String.class, Visibility.PUBLIC)
>, <Line: +                .intercept(FixedValue.value(FOO))
>, <Line: +                .defineMethod(QUX, Object.class, Ownership.STATIC, Visibility.PUBLIC) // TIs static to avoid method graph compiler.
>, <Line: +                .intercept(FixedValue.value(BAR))
>, <Line: +                .make()
>, <Line: +                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)
>, <Line: +                .getLoaded();
>, <Line: +        for (Method method : type.getDeclaredMethods()) {
>, <Line: +            if (method.getReturnType() == String.class) {
>, <Line: +                assertThat(method.getName(), is(QUX));
>, <Line: +                assertThat(method.getParameterTypes().length, is(0));
>, <Line: +                assertThat(method.invoke(type.newInstance()), is((Object) FOO));
>, <Line: +            } else if(method.getReturnType() == Object.class) {
>, <Line: +                assertThat(method.getName(), is(QUX));
>, <Line: +                assertThat(method.getParameterTypes().length, is(0));
>, <Line: +                assertThat(method.invoke(null), is((Object) BAR));
>, <Line: +            } else {
>, <Line: +                throw new AssertionError();
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    public void testCanOverloadFieldByType() throws Exception {
>, <Line: +        Class<?> type = createPlain()
>, <Line: +                .defineField(QUX, String.class)
>, <Line: +                .defineField(QUX, Object.class)
>, <Line: +                .make()
>, <Line: +                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)
>, <Line: +                .getLoaded();
>, <Line: +        for (Field field: type.getDeclaredFields()) {
>, <Line: +            if (field.getType() == String.class) {
>, <Line: +                assertThat(field.getName(), is(QUX));
>, <Line: +            } else if(field.getType() == Object.class) {
>, <Line: +                assertThat(field.getName(), is(QUX));
>, <Line: +            } else {
>, <Line: +                throw new AssertionError();
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>]
[]