[<Line: +import net.bytebuddy.dynamic.scaffold.FieldLocator;
>, <Line: +import net.bytebuddy.implementation.bytecode.Removal;
>, <Line: +import static net.bytebuddy.matcher.ElementMatchers.genericFieldType;
>, <Line: +public class Forwarding implements Implementation.Composable {
>, <Line: +     * A handler for preparing the instrumented type and the field invocation operation.
>, <Line: +    protected final PreparationHandler preparationHandler;
>, <Line: +     * The termination handler to apply.
>, <Line: +    protected final TerminationHandler terminationHandler;
>, <Line: +     * @param terminationHandler The termination handler to apply.
>, <Line: +    protected Forwarding(PreparationHandler preparationHandler, TerminationHandler terminationHandler) {
>, <Line: +        this.terminationHandler = terminationHandler;
>, <Line: +    public static Implementation.Composable to(Object delegate) {
>, <Line: +        return to(delegate, delegate.getClass());
>, <Line: +    public static Implementation.Composable to(Object delegate, String fieldName) {
>, <Line: +        return to(delegate, fieldName, delegate.getClass());
>, <Line: +     * Forwards all intercepted method invocations to the given instance which is stored in a {@code static} field
>, <Line: +     * of the instrumented class.
>, <Line: +     * @param delegate The delegate to which all intercepted methods should be forwarded.
>, <Line: +     * @param type     The type of the field. Must be a subtype of the delegate's type.
>, <Line: +    public static Implementation.Composable to(Object delegate, Type type) {
>, <Line: +        return to(delegate, String.format("%s$%d", FIELD_PREFIX, Math.abs(delegate.hashCode() % Integer.MAX_VALUE)), type);
>, <Line: +     * Forwards all intercepted method invocations to the given instance which is stored in a {@code static} field
>, <Line: +     * of the instrumented class.
>, <Line: +     * @param delegate  The delegate to which all intercepted methods should be forwarded.
>, <Line: +     * @param type      The type of the field. Must be a subtype of the delegate's type.
>, <Line: +    public static Implementation.Composable to(Object delegate, String fieldName, Type type) {
>, <Line: +        TypeDescription.Generic typeDescription = TypeDefinition.Sort.describe(type);
>, <Line: +        if (!typeDescription.asErasure().isInstance(delegate)) {
>, <Line: +            throw new IllegalArgumentException(delegate + " is not of type " + type);
>, <Line: +        }
>, <Line: +        return new Forwarding(new PreparationHandler.ForInstance(fieldName, typeDescription, delegate), TerminationHandler.RETURNING);
>, <Line: +     * Delegates a method invocation to a field. The field's type must be compatible to the declaring type of the method.
>, <Line: +     * @param name The name of the field.
>, <Line: +     * @return An implementation for a method forwarding that invokes the instrumented method on the given field.
>, <Line: +    public static Implementation.Composable toField(String name) {
>, <Line: +        return toField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);
>, <Line: +     * Delegates a method invocation to a field. The field's type must be compatible to the declaring type of the method.
>, <Line: +     * @param name                The name of the field.
>, <Line: +     * @param fieldLocatorFactory The field locator factory to use.
>, <Line: +     * @return An implementation for a method forwarding that invokes the instrumented method on the given field.
>, <Line: +    public static Implementation.Composable toField(String name, FieldLocator.Factory fieldLocatorFactory) {
>, <Line: +        return new Forwarding(new PreparationHandler.ForField(name, fieldLocatorFactory), TerminationHandler.RETURNING);
>, <Line: +        return new Appender(preparationHandler.resolve(implementationTarget.getInstrumentedType()), terminationHandler);
>, <Line: +    @Override
>, <Line: +    public Implementation andThen(Implementation implementation) {
>, <Line: +        return new Compound(new Forwarding(preparationHandler, TerminationHandler.DROPPING), implementation);
>, <Line: +        return preparationHandler.prepare(instrumentedType);
>, <Line: +    public boolean equals(Object object) {
>, <Line: +        if (this == object) return true;
>, <Line: +        if (object == null || getClass() != object.getClass()) return false;
>, <Line: +        Forwarding that = (Forwarding) object;
>, <Line: +        return preparationHandler.equals(that.preparationHandler) && terminationHandler == that.terminationHandler;
>, <Line: +        int result = preparationHandler.hashCode();
>, <Line: +        result = 31 * result + terminationHandler.hashCode();
>, <Line: +                "preparationHandler=" + preparationHandler +
>, <Line: +                ", terminationHandler=" + terminationHandler +
>, <Line: +     * A preparation handler is responsible for reading the field containing the forwarding instance.
>, <Line: +    protected interface PreparationHandler extends InstrumentedType.Prepareable {
>, <Line: +         * Resolves the field to which to delegate.
>, <Line: +         * @param instrumentedType The instrumented type.
>, <Line: +         * @return The field to which to delegate.
>, <Line: +        FieldDescription resolve(TypeDescription instrumentedType);
>, <Line: +         * A preparation handler that delegates to a specific instance.
>, <Line: +        class ForInstance implements PreparationHandler {
>, <Line: +            /**
>, <Line: +             * The name of the field to delegate to.
>, <Line: +             */
>, <Line: +            private final String fieldName;
>, <Line: +             * The type of the field.
>, <Line: +            private final TypeDescription.Generic typeDescription;
>, <Line: +            /**
>, <Line: +             * The delegate instance.
>, <Line: +             */
>, <Line: +            private final Object delegate;
>, <Line: +            /**
>, <Line: +             * Creates a new preparation handler for delegating to a field.
>, <Line: +             *
>, <Line: +             * @param fieldName       The name of the field to delegate to.
>, <Line: +             * @param typeDescription The type of the field.
>, <Line: +             * @param delegate        The delegate instance.
>, <Line: +             */
>, <Line: +            protected ForInstance(String fieldName, TypeDescription.Generic typeDescription, Object delegate) {
>, <Line: +                this.fieldName = fieldName;
>, <Line: +                this.typeDescription = typeDescription;
>, <Line: +                this.delegate = delegate;
>, <Line: +            public FieldDescription resolve(TypeDescription instrumentedType) {
>, <Line: +                return instrumentedType.getDeclaredFields().filter(named(fieldName).and(genericFieldType(typeDescription))).getOnly();
>, <Line: +            public InstrumentedType prepare(InstrumentedType instrumentedType) {
>, <Line: +                return instrumentedType
>, <Line: +                        .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC, typeDescription))
>, <Line: +                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, delegate));
>, <Line: +            public boolean equals(Object object) {
>, <Line: +                if (this == object) return true;
>, <Line: +                if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                ForInstance that = (ForInstance) object;
>, <Line: +                return fieldName.equals(that.fieldName)
>, <Line: +                        && typeDescription.equals(that.typeDescription)
>, <Line: +                        && delegate.equals(that.delegate);
>, <Line: +            public int hashCode() {
>, <Line: +                int result = fieldName.hashCode();
>, <Line: +                result = 31 * result + typeDescription.hashCode();
>, <Line: +                result = 31 * result + delegate.hashCode();
>, <Line: +                return result;
>, <Line: +                return "Forwarding.PreparationHandler.ForInstance{" +
>, <Line: +                        "fieldName='" + fieldName + '\'' +
>, <Line: +                        ", typeDescription=" + typeDescription +
>, <Line: +                        ", delegate=" + delegate +
>, <Line: +                        '}';
>, <Line: +         * A preparation handler that delegates to a specific field.
>, <Line: +        class ForField implements PreparationHandler {
>, <Line: +             * The name of the field to delegate to.
>, <Line: +            private final String fieldName;
>, <Line: +             * The field locator factory to use.
>, <Line: +             */
>, <Line: +            private final FieldLocator.Factory fieldLocatorFactory;
>, <Line: +            /**
>, <Line: +             * Creates a new preparation handler for forwarding to a specific field.
>, <Line: +             * @param fieldName           The name of the field to delegate to.
>, <Line: +             * @param fieldLocatorFactory The field locator factory to use.
>, <Line: +            protected ForField(String fieldName, FieldLocator.Factory fieldLocatorFactory) {
>, <Line: +                this.fieldName = fieldName;
>, <Line: +                this.fieldLocatorFactory = fieldLocatorFactory;
>, <Line: +            public FieldDescription resolve(TypeDescription instrumentedType) {
>, <Line: +                FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(fieldName);
>, <Line: +                if (!resolution.isResolved()) {
>, <Line: +                    throw new IllegalStateException();
>, <Line: +                }
>, <Line: +                return resolution.getField();
>, <Line: +            public InstrumentedType prepare(InstrumentedType instrumentedType) {
>, <Line: +                return instrumentedType;
>, <Line: +            public boolean equals(Object object) {
>, <Line: +                if (this == object) return true;
>, <Line: +                if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                ForField forField = (ForField) object;
>, <Line: +                return fieldName.equals(forField.fieldName) && fieldLocatorFactory.equals(forField.fieldLocatorFactory);
>, <Line: +                int result = fieldName.hashCode();
>, <Line: +                result = 31 * result + fieldLocatorFactory.hashCode();
>, <Line: +                return result;
>, <Line: +                return "Forwarding.PreparationHandler.ForField{" +
>, <Line: +                        "fieldName='" + fieldName + '\'' +
>, <Line: +                        ", fieldLocatorFactory=" + fieldLocatorFactory +
>, <Line: +                        '}';
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * A termination handler is responsible for a method's return.
>, <Line: +     */
>, <Line: +    protected enum TerminationHandler {
>, <Line: +        /**
>, <Line: +         * A termination handler that drops the forwarded method's return value.
>, <Line: +         */
>, <Line: +        DROPPING {
>, <Line: +            @Override
>, <Line: +            protected StackManipulation resolve(TypeDefinition returnType) {
>, <Line: +                return Removal.pop(returnType);
>, <Line: +        },
>, <Line: +        /**
>, <Line: +         * A termination handler that returns the forwarded method's return value.
>, <Line: +         */
>, <Line: +        RETURNING {
>, <Line: +            @Override
>, <Line: +            protected StackManipulation resolve(TypeDefinition returnType) {
>, <Line: +                return MethodReturn.of(returnType);
>, <Line: +            }
>, <Line: +        };
>, <Line: +        /**
>, <Line: +         * Resolves a stack manipulation for handling the forwarded method's return value.
>, <Line: +         *
>, <Line: +         * @param returnType The return type.
>, <Line: +         * @return An appropriate stack manipulation.
>, <Line: +         */
>, <Line: +        protected abstract StackManipulation resolve(TypeDefinition returnType);
>, <Line: +        @Override
>, <Line: +        public String toString() {
>, <Line: +            return "Forwarding.TerminationHandler." + name();
>, <Line: +    protected static class Appender implements ByteCodeAppender {
>, <Line: +        /**
>, <Line: +         * The field to forward to.
>, <Line: +         */
>, <Line: +        private final FieldDescription fieldDescription;
>, <Line: +         * The termination handler to apply.
>, <Line: +        private final TerminationHandler terminationHandler;
>, <Line: +         * Creates a new appender for a forwarding implementation.
>, <Line: +         * @param fieldDescription   The field to forward to.
>, <Line: +         * @param terminationHandler The termination handler to apply.
>, <Line: +        protected Appender(FieldDescription fieldDescription, TerminationHandler terminationHandler) {
>, <Line: +            this.fieldDescription = fieldDescription;
>, <Line: +            this.terminationHandler = terminationHandler;
>, <Line: +            if (instrumentedMethod.isStatic()) {
>, <Line: +                throw new IllegalStateException("Cannot forward the static method " + instrumentedMethod);
>, <Line: +            } else if (!instrumentedMethod.isInvokableOn(fieldDescription.getType().asErasure())) {
>, <Line: +                throw new IllegalStateException("Cannot forward " + instrumentedMethod + " to " + fieldDescription.getType());
>, <Line: +                    fieldDescription.isStatic()
>, <Line: +                            ? StackManipulation.Trivial.INSTANCE
>, <Line: +                            : MethodVariableAccess.REFERENCE.loadOffset(0),
>, <Line: +                    FieldAccess.forField(fieldDescription).getter(),
>, <Line: +                    MethodInvocation.invoke(instrumentedMethod).virtual(fieldDescription.getType().asErasure()),
>, <Line: +                    terminationHandler.resolve(instrumentedMethod.getReturnType())
>, <Line: +        public boolean equals(Object object) {
>, <Line: +            if (this == object) return true;
>, <Line: +            if (object == null || getClass() != object.getClass()) return false;
>, <Line: +            Appender appender = (Appender) object;
>, <Line: +            return fieldDescription.equals(appender.fieldDescription)
>, <Line: +                    && terminationHandler == appender.terminationHandler;
>, <Line: +            int result = fieldDescription.hashCode();
>, <Line: +            result = 31 * result + terminationHandler.hashCode();
>, <Line: +            return result;
>, <Line: +            return "Forwarding.Appender{" +
>, <Line: +                    "fieldDescription=" + fieldDescription +
>, <Line: +                    ", terminationHandler=" + terminationHandler +
>, <Line: +                    '}';
>]
[<Line: -public class Forwarding implements Implementation {
>, <Line: -     * The name of the field.
>, <Line: -    protected final String fieldName;
>, <Line: -     * The type of the field.
>, <Line: -    protected final TypeDescription.Generic fieldType;
>, <Line: -    /**
>, <Line: -     * A handler for preparing the instrumented type and the field invocation operation.
>, <Line: -     */
>, <Line: -    protected final PreparationHandler preparationHandler;
>, <Line: -     * @param fieldName          The name of the field.
>, <Line: -     * @param fieldType          The type of the field.
>, <Line: -    protected Forwarding(String fieldName, TypeDescription.Generic fieldType, PreparationHandler preparationHandler) {
>, <Line: -        this.fieldName = fieldName;
>, <Line: -        this.fieldType = fieldType;
>, <Line: -    public static Implementation to(Object delegate) {
>, <Line: -        return to(delegate, String.format("%s$%d", FIELD_PREFIX, Math.abs(delegate.hashCode() % Integer.MAX_VALUE)));
>, <Line: -    public static Implementation to(Object delegate, String fieldName) {
>, <Line: -        return new Forwarding(fieldName,
>, <Line: -                new TypeDescription.Generic.OfNonGenericType.ForLoadedType(delegate.getClass()),
>, <Line: -                new PreparationHandler.ForStaticInstance(delegate));
>, <Line: -     * Forwards all intercepted method invocations to a {@code static} field of the instrumented class. The value
>, <Line: -     * of this field must be set explicitly.
>, <Line: -     * @param fieldName The name of the field in which the delegate should be stored.
>, <Line: -     * @param fieldType The type of the field and thus the type of which the delegate is assumed to be of.
>, <Line: -    public static Implementation toStaticField(String fieldName, Type fieldType) {
>, <Line: -        return toStaticField(fieldName, TypeDefinition.Sort.describe(fieldType));
>, <Line: -     * Forwards all intercepted method invocations to a {@code static} field of the instrumented class. The value
>, <Line: -     * of this field must be set explicitly.
>, <Line: -     * @param fieldType The type of the field and thus the type of which the delegate is assumed to be of.
>, <Line: -    public static Implementation toStaticField(String fieldName, TypeDefinition fieldType) {
>, <Line: -        return new Forwarding(fieldName, fieldType.asGenericType(), PreparationHandler.ForStaticField.INSTANCE);
>, <Line: -     * Forwards all intercepted method invocations to an instance field of the instrumented class. The value
>, <Line: -     * of this field must be set explicitly.
>, <Line: -     * @param fieldName The name of the field in which the delegate should be stored.
>, <Line: -     * @param fieldType The type of the field and thus the type of which the delegate is assumed to be of.
>, <Line: -     * @return A corresponding implementation.
>, <Line: -    public static Implementation toInstanceField(String fieldName, Type fieldType) {
>, <Line: -        return toInstanceField(fieldName, TypeDefinition.Sort.describe(fieldType));
>, <Line: -     * Forwards all intercepted method invocations to an instance field of the instrumented class. The value
>, <Line: -     * of this field must be set explicitly.
>, <Line: -     * @param fieldName The name of the field in which the delegate should be stored.
>, <Line: -     * @param fieldType The type of the field and thus the type of which the delegate is assumed to be of.
>, <Line: -     * @return A corresponding implementation.
>, <Line: -    public static Implementation toInstanceField(String fieldName, TypeDefinition fieldType) {
>, <Line: -        return new Forwarding(fieldName, fieldType.asGenericType(), PreparationHandler.ForInstanceField.INSTANCE);
>, <Line: -        return new Appender(loadDelegate(implementationTarget.getInstrumentedType()));
>, <Line: -    /**
>, <Line: -     * Loads the field onto the operand stack.
>, <Line: -     *
>, <Line: -     * @param instrumentedType The instrumented type that declares the field.
>, <Line: -     * @return A stack manipulation for loading the field value onto the operand stack.
>, <Line: -     */
>, <Line: -    private StackManipulation loadDelegate(TypeDescription instrumentedType) {
>, <Line: -        return new StackManipulation.Compound(preparationHandler.loadFieldOwner(),
>, <Line: -                FieldAccess.forField(instrumentedType.getDeclaredFields().filter((named(fieldName))).getOnly()).getter());
>, <Line: -        return preparationHandler.prepare(instrumentedType, fieldName, fieldType);
>, <Line: -    public boolean equals(Object other) {
>, <Line: -        if (this == other) return true;
>, <Line: -        if (other == null || getClass() != other.getClass()) return false;
>, <Line: -        Forwarding that = (Forwarding) other;
>, <Line: -        return fieldName.equals(that.fieldName)
>, <Line: -                && fieldType.equals(that.fieldType)
>, <Line: -                && preparationHandler.equals(that.preparationHandler);
>, <Line: -        int result = fieldName.hashCode();
>, <Line: -        result = 31 * result + fieldType.hashCode();
>, <Line: -        result = 31 * result + preparationHandler.hashCode();
>, <Line: -                "fieldName='" + fieldName + '\'' +
>, <Line: -                ", fieldType=" + fieldType +
>, <Line: -                ", preparationHandler=" + preparationHandler +
>, <Line: -     * A handler for preparing a {@link net.bytebuddy.implementation.Forwarding} implementation.
>, <Line: -    protected interface PreparationHandler {
>, <Line: -         * Prepares the instrumented type.
>, <Line: -         * @param instrumentedType The instrumented type to prepare.
>, <Line: -         * @param fieldName        The name of the field in which the delegate should be stored.
>, <Line: -         * @param fieldType        The type of the field.
>, <Line: -         * @return The prepared instrumented type.
>, <Line: -        InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription.Generic fieldType);
>, <Line: -         * Creates a stack manipulation for loading the field owner onto the operand stack.
>, <Line: -         *
>, <Line: -         * @return A stack manipulation for loading the field owner onto the operand stack.
>, <Line: -        StackManipulation loadFieldOwner();
>, <Line: -        /**
>, <Line: -         * A preparation handler for an unset instance that is stored in an instance field.
>, <Line: -         */
>, <Line: -        enum ForInstanceField implements PreparationHandler {
>, <Line: -             * The singleton instance.
>, <Line: -            INSTANCE;
>, <Line: -            @Override
>, <Line: -            public InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription.Generic fieldType) {
>, <Line: -                if (instrumentedType.isInterface()) {
>, <Line: -                    throw new IllegalStateException("Cannot define instance field '" + fieldName + "' for " + instrumentedType);
>, <Line: -                }
>, <Line: -                return instrumentedType.withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC, fieldType));
>, <Line: -            public StackManipulation loadFieldOwner() {
>, <Line: -                return MethodVariableAccess.REFERENCE.loadOffset(0);
>, <Line: -            public String toString() {
>, <Line: -                return "Forwarding.PreparationHandler.ForInstanceField." + name();
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A preparation handler for an unset instance that is stored in a {@code static} field.
>, <Line: -         */
>, <Line: -        enum ForStaticField implements PreparationHandler {
>, <Line: -            /**
>, <Line: -             * The singleton instance.
>, <Line: -             */
>, <Line: -            INSTANCE;
>, <Line: -            public InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription.Generic fieldType) {
>, <Line: -                return instrumentedType.withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, fieldType));
>, <Line: -            public StackManipulation loadFieldOwner() {
>, <Line: -                return StackManipulation.Trivial.INSTANCE;
>, <Line: -                return "Forwarding.PreparationHandler.ForStaticField." + name();
>, <Line: -         * A preparation handler for an explicit instance that is stored in a {@code static} field.
>, <Line: -        class ForStaticInstance implements PreparationHandler {
>, <Line: -             * The target of the delegation.
>, <Line: -            private final Object target;
>, <Line: -             * Creates a new preparation handler for an explicit instance.
>, <Line: -             * @param target The target of the delegation.
>, <Line: -            public ForStaticInstance(Object target) {
>, <Line: -                this.target = target;
>, <Line: -            public InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription.Generic fieldType) {
>, <Line: -                return instrumentedType
>, <Line: -                        .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, fieldType))
>, <Line: -                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, target));
>, <Line: -            public StackManipulation loadFieldOwner() {
>, <Line: -                return StackManipulation.Trivial.INSTANCE;
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                        && target.equals(((ForStaticInstance) other).target);
>, <Line: -                return target.hashCode();
>, <Line: -                return "Forwarding.PreparationHandler.ForStaticInstance{target=" + target + '}';
>, <Line: -    protected class Appender implements ByteCodeAppender {
>, <Line: -         * The stack manipulation for loading the delegate onto the stack, i.e. the field loading operation.
>, <Line: -        private final StackManipulation delegateLoadingInstruction;
>, <Line: -         * Creates a new appender.
>, <Line: -         * @param delegateLoadingInstruction The stack manipulation for loading the delegate onto the stack, i.e.
>, <Line: -         *                                   the field loading operation.
>, <Line: -        private Appender(StackManipulation delegateLoadingInstruction) {
>, <Line: -            this.delegateLoadingInstruction = delegateLoadingInstruction;
>, <Line: -            if (!instrumentedMethod.isInvokableOn(fieldType.asErasure())) {
>, <Line: -                throw new IllegalArgumentException("Cannot forward " + instrumentedMethod + " to " + fieldType);
>, <Line: -            } else if (instrumentedMethod.isStatic()) {
>, <Line: -                throw new IllegalArgumentException("Cannot forward the static method " + instrumentedMethod);
>, <Line: -                    delegateLoadingInstruction,
>, <Line: -                    MethodInvocation.invoke(instrumentedMethod).virtual(fieldType.asErasure()),
>, <Line: -                    MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
>, <Line: -        public boolean equals(Object other) {
>, <Line: -            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                    && delegateLoadingInstruction.equals(((Appender) other).delegateLoadingInstruction)
>, <Line: -                    && Forwarding.this.equals(((Appender) other).getForwarding());
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * Returns the outer instance.
>, <Line: -         *
>, <Line: -         * @return The outer instance.
>, <Line: -         */
>, <Line: -        private Forwarding getForwarding() {
>, <Line: -            return Forwarding.this;
>, <Line: -            return Forwarding.this.hashCode() + 31 * delegateLoadingInstruction.hashCode();
>, <Line: -            return "Forwarding.Appender{delegateLoadingInstruction=" + delegateLoadingInstruction + '}';
>]