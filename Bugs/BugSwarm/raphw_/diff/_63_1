[<Line: +                                       ComponentTypeReference componentTypeReference,
>, <Line: +                                       List<AnnotationValue<?, ?>> values) {
>, <Line: +                    protected ForRawType(String name) {
>, <Line: +                    protected ForTypeVariable(String symbol) {
>, <Line: +                        return typeVariable == null
>, <Line: +                                ? new UnresolvedTypeVariable(typeVariableSource, typePool, symbol, annotationTokens.get(typePath))
>, <Line: +                                : new AnnotatedTypeVariable(typePool, annotationTokens.get(typePath), typeVariable);
>, <Line: +                    /**
>, <Line: +                     * Represents a type variable that a type references but that does not exist. Such type variables are only emitted by wrongful
>, <Line: +                     * compilation either due to the isolated recompilation of outer classes or due to bugs in compilers.
>, <Line: +                     */
>, <Line: +                    protected static class UnresolvedTypeVariable extends Generic.OfTypeVariable {
>, <Line: +                        /**
>, <Line: +                         * The undeclared type variable's source.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable's symbol.
>, <Line: +                         */
>, <Line: +                        private final String symbol;
>, <Line: +                        /**
>, <Line: +                         * The type variable's annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final List<AnnotationToken> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * Creates an unresolved type variable.
>, <Line: +                         *
>, <Line: +                         * @param typeVariableSource The undeclared type variable's source.
>, <Line: +                         * @param typePool           The type pool to use.
>, <Line: +                         * @param symbol             The type variable's symbol.
>, <Line: +                         * @param annotationTokens   The type variable's annotation tokens.
>, <Line: +                         */
>, <Line: +                        protected UnresolvedTypeVariable(TypeVariableSource typeVariableSource,
>, <Line: +                                                         TypePool typePool,
>, <Line: +                                                         String symbol,
>, <Line: +                                                         List<AnnotationToken> annotationTokens) {
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.symbol = symbol;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            throw new IllegalStateException("Cannot resolve bounds of unresolved type variable " + this + " by " + typeVariableSource);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableSource getTypeVariableSource() {
>, <Line: +                            return typeVariableSource;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String getSymbol() {
>, <Line: +                            return symbol;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    protected static class Formal implements GenericTypeToken.OfFormalTypeVariable {
>, <Line: +                        protected Formal(String symbol, List<GenericTypeToken> boundTypeTokens) {
>, <Line: +                    protected ForGenericArray(GenericTypeToken componentTypeToken) {
>, <Line: +                    protected ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: +                    protected ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: +                    protected ForParameterizedType(String name, List<GenericTypeToken> parameterTypeTokens) {
>, <Line: +                        protected Nested(String name, List<GenericTypeToken> parameterTypeTokens, GenericTypeToken ownerTypeToken) {
>]
[<Line: -                                   ComponentTypeReference componentTypeReference,
>, <Line: -                                   List<AnnotationValue<?, ?>> values) {
>, <Line: -                    public ForRawType(String name) {
>, <Line: -                    public ForTypeVariable(String symbol) {
>, <Line: -                        if (typeVariable == null) {
>, <Line: -                            throw new IllegalStateException("Cannot resolve type variable '" + symbol + "' for " + typeVariableSource);
>, <Line: -                        } else {
>, <Line: -                            return new AnnotatedTypeVariable(typePool, annotationTokens.get(typePath), typeVariable);
>, <Line: -                        }
>, <Line: -                    public static class Formal implements GenericTypeToken.OfFormalTypeVariable {
>, <Line: -                        public Formal(String symbol, List<GenericTypeToken> boundTypeTokens) {
>, <Line: -                    public ForGenericArray(GenericTypeToken componentTypeToken) {
>, <Line: -                    public ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: -                    public ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: -                    public ForParameterizedType(String name, List<GenericTypeToken> parameterTypeTokens) {
>, <Line: -                        public Nested(String name, List<GenericTypeToken> parameterTypeTokens, GenericTypeToken ownerTypeToken) {
>]