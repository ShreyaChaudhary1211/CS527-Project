[<Line: +import net.bytebuddy.ClassFileVersion;
>, <Line: +import net.bytebuddy.description.type.TypeDescription;
>, <Line: +    /**
>, <Line: +     * A property dispatcher for a {@code Class} value. This value requires special handling since Java 9.
>, <Line: +     */
>, <Line: +    TYPE_LOADED {
>, <Line: +        @Override
>, <Line: +        public String toString(Object value) {
>, <Line: +            return TypeRenderer.CURRENT.render((Class<?>) value);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode(Object value) {
>, <Line: +            return value.hashCode();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        protected boolean doEquals(Object first, Object second) {
>, <Line: +            return first.equals(second);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public <T> T conditionalClone(T value) {
>, <Line: +            return value;
>, <Line: +        }
>, <Line: +    },
>, <Line: +    /**
>, <Line: +     * A property dispatcher for a {@code Class[]} value. This value requires special handling since Java 9.
>, <Line: +     */
>, <Line: +    TYPE_LOADED_ARRAY {
>, <Line: +        @Override
>, <Line: +        public String toString(Object value) {
>, <Line: +            StringBuilder stringBuilder = new StringBuilder().append(TypeRenderer.CURRENT.adjust('['));
>, <Line: +            boolean initial = true;
>, <Line: +            for (Class<?> type : (Class<?>[]) value) {
>, <Line: +                stringBuilder.append(TypeRenderer.CURRENT.render(type));
>, <Line: +                if (initial) {
>, <Line: +                    initial = false;
>, <Line: +                } else {
>, <Line: +                    stringBuilder.append(", ");
>, <Line: +                }
>, <Line: +            }
>, <Line: +            return stringBuilder.append(TypeRenderer.CURRENT.adjust(']')).toString();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode(Object value) {
>, <Line: +            return Arrays.hashCode((Object[]) value);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        protected boolean doEquals(Object first, Object second) {
>, <Line: +            return Arrays.equals((Object[]) first, (Object[]) second);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        @SuppressWarnings("unchecked")
>, <Line: +        public <T> T conditionalClone(T value) {
>, <Line: +            Object[] castValue = (Object[]) value;
>, <Line: +            return castValue.length == 0 ? value : (T) castValue.clone();
>, <Line: +        }
>, <Line: +    },
>, <Line: +    /**
>, <Line: +     * A property dispatcher for a {@code TypeDescription} value. This value requires special handling since Java 9.
>, <Line: +     */
>, <Line: +    TYPE_DESCRIBED {
>, <Line: +        @Override
>, <Line: +        public String toString(Object value) {
>, <Line: +            return TypeRenderer.CURRENT.render((TypeDescription) value);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode(Object value) {
>, <Line: +            return value.hashCode();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        protected boolean doEquals(Object first, Object second) {
>, <Line: +            return first.equals(second);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public <T> T conditionalClone(T value) {
>, <Line: +            return value;
>, <Line: +        }
>, <Line: +    },
>, <Line: +    /**
>, <Line: +     * A property dispatcher for a {@code TypeDescription[]} value. This value requires special handling since Java 9.
>, <Line: +     */
>, <Line: +    TYPE_DESCRIBED_ARRAY {
>, <Line: +        @Override
>, <Line: +        public String toString(Object value) {
>, <Line: +            StringBuilder stringBuilder = new StringBuilder().append(TypeRenderer.CURRENT.adjust('['));
>, <Line: +            boolean initial = true;
>, <Line: +            for (TypeDescription typeDescription : (TypeDescription[]) value) {
>, <Line: +                stringBuilder.append(TypeRenderer.CURRENT.render(typeDescription));
>, <Line: +                if (initial) {
>, <Line: +                    initial = false;
>, <Line: +                } else {
>, <Line: +                    stringBuilder.append(", ");
>, <Line: +                }
>, <Line: +            }
>, <Line: +            return stringBuilder.append(TypeRenderer.CURRENT.adjust(']')).toString();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode(Object value) {
>, <Line: +            return Arrays.hashCode((Object[]) value);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        protected boolean doEquals(Object first, Object second) {
>, <Line: +            return Arrays.equals((Object[]) first, (Object[]) second);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        @SuppressWarnings("unchecked")
>, <Line: +        public <T> T conditionalClone(T value) {
>, <Line: +            Object[] castValue = (Object[]) value;
>, <Line: +            return castValue.length == 0 ? value : (T) castValue.clone();
>, <Line: +        }
>, <Line: +    },
>, <Line: +        } else if (type == Class.class) {
>, <Line: +            return TYPE_LOADED;
>, <Line: +        } else if (type == Class[].class) {
>, <Line: +            return TYPE_LOADED_ARRAY;
>, <Line: +        } else if (TypeDescription.class.isAssignableFrom(type)) {
>, <Line: +            return TYPE_DESCRIBED;
>, <Line: +        } else if (TypeDescription[].class.isAssignableFrom(type)) {
>, <Line: +            return TYPE_DESCRIBED_ARRAY;
>, <Line: +    /**
>, <Line: +     * A delegate for rendering a {@link Class} or {@link TypeDescription}. Starting with Java 9, such values are enclosed
>, <Line: +     * in curly braces and are rendered as class literals to better match the source code.
>, <Line: +     */
>, <Line: +    protected enum TypeRenderer {
>, <Line: +        /**
>, <Line: +         * A type renderer for a legacy VM prior to Java 8.
>, <Line: +         */
>, <Line: +        FOR_LEGACY_VM(0) {
>, <Line: +            @Override
>, <Line: +            protected String render(Class<?> type) {
>, <Line: +                return type.toString();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            protected String render(TypeDescription typeDescription) {
>, <Line: +                return typeDescription.toString();
>, <Line: +            }
>, <Line: +        },
>, <Line: +        /**
>, <Line: +         * A type renderer for a VM of at least Java version 9.
>, <Line: +         */
>, <Line: +        FOR_JAVA9_CAPABLE_VM('{' - '[') {
>, <Line: +            @Override
>, <Line: +            protected String render(Class<?> type) {
>, <Line: +                return type.getName() + JAVA9_NAME_SUFFIX;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            protected String render(TypeDescription typeDescription) {
>, <Line: +                return typeDescription.getName() + JAVA9_NAME_SUFFIX;
>, <Line: +            }
>, <Line: +        };
>, <Line: +        /**
>, <Line: +         * The class constant suffix for types from Java 9 and later.
>, <Line: +         */
>, <Line: +        private static final String JAVA9_NAME_SUFFIX = ".class";
>, <Line: +        /**
>, <Line: +         * The type renderer to be used on the current VM.
>, <Line: +         */
>, <Line: +        protected static final TypeRenderer CURRENT = make();
>, <Line: +        /**
>, <Line: +         * Finds the type renderer for the current VM.
>, <Line: +         *
>, <Line: +         * @return The type renderer to be used on the current VM.
>, <Line: +         */
>, <Line: +        private static TypeRenderer make() {
>, <Line: +            return ClassFileVersion.forCurrentJavaVersion(ClassFileVersion.JAVA_V6).isAtLeast(ClassFileVersion.JAVA_V9)
>, <Line: +                    ? FOR_JAVA9_CAPABLE_VM
>, <Line: +                    : FOR_LEGACY_VM;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * The offset to add for braces starting from {@code [} or {@code ]}.
>, <Line: +         */
>, <Line: +        private final int offset;
>, <Line: +        /**
>, <Line: +         * Creates a new type renderer.
>, <Line: +         *
>, <Line: +         * @param offset The offset to add for braces.
>, <Line: +         */
>, <Line: +        TypeRenderer(int offset) {
>, <Line: +            this.offset = offset;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Adjusts a brace character.
>, <Line: +         *
>, <Line: +         * @param delimiter The delimiter being used.
>, <Line: +         * @return The adjusted delimiter.
>, <Line: +         */
>, <Line: +        protected char adjust(char delimiter) {
>, <Line: +            return (char) (delimiter + offset);
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Renders a {@link Class} constant.
>, <Line: +         *
>, <Line: +         * @param type The type to be rendered.
>, <Line: +         * @return The rendered string.
>, <Line: +         */
>, <Line: +        protected abstract String render(Class<?> type);
>, <Line: +        /**
>, <Line: +         * Renders a {@link TypeDescription} which represents a constant.
>, <Line: +         *
>, <Line: +         * @param typeDescription The type to be rendered.
>, <Line: +         * @return The rendered string.
>, <Line: +         */
>, <Line: +        protected abstract String render(TypeDescription typeDescription);
>, <Line: +        @Override
>, <Line: +        public String toString() {
>, <Line: +            return "PropertyDispatcher.TypeRenderer." + name();
>, <Line: +        }
>, <Line: +    }
>]
[]