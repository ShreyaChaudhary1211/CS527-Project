[<Line: +import net.bytebuddy.description.ModifierReviewable;
>, <Line: +import net.bytebuddy.test.packaging.PackagePrivateType;
>, <Line: +    private static final int ILLEGAL_MODIFIERS = -1, OTHER_MODIFIERS = 42;
>, <Line: +    @Mock
>, <Line: +    private AnnotationDescription annotationDescription;
>, <Line: +                ModifierReviewable.EMPTY_MASK,
>, <Line: +                new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.singletonList(annotationDescription))));
>, <Line: +        assertThat(fieldDescription.getType().getDeclaredAnnotations().size(), is(1));
>, <Line: +        assertThat(fieldDescription.getType().getDeclaredAnnotations().getOnly(), is(annotationDescription));
>, <Line: +                new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.singletonList(annotationDescription)),
>, <Line: +                Collections.singletonList(new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.singletonList(annotationDescription)))));
>, <Line: +        assertThat(methodDescription.getReturnType().getDeclaredAnnotations().size(), is(1));
>, <Line: +        assertThat(methodDescription.getReturnType().getDeclaredAnnotations().getOnly(), is(annotationDescription));
>, <Line: +        assertThat(methodDescription.getParameters().getOnly().getType().getDeclaredAnnotations().size(), is(1));
>, <Line: +        assertThat(methodDescription.getParameters().getOnly().getType().getDeclaredAnnotations().getOnly(), is(annotationDescription));
>, <Line: +        assertThat(instrumentedType.getModifiers(), is(ModifierContributor.EMPTY_MASK));
>, <Line: +        instrumentedType = instrumentedType.withModifiers(OTHER_MODIFIERS);
>, <Line: +        assertThat(instrumentedType.getModifiers(), is(OTHER_MODIFIERS));
>, <Line: +    @Test(expected = IllegalStateException.class)
>, <Line: +        InstrumentedType.Default.subclass(FOO, ModifierContributor.EMPTY_MASK, TypeDefinition.Sort.describe(PackagePrivateType.TYPE)).validated();
>, <Line: +        makePlainInstrumentedType().withInterfaces(new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(PackagePrivateType.INTERFACE_TYPE))).validated();
>, <Line: +        makePlainInstrumentedType()
>, <Line: +                .withField(new FieldDescription.Token(FOO, ModifierContributor.EMPTY_MASK, TypeDefinition.Sort.describe(PackagePrivateType.TYPE)))
>, <Line: +                .validated();
>, <Line: +                .withMethod(new MethodDescription.Token(FOO, ModifierContributor.EMPTY_MASK, TypeDefinition.Sort.describe(PackagePrivateType.TYPE)))
>, <Line: +    @Test
>, <Line: +    public void testMethodInvisibleReturnTypeSynthetic() throws Exception {
>, <Line: +        assertThat(makePlainInstrumentedType()
>, <Line: +                .withMethod(new MethodDescription.Token(FOO, Opcodes.ACC_SYNTHETIC, TypeDefinition.Sort.describe(PackagePrivateType.TYPE)))
>, <Line: +                .validated(), instanceOf(TypeDescription.class));
>, <Line: +    }
>, <Line: +                        Collections.singletonList(new ParameterDescription.Token(TypeDefinition.Sort.describe(PackagePrivateType.TYPE))),
>, <Line: +    @Test
>, <Line: +    public void testMethodParameterInvisibleTypeSynthetic() throws Exception {
>, <Line: +        assertThat(makePlainInstrumentedType()
>, <Line: +                .withMethod(new MethodDescription.Token(FOO,
>, <Line: +                        Opcodes.ACC_SYNTHETIC,
>, <Line: +                        Collections.<TypeVariableToken>emptyList(),
>, <Line: +                        TypeDescription.Generic.OBJECT,
>, <Line: +                        Collections.singletonList(new ParameterDescription.Token(TypeDefinition.Sort.describe(PackagePrivateType.TYPE))),
>, <Line: +                        Collections.<TypeDescription.Generic>emptyList(),
>, <Line: +                        Collections.<AnnotationDescription>emptyList(),
>, <Line: +                        MethodDescription.NO_DEFAULT_VALUE))
>, <Line: +                .validated(), notNullValue(TypeDescription.class));
>, <Line: +    }
>, <Line: +    public void testMethodParameterIllegalModifiers() throws Exception {
>, <Line: +                        Collections.singletonList(TypeDefinition.Sort.describe(PackagePrivateType.EXCEPTION_TYPE)),
>, <Line: +    @Test
>, <Line: +    public void testMethodInvisibleExceptionSynthetic() throws Exception {
>, <Line: +        assertThat(makePlainInstrumentedType()
>, <Line: +                .withMethod(new MethodDescription.Token(FOO,
>, <Line: +                        Opcodes.ACC_SYNTHETIC,
>, <Line: +                        Collections.<TypeVariableToken>emptyList(),
>, <Line: +                        TypeDescription.Generic.OBJECT,
>, <Line: +                        Collections.<ParameterDescription.Token>emptyList(),
>, <Line: +                        Collections.singletonList(TypeDefinition.Sort.describe(PackagePrivateType.EXCEPTION_TYPE)),
>, <Line: +                        Collections.<AnnotationDescription>emptyList(),
>, <Line: +                        MethodDescription.NO_DEFAULT_VALUE))
>, <Line: +                .validated(), notNullValue(TypeDescription.class));
>, <Line: +    }
>]
[<Line: -import org.junit.Before;
>, <Line: -    private static final int MODIFIERS = 42, ILLEGAL_MODIFIERS = -1;
>, <Line: -    private TypeDescription.Generic packagePrivateType, packagePrivateInterfaceType, packagePrivateExceptionType;
>, <Line: -    @Before
>, <Line: -    public void setUp() throws Exception {
>, <Line: -        packagePrivateType = TypeDefinition.Sort.describe(Class.forName("net.bytebuddy.test.packaging.PackagePrivateType"));
>, <Line: -        packagePrivateInterfaceType = TypeDefinition.Sort.describe(Class.forName("net.bytebuddy.test.packaging.PackagePrivateInterfaceType"));
>, <Line: -        packagePrivateExceptionType = TypeDefinition.Sort.describe(Class.forName("net.bytebuddy.test.packaging.PackagePrivateExceptionType"));
>, <Line: -    }
>, <Line: -                MODIFIERS,
>, <Line: -                TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, 1)));
>, <Line: -                TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, 1),
>, <Line: -                Collections.singletonList(TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, 1))));
>, <Line: -        assertThat(instrumentedType.getModifiers(), is(MODIFIERS));
>, <Line: -        instrumentedType = instrumentedType.withModifiers(MODIFIERS);
>, <Line: -        assertThat(instrumentedType.getModifiers(), is(MODIFIERS));
>, <Line: -    @Test
>, <Line: -        InstrumentedType.Default.subclass(FOO, ModifierContributor.EMPTY_MASK, packagePrivateType).validated();
>, <Line: -        makePlainInstrumentedType().withInterfaces(new TypeList.Generic.Explicit(packagePrivateInterfaceType)).validated();
>, <Line: -        makePlainInstrumentedType().withField(new FieldDescription.Token(FOO, ModifierContributor.EMPTY_MASK, packagePrivateType)).validated();
>, <Line: -                .withMethod(new MethodDescription.Token(FOO, ModifierContributor.EMPTY_MASK, packagePrivateType))
>, <Line: -                        Collections.singletonList(new ParameterDescription.Token(packagePrivateType)),
>, <Line: -    public void testMethodParameterIllegalModiifers() throws Exception {
>, <Line: -                        Collections.singletonList(packagePrivateExceptionType),
>]