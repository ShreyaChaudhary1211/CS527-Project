[<Line: +import org.hamcrest.BaseMatcher;
>, <Line: +import org.hamcrest.Description;
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +        verify(instrumentation).retransformClasses(REDEFINED);
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verifyZeroInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.<List<Class<?>>, Throwable>emptyMap());
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +        Throwable throwable = new RuntimeException();
>, <Line: +        doThrow(throwable).when(instrumentation).retransformClasses(OTHER);
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        doThrow(throwable).when(redefinitionFailureHandler).onFailure(any(Map.class));
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +        verify(instrumentation).retransformClasses(REDEFINED);
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verify(redefinitionFailureHandler).onBatchFailure(Collections.<Class<?>>singletonList(OTHER), throwable);
>, <Line: +        verify(redefinitionFailureHandler).onFailure(Collections.singletonMap(Collections.<Class<?>>singletonList(OTHER), throwable));
>, <Line: +        verifyNoMoreInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onError(1, Collections.<Class<?>>singletonList(OTHER), throwable, Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.singletonMap(Collections.<Class<?>>singletonList(OTHER), throwable));
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +    public void testRetransformationChunkedOneFailsHandled() throws Exception {
>, <Line: +        when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED, OTHER});
>, <Line: +        when(typeMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
>, <Line: +        when(typeMatcher.matches(new TypeDescription.ForLoadedType(OTHER), OTHER.getClassLoader(), JavaModule.ofType(OTHER), OTHER, OTHER.getProtectionDomain())).thenReturn(true);
>, <Line: +        when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
>, <Line: +        when(instrumentation.isModifiableClass(OTHER)).thenReturn(true);
>, <Line: +        when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
>, <Line: +        Throwable throwable = new RuntimeException();
>, <Line: +        doThrow(throwable).when(instrumentation).retransformClasses(OTHER);
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        doThrow(throwable).when(redefinitionFailureHandler).onFailure(any(Map.class));
>, <Line: +        when(redefinitionFailureHandler.onBatchFailure(any(List.class), any(Throwable.class))).thenReturn(true);
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +        ResettableClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
>, <Line: +                .with(initializationStrategy)
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +                .with(poolStrategy)
>, <Line: +                .with(typeStrategy)
>, <Line: +                .with(installationStrategy)
>, <Line: +                .with(listener)
>, <Line: +                .disableNativeMethodPrefix()
>, <Line: +                .ignore(none())
>, <Line: +                .type(typeMatcher).transform(transformer)
>, <Line: +                .installOn(instrumentation);
>, <Line: +        verifyZeroInteractions(listener);
>, <Line: +        verify(instrumentation).addTransformer(classFileTransformer, true);
>, <Line: +        verify(instrumentation).getAllLoadedClasses();
>, <Line: +        verify(instrumentation).isModifiableClass(REDEFINED);
>, <Line: +        verify(instrumentation).isModifiableClass(OTHER);
>, <Line: +        verify(instrumentation).retransformClasses(REDEFINED);
>, <Line: +        verify(instrumentation).retransformClasses(OTHER);
>, <Line: +        verify(instrumentation).isRetransformClassesSupported();
>, <Line: +        verifyNoMoreInteractions(instrumentation);
>, <Line: +        verify(typeMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
>, <Line: +        verify(typeMatcher).matches(new TypeDescription.ForLoadedType(OTHER), OTHER.getClassLoader(), JavaModule.ofType(OTHER), OTHER, OTHER.getProtectionDomain());
>, <Line: +        verifyNoMoreInteractions(typeMatcher);
>, <Line: +        verifyZeroInteractions(initializationStrategy);
>, <Line: +        verifyZeroInteractions(installationStrategy);
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verify(redefinitionFailureHandler).onBatchFailure(Collections.<Class<?>>singletonList(OTHER), throwable);
>, <Line: +        verifyNoMoreInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.<List<Class<?>>, Throwable>emptyMap());
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +    public void testSkipRedefinitionWithIgnoredTypeChainedDisjunction() throws Exception {
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verifyZeroInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.<List<Class<?>>, Throwable>emptyMap());
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +        Throwable throwable = new RuntimeException();
>, <Line: +        doThrow(throwable).when(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        doThrow(throwable).when(redefinitionFailureHandler).onFailure(any(Map.class));
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +        verify(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(REDEFINED)));
>, <Line: +        verify(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(OTHER)));
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verify(redefinitionFailureHandler).onBatchFailure(Collections.<Class<?>>singletonList(OTHER), throwable);
>, <Line: +        verify(redefinitionFailureHandler).onFailure(Collections.singletonMap(Collections.<Class<?>>singletonList(OTHER), throwable));
>, <Line: +        verifyNoMoreInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onError(1, Collections.<Class<?>>singletonList(OTHER), throwable, Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.singletonMap(Collections.<Class<?>>singletonList(OTHER), throwable));
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +    }
>, <Line: +    @Test
>, <Line: +    @SuppressWarnings("unchecked")
>, <Line: +    public void testRedefinitionChunkedOneFailsHandled() throws Exception {
>, <Line: +        when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED, OTHER});
>, <Line: +        when(typeMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
>, <Line: +        when(typeMatcher.matches(new TypeDescription.ForLoadedType(OTHER), OTHER.getClassLoader(), JavaModule.ofType(OTHER), OTHER, OTHER.getProtectionDomain())).thenReturn(true);
>, <Line: +        when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
>, <Line: +        when(instrumentation.isModifiableClass(OTHER)).thenReturn(true);
>, <Line: +        when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
>, <Line: +        Throwable throwable = new RuntimeException();
>, <Line: +        doThrow(throwable).when(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator = mock(AgentBuilder.RedefinitionStrategy.BatchAllocator.class);
>, <Line: +        when(redefinitionBatchAllocator.batch(Arrays.asList(REDEFINED, OTHER)))
>, <Line: +                .thenReturn((Iterable) Arrays.asList(Collections.singletonList(REDEFINED), Collections.singletonList(OTHER)));
>, <Line: +        AgentBuilder.RedefinitionStrategy.FailureHandler redefinitionFailureHandler = mock(AgentBuilder.RedefinitionStrategy.FailureHandler.class);
>, <Line: +        doThrow(throwable).when(redefinitionFailureHandler).onFailure(any(Map.class));
>, <Line: +        when(redefinitionFailureHandler.onBatchFailure(any(List.class), any(Throwable.class))).thenReturn(true);
>, <Line: +        AgentBuilder.RedefinitionStrategy.Listener redefinitionListener = mock(AgentBuilder.RedefinitionStrategy.Listener.class);
>, <Line: +        ResettableClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
>, <Line: +                .with(initializationStrategy)
>, <Line: +                .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
>, <Line: +                .with(redefinitionBatchAllocator)
>, <Line: +                .with(redefinitionFailureHandler)
>, <Line: +                .with(redefinitionListener)
>, <Line: +                .with(poolStrategy)
>, <Line: +                .with(typeStrategy)
>, <Line: +                .with(installationStrategy)
>, <Line: +                .with(listener)
>, <Line: +                .disableNativeMethodPrefix()
>, <Line: +                .ignore(none())
>, <Line: +                .type(typeMatcher).transform(transformer)
>, <Line: +                .installOn(instrumentation);
>, <Line: +        verifyZeroInteractions(listener);
>, <Line: +        verify(instrumentation).addTransformer(classFileTransformer, false);
>, <Line: +        verify(instrumentation).getAllLoadedClasses();
>, <Line: +        verify(instrumentation).isModifiableClass(REDEFINED);
>, <Line: +        verify(instrumentation).isModifiableClass(OTHER);
>, <Line: +        verify(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(REDEFINED)));
>, <Line: +        verify(instrumentation).redefineClasses(argThat(new ClassRedefinitionMatcher(OTHER)));
>, <Line: +        verify(instrumentation).isRedefineClassesSupported();
>, <Line: +        verifyNoMoreInteractions(instrumentation);
>, <Line: +        verify(typeMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
>, <Line: +        verify(typeMatcher).matches(new TypeDescription.ForLoadedType(OTHER), OTHER.getClassLoader(), JavaModule.ofType(OTHER), OTHER, OTHER.getProtectionDomain());
>, <Line: +        verifyNoMoreInteractions(typeMatcher);
>, <Line: +        verifyZeroInteractions(initializationStrategy);
>, <Line: +        verifyZeroInteractions(installationStrategy);
>, <Line: +        verify(redefinitionBatchAllocator).batch(Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verifyNoMoreInteractions(redefinitionBatchAllocator);
>, <Line: +        verify(redefinitionFailureHandler).onBatchFailure(Collections.<Class<?>>singletonList(OTHER), throwable);
>, <Line: +        verifyNoMoreInteractions(redefinitionFailureHandler);
>, <Line: +        verify(redefinitionListener).onBatch(0, Collections.<Class<?>>singletonList(REDEFINED), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onBatch(1, Collections.<Class<?>>singletonList(OTHER), Arrays.asList(REDEFINED, OTHER));
>, <Line: +        verify(redefinitionListener).onComplete(2, Arrays.asList(REDEFINED, OTHER), Collections.<List<Class<?>>, Throwable>emptyMap());
>, <Line: +        verifyNoMoreInteractions(redefinitionListener);
>, <Line: +        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.FailureCollectingListener.class).apply();
>, <Line: +    private static class ClassRedefinitionMatcher extends BaseMatcher<ClassDefinition> {
>, <Line: +        private final Class<?> type;
>, <Line: +        public ClassRedefinitionMatcher(Class<?> type) {
>, <Line: +            this.type = type;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public boolean matches(Object item) {
>, <Line: +            return ((ClassDefinition) item).getDefinitionClass() == type;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public void describeTo(Description description) {
>, <Line: +            /* empty */
>, <Line: +        }
>, <Line: +    }
>]
[<Line: -                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION_CHUNKED)
>, <Line: -        verify(instrumentation).retransformClasses(REDEFINED);
>, <Line: -        doThrow(new RuntimeException()).when(instrumentation).retransformClasses(OTHER);
>, <Line: -                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION_CHUNKED)
>, <Line: -        verify(instrumentation).retransformClasses(REDEFINED);
>, <Line: -    public void testSkipRedefinitionWithIgnoredTypeChainedDijunction() throws Exception {
>, <Line: -                .with(AgentBuilder.RedefinitionStrategy.REDEFINITION_CHUNKED)
>, <Line: -        doThrow(new RuntimeException()).when(instrumentation).redefineClasses(any(ClassDefinition[].class));
>, <Line: -                .with(AgentBuilder.RedefinitionStrategy.REDEFINITION_CHUNKED)
>, <Line: -        verify(instrumentation, times(2)).redefineClasses(any(ClassDefinition[].class));
>]