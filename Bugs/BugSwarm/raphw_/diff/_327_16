[<Line: +                name = primitiveName == null
>, <Line: +                        ? name.substring(1, name.length() - 1)
>, <Line: +                        : primitiveName;
>, <Line: +            private final Default.LazyTypeDescription.AnnotationToken annotationToken;
>, <Line: +            public RawAnnotationValue(TypePool typePool, Default.LazyTypeDescription.AnnotationToken annotationToken) {
>, <Line: +                return "TypePool.DefaultLazyTypeDescription.AnnotationValue.ForEnumeration{" +
>, <Line: +                return "TypePool.DefaultLazyTypeDescription.AnnotationValue.ForType{" +
>, <Line: +                return "TypePool.DefaultLazyTypeDescription.AnnotationValue.ForComplexArray{" +
>, <Line: +            /**
>, <Line: +             * An abstract base implementation of an annotation registrant.
>, <Line: +             */
>, <Line: +            abstract class AbstractBase implements AnnotationRegistrant {
>, <Line: +                /**
>, <Line: +                 * The annotation descriptor.
>, <Line: +                 */
>, <Line: +                private final String descriptor;
>, <Line: +                /**
>, <Line: +                 * The values that were collected so far.
>, <Line: +                 */
>, <Line: +                private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation registrant.
>, <Line: +                 *
>, <Line: +                 * @param descriptor The annotation descriptor.
>, <Line: +                 */
>, <Line: +                protected AbstractBase(String descriptor) {
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: +                    values.put(name, annotationValue);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onComplete() {
>, <Line: +                    getTokens().add(new LazyTypeDescription.AnnotationToken(descriptor, values));
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Returns the token list for this collector.
>, <Line: +                 *
>, <Line: +                 * @return The token list for this collector.
>, <Line: +                 */
>, <Line: +                protected abstract List<LazyTypeDescription.AnnotationToken> getTokens();
>, <Line: +                /**
>, <Line: +                 * A base implementation for a collector for a type variable.
>, <Line: +                 */
>, <Line: +                protected abstract static class ForTypeVariable extends AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The type variable's type path.
>, <Line: +                     */
>, <Line: +                    private final String typePath;
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation collector.
>, <Line: +                     *
>, <Line: +                     * @param descriptor The annotation descriptor.
>, <Line: +                     * @param typePath   The type variable's type path.
>, <Line: +                     */
>, <Line: +                    protected ForTypeVariable(String descriptor, TypePath typePath) {
>, <Line: +                        super(descriptor);
>, <Line: +                        this.typePath = typePath == null
>, <Line: +                                ? LazyTypeDescription.GenericTypeToken.EMPTY_TYPE_PATH
>, <Line: +                                : typePath.toString();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected List<LazyTypeDescription.AnnotationToken> getTokens() {
>, <Line: +                        Map<String, List<LazyTypeDescription.AnnotationToken>> pathMap = getPathMap();
>, <Line: +                        List<LazyTypeDescription.AnnotationToken> tokens = pathMap.get(typePath);
>, <Line: +                        if (tokens == null) {
>, <Line: +                            tokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: +                            pathMap.put(typePath, tokens);
>, <Line: +                        }
>, <Line: +                        return tokens;
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Returns this collector's path map.
>, <Line: +                     *
>, <Line: +                     * @return This collector's path map.
>, <Line: +                     */
>, <Line: +                    protected abstract Map<String, List<LazyTypeDescription.AnnotationToken>> getPathMap();
>, <Line: +                    /**
>, <Line: +                     * A base implementation for a collector for a type variable with an index.
>, <Line: +                     */
>, <Line: +                    protected abstract static class WithIndex extends AbstractBase.ForTypeVariable {
>, <Line: +                        /**
>, <Line: +                         * The type variable's index.
>, <Line: +                         */
>, <Line: +                        private final int index;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation collector.
>, <Line: +                         *
>, <Line: +                         * @param descriptor The annotation descriptor.
>, <Line: +                         * @param typePath   The type variable's type path.
>, <Line: +                         * @param index      The type variable's index.
>, <Line: +                         */
>, <Line: +                        protected WithIndex(String descriptor, TypePath typePath, int index) {
>, <Line: +                            super(descriptor, typePath);
>, <Line: +                            this.index = index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        protected Map<String, List<LazyTypeDescription.AnnotationToken>> getPathMap() {
>, <Line: +                            Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> indexedPathMap = getIndexedPathMap();
>, <Line: +                            Map<String, List<LazyTypeDescription.AnnotationToken>> pathMap = indexedPathMap.get(index);
>, <Line: +                            if (pathMap == null) {
>, <Line: +                                pathMap = new HashMap<String, List<LazyTypeDescription.AnnotationToken>>();
>, <Line: +                                indexedPathMap.put(index, pathMap);
>, <Line: +                            }
>, <Line: +                            return pathMap;
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns this collector's indexed path map.
>, <Line: +                         *
>, <Line: +                         * @return This collector's indexed path map.
>, <Line: +                         */
>, <Line: +                        protected abstract Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> getIndexedPathMap();
>, <Line: +                        /**
>, <Line: +                         * A base implementation for a collector for a type variable with two indices.
>, <Line: +                         */
>, <Line: +                        protected abstract static class DoubleIndexed extends WithIndex {
>, <Line: +                            /**
>, <Line: +                             * The type variable's first index.
>, <Line: +                             */
>, <Line: +                            private final int preIndex;
>, <Line: +                            /**
>, <Line: +                             * Creates a new annotation collector.
>, <Line: +                             *
>, <Line: +                             * @param descriptor The annotation descriptor.
>, <Line: +                             * @param typePath   The type variable's type path.
>, <Line: +                             * @param index      The type variable's index.
>, <Line: +                             * @param preIndex   The type variable's first index.
>, <Line: +                             */
>, <Line: +                            protected DoubleIndexed(String descriptor, TypePath typePath, int index, int preIndex) {
>, <Line: +                                super(descriptor, typePath, index);
>, <Line: +                                this.preIndex = preIndex;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            protected Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> getIndexedPathMap() {
>, <Line: +                                Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> doubleIndexPathMap = getDoubleIndexedPathMap();
>, <Line: +                                Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> indexedPathMap = doubleIndexPathMap.get(preIndex);
>, <Line: +                                if (indexedPathMap == null) {
>, <Line: +                                    indexedPathMap = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                                    doubleIndexPathMap.put(preIndex, indexedPathMap);
>, <Line: +                                }
>, <Line: +                                return indexedPathMap;
>, <Line: +                            }
>, <Line: +                            /**
>, <Line: +                             * Returns this collector's double indexed path map.
>, <Line: +                             *
>, <Line: +                             * @return This collector's double indexed path map.
>, <Line: +                             */
>, <Line: +                            protected abstract Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> getDoubleIndexedPathMap();
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * An annotation collector for a byte code element.
>, <Line: +             */
>, <Line: +            class ForByteCodeElement extends AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The target collection.
>, <Line: +                 */
>, <Line: +                private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation collector for a byte code element.
>, <Line: +                 *
>, <Line: +                 * @param descriptor       The annotation descriptor.
>, <Line: +                 * @param annotationTokens The target collection.
>, <Line: +                 */
>, <Line: +                protected ForByteCodeElement(String descriptor, List<LazyTypeDescription.AnnotationToken> annotationTokens) {
>, <Line: +                    super(descriptor);
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected List<LazyTypeDescription.AnnotationToken> getTokens() {
>, <Line: +                    return annotationTokens;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypePool.Default.AnnotationRegistrant.ForByteCodeElement{" +
>, <Line: +                            "annotationTokens=" + annotationTokens +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * An annotation collector for a byte code element with an index.
>, <Line: +                 */
>, <Line: +                public static class WithIndex extends AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The byte code element's index.
>, <Line: +                     */
>, <Line: +                    private final int index;
>, <Line: +                    /**
>, <Line: +                     * The target collection.
>, <Line: +                     */
>, <Line: +                    private final Map<Integer, List<LazyTypeDescription.AnnotationToken>> annotationTokens;
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation collector for a byte code element with an index.
>, <Line: +                     *
>, <Line: +                     * @param descriptor       The annotation descriptor.
>, <Line: +                     * @param index            The byte code element's index.
>, <Line: +                     * @param annotationTokens The target collection.
>, <Line: +                     */
>, <Line: +                    protected WithIndex(String descriptor, int index, Map<Integer, List<LazyTypeDescription.AnnotationToken>> annotationTokens) {
>, <Line: +                        super(descriptor);
>, <Line: +                        this.index = index;
>, <Line: +                        this.annotationTokens = annotationTokens;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected List<LazyTypeDescription.AnnotationToken> getTokens() {
>, <Line: +                        List<LazyTypeDescription.AnnotationToken> annotationTokens = this.annotationTokens.get(index);
>, <Line: +                        if (annotationTokens == null) {
>, <Line: +                            annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: +                            this.annotationTokens.put(index, annotationTokens);
>, <Line: +                        }
>, <Line: +                        return annotationTokens;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.AnnotationRegistrant.ForByteCodeElement.WithIndex{" +
>, <Line: +                                "index=" + index +
>, <Line: +                                ", annotationTokens=" + annotationTokens +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * An annotation collector for a type variable.
>, <Line: +             */
>, <Line: +            class ForTypeVariable extends AbstractBase.ForTypeVariable {
>, <Line: +                /**
>, <Line: +                 * The target collection.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<LazyTypeDescription.AnnotationToken>> pathMap;
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation collector.
>, <Line: +                 *
>, <Line: +                 * @param descriptor The annotation descriptor.
>, <Line: +                 * @param typePath   The type variable's type path.
>, <Line: +                 * @param pathMap    The target collection.
>, <Line: +                 */
>, <Line: +                protected ForTypeVariable(String descriptor, TypePath typePath, Map<String, List<LazyTypeDescription.AnnotationToken>> pathMap) {
>, <Line: +                    super(descriptor, typePath);
>, <Line: +                    this.pathMap = pathMap;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Map<String, List<LazyTypeDescription.AnnotationToken>> getPathMap() {
>, <Line: +                    return pathMap;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypePool.Default.AnnotationRegistrant.ForTypeVariable{" +
>, <Line: +                            ", pathMap=" + pathMap +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * An annotation collector for a type variable with an index.
>, <Line: +                 */
>, <Line: +                public static class WithIndex extends AbstractBase.ForTypeVariable.WithIndex {
>, <Line: +                    /**
>, <Line: +                     * The target collection.
>, <Line: +                     */
>, <Line: +                    private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> indexedPathMap;
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation collector.
>, <Line: +                     *
>, <Line: +                     * @param descriptor     The annotation descriptor.
>, <Line: +                     * @param typePath       The type variable's type path.
>, <Line: +                     * @param index          The target index.
>, <Line: +                     * @param indexedPathMap The target collection.
>, <Line: +                     */
>, <Line: +                    protected WithIndex(String descriptor,
>, <Line: +                                        TypePath typePath,
>, <Line: +                                        int index,
>, <Line: +                                        Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> indexedPathMap) {
>, <Line: +                        super(descriptor, typePath, index);
>, <Line: +                        this.indexedPathMap = indexedPathMap;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> getIndexedPathMap() {
>, <Line: +                        return indexedPathMap;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.AnnotationRegistrant.ForTypeVariable.WithIndex{" +
>, <Line: +                                ", indexedPathMap=" + indexedPathMap +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * An annotation collector for a type variable with two indices.
>, <Line: +                     */
>, <Line: +                    public static class DoubleIndexed extends AbstractBase.ForTypeVariable.WithIndex.DoubleIndexed {
>, <Line: +                        /**
>, <Line: +                         * The target collection.
>, <Line: +                         */
>, <Line: +                        private final Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> doubleIndexedPathMap;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation collector.
>, <Line: +                         *
>, <Line: +                         * @param descriptor           The annotation descriptor.
>, <Line: +                         * @param typePath             The type variable's type path.
>, <Line: +                         * @param index                The target index.
>, <Line: +                         * @param preIndex             The initial target index.
>, <Line: +                         * @param doubleIndexedPathMap The target collection.
>, <Line: +                         */
>, <Line: +                        protected DoubleIndexed(String descriptor,
>, <Line: +                                                TypePath typePath,
>, <Line: +                                                int index,
>, <Line: +                                                int preIndex,
>, <Line: +                                                Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> doubleIndexedPathMap) {
>, <Line: +                            super(descriptor, typePath, index, preIndex);
>, <Line: +                            this.doubleIndexedPathMap = doubleIndexedPathMap;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        protected Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> getDoubleIndexedPathMap() {
>, <Line: +                            return doubleIndexedPathMap;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed{" +
>, <Line: +                                    ", doubleIndexedPathMap=" + doubleIndexedPathMap +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +             * An incomplete {@link LazyTypeDescription.GenericTypeToken}.
>, <Line: +                protected final List<LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable> typeVariableTokens;
>, <Line: +                    typeVariableTokens = new ArrayList<LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable>();
>, <Line: +         * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
>, <Line: +         * {@link AnnotationDescription} by querying a type pool at lookup time.
>, <Line: +        public static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
>, <Line: +             * The index of a super type's type annotations.
>, <Line: +            private static final int SUPER_TYPE_INDEX = -1;
>, <Line: +             * Indicates that a type does not define a super type.
>, <Line: +            private static final String NO_SUPER_TYPE = null;
>, <Line: +             * The type pool to be used for looking up linked types.
>, <Line: +            private final TypePool typePool;
>, <Line: +             * The modifiers of this type.
>, <Line: +            private final int modifiers;
>, <Line: +             * The binary name of this type.
>, <Line: +            private final String name;
>, <Line: +             * The type's super type's descriptor or {@code null} if this type does not define a super type.
>, <Line: +            private final String superTypeDescriptor;
>, <Line: +             * The resolution of this type's generic type.
>, <Line: +            private final GenericTypeToken.Resolution.ForType signatureResolution;
>, <Line: +             * The descriptor of this type's interfaces.
>, <Line: +            private final List<String> interfaceTypeDescriptors;
>, <Line: +             * The declaration context of this type.
>, <Line: +            private final DeclarationContext declarationContext;
>, <Line: +             * A list of descriptors representing the types that are declared by this type.
>, <Line: +            private final List<String> declaredTypes;
>, <Line: +             * {@code true} if this type is an anonymous type.
>, <Line: +            private final boolean anonymousType;
>, <Line: +             * A mapping of type annotations for this type's super type and interface types by their indices.
>, <Line: +            private final Map<Integer, Map<String, List<AnnotationToken>>> superTypeAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A mapping of type annotations of the type variables' type annotations by their indices.
>, <Line: +             */
>, <Line: +            private final Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A mapping of type annotations of the type variables' bounds' type annotations by their indices and each variable's index.
>, <Line: +             */
>, <Line: +            private final Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundsAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A list of tokens that represent the annotations of this type.
>, <Line: +             */
>, <Line: +            private final List<AnnotationToken> annotationTokens;
>, <Line: +            /**
>, <Line: +             * A list of field tokens describing the field's of this type.
>, <Line: +             */
>, <Line: +            private final List<FieldToken> fieldTokens;
>, <Line: +            /**
>, <Line: +             * A list of method tokens describing the method's of this type.
>, <Line: +             */
>, <Line: +            private final List<MethodToken> methodTokens;
>, <Line: +            /**
>, <Line: +             * Creates a new lazy type description.
>, <Line: +             *
>, <Line: +             * @param typePool                           The type pool to be used for looking up linked types.
>, <Line: +             * @param modifiers                          The modifiers of this type.
>, <Line: +             * @param name                               The binary name of this type.
>, <Line: +             * @param superTypeInternalName              The internal name of this type's super type or {@code null} if no such super type is defined.
>, <Line: +             * @param interfaceInternalName              An array of this type's interfaces or {@code null} if this type does not define any interfaces.
>, <Line: +             * @param signatureResolution                The resolution of this type's generic types.
>, <Line: +             * @param declarationContext                 The declaration context of this type.
>, <Line: +             * @param declaredTypes                      A list of descriptors representing the types that are declared by this type.
>, <Line: +             * @param anonymousType                      {@code true} if this type is an anonymous type.
>, <Line: +             * @param superTypeAnnotationTokens          A mapping of type annotations for this type's super type and interface types by their indices.
>, <Line: +             * @param typeVariableAnnotationTokens       A mapping of type annotations of the type variables' type annotations by their indices.
>, <Line: +             * @param typeVariableBoundsAnnotationTokens A mapping of type annotations of the type variables' bounds' type annotations by their indices
>, <Line: +             *                                           and each variable's index.
>, <Line: +             * @param annotationTokens                   A list of tokens that represent the annotations of this type.
>, <Line: +             * @param fieldTokens                        A list of field tokens describing the field's of this type.
>, <Line: +             * @param methodTokens                       A list of method tokens describing the method's of this type.
>, <Line: +             */
>, <Line: +            protected LazyTypeDescription(TypePool typePool,
>, <Line: +                                          int modifiers,
>, <Line: +                                          String name,
>, <Line: +                                          String superTypeInternalName,
>, <Line: +                                          String[] interfaceInternalName,
>, <Line: +                                          GenericTypeToken.Resolution.ForType signatureResolution,
>, <Line: +                                          DeclarationContext declarationContext,
>, <Line: +                                          List<String> declaredTypes,
>, <Line: +                                          boolean anonymousType,
>, <Line: +                                          Map<Integer, Map<String, List<AnnotationToken>>> superTypeAnnotationTokens,
>, <Line: +                                          Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens,
>, <Line: +                                          Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundsAnnotationTokens,
>, <Line: +                                          List<AnnotationToken> annotationTokens,
>, <Line: +                                          List<FieldToken> fieldTokens,
>, <Line: +                                          List<MethodToken> methodTokens) {
>, <Line: +                this.typePool = typePool;
>, <Line: +                this.modifiers = modifiers & ~Opcodes.ACC_SUPER;
>, <Line: +                this.name = Type.getObjectType(name).getClassName();
>, <Line: +                this.superTypeDescriptor = superTypeInternalName == null
>, <Line: +                        ? NO_SUPER_TYPE
>, <Line: +                        : Type.getObjectType(superTypeInternalName).getDescriptor();
>, <Line: +                this.signatureResolution = signatureResolution;
>, <Line: +                if (interfaceInternalName == null) {
>, <Line: +                    interfaceTypeDescriptors = Collections.emptyList();
>, <Line: +                } else {
>, <Line: +                    interfaceTypeDescriptors = new ArrayList<String>(interfaceInternalName.length);
>, <Line: +                    for (String internalName : interfaceInternalName) {
>, <Line: +                        interfaceTypeDescriptors.add(Type.getObjectType(internalName).getDescriptor());
>, <Line: +                this.declarationContext = declarationContext;
>, <Line: +                this.declaredTypes = declaredTypes;
>, <Line: +                this.anonymousType = anonymousType;
>, <Line: +                this.superTypeAnnotationTokens = superTypeAnnotationTokens;
>, <Line: +                this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
>, <Line: +                this.typeVariableBoundsAnnotationTokens = typeVariableBoundsAnnotationTokens;
>, <Line: +                this.annotationTokens = annotationTokens;
>, <Line: +                this.fieldTokens = fieldTokens;
>, <Line: +                this.methodTokens = methodTokens;
>, <Line: +            public Generic getSuperType() {
>, <Line: +                return superTypeDescriptor == null || isInterface()
>, <Line: +                        ? Generic.UNDEFINED
>, <Line: +                        : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, superTypeAnnotationTokens.get(SUPER_TYPE_INDEX), this);
>, <Line: +            public TypeList.Generic getInterfaces() {
>, <Line: +                return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, superTypeAnnotationTokens, this);
>, <Line: +            public MethodDescription getEnclosingMethod() {
>, <Line: +                return declarationContext.getEnclosingMethod(typePool);
>, <Line: +            @Override
>, <Line: +            public TypeDescription getEnclosingType() {
>, <Line: +                return declarationContext.getEnclosingType(typePool);
>, <Line: +            public TypeList getDeclaredTypes() {
>, <Line: +                return new LazyTypeList(typePool, declaredTypes);
>, <Line: +            @Override
>, <Line: +            public boolean isAnonymousClass() {
>, <Line: +                return anonymousType;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean isLocalClass() {
>, <Line: +                return !anonymousType && declarationContext.isDeclaredInMethod();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean isMemberClass() {
>, <Line: +                return declarationContext.isDeclaredInType();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
>, <Line: +                return new FieldTokenList();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
>, <Line: +                return new MethodTokenList();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public PackageDescription getPackage() {
>, <Line: +                String name = getName();
>, <Line: +                int index = name.lastIndexOf('.');
>, <Line: +                return index == -1
>, <Line: +                        ? PackageDescription.UNDEFINED
>, <Line: +                        : new LazyPackageDescription(typePool, name.substring(0, index));
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String getName() {
>, <Line: +                return name;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeDescription getDeclaringType() {
>, <Line: +                return declarationContext.isDeclaredInType()
>, <Line: +                        ? declarationContext.getEnclosingType(typePool)
>, <Line: +                        : TypeDescription.UNDEFINED;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public int getModifiers() {
>, <Line: +                return modifiers;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public AnnotationList getDeclaredAnnotations() {
>, <Line: +                return LazyAnnotationDescription.asList(typePool, annotationTokens);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeList.Generic getTypeVariables() {
>, <Line: +                return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundsAnnotationTokens);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A list of field tokens representing each entry as a field description.
>, <Line: +             */
>, <Line: +            protected class FieldTokenList extends FieldList.AbstractBase<FieldDescription.InDefinedShape> {
>, <Line: +                @Override
>, <Line: +                public FieldDescription.InDefinedShape get(int index) {
>, <Line: +                    return fieldTokens.get(index).toFieldDescription(LazyTypeDescription.this);
>, <Line: +                public int size() {
>, <Line: +                    return fieldTokens.size();
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A list of method tokens representing each entry as a method description.
>, <Line: +             */
>, <Line: +            protected class MethodTokenList extends MethodList.AbstractBase<MethodDescription.InDefinedShape> {
>, <Line: +                public MethodDescription.InDefinedShape get(int index) {
>, <Line: +                    return methodTokens.get(index).toMethodDescription(LazyTypeDescription.this);
>, <Line: +                public int size() {
>, <Line: +                    return methodTokens.size();
>, <Line: +             * A declaration context encapsulates information about whether a type was declared within another type
>, <Line: +             * or within a method of another type.
>, <Line: +            protected interface DeclarationContext {
>, <Line: +                 * Returns the enclosing method or {@code null} if no such method exists.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to be used for looking up linked types.
>, <Line: +                 * @return A method description describing the linked type or {@code null}.
>, <Line: +                MethodDescription getEnclosingMethod(TypePool typePool);
>, <Line: +                 * Returns the enclosing type or {@code null} if no such type exists.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to be used for looking up linked types.
>, <Line: +                 * @return A type description describing the linked type or {@code null}.
>, <Line: +                TypeDescription getEnclosingType(TypePool typePool);
>, <Line: +                 * Returns {@code true} if this instance represents a self declared type.
>, <Line: +                 * @return {@code true} if this instance represents a self declared type.
>, <Line: +                boolean isSelfDeclared();
>, <Line: +                /**
>, <Line: +                 * Returns {@code true} if this instance represents a type that was declared within another type but not
>, <Line: +                 * within a method.
>, <Line: +                 *
>, <Line: +                 * @return {@code true} if this instance represents a type that was declared within another type but not
>, <Line: +                 * within a method.
>, <Line: +                 */
>, <Line: +                boolean isDeclaredInType();
>, <Line: +                /**
>, <Line: +                 * Returns {@code true} if this instance represents a type that was declared within a method.
>, <Line: +                 *
>, <Line: +                 * @return {@code true} if this instance represents a type that was declared within a method.
>, <Line: +                 */
>, <Line: +                boolean isDeclaredInMethod();
>, <Line: +                 * Represents a self-declared type that is not defined within another type.
>, <Line: +                enum SelfDeclared implements DeclarationContext {
>, <Line: +                     * The singleton instance.
>, <Line: +                    INSTANCE;
>, <Line: +                    @Override
>, <Line: +                    public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: +                        return MethodDescription.UNDEFINED;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: +                        return TypeDescription.UNDEFINED;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isSelfDeclared() {
>, <Line: +                        return true;
>, <Line: +                    public boolean isDeclaredInType() {
>, <Line: +                        return false;
>, <Line: +                    public boolean isDeclaredInMethod() {
>, <Line: +                        return false;
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.DeclarationContext.SelfDeclared." + name();
>, <Line: +                 * A declaration context representing a type that is declared within another type but not within
>, <Line: +                 * a method.
>, <Line: +                class DeclaredInType implements DeclarationContext {
>, <Line: +                     * The binary name of the referenced type.
>, <Line: +                     * Creates a new declaration context for a type that is declared within another type.
>, <Line: +                     * @param internalName The internal name of the declaring type.
>, <Line: +                    public DeclaredInType(String internalName) {
>, <Line: +                        name = internalName.replace('/', '.');
>, <Line: +                    public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: +                        return MethodDescription.UNDEFINED;
>, <Line: +                    public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: +                        return typePool.describe(name).resolve();
>, <Line: +                    public boolean isSelfDeclared() {
>, <Line: +                        return false;
>, <Line: +                    @Override
>, <Line: +                    public boolean isDeclaredInType() {
>, <Line: +                        return true;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isDeclaredInMethod() {
>, <Line: +                        return false;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && name.equals(((DeclaredInType) other).name);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return name.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.DeclarationContext.DeclaredInType{" +
>, <Line: +                                "name='" + name + '\'' +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                 * A declaration context representing a type that is declared within a method of another type.
>, <Line: +                class DeclaredInMethod implements DeclarationContext {
>, <Line: +                     * The binary name of the declaring type.
>, <Line: +                    private final String name;
>, <Line: +                     * The name of the method that is declaring a type.
>, <Line: +                    private final String methodName;
>, <Line: +                    /**
>, <Line: +                     * The descriptor of the method that is declaring a type.
>, <Line: +                     */
>, <Line: +                    private final String methodDescriptor;
>, <Line: +                     * Creates a new declaration context for a method that declares a type.
>, <Line: +                     * @param internalName     The internal name of the declaring type.
>, <Line: +                     * @param methodName       The name of the method that is declaring a type.
>, <Line: +                     * @param methodDescriptor The descriptor of the method that is declaring a type.
>, <Line: +                    public DeclaredInMethod(String internalName, String methodName, String methodDescriptor) {
>, <Line: +                        name = internalName.replace('/', '.');
>, <Line: +                        this.methodName = methodName;
>, <Line: +                        this.methodDescriptor = methodDescriptor;
>, <Line: +                    public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: +                        return getEnclosingType(typePool).getDeclaredMethods().filter(hasMethodName(methodName).and(hasDescriptor(methodDescriptor))).getOnly();
>, <Line: +                    public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: +                        return typePool.describe(name).resolve();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isSelfDeclared() {
>, <Line: +                        return false;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isDeclaredInType() {
>, <Line: +                        return false;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isDeclaredInMethod() {
>, <Line: +                        return true;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        if (this == other) return true;
>, <Line: +                        if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                        DeclaredInMethod that = (DeclaredInMethod) other;
>, <Line: +                        return methodDescriptor.equals(that.methodDescriptor)
>, <Line: +                                && methodName.equals(that.methodName)
>, <Line: +                                && name.equals(that.name);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = name.hashCode();
>, <Line: +                        result = 31 * result + methodName.hashCode();
>, <Line: +                        result = 31 * result + methodDescriptor.hashCode();
>, <Line: +                        return result;
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.DeclarationContext.DeclaredInMethod{" +
>, <Line: +                                "name='" + name + '\'' +
>, <Line: +                                ", methodName='" + methodName + '\'' +
>, <Line: +                                ", methodDescriptor='" + methodDescriptor + '\'' +
>, <Line: +             * A token that represents a generic Java type.
>, <Line: +            protected interface GenericTypeToken {
>, <Line: +                 * Represents an empty type path.
>, <Line: +                String EMPTY_TYPE_PATH = "";
>, <Line: +                 * Represents a step to a component type within a type path.
>, <Line: +                char COMPONENT_TYPE_PATH = '[';
>, <Line: +                 * Represents a wildcard type step within a type path.
>, <Line: +                char WILDCARD_TYPE_PATH = '*';
>, <Line: +                 * Represents a owner type step within a type path.
>, <Line: +                char OWNER_TYPE_PATH = '.';
>, <Line: +                 * Represents an index tzpe delimiter within a type path.
>, <Line: +                char INDEXED_TYPE_DELIMITER = ';';
>, <Line: +                 * Transforms this token into a generic type representation.
>, <Line: +                 *
>, <Line: +                 * @param typePool           The type pool to be used for locating non-generic type descriptions.
>, <Line: +                 * @param typeVariableSource The type variable source.
>, <Line: +                 * @param typePath           The type path of the resolved generic type.
>, <Line: +                 * @param annotationTokens   A mapping of the type's annotation tokens by their type path.
>, <Line: +                 * @return A description of the represented generic type.
>, <Line: +                Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map<String, List<AnnotationToken>> annotationTokens);
>, <Line: +                 * Determines if a generic type tokens represents a primary bound of a type variable. This method must only be invoked on types
>, <Line: +                 * that represent a {@link Sort#NON_GENERIC},
>, <Line: +                 * {@link Sort#PARAMETERIZED} or {@link Sort#VARIABLE}.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to use.
>, <Line: +                 * @return {@code true} if this token represents a primary bound.
>, <Line: +                boolean isPrimaryBound(TypePool typePool);
>, <Line: +                 * Represents a generic type token for a formal type variable.
>, <Line: +                interface OfFormalTypeVariable {
>, <Line: +                    /**
>, <Line: +                     * Transforms this token into a generic type representation.
>, <Line: +                     *
>, <Line: +                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: +                     * @param typeVariableSource       The type variable source.
>, <Line: +                     * @param annotationTokens         A mapping of the type variables' type annotations.
>, <Line: +                     * @param boundaryAnnotationTokens A mapping of the type variables' bounds' type annotation by their bound index.
>, <Line: +                     * @return A generic type representation of this formal type variable.
>, <Line: +                     */
>, <Line: +                    Generic toGenericType(TypePool typePool,
>, <Line: +                                          TypeVariableSource typeVariableSource,
>, <Line: +                                          Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                          Map<Integer, Map<String, List<AnnotationToken>>> boundaryAnnotationTokens);
>, <Line: +                }
>, <Line: +                 * A generic type token that represents a primitive type.
>, <Line: +                enum ForPrimitiveType implements GenericTypeToken {
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code boolean} type.
>, <Line: +                     */
>, <Line: +                    BOOLEAN(boolean.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code byte} type.
>, <Line: +                     */
>, <Line: +                    BYTE(byte.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code short} type.
>, <Line: +                     */
>, <Line: +                    SHORT(short.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code char} type.
>, <Line: +                     */
>, <Line: +                    CHAR(char.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code int} type.
>, <Line: +                     */
>, <Line: +                    INTEGER(int.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code long} type.
>, <Line: +                     */
>, <Line: +                    LONG(long.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code float} type.
>, <Line: +                     */
>, <Line: +                    FLOAT(float.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code double} type.
>, <Line: +                     */
>, <Line: +                    DOUBLE(double.class),
>, <Line: +                    /**
>, <Line: +                     * The generic type token describing the {@code void} type.
>, <Line: +                     */
>, <Line: +                    VOID(void.class);
>, <Line: +                    /**
>, <Line: +                     * A description of this primitive type token.
>, <Line: +                     */
>, <Line: +                    private final TypeDescription typeDescription;
>, <Line: +                     * Creates a new primitive type token.
>, <Line: +                     *
>, <Line: +                     * @param type The loaded type representing this primitive.
>, <Line: +                    ForPrimitiveType(Class<?> type) {
>, <Line: +                        typeDescription = new ForLoadedType(type);
>, <Line: +                    }
>, <Line: +                     * Resolves a generic type token of a primitive type.
>, <Line: +                     * @param descriptor The descriptor of the primitive type.
>, <Line: +                     * @return The corresponding generic type token.
>, <Line: +                    public static GenericTypeToken of(char descriptor) {
>, <Line: +                        switch (descriptor) {
>, <Line: +                            case 'V':
>, <Line: +                                return VOID;
>, <Line: +                            case 'Z':
>, <Line: +                                return BOOLEAN;
>, <Line: +                            case 'B':
>, <Line: +                                return BYTE;
>, <Line: +                            case 'S':
>, <Line: +                                return SHORT;
>, <Line: +                            case 'C':
>, <Line: +                                return CHAR;
>, <Line: +                            case 'I':
>, <Line: +                                return INTEGER;
>, <Line: +                            case 'J':
>, <Line: +                                return LONG;
>, <Line: +                            case 'F':
>, <Line: +                                return FLOAT;
>, <Line: +                            case 'D':
>, <Line: +                                return DOUBLE;
>, <Line: +                            default:
>, <Line: +                                throw new IllegalArgumentException("Not a valid primitive type descriptor: " + descriptor);
>, <Line: +                        }
>, <Line: +                    public Generic toGenericType(TypePool typePool,
>, <Line: +                                                 TypeVariableSource typeVariableSource,
>, <Line: +                                                 String typePath,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyPrimitiveType(typePool,
>, <Line: +                                typePath,
>, <Line: +                                annotationTokens == null
>, <Line: +                                        ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                        : annotationTokens,
>, <Line: +                                typeDescription);
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        throw new IllegalStateException("A primitive type cannot be a type variable bound: " + this);
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForPrimitiveType." + name();
>, <Line: +                     * A representation of a lazy primitive type.
>, <Line: +                    protected static class LazyPrimitiveType extends Generic.OfNonGenericType {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * This type's type annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * The represented type's description.
>, <Line: +                         */
>, <Line: +                        private final TypeDescription typeDescription;
>, <Line: +                        /**
>, <Line: +                         * Creates a new lazy primitive type.
>, <Line: +                         *
>, <Line: +                         * @param typePool         The type pool to use.
>, <Line: +                         * @param typePath         This type's type path.
>, <Line: +                         * @param annotationTokens This type's type annotation tokens.
>, <Line: +                         * @param typeDescription  The represented type's description.
>, <Line: +                         */
>, <Line: +                        protected LazyPrimitiveType(TypePool typePool,
>, <Line: +                                                    String typePath,
>, <Line: +                                                    Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                    TypeDescription typeDescription) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.typeDescription = typeDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeDescription asErasure() {
>, <Line: +                            return typeDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic getComponentType() {
>, <Line: +                            return UNDEFINED;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A generic type token that represents an unbound wildcard.
>, <Line: +                 */
>, <Line: +                enum ForUnboundWildcard implements GenericTypeToken {
>, <Line: +                     * The singleton instance.
>, <Line: +                    INSTANCE;
>, <Line: +                    public Generic toGenericType(TypePool typePool,
>, <Line: +                                                 TypeVariableSource typeVariableSource,
>, <Line: +                                                 String typePath,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyUnboundWildcard(typePool,
>, <Line: +                                typePath,
>, <Line: +                                annotationTokens == null
>, <Line: +                                        ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                        : annotationTokens);
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        throw new IllegalStateException("A wildcard type cannot be a type variable bound: " + this);
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForUnboundWildcard." + name();
>, <Line: +                    /**
>, <Line: +                     * A generic type representation of a generic unbound wildcard.
>, <Line: +                     */
>, <Line: +                    protected static class LazyUnboundWildcard extends Generic.OfWildcardType {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * The type's type annotations.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * Creates a new lazy unbound wildcard.
>, <Line: +                         *
>, <Line: +                         * @param typePool         The type pool to use.
>, <Line: +                         * @param typePath         This type's type path.
>, <Line: +                         * @param annotationTokens The type's type annotations.
>, <Line: +                         */
>, <Line: +                        protected LazyUnboundWildcard(TypePool typePool, String typePath, Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            return new TypeList.Generic.Explicit(Generic.OBJECT);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getLowerBounds() {
>, <Line: +                            return new TypeList.Generic.Empty();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A resolution of a type's, method's or field's generic types.
>, <Line: +                 */
>, <Line: +                interface Resolution {
>, <Line: +                    /**
>, <Line: +                     * Resolves the type variables of the represented element.
>, <Line: +                     *
>, <Line: +                     * @param typePool              The type pool to be used for locating non-generic type descriptions.
>, <Line: +                     * @param typeVariableSource    The type variable source to use for resolving type variables.
>, <Line: +                     * @param annotationTokens      A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                     * @param boundAnnotationTokens A mapping of the type variables' bounds' type annotation tokens by their indices
>, <Line: +                     *                              and each type variable's index.
>, <Line: +                     * @return A list describing the resolved generic types.
>, <Line: +                     */
>, <Line: +                    TypeList.Generic resolveTypeVariables(TypePool typePool,
>, <Line: +                                                          TypeVariableSource typeVariableSource,
>, <Line: +                                                          Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                          Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens);
>, <Line: +                    /**
>, <Line: +                     * A resolution of a type's, method's or field's generic types if all of the represented element's are raw.
>, <Line: +                     */
>, <Line: +                    enum Raw implements ForType, ForMethod, ForField {
>, <Line: +                        /**
>, <Line: +                         * The singleton instance.
>, <Line: +                         */
>, <Line: +                        INSTANCE;
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveFieldType(String fieldTypeDescriptor,
>, <Line: +                                                        TypePool typePool,
>, <Line: +                                                        Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                        FieldDescription.InDefinedShape definingField) {
>, <Line: +                            return RawAnnotatedType.of(typePool, annotationTokens, fieldTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveReturnType(String returnTypeDescriptor,
>, <Line: +                                                         TypePool typePool,
>, <Line: +                                                         Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                         MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return RawAnnotatedType.of(typePool, annotationTokens, returnTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, parameterTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, exceptionTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveSuperType(String superTypeDescriptor,
>, <Line: +                                                        TypePool typePool,
>, <Line: +                                                        Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                        TypeDescription definingType) {
>, <Line: +                            return RawAnnotatedType.of(typePool, annotationTokens, superTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      TypeDescription definingType) {
>, <Line: +                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, interfaceTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
>, <Line: +                                                                     TypeVariableSource typeVariableSource,
>, <Line: +                                                                     Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                     Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens) {
>, <Line: +                            return new TypeList.Generic.Empty();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw." + name();
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Represents a non-generic type that defines type annotations.
>, <Line: +                         */
>, <Line: +                        protected static class RawAnnotatedType extends Generic.OfNonGenericType {
>, <Line: +                            /**
>, <Line: +                             * The type pool to use.
>, <Line: +                             */
>, <Line: +                            private final TypePool typePool;
>, <Line: +                            /**
>, <Line: +                             * The type's type path.
>, <Line: +                             */
>, <Line: +                            private final String typePath;
>, <Line: +                            /**
>, <Line: +                             * A mapping of this type's type annotations.
>, <Line: +                             */
>, <Line: +                            private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                            /**
>, <Line: +                             * The represented non-generic type.
>, <Line: +                             */
>, <Line: +                            private final TypeDescription typeDescription;
>, <Line: +                            /**
>, <Line: +                             * Creates a new raw annotated type.
>, <Line: +                             *
>, <Line: +                             * @param typePool         The type pool to use.
>, <Line: +                             * @param typePath         The type's type path.
>, <Line: +                             * @param annotationTokens A mapping of this type's type annotations.
>, <Line: +                             * @param typeDescription  The represented non-generic type.
>, <Line: +                             */
>, <Line: +                            protected RawAnnotatedType(TypePool typePool,
>, <Line: +                                                       String typePath,
>, <Line: +                                                       Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                       TypeDescription typeDescription) {
>, <Line: +                                this.typePool = typePool;
>, <Line: +                                this.typePath = typePath;
>, <Line: +                                this.annotationTokens = annotationTokens;
>, <Line: +                                this.typeDescription = typeDescription;
>, <Line: +                            }
>, <Line: +                            /**
>, <Line: +                             * Creates a new raw annotated type.
>, <Line: +                             *
>, <Line: +                             * @param typePool         The type pool to use.
>, <Line: +                             * @param annotationTokens A mapping of this type's type annotations.
>, <Line: +                             * @param descriptor       The descriptor of the represented non-generic type.
>, <Line: +                             * @return An annotated non-generic type.
>, <Line: +                             */
>, <Line: +                            protected static Generic of(TypePool typePool, Map<String, List<AnnotationToken>> annotationTokens, String descriptor) {
>, <Line: +                                return new RawAnnotatedType(typePool,
>, <Line: +                                        EMPTY_TYPE_PATH,
>, <Line: +                                        annotationTokens == null
>, <Line: +                                                ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                                : annotationTokens,
>, <Line: +                                        TokenizedGenericType.toErasure(typePool, descriptor));
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeDescription asErasure() {
>, <Line: +                                return typeDescription;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public Generic getComponentType() {
>, <Line: +                                TypeDescription componentType = typeDescription.getComponentType();
>, <Line: +                                return componentType == null
>, <Line: +                                        ? UNDEFINED
>, <Line: +                                        : new RawAnnotatedType(typePool, typePath + COMPONENT_TYPE_PATH, annotationTokens, componentType);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public AnnotationList getDeclaredAnnotations() {
>, <Line: +                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                            }
>, <Line: +                            /**
>, <Line: +                             * A generic type list representing raw types.
>, <Line: +                             */
>, <Line: +                            protected static class LazyRawAnnotatedTypeList extends TypeList.Generic.AbstractBase {
>, <Line: +                                /**
>, <Line: +                                 * The type pool to use for locating types.
>, <Line: +                                 */
>, <Line: +                                private final TypePool typePool;
>, <Line: +                                /**
>, <Line: +                                 * A mapping of the represented types' type annotation tokens by their indices.
>, <Line: +                                 */
>, <Line: +                                private final Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens;
>, <Line: +                                /**
>, <Line: +                                 * A list of type descriptors that this list represents.
>, <Line: +                                 */
>, <Line: +                                private final List<String> descriptors;
>, <Line: +                                /**
>, <Line: +                                 * Creates a generic type list only representing raw types.
>, <Line: +                                 *
>, <Line: +                                 * @param typePool         The type pool to use for locating types.
>, <Line: +                                 * @param annotationTokens A mapping of the represented types' type annotation tokens by their indices.
>, <Line: +                                 * @param descriptors      A list of type descriptors that this list represents.
>, <Line: +                                 */
>, <Line: +                                protected LazyRawAnnotatedTypeList(TypePool typePool,
>, <Line: +                                                                   Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                   List<String> descriptors) {
>, <Line: +                                    this.typePool = typePool;
>, <Line: +                                    this.annotationTokens = annotationTokens;
>, <Line: +                                    this.descriptors = descriptors;
>, <Line: +                                }
>, <Line: +                                /**
>, <Line: +                                 * Creates generic type list only representing raw types.
>, <Line: +                                 *
>, <Line: +                                 * @param typePool         The type pool to use for locating types.
>, <Line: +                                 * @param annotationTokens A mapping of the represented types' type annotation tokens by their indices or
>, <Line: +                                 *                         {@code null} if no type annotations are defined for any type.
>, <Line: +                                 * @param descriptors      A list of type descriptors that this list represents.
>, <Line: +                                 * @return A generic type list representing the raw types this list represents.
>, <Line: +                                 */
>, <Line: +                                protected static TypeList.Generic of(TypePool typePool,
>, <Line: +                                                                     Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                     List<String> descriptors) {
>, <Line: +                                    return new LazyRawAnnotatedTypeList(typePool,
>, <Line: +                                            annotationTokens == null
>, <Line: +                                                    ? Collections.<Integer, Map<String, List<AnnotationToken>>>emptyMap()
>, <Line: +                                                    : annotationTokens,
>, <Line: +                                            descriptors);
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public Generic get(int index) {
>, <Line: +                                    return RawAnnotatedType.of(typePool, annotationTokens.get(index), descriptors.get(index));
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public int size() {
>, <Line: +                                    return descriptors.size();
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public TypeList asErasures() {
>, <Line: +                                    return new LazyTypeList(typePool, descriptors);
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public TypeList.Generic asRawTypes() {
>, <Line: +                                    return this;
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public int getStackSize() {
>, <Line: +                                    int stackSize = 0;
>, <Line: +                                    for (String descriptor : descriptors) {
>, <Line: +                                        stackSize += Type.getType(descriptor).getSize();
>, <Line: +                                    }
>, <Line: +                                    return stackSize;
>, <Line: +                                }
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A resolution of a type's, method's or field's generic types if its generic signature is malformed.
>, <Line: +                     */
>, <Line: +                    enum Malformed implements ForType, ForMethod, ForField {
>, <Line: +                        /**
>, <Line: +                         * The singleton instance.
>, <Line: +                         */
>, <Line: +                        INSTANCE;
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveFieldType(String fieldTypeDescriptor,
>, <Line: +                                                        TypePool typePool,
>, <Line: +                                                        Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                        FieldDescription.InDefinedShape definingField) {
>, <Line: +                            return new TokenizedGenericType.Malformed(typePool, fieldTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveReturnType(String returnTypeDescriptor,
>, <Line: +                                                         TypePool typePool,
>, <Line: +                                                         Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                         MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return new TokenizedGenericType.Malformed(typePool, returnTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return new TokenizedGenericType.Malformed.TokenList(typePool, parameterTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                            return new TokenizedGenericType.Malformed.TokenList(typePool, exceptionTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic resolveSuperType(String superTypeDescriptor,
>, <Line: +                                                        TypePool typePool,
>, <Line: +                                                        Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                        TypeDescription definingType) {
>, <Line: +                            return new TokenizedGenericType.Malformed(typePool, superTypeDescriptor);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors,
>, <Line: +                                                                      TypePool typePool,
>, <Line: +                                                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                      TypeDescription definingType) {
>, <Line: +                            return new TokenizedGenericType.Malformed.TokenList(typePool, interfaceTypeDescriptors);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
>, <Line: +                                                                     TypeVariableSource typeVariableSource,
>, <Line: +                                                                     Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                     Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens) {
>, <Line: +                            throw new GenericSignatureFormatError();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Malformed." + name();
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A resolution of the generic types of a {@link TypeDescription}.
>, <Line: +                     */
>, <Line: +                    interface ForType extends Resolution {
>, <Line: +                        /**
>, <Line: +                         * Resolves the generic super type of the represented type.
>, <Line: +                         *
>, <Line: +                         * @param superTypeDescriptor The descriptor of the raw super type.
>, <Line: +                         * @param typePool            The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param annotationTokens    A mapping of the super type's type annotation tokens.
>, <Line: +                         * @param definingType        The type that defines this super type.
>, <Line: +                         * @return A description of this type's generic super type.
>, <Line: +                         */
>, <Line: +                        Generic resolveSuperType(String superTypeDescriptor,
>, <Line: +                                                 TypePool typePool,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                 TypeDescription definingType);
>, <Line: +                        /**
>, <Line: +                         * Resolves the generic interface types of the represented type.
>, <Line: +                         *
>, <Line: +                         * @param interfaceTypeDescriptors The descriptor of the raw interface types.
>, <Line: +                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param annotationTokens         A mapping of the interface types' type annotation tokens by their indices.
>, <Line: +                         * @param definingType             The type that defines these interface type.
>, <Line: +                         * @return A description of this type's generic interface types.
>, <Line: +                         */
>, <Line: +                        TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors,
>, <Line: +                                                               TypePool typePool,
>, <Line: +                                                               Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                               TypeDescription definingType);
>, <Line: +                        /**
>, <Line: +                         * An implementation of a tokenized resolution of generic types of a {@link TypeDescription}.
>, <Line: +                         */
>, <Line: +                        class Tokenized implements ForType {
>, <Line: +                            /**
>, <Line: +                             * The super type's generic type token.
>, <Line: +                             */
>, <Line: +                            private final GenericTypeToken superTypeToken;
>, <Line: +                            /**
>, <Line: +                             * The interface type's generic type tokens.
>, <Line: +                             */
>, <Line: +                            private final List<GenericTypeToken> interfaceTypeTokens;
>, <Line: +                            /**
>, <Line: +                             * The type variables generic type tokens.
>, <Line: +                             */
>, <Line: +                            private final List<OfFormalTypeVariable> typeVariableTokens;
>, <Line: +                            /**
>, <Line: +                             * Creates a new tokenized resolution of a {@link TypeDescription}'s generic signatures.
>, <Line: +                             *
>, <Line: +                             * @param superTypeToken      The super type's generic type token.
>, <Line: +                             * @param interfaceTypeTokens The interface type's generic type tokens.
>, <Line: +                             * @param typeVariableTokens  The type variables generic type tokens.
>, <Line: +                             */
>, <Line: +                            public Tokenized(GenericTypeToken superTypeToken,
>, <Line: +                                             List<GenericTypeToken> interfaceTypeTokens,
>, <Line: +                                             List<OfFormalTypeVariable> typeVariableTokens) {
>, <Line: +                                this.superTypeToken = superTypeToken;
>, <Line: +                                this.interfaceTypeTokens = interfaceTypeTokens;
>, <Line: +                                this.typeVariableTokens = typeVariableTokens;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public Generic resolveSuperType(String superTypeDescriptor,
>, <Line: +                                                            TypePool typePool,
>, <Line: +                                                            Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                            TypeDescription definingType) {
>, <Line: +                                return TokenizedGenericType.of(typePool, superTypeToken, superTypeDescriptor, annotationTokens, definingType);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors,
>, <Line: +                                                                          TypePool typePool,
>, <Line: +                                                                          Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                          TypeDescription definingType) {
>, <Line: +                                return new TokenizedGenericType.TokenList(typePool, interfaceTypeTokens, annotationTokens, interfaceTypeDescriptors, definingType);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
>, <Line: +                                                                         TypeVariableSource typeVariableSource,
>, <Line: +                                                                         Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                         Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens) {
>, <Line: +                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public boolean equals(Object other) {
>, <Line: +                                if (this == other) return true;
>, <Line: +                                if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                                Tokenized tokenized = (Tokenized) other;
>, <Line: +                                return superTypeToken.equals(tokenized.superTypeToken)
>, <Line: +                                        && interfaceTypeTokens.equals(tokenized.interfaceTypeTokens)
>, <Line: +                                        && typeVariableTokens.equals(tokenized.typeVariableTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public int hashCode() {
>, <Line: +                                int result = superTypeToken.hashCode();
>, <Line: +                                result = 31 * result + interfaceTypeTokens.hashCode();
>, <Line: +                                result = 31 * result + typeVariableTokens.hashCode();
>, <Line: +                                return result;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public String toString() {
>, <Line: +                                return "TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.ForType.Tokenized{" +
>, <Line: +                                        "superTypeToken=" + superTypeToken +
>, <Line: +                                        ", interfaceTypeTokens=" + interfaceTypeTokens +
>, <Line: +                                        ", typeVariableTokens=" + typeVariableTokens +
>, <Line: +                                        '}';
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A resolution of the generic types of a {@link MethodDescription}.
>, <Line: +                     */
>, <Line: +                    interface ForMethod extends Resolution {
>, <Line: +                        /**
>, <Line: +                         * Resolves the return type of the represented method.
>, <Line: +                         *
>, <Line: +                         * @param returnTypeDescriptor The descriptor of the raw return type.
>, <Line: +                         * @param typePool             The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param annotationTokens     A mapping of the return type's type annotation tokens.
>, <Line: +                         * @param definingMethod       The method that defines this return type.
>, <Line: +                         * @return A description of this type's generic return type.
>, <Line: +                         */
>, <Line: +                        Generic resolveReturnType(String returnTypeDescriptor,
>, <Line: +                                                  TypePool typePool,
>, <Line: +                                                  Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                  MethodDescription.InDefinedShape definingMethod);
>, <Line: +                        /**
>, <Line: +                         * Resolves the generic parameter types of the represented method.
>, <Line: +                         *
>, <Line: +                         * @param parameterTypeDescriptors The descriptor of the raw parameter types.
>, <Line: +                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param annotationTokens         A mapping of the parameter types' type annotation tokens by their indices.
>, <Line: +                         * @param definingMethod           The method that defines these parameter types.
>, <Line: +                         * @return A description of this type's generic interface types.
>, <Line: +                         */
>, <Line: +                        TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors,
>, <Line: +                                                               TypePool typePool,
>, <Line: +                                                               Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                               MethodDescription.InDefinedShape definingMethod);
>, <Line: +                        /**
>, <Line: +                         * Resolves the generic parameter types of the represented method.
>, <Line: +                         *
>, <Line: +                         * @param exceptionTypeDescriptors The descriptor of the raw exception types.
>, <Line: +                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param annotationTokens         A mapping of the execption types' type annotation tokens by their indices.
>, <Line: +                         * @param definingMethod           The method that defines these exception types.
>, <Line: +                         * @return A description of this type's generic interface types.
>, <Line: +                         */
>, <Line: +                        TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors,
>, <Line: +                                                               TypePool typePool,
>, <Line: +                                                               Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                               MethodDescription.InDefinedShape definingMethod);
>, <Line: +                        /**
>, <Line: +                         * An implementation of a tokenized resolution of generic types of a {@link MethodDescription}.
>, <Line: +                         */
>, <Line: +                        class Tokenized implements ForMethod {
>, <Line: +                            /**
>, <Line: +                             * A token describing the represented method's return type.
>, <Line: +                             */
>, <Line: +                            private final GenericTypeToken returnTypeToken;
>, <Line: +                            /**
>, <Line: +                             * A token describing the represented method's parameter types.
>, <Line: +                             */
>, <Line: +                            private final List<GenericTypeToken> parameterTypeTokens;
>, <Line: +                            /**
>, <Line: +                             * A token describing the represented method's exception types.
>, <Line: +                             */
>, <Line: +                            private final List<GenericTypeToken> exceptionTypeTokens;
>, <Line: +                            /**
>, <Line: +                             * A token describing the represented method's type variables.
>, <Line: +                             */
>, <Line: +                            private final List<OfFormalTypeVariable> typeVariableTokens;
>, <Line: +                            /**
>, <Line: +                             * Creates a new tokenized resolution of a {@link MethodDescription}'s generic signatures.
>, <Line: +                             *
>, <Line: +                             * @param returnTypeToken     A token describing the represented method's return type.
>, <Line: +                             * @param parameterTypeTokens A token describing the represented method's parameter types.
>, <Line: +                             * @param exceptionTypeTokens A token describing the represented method's exception types.
>, <Line: +                             * @param typeVariableTokens  A token describing the represented method's type variables.
>, <Line: +                             */
>, <Line: +                            public Tokenized(GenericTypeToken returnTypeToken,
>, <Line: +                                             List<GenericTypeToken> parameterTypeTokens,
>, <Line: +                                             List<GenericTypeToken> exceptionTypeTokens,
>, <Line: +                                             List<OfFormalTypeVariable> typeVariableTokens) {
>, <Line: +                                this.returnTypeToken = returnTypeToken;
>, <Line: +                                this.parameterTypeTokens = parameterTypeTokens;
>, <Line: +                                this.exceptionTypeTokens = exceptionTypeTokens;
>, <Line: +                                this.typeVariableTokens = typeVariableTokens;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public Generic resolveReturnType(String returnTypeDescriptor,
>, <Line: +                                                             TypePool typePool,
>, <Line: +                                                             Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                             MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                                return TokenizedGenericType.of(typePool, returnTypeToken, returnTypeDescriptor, annotationTokens, definingMethod);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors,
>, <Line: +                                                                          TypePool typePool,
>, <Line: +                                                                          Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                          MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                                return new TokenizedGenericType.TokenList(typePool, parameterTypeTokens, annotationTokens, parameterTypeDescriptors, definingMethod);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors,
>, <Line: +                                                                          TypePool typePool,
>, <Line: +                                                                          Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                          MethodDescription.InDefinedShape definingMethod) {
>, <Line: +                                // Generic signatures of methods are optional.
>, <Line: +                                return exceptionTypeTokens.isEmpty()
>, <Line: +                                        ? Raw.INSTANCE.resolveExceptionTypes(exceptionTypeDescriptors, typePool, annotationTokens, definingMethod)
>, <Line: +                                        : new TokenizedGenericType.TokenList(typePool, exceptionTypeTokens, annotationTokens, exceptionTypeDescriptors, definingMethod);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
>, <Line: +                                                                         TypeVariableSource typeVariableSource,
>, <Line: +                                                                         Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                                         Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens) {
>, <Line: +                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public boolean equals(Object other) {
>, <Line: +                                if (this == other) return true;
>, <Line: +                                if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                                Tokenized tokenized = (Tokenized) other;
>, <Line: +                                return returnTypeToken.equals(tokenized.returnTypeToken)
>, <Line: +                                        && parameterTypeTokens.equals(tokenized.parameterTypeTokens)
>, <Line: +                                        && exceptionTypeTokens.equals(tokenized.exceptionTypeTokens)
>, <Line: +                                        && typeVariableTokens.equals(tokenized.typeVariableTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public int hashCode() {
>, <Line: +                                int result = returnTypeToken.hashCode();
>, <Line: +                                result = 31 * result + parameterTypeTokens.hashCode();
>, <Line: +                                result = 31 * result + exceptionTypeTokens.hashCode();
>, <Line: +                                result = 31 * result + typeVariableTokens.hashCode();
>, <Line: +                                return result;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public String toString() {
>, <Line: +                                return "TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.ForMethod.Tokenized{" +
>, <Line: +                                        "returnTypeToken=" + returnTypeToken +
>, <Line: +                                        ", parameterTypeTokens=" + parameterTypeTokens +
>, <Line: +                                        ", exceptionTypeTokens=" + exceptionTypeTokens +
>, <Line: +                                        ", typeVariableTokens=" + typeVariableTokens +
>, <Line: +                                        '}';
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A resolution of the generic types of a {@link FieldDescription}.
>, <Line: +                     */
>, <Line: +                    interface ForField {
>, <Line: +                        /**
>, <Line: +                         * Resolves the field type of the represented field.
>, <Line: +                         *
>, <Line: +                         * @param fieldTypeDescriptor The descriptor of the raw field type.
>, <Line: +                         * @param annotationTokens    A mapping of the represented types' type annotation tokens.
>, <Line: +                         * @param typePool            The type pool to be used for locating non-generic type descriptions.
>, <Line: +                         * @param definingField       The field that defines this type.   @return A description of this field's type.
>, <Line: +                         * @return A generic type representation of the field's type.
>, <Line: +                         */
>, <Line: +                        Generic resolveFieldType(String fieldTypeDescriptor,
>, <Line: +                                                 TypePool typePool,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                 FieldDescription.InDefinedShape definingField);
>, <Line: +                        /**
>, <Line: +                         * An implementation of a tokenized resolution of the generic type of a {@link FieldDescription}.
>, <Line: +                         */
>, <Line: +                        class Tokenized implements ForField {
>, <Line: +                            /**
>, <Line: +                             * The token of the represented field's type.
>, <Line: +                             */
>, <Line: +                            private final GenericTypeToken fieldTypeToken;
>, <Line: +                            /**
>, <Line: +                             * Creates a new tokenized resolution of a {@link FieldDescription}'s type.
>, <Line: +                             *
>, <Line: +                             * @param fieldTypeToken The token of the represented field's type.
>, <Line: +                             */
>, <Line: +                            public Tokenized(GenericTypeToken fieldTypeToken) {
>, <Line: +                                this.fieldTypeToken = fieldTypeToken;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public Generic resolveFieldType(String fieldTypeDescriptor,
>, <Line: +                                                            TypePool typePool,
>, <Line: +                                                            Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                            FieldDescription.InDefinedShape definingField) {
>, <Line: +                                return TokenizedGenericType.of(typePool, fieldTypeToken, fieldTypeDescriptor, annotationTokens, definingField.getDeclaringType());
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public boolean equals(Object other) {
>, <Line: +                                return this == other || other != null && getClass() == other.getClass()
>, <Line: +                                        && fieldTypeToken.equals(((Tokenized) other).fieldTypeToken);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public int hashCode() {
>, <Line: +                                return fieldTypeToken.hashCode();
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public String toString() {
>, <Line: +                                return "TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.ForField.Tokenized{" +
>, <Line: +                                        "fieldTypeToken=" + fieldTypeToken +
>, <Line: +                                        '}';
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A generic type token that represents a non-generic type.
>, <Line: +                 */
>, <Line: +                class ForRawType implements GenericTypeToken {
>, <Line: +                    /**
>, <Line: +                     * The name of the represented type.
>, <Line: +                     */
>, <Line: +                    private final String name;
>, <Line: +                    /**
>, <Line: +                     * Creates a new type token that represents a non-generic type.
>, <Line: +                     *
>, <Line: +                     * @param name The name of the represented type.
>, <Line: +                     */
>, <Line: +                    public ForRawType(String name) {
>, <Line: +                        this.name = name;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic toGenericType(TypePool typePool,
>, <Line: +                                                 TypeVariableSource typeVariableSource,
>, <Line: +                                                 String typePath,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyNonGenericType(typePool,
>, <Line: +                                typePath,
>, <Line: +                                annotationTokens == null
>, <Line: +                                        ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                        : annotationTokens,
>, <Line: +                                typePool.describe(name).resolve());
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        return !typePool.describe(name).resolve().isInterface();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass()) && name.equals(((ForRawType) other).name);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return name.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForRawType{" +
>, <Line: +                                "name='" + name + '\'' +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A representation of an annotated non-generic type.
>, <Line: +                     */
>, <Line: +                    protected static class LazyNonGenericType extends Generic.OfNonGenericType {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * A mapping of this type's type annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * The represented type description.
>, <Line: +                         */
>, <Line: +                        private final TypeDescription typeDescription;
>, <Line: +                        /**
>, <Line: +                         * Creates a new lazy non-generic type.
>, <Line: +                         *
>, <Line: +                         * @param typePool         The type pool to use.
>, <Line: +                         * @param typePath         This type's type path.
>, <Line: +                         * @param annotationTokens A mapping of this type's type annotation tokens.
>, <Line: +                         * @param typeDescription  The represented type description.
>, <Line: +                         */
>, <Line: +                        protected LazyNonGenericType(TypePool typePool,
>, <Line: +                                                     String typePath,
>, <Line: +                                                     Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                     TypeDescription typeDescription) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.typeDescription = typeDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeDescription asErasure() {
>, <Line: +                            return typeDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic getComponentType() {
>, <Line: +                            TypeDescription componentType = typeDescription.getComponentType();
>, <Line: +                            return componentType == null
>, <Line: +                                    ? UNDEFINED
>, <Line: +                                    : new LazyNonGenericType(typePool, typePath + COMPONENT_TYPE_PATH, annotationTokens, componentType);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A generic type token that represents a type variable.
>, <Line: +                 */
>, <Line: +                class ForTypeVariable implements GenericTypeToken {
>, <Line: +                    /**
>, <Line: +                     * This type variable's nominal symbol.
>, <Line: +                     */
>, <Line: +                    private final String symbol;
>, <Line: +                    /**
>, <Line: +                     * Creates a generic type token that represents a type variable.
>, <Line: +                     *
>, <Line: +                     * @param symbol This type variable's nominal symbol.
>, <Line: +                     */
>, <Line: +                    public ForTypeVariable(String symbol) {
>, <Line: +                        this.symbol = symbol;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        Generic typeVariable = typeVariableSource.findVariable(symbol);
>, <Line: +                        if (typeVariable == null) {
>, <Line: +                            throw new IllegalStateException("Cannot resolve type variable '" + symbol + "' for " + typeVariableSource);
>, <Line: +                        } else {
>, <Line: +                            return new AnnotatedTypeVariable(typePool, annotationTokens.get(typePath), typeVariable);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        return true;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass()) && symbol.equals(((ForTypeVariable) other).symbol);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return symbol.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForTypeVariable{" +
>, <Line: +                                "symbol='" + symbol + '\'' +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * An annotated representation of a formal type variable.
>, <Line: +                     */
>, <Line: +                    protected static class AnnotatedTypeVariable extends Generic.OfTypeVariable {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The represented annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final List<AnnotationToken> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * The represented type variable.
>, <Line: +                         */
>, <Line: +                        private final Generic typeVariable;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotated type variable.
>, <Line: +                         *
>, <Line: +                         * @param typePool         The type pool to use.
>, <Line: +                         * @param annotationTokens The represented annotation tokens.
>, <Line: +                         * @param typeVariable     The represented type variable.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedTypeVariable(TypePool typePool, List<AnnotationToken> annotationTokens, Generic typeVariable) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.typeVariable = typeVariable;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            return typeVariable.getUpperBounds();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableSource getVariableSource() {
>, <Line: +                            return typeVariable.getVariableSource();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String getSymbol() {
>, <Line: +                            return typeVariable.getSymbol();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A generic type token that represent a formal type variable, i.e. a type variable including its upper bounds.
>, <Line: +                     */
>, <Line: +                    public static class Formal implements GenericTypeToken.OfFormalTypeVariable {
>, <Line: +                        /**
>, <Line: +                         * This type variable's nominal symbol.
>, <Line: +                         */
>, <Line: +                        private final String symbol;
>, <Line: +                        /**
>, <Line: +                         * A list of tokens that represent this type variable's upper bounds.
>, <Line: +                         */
>, <Line: +                        private final List<GenericTypeToken> boundTypeTokens;
>, <Line: +                        /**
>, <Line: +                         * Creates generic type token that represent a formal type variable.
>, <Line: +                         *
>, <Line: +                         * @param symbol          This type variable's nominal symbol.
>, <Line: +                         * @param boundTypeTokens A list of tokens that represent this type variable's upper bounds.
>, <Line: +                         */
>, <Line: +                        public Formal(String symbol, List<GenericTypeToken> boundTypeTokens) {
>, <Line: +                            this.symbol = symbol;
>, <Line: +                            this.boundTypeTokens = boundTypeTokens;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic toGenericType(TypePool typePool,
>, <Line: +                                                     TypeVariableSource typeVariableSource,
>, <Line: +                                                     Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                     Map<Integer, Map<String, List<AnnotationToken>>> boundaryAnnotationTokens) {
>, <Line: +                            return new LazyTypeVariable(typePool,
>, <Line: +                                    typeVariableSource,
>, <Line: +                                    annotationTokens == null
>, <Line: +                                            ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                            : annotationTokens,
>, <Line: +                                    boundaryAnnotationTokens == null
>, <Line: +                                            ? Collections.<Integer, Map<String, List<AnnotationToken>>>emptyMap()
>, <Line: +                                            : boundaryAnnotationTokens,
>, <Line: +                                    symbol,
>, <Line: +                                    boundTypeTokens);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && symbol.equals(((Formal) other).symbol)
>, <Line: +                                    && boundTypeTokens.equals(((Formal) other).boundTypeTokens);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return symbol.hashCode() + 31 * boundTypeTokens.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForTypeVariable.Formal{" +
>, <Line: +                                    "symbol='" + symbol + '\'' +
>, <Line: +                                    "boundTypeTokens='" + boundTypeTokens + '\'' +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * A type description that represents a type variable with bounds that are resolved lazily.
>, <Line: +                         */
>, <Line: +                        protected static class LazyTypeVariable extends Generic.OfTypeVariable {
>, <Line: +                            /**
>, <Line: +                             * The type pool to use for locating type descriptions.
>, <Line: +                             */
>, <Line: +                            private final TypePool typePool;
>, <Line: +                            /**
>, <Line: +                             * The type variable source to use for locating type variables.
>, <Line: +                             */
>, <Line: +                            private final TypeVariableSource typeVariableSource;
>, <Line: +                            /**
>, <Line: +                             * The type variable's type annotation tokens.
>, <Line: +                             */
>, <Line: +                            private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                            /**
>, <Line: +                             * A mapping of the type variable boundss type annotation tokens by their indices.
>, <Line: +                             */
>, <Line: +                            private final Map<Integer, Map<String, List<AnnotationToken>>> boundaryAnnotationTokens;
>, <Line: +                            /**
>, <Line: +                             * The type variable's symbol.
>, <Line: +                             */
>, <Line: +                            private final String symbol;
>, <Line: +                            /**
>, <Line: +                             * Tokenized representations of the type variables bound types.
>, <Line: +                             */
>, <Line: +                            private final List<GenericTypeToken> boundTypeTokens;
>, <Line: +                            /**
>, <Line: +                             * Creates a lazy type description of a type variables.
>, <Line: +                             *
>, <Line: +                             * @param typePool                 The type pool to use for locating type descriptions.
>, <Line: +                             * @param typeVariableSource       The type variable source to use for locating type variables.
>, <Line: +                             * @param annotationTokens         The type variable's type annotation tokens.
>, <Line: +                             * @param boundaryAnnotationTokens A mapping of the type variable boundss type annotation tokens by their indices.
>, <Line: +                             * @param symbol                   The type variable's symbol.
>, <Line: +                             * @param boundTypeTokens          Tokenized representations of the type variables bound types.
>, <Line: +                             */
>, <Line: +                            protected LazyTypeVariable(TypePool typePool,
>, <Line: +                                                       TypeVariableSource typeVariableSource,
>, <Line: +                                                       Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                       Map<Integer, Map<String, List<AnnotationToken>>> boundaryAnnotationTokens,
>, <Line: +                                                       String symbol,
>, <Line: +                                                       List<GenericTypeToken> boundTypeTokens) {
>, <Line: +                                this.typePool = typePool;
>, <Line: +                                this.typeVariableSource = typeVariableSource;
>, <Line: +                                this.annotationTokens = annotationTokens;
>, <Line: +                                this.boundaryAnnotationTokens = boundaryAnnotationTokens;
>, <Line: +                                this.symbol = symbol;
>, <Line: +                                this.boundTypeTokens = boundTypeTokens;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic getUpperBounds() {
>, <Line: +                                return new LazyBoundTokenList(typePool, typeVariableSource, boundaryAnnotationTokens, boundTypeTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeVariableSource getVariableSource() {
>, <Line: +                                return typeVariableSource;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public String getSymbol() {
>, <Line: +                                return symbol;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public AnnotationList getDeclaredAnnotations() {
>, <Line: +                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(EMPTY_TYPE_PATH));
>, <Line: +                            }
>, <Line: +                            /**
>, <Line: +                             * A list representing a formal type variable's bounds.
>, <Line: +                             */
>, <Line: +                            protected static class LazyBoundTokenList extends TypeList.Generic.AbstractBase {
>, <Line: +                                /**
>, <Line: +                                 * The type pool to use.
>, <Line: +                                 */
>, <Line: +                                private final TypePool typePool;
>, <Line: +                                /**
>, <Line: +                                 * The type variable source for locating type variables.
>, <Line: +                                 */
>, <Line: +                                private final TypeVariableSource typeVariableSource;
>, <Line: +                                /**
>, <Line: +                                 * A mapping of the bound type's type annotations by their bound index.
>, <Line: +                                 */
>, <Line: +                                private final Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens;
>, <Line: +                                /**
>, <Line: +                                 * The bound types in their tokenized form.
>, <Line: +                                 */
>, <Line: +                                private final List<GenericTypeToken> boundTypeTokens;
>, <Line: +                                /**
>, <Line: +                                 * Creates a new lazy bound token list for a type variable.
>, <Line: +                                 *
>, <Line: +                                 * @param typePool           The type pool to use.
>, <Line: +                                 * @param typeVariableSource The type variable source for locating type variables.
>, <Line: +                                 * @param annotationTokens   A mapping of the bound type's type annotations by their bound index.
>, <Line: +                                 * @param boundTypeTokens    The bound types in their tokenized form.
>, <Line: +                                 */
>, <Line: +                                protected LazyBoundTokenList(TypePool typePool,
>, <Line: +                                                             TypeVariableSource typeVariableSource,
>, <Line: +                                                             Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                                             List<GenericTypeToken> boundTypeTokens) {
>, <Line: +                                    this.typePool = typePool;
>, <Line: +                                    this.typeVariableSource = typeVariableSource;
>, <Line: +                                    this.annotationTokens = annotationTokens;
>, <Line: +                                    this.boundTypeTokens = boundTypeTokens;
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public Generic get(int index) {
>, <Line: +                                    Map<String, List<AnnotationToken>> annotationTokens = this.annotationTokens.get(index + (boundTypeTokens.get(0).isPrimaryBound(typePool)
>, <Line: +                                            ? 0
>, <Line: +                                            : 1));
>, <Line: +                                    return boundTypeTokens.get(index).toGenericType(typePool,
>, <Line: +                                            typeVariableSource,
>, <Line: +                                            EMPTY_TYPE_PATH,
>, <Line: +                                            annotationTokens == null
>, <Line: +                                                    ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                                    : annotationTokens);
>, <Line: +                                }
>, <Line: +                                @Override
>, <Line: +                                public int size() {
>, <Line: +                                    return boundTypeTokens.size();
>, <Line: +                                }
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                 * A generic type token that represents a generic array.
>, <Line: +                class ForGenericArray implements GenericTypeToken {
>, <Line: +                    /**
>, <Line: +                     * The array's component type.
>, <Line: +                     */
>, <Line: +                    private final GenericTypeToken componentTypeToken;
>, <Line: +                    /**
>, <Line: +                     * Creates a generic type token that represents a generic array.
>, <Line: +                     *
>, <Line: +                     * @param componentTypeToken The array's component type.
>, <Line: +                     */
>, <Line: +                    public ForGenericArray(GenericTypeToken componentTypeToken) {
>, <Line: +                        this.componentTypeToken = componentTypeToken;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyGenericArray(typePool, typeVariableSource, typePath, annotationTokens, componentTypeToken);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        throw new IllegalStateException("A generic array type cannot be a type variable bound: " + this);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && componentTypeToken.equals(((ForGenericArray) other).componentTypeToken);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return componentTypeToken.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForGenericArray{" +
>, <Line: +                                "componentTypeToken='" + componentTypeToken + '\'' +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A generic type representation of a generic array.
>, <Line: +                     */
>, <Line: +                    protected static class LazyGenericArray extends Generic.OfGenericArray {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable source for locating type variables.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * This type's type annotations.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * A tokenized representation of this generic arrays's component type.
>, <Line: +                         */
>, <Line: +                        private final GenericTypeToken componentTypeToken;
>, <Line: +                        /**
>, <Line: +                         * Creates a new lazy generic array.
>, <Line: +                         *
>, <Line: +                         * @param typePool           The type pool to use.
>, <Line: +                         * @param typeVariableSource The type variable source for locating type variables.
>, <Line: +                         * @param typePath           This type's type path.
>, <Line: +                         * @param annotationTokens   This type's type annotations.
>, <Line: +                         * @param componentTypeToken A tokenized representation of this generic arrays's component type.
>, <Line: +                         */
>, <Line: +                        protected LazyGenericArray(TypePool typePool,
>, <Line: +                                                   TypeVariableSource typeVariableSource,
>, <Line: +                                                   String typePath,
>, <Line: +                                                   Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                   GenericTypeToken componentTypeToken) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.componentTypeToken = componentTypeToken;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic getComponentType() {
>, <Line: +                            return componentTypeToken.toGenericType(typePool, typeVariableSource, typePath + COMPONENT_TYPE_PATH, annotationTokens);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                 * A generic type token for a wildcard that is bound below.
>, <Line: +                class ForLowerBoundWildcard implements GenericTypeToken {
>, <Line: +                    /**
>, <Line: +                     * A token that represents the wildcard's lower bound.
>, <Line: +                     */
>, <Line: +                    private final GenericTypeToken boundTypeToken;
>, <Line: +                    /**
>, <Line: +                     * Creates a generic type token for a wildcard that is bound below.
>, <Line: +                     *
>, <Line: +                     * @param boundTypeToken A token that represents the wildcard's lower bound.
>, <Line: +                     */
>, <Line: +                    public ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: +                        this.boundTypeToken = boundTypeToken;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyLowerBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        throw new IllegalStateException("A wildcard type cannot be a type variable bound: " + this);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && boundTypeToken.equals(((ForLowerBoundWildcard) other).boundTypeToken);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return boundTypeToken.hashCode();
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForLowerBoundWildcard{" +
>, <Line: +                                "boundTypeToken=" + boundTypeToken +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                     * A generic type representation of a lower bound wildcard.
>, <Line: +                    protected static class LazyLowerBoundWildcard extends Generic.OfWildcardType {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable source for locating type variables.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * This type's type annotations.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * A tokenized representation of this wildcard's bound.
>, <Line: +                         */
>, <Line: +                        private final GenericTypeToken boundTypeToken;
>, <Line: +                        /**
>, <Line: +                         * Creates a new lazy lower bound wildcard.
>, <Line: +                         *
>, <Line: +                         * @param typePool           The type pool to use.
>, <Line: +                         * @param typeVariableSource The type variable source for locating type variables.
>, <Line: +                         * @param typePath           This type's type path.
>, <Line: +                         * @param annotationTokens   This type's type annotations.
>, <Line: +                         * @param boundTypeToken     A tokenized representation of this wildcard's bound.
>, <Line: +                         */
>, <Line: +                        protected LazyLowerBoundWildcard(TypePool typePool,
>, <Line: +                                                         TypeVariableSource typeVariableSource,
>, <Line: +                                                         String typePath,
>, <Line: +                                                         Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                         GenericTypeToken boundTypeToken) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.boundTypeToken = boundTypeToken;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            return new TypeList.Generic.Explicit(Generic.OBJECT);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getLowerBounds() {
>, <Line: +                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                        }
>, <Line: +                 * A generic type token for a wildcard that is bound above.
>, <Line: +                class ForUpperBoundWildcard implements GenericTypeToken {
>, <Line: +                     * A token that represents the wildcard's upper bound.
>, <Line: +                    private final GenericTypeToken boundTypeToken;
>, <Line: +                    /**
>, <Line: +                     * Creates a generic type token for a wildcard that is bound above.
>, <Line: +                     *
>, <Line: +                     * @param boundTypeToken A token that represents the wildcard's upper bound.
>, <Line: +                     */
>, <Line: +                    public ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {
>, <Line: +                        this.boundTypeToken = boundTypeToken;
>, <Line: +                    public Generic toGenericType(TypePool typePool,
>, <Line: +                                                 TypeVariableSource typeVariableSource,
>, <Line: +                                                 String typePath,
>, <Line: +                                                 Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyUpperBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        throw new IllegalStateException("A wildcard type cannot be a type variable bound: " + this);
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && boundTypeToken.equals(((ForUpperBoundWildcard) other).boundTypeToken);
>, <Line: +                    public int hashCode() {
>, <Line: +                        return boundTypeToken.hashCode();
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForUpperBoundWildcard{" +
>, <Line: +                                "boundTypeToken=" + boundTypeToken +
>, <Line: +                                '}';
>, <Line: +                     * A generic type representation of a tokenized wildcard with an upper bound.
>, <Line: +                    protected static class LazyUpperBoundWildcard extends Generic.OfWildcardType {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable source for locating type variables.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                         * This type's type path.
>, <Line: +                        private final String typePath;
>, <Line: +                         * This type's type annotations.
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                         * A tokenized representation of this wildcard's bound.
>, <Line: +                        private final GenericTypeToken boundTypeToken;
>, <Line: +                         * Creates a new lazy upper bound wildcard.
>, <Line: +                         * @param typePool           The type pool to use.
>, <Line: +                         * @param typeVariableSource The type variable source for locating type variables.
>, <Line: +                         * @param typePath           This type's type path.
>, <Line: +                         * @param annotationTokens   This type's type annotations.
>, <Line: +                         * @param boundTypeToken     A tokenized representation of this wildcard's bound.
>, <Line: +                        protected LazyUpperBoundWildcard(TypePool typePool,
>, <Line: +                                                         TypeVariableSource typeVariableSource,
>, <Line: +                                                         String typePath,
>, <Line: +                                                         Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                         GenericTypeToken boundTypeToken) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.boundTypeToken = boundTypeToken;
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
>, <Line: +                        public TypeList.Generic getLowerBounds() {
>, <Line: +                            return new TypeList.Generic.Empty();
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                 * A generic type token that represents a parameterized type.
>, <Line: +                class ForParameterizedType implements GenericTypeToken {
>, <Line: +                     * The name of the parameterized type's erasure.
>, <Line: +                    private final String name;
>, <Line: +                     * A list of tokens that represent the parameters of the represented type.
>, <Line: +                    private final List<GenericTypeToken> parameterTypeTokens;
>, <Line: +                     * Creates a type token that represents a parameterized type.
>, <Line: +                     * @param name                The name of the parameterized type's erasure.
>, <Line: +                     * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
>, <Line: +                    public ForParameterizedType(String name, List<GenericTypeToken> parameterTypeTokens) {
>, <Line: +                        this.name = name;
>, <Line: +                        this.parameterTypeTokens = parameterTypeTokens;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                        return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                        return !typePool.describe(name).resolve().isInterface();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && name.equals(((ForParameterizedType) other).name)
>, <Line: +                                && parameterTypeTokens.equals(((ForParameterizedType) other).parameterTypeTokens);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return name.hashCode() + 31 * parameterTypeTokens.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForParameterizedType{" +
>, <Line: +                                "name='" + name + '\'' +
>, <Line: +                                ", parameterTypeTokens=" + parameterTypeTokens +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                     * A generic type token to describe a parameterized type description with a generic owner type.
>, <Line: +                    public static class Nested implements GenericTypeToken {
>, <Line: +                         * The name of the parameterized type's erasure.
>, <Line: +                        private final String name;
>, <Line: +                         * A list of tokens that represent the parameters of the represented type.
>, <Line: +                         * A token that describes the described parameterized type's owner type.
>, <Line: +                        private final GenericTypeToken ownerTypeToken;
>, <Line: +                         * Creates a type token that represents a parameterized type.
>, <Line: +                         * @param name                The name of the parameterized type's erasure.
>, <Line: +                         * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
>, <Line: +                         * @param ownerTypeToken      A token that describes the described parameterized type's owner type.
>, <Line: +                        public Nested(String name, List<GenericTypeToken> parameterTypeTokens, GenericTypeToken ownerTypeToken) {
>, <Line: +                            this.name = name;
>, <Line: +                            this.ownerTypeToken = ownerTypeToken;
>, <Line: +                        public Generic toGenericType(TypePool typePool,
>, <Line: +                                                     TypeVariableSource typeVariableSource,
>, <Line: +                                                     String typePath,
>, <Line: +                                                     Map<String, List<AnnotationToken>> annotationTokens) {
>, <Line: +                            return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens, ownerTypeToken);
>, <Line: +                        public boolean isPrimaryBound(TypePool typePool) {
>, <Line: +                            return !typePool.describe(name).resolve().isInterface();
>, <Line: +                            Nested nested = (Nested) other;
>, <Line: +                            return name.equals(nested.name)
>, <Line: +                                    && parameterTypeTokens.equals(nested.parameterTypeTokens)
>, <Line: +                                    && ownerTypeToken.equals(nested.ownerTypeToken);
>, <Line: +                            int result = name.hashCode();
>, <Line: +                            result = 31 * result + ownerTypeToken.hashCode();
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.GenericTypeToken.ForParameterizedType.Nested{" +
>, <Line: +                                    "name='" + name + '\'' +
>, <Line: +                                    ", ownerTypeToken=" + ownerTypeToken +
>, <Line: +                        /**
>, <Line: +                         * A lazy description of a parameterized type with an owner type.
>, <Line: +                         */
>, <Line: +                        protected static class LazyParameterizedType extends Generic.OfParameterizedType {
>, <Line: +                            /**
>, <Line: +                             * The type pool that is used for locating a generic type.
>, <Line: +                             */
>, <Line: +                            private final TypePool typePool;
>, <Line: +                            /**
>, <Line: +                             * The type variable source to use for resolving type variables.
>, <Line: +                             */
>, <Line: +                            private final TypeVariableSource typeVariableSource;
>, <Line: +                            /**
>, <Line: +                             * This type's type path.
>, <Line: +                             */
>, <Line: +                            private final String typePath;
>, <Line: +                            /**
>, <Line: +                             * A mapping of type annotations for this type.
>, <Line: +                             */
>, <Line: +                            private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                            /**
>, <Line: +                             * The binary name of this parameterized type's raw type.
>, <Line: +                             */
>, <Line: +                            private final String name;
>, <Line: +                            /**
>, <Line: +                             * Tokens that represent this parameterized type's parameters.
>, <Line: +                             */
>, <Line: +                            private final List<GenericTypeToken> parameterTypeTokens;
>, <Line: +                            /**
>, <Line: +                             * A token that represents this type's owner type.
>, <Line: +                             */
>, <Line: +                            private final GenericTypeToken ownerTypeToken;
>, <Line: +                            /**
>, <Line: +                             * Creates a new lazy parameterized type.
>, <Line: +                             *
>, <Line: +                             * @param typePool            The type pool that is used for locating a generic type.
>, <Line: +                             * @param typeVariableSource  The type variable source to use for resolving type variables.
>, <Line: +                             * @param typePath            This type's type path.
>, <Line: +                             * @param annotationTokens    A mapping of type annotations for this type.
>, <Line: +                             * @param name                The binary name of this parameterized type's raw type.
>, <Line: +                             * @param parameterTypeTokens Tokens that represent this parameterized type's parameters.
>, <Line: +                             * @param ownerTypeToken      A token that represents this type's owner type.
>, <Line: +                             */
>, <Line: +                            protected LazyParameterizedType(TypePool typePool,
>, <Line: +                                                            TypeVariableSource typeVariableSource,
>, <Line: +                                                            String typePath,
>, <Line: +                                                            Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                            String name,
>, <Line: +                                                            List<GenericTypeToken> parameterTypeTokens,
>, <Line: +                                                            GenericTypeToken ownerTypeToken) {
>, <Line: +                                this.typePool = typePool;
>, <Line: +                                this.typeVariableSource = typeVariableSource;
>, <Line: +                                this.typePath = typePath;
>, <Line: +                                this.annotationTokens = annotationTokens;
>, <Line: +                                this.name = name;
>, <Line: +                                this.parameterTypeTokens = parameterTypeTokens;
>, <Line: +                                this.ownerTypeToken = ownerTypeToken;
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeDescription asErasure() {
>, <Line: +                                return typePool.describe(name).resolve();
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public TypeList.Generic getTypeArguments() {
>, <Line: +                                return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public Generic getOwnerType() {
>, <Line: +                                return ownerTypeToken.toGenericType(typePool, typeVariableSource, typePath + OWNER_TYPE_PATH, annotationTokens);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public AnnotationList getDeclaredAnnotations() {
>, <Line: +                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                     * A generic type description that represents a parameterized type <b>without</b> an enclosing generic owner type.
>, <Line: +                    protected static class LazyParameterizedType extends Generic.OfParameterizedType {
>, <Line: +                        /**
>, <Line: +                         * The type pool that is used for locating a generic type.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable source to use for resolving type variables.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                        /**
>, <Line: +                         * This type's type path.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * A mapping of the represent type's annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * The binary name of the raw type.
>, <Line: +                         */
>, <Line: +                        private final String name;
>, <Line: +                         * A list of type tokens representing this type's bounds.
>, <Line: +                        private final List<GenericTypeToken> parameterTypeTokens;
>, <Line: +                         * Creates a new description of a parameterized type.
>, <Line: +                         * @param typePool            The type pool that is used for locating a generic type.
>, <Line: +                         * @param typeVariableSource  The type variable source to use for resolving type variables.
>, <Line: +                         * @param typePath            This type's type path.
>, <Line: +                         * @param annotationTokens    A mapping of the represent type's annotation tokens,
>, <Line: +                         * @param name                The binary name of the raw type.
>, <Line: +                         * @param parameterTypeTokens A list of type tokens representing this type's bounds.
>, <Line: +                        protected LazyParameterizedType(TypePool typePool,
>, <Line: +                                                        TypeVariableSource typeVariableSource,
>, <Line: +                                                        String typePath,
>, <Line: +                                                        Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                        String name,
>, <Line: +                                                        List<GenericTypeToken> parameterTypeTokens) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.name = name;
>, <Line: +                            this.parameterTypeTokens = parameterTypeTokens;
>, <Line: +                        public TypeDescription asErasure() {
>, <Line: +                            return typePool.describe(name).resolve();
>, <Line: +                        public TypeList.Generic getTypeArguments() {
>, <Line: +                            return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);
>, <Line: +                        public Generic getOwnerType() {
>, <Line: +                            TypeDescription ownerType = typePool.describe(name).resolve().getEnclosingType();
>, <Line: +                            return ownerType == null
>, <Line: +                                    ? UNDEFINED
>, <Line: +                                    : ownerType.asGenericType();
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
>, <Line: +                 * A lazy list of type tokens.
>, <Line: +                class LazyTokenList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The type pool that is used for locating a generic type.
>, <Line: +                     */
>, <Line: +                    private final TypePool typePool;
>, <Line: +                    /**
>, <Line: +                     * The type variable source to use for resolving type variables.
>, <Line: +                     */
>, <Line: +                    private final TypeVariableSource typeVariableSource;
>, <Line: +                    /**
>, <Line: +                     * The represented types' type path to which an index step is added upon resolution.
>, <Line: +                     */
>, <Line: +                    private final String typePath;
>, <Line: +                    /**
>, <Line: +                     * A mapping of the represent types' annotation tokens.
>, <Line: +                     */
>, <Line: +                    private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                    /**
>, <Line: +                     * A list of type tokens this list represents.
>, <Line: +                     */
>, <Line: +                    private final List<GenericTypeToken> genericTypeTokens;
>, <Line: +                    /**
>, <Line: +                     * Creates a new type list that represents a list of tokenized types.
>, <Line: +                     *
>, <Line: +                     * @param typePool           The type pool that is used for locating a generic type.
>, <Line: +                     * @param typeVariableSource The type variable source to use for resolving type variables.
>, <Line: +                     * @param typePath           The represented types' type path to which an index step is added upon resolution.
>, <Line: +                     * @param annotationTokens   A mapping of the represent types' annotation tokens,
>, <Line: +                     * @param genericTypeTokens  A list of type tokens this list represents.
>, <Line: +                     */
>, <Line: +                    protected LazyTokenList(TypePool typePool,
>, <Line: +                                            TypeVariableSource typeVariableSource,
>, <Line: +                                            String typePath,
>, <Line: +                                            Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                            List<GenericTypeToken> genericTypeTokens) {
>, <Line: +                        this.typePool = typePool;
>, <Line: +                        this.typeVariableSource = typeVariableSource;
>, <Line: +                        this.typePath = typePath;
>, <Line: +                        this.annotationTokens = annotationTokens;
>, <Line: +                        this.genericTypeTokens = genericTypeTokens;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return genericTypeTokens.get(index).toGenericType(typePool, typeVariableSource, typePath + index + INDEXED_TYPE_DELIMITER, annotationTokens);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return genericTypeTokens.size();
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A generic type description representing a tokenized wildcard bound.
>, <Line: +                     */
>, <Line: +                    protected static class ForWildcardBound extends TypeList.Generic.AbstractBase {
>, <Line: +                        /**
>, <Line: +                         * The type pool that is used for locating a generic type.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * The type variable source to use for resolving type variables.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableSource typeVariableSource;
>, <Line: +                        /**
>, <Line: +                         * The represented types' type path to which a wildcard step is added upon resolution.
>, <Line: +                         */
>, <Line: +                        private final String typePath;
>, <Line: +                        /**
>, <Line: +                         * A mapping of the represent types' annotation tokens.
>, <Line: +                         */
>, <Line: +                        private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                        /**
>, <Line: +                         * A token representing the wildcard's bound.
>, <Line: +                         */
>, <Line: +                        private final GenericTypeToken genericTypeToken;
>, <Line: +                        /**
>, <Line: +                         * @param typePool           The type pool that is used for locating a generic type.
>, <Line: +                         * @param typeVariableSource The type variable source to use for resolving type variables.
>, <Line: +                         * @param typePath           The represented types' type path to which a wildcard step is added upon resolution.
>, <Line: +                         * @param annotationTokens   A mapping of the represent types' annotation tokens,
>, <Line: +                         * @param genericTypeToken   A token representing the wildcard's bound.
>, <Line: +                         */
>, <Line: +                        protected ForWildcardBound(TypePool typePool,
>, <Line: +                                                   TypeVariableSource typeVariableSource,
>, <Line: +                                                   String typePath,
>, <Line: +                                                   Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                                   GenericTypeToken genericTypeToken) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.typeVariableSource = typeVariableSource;
>, <Line: +                            this.typePath = typePath;
>, <Line: +                            this.annotationTokens = annotationTokens;
>, <Line: +                            this.genericTypeToken = genericTypeToken;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic get(int index) {
>, <Line: +                            if (index == 0) {
>, <Line: +                                return genericTypeToken.toGenericType(typePool, typeVariableSource, typePath + WILDCARD_TYPE_PATH, annotationTokens);
>, <Line: +                            } else {
>, <Line: +                                throw new IndexOutOfBoundsException("index = " + index);
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int size() {
>, <Line: +                            return 1;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +             * A token for representing collected data on an annotation.
>, <Line: +            protected static class AnnotationToken {
>, <Line: +                /**
>, <Line: +                 * The descriptor of the represented annotation.
>, <Line: +                 */
>, <Line: +                private final String descriptor;
>, <Line: +                 * A map of annotation value names to their value representations.
>, <Line: +                private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: +                 * Creates a new annotation token.
>, <Line: +                 * @param descriptor The descriptor of the represented annotation.
>, <Line: +                 * @param values     A map of annotation value names to their value representations.
>, <Line: +                protected AnnotationToken(String descriptor, Map<String, AnnotationDescription.AnnotationValue<?, ?>> values) {
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.values = values;
>, <Line: +                /**
>, <Line: +                 * Returns a map of annotation value names to their value representations.
>, <Line: +                 *
>, <Line: +                 * @return A map of annotation value names to their value representations.
>, <Line: +                 */
>, <Line: +                protected Map<String, AnnotationDescription.AnnotationValue<?, ?>> getValues() {
>, <Line: +                    return values;
>, <Line: +                /**
>, <Line: +                 * Returns the annotation type's binary name.
>, <Line: +                 *
>, <Line: +                 * @return The annotation type's binary name.
>, <Line: +                 */
>, <Line: +                protected String getBinaryName() {
>, <Line: +                    return descriptor.substring(1, descriptor.length() - 1).replace('/', '.');
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Transforms this token into an annotation description.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to be used for looking up linked types.
>, <Line: +                 * @return An optional description of this annotation's token.
>, <Line: +                 */
>, <Line: +                private Resolution toAnnotationDescription(TypePool typePool) {
>, <Line: +                    TypePool.Resolution resolution = typePool.describe(getBinaryName());
>, <Line: +                    return resolution.isResolved()
>, <Line: +                            ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))
>, <Line: +                            : new Resolution.Illegal(getBinaryName());
>, <Line: +                    if (this == other) return true;
>, <Line: +                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                    AnnotationToken that = (AnnotationToken) other;
>, <Line: +                    return descriptor.equals(that.descriptor)
>, <Line: +                            && values.equals(that.values);
>, <Line: +                    int result = descriptor.hashCode();
>, <Line: +                    result = 31 * result + values.hashCode();
>, <Line: +                    return result;
>, <Line: +                    return "TypePool.Default.LazyTypeDescription.AnnotationToken{" +
>, <Line: +                            "descriptor='" + descriptor + '\'' +
>, <Line: +                            ", values=" + values +
>, <Line: +                 * A resolution for an annotation tokens. Any annotation is suppressed if its type is not available.
>, <Line: +                 * This conforms to the handling of the Java reflection API.
>, <Line: +                protected interface Resolution {
>, <Line: +                     * Returns {@code true} if the represented annotation could be resolved.
>, <Line: +                     *
>, <Line: +                     * @return {@code true} if the represented annotation could be resolved.
>, <Line: +                    boolean isResolved();
>, <Line: +                     * Returns the resolved annotation. This method throws an exception if this instance is not resolved.
>, <Line: +                     *
>, <Line: +                     * @return The resolved annotation. This method throws an exception if this instance is not resolved.
>, <Line: +                    AnnotationDescription resolve();
>, <Line: +                     * A simple resolved annotation.
>, <Line: +                    class Simple implements Resolution {
>, <Line: +                        /**
>, <Line: +                         * The represented annotation description.
>, <Line: +                         */
>, <Line: +                        private final AnnotationDescription annotationDescription;
>, <Line: +                        /**
>, <Line: +                         * Creates a new simple resolution.
>, <Line: +                         *
>, <Line: +                         * @param annotationDescription The represented annotation description.
>, <Line: +                         */
>, <Line: +                        protected Simple(AnnotationDescription annotationDescription) {
>, <Line: +                            this.annotationDescription = annotationDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean isResolved() {
>, <Line: +                            return true;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationDescription resolve() {
>, <Line: +                            return annotationDescription;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && annotationDescription.equals(((Simple) other).annotationDescription);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return annotationDescription.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.AnnotationToken.Resolution.Simple{" +
>, <Line: +                                    "annotationDescription=" + annotationDescription +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                     * An illegal resolution.
>, <Line: +                    class Illegal implements Resolution {
>, <Line: +                         * The annotation's binary type name.
>, <Line: +                        private final String annotationType;
>, <Line: +                         * Creates a new illegal resolution.
>, <Line: +                         * @param annotationType The annotation's binary type name.
>, <Line: +                        public Illegal(String annotationType) {
>, <Line: +                            this.annotationType = annotationType;
>, <Line: +                        public boolean isResolved() {
>, <Line: +                            return false;
>, <Line: +                        public AnnotationDescription resolve() {
>, <Line: +                            throw new IllegalStateException("Annotation type is not available: " + annotationType);
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && annotationType.equals(((Illegal) other).annotationType);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return annotationType.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypePool.Default.LazyTypeDescription.AnnotationToken.Resolution.Illegal{" +
>, <Line: +                                    "annotationType=" + annotationType +
>, <Line: +                                    '}';
>, <Line: +             * A token for representing collected data on a field.
>, <Line: +            protected static class FieldToken {
>, <Line: +                 * The name of the field.
>, <Line: +                private final String name;
>, <Line: +                 * The modifiers of the represented field.
>, <Line: +                private final int modifiers;
>, <Line: +                 * The descriptor of the field.
>, <Line: +                private final String descriptor;
>, <Line: +                 * The resolution of this field's generic type.
>, <Line: +                private final GenericTypeToken.Resolution.ForField signatureResolution;
>, <Line: +                 * A mapping of the field type's type annotation tokens.
>, <Line: +                private final Map<String, List<AnnotationToken>> typeAnnotationTokens;
>, <Line: +                 * A list of annotation tokens representing the annotations of the represented field.
>, <Line: +                private final List<AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * Creates a new field token.
>, <Line: +                 *
>, <Line: +                 * @param name                 The name of the field.
>, <Line: +                 * @param modifiers            The modifiers of the represented field.
>, <Line: +                 * @param descriptor           The descriptor of the field.
>, <Line: +                 * @param signatureResolution  The resolution of this field's generic type.
>, <Line: +                 * @param typeAnnotationTokens A mapping of the field type's type annotation tokens.
>, <Line: +                 * @param annotationTokens     A list of annotation tokens representing the annotations of the represented field.
>, <Line: +                 */
>, <Line: +                protected FieldToken(String name,
>, <Line: +                                     int modifiers,
>, <Line: +                                     String descriptor,
>, <Line: +                                     GenericTypeToken.Resolution.ForField signatureResolution,
>, <Line: +                                     Map<String, List<AnnotationToken>> typeAnnotationTokens,
>, <Line: +                                     List<AnnotationToken> annotationTokens) {
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.name = name;
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.signatureResolution = signatureResolution;
>, <Line: +                    this.typeAnnotationTokens = typeAnnotationTokens;
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                /**
>, <Line: +                 * Transforms this token into a lazy field description.
>, <Line: +                 *
>, <Line: +                 * @param lazyTypeDescription The lazy type description to attach this field description to.
>, <Line: +                 * @return A field description resembling this field token.
>, <Line: +                 */
>, <Line: +                private LazyFieldDescription toFieldDescription(LazyTypeDescription lazyTypeDescription) {
>, <Line: +                    return lazyTypeDescription.new LazyFieldDescription(name,
>, <Line: +                            modifiers,
>, <Line: +                            descriptor,
>, <Line: +                            signatureResolution,
>, <Line: +                            typeAnnotationTokens,
>, <Line: +                            annotationTokens);
>, <Line: +                    if (this == other) return true;
>, <Line: +                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                    FieldToken that = (FieldToken) other;
>, <Line: +                    return modifiers == that.modifiers
>, <Line: +                            && annotationTokens.equals(that.annotationTokens)
>, <Line: +                            && descriptor.equals(that.descriptor)
>, <Line: +                            && signatureResolution.equals(that.signatureResolution)
>, <Line: +                            && typeAnnotationTokens.equals(that.typeAnnotationTokens)
>, <Line: +                            && name.equals(that.name);
>, <Line: +                    int result = modifiers;
>, <Line: +                    result = 31 * result + name.hashCode();
>, <Line: +                    result = 31 * result + descriptor.hashCode();
>, <Line: +                    result = 31 * result + signatureResolution.hashCode();
>, <Line: +                    result = 31 * result + typeAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + annotationTokens.hashCode();
>, <Line: +                    return result;
>, <Line: +                    return "TypePool.Default.LazyTypeDescription.FieldToken{" +
>, <Line: +                            "modifiers=" + modifiers +
>, <Line: +                            ", name='" + name + '\'' +
>, <Line: +                            ", descriptor='" + descriptor + '\'' +
>, <Line: +                            ", signatureResolution=" + signatureResolution +
>, <Line: +                            ", typeAnnotationTokens=" + typeAnnotationTokens +
>, <Line: +                            ", annotationTokens=" + annotationTokens +
>, <Line: +             * A token for representing collected data on a method.
>, <Line: +            protected static class MethodToken {
>, <Line: +                 * The internal name of the represented method.
>, <Line: +                 * The modifiers of the represented method.
>, <Line: +                private final int modifiers;
>, <Line: +                 * The descriptor of the represented method.
>, <Line: +                private final String descriptor;
>, <Line: +                /**
>, <Line: +                 * The generic type resolution of this method.
>, <Line: +                 */
>, <Line: +                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
>, <Line: +                /**
>, <Line: +                 * An array of internal names of the exceptions of the represented method or {@code null} if there
>, <Line: +                 * are no such exceptions.
>, <Line: +                 */
>, <Line: +                private final String[] exceptionName;
>, <Line: +                /**
>, <Line: +                 * A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the type variables' type bounds' type annotation tokens by their indices and each variable's index.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the return type's type variable tokens.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<AnnotationToken>> returnTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the parameter types' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> parameterTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the exception types' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> exceptionTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of annotation tokens that are present on the represented method.
>, <Line: +                 */
>, <Line: +                private final List<AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * A map of parameter indices to tokens that represent their annotations.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, List<AnnotationToken>> parameterAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of tokens describing meta data of the method's parameters.
>, <Line: +                 */
>, <Line: +                private final List<ParameterToken> parameterTokens;
>, <Line: +                /**
>, <Line: +                 * The default value of this method or {@code null} if there is no such value.
>, <Line: +                 */
>, <Line: +                private final AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: +                /**
>, <Line: +                 * Creates a new method token.
>, <Line: +                 *
>, <Line: +                 * @param name                              The name of the method.
>, <Line: +                 * @param modifiers                         The modifiers of the represented method.
>, <Line: +                 * @param descriptor                        The descriptor of the represented method.
>, <Line: +                 * @param signatureResolution               The generic type resolution of this method.
>, <Line: +                 * @param exceptionName                     An array of internal names of the exceptions of the represented method or {@code null} if
>, <Line: +                 *                                          there are no such exceptions.
>, <Line: +                 * @param typeVariableAnnotationTokens      A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables' type bounds' type annotation tokens by their
>, <Line: +                 *                                          index and each variable's index.
>, <Line: +                 * @param returnTypeAnnotationTokens        A mapping of the return type's type variable tokens.
>, <Line: +                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types' type annotation tokens by their indices.
>, <Line: +                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types' type annotation tokens by their indices.
>, <Line: +                 * @param annotationTokens                  A list of annotation tokens that are present on the represented method.
>, <Line: +                 * @param parameterAnnotationTokens         A map of parameter indices to tokens that represent their annotations.
>, <Line: +                 * @param parameterTokens                   A list of tokens describing meta data of the method's parameters.
>, <Line: +                 * @param defaultValue                      The default value of this method or {@code null} if there is no such value.
>, <Line: +                 */
>, <Line: +                protected MethodToken(String name,
>, <Line: +                                      int modifiers,
>, <Line: +                                      String descriptor,
>, <Line: +                                      GenericTypeToken.Resolution.ForMethod signatureResolution,
>, <Line: +                                      String[] exceptionName,
>, <Line: +                                      Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens,
>, <Line: +                                      Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundAnnotationTokens,
>, <Line: +                                      Map<String, List<AnnotationToken>> returnTypeAnnotationTokens,
>, <Line: +                                      Map<Integer, Map<String, List<AnnotationToken>>> parameterTypeAnnotationTokens,
>, <Line: +                                      Map<Integer, Map<String, List<AnnotationToken>>> exceptionTypeAnnotationTokens,
>, <Line: +                                      List<AnnotationToken> annotationTokens,
>, <Line: +                                      Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
>, <Line: +                                      List<ParameterToken> parameterTokens,
>, <Line: +                                      AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.name = name;
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.signatureResolution = signatureResolution;
>, <Line: +                    this.exceptionName = exceptionName;
>, <Line: +                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
>, <Line: +                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
>, <Line: +                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
>, <Line: +                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
>, <Line: +                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                    this.parameterAnnotationTokens = parameterAnnotationTokens;
>, <Line: +                    this.parameterTokens = parameterTokens;
>, <Line: +                    this.defaultValue = defaultValue;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Transforms this method token to a method description that is attached to a lazy type description.
>, <Line: +                 *
>, <Line: +                 * @param lazyTypeDescription The lazy type description to attach this method description to.
>, <Line: +                 * @return A method description representing this field token.
>, <Line: +                 */
>, <Line: +                private MethodDescription.InDefinedShape toMethodDescription(LazyTypeDescription lazyTypeDescription) {
>, <Line: +                    return lazyTypeDescription.new LazyMethodDescription(name,
>, <Line: +                            modifiers,
>, <Line: +                            descriptor,
>, <Line: +                            signatureResolution,
>, <Line: +                            exceptionName,
>, <Line: +                            typeVariableAnnotationTokens,
>, <Line: +                            typeVariableBoundAnnotationTokens,
>, <Line: +                            returnTypeAnnotationTokens,
>, <Line: +                            parameterTypeAnnotationTokens,
>, <Line: +                            exceptionTypeAnnotationTokens,
>, <Line: +                            annotationTokens,
>, <Line: +                            parameterAnnotationTokens,
>, <Line: +                            parameterTokens,
>, <Line: +                            defaultValue);
>, <Line: +                    if (this == other) return true;
>, <Line: +                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                    MethodToken that = (MethodToken) other;
>, <Line: +                    return modifiers == that.modifiers
>, <Line: +                            && typeVariableAnnotationTokens.equals(that.typeVariableAnnotationTokens)
>, <Line: +                            && typeVariableBoundAnnotationTokens.equals(that.typeVariableBoundAnnotationTokens)
>, <Line: +                            && returnTypeAnnotationTokens.equals(that.returnTypeAnnotationTokens)
>, <Line: +                            && parameterTypeAnnotationTokens.equals(that.parameterTypeAnnotationTokens)
>, <Line: +                            && exceptionTypeAnnotationTokens.equals(that.exceptionTypeAnnotationTokens)
>, <Line: +                            && annotationTokens.equals(that.annotationTokens)
>, <Line: +                            && defaultValue.equals(that.defaultValue)
>, <Line: +                            && descriptor.equals(that.descriptor)
>, <Line: +                            && parameterTokens.equals(that.parameterTokens)
>, <Line: +                            && signatureResolution.equals(that.signatureResolution)
>, <Line: +                            && Arrays.equals(exceptionName, that.exceptionName)
>, <Line: +                            && name.equals(that.name)
>, <Line: +                            && parameterAnnotationTokens.equals(that.parameterAnnotationTokens);
>, <Line: +                    int result = modifiers;
>, <Line: +                    result = 31 * result + name.hashCode();
>, <Line: +                    result = 31 * result + descriptor.hashCode();
>, <Line: +                    result = 31 * result + signatureResolution.hashCode();
>, <Line: +                    result = 31 * result + Arrays.hashCode(exceptionName);
>, <Line: +                    result = 31 * result + typeVariableAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + typeVariableBoundAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + returnTypeAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + parameterTypeAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + exceptionTypeAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + annotationTokens.hashCode();
>, <Line: +                    result = 31 * result + parameterAnnotationTokens.hashCode();
>, <Line: +                    result = 31 * result + parameterTokens.hashCode();
>, <Line: +                    result = 31 * result + defaultValue.hashCode();
>, <Line: +                    return result;
>, <Line: +                    return "TypePool.Default.LazyTypeDescription.MethodToken{" +
>, <Line: +                            "modifiers=" + modifiers +
>, <Line: +                            ", name='" + name + '\'' +
>, <Line: +                            ", descriptor='" + descriptor + '\'' +
>, <Line: +                            ", signatureResolution=" + signatureResolution +
>, <Line: +                            ", exceptionName=" + Arrays.toString(exceptionName) +
>, <Line: +                            ", typeVariableAnnotationTokens=" + typeVariableAnnotationTokens +
>, <Line: +                            ", typeVariableBoundAnnotationTokens=" + typeVariableBoundAnnotationTokens +
>, <Line: +                            ", returnTypeAnnotationTokens=" + returnTypeAnnotationTokens +
>, <Line: +                            ", parameterTypeAnnotationTokens=" + parameterTypeAnnotationTokens +
>, <Line: +                            ", exceptionTypeAnnotationTokens=" + exceptionTypeAnnotationTokens +
>, <Line: +                            ", annotationTokens=" + annotationTokens +
>, <Line: +                            ", parameterAnnotationTokens=" + parameterAnnotationTokens +
>, <Line: +                            ", parameterTokens=" + parameterTokens +
>, <Line: +                            ", defaultValue=" + defaultValue +
>, <Line: +                 * A token representing a method's parameter.
>, <Line: +                protected static class ParameterToken {
>, <Line: +                     * Donates an unknown name of a parameter.
>, <Line: +                    protected static final String NO_NAME = null;
>, <Line: +                     * Donates an unknown modifier of a parameter.
>, <Line: +                    protected static final Integer NO_MODIFIERS = null;
>, <Line: +                     * The name of the parameter or {@code null} if no explicit name for this parameter is known.
>, <Line: +                    private final String name;
>, <Line: +                     * The modifiers of the parameter or {@code null} if no modifiers are known for this parameter.
>, <Line: +                    private final Integer modifiers;
>, <Line: +                    /**
>, <Line: +                     * Creates a parameter token for a parameter without an explicit name and without specific modifiers.
>, <Line: +                     */
>, <Line: +                    protected ParameterToken() {
>, <Line: +                        this(NO_NAME);
>, <Line: +                     * Creates a parameter token for a parameter with an explicit name and without specific modifiers.
>, <Line: +                     *
>, <Line: +                     * @param name The name of the parameter.
>, <Line: +                    protected ParameterToken(String name) {
>, <Line: +                        this(name, NO_MODIFIERS);
>, <Line: +                     * Creates a parameter token for a parameter with an explicit name and with specific modifiers.
>, <Line: +                     *
>, <Line: +                     * @param name      The name of the parameter.
>, <Line: +                     * @param modifiers The modifiers of the parameter.
>, <Line: +                    protected ParameterToken(String name, Integer modifiers) {
>, <Line: +                        this.name = name;
>, <Line: +                        this.modifiers = modifiers;
>, <Line: +                    }
>, <Line: +                     * Returns the name of the parameter or {@code null} if there is no such name.
>, <Line: +                     *
>, <Line: +                     * @return The name of the parameter or {@code null} if there is no such name.
>, <Line: +                    protected String getName() {
>, <Line: +                        return name;
>, <Line: +                    }
>, <Line: +                     * Returns the modifiers of the parameter or {@code null} if no modifiers are known.
>, <Line: +                     * @return The modifiers of the parameter or {@code null} if no modifiers are known.
>, <Line: +                    protected Integer getModifiers() {
>, <Line: +                        return modifiers;
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        if (this == other) return true;
>, <Line: +                        if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                        ParameterToken that = ((ParameterToken) other);
>, <Line: +                        return !(modifiers != null ? !modifiers.equals(that.modifiers) : that.modifiers != null)
>, <Line: +                                && !(name != null ? !name.equals(that.name) : that.name != null);
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = name != null ? name.hashCode() : 0;
>, <Line: +                        result = 31 * result + (modifiers != null ? modifiers.hashCode() : 0);
>, <Line: +                        return result;
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.LazyTypeDescription.MethodToken.ParameterToken{" +
>, <Line: +                                "name='" + name + '\'' +
>, <Line: +                                ", modifiers=" + modifiers +
>, <Line: +                                '}';
>, <Line: +             * A lazy description of an annotation that looks up types from a type pool when required.
>, <Line: +            private static class LazyAnnotationDescription extends AnnotationDescription.AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The type pool for looking up type references.
>, <Line: +                 */
>, <Line: +                protected final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * The type of this annotation.
>, <Line: +                 */
>, <Line: +                private final TypeDescription annotationType;
>, <Line: +                 * A map of annotation values by their property name.
>, <Line: +                protected final Map<String, AnnotationValue<?, ?>> values;
>, <Line: +                 * Creates a new lazy annotation description.
>, <Line: +                 * @param typePool       The type pool to be used for looking up linked types.
>, <Line: +                 * @param annotationType The annotation's type.
>, <Line: +                 * @param values         A map of annotation value names to their value representations.
>, <Line: +                private LazyAnnotationDescription(TypePool typePool, TypeDescription annotationType, Map<String, AnnotationValue<?, ?>> values) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.annotationType = annotationType;
>, <Line: +                    this.values = values;
>, <Line: +                }
>, <Line: +                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
>, <Line: +                 * a type that cannot be loaded from the type pool is ignored and not included in the list. If the provided
>, <Line: +                 * {@code tokens} are {@code null}, an empty list is returned.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to be used for looking up linked types.
>, <Line: +                 * @param tokens   The tokens to represent in the list.
>, <Line: +                 * @return A list of the loadable annotations.
>, <Line: +                protected static AnnotationList asListOfNullable(TypePool typePool, List<? extends AnnotationToken> tokens) {
>, <Line: +                    return tokens == null
>, <Line: +                            ? new AnnotationList.Empty()
>, <Line: +                            : asList(typePool, tokens);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
>, <Line: +                 * a type that cannot be loaded from the type pool is ignored and not included in the list.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to be used for looking up linked types.
>, <Line: +                 * @param tokens   The tokens to represent in the list.
>, <Line: +                 * @return A list of the loadable annotations.
>, <Line: +                 */
>, <Line: +                protected static AnnotationList asList(TypePool typePool, List<? extends AnnotationToken> tokens) {
>, <Line: +                    List<AnnotationDescription> annotationDescriptions = new ArrayList<AnnotationDescription>(tokens.size());
>, <Line: +                    for (AnnotationToken token : tokens) {
>, <Line: +                        AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);
>, <Line: +                        if (resolution.isResolved()) {
>, <Line: +                            annotationDescriptions.add(resolution.resolve());
>, <Line: +                        }
>, <Line: +                    return new AnnotationList.Explicit(annotationDescriptions);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Object getValue(MethodDescription.InDefinedShape methodDescription) {
>, <Line: +                    if (!methodDescription.getDeclaringType().asErasure().equals(annotationType)) {
>, <Line: +                        throw new IllegalArgumentException(methodDescription + " is not declared by " + getAnnotationType());
>, <Line: +                    AnnotationValue<?, ?> annotationValue = values.get(methodDescription.getName());
>, <Line: +                    Object value = annotationValue == null
>, <Line: +                            ? getAnnotationType().getDeclaredMethods().filter(is(methodDescription)).getOnly().getDefaultValue()
>, <Line: +                            : annotationValue.resolve();
>, <Line: +                    if (value == null) {
>, <Line: +                        throw new IllegalStateException(methodDescription + " is not defined on annotation");
>, <Line: +                    return PropertyDispatcher.of(value.getClass()).conditionalClone(value);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription getAnnotationType() {
>, <Line: +                    return annotationType;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public <T extends Annotation> Loadable<T> prepare(Class<T> annotationType) {
>, <Line: +                    if (!this.annotationType.represents(annotationType)) {
>, <Line: +                        throw new IllegalArgumentException(annotationType + " does not represent " + this.annotationType);
>, <Line: +                    return new Loadable<T>(typePool, annotationType, values);
>, <Line: +                 * A loadable version of a lazy annotation description.
>, <Line: +                 *
>, <Line: +                 * @param <S> The annotation type.
>, <Line: +                private static class Loadable<S extends Annotation> extends LazyAnnotationDescription implements AnnotationDescription.Loadable<S> {
>, <Line: +                     * The loaded annotation type.
>, <Line: +                    private final Class<S> annotationType;
>, <Line: +                     * Creates a new loadable version of a lazy annotation.
>, <Line: +                     * @param typePool       The type pool to be used for looking up linked types.
>, <Line: +                     * @param annotationType The annotation's loaded type.
>, <Line: +                     * @param values         A map of annotation value names to their value representations.
>, <Line: +                    private Loadable(TypePool typePool, Class<S> annotationType, Map<String, AnnotationValue<?, ?>> values) {
>, <Line: +                        super(typePool, new ForLoadedType(annotationType), values);
>, <Line: +                    public S load() throws ClassNotFoundException {
>, <Line: +                        return load(annotationType.getClassLoader());
>, <Line: +                    @SuppressWarnings("unchecked")
>, <Line: +                    public S load(ClassLoader classLoader) throws ClassNotFoundException {
>, <Line: +                        return (S) Proxy.newProxyInstance(classLoader,
>, <Line: +                                new Class<?>[]{annotationType},
>, <Line: +                                AnnotationInvocationHandler.of(classLoader, annotationType, values));
>, <Line: +                    public S loadSilent() {
>, <Line: +                        try {
>, <Line: +                            return load();
>, <Line: +                        } catch (ClassNotFoundException exception) {
>, <Line: +                            throw new IllegalStateException(ForLoadedAnnotation.ERROR_MESSAGE, exception);
>, <Line: +                        }
>, <Line: +                    public S loadSilent(ClassLoader classLoader) {
>, <Line: +                        try {
>, <Line: +                            return load(classLoader);
>, <Line: +                        } catch (ClassNotFoundException exception) {
>, <Line: +                            throw new IllegalStateException(ForLoadedAnnotation.ERROR_MESSAGE, exception);
>, <Line: +                        }
>, <Line: +             * An implementation of a {@link PackageDescription} that only
>, <Line: +             * loads its annotations on requirement.
>, <Line: +            private static class LazyPackageDescription extends PackageDescription.AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The type pool to use for look-ups.
>, <Line: +                 */
>, <Line: +                private final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * The name of the package.
>, <Line: +                 */
>, <Line: +                private final String name;
>, <Line: +                /**
>, <Line: +                 * Creates a new lazy package description.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to use for look-ups.
>, <Line: +                 * @param name     The name of the package.
>, <Line: +                 */
>, <Line: +                private LazyPackageDescription(TypePool typePool, String name) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.name = name;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    Resolution resolution = typePool.describe(name + "." + PackageDescription.PACKAGE_CLASS_NAME);
>, <Line: +                    return resolution.isResolved()
>, <Line: +                            ? resolution.resolve().getDeclaredAnnotations()
>, <Line: +                            : new AnnotationList.Empty();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String getName() {
>, <Line: +                    return name;
>, <Line: +                }
>, <Line: +             * A list that is constructing {@link LazyTypeDescription}s.
>, <Line: +            private static class LazyTypeList extends TypeList.AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The type pool to use for locating types.
>, <Line: +                 */
>, <Line: +                private final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * A list of type descriptors that this list represents.
>, <Line: +                 */
>, <Line: +                private final List<String> descriptors;
>, <Line: +                /**
>, <Line: +                 * Creates a list of lazy type descriptions.
>, <Line: +                 *
>, <Line: +                 * @param typePool    The type pool to use for locating types.
>, <Line: +                 * @param descriptors A list of type descriptors that this list represents.
>, <Line: +                 */
>, <Line: +                private LazyTypeList(TypePool typePool, List<String> descriptors) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.descriptors = descriptors;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription get(int index) {
>, <Line: +                    return TokenizedGenericType.toErasure(typePool, descriptors.get(index));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int size() {
>, <Line: +                    return descriptors.size();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String[] toInternalNames() {
>, <Line: +                    String[] internalName = new String[descriptors.size()];
>, <Line: +                    int index = 0;
>, <Line: +                    for (String descriptor : descriptors) {
>, <Line: +                        internalName[index++] = Type.getType(descriptor).getInternalName();
>, <Line: +                    }
>, <Line: +                    return internalName.length == 0
>, <Line: +                            ? NO_INTERFACES
>, <Line: +                            : internalName;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int getStackSize() {
>, <Line: +                    int stackSize = 0;
>, <Line: +                    for (String descriptor : descriptors) {
>, <Line: +                        stackSize += Type.getType(descriptor).getSize();
>, <Line: +                    }
>, <Line: +                    return stackSize;
>, <Line: +                }
>, <Line: +             * A representation of a generic type that is described by a {@link GenericTypeToken}.
>, <Line: +            private static class TokenizedGenericType extends Generic.LazyProjection {
>, <Line: +                /**
>, <Line: +                 * The type pool to use for locating referenced types.
>, <Line: +                 */
>, <Line: +                private final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * The token that describes the represented generic type.
>, <Line: +                 */
>, <Line: +                private final GenericTypeToken genericTypeToken;
>, <Line: +                /**
>, <Line: +                 * A descriptor of the generic type's raw type.
>, <Line: +                 */
>, <Line: +                private final String rawTypeDescriptor;
>, <Line: +                /**
>, <Line: +                 * The tokenized type's type annotation tokens.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<AnnotationToken>> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * The closest type variable source of this generic type's declaration context.
>, <Line: +                 */
>, <Line: +                private final TypeVariableSource typeVariableSource;
>, <Line: +                /**
>, <Line: +                 * Creates a new tokenized generic type.
>, <Line: +                 *
>, <Line: +                 * @param typePool           The type pool to use for locating referenced types.
>, <Line: +                 * @param genericTypeToken   The token that describes the represented generic type.
>, <Line: +                 * @param rawTypeDescriptor  A descriptor of the generic type's erasure.
>, <Line: +                 * @param annotationTokens   The tokenized type's type annotation tokens.
>, <Line: +                 * @param typeVariableSource The closest type variable source of this generic type's declaration context.
>, <Line: +                 */
>, <Line: +                protected TokenizedGenericType(TypePool typePool,
>, <Line: +                                               GenericTypeToken genericTypeToken,
>, <Line: +                                               String rawTypeDescriptor,
>, <Line: +                                               Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                               TypeVariableSource typeVariableSource) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.genericTypeToken = genericTypeToken;
>, <Line: +                    this.rawTypeDescriptor = rawTypeDescriptor;
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                    this.typeVariableSource = typeVariableSource;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a new generic type description for a tokenized generic type.
>, <Line: +                 *
>, <Line: +                 * @param typePool           The type pool to use for locating referenced types.
>, <Line: +                 * @param genericTypeToken   The token that describes the represented generic type.
>, <Line: +                 * @param rawTypeDescriptor  A descriptor of the generic type's erasure.
>, <Line: +                 * @param annotationTokens   The tokenized type's type annotation tokens or {@code null} if no such annotations are defined.
>, <Line: +                 * @param typeVariableSource The closest type variable source of this generic type's declaration context.
>, <Line: +                 * @return A suitable genric type.
>, <Line: +                 */
>, <Line: +                protected static Generic of(TypePool typePool,
>, <Line: +                                            GenericTypeToken genericTypeToken,
>, <Line: +                                            String rawTypeDescriptor,
>, <Line: +                                            Map<String, List<AnnotationToken>> annotationTokens,
>, <Line: +                                            TypeVariableSource typeVariableSource) {
>, <Line: +                    return new TokenizedGenericType(typePool,
>, <Line: +                            genericTypeToken,
>, <Line: +                            rawTypeDescriptor,
>, <Line: +                            annotationTokens == null
>, <Line: +                                    ? Collections.<String, List<AnnotationToken>>emptyMap()
>, <Line: +                                    : annotationTokens,
>, <Line: +                            typeVariableSource);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a type description from a descriptor by looking up the corresponding type.
>, <Line: +                 *
>, <Line: +                 * @param typePool   The type pool to use for locating a type.
>, <Line: +                 * @param descriptor The descriptor to interpret.
>, <Line: +                 * @return A description of the type represented by the descriptor.
>, <Line: +                 */
>, <Line: +                protected static TypeDescription toErasure(TypePool typePool, String descriptor) {
>, <Line: +                    Type type = Type.getType(descriptor);
>, <Line: +                    return typePool.describe(type.getSort() == Type.ARRAY
>, <Line: +                            ? type.getInternalName().replace('/', '.')
>, <Line: +                            : type.getClassName()).resolve();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Generic resolve() {
>, <Line: +                    return genericTypeToken.toGenericType(typePool, typeVariableSource, GenericTypeToken.EMPTY_TYPE_PATH, annotationTokens);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription asErasure() {
>, <Line: +                    return toErasure(typePool, rawTypeDescriptor);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(GenericTypeToken.EMPTY_TYPE_PATH));
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A tokenized list of generic types.
>, <Line: +                 */
>, <Line: +                protected static class TokenList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The type pool to use for locating types.
>, <Line: +                     */
>, <Line: +                    private final TypePool typePool;
>, <Line: +                    /**
>, <Line: +                     * Type tokens that describe the represented generic types.
>, <Line: +                     */
>, <Line: +                    private final List<GenericTypeToken> genericTypeTokens;
>, <Line: +                    /**
>, <Line: +                     * A list of the generic types' erasures.
>, <Line: +                     */
>, <Line: +                    private final List<String> rawTypeDescriptors;
>, <Line: +                    /**
>, <Line: +                     * The closest type variable source of this generic type's declaration context.
>, <Line: +                     */
>, <Line: +                    private final TypeVariableSource typeVariableSource;
>, <Line: +                    /**
>, <Line: +                     * A mapping of each type's type annotation tokens by its index.
>, <Line: +                     */
>, <Line: +                    private final Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens;
>, <Line: +                    /**
>, <Line: +                     * Creates a list of tokenized generic types.
>, <Line: +                     *
>, <Line: +                     * @param typePool           The type pool to use for locating type descriptions.
>, <Line: +                     * @param genericTypeTokens  A list of tokens describing the represented generic types.
>, <Line: +                     * @param annotationTokens   A mapping of each type's type annotation tokens by its index.
>, <Line: +                     * @param rawTypeDescriptors A list of the generic types' erasures.
>, <Line: +                     * @param typeVariableSource The closest type variable source of this generic type's declaration context.
>, <Line: +                     */
>, <Line: +                    private TokenList(TypePool typePool,
>, <Line: +                                      List<GenericTypeToken> genericTypeTokens,
>, <Line: +                                      Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                      List<String> rawTypeDescriptors,
>, <Line: +                                      TypeVariableSource typeVariableSource) {
>, <Line: +                        this.typePool = typePool;
>, <Line: +                        this.genericTypeTokens = genericTypeTokens;
>, <Line: +                        this.annotationTokens = annotationTokens;
>, <Line: +                        this.rawTypeDescriptors = rawTypeDescriptors;
>, <Line: +                        this.typeVariableSource = typeVariableSource;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return index < genericTypeTokens.size()
>, <Line: +                                ? TokenizedGenericType.of(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), annotationTokens.get(index), typeVariableSource)
>, <Line: +                                : TokenizedGenericType.toErasure(typePool, rawTypeDescriptors.get(index)).asGenericType();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return rawTypeDescriptors.size();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeList asErasures() {
>, <Line: +                        return new LazyTypeList(typePool, rawTypeDescriptors);
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A list of tokenized type variables.
>, <Line: +                 */
>, <Line: +                protected static class TypeVariableList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The type pool to use for locating types.
>, <Line: +                     */
>, <Line: +                    private final TypePool typePool;
>, <Line: +                    /**
>, <Line: +                     * Type tokens that describe the represented type variables.
>, <Line: +                     */
>, <Line: +                    private final List<GenericTypeToken.OfFormalTypeVariable> typeVariables;
>, <Line: +                    /**
>, <Line: +                     * The type variable source of the represented type variables.
>, <Line: +                     */
>, <Line: +                    private final TypeVariableSource typeVariableSource;
>, <Line: +                    /**
>, <Line: +                     * A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                     */
>, <Line: +                    private final Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens;
>, <Line: +                    /**
>, <Line: +                     * A mapping of the type variables' bound types' annotation tokens by their indices and each type variable's index..
>, <Line: +                     */
>, <Line: +                    private final Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens;
>, <Line: +                    /**
>, <Line: +                     * Creates a list of type variables.
>, <Line: +                     *
>, <Line: +                     * @param typePool              The type pool to use for locating types.
>, <Line: +                     * @param typeVariables         Type tokens that describe the represented generic types.
>, <Line: +                     * @param typeVariableSource    The type variable source of the represented type variables.
>, <Line: +                     * @param annotationTokens      A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                     * @param boundAnnotationTokens A mapping of the type variables' bound types' annotation tokens by their indices
>, <Line: +                     *                              and each type variable's index.
>, <Line: +                     */
>, <Line: +                    protected TypeVariableList(TypePool typePool,
>, <Line: +                                               List<GenericTypeToken.OfFormalTypeVariable> typeVariables,
>, <Line: +                                               TypeVariableSource typeVariableSource,
>, <Line: +                                               Map<Integer, Map<String, List<AnnotationToken>>> annotationTokens,
>, <Line: +                                               Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> boundAnnotationTokens) {
>, <Line: +                        this.typePool = typePool;
>, <Line: +                        this.typeVariables = typeVariables;
>, <Line: +                        this.typeVariableSource = typeVariableSource;
>, <Line: +                        this.annotationTokens = annotationTokens;
>, <Line: +                        this.boundAnnotationTokens = boundAnnotationTokens;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return typeVariables.get(index).toGenericType(typePool, typeVariableSource, annotationTokens.get(index), boundAnnotationTokens.get(index));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return typeVariables.size();
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A lazy description of a non-well-defined described generic type.
>, <Line: +                 */
>, <Line: +                protected static class Malformed extends LazyProjection {
>, <Line: +                    /**
>, <Line: +                     * The type pool to use for locating types.
>, <Line: +                     */
>, <Line: +                    private final TypePool typePool;
>, <Line: +                    /**
>, <Line: +                     * The descriptor of the type erasure.
>, <Line: +                     */
>, <Line: +                    private final String rawTypeDescriptor;
>, <Line: +                    /**
>, <Line: +                     * Creates a lazy description of a non-well-defined described generic type.
>, <Line: +                     *
>, <Line: +                     * @param typePool          The type pool to use for locating types.
>, <Line: +                     * @param rawTypeDescriptor The descriptor of the type erasure.
>, <Line: +                     */
>, <Line: +                    protected Malformed(TypePool typePool, String rawTypeDescriptor) {
>, <Line: +                        this.typePool = typePool;
>, <Line: +                        this.rawTypeDescriptor = rawTypeDescriptor;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected Generic resolve() {
>, <Line: +                        throw new GenericSignatureFormatError();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeDescription asErasure() {
>, <Line: +                        return toErasure(typePool, rawTypeDescriptor);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationList getDeclaredAnnotations() {
>, <Line: +                        throw new GenericSignatureFormatError();
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A tokenized list of non-well-defined generic types.
>, <Line: +                     */
>, <Line: +                    protected static class TokenList extends TypeList.Generic.AbstractBase {
>, <Line: +                        /**
>, <Line: +                         * The type pool to use for locating types.
>, <Line: +                         */
>, <Line: +                        private final TypePool typePool;
>, <Line: +                        /**
>, <Line: +                         * A list of descriptors of the list's types' erasures.
>, <Line: +                         */
>, <Line: +                        private final List<String> rawTypeDescriptors;
>, <Line: +                        /**
>, <Line: +                         * Creates a new tokenized list of generic types.
>, <Line: +                         *
>, <Line: +                         * @param typePool           The type pool to use for locating types.
>, <Line: +                         * @param rawTypeDescriptors A list of descriptors of the list's types' erasures.
>, <Line: +                         */
>, <Line: +                        protected TokenList(TypePool typePool, List<String> rawTypeDescriptors) {
>, <Line: +                            this.typePool = typePool;
>, <Line: +                            this.rawTypeDescriptors = rawTypeDescriptors;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Generic get(int index) {
>, <Line: +                            return new Malformed(typePool, rawTypeDescriptors.get(index));
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int size() {
>, <Line: +                            return rawTypeDescriptors.size();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList asErasures() {
>, <Line: +                            return new LazyTypeList(typePool, rawTypeDescriptors);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            /**
>, <Line: +             * A lazy field description that only resolved type references when required.
>, <Line: +             */
>, <Line: +            private class LazyFieldDescription extends FieldDescription.InDefinedShape.AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The name of the field.
>, <Line: +                 */
>, <Line: +                private final String name;
>, <Line: +                /**
>, <Line: +                 * The modifiers of the field.
>, <Line: +                 */
>, <Line: +                private final int modifiers;
>, <Line: +                /**
>, <Line: +                 * The descriptor of this field's type.
>, <Line: +                 */
>, <Line: +                private final String descriptor;
>, <Line: +                /**
>, <Line: +                 * A resolution of this field's generic type.
>, <Line: +                 */
>, <Line: +                private final GenericTypeToken.Resolution.ForField signatureResolution;
>, <Line: +                /**
>, <Line: +                 * A mapping of the field type's type annotation tokens.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<AnnotationToken>> typeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of annotation descriptions of this field.
>, <Line: +                 */
>, <Line: +                private final List<AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * Creates a new lazy field description.
>, <Line: +                 *
>, <Line: +                 * @param name                 The name of the field.
>, <Line: +                 * @param modifiers            The modifiers of the field.
>, <Line: +                 * @param descriptor           The descriptor of this field's type.
>, <Line: +                 * @param signatureResolution  A resolution of this field's generic type.
>, <Line: +                 * @param typeAnnotationTokens A mapping of the field type's type annotation tokens.
>, <Line: +                 * @param annotationTokens     A list of annotation descriptions of this field.
>, <Line: +                 */
>, <Line: +                private LazyFieldDescription(String name,
>, <Line: +                                             int modifiers,
>, <Line: +                                             String descriptor,
>, <Line: +                                             GenericTypeToken.Resolution.ForField signatureResolution,
>, <Line: +                                             Map<String, List<AnnotationToken>> typeAnnotationTokens,
>, <Line: +                                             List<AnnotationToken> annotationTokens) {
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.name = name;
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.signatureResolution = signatureResolution;
>, <Line: +                    this.typeAnnotationTokens = typeAnnotationTokens;
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Generic getType() {
>, <Line: +                    return signatureResolution.resolveFieldType(descriptor, typePool, typeAnnotationTokens, this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String getName() {
>, <Line: +                    return name;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription getDeclaringType() {
>, <Line: +                    return LazyTypeDescription.this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int getModifiers() {
>, <Line: +                    return modifiers;
>, <Line: +                }
>, <Line: +            /**
>, <Line: +             * A lazy representation of a method that resolves references to types only on demand.
>, <Line: +             */
>, <Line: +            private class LazyMethodDescription extends MethodDescription.InDefinedShape.AbstractBase {
>, <Line: +                /**
>, <Line: +                 * The internal name of this method.
>, <Line: +                 */
>, <Line: +                private final String internalName;
>, <Line: +                /**
>, <Line: +                 * The modifiers of this method.
>, <Line: +                 */
>, <Line: +                private final int modifiers;
>, <Line: +                /**
>, <Line: +                 * The descriptor of the return type.
>, <Line: +                 */
>, <Line: +                private final String returnTypeDescriptor;
>, <Line: +                /**
>, <Line: +                 * The generic type token of this method.
>, <Line: +                 */
>, <Line: +                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
>, <Line: +                /**
>, <Line: +                 * A list of type descriptions of this method's parameters.
>, <Line: +                 */
>, <Line: +                private final List<String> parameterTypeDescriptors;
>, <Line: +                /**
>, <Line: +                 * A list of type descriptions of this method's exception types.
>, <Line: +                 */
>, <Line: +                private final List<String> exceptionTypeDescriptors;
>, <Line: +                /**
>, <Line: +                 * A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the type variables' type bounds' type annotation tokens by their indices and each variable's index.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the return type's type variable tokens.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<AnnotationToken>> returnTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the parameter types' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> parameterTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the exception types' type annotation tokens by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<AnnotationToken>>> exceptionTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * The annotation tokens representing the method's annotations.
>, <Line: +                 */
>, <Line: +                private final List<AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * The annotation tokens representing the parameter's annotation. Every index can
>, <Line: +                 * contain {@code null} if a parameter does not define any annotations.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, List<AnnotationToken>> parameterAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * An array of parameter names which may be {@code null} if no explicit name is known for a parameter.
>, <Line: +                 */
>, <Line: +                private final String[] parameterNames;
>, <Line: +                /**
>, <Line: +                 * An array of parameter modifiers which may be {@code null} if no modifiers is known.
>, <Line: +                 */
>, <Line: +                private final Integer[] parameterModifiers;
>, <Line: +                /**
>, <Line: +                 * The default value of this method or {@code null} if no such value exists.
>, <Line: +                 */
>, <Line: +                private final AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: +                /**
>, <Line: +                 * Creates a new lazy method description.
>, <Line: +                 *
>, <Line: +                 * @param internalName                      The internal name of this method.
>, <Line: +                 * @param modifiers                         The modifiers of the represented method.
>, <Line: +                 * @param methodDescriptor                  The method descriptor of this method.
>, <Line: +                 * @param signatureResolution               The generic type token of this method.
>, <Line: +                 * @param exceptionTypeInternalName         The internal names of the exceptions that are declared by this
>, <Line: +                 *                                          method or {@code null} if no exceptions are declared by this
>, <Line: +                 *                                          method.
>, <Line: +                 * @param typeVariableAnnotationTokens      A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables' type bounds' type annotation tokens by their
>, <Line: +                 *                                          index and each variable's index.
>, <Line: +                 * @param returnTypeAnnotationTokens        A mapping of the return type's type variable tokens.
>, <Line: +                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types' type annotation tokens by their indices.
>, <Line: +                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types' type annotation tokens by their indices.
>, <Line: +                 * @param annotationTokens                  The annotation tokens representing the method's annotations.
>, <Line: +                 * @param parameterAnnotationTokens         The annotation tokens representing the parameter's annotation. Every
>, <Line: +                 *                                          index can contain {@code null} if a parameter does not define any annotations.
>, <Line: +                 * @param parameterTokens                   A list of parameter tokens which might be empty or even out of sync
>, <Line: +                 *                                          with the actual parameters if the debugging information found in a
>, <Line: +                 *                                          class was corrupt.
>, <Line: +                 * @param defaultValue                      The default value of this method or {@code null} if there is no
>, <Line: +                 */
>, <Line: +                private LazyMethodDescription(String internalName,
>, <Line: +                                              int modifiers,
>, <Line: +                                              String methodDescriptor,
>, <Line: +                                              GenericTypeToken.Resolution.ForMethod signatureResolution,
>, <Line: +                                              String[] exceptionTypeInternalName,
>, <Line: +                                              Map<Integer, Map<String, List<AnnotationToken>>> typeVariableAnnotationTokens,
>, <Line: +                                              Map<Integer, Map<Integer, Map<String, List<AnnotationToken>>>> typeVariableBoundAnnotationTokens,
>, <Line: +                                              Map<String, List<AnnotationToken>> returnTypeAnnotationTokens,
>, <Line: +                                              Map<Integer, Map<String, List<AnnotationToken>>> parameterTypeAnnotationTokens,
>, <Line: +                                              Map<Integer, Map<String, List<AnnotationToken>>> exceptionTypeAnnotationTokens,
>, <Line: +                                              List<AnnotationToken> annotationTokens,
>, <Line: +                                              Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
>, <Line: +                                              List<MethodToken.ParameterToken> parameterTokens,
>, <Line: +                                              AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.internalName = internalName;
>, <Line: +                    Type methodType = Type.getMethodType(methodDescriptor);
>, <Line: +                    Type returnType = methodType.getReturnType();
>, <Line: +                    Type[] parameterType = methodType.getArgumentTypes();
>, <Line: +                    returnTypeDescriptor = returnType.getDescriptor();
>, <Line: +                    parameterTypeDescriptors = new ArrayList<String>(parameterType.length);
>, <Line: +                    for (Type type : parameterType) {
>, <Line: +                        parameterTypeDescriptors.add(type.getDescriptor());
>, <Line: +                    }
>, <Line: +                    this.signatureResolution = signatureResolution;
>, <Line: +                    if (exceptionTypeInternalName == null) {
>, <Line: +                        exceptionTypeDescriptors = Collections.emptyList();
>, <Line: +                    } else {
>, <Line: +                        exceptionTypeDescriptors = new ArrayList<String>(exceptionTypeInternalName.length);
>, <Line: +                        for (String anExceptionTypeInternalName : exceptionTypeInternalName) {
>, <Line: +                            exceptionTypeDescriptors.add(Type.getObjectType(anExceptionTypeInternalName).getDescriptor());
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
>, <Line: +                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
>, <Line: +                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
>, <Line: +                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
>, <Line: +                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
>, <Line: +                    this.annotationTokens = annotationTokens;
>, <Line: +                    this.parameterAnnotationTokens = parameterAnnotationTokens;
>, <Line: +                    parameterNames = new String[parameterType.length];
>, <Line: +                    parameterModifiers = new Integer[parameterType.length];
>, <Line: +                    if (parameterTokens.size() == parameterType.length) {
>, <Line: +                        int index = 0;
>, <Line: +                        for (MethodToken.ParameterToken parameterToken : parameterTokens) {
>, <Line: +                            parameterNames[index] = parameterToken.getName();
>, <Line: +                            parameterModifiers[index] = parameterToken.getModifiers();
>, <Line: +                            index++;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    this.defaultValue = defaultValue;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Generic getReturnType() {
>, <Line: +                    return signatureResolution.resolveReturnType(returnTypeDescriptor, typePool, returnTypeAnnotationTokens, this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeList.Generic getExceptionTypes() {
>, <Line: +                    return signatureResolution.resolveExceptionTypes(exceptionTypeDescriptors, typePool, exceptionTypeAnnotationTokens, this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
>, <Line: +                    return new LazyParameterList();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return LazyAnnotationDescription.asList(typePool, annotationTokens);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String getInternalName() {
>, <Line: +                    return internalName;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription getDeclaringType() {
>, <Line: +                    return LazyTypeDescription.this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int getModifiers() {
>, <Line: +                    return modifiers;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeList.Generic getTypeVariables() {
>, <Line: +                    return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundAnnotationTokens);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Object getDefaultValue() {
>, <Line: +                    return defaultValue == null
>, <Line: +                            ? NO_DEFAULT_VALUE
>, <Line: +                            : defaultValue.resolve();
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A lazy list of parameter descriptions for the enclosing method description.
>, <Line: +                 */
>, <Line: +                private class LazyParameterList extends ParameterList.AbstractBase<ParameterDescription.InDefinedShape> {
>, <Line: +                    @Override
>, <Line: +                    public ParameterDescription.InDefinedShape get(int index) {
>, <Line: +                        return new LazyParameterDescription(index);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean hasExplicitMetaData() {
>, <Line: +                        for (int i = 0; i < size(); i++) {
>, <Line: +                            if (parameterNames[i] == null || parameterModifiers[i] == null) {
>, <Line: +                                return false;
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        return true;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return parameterTypeDescriptors.size();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeList.Generic asTypeList() {
>, <Line: +                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this);
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A lazy description of a parameters of the enclosing method.
>, <Line: +                 */
>, <Line: +                private class LazyParameterDescription extends ParameterDescription.InDefinedShape.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The index of the described parameter.
>, <Line: +                     */
>, <Line: +                    private final int index;
>, <Line: +                    /**
>, <Line: +                     * Creates a new description for a given parameter of the enclosing method.
>, <Line: +                     *
>, <Line: +                     * @param index The index of the described parameter.
>, <Line: +                     */
>, <Line: +                    protected LazyParameterDescription(int index) {
>, <Line: +                        this.index = index;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public MethodDescription.InDefinedShape getDeclaringMethod() {
>, <Line: +                        return LazyMethodDescription.this;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int getIndex() {
>, <Line: +                        return index;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean isNamed() {
>, <Line: +                        return parameterNames[index] != null;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean hasModifiers() {
>, <Line: +                        return parameterModifiers[index] != null;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String getName() {
>, <Line: +                        return isNamed()
>, <Line: +                                ? parameterNames[index]
>, <Line: +                                : super.getName();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int getModifiers() {
>, <Line: +                        return hasModifiers()
>, <Line: +                                ? parameterModifiers[index]
>, <Line: +                                : super.getModifiers();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic getType() {
>, <Line: +                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this).get(index);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationList getDeclaredAnnotations() {
>, <Line: +                        return LazyAnnotationDescription.asListOfNullable(typePool, parameterAnnotationTokens.get(index));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A type extractor reads a class file and collects data that is relevant to create a type description.
>, <Line: +         */
>, <Line: +        protected class TypeExtractor extends ClassVisitor {
>, <Line: +            /**
>, <Line: +             * A mapping of the super types' type annotation tokens by their indices.
>, <Line: +             */
>, <Line: +            private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> superTypeAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A mapping of the type variables' type annotation tokens by their indices.
>, <Line: +             */
>, <Line: +            private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> typeVariableAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A mapping of the type variables' bounds' type annotation tokens by their indices and each variables index.
>, <Line: +             */
>, <Line: +            private final Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> typeVariableBoundsAnnotationTokens;
>, <Line: +            /**
>, <Line: +             * A list of annotation tokens describing annotations that are found on the visited type.
>, <Line: +             */
>, <Line: +            private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: +            /**
>, <Line: +             * A list of field tokens describing fields that are found on the visited type.
>, <Line: +             */
>, <Line: +            private final List<LazyTypeDescription.FieldToken> fieldTokens;
>, <Line: +            /**
>, <Line: +             * A list of method tokens describing annotations that are found on the visited type.
>, <Line: +             */
>, <Line: +            private final List<LazyTypeDescription.MethodToken> methodTokens;
>, <Line: +            /**
>, <Line: +             * The modifiers found for this type.
>, <Line: +             */
>, <Line: +            private int modifiers;
>, <Line: +            /**
>, <Line: +             * The internal name found for this type.
>, <Line: +             */
>, <Line: +            private String internalName;
>, <Line: +            /**
>, <Line: +             * The internal name of the super type found for this type or {@code null} if no such type exists.
>, <Line: +             */
>, <Line: +            private String superTypeName;
>, <Line: +            /**
>, <Line: +             * The generic signature of the type or {@code null} if it is not generic.
>, <Line: +             */
>, <Line: +            private String genericSignature;
>, <Line: +            /**
>, <Line: +             * A list of internal names of interfaces implemented by this type or {@code null} if no interfaces
>, <Line: +             * are implemented.
>, <Line: +             */
>, <Line: +            private String[] interfaceName;
>, <Line: +            /**
>, <Line: +             * {@code true} if this type was found to represent an anonymous type.
>, <Line: +             */
>, <Line: +            private boolean anonymousType;
>, <Line: +            /**
>, <Line: +             * The declaration context found for this type.
>, <Line: +             */
>, <Line: +            private LazyTypeDescription.DeclarationContext declarationContext;
>, <Line: +            /**
>, <Line: +             * A list of descriptors representing the types that are declared by the parsed type.
>, <Line: +             */
>, <Line: +            private final List<String> declaredTypes;
>, <Line: +            /**
>, <Line: +             * Creates a new type extractor.
>, <Line: +             */
>, <Line: +            protected TypeExtractor() {
>, <Line: +                super(Opcodes.ASM5);
>, <Line: +                superTypeAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                typeVariableAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                typeVariableBoundsAnnotationTokens = new HashMap<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>>();
>, <Line: +                annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: +                fieldTokens = new ArrayList<LazyTypeDescription.FieldToken>();
>, <Line: +                methodTokens = new ArrayList<LazyTypeDescription.MethodToken>();
>, <Line: +                anonymousType = false;
>, <Line: +                declarationContext = LazyTypeDescription.DeclarationContext.SelfDeclared.INSTANCE;
>, <Line: +                declaredTypes = new ArrayList<String>();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The received value is never modified")
>, <Line: +            public void visit(int classFileVersion,
>, <Line: +                              int modifiers,
>, <Line: +                              String internalName,
>, <Line: +                              String genericSignature,
>, <Line: +                              String superTypeName,
>, <Line: +                              String[] interfaceName) {
>, <Line: +                this.modifiers = modifiers;
>, <Line: +                this.internalName = internalName;
>, <Line: +                this.genericSignature = genericSignature;
>, <Line: +                this.superTypeName = superTypeName;
>, <Line: +                this.interfaceName = interfaceName;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void visitOuterClass(String typeName, String methodName, String methodDescriptor) {
>, <Line: +                if (methodName != null) {
>, <Line: +                    declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInMethod(typeName, methodName, methodDescriptor);
>, <Line: +                } else if (typeName != null) {
>, <Line: +                    declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInType(typeName);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
>, <Line: +                if (internalName.equals(this.internalName)) {
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    if (innerName == null) {
>, <Line: +                        anonymousType = true;
>, <Line: +                    }
>, <Line: +                    // Older Java compilers do not add the outer class attribute.
>, <Line: +                    if (outerName != null && declarationContext.isSelfDeclared()) {
>, <Line: +                        declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInType(outerName);
>, <Line: +                    }
>, <Line: +                } else if (outerName != null && innerName != null && internalName.equals(this.internalName + "$" + innerName)) {
>, <Line: +                    declaredTypes.add("L" + internalName + ";");
>, <Line: +                }
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
>, <Line: +                AnnotationRegistrant annotationRegistrant;
>, <Line: +                TypeReference typeReference = new TypeReference(rawTypeReference);
>, <Line: +                switch (typeReference.getSort()) {
>, <Line: +                    case TypeReference.CLASS_EXTENDS:
>, <Line: +                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,
>, <Line: +                                typePath,
>, <Line: +                                typeReference.getSuperTypeIndex(),
>, <Line: +                                superTypeAnnotationTokens);
>, <Line: +                        break;
>, <Line: +                    case TypeReference.CLASS_TYPE_PARAMETER:
>, <Line: +                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,
>, <Line: +                                typePath,
>, <Line: +                                typeReference.getTypeParameterIndex(),
>, <Line: +                                typeVariableAnnotationTokens);
>, <Line: +                        break;
>, <Line: +                    case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
>, <Line: +                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor,
>, <Line: +                                typePath,
>, <Line: +                                typeReference.getTypeParameterBoundIndex(),
>, <Line: +                                typeReference.getTypeParameterIndex(),
>, <Line: +                                typeVariableBoundsAnnotationTokens);
>, <Line: +                        break;
>, <Line: +                    default:
>, <Line: +                        throw new IllegalArgumentException("Unexpected type reference: " + typeReference.getSort());
>, <Line: +                }
>, <Line: +                return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: +                return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public FieldVisitor visitField(int modifiers, String internalName, String descriptor, String genericSignature, Object defaultValue) {
>, <Line: +                return new FieldExtractor(modifiers, internalName, descriptor, genericSignature);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, String genericSignature, String[] exceptionName) {
>, <Line: +                return internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)
>, <Line: +                        ? IGNORE_METHOD
>, <Line: +                        : new MethodExtractor(modifiers, internalName, descriptor, genericSignature, exceptionName);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a type description from all data that is currently collected. This method should only be invoked
>, <Line: +             * after a class file was parsed fully.
>, <Line: +             *
>, <Line: +             * @return A type description reflecting the data that was collected by this instance.
>, <Line: +             */
>, <Line: +            protected TypeDescription toTypeDescription() {
>, <Line: +                return new LazyTypeDescription(Default.this,
>, <Line: +                        modifiers,
>, <Line: +                        internalName,
>, <Line: +                        superTypeName,
>, <Line: +                        interfaceName,
>, <Line: +                        GenericTypeExtractor.ForSignature.OfType.extract(genericSignature),
>, <Line: +                        declarationContext,
>, <Line: +                        declaredTypes,
>, <Line: +                        anonymousType,
>, <Line: +                        superTypeAnnotationTokens,
>, <Line: +                        typeVariableAnnotationTokens,
>, <Line: +                        typeVariableBoundsAnnotationTokens,
>, <Line: +                        annotationTokens,
>, <Line: +                        fieldTokens,
>, <Line: +                        methodTokens);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String toString() {
>, <Line: +                return "TypePool.Default.TypeExtractor{" +
>, <Line: +                        "typePool=" + Default.this +
>, <Line: +                        ", annotationTokens=" + annotationTokens +
>, <Line: +                        ", fieldTokens=" + fieldTokens +
>, <Line: +                        ", methodTokens=" + methodTokens +
>, <Line: +                        ", modifiers=" + modifiers +
>, <Line: +                        ", internalName='" + internalName + '\'' +
>, <Line: +                        ", superTypeName='" + superTypeName + '\'' +
>, <Line: +                        ", genericSignature='" + genericSignature + '\'' +
>, <Line: +                        ", interfaceName=" + Arrays.toString(interfaceName) +
>, <Line: +                        ", anonymousType=" + anonymousType +
>, <Line: +                        ", declarationContext=" + declarationContext +
>, <Line: +                        '}';
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * An annotation extractor reads an annotation found in a class field an collects data that
>, <Line: +             * is relevant to creating a related annotation description.
>, <Line: +             */
>, <Line: +            protected class AnnotationExtractor extends AnnotationVisitor {
>, <Line: +                /**
>, <Line: +                 * The annotation registrant to register found annotation values on.
>, <Line: +                 */
>, <Line: +                private final AnnotationRegistrant annotationRegistrant;
>, <Line: +                /**
>, <Line: +                 * A locator for the component type of any found annotation value.
>, <Line: +                 */
>, <Line: +                private final ComponentTypeLocator componentTypeLocator;
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation extractor for a byte code element without an index.
>, <Line: +                 *
>, <Line: +                 * @param descriptor           The annotation descriptor.
>, <Line: +                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
>, <Line: +                 * @param componentTypeLocator The component type locator to use.
>, <Line: +                 */
>, <Line: +                protected AnnotationExtractor(String descriptor, List<LazyTypeDescription.AnnotationToken> annotationTokens, ComponentTypeLocator componentTypeLocator) {
>, <Line: +                    this(new AnnotationRegistrant.ForByteCodeElement(descriptor, annotationTokens), componentTypeLocator);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation extractor for a byte code element with an index.
>, <Line: +                 *
>, <Line: +                 * @param descriptor           The annotation descriptor.
>, <Line: +                 * @param index                The index of the element for which the annotations are collected.
>, <Line: +                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
>, <Line: +                 * @param componentTypeLocator The component type locator to use.
>, <Line: +                 */
>, <Line: +                protected AnnotationExtractor(String descriptor,
>, <Line: +                                              int index,
>, <Line: +                                              Map<Integer, List<LazyTypeDescription.AnnotationToken>> annotationTokens,
>, <Line: +                                              ComponentTypeLocator componentTypeLocator) {
>, <Line: +                    this(new AnnotationRegistrant.ForByteCodeElement.WithIndex(descriptor, index, annotationTokens), componentTypeLocator);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a new annotation extractor.
>, <Line: +                 *
>, <Line: +                 * @param annotationRegistrant The annotation registrant to register found annotation values on.
>, <Line: +                 * @param componentTypeLocator A locator for the component type of any found annotation value.
>, <Line: +                 */
>, <Line: +                protected AnnotationExtractor(AnnotationRegistrant annotationRegistrant, ComponentTypeLocator componentTypeLocator) {
>, <Line: +                    super(Opcodes.ASM5);
>, <Line: +                    this.annotationRegistrant = annotationRegistrant;
>, <Line: +                    this.componentTypeLocator = componentTypeLocator;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void visit(String name, Object value) {
>, <Line: +                    annotationRegistrant.register(name, value instanceof Type
>, <Line: +                            ? new RawTypeValue(Default.this, (Type) value)
>, <Line: +                            : new AnnotationDescription.AnnotationValue.Trivial<Object>(value));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void visitEnum(String name, String descriptor, String value) {
>, <Line: +                    annotationRegistrant.register(name, new RawEnumerationValue(Default.this, descriptor, value));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationVisitor visitAnnotation(String name, String descriptor) {
>, <Line: +                    return new AnnotationExtractor(new AnnotationLookup(descriptor, name),
>, <Line: +                            new ComponentTypeLocator.ForAnnotationProperty(TypePool.Default.this, descriptor));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationVisitor visitArray(String name) {
>, <Line: +                    return new AnnotationExtractor(new ArrayLookup(name, componentTypeLocator.bind(name)), ComponentTypeLocator.Illegal.INSTANCE);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void visitEnd() {
>, <Line: +                    annotationRegistrant.onComplete();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypePool.Default.TypeExtractor.AnnotationExtractor{" +
>, <Line: +                            "typeExtractor=" + TypeExtractor.this +
>, <Line: +                            "annotationRegistrant=" + annotationRegistrant +
>, <Line: +                            ", componentTypeLocator=" + componentTypeLocator +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * An annotation registrant for registering values of an array.
>, <Line: +                 */
>, <Line: +                protected class ArrayLookup implements AnnotationRegistrant {
>, <Line: +                    /**
>, <Line: +                     * The name of the annotation property the collected array is representing.
>, <Line: +                     */
>, <Line: +                    private final String name;
>, <Line: +                    /**
>, <Line: +                     * A lazy reference to resolve the component type of the collected array.
>, <Line: +                     */
>, <Line: +                    private final RawNonPrimitiveArray.ComponentTypeReference componentTypeReference;
>, <Line: +                    /**
>, <Line: +                     * A list of all annotation values that are found on this array.
>, <Line: +                     */
>, <Line: +                    private final List<AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation registrant for an array lookup.
>, <Line: +                     *
>, <Line: +                     * @param name                   The name of the annotation property the collected array is representing.
>, <Line: +                     * @param componentTypeReference A lazy reference to resolve the component type of the collected array.
>, <Line: +                     */
>, <Line: +                    protected ArrayLookup(String name, RawNonPrimitiveArray.ComponentTypeReference componentTypeReference) {
>, <Line: +                        this.name = name;
>, <Line: +                        this.componentTypeReference = componentTypeReference;
>, <Line: +                        values = new ArrayList<AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void register(String ignored, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: +                        values.add(annotationValue);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void onComplete() {
>, <Line: +                        annotationRegistrant.register(name, new RawNonPrimitiveArray(Default.this, componentTypeReference, values));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.TypeExtractor.AnnotationExtractor.ArrayLookup{" +
>, <Line: +                                "annotationExtractor=" + AnnotationExtractor.this +
>, <Line: +                                ", name='" + name + '\'' +
>, <Line: +                                ", componentTypeReference=" + componentTypeReference +
>, <Line: +                                ", values=" + values +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * An annotation registrant for registering the values on an array that is itself an annotation property.
>, <Line: +                 */
>, <Line: +                protected class AnnotationLookup implements AnnotationRegistrant {
>, <Line: +                    /**
>, <Line: +                     * The descriptor of the original annotation for which the annotation values are looked up.
>, <Line: +                     */
>, <Line: +                    private final String descriptor;
>, <Line: +                    /**
>, <Line: +                     * The name of the original annotation for which the annotation values are looked up.
>, <Line: +                     */
>, <Line: +                    private final String name;
>, <Line: +                    /**
>, <Line: +                     * This annotation's values mapped by their attribute name.
>, <Line: +                     */
>, <Line: +                    private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation registrant for a recursive annotation lookup.
>, <Line: +                     *
>, <Line: +                     * @param name       The name of the original annotation for which the annotation values are looked up.
>, <Line: +                     * @param descriptor The descriptor of the original annotation for which the annotation values are looked up.
>, <Line: +                     */
>, <Line: +                    protected AnnotationLookup(String descriptor, String name) {
>, <Line: +                        this.descriptor = descriptor;
>, <Line: +                        this.name = name;
>, <Line: +                        values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: +                        values.put(name, annotationValue);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void onComplete() {
>, <Line: +                        annotationRegistrant.register(name, new RawAnnotationValue(Default.this, new LazyTypeDescription.AnnotationToken(descriptor, values)));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypePool.Default.TypeExtractor.AnnotationExtractor.AnnotationLookup{" +
>, <Line: +                                "descriptor='" + descriptor + '\'' +
>, <Line: +                                ", name='" + name + '\'' +
>, <Line: +                                ", values=" + values +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A field extractor reads a field within a class file and collects data that is relevant
>, <Line: +             * to creating a related field description.
>, <Line: +             */
>, <Line: +            protected class FieldExtractor extends FieldVisitor {
>, <Line: +                /**
>, <Line: +                 * The modifiers found on the field.
>, <Line: +                 */
>, <Line: +                private final int modifiers;
>, <Line: +                /**
>, <Line: +                 * The name of the field.
>, <Line: +                 */
>, <Line: +                private final String internalName;
>, <Line: +                /**
>, <Line: +                 * The descriptor of the field type.
>, <Line: +                 */
>, <Line: +                private final String descriptor;
>, <Line: +                /**
>, <Line: +                 * The generic signature of the field or {@code null} if it is not generic.
>, <Line: +                 */
>, <Line: +                private final String genericSignature;
>, <Line: +                /**
>, <Line: +                 * A mapping of the field type's type annotations.
>, <Line: +                 */
>, <Line: +                private final Map<String, List<LazyTypeDescription.AnnotationToken>> typeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of annotation tokens found for this field.
>, <Line: +                 */
>, <Line: +                private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * Creates a new field extractor.
>, <Line: +                 *
>, <Line: +                 * @param modifiers        The modifiers found for this field.
>, <Line: +                 * @param internalName     The name of the field.
>, <Line: +                 * @param descriptor       The descriptor of the field type.
>, <Line: +                 * @param genericSignature The generic signature of the field or {@code null} if it is not generic.
>, <Line: +                 */
>, <Line: +                protected FieldExtractor(int modifiers,
>, <Line: +                                         String internalName,
>, <Line: +                                         String descriptor,
>, <Line: +                                         String genericSignature) {
>, <Line: +                    super(Opcodes.ASM5);
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.internalName = internalName;
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.genericSignature = genericSignature;
>, <Line: +                    typeAnnotationTokens = new HashMap<String, List<LazyTypeDescription.AnnotationToken>>();
>, <Line: +                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
>, <Line: +                    AnnotationRegistrant annotationRegistrant;
>, <Line: +                    TypeReference typeReference = new TypeReference(rawTypeReference);
>, <Line: +                    switch (typeReference.getSort()) {
>, <Line: +                        case TypeReference.FIELD:
>, <Line: +                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, typeAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        default:
>, <Line: +                            throw new IllegalStateException("Unexpected type reference on field: " + typeReference.getSort());
>, <Line: +                    }
>, <Line: +                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: +                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void visitEnd() {
>, <Line: +                    fieldTokens.add(new LazyTypeDescription.FieldToken(internalName,
>, <Line: +                            modifiers,
>, <Line: +                            descriptor,
>, <Line: +                            GenericTypeExtractor.ForSignature.OfField.extract(genericSignature),
>, <Line: +                            typeAnnotationTokens,
>, <Line: +                            annotationTokens));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypePool.Default.TypeExtractor.FieldExtractor{" +
>, <Line: +                            "typeExtractor=" + TypeExtractor.this +
>, <Line: +                            ", modifiers=" + modifiers +
>, <Line: +                            ", internalName='" + internalName + '\'' +
>, <Line: +                            ", descriptor='" + descriptor + '\'' +
>, <Line: +                            ", genericSignature='" + genericSignature + '\'' +
>, <Line: +                            ", typeAnnotationTokens=" + typeAnnotationTokens +
>, <Line: +                            ", annotationTokens=" + annotationTokens +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +             * A method extractor reads a method within a class file and collects data that is relevant
>, <Line: +             * to creating a related method description.
>, <Line: +            protected class MethodExtractor extends MethodVisitor implements AnnotationRegistrant {
>, <Line: +                 * The modifiers found for this method.
>, <Line: +                private final int modifiers;
>, <Line: +                 * The internal name found for this method.
>, <Line: +                private final String internalName;
>, <Line: +                 * The descriptor found for this method.
>, <Line: +                private final String descriptor;
>, <Line: +                 * The generic signature of the method or {@code null} if it is not generic.
>, <Line: +                private final String genericSignature;
>, <Line: +                 * An array of internal names of the exceptions of the found method
>, <Line: +                 * or {@code null} if there are no such exceptions.
>, <Line: +                private final String[] exceptionName;
>, <Line: +                 * A mapping of the method's type variables' type annotations by their indices.
>, <Line: +                private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> typeVariableAnnotationTokens;
>, <Line: +                 * A mapping of the method's type variables' bounds' type annotations by their indices and each variable's index.
>, <Line: +                private final Map<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>> typeVariableBoundAnnotationTokens;
>, <Line: +                 * A mapping of the method's return type's type annotations.
>, <Line: +                private final Map<String, List<LazyTypeDescription.AnnotationToken>> returnTypeAnnotationTokens;
>, <Line: +                 * A mapping of the parameters' type annotations by their indices.
>, <Line: +                private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> parameterTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of the exception types' type annotations by their indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>> exceptionTypeAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of annotation tokens declared on the found method.
>, <Line: +                 */
>, <Line: +                private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: +                /**
>, <Line: +                 * A mapping of parameter indices to annotation tokens found for the parameters at these indices.
>, <Line: +                 */
>, <Line: +                private final Map<Integer, List<LazyTypeDescription.AnnotationToken>> parameterAnnotationTokens;
>, <Line: +                /**
>, <Line: +                 * A list of tokens representing meta information of a parameter as it is available for method's
>, <Line: +                 * that are compiled in the Java 8 version format.
>, <Line: +                 */
>, <Line: +                private final List<LazyTypeDescription.MethodToken.ParameterToken> parameterTokens;
>, <Line: +                /**
>, <Line: +                 * A bag of parameter meta information representing debugging information which allows to extract
>, <Line: +                 * a method's parameter names.
>, <Line: +                 */
>, <Line: +                private final ParameterBag legacyParameterBag;
>, <Line: +                /**
>, <Line: +                 * The first label that is found in the method's body, if any, denoting the start of the method.
>, <Line: +                 * This label can be used to identify names of local variables that describe the method's parameters.
>, <Line: +                 */
>, <Line: +                private Label firstLabel;
>, <Line: +                 * The default value of the found method or {@code null} if no such value exists.
>, <Line: +                private AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: +                 * Creates a method extractor.
>, <Line: +                 * @param modifiers        The modifiers found for this method.
>, <Line: +                 * @param internalName     The internal name found for this method.
>, <Line: +                 * @param descriptor       The descriptor found for this method.
>, <Line: +                 * @param genericSignature The generic signature of the method or {@code null} if it is not generic.
>, <Line: +                 * @param exceptionName    An array of internal names of the exceptions of the found method
>, <Line: +                 *                         or {@code null} if there are no such exceptions.
>, <Line: +                protected MethodExtractor(int modifiers,
>, <Line: +                                          String internalName,
>, <Line: +                                          String descriptor,
>, <Line: +                                          String genericSignature,
>, <Line: +                                          String[] exceptionName) {
>, <Line: +                    super(Opcodes.ASM5);
>, <Line: +                    this.modifiers = modifiers;
>, <Line: +                    this.internalName = internalName;
>, <Line: +                    this.descriptor = descriptor;
>, <Line: +                    this.genericSignature = genericSignature;
>, <Line: +                    this.exceptionName = exceptionName;
>, <Line: +                    typeVariableAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                    typeVariableBoundAnnotationTokens = new HashMap<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>>();
>, <Line: +                    returnTypeAnnotationTokens = new HashMap<String, List<LazyTypeDescription.AnnotationToken>>();
>, <Line: +                    parameterTypeAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                    exceptionTypeAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
>, <Line: +                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: +                    parameterAnnotationTokens = new HashMap<Integer, List<LazyTypeDescription.AnnotationToken>>();
>, <Line: +                    parameterTokens = new ArrayList<LazyTypeDescription.MethodToken.ParameterToken>();
>, <Line: +                    legacyParameterBag = new ParameterBag(Type.getMethodType(descriptor).getArgumentTypes());
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
>, <Line: +                    AnnotationRegistrant annotationRegistrant;
>, <Line: +                    TypeReference typeReference = new TypeReference(rawTypeReference);
>, <Line: +                    switch (typeReference.getSort()) {
>, <Line: +                        case TypeReference.METHOD_TYPE_PARAMETER:
>, <Line: +                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
>, <Line: +                                    typePath,
>, <Line: +                                    typeReference.getTypeParameterIndex(),
>, <Line: +                                    typeVariableAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
>, <Line: +                            annotationRegistrant = new ForTypeVariable.WithIndex.DoubleIndexed(descriptor,
>, <Line: +                                    typePath,
>, <Line: +                                    typeReference.getTypeParameterBoundIndex(),
>, <Line: +                                    typeReference.getTypeParameterIndex(),
>, <Line: +                                    typeVariableBoundAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        case TypeReference.METHOD_RETURN:
>, <Line: +                            annotationRegistrant = new ForTypeVariable(descriptor,
>, <Line: +                                    typePath,
>, <Line: +                                    returnTypeAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        case TypeReference.METHOD_FORMAL_PARAMETER:
>, <Line: +                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
>, <Line: +                                    typePath,
>, <Line: +                                    typeReference.getFormalParameterIndex(),
>, <Line: +                                    parameterTypeAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        case TypeReference.THROWS:
>, <Line: +                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
>, <Line: +                                    typePath,
>, <Line: +                                    typeReference.getExceptionIndex(),
>, <Line: +                                    exceptionTypeAnnotationTokens);
>, <Line: +                            break;
>, <Line: +                        case TypeReference.METHOD_RECEIVER:
>, <Line: +                            return null; // Receiver types are currently not supported.
>, <Line: +                        default:
>, <Line: +                            throw new IllegalStateException("Unexpected type reference on method: " + typeReference.getSort());
>, <Line: +                    }
>, <Line: +                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: +                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
>, <Line: +                    return new AnnotationExtractor(descriptor, index, parameterAnnotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: +                public void visitLabel(Label label) {
>, <Line: +                    if (readerMode.isExtended() && firstLabel == null) {
>, <Line: +                        firstLabel = label;
>, <Line: +                public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
>, <Line: +                    if (readerMode.isExtended() && start == firstLabel) {
>, <Line: +                        legacyParameterBag.register(index, name);
>, <Line: +                public void visitParameter(String name, int modifiers) {
>, <Line: +                    parameterTokens.add(new LazyTypeDescription.MethodToken.ParameterToken(name, modifiers));
>, <Line: +                public AnnotationVisitor visitAnnotationDefault() {
>, <Line: +                    return new AnnotationExtractor(this, new ComponentTypeLocator.ForArrayType(descriptor));
>, <Line: +                public void register(String ignored, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: +                    defaultValue = annotationValue;
>, <Line: +                public void onComplete() {
>, <Line: +                    /* do nothing, as the register method is called at most once for default values */
>, <Line: +                public void visitEnd() {
>, <Line: +                    methodTokens.add(new LazyTypeDescription.MethodToken(internalName,
>, <Line: +                            modifiers,
>, <Line: +                            descriptor,
>, <Line: +                            GenericTypeExtractor.ForSignature.OfMethod.extract(genericSignature),
>, <Line: +                            exceptionName,
>, <Line: +                            typeVariableAnnotationTokens,
>, <Line: +                            typeVariableBoundAnnotationTokens,
>, <Line: +                            returnTypeAnnotationTokens,
>, <Line: +                            parameterTypeAnnotationTokens,
>, <Line: +                            exceptionTypeAnnotationTokens,
>, <Line: +                            annotationTokens,
>, <Line: +                            parameterAnnotationTokens,
>, <Line: +                            parameterTokens.isEmpty()
>, <Line: +                                    ? legacyParameterBag.resolve((modifiers & Opcodes.ACC_STATIC) != 0)
>, <Line: +                                    : parameterTokens,
>, <Line: +                            defaultValue));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypePool.Default.TypeExtractor.MethodExtractor{" +
>, <Line: +                            "typeExtractor=" + TypeExtractor.this +
>, <Line: +                            ", modifiers=" + modifiers +
>, <Line: +                            ", internalName='" + internalName + '\'' +
>, <Line: +                            ", descriptor='" + descriptor + '\'' +
>, <Line: +                            ", genericSignature='" + genericSignature + '\'' +
>, <Line: +                            ", exceptionName=" + Arrays.toString(exceptionName) +
>, <Line: +                            ", typeVariableAnnotationTokens=" + typeVariableAnnotationTokens +
>, <Line: +                            ", typeVariableBoundAnnotationTokens=" + typeVariableBoundAnnotationTokens +
>, <Line: +                            ", returnTypeAnnotationTokens=" + returnTypeAnnotationTokens +
>, <Line: +                            ", parameterTypeAnnotationTokens=" + parameterTypeAnnotationTokens +
>, <Line: +                            ", exceptionTypeAnnotationTokens=" + exceptionTypeAnnotationTokens +
>, <Line: +                            ", annotationTokens=" + annotationTokens +
>, <Line: +                            ", parameterAnnotationTokens=" + parameterAnnotationTokens +
>, <Line: +                            ", parameterTokens=" + parameterTokens +
>, <Line: +                            ", legacyParameterBag=" + legacyParameterBag +
>, <Line: +                            ", firstLabel=" + firstLabel +
>, <Line: +                            ", defaultValue=" + defaultValue +
>, <Line: +                            '}';
>, <Line: +         * Determines the granularity of the class file parsing that is conducted by a {@link net.bytebuddy.pool.TypePool.Default}.
>, <Line: +        public enum ReaderMode {
>, <Line: +             * The extended reader mode parses the code segment of each method in order to detect parameter names
>, <Line: +             * that are only stored in a method's debugging information but are not explicitly included.
>, <Line: +            EXTENDED(ClassReader.SKIP_FRAMES),
>, <Line: +             * The fast reader mode skips the code segment of each method and cannot detect parameter names that are
>, <Line: +             * only contained within the debugging information. This mode still detects explicitly included method
>, <Line: +             * parameter names.
>, <Line: +            FAST(ClassReader.SKIP_CODE);
>, <Line: +             * The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: +            private final int flags;
>, <Line: +             * Creates a new reader mode constant.
>, <Line: +             *
>, <Line: +             * @param flags The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: +            ReaderMode(int flags) {
>, <Line: +                this.flags = flags;
>, <Line: +            }
>, <Line: +             * Returns the flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: +             * @return The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: +            protected int getFlags() {
>, <Line: +                return flags;
>, <Line: +             * Determines if this reader mode represents extended reading.
>, <Line: +             * @return {@code true} if this reader mode represents extended reading.
>, <Line: +            public boolean isExtended() {
>, <Line: +                return this == EXTENDED;
>, <Line: +            public String toString() {
>, <Line: +                return "TypePool.Default.ReaderMode." + name();
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A class file locator that loads classes and describes the loaded classes as a {@link TypeDescription.ForLoadedType}
>, <Line: +         * if a type cannot be located as its class file.
>, <Line: +         */
>, <Line: +        public static class ClassLoading extends Default {
>, <Line: +             * The class loader to query.
>, <Line: +            private final ClassLoader classLoader;
>, <Line: +            /**
>, <Line: +             * Creates a class loading type pool.
>, <Line: +             *
>, <Line: +             * @param cacheProvider    The cache provider to be used.
>, <Line: +             * @param classFileLocator The class file locator to be used.
>, <Line: +             * @param classLoader      The class loader to query.
>, <Line: +             */
>, <Line: +            public ClassLoading(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ClassLoader classLoader) {
>, <Line: +                super(cacheProvider, classFileLocator, ReaderMode.FAST);
>, <Line: +                this.classLoader = classLoader;
>, <Line: +             * Returns a class loading type pool that does not attempt to parse a class file but immediately falls back to loading one.
>, <Line: +             *
>, <Line: +             * @param classLoader The class loader to query.
>, <Line: +             * @return An appropriate type pool.
>, <Line: +            public static TypePool of(ClassLoader classLoader) {
>, <Line: +                return of(ClassFileLocator.NoOp.INSTANCE, classLoader);
>, <Line: +             * Returns a class loading type pool that uses a simple cache.
>, <Line: +             *
>, <Line: +             * @param classFileLocator The class file locator to be used.
>, <Line: +             * @param classLoader      The class loader to query.
>, <Line: +             * @return An appropriate type pool.
>, <Line: +            public static TypePool of(ClassFileLocator classFileLocator, ClassLoader classLoader) {
>, <Line: +                return new ClassLoading(new CacheProvider.Simple(), classFileLocator, classLoader);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public Resolution doDescribe(String name) {
>, <Line: +                Resolution resolution = super.doDescribe(name);
>, <Line: +                if (resolution.isResolved()) {
>, <Line: +                    return resolution;
>, <Line: +                try {
>, <Line: +                    return new Resolution.Simple(new TypeDescription.ForLoadedType(Class.forName(name, false, classLoader)));
>, <Line: +                } catch (ClassNotFoundException ignored) {
>, <Line: +                    return new Resolution.Illegal(name);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean equals(Object other) {
>, <Line: +                if (this == other) return true;
>, <Line: +                if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                if (!super.equals(other)) return false;
>, <Line: +                ClassLoading that = (ClassLoading) other;
>, <Line: +                return !(classLoader != null ? !classLoader.equals(that.classLoader) : that.classLoader != null);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public int hashCode() {
>, <Line: +                int result = super.hashCode();
>, <Line: +                result = 31 * result + (classLoader != null ? classLoader.hashCode() : 0);
>, <Line: +                return result;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String toString() {
>, <Line: +                return "TypePool.Default.ClassLoading{" +
>, <Line: +                        "classFileLocator=" + classFileLocator +
>, <Line: +                        ", cacheProvider=" + cacheProvider +
>, <Line: +                        ", readerMode=" + readerMode +
>, <Line: +                        ", classLoader=" + classLoader +
>, <Line: +                        '}';
>, <Line: +         * A class file locator that maintains a map of precomputed classes which are returned as a resolution in case that a type name is known.
>, <Line: +        public static class Precomputed extends Default {
>, <Line: +             * The precomputed type descriptions.
>, <Line: +            private final Map<String, TypeDescription> precomputed;
>, <Line: +             * Creates a new precomputed type pool.
>, <Line: +             *
>, <Line: +             * @param cacheProvider    The cache provider to be used.
>, <Line: +             * @param classFileLocator The class file locator to be used.
>, <Line: +             * @param readerMode       The reader mode to apply by this default type pool.
>, <Line: +             * @param precomputed      The precomputed type descriptions.
>, <Line: +            public Precomputed(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, Map<String, TypeDescription> precomputed) {
>, <Line: +                super(cacheProvider, classFileLocator, readerMode);
>, <Line: +                this.precomputed = precomputed;
>, <Line: +            }
>, <Line: +             * Creates a new precomputed type pool with the {@link Object} type being precomputed.
>, <Line: +             * @param cacheProvider    The cache provider to be used.
>, <Line: +             * @param classFileLocator The class file locator to be used.
>, <Line: +             * @param readerMode       The reader mode to apply by this default type pool.
>, <Line: +             * @return A type pool with the {@link Object} type being precomputed.
>, <Line: +            public static TypePool withObjectType(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
>, <Line: +                return new Precomputed(cacheProvider, classFileLocator, readerMode, Collections.singletonMap(Object.class.getName(), TypeDescription.OBJECT));
>, <Line: +            protected Resolution doDescribe(String name) {
>, <Line: +                TypeDescription typeDescription = precomputed.get(name);
>, <Line: +                return typeDescription == null
>, <Line: +                        ? super.doDescribe(name)
>, <Line: +                        : new Resolution.Simple(typeDescription);
>, <Line: +            public boolean equals(Object other) {
>, <Line: +                return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                        && super.equals(other)
>, <Line: +                        && precomputed.equals(((Precomputed) other).precomputed);
>, <Line: +            public int hashCode() {
>, <Line: +                int result = super.hashCode();
>, <Line: +                result = 31 * result + precomputed.hashCode();
>, <Line: +                return result;
>, <Line: +            public String toString() {
>, <Line: +                return "TypePool.Default.Precomputed{" +
>, <Line: +                        "classFileLocator=" + classFileLocator +
>, <Line: +                        ", cacheProvider=" + cacheProvider +
>, <Line: +                        ", readerMode=" + readerMode +
>, <Line: +                        ", precomputed=" + precomputed +
>, <Line: +                        '}';
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * A lazy facade of a type pool that delegates any lookups to another type pool only if another value than the type's name is looked up.
>, <Line: +     */
>, <Line: +    class LazyFacade extends AbstractBase {
>, <Line: +         * The type pool to delegate to.
>, <Line: +        private final TypePool typePool;
>, <Line: +        /**
>, <Line: +         * Creates a lazy facade for a type pool.
>, <Line: +         *
>, <Line: +         * @param typePool The type pool to delegate to.
>, <Line: +         */
>, <Line: +        public LazyFacade(TypePool typePool) {
>, <Line: +            super(CacheProvider.NoOp.INSTANCE);
>, <Line: +            this.typePool = typePool;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        protected Resolution doDescribe(String name) {
>, <Line: +            return new LazyResolution(typePool, name);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public void clear() {
>, <Line: +            typePool.clear();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public boolean equals(Object other) {
>, <Line: +            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                    && typePool.equals(((LazyFacade) other).typePool);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode() {
>, <Line: +            return typePool.hashCode();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public String toString() {
>, <Line: +            return "TypePool.LazyFacade{" +
>, <Line: +                    "typePool=" + typePool +
>, <Line: +                    '}';
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * The lazy resolution for a lazy facade for a type pool.
>, <Line: +         */
>, <Line: +        protected static class LazyResolution implements Resolution {
>, <Line: +             * The type pool to delegate to.
>, <Line: +            private final TypePool typePool;
>, <Line: +             * The name of the type that is represented by this resolution.
>, <Line: +            private final String name;
>, <Line: +             * Creates a lazy resolution for a lazy facade for a type pool.
>, <Line: +             * @param typePool The type pool to delegate to.
>, <Line: +             * @param name     The name of the type that is represented by this resolution.
>, <Line: +            protected LazyResolution(TypePool typePool, String name) {
>, <Line: +                this.typePool = typePool;
>, <Line: +                this.name = name;
>, <Line: +            public boolean isResolved() {
>, <Line: +                return typePool.describe(name).isResolved();
>, <Line: +            public TypeDescription resolve() {
>, <Line: +                return new LazyTypeDescription(typePool, name);
>, <Line: +            public boolean equals(Object other) {
>, <Line: +                if (this == other) return true;
>, <Line: +                if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                LazyResolution that = (LazyResolution) other;
>, <Line: +                return typePool.equals(that.typePool) && name.equals(that.name);
>, <Line: +            public int hashCode() {
>, <Line: +                int result = typePool.hashCode();
>, <Line: +                result = 31 * result + name.hashCode();
>, <Line: +                return result;
>, <Line: +            public String toString() {
>, <Line: +                return "TypePool.LazyFacade.LazyResolution{" +
>, <Line: +                        "typePool=" + typePool +
>, <Line: +                        ", name=" + name +
>, <Line: +                        '}';
>, <Line: +            /**
>, <Line: +             * A lazy type description for a lazy facade of a type pool.
>, <Line: +             */
>, <Line: +            protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
>, <Line: +                /**
>, <Line: +                 * The type pool to delegate to.
>, <Line: +                 */
>, <Line: +                private final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * The name of the type that is represented by this resolution.
>, <Line: +                 */
>, <Line: +                private final String name;
>, <Line: +                /**
>, <Line: +                 * Creates a lazy type description for a lazy facade of a type pool.
>, <Line: +                 *
>, <Line: +                 * @param typePool The type pool to delegate to.
>, <Line: +                 * @param name     The name of the type that is represented by this resolution.
>, <Line: +                 */
>, <Line: +                protected LazyTypeDescription(TypePool typePool, String name) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.name = name;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Resolves the actual type by querying the actual type pool.
>, <Line: +                 *
>, <Line: +                 * @return A representation of the actual type description.
>, <Line: +                 */
>, <Line: +                private TypeDescription resolve() {
>, <Line: +                    return typePool.describe(name).resolve();
>, <Line: +                }
>, <Line: +                public Generic getSuperType() {
>, <Line: +                    return resolve().getSuperType();
>, <Line: +                public TypeList.Generic getInterfaces() {
>, <Line: +                    return resolve().getInterfaces();
>, <Line: +                public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
>, <Line: +                    return resolve().getDeclaredFields();
>, <Line: +                public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
>, <Line: +                    return resolve().getDeclaredMethods();
>, <Line: +                @Override
>, <Line: +                public TypeDescription getDeclaringType() {
>, <Line: +                    return resolve().getDeclaringType();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public MethodDescription getEnclosingMethod() {
>, <Line: +                    return resolve().getEnclosingMethod();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription getEnclosingType() {
>, <Line: +                    return resolve().getEnclosingType();
>, <Line: +                public TypeList getDeclaredTypes() {
>, <Line: +                    return resolve().getDeclaredTypes();
>, <Line: +                public boolean isAnonymousClass() {
>, <Line: +                    return resolve().isAnonymousClass();
>, <Line: +                public boolean isLocalClass() {
>, <Line: +                    return resolve().isLocalClass();
>, <Line: +                public boolean isMemberClass() {
>, <Line: +                    return resolve().isMemberClass();
>, <Line: +                public PackageDescription getPackage() {
>, <Line: +                    return resolve().getPackage();
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return resolve().getDeclaredAnnotations();
>, <Line: +                public TypeList.Generic getTypeVariables() {
>, <Line: +                    return resolve().getTypeVariables();
>, <Line: +                public int getModifiers() {
>, <Line: +                    return resolve().getModifiers();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String getName() {
>, <Line: +                    return name;
>]
[<Line: -import net.bytebuddy.description.type.TypeDefinition;
>, <Line: -                name = primitiveName == null ? name.substring(1, name.length() - 1) : primitiveName;
>, <Line: -            private final LazyTypeDescription.AnnotationToken annotationToken;
>, <Line: -            public RawAnnotationValue(TypePool typePool, LazyTypeDescription.AnnotationToken annotationToken) {
>, <Line: -                return "TypePool.LazyTypeDescription.AnnotationValue.ForEnumeration{" +
>, <Line: -                return "TypePool.LazyTypeDescription.AnnotationValue.ForType{" +
>, <Line: -                return "TypePool.LazyTypeDescription.AnnotationValue.ForComplexArray{" +
>, <Line: -             * An incomplete {@link net.bytebuddy.pool.TypePool.LazyTypeDescription.GenericTypeToken}.
>, <Line: -                protected final List<LazyTypeDescription.GenericTypeToken> typeVariableTokens;
>, <Line: -                    typeVariableTokens = new ArrayList<LazyTypeDescription.GenericTypeToken>();
>, <Line: -         * A type extractor reads a class file and collects data that is relevant to create a type description.
>, <Line: -        protected class TypeExtractor extends ClassVisitor {
>, <Line: -             * A list of annotation tokens describing annotations that are found on the visited type.
>, <Line: -            private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: -             * A list of field tokens describing fields that are found on the visited type.
>, <Line: -            private final List<LazyTypeDescription.FieldToken> fieldTokens;
>, <Line: -             * A list of method tokens describing annotations that are found on the visited type.
>, <Line: -            private final List<LazyTypeDescription.MethodToken> methodTokens;
>, <Line: -             * The modifiers found for this type.
>, <Line: -            private int modifiers;
>, <Line: -             * The internal name found for this type.
>, <Line: -            private String internalName;
>, <Line: -             * The internal name of the super type found for this type or {@code null} if no such type exists.
>, <Line: -            private String superTypeName;
>, <Line: -             * The generic signature of the type or {@code null} if it is not generic.
>, <Line: -            private String genericSignature;
>, <Line: -             * A list of internal names of interfaces implemented by this type or {@code null} if no interfaces
>, <Line: -             * are implemented.
>, <Line: -            private String[] interfaceName;
>, <Line: -             * {@code true} if this type was found to represent an anonymous type.
>, <Line: -            private boolean anonymousType;
>, <Line: -             * The declaration context found for this type.
>, <Line: -            private LazyTypeDescription.DeclarationContext declarationContext;
>, <Line: -             * A list of descriptors representing the types that are declared by the parsed type.
>, <Line: -            private final List<String> declaredTypes;
>, <Line: -             * Creates a new type extractor.
>, <Line: -            protected TypeExtractor() {
>, <Line: -                super(Opcodes.ASM5);
>, <Line: -                annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: -                fieldTokens = new ArrayList<LazyTypeDescription.FieldToken>();
>, <Line: -                methodTokens = new ArrayList<LazyTypeDescription.MethodToken>();
>, <Line: -                anonymousType = false;
>, <Line: -                declarationContext = LazyTypeDescription.DeclarationContext.SelfDeclared.INSTANCE;
>, <Line: -                declaredTypes = new ArrayList<String>();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The received value is never modified")
>, <Line: -            public void visit(int classFileVersion,
>, <Line: -                              int modifiers,
>, <Line: -                              String internalName,
>, <Line: -                              String genericSignature,
>, <Line: -                              String superTypeName,
>, <Line: -                              String[] interfaceName) {
>, <Line: -                this.modifiers = modifiers;
>, <Line: -                this.internalName = internalName;
>, <Line: -                this.genericSignature = genericSignature;
>, <Line: -                this.superTypeName = superTypeName;
>, <Line: -                this.interfaceName = interfaceName;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public void visitOuterClass(String typeName, String methodName, String methodDescriptor) {
>, <Line: -                if (methodName != null) {
>, <Line: -                    declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInMethod(typeName, methodName, methodDescriptor);
>, <Line: -                } else if (typeName != null) {
>, <Line: -                    declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInType(typeName);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
>, <Line: -                if (internalName.equals(this.internalName)) {
>, <Line: -                    this.modifiers = modifiers;
>, <Line: -                    if (innerName == null) {
>, <Line: -                        anonymousType = true;
>, <Line: -                    }
>, <Line: -                    // Older Java compilers do not add the outer class attribute.
>, <Line: -                    if (outerName != null && declarationContext.isSelfDeclared()) {
>, <Line: -                        declarationContext = new LazyTypeDescription.DeclarationContext.DeclaredInType(outerName);
>, <Line: -                } else if (outerName != null && innerName != null && internalName.equals(this.internalName + "$" + innerName)) {
>, <Line: -                    declaredTypes.add("L" + internalName + ";");
>, <Line: -            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: -                return new AnnotationExtractor(new OnTypeCollector(descriptor),
>, <Line: -                        new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: -            public FieldVisitor visitField(int modifiers, String internalName, String descriptor, String genericSignature, Object defaultValue) {
>, <Line: -                return new FieldExtractor(modifiers, internalName, descriptor, genericSignature);
>, <Line: -            public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, String genericSignature, String[] exceptionName) {
>, <Line: -                return internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)
>, <Line: -                        ? IGNORE_METHOD
>, <Line: -                        : new MethodExtractor(modifiers, internalName, descriptor, genericSignature, exceptionName);
>, <Line: -            /**
>, <Line: -             * Creates a type description from all data that is currently collected. This method should only be invoked
>, <Line: -             * after a class file was parsed fully.
>, <Line: -             *
>, <Line: -             * @return A type description reflecting the data that was collected by this instance.
>, <Line: -             */
>, <Line: -            protected TypeDescription toTypeDescription() {
>, <Line: -                return new LazyTypeDescription(Default.this,
>, <Line: -                        modifiers,
>, <Line: -                        internalName,
>, <Line: -                        superTypeName,
>, <Line: -                        interfaceName,
>, <Line: -                        GenericTypeExtractor.ForSignature.OfType.extract(genericSignature),
>, <Line: -                        declarationContext,
>, <Line: -                        declaredTypes,
>, <Line: -                        anonymousType,
>, <Line: -                        annotationTokens,
>, <Line: -                        fieldTokens,
>, <Line: -                        methodTokens);
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.Default.TypeExtractor{" +
>, <Line: -                        "typePool=" + Default.this +
>, <Line: -                        ", annotationTokens=" + annotationTokens +
>, <Line: -                        ", fieldTokens=" + fieldTokens +
>, <Line: -                        ", methodTokens=" + methodTokens +
>, <Line: -                        ", modifiers=" + modifiers +
>, <Line: -                        ", internalName='" + internalName + '\'' +
>, <Line: -                        ", superTypeName='" + superTypeName + '\'' +
>, <Line: -                        ", genericSignature='" + genericSignature + '\'' +
>, <Line: -                        ", interfaceName=" + Arrays.toString(interfaceName) +
>, <Line: -                        ", anonymousType=" + anonymousType +
>, <Line: -                        ", declarationContext=" + declarationContext +
>, <Line: -                        '}';
>, <Line: -            /**
>, <Line: -             * An annotation registrant that collects annotations found on a type.
>, <Line: -             */
>, <Line: -            protected class OnTypeCollector implements AnnotationRegistrant {
>, <Line: -                /**
>, <Line: -                 * The descriptor of the annotation that is being collected.
>, <Line: -                 */
>, <Line: -                private final String descriptor;
>, <Line: -                /**
>, <Line: -                 * The values that were collected so far.
>, <Line: -                 */
>, <Line: -                private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                /**
>, <Line: -                 * Creates a new on type collector.
>, <Line: -                 *
>, <Line: -                 * @param descriptor The descriptor of the annotation that is being collected.
>, <Line: -                 */
>, <Line: -                protected OnTypeCollector(String descriptor) {
>, <Line: -                    this.descriptor = descriptor;
>, <Line: -                    values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                    values.put(name, annotationValue);
>, <Line: -                public void onComplete() {
>, <Line: -                    annotationTokens.add(new LazyTypeDescription.AnnotationToken(descriptor, values));
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.Default.TypeExtractor.OnTypeCollector{" +
>, <Line: -                            "typeExtractor=" + TypeExtractor.this +
>, <Line: -                            ", descriptor='" + descriptor + '\'' +
>, <Line: -                            ", values=" + values +
>, <Line: -                            '}';
>, <Line: -             * An annotation extractor reads an annotation found in a class field an collects data that
>, <Line: -             * is relevant to creating a related annotation description.
>, <Line: -            protected class AnnotationExtractor extends AnnotationVisitor {
>, <Line: -                 * The annotation registrant to register found annotation values on.
>, <Line: -                private final AnnotationRegistrant annotationRegistrant;
>, <Line: -                 * A locator for the component type of any found annotation value.
>, <Line: -                private final ComponentTypeLocator componentTypeLocator;
>, <Line: -                 * Creates a new annotation extractor.
>, <Line: -                 * @param annotationRegistrant The annotation registrant to register found annotation values on.
>, <Line: -                 * @param componentTypeLocator A locator for the component type of any found annotation value.
>, <Line: -                protected AnnotationExtractor(AnnotationRegistrant annotationRegistrant,
>, <Line: -                                              ComponentTypeLocator componentTypeLocator) {
>, <Line: -                    super(Opcodes.ASM5);
>, <Line: -                    this.annotationRegistrant = annotationRegistrant;
>, <Line: -                    this.componentTypeLocator = componentTypeLocator;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visit(String name, Object value) {
>, <Line: -                    annotationRegistrant.register(name, value instanceof Type
>, <Line: -                            ? new RawTypeValue(Default.this, (Type) value)
>, <Line: -                            : new AnnotationDescription.AnnotationValue.Trivial<Object>(value));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitEnum(String name, String descriptor, String value) {
>, <Line: -                    annotationRegistrant.register(name, new RawEnumerationValue(Default.this, descriptor, value));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitAnnotation(String name, String descriptor) {
>, <Line: -                    return new AnnotationExtractor(new AnnotationLookup(name, descriptor),
>, <Line: -                            new ComponentTypeLocator.ForAnnotationProperty(TypePool.Default.this, descriptor));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitArray(String name) {
>, <Line: -                    return new AnnotationExtractor(new ArrayLookup(name, componentTypeLocator.bind(name)), ComponentTypeLocator.Illegal.INSTANCE);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitEnd() {
>, <Line: -                    annotationRegistrant.onComplete();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.Default.TypeExtractor.AnnotationExtractor{" +
>, <Line: -                            "typeExtractor=" + TypeExtractor.this +
>, <Line: -                            "annotationRegistrant=" + annotationRegistrant +
>, <Line: -                            ", componentTypeLocator=" + componentTypeLocator +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -                 * An annotation registrant for registering values of an array.
>, <Line: -                protected class ArrayLookup implements AnnotationRegistrant {
>, <Line: -                     * The name of the annotation property the collected array is representing.
>, <Line: -                    private final String name;
>, <Line: -                    /**
>, <Line: -                     * A lazy reference to resolve the component type of the collected array.
>, <Line: -                     */
>, <Line: -                    private final RawNonPrimitiveArray.ComponentTypeReference componentTypeReference;
>, <Line: -                    /**
>, <Line: -                     * A list of all annotation values that are found on this array.
>, <Line: -                     */
>, <Line: -                    private final List<AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                    /**
>, <Line: -                     * Creates a new annotation registrant for an array lookup.
>, <Line: -                     *
>, <Line: -                     * @param name                   The name of the annotation property the collected array is representing.
>, <Line: -                     * @param componentTypeReference A lazy reference to resolve the component type of the collected array.
>, <Line: -                     */
>, <Line: -                    protected ArrayLookup(String name,
>, <Line: -                                          RawNonPrimitiveArray.ComponentTypeReference componentTypeReference) {
>, <Line: -                        this.name = name;
>, <Line: -                        this.componentTypeReference = componentTypeReference;
>, <Line: -                        values = new ArrayList<AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                    public void register(String ignored, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                        values.add(annotationValue);
>, <Line: -                    public void onComplete() {
>, <Line: -                        annotationRegistrant.register(name, new RawNonPrimitiveArray(Default.this, componentTypeReference, values));
>, <Line: -                        return "TypePool.Default.TypeExtractor.AnnotationExtractor.ArrayLookup{" +
>, <Line: -                                "annotationExtractor=" + AnnotationExtractor.this +
>, <Line: -                                ", name='" + name + '\'' +
>, <Line: -                                ", componentTypeReference=" + componentTypeReference +
>, <Line: -                                ", values=" + values +
>, <Line: -                                '}';
>, <Line: -                 * An annotation registrant for registering the values on an array that is itself an annotation property.
>, <Line: -                protected class AnnotationLookup implements AnnotationRegistrant {
>, <Line: -                     * The name of the original annotation for which the annotation values are looked up.
>, <Line: -                     * The descriptor of the original annotation for which the annotation values are looked up.
>, <Line: -                     */
>, <Line: -                    private final String descriptor;
>, <Line: -                    /**
>, <Line: -                     * A mapping of annotation property values to their values.
>, <Line: -                     */
>, <Line: -                    private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                    /**
>, <Line: -                     * Creates a new annotation registrant for a recursive annotation lookup.
>, <Line: -                     * @param name       The name of the original annotation for which the annotation values are
>, <Line: -                     *                   looked up.
>, <Line: -                     * @param descriptor The descriptor of the original annotation for which the annotation values are
>, <Line: -                     *                   looked up.
>, <Line: -                    protected AnnotationLookup(String name, String descriptor) {
>, <Line: -                        this.name = name;
>, <Line: -                        this.descriptor = descriptor;
>, <Line: -                        values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                    public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                        values.put(name, annotationValue);
>, <Line: -                    public void onComplete() {
>, <Line: -                        annotationRegistrant.register(name, new RawAnnotationValue(Default.this, new LazyTypeDescription.AnnotationToken(descriptor, values)));
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.Default.TypeExtractor.AnnotationExtractor.AnnotationLookup{" +
>, <Line: -                                "annotationExtractor=" + AnnotationExtractor.this +
>, <Line: -                                ", name='" + name + '\'' +
>, <Line: -                                ", descriptor='" + descriptor + '\'' +
>, <Line: -                                ", values=" + values +
>, <Line: -                                '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A field extractor reads a field within a class file and collects data that is relevant
>, <Line: -             * to creating a related field description.
>, <Line: -             */
>, <Line: -            protected class FieldExtractor extends FieldVisitor {
>, <Line: -                /**
>, <Line: -                 * The modifiers found on the field.
>, <Line: -                 */
>, <Line: -                private final int modifiers;
>, <Line: -                /**
>, <Line: -                 * The name of the field.
>, <Line: -                 */
>, <Line: -                private final String internalName;
>, <Line: -                /**
>, <Line: -                 * The descriptor of the field type.
>, <Line: -                 */
>, <Line: -                private final String descriptor;
>, <Line: -                /**
>, <Line: -                 * The generic signature of the field or {@code null} if it is not generic.
>, <Line: -                 */
>, <Line: -                private final String genericSignature;
>, <Line: -                /**
>, <Line: -                 * A list of annotation tokens found for this field.
>, <Line: -                 */
>, <Line: -                private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: -                /**
>, <Line: -                 * Creates a new field extractor.
>, <Line: -                 *
>, <Line: -                 * @param modifiers        The modifiers found for this field.
>, <Line: -                 * @param internalName     The name of the field.
>, <Line: -                 * @param descriptor       The descriptor of the field type.
>, <Line: -                 * @param genericSignature The generic signature of the field or {@code null} if it is not generic.
>, <Line: -                 */
>, <Line: -                protected FieldExtractor(int modifiers,
>, <Line: -                                         String internalName,
>, <Line: -                                         String descriptor,
>, <Line: -                                         String genericSignature) {
>, <Line: -                    super(Opcodes.ASM5);
>, <Line: -                    this.modifiers = modifiers;
>, <Line: -                    this.internalName = internalName;
>, <Line: -                    this.descriptor = descriptor;
>, <Line: -                    this.genericSignature = genericSignature;
>, <Line: -                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: -                    return new AnnotationExtractor(new OnFieldCollector(descriptor),
>, <Line: -                            new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitEnd() {
>, <Line: -                    fieldTokens.add(new LazyTypeDescription.FieldToken(internalName,
>, <Line: -                            modifiers,
>, <Line: -                            descriptor,
>, <Line: -                            GenericTypeExtractor.ForSignature.OfField.extract(genericSignature),
>, <Line: -                            annotationTokens));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.Default.TypeExtractor.FieldExtractor{" +
>, <Line: -                            "typeExtractor=" + TypeExtractor.this +
>, <Line: -                            ", modifiers=" + modifiers +
>, <Line: -                            ", internalName='" + internalName + '\'' +
>, <Line: -                            ", descriptor='" + descriptor + '\'' +
>, <Line: -                            ", genericSignature='" + genericSignature + '\'' +
>, <Line: -                            ", annotationTokens=" + annotationTokens +
>, <Line: -                            '}';
>, <Line: -                 * An annotation registrant that collects annotations that are declared on a field.
>, <Line: -                protected class OnFieldCollector implements AnnotationRegistrant {
>, <Line: -                     * The annotation descriptor.
>, <Line: -                    private final String descriptor;
>, <Line: -                     * A mapping of annotation property names to their values.
>, <Line: -                    private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                     * Creates a new annotation field registrant.
>, <Line: -                     * @param descriptor The descriptor of the annotation.
>, <Line: -                    protected OnFieldCollector(String descriptor) {
>, <Line: -                        this.descriptor = descriptor;
>, <Line: -                        values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                    public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                        values.put(name, annotationValue);
>, <Line: -                    public void onComplete() {
>, <Line: -                        annotationTokens.add(new LazyTypeDescription.AnnotationToken(descriptor, values));
>, <Line: -                        return "TypePool.Default.TypeExtractor.FieldExtractor.OnFieldCollector{" +
>, <Line: -                                "fieldExtractor=" + FieldExtractor.this +
>, <Line: -                                ", descriptor='" + descriptor + '\'' +
>, <Line: -                                ", values=" + values +
>, <Line: -             * A method extractor reads a method within a class file and collects data that is relevant
>, <Line: -             * to creating a related method description.
>, <Line: -            protected class MethodExtractor extends MethodVisitor implements AnnotationRegistrant {
>, <Line: -                 * The modifiers found for this method.
>, <Line: -                private final int modifiers;
>, <Line: -                 * The internal name found for this method.
>, <Line: -                private final String internalName;
>, <Line: -                 * The descriptor found for this method.
>, <Line: -                private final String descriptor;
>, <Line: -                 * The generic signature of the method or {@code null} if it is not generic.
>, <Line: -                private final String genericSignature;
>, <Line: -                 * An array of internal names of the exceptions of the found method
>, <Line: -                 * or {@code null} if there are no such exceptions.
>, <Line: -                private final String[] exceptionName;
>, <Line: -                 * A list of annotation tokens declared on the found method.
>, <Line: -                private final List<LazyTypeDescription.AnnotationToken> annotationTokens;
>, <Line: -                 * A mapping of parameter indices to annotation tokens found for the parameters at these indices.
>, <Line: -                private final Map<Integer, List<LazyTypeDescription.AnnotationToken>> parameterAnnotationTokens;
>, <Line: -                 * A list of tokens representing meta information of a parameter as it is available for method's
>, <Line: -                 * that are compiled in the Java 8 version format.
>, <Line: -                private final List<LazyTypeDescription.MethodToken.ParameterToken> parameterTokens;
>, <Line: -                /**
>, <Line: -                 * A bag of parameter meta information representing debugging information which allows to extract
>, <Line: -                 * a method's parameter names.
>, <Line: -                 */
>, <Line: -                private final ParameterBag legacyParameterBag;
>, <Line: -                 * The first label that is found in the method's body, if any, denoting the start of the method.
>, <Line: -                 * This label can be used to identify names of local variables that describe the method's parameters.
>, <Line: -                private Label firstLabel;
>, <Line: -                /**
>, <Line: -                 * The default value of the found method or {@code null} if no such value exists.
>, <Line: -                 */
>, <Line: -                private AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: -                /**
>, <Line: -                 * Creates a method extractor.
>, <Line: -                 *
>, <Line: -                 * @param modifiers        The modifiers found for this method.
>, <Line: -                 * @param internalName     The internal name found for this method.
>, <Line: -                 * @param descriptor       The descriptor found for this method.
>, <Line: -                 * @param genericSignature The generic signature of the method or {@code null} if it is not generic.
>, <Line: -                 * @param exceptionName    An array of internal names of the exceptions of the found method
>, <Line: -                 *                         or {@code null} if there are no such exceptions.
>, <Line: -                 */
>, <Line: -                protected MethodExtractor(int modifiers,
>, <Line: -                                          String internalName,
>, <Line: -                                          String descriptor,
>, <Line: -                                          String genericSignature,
>, <Line: -                                          String[] exceptionName) {
>, <Line: -                    super(Opcodes.ASM5);
>, <Line: -                    this.modifiers = modifiers;
>, <Line: -                    this.internalName = internalName;
>, <Line: -                    this.descriptor = descriptor;
>, <Line: -                    this.genericSignature = genericSignature;
>, <Line: -                    this.exceptionName = exceptionName;
>, <Line: -                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
>, <Line: -                    Type[] parameterTypes = Type.getMethodType(descriptor).getArgumentTypes();
>, <Line: -                    parameterAnnotationTokens = new HashMap<Integer, List<LazyTypeDescription.AnnotationToken>>();
>, <Line: -                    for (int i = 0; i < parameterTypes.length; i++) {
>, <Line: -                        parameterAnnotationTokens.put(i, new ArrayList<LazyTypeDescription.AnnotationToken>());
>, <Line: -                    }
>, <Line: -                    parameterTokens = new ArrayList<LazyTypeDescription.MethodToken.ParameterToken>(parameterTypes.length);
>, <Line: -                    legacyParameterBag = new ParameterBag(parameterTypes);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
>, <Line: -                    return new AnnotationExtractor(new OnMethodCollector(descriptor),
>, <Line: -                            new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
>, <Line: -                    return new AnnotationExtractor(new OnMethodParameterCollector(descriptor, index),
>, <Line: -                            new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitLabel(Label label) {
>, <Line: -                    if (readerMode.isExtended() && firstLabel == null) {
>, <Line: -                        firstLabel = label;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
>, <Line: -                    if (readerMode.isExtended() && start == firstLabel) {
>, <Line: -                        legacyParameterBag.register(index, name);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitParameter(String name, int modifiers) {
>, <Line: -                    parameterTokens.add(new LazyTypeDescription.MethodToken.ParameterToken(name, modifiers));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationVisitor visitAnnotationDefault() {
>, <Line: -                    return new AnnotationExtractor(this, new ComponentTypeLocator.ForArrayType(descriptor));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void register(String ignored, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                    defaultValue = annotationValue;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void onComplete() {
>, <Line: -                    /* do nothing, as the register method is called at most once for default values */
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public void visitEnd() {
>, <Line: -                    methodTokens.add(new LazyTypeDescription.MethodToken(internalName,
>, <Line: -                            modifiers,
>, <Line: -                            descriptor,
>, <Line: -                            GenericTypeExtractor.ForSignature.OfMethod.extract(genericSignature),
>, <Line: -                            exceptionName,
>, <Line: -                            annotationTokens,
>, <Line: -                            parameterAnnotationTokens,
>, <Line: -                            parameterTokens.isEmpty()
>, <Line: -                                    ? legacyParameterBag.resolve((modifiers & Opcodes.ACC_STATIC) != 0)
>, <Line: -                                    : parameterTokens,
>, <Line: -                            defaultValue));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.Default.TypeExtractor.MethodExtractor{" +
>, <Line: -                            "typeExtractor=" + TypeExtractor.this +
>, <Line: -                            ", modifiers=" + modifiers +
>, <Line: -                            ", internalName='" + internalName + '\'' +
>, <Line: -                            ", descriptor='" + descriptor + '\'' +
>, <Line: -                            ", genericSignature='" + genericSignature + '\'' +
>, <Line: -                            ", exceptionName=" + Arrays.toString(exceptionName) +
>, <Line: -                            ", annotationTokens=" + annotationTokens +
>, <Line: -                            ", parameterAnnotationTokens=" + parameterAnnotationTokens +
>, <Line: -                            ", parameterTokens=" + parameterTokens +
>, <Line: -                            ", legacyParameterBag=" + legacyParameterBag +
>, <Line: -                            ", firstLabel=" + firstLabel +
>, <Line: -                            ", defaultValue=" + defaultValue +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * An annotation registrant for annotations found on the method itself.
>, <Line: -                 */
>, <Line: -                protected class OnMethodCollector implements AnnotationRegistrant {
>, <Line: -                     * The descriptor of the annotation.
>, <Line: -                     */
>, <Line: -                    private final String descriptor;
>, <Line: -                    /**
>, <Line: -                     * A mapping of annotation properties to their values.
>, <Line: -                    private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                     * Creates a new method annotation registrant.
>, <Line: -                     * @param descriptor The descriptor of the annotation.
>, <Line: -                    protected OnMethodCollector(String descriptor) {
>, <Line: -                        this.descriptor = descriptor;
>, <Line: -                        values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                    public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                        values.put(name, annotationValue);
>, <Line: -                    public void onComplete() {
>, <Line: -                        annotationTokens.add(new LazyTypeDescription.AnnotationToken(descriptor, values));
>, <Line: -                        return "TypePool.Default.TypeExtractor.MethodExtractor.OnMethodCollector{" +
>, <Line: -                                "methodExtractor=" + MethodExtractor.this +
>, <Line: -                                ", descriptor='" + descriptor + '\'' +
>, <Line: -                                ", values=" + values +
>, <Line: -                                '}';
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * An annotation registrant that collects annotations that are found on a specific parameter.
>, <Line: -                 */
>, <Line: -                protected class OnMethodParameterCollector implements AnnotationRegistrant {
>, <Line: -                     * The descriptor of the annotation.
>, <Line: -                    private final String descriptor;
>, <Line: -                    /**
>, <Line: -                     * The index of the parameter of this annotation.
>, <Line: -                     */
>, <Line: -                    private final int index;
>, <Line: -                    /**
>, <Line: -                     * A mapping of annotation properties to their values.
>, <Line: -                     */
>, <Line: -                    private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -                     * Creates a new method parameter annotation registrant.
>, <Line: -                     *
>, <Line: -                     * @param descriptor The descriptor of the annotation.
>, <Line: -                     * @param index      The index of the parameter of this annotation.
>, <Line: -                    protected OnMethodParameterCollector(String descriptor, int index) {
>, <Line: -                        this.descriptor = descriptor;
>, <Line: -                        this.index = index;
>, <Line: -                        values = new HashMap<String, AnnotationDescription.AnnotationValue<?, ?>>();
>, <Line: -                    }
>, <Line: -                    public void register(String name, AnnotationDescription.AnnotationValue<?, ?> annotationValue) {
>, <Line: -                        values.put(name, annotationValue);
>, <Line: -                    public void onComplete() {
>, <Line: -                        parameterAnnotationTokens.get(index).add(new LazyTypeDescription.AnnotationToken(descriptor, values));
>, <Line: -                        return "TypePool.Default.TypeExtractor.MethodExtractor.OnMethodParameterCollector{" +
>, <Line: -                                "methodExtractor=" + MethodExtractor.this +
>, <Line: -                                ", descriptor='" + descriptor + '\'' +
>, <Line: -                                ", index=" + index +
>, <Line: -                                ", values=" + values +
>, <Line: -                                '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * Determines the granularity of the class file parsing that is conducted by a {@link net.bytebuddy.pool.TypePool.Default}.
>, <Line: -         */
>, <Line: -        public enum ReaderMode {
>, <Line: -            /**
>, <Line: -             * The extended reader mode parses the code segment of each method in order to detect parameter names
>, <Line: -             * that are only stored in a method's debugging information but are not explicitly included.
>, <Line: -             */
>, <Line: -            EXTENDED(ClassReader.SKIP_FRAMES),
>, <Line: -            /**
>, <Line: -             * The fast reader mode skips the code segment of each method and cannot detect parameter names that are
>, <Line: -             * only contained within the debugging information. This mode still detects explicitly included method
>, <Line: -             * parameter names.
>, <Line: -             */
>, <Line: -            FAST(ClassReader.SKIP_CODE);
>, <Line: -            /**
>, <Line: -             * The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: -             */
>, <Line: -            private final int flags;
>, <Line: -            /**
>, <Line: -             * Creates a new reader mode constant.
>, <Line: -             *
>, <Line: -             * @param flags The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: -             */
>, <Line: -            ReaderMode(int flags) {
>, <Line: -                this.flags = flags;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: -             *
>, <Line: -             * @return The flags to provide to a {@link ClassReader} for parsing a file.
>, <Line: -             */
>, <Line: -            protected int getFlags() {
>, <Line: -                return flags;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Determines if this reader mode represents extended reading.
>, <Line: -             *
>, <Line: -             * @return {@code true} if this reader mode represents extended reading.
>, <Line: -             */
>, <Line: -            public boolean isExtended() {
>, <Line: -                return this == EXTENDED;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.Default.ReaderMode." + name();
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A class file locator that loads classes and describes the loaded classes as a {@link TypeDescription.ForLoadedType}
>, <Line: -         * if a type cannot be located as its class file.
>, <Line: -         */
>, <Line: -        public static class ClassLoading extends Default {
>, <Line: -            /**
>, <Line: -             * The class loader to query.
>, <Line: -             */
>, <Line: -            private final ClassLoader classLoader;
>, <Line: -            /**
>, <Line: -             * Creates a class loading type pool.
>, <Line: -             *
>, <Line: -             * @param cacheProvider    The cache provider to be used.
>, <Line: -             * @param classFileLocator The class file locator to be used.
>, <Line: -             * @param classLoader      The class loader to query.
>, <Line: -             */
>, <Line: -            public ClassLoading(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ClassLoader classLoader) {
>, <Line: -                super(cacheProvider, classFileLocator, ReaderMode.FAST);
>, <Line: -                this.classLoader = classLoader;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a class loading type pool that does not attempt to parse a class file but immediately falls back to loading one.
>, <Line: -             *
>, <Line: -             * @param classLoader The class loader to query.
>, <Line: -             * @return An appropriate type pool.
>, <Line: -             */
>, <Line: -            public static TypePool of(ClassLoader classLoader) {
>, <Line: -                return of(ClassFileLocator.NoOp.INSTANCE, classLoader);
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a class loading type pool that uses a simple cache.
>, <Line: -             *
>, <Line: -             * @param classFileLocator The class file locator to be used.
>, <Line: -             * @param classLoader      The class loader to query.
>, <Line: -             * @return An appropriate type pool.
>, <Line: -             */
>, <Line: -            public static TypePool of(ClassFileLocator classFileLocator, ClassLoader classLoader) {
>, <Line: -                return new ClassLoading(new CacheProvider.Simple(), classFileLocator, classLoader);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Resolution doDescribe(String name) {
>, <Line: -                Resolution resolution = super.doDescribe(name);
>, <Line: -                if (resolution.isResolved()) {
>, <Line: -                    return resolution;
>, <Line: -                }
>, <Line: -                try {
>, <Line: -                    return new Resolution.Simple(new TypeDescription.ForLoadedType(Class.forName(name, false, classLoader)));
>, <Line: -                } catch (ClassNotFoundException ignored) {
>, <Line: -                    return new Resolution.Illegal(name);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                if (!super.equals(other)) return false;
>, <Line: -                ClassLoading that = (ClassLoading) other;
>, <Line: -                return !(classLoader != null ? !classLoader.equals(that.classLoader) : that.classLoader != null);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = super.hashCode();
>, <Line: -                result = 31 * result + (classLoader != null ? classLoader.hashCode() : 0);
>, <Line: -                return result;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.Default.ClassLoading{" +
>, <Line: -                        "classFileLocator=" + classFileLocator +
>, <Line: -                        ", cacheProvider=" + cacheProvider +
>, <Line: -                        ", readerMode=" + readerMode +
>, <Line: -                        ", classLoader=" + classLoader +
>, <Line: -                        '}';
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A class file locator that maintains a map of precomputed classes which are returned as a resolution in case that a type name is known.
>, <Line: -         */
>, <Line: -        public static class Precomputed extends Default {
>, <Line: -            /**
>, <Line: -             * The precomputed type descriptions.
>, <Line: -             */
>, <Line: -            private final Map<String, TypeDescription> precomputed;
>, <Line: -            /**
>, <Line: -             * Creates a new precomputed type pool.
>, <Line: -             *
>, <Line: -             * @param cacheProvider    The cache provider to be used.
>, <Line: -             * @param classFileLocator The class file locator to be used.
>, <Line: -             * @param readerMode       The reader mode to apply by this default type pool.
>, <Line: -             * @param precomputed      The precomputed type descriptions.
>, <Line: -             */
>, <Line: -            public Precomputed(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, Map<String, TypeDescription> precomputed) {
>, <Line: -                super(cacheProvider, classFileLocator, readerMode);
>, <Line: -                this.precomputed = precomputed;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Creates a new precomputed type pool with the {@link Object} type being precomputed.
>, <Line: -             *
>, <Line: -             * @param cacheProvider    The cache provider to be used.
>, <Line: -             * @param classFileLocator The class file locator to be used.
>, <Line: -             * @param readerMode       The reader mode to apply by this default type pool.
>, <Line: -             * @return A type pool with the {@link Object} type being precomputed.
>, <Line: -             */
>, <Line: -            public static TypePool withObjectType(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
>, <Line: -                return new Precomputed(cacheProvider, classFileLocator, readerMode, Collections.singletonMap(Object.class.getName(), TypeDescription.OBJECT));
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            protected Resolution doDescribe(String name) {
>, <Line: -                TypeDescription typeDescription = precomputed.get(name);
>, <Line: -                return typeDescription == null
>, <Line: -                        ? super.doDescribe(name)
>, <Line: -                        : new Resolution.Simple(typeDescription);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                        && super.equals(other)
>, <Line: -                        && precomputed.equals(((Precomputed) other).precomputed);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = super.hashCode();
>, <Line: -                result = 31 * result + precomputed.hashCode();
>, <Line: -                return result;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.Default.Precomputed{" +
>, <Line: -                        "classFileLocator=" + classFileLocator +
>, <Line: -                        ", cacheProvider=" + cacheProvider +
>, <Line: -                        ", readerMode=" + readerMode +
>, <Line: -                        ", precomputed=" + precomputed +
>, <Line: -                        '}';
>, <Line: -            }
>, <Line: -        }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * A lazy facade of a type pool that delegates any lookups to another type pool only if another value than the type's name is looked up.
>, <Line: -     */
>, <Line: -    class LazyFacade extends AbstractBase {
>, <Line: -        /**
>, <Line: -         * The type pool to delegate to.
>, <Line: -         */
>, <Line: -        private final TypePool typePool;
>, <Line: -        /**
>, <Line: -         * Creates a lazy facade for a type pool.
>, <Line: -         *
>, <Line: -         * @param typePool The type pool to delegate to.
>, <Line: -         */
>, <Line: -        public LazyFacade(TypePool typePool) {
>, <Line: -            super(CacheProvider.NoOp.INSTANCE);
>, <Line: -            this.typePool = typePool;
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        protected Resolution doDescribe(String name) {
>, <Line: -            return new LazyResolution(typePool, name);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public void clear() {
>, <Line: -            typePool.clear();
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public boolean equals(Object other) {
>, <Line: -            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                    && typePool.equals(((LazyFacade) other).typePool);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public int hashCode() {
>, <Line: -            return typePool.hashCode();
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public String toString() {
>, <Line: -            return "TypePool.LazyFacade{" +
>, <Line: -                    "typePool=" + typePool +
>, <Line: -                    '}';
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * The lazy resolution for a lazy facade for a type pool.
>, <Line: -         */
>, <Line: -        protected static class LazyResolution implements Resolution {
>, <Line: -            /**
>, <Line: -             * The type pool to delegate to.
>, <Line: -             */
>, <Line: -            private final TypePool typePool;
>, <Line: -            /**
>, <Line: -             * The name of the type that is represented by this resolution.
>, <Line: -             */
>, <Line: -            private final String name;
>, <Line: -            /**
>, <Line: -             * Creates a lazy resolution for a lazy facade for a type pool.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to delegate to.
>, <Line: -             * @param name     The name of the type that is represented by this resolution.
>, <Line: -             */
>, <Line: -            protected LazyResolution(TypePool typePool, String name) {
>, <Line: -                this.typePool = typePool;
>, <Line: -                this.name = name;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isResolved() {
>, <Line: -                return typePool.describe(name).isResolved();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeDescription resolve() {
>, <Line: -                return new LazyTypeDescription(typePool, name);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                LazyResolution that = (LazyResolution) other;
>, <Line: -                return typePool.equals(that.typePool) && name.equals(that.name);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = typePool.hashCode();
>, <Line: -                result = 31 * result + name.hashCode();
>, <Line: -                return result;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.LazyFacade.LazyResolution{" +
>, <Line: -                        "typePool=" + typePool +
>, <Line: -                        ", name=" + name +
>, <Line: -                        '}';
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A lazy type description for a lazy facade of a type pool.
>, <Line: -             */
>, <Line: -            protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
>, <Line: -                /**
>, <Line: -                 * The type pool to delegate to.
>, <Line: -                 */
>, <Line: -                private final TypePool typePool;
>, <Line: -                /**
>, <Line: -                 * The name of the type that is represented by this resolution.
>, <Line: -                 */
>, <Line: -                private final String name;
>, <Line: -                /**
>, <Line: -                 * Creates a lazy type description for a lazy facade of a type pool.
>, <Line: -                 *
>, <Line: -                 * @param typePool The type pool to delegate to.
>, <Line: -                 * @param name     The name of the type that is represented by this resolution.
>, <Line: -                 */
>, <Line: -                protected LazyTypeDescription(TypePool typePool, String name) {
>, <Line: -                    this.typePool = typePool;
>, <Line: -                    this.name = name;
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * Resolves the actual type by querying the actual type pool.
>, <Line: -                 *
>, <Line: -                 * @return A representation of the actual type description.
>, <Line: -                 */
>, <Line: -                private TypeDescription resolve() {
>, <Line: -                    return typePool.describe(name).resolve();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic getSuperType() {
>, <Line: -                    return resolve().getSuperType();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeList.Generic getInterfaces() {
>, <Line: -                    return resolve().getInterfaces();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
>, <Line: -                    return resolve().getDeclaredFields();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
>, <Line: -                    return resolve().getDeclaredMethods();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription getDeclaringType() {
>, <Line: -                    return resolve().getDeclaringType();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public MethodDescription getEnclosingMethod() {
>, <Line: -                    return resolve().getEnclosingMethod();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription getEnclosingType() {
>, <Line: -                    return resolve().getEnclosingType();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeList getDeclaredTypes() {
>, <Line: -                    return resolve().getDeclaredTypes();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isAnonymousClass() {
>, <Line: -                    return resolve().isAnonymousClass();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isLocalClass() {
>, <Line: -                    return resolve().isLocalClass();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isMemberClass() {
>, <Line: -                    return resolve().isMemberClass();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public PackageDescription getPackage() {
>, <Line: -                    return resolve().getPackage();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public AnnotationList getDeclaredAnnotations() {
>, <Line: -                    return resolve().getDeclaredAnnotations();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeList.Generic getTypeVariables() {
>, <Line: -                    return resolve().getTypeVariables();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int getModifiers() {
>, <Line: -                    return resolve().getModifiers();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String getName() {
>, <Line: -                    return name;
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
>, <Line: -     * {@link AnnotationDescription} by querying a type pool at lookup time.
>, <Line: -     */
>, <Line: -    class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
>, <Line: -        /**
>, <Line: -         * Specifies a type without a super type definition, i.e. the {@link Object} type.
>, <Line: -         */
>, <Line: -        private static final String NO_SUPER_TYPE = null;
>, <Line: -        /**
>, <Line: -         * The type pool to be used for looking up linked types.
>, <Line: -         */
>, <Line: -        private final TypePool typePool;
>, <Line: -        /**
>, <Line: -         * The modifiers of this type.
>, <Line: -         */
>, <Line: -        private final int modifiers;
>, <Line: -        /**
>, <Line: -         * The binary name of this type.
>, <Line: -         */
>, <Line: -        private final String name;
>, <Line: -        /**
>, <Line: -         * The type's super type's descriptor or {@code null} if this type does not define a super type.
>, <Line: -         */
>, <Line: -        private final String superTypeDescriptor;
>, <Line: -        /**
>, <Line: -         * The resolution of this type's generic type.
>, <Line: -         */
>, <Line: -        private final GenericTypeToken.Resolution.ForType signatureResolution;
>, <Line: -        /**
>, <Line: -         * The descriptor of this type's interfaces.
>, <Line: -         */
>, <Line: -        private final List<String> interfaceTypeDescriptors;
>, <Line: -        /**
>, <Line: -         * The declaration context of this type.
>, <Line: -         */
>, <Line: -        private final DeclarationContext declarationContext;
>, <Line: -        /**
>, <Line: -         * A list of descriptors representing the types that are declared by this type.
>, <Line: -         */
>, <Line: -        private final List<String> declaredTypes;
>, <Line: -        /**
>, <Line: -         * {@code true} if this type is an anonymous type.
>, <Line: -         */
>, <Line: -        private final boolean anonymousType;
>, <Line: -        /**
>, <Line: -         * A list of tokens that represent the annotations of this type.
>, <Line: -         */
>, <Line: -        private final List<AnnotationToken> annotationTokens;
>, <Line: -        /**
>, <Line: -         * A list of field descriptions that are declared by this type.
>, <Line: -         */
>, <Line: -        private final List<FieldDescription.InDefinedShape> declaredFields;
>, <Line: -        /**
>, <Line: -         * A list of method descriptions that are declared by this type.
>, <Line: -         */
>, <Line: -        private final List<MethodDescription.InDefinedShape> declaredMethods;
>, <Line: -        /**
>, <Line: -         * Creates a new lazy type description.
>, <Line: -         *
>, <Line: -         * @param typePool              The type pool to be used for looking up linked types.
>, <Line: -         * @param modifiers             The modifiers of this type.
>, <Line: -         * @param name                  The binary name of this type.
>, <Line: -         * @param superTypeInternalName The internal name of this type's super type or {@code null} if no such super type is defined.
>, <Line: -         * @param interfaceInternalName An array of this type's interfaces or {@code null} if this type does not define any interfaces.
>, <Line: -         * @param signatureResolution   The resolution of this type's generic types.
>, <Line: -         * @param declarationContext    The declaration context of this type.
>, <Line: -         * @param declaredTypes         A list of descriptors representing the types that are declared by this type.
>, <Line: -         * @param anonymousType         {@code true} if this type is an anonymous type.
>, <Line: -         * @param annotationTokens      A list of tokens that represent the annotations of this type.
>, <Line: -         * @param fieldTokens           A list of field tokens describing the field's of this type.
>, <Line: -         * @param methodTokens          A list of method tokens describing the method's of this type.
>, <Line: -         */
>, <Line: -        protected LazyTypeDescription(TypePool typePool,
>, <Line: -                                      int modifiers,
>, <Line: -                                      String name,
>, <Line: -                                      String superTypeInternalName,
>, <Line: -                                      String[] interfaceInternalName,
>, <Line: -                                      GenericTypeToken.Resolution.ForType signatureResolution,
>, <Line: -                                      DeclarationContext declarationContext,
>, <Line: -                                      List<String> declaredTypes,
>, <Line: -                                      boolean anonymousType,
>, <Line: -                                      List<AnnotationToken> annotationTokens,
>, <Line: -                                      List<FieldToken> fieldTokens,
>, <Line: -                                      List<MethodToken> methodTokens) {
>, <Line: -            this.typePool = typePool;
>, <Line: -            this.modifiers = modifiers & ~Opcodes.ACC_SUPER;
>, <Line: -            this.name = Type.getObjectType(name).getClassName();
>, <Line: -            this.superTypeDescriptor = superTypeInternalName == null
>, <Line: -                    ? NO_SUPER_TYPE
>, <Line: -                    : Type.getObjectType(superTypeInternalName).getDescriptor();
>, <Line: -            this.signatureResolution = signatureResolution;
>, <Line: -            if (interfaceInternalName == null) {
>, <Line: -                interfaceTypeDescriptors = Collections.emptyList();
>, <Line: -            } else {
>, <Line: -                interfaceTypeDescriptors = new ArrayList<String>(interfaceInternalName.length);
>, <Line: -                for (String internalName : interfaceInternalName) {
>, <Line: -                    interfaceTypeDescriptors.add(Type.getObjectType(internalName).getDescriptor());
>, <Line: -                }
>, <Line: -            }
>, <Line: -            this.declarationContext = declarationContext;
>, <Line: -            this.declaredTypes = declaredTypes;
>, <Line: -            this.anonymousType = anonymousType;
>, <Line: -            this.annotationTokens = annotationTokens;
>, <Line: -            declaredFields = new ArrayList<FieldDescription.InDefinedShape>(fieldTokens.size());
>, <Line: -            for (FieldToken fieldToken : fieldTokens) {
>, <Line: -                declaredFields.add(fieldToken.toFieldDescription(this));
>, <Line: -            }
>, <Line: -            declaredMethods = new ArrayList<MethodDescription.InDefinedShape>(methodTokens.size());
>, <Line: -            for (MethodToken methodToken : methodTokens) {
>, <Line: -                declaredMethods.add(methodToken.toMethodDescription(this));
>, <Line: -            }
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public Generic getSuperType() {
>, <Line: -            return superTypeDescriptor == null || isInterface()
>, <Line: -                    ? TypeDescription.Generic.UNDEFINED
>, <Line: -                    : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, this);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public TypeList.Generic getInterfaces() {
>, <Line: -            return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, this);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public MethodDescription getEnclosingMethod() {
>, <Line: -            return declarationContext.getEnclosingMethod(typePool);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public TypeDescription getEnclosingType() {
>, <Line: -            return declarationContext.getEnclosingType(typePool);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public TypeList getDeclaredTypes() {
>, <Line: -            return new LazyTypeList(typePool, declaredTypes);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public boolean isAnonymousClass() {
>, <Line: -            return anonymousType;
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public boolean isLocalClass() {
>, <Line: -            return !anonymousType && declarationContext.isDeclaredInMethod();
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public boolean isMemberClass() {
>, <Line: -            return declarationContext.isDeclaredInType();
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
>, <Line: -            return new FieldList.Explicit<FieldDescription.InDefinedShape>(declaredFields);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
>, <Line: -            return new MethodList.Explicit<MethodDescription.InDefinedShape>(declaredMethods);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public PackageDescription getPackage() {
>, <Line: -            String name = getName();
>, <Line: -            int index = name.lastIndexOf('.');
>, <Line: -            return index == -1
>, <Line: -                    ? PackageDescription.UNDEFINED
>, <Line: -                    : new LazyPackageDescription(typePool, name.substring(0, index));
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public String getName() {
>, <Line: -            return name;
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public TypeDescription getDeclaringType() {
>, <Line: -            return declarationContext.isDeclaredInType()
>, <Line: -                    ? declarationContext.getEnclosingType(typePool)
>, <Line: -                    : TypeDescription.UNDEFINED;
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public int getModifiers() {
>, <Line: -            return modifiers;
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public AnnotationList getDeclaredAnnotations() {
>, <Line: -            return LazyAnnotationDescription.asList(typePool, annotationTokens);
>, <Line: -        }
>, <Line: -        @Override
>, <Line: -        public TypeList.Generic getTypeVariables() {
>, <Line: -            return signatureResolution.resolveTypeVariables(typePool, this);
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A declaration context encapsulates information about whether a type was declared within another type
>, <Line: -         * or within a method of another type.
>, <Line: -         */
>, <Line: -        protected interface DeclarationContext {
>, <Line: -            /**
>, <Line: -             * Returns the enclosing method or {@code null} if no such method exists.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to be used for looking up linked types.
>, <Line: -             * @return A method description describing the linked type or {@code null}.
>, <Line: -             */
>, <Line: -            MethodDescription getEnclosingMethod(TypePool typePool);
>, <Line: -            /**
>, <Line: -             * Returns the enclosing type or {@code null} if no such type exists.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to be used for looking up linked types.
>, <Line: -             * @return A type description describing the linked type or {@code null}.
>, <Line: -             */
>, <Line: -            TypeDescription getEnclosingType(TypePool typePool);
>, <Line: -            /**
>, <Line: -             * Returns {@code true} if this instance represents a self declared type.
>, <Line: -             *
>, <Line: -             * @return {@code true} if this instance represents a self declared type.
>, <Line: -             */
>, <Line: -            boolean isSelfDeclared();
>, <Line: -            /**
>, <Line: -             * Returns {@code true} if this instance represents a type that was declared within another type but not
>, <Line: -             * within a method.
>, <Line: -             *
>, <Line: -             * @return {@code true} if this instance represents a type that was declared within another type but not
>, <Line: -             * within a method.
>, <Line: -             */
>, <Line: -            boolean isDeclaredInType();
>, <Line: -            /**
>, <Line: -             * Returns {@code true} if this instance represents a type that was declared within a method.
>, <Line: -             *
>, <Line: -             * @return {@code true} if this instance represents a type that was declared within a method.
>, <Line: -             */
>, <Line: -            boolean isDeclaredInMethod();
>, <Line: -            /**
>, <Line: -             * Represents a self-declared type that is not defined within another type.
>, <Line: -             */
>, <Line: -            enum SelfDeclared implements DeclarationContext {
>, <Line: -                /**
>, <Line: -                 * The singleton instance.
>, <Line: -                 */
>, <Line: -                INSTANCE;
>, <Line: -                @Override
>, <Line: -                public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: -                    return MethodDescription.UNDEFINED;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: -                    return TypeDescription.UNDEFINED;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isSelfDeclared() {
>, <Line: -                    return true;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInType() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInMethod() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.DeclarationContext.SelfDeclared." + name();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A declaration context representing a type that is declared within another type but not within
>, <Line: -             * a method.
>, <Line: -             */
>, <Line: -            class DeclaredInType implements DeclarationContext {
>, <Line: -                /**
>, <Line: -                 * The binary name of the referenced type.
>, <Line: -                 */
>, <Line: -                private final String name;
>, <Line: -                /**
>, <Line: -                 * Creates a new declaration context for a type that is declared within another type.
>, <Line: -                 *
>, <Line: -                 * @param internalName The internal name of the declaring type.
>, <Line: -                 */
>, <Line: -                public DeclaredInType(String internalName) {
>, <Line: -                    name = internalName.replace('/', '.');
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: -                    return MethodDescription.UNDEFINED;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: -                    return typePool.describe(name).resolve();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isSelfDeclared() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInType() {
>, <Line: -                    return true;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInMethod() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                            && name.equals(((DeclaredInType) other).name);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    return name.hashCode();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.DeclarationContext.DeclaredInType{" +
>, <Line: -                            "name='" + name + '\'' +
>, <Line: -                            '}';
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A declaration context representing a type that is declared within a method of another type.
>, <Line: -             */
>, <Line: -            class DeclaredInMethod implements DeclarationContext {
>, <Line: -                /**
>, <Line: -                 * The binary name of the declaring type.
>, <Line: -                 */
>, <Line: -                private final String name;
>, <Line: -                 * The name of the method that is declaring a type.
>, <Line: -                private final String methodName;
>, <Line: -                /**
>, <Line: -                 * The descriptor of the method that is declaring a type.
>, <Line: -                 */
>, <Line: -                private final String methodDescriptor;
>, <Line: -                /**
>, <Line: -                 * Creates a new declaration context for a method that declares a type.
>, <Line: -                 *
>, <Line: -                 * @param internalName     The internal name of the declaring type.
>, <Line: -                 * @param methodName       The name of the method that is declaring a type.
>, <Line: -                 * @param methodDescriptor The descriptor of the method that is declaring a type.
>, <Line: -                 */
>, <Line: -                public DeclaredInMethod(String internalName, String methodName, String methodDescriptor) {
>, <Line: -                    name = internalName.replace('/', '.');
>, <Line: -                    this.methodName = methodName;
>, <Line: -                    this.methodDescriptor = methodDescriptor;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public MethodDescription getEnclosingMethod(TypePool typePool) {
>, <Line: -                    return getEnclosingType(typePool).getDeclaredMethods().filter(hasMethodName(methodName).and(hasDescriptor(methodDescriptor))).getOnly();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription getEnclosingType(TypePool typePool) {
>, <Line: -                    return typePool.describe(name).resolve();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isSelfDeclared() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInType() {
>, <Line: -                    return false;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean isDeclaredInMethod() {
>, <Line: -                    return true;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    if (this == other) return true;
>, <Line: -                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                    DeclaredInMethod that = (DeclaredInMethod) other;
>, <Line: -                    return methodDescriptor.equals(that.methodDescriptor)
>, <Line: -                            && methodName.equals(that.methodName)
>, <Line: -                            && name.equals(that.name);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    int result = name.hashCode();
>, <Line: -                    result = 31 * result + methodName.hashCode();
>, <Line: -                    result = 31 * result + methodDescriptor.hashCode();
>, <Line: -                    return result;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.DeclarationContext.DeclaredInMethod{" +
>, <Line: -                            "name='" + name + '\'' +
>, <Line: -                            ", methodName='" + methodName + '\'' +
>, <Line: -                            ", methodDescriptor='" + methodDescriptor + '\'' +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A token that represents a generic Java type.
>, <Line: -         */
>, <Line: -        protected interface GenericTypeToken {
>, <Line: -            /**
>, <Line: -             * Returns the sort of the generic type this token represents.
>, <Line: -             *
>, <Line: -             * @return The sort of the generic type this token represents.
>, <Line: -             */
>, <Line: -            TypeDefinition.Sort getSort();
>, <Line: -            /**
>, <Line: -             * Transforms this token into a generic type representation.
>, <Line: -             *
>, <Line: -             * @param typePool           The type pool to be used for locating non-generic type descriptions.
>, <Line: -             * @param typeVariableSource The type variable source.
>, <Line: -             * @return A description of the represented generic type.
>, <Line: -             */
>, <Line: -            Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource);
>, <Line: -            /**
>, <Line: -             * A generic type token that represents a primitive type.
>, <Line: -             */
>, <Line: -            enum ForPrimitiveType implements GenericTypeToken {
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code boolean} type.
>, <Line: -                 */
>, <Line: -                BOOLEAN(boolean.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code byte} type.
>, <Line: -                 */
>, <Line: -                BYTE(byte.class),
>, <Line: -                 * The generic type token describing the {@code short} type.
>, <Line: -                SHORT(short.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code char} type.
>, <Line: -                 */
>, <Line: -                CHAR(char.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code int} type.
>, <Line: -                 */
>, <Line: -                INTEGER(int.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code long} type.
>, <Line: -                 */
>, <Line: -                LONG(long.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code float} type.
>, <Line: -                 */
>, <Line: -                FLOAT(float.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code double} type.
>, <Line: -                 */
>, <Line: -                DOUBLE(double.class),
>, <Line: -                /**
>, <Line: -                 * The generic type token describing the {@code void} type.
>, <Line: -                 */
>, <Line: -                VOID(void.class);
>, <Line: -                /**
>, <Line: -                 * A description of this primitive type token.
>, <Line: -                 */
>, <Line: -                private final Generic typeDescription;
>, <Line: -                /**
>, <Line: -                 * Creates a new primitive type token.
>, <Line: -                 *
>, <Line: -                 * @param type The loaded type representing this primitive.
>, <Line: -                 */
>, <Line: -                ForPrimitiveType(Class<?> type) {
>, <Line: -                    typeDescription = new Generic.OfNonGenericType.ForLoadedType(type);
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * Resolves a generic type token of a primitive type.
>, <Line: -                 *
>, <Line: -                 * @param descriptor The descriptor of the primitive type.
>, <Line: -                 * @return The corresponding generic type token.
>, <Line: -                 */
>, <Line: -                public static GenericTypeToken of(char descriptor) {
>, <Line: -                    switch (descriptor) {
>, <Line: -                        case 'V':
>, <Line: -                            return VOID;
>, <Line: -                        case 'Z':
>, <Line: -                            return BOOLEAN;
>, <Line: -                        case 'B':
>, <Line: -                            return BYTE;
>, <Line: -                        case 'S':
>, <Line: -                            return SHORT;
>, <Line: -                        case 'C':
>, <Line: -                            return CHAR;
>, <Line: -                        case 'I':
>, <Line: -                            return INTEGER;
>, <Line: -                        case 'J':
>, <Line: -                            return LONG;
>, <Line: -                        case 'F':
>, <Line: -                            return FLOAT;
>, <Line: -                        case 'D':
>, <Line: -                            return DOUBLE;
>, <Line: -                        default:
>, <Line: -                            throw new IllegalArgumentException("Not a valid primitive type descriptor: " + descriptor);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.NON_GENERIC;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return typeDescription;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForPrimitiveType." + name();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A generic type token that represents an unbound wildcard.
>, <Line: -             */
>, <Line: -            enum ForUnboundWildcard implements GenericTypeToken {
>, <Line: -                /**
>, <Line: -                 * The singleton instance.
>, <Line: -                 */
>, <Line: -                INSTANCE;
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.WILDCARD;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return Generic.OfWildcardType.Latent.unbounded();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForUnboundWildcard." + name();
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A resolution of a type's, method's or field's generic types.
>, <Line: -             */
>, <Line: -            interface Resolution {
>, <Line: -                /**
>, <Line: -                 * Resolves the type variables of the represented element.
>, <Line: -                 *
>, <Line: -                 * @param typePool           The type pool to be used for locating non-generic type descriptions.
>, <Line: -                 * @param typeVariableSource The type variable source to use for resolving type variables.
>, <Line: -                 * @return A list describing the resolved generic types.
>, <Line: -                 */
>, <Line: -                TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource);
>, <Line: -                /**
>, <Line: -                 * A resolution of a type's, method's or field's generic types if all of the represented element's are raw.
>, <Line: -                 */
>, <Line: -                enum Raw implements ForType, ForMethod, ForField {
>, <Line: -                     * The singleton instance.
>, <Line: -                    INSTANCE;
>, <Line: -                    @Override
>, <Line: -                    public Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, FieldDescription definingField) {
>, <Line: -                        return TokenizedGenericType.toErasure(typePool, fieldTypeDescriptor).asGenericType();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return TokenizedGenericType.toErasure(typePool, returnTypeDescriptor).asGenericType();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return new LazyTypeList.Generic(typePool, parameterTypeDescriptors);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return new LazyTypeList.Generic(typePool, exceptionTypeDescriptors);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic resolveSuperType(String superTypeDescriptor, TypePool typePool, TypeDescription definingType) {
>, <Line: -                        return TokenizedGenericType.toErasure(typePool, superTypeDescriptor).asGenericType();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors, TypePool typePool, TypeDescription definingType) {
>, <Line: -                        return new LazyTypeList.Generic(typePool, interfaceTypeDescriptors);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                        return new TypeList.Generic.Empty();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.LazyTypeDescription.GenericTypeToken.Resolution.Raw." + name();
>, <Line: -                 * A resolution of a type's, method's or field's generic types if its generic signature is malformed.
>, <Line: -                enum Malformed implements ForType, ForMethod, ForField {
>, <Line: -                     * The singleton instance.
>, <Line: -                    INSTANCE;
>, <Line: -                    @Override
>, <Line: -                    public Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, FieldDescription definingField) {
>, <Line: -                        return new TokenizedGenericType.Malformed(typePool, fieldTypeDescriptor);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return new TokenizedGenericType.Malformed(typePool, returnTypeDescriptor);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return new TokenizedGenericType.Malformed.TokenList(typePool, parameterTypeDescriptors);
>, <Line: -                    public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                        return new TokenizedGenericType.Malformed.TokenList(typePool, exceptionTypeDescriptors);
>, <Line: -                    public Generic resolveSuperType(String superTypeDescriptor, TypePool typePool, TypeDescription definingType) {
>, <Line: -                        return new TokenizedGenericType.Malformed(typePool, superTypeDescriptor);
>, <Line: -                    public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors, TypePool typePool, TypeDescription definingType) {
>, <Line: -                        return new TokenizedGenericType.Malformed.TokenList(typePool, interfaceTypeDescriptors);
>, <Line: -                    public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                        throw new GenericSignatureFormatError();
>, <Line: -                        return "TypePool.LazyTypeDescription.GenericTypeToken.Resolution.Malformed." + name();
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * A resolution of the generic types of a {@link TypeDescription}.
>, <Line: -                 */
>, <Line: -                interface ForType extends Resolution {
>, <Line: -                     * Resolves the generic super type of the represented type.
>, <Line: -                     *
>, <Line: -                     * @param superTypeDescriptor The descriptor of the raw super type.
>, <Line: -                     * @param typePool            The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingType        The type that defines this super type.
>, <Line: -                     * @return A description of this type's generic super type.
>, <Line: -                    Generic resolveSuperType(String superTypeDescriptor, TypePool typePool, TypeDescription definingType);
>, <Line: -                    /**
>, <Line: -                     * Resolves the generic interface types of the represented type.
>, <Line: -                     *
>, <Line: -                     * @param interfaceTypeDescriptors The descriptor of the raw interface types.
>, <Line: -                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingType             The type that defines these interface type.
>, <Line: -                     * @return A description of this type's generic interface types.
>, <Line: -                     */
>, <Line: -                    TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors, TypePool typePool, TypeDescription definingType);
>, <Line: -                    /**
>, <Line: -                     * An implementation of a tokenized resolution of generic types of a {@link TypeDescription}.
>, <Line: -                     */
>, <Line: -                    class Tokenized implements ForType {
>, <Line: -                         * The super type's generic type token.
>, <Line: -                        private final GenericTypeToken superTypeToken;
>, <Line: -                         * The interface type's generic type tokens.
>, <Line: -                        private final List<GenericTypeToken> interfaceTypeTokens;
>, <Line: -                         * The type variables generic type tokens.
>, <Line: -                        private final List<GenericTypeToken> typeVariableTokens;
>, <Line: -                         * Creates a new tokenized resolution of a {@link TypeDescription}'s generic signatures.
>, <Line: -                         * @param superTypeToken      The super type's generic type token.
>, <Line: -                         * @param interfaceTypeTokens The interface type's generic type tokens.
>, <Line: -                         * @param typeVariableTokens  The type variables generic type tokens.
>, <Line: -                        public Tokenized(GenericTypeToken superTypeToken,
>, <Line: -                                         List<GenericTypeToken> interfaceTypeTokens,
>, <Line: -                                         List<GenericTypeToken> typeVariableTokens) {
>, <Line: -                            this.superTypeToken = superTypeToken;
>, <Line: -                            this.interfaceTypeTokens = interfaceTypeTokens;
>, <Line: -                            this.typeVariableTokens = typeVariableTokens;
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public Generic resolveSuperType(String superTypeDescriptor, TypePool typePool, TypeDescription definingType) {
>, <Line: -                            return new TokenizedGenericType(typePool, superTypeToken, superTypeDescriptor, definingType);
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeList.Generic resolveInterfaceTypes(List<String> interfaceTypeDescriptors, TypePool typePool, TypeDescription definingType) {
>, <Line: -                            return new TokenizedGenericType.TokenList(typePool, interfaceTypeTokens, interfaceTypeDescriptors, definingType);
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                            return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource);
>, <Line: -                        public boolean equals(Object other) {
>, <Line: -                            if (this == other) return true;
>, <Line: -                            if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                            Tokenized tokenized = (Tokenized) other;
>, <Line: -                            return superTypeToken.equals(tokenized.superTypeToken)
>, <Line: -                                    && interfaceTypeTokens.equals(tokenized.interfaceTypeTokens)
>, <Line: -                                    && typeVariableTokens.equals(tokenized.typeVariableTokens);
>, <Line: -                        public int hashCode() {
>, <Line: -                            int result = superTypeToken.hashCode();
>, <Line: -                            result = 31 * result + interfaceTypeTokens.hashCode();
>, <Line: -                            result = 31 * result + typeVariableTokens.hashCode();
>, <Line: -                            return result;
>, <Line: -                        public String toString() {
>, <Line: -                            return "TypePool.LazyTypeDescription.GenericTypeToken.Resolution.ForType.Tokenized{" +
>, <Line: -                                    "superTypeToken=" + superTypeToken +
>, <Line: -                                    ", interfaceTypeTokens=" + interfaceTypeTokens +
>, <Line: -                                    ", typeVariableTokens=" + typeVariableTokens +
>, <Line: -                                    '}';
>, <Line: -                 * A resolution of the generic types of a {@link MethodDescription}.
>, <Line: -                interface ForMethod extends Resolution {
>, <Line: -                     * Resolves the return type of the represented method.
>, <Line: -                     *
>, <Line: -                     * @param returnTypeDescriptor The descriptor of the raw return type.
>, <Line: -                     * @param typePool             The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingMethod       The method that defines this return type.
>, <Line: -                     * @return A description of this type's generic return type.
>, <Line: -                    Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, MethodDescription definingMethod);
>, <Line: -                     * Resolves the generic parameter types of the represented method.
>, <Line: -                     *
>, <Line: -                     * @param parameterTypeDescriptors The descriptor of the raw parameter types.
>, <Line: -                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingMethod           The method that defines these parameter types.
>, <Line: -                     * @return A description of this type's generic interface types.
>, <Line: -                    TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors, TypePool typePool, MethodDescription definingMethod);
>, <Line: -                     * Resolves the generic parameter types of the represented method.
>, <Line: -                     * @param exceptionTypeDescriptors The descriptor of the raw exception types.
>, <Line: -                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingMethod           The method that defines these exception types.
>, <Line: -                     * @return A description of this type's generic interface types.
>, <Line: -                    TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors, TypePool typePool, MethodDescription definingMethod);
>, <Line: -                     * An implementation of a tokenized resolution of generic types of a {@link MethodDescription}.
>, <Line: -                    class Tokenized implements ForMethod {
>, <Line: -                         * A token describing the represented method's return type.
>, <Line: -                        private final GenericTypeToken returnTypeToken;
>, <Line: -                         * A token describing the represented method's parameter types.
>, <Line: -                         * A token describing the represented method's exception types.
>, <Line: -                         */
>, <Line: -                        private final List<GenericTypeToken> exceptionTypeTokens;
>, <Line: -                        /**
>, <Line: -                         * A token describing the represented method's type variables.
>, <Line: -                        private final List<GenericTypeToken> typeVariableTokens;
>, <Line: -                         * Creates a new tokenized resolution of a {@link MethodDescription}'s generic signatures.
>, <Line: -                         * @param returnTypeToken     A token describing the represented method's return type.
>, <Line: -                         * @param parameterTypeTokens A token describing the represented method's parameter types.
>, <Line: -                         * @param exceptionTypeTokens A token describing the represented method's exception types.
>, <Line: -                         * @param typeVariableTokens  A token describing the represented method's type variables.
>, <Line: -                        public Tokenized(GenericTypeToken returnTypeToken,
>, <Line: -                                         List<GenericTypeToken> parameterTypeTokens,
>, <Line: -                                         List<GenericTypeToken> exceptionTypeTokens,
>, <Line: -                                         List<GenericTypeToken> typeVariableTokens) {
>, <Line: -                            this.returnTypeToken = returnTypeToken;
>, <Line: -                            this.exceptionTypeTokens = exceptionTypeTokens;
>, <Line: -                            this.typeVariableTokens = typeVariableTokens;
>, <Line: -                        public Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                            return new TokenizedGenericType(typePool, returnTypeToken, returnTypeDescriptor, definingMethod);
>, <Line: -                        public TypeList.Generic resolveParameterTypes(List<String> parameterTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                            return new TokenizedGenericType.TokenList(typePool, parameterTypeTokens, parameterTypeDescriptors, definingMethod);
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeList.Generic resolveExceptionTypes(List<String> exceptionTypeDescriptors, TypePool typePool, MethodDescription definingMethod) {
>, <Line: -                            // Generic signatures of methods are optional.
>, <Line: -                            return exceptionTypeTokens.isEmpty()
>, <Line: -                                    ? Raw.INSTANCE.resolveExceptionTypes(exceptionTypeDescriptors, typePool, definingMethod)
>, <Line: -                                    : new TokenizedGenericType.TokenList(typePool, exceptionTypeTokens, exceptionTypeDescriptors, definingMethod);
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                            return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource);
>, <Line: -                            Tokenized tokenized = (Tokenized) other;
>, <Line: -                            return returnTypeToken.equals(tokenized.returnTypeToken)
>, <Line: -                                    && parameterTypeTokens.equals(tokenized.parameterTypeTokens)
>, <Line: -                                    && exceptionTypeTokens.equals(tokenized.exceptionTypeTokens)
>, <Line: -                                    && typeVariableTokens.equals(tokenized.typeVariableTokens);
>, <Line: -                            int result = returnTypeToken.hashCode();
>, <Line: -                            result = 31 * result + exceptionTypeTokens.hashCode();
>, <Line: -                            result = 31 * result + typeVariableTokens.hashCode();
>, <Line: -                            return "TypePool.LazyTypeDescription.GenericTypeToken.Resolution.ForMethod.Tokenized{" +
>, <Line: -                                    "returnTypeToken=" + returnTypeToken +
>, <Line: -                                    ", exceptionTypeTokens=" + exceptionTypeTokens +
>, <Line: -                                    ", typeVariableTokens=" + typeVariableTokens +
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * A resolution of the generic types of a {@link FieldDescription}.
>, <Line: -                 */
>, <Line: -                interface ForField {
>, <Line: -                    /**
>, <Line: -                     * Resolves the field type of the represented field.
>, <Line: -                     *
>, <Line: -                     * @param fieldTypeDescriptor The descriptor of the raw field type.
>, <Line: -                     * @param typePool            The type pool to be used for locating non-generic type descriptions.
>, <Line: -                     * @param definingField       The field that defines this type.
>, <Line: -                     * @return A description of this field's type.
>, <Line: -                     */
>, <Line: -                    Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, FieldDescription definingField);
>, <Line: -                     * An implementation of a tokenized resolution of the generic type of a {@link FieldDescription}.
>, <Line: -                    class Tokenized implements ForField {
>, <Line: -                         * The token of the represented field's type.
>, <Line: -                        private final GenericTypeToken fieldTypeToken;
>, <Line: -                         * Creates a new tokenized resolution of a {@link FieldDescription}'s type.
>, <Line: -                         * @param fieldTypeToken The token of the represented field's type.
>, <Line: -                        public Tokenized(GenericTypeToken fieldTypeToken) {
>, <Line: -                            this.fieldTypeToken = fieldTypeToken;
>, <Line: -                        public Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, FieldDescription definingField) {
>, <Line: -                            return new TokenizedGenericType(typePool, fieldTypeToken, fieldTypeDescriptor, definingField.getDeclaringType().asErasure());
>, <Line: -                        public boolean equals(Object other) {
>, <Line: -                            return this == other || other != null && getClass() == other.getClass()
>, <Line: -                                    && fieldTypeToken.equals(((Tokenized) other).fieldTypeToken);
>, <Line: -                        public int hashCode() {
>, <Line: -                            return fieldTypeToken.hashCode();
>, <Line: -                        public String toString() {
>, <Line: -                            return "TypePool.LazyTypeDescription.GenericTypeToken.Resolution.ForField.Tokenized{" +
>, <Line: -                                    "fieldTypeToken=" + fieldTypeToken +
>, <Line: -                                    '}';
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A generic type token that represents a non-generic type.
>, <Line: -             */
>, <Line: -            class ForRawType implements GenericTypeToken {
>, <Line: -                /**
>, <Line: -                 * The name of the represented type.
>, <Line: -                 */
>, <Line: -                private final String name;
>, <Line: -                 * Creates a new type token that represents a non-generic type.
>, <Line: -                 *
>, <Line: -                 * @param name The name of the represented type.
>, <Line: -                public ForRawType(String name) {
>, <Line: -                    this.name = name;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.NON_GENERIC;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return typePool.describe(name).resolve().asGenericType();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass()) && name.equals(((ForRawType) other).name);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    return name.hashCode();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForRawType{" +
>, <Line: -                            "name='" + name + '\'' +
>, <Line: -                            '}';
>, <Line: -             * A generic type token that represents a type variable.
>, <Line: -            class ForTypeVariable implements GenericTypeToken {
>, <Line: -                 * This type variable's nominal symbol.
>, <Line: -                private final String symbol;
>, <Line: -                 * Creates a generic type token that represents a type variable.
>, <Line: -                 * @param symbol This type variable's nominal symbol.
>, <Line: -                public ForTypeVariable(String symbol) {
>, <Line: -                    this.symbol = symbol;
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.VARIABLE;
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    Generic typeVariable = typeVariableSource.findVariable(symbol);
>, <Line: -                    if (typeVariable == null) {
>, <Line: -                        throw new IllegalStateException("Cannot resolve type variable '" + symbol + "' for " + typeVariableSource);
>, <Line: -                    } else {
>, <Line: -                        return typeVariable;
>, <Line: -                    }
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass()) && symbol.equals(((ForTypeVariable) other).symbol);
>, <Line: -                    return symbol.hashCode();
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForTypeVariable{" +
>, <Line: -                            "symbol='" + symbol + '\'' +
>, <Line: -                 * A generic type token that represent a formal type variable, i.e. a type variable including its upper bounds.
>, <Line: -                public static class Formal implements GenericTypeToken {
>, <Line: -                     * This type variable's nominal symbol.
>, <Line: -                    private final String symbol;
>, <Line: -                     * A list of tokens that represent this type variable's upper bounds.
>, <Line: -                    private final List<GenericTypeToken> bounds;
>, <Line: -                     * Creates generic type token that represent a formal type variable.
>, <Line: -                     *
>, <Line: -                     * @param symbol This type variable's nominal symbol.
>, <Line: -                     * @param bounds A list of tokens that represent this type variable's upper bounds.
>, <Line: -                    public Formal(String symbol, List<GenericTypeToken> bounds) {
>, <Line: -                        this.symbol = symbol;
>, <Line: -                        this.bounds = bounds;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeDefinition.Sort getSort() {
>, <Line: -                        return TypeDefinition.Sort.VARIABLE;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                        return new LazyTypeVariable(typePool, typeVariableSource);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public boolean equals(Object other) {
>, <Line: -                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                                && symbol.equals(((Formal) other).symbol)
>, <Line: -                                && bounds.equals(((Formal) other).bounds);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public int hashCode() {
>, <Line: -                        return symbol.hashCode() + 31 * bounds.hashCode();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.LazyTypeDescription.GenericTypeToken.ForTypeVariable.Formal{" +
>, <Line: -                                "symbol='" + symbol + '\'' +
>, <Line: -                                "bounds='" + bounds + '\'' +
>, <Line: -                                '}';
>, <Line: -                     * A type description that represents a type variable with bounds that are resolved lazily.
>, <Line: -                    protected class LazyTypeVariable extends Generic.OfTypeVariable {
>, <Line: -                        /**
>, <Line: -                         * The type pool to use for locating type descriptions.
>, <Line: -                         */
>, <Line: -                        private final TypePool typePool;
>, <Line: -                         * The type variable source to use for locating type variables.
>, <Line: -                        private final TypeVariableSource typeVariableSource;
>, <Line: -                         * Creates a lazy type description of a type variables.
>, <Line: -                         * @param typePool           The type pool to use for locating type descriptions.
>, <Line: -                         * @param typeVariableSource The type variable source to use for locating type variables.
>, <Line: -                        protected LazyTypeVariable(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                            this.typePool = typePool;
>, <Line: -                            this.typeVariableSource = typeVariableSource;
>, <Line: -                        public TypeList.Generic getUpperBounds() {
>, <Line: -                            List<Generic> boundTypes = new ArrayList<Generic>(bounds.size());
>, <Line: -                            for (GenericTypeToken bound : bounds) {
>, <Line: -                                boundTypes.add(bound.toGenericType(typePool, typeVariableSource));
>, <Line: -                            }
>, <Line: -                            return new TypeList.Generic.Explicit(boundTypes);
>, <Line: -                        public TypeVariableSource getVariableSource() {
>, <Line: -                            return typeVariableSource;
>, <Line: -                        public String getSymbol() {
>, <Line: -                            return symbol;
>, <Line: -             * A generic type token that represents a generic array.
>, <Line: -            class ForGenericArray implements GenericTypeToken {
>, <Line: -                 * The array's component type.
>, <Line: -                private final GenericTypeToken componentTypeToken;
>, <Line: -                 * Creates a generic type token that represents a generic array.
>, <Line: -                 *
>, <Line: -                 * @param componentTypeToken The array's component type.
>, <Line: -                public ForGenericArray(GenericTypeToken componentTypeToken) {
>, <Line: -                    this.componentTypeToken = componentTypeToken;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.GENERIC_ARRAY;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return Generic.OfGenericArray.Latent.of(componentTypeToken.toGenericType(typePool, typeVariableSource), 1);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                            && componentTypeToken.equals(((ForGenericArray) other).componentTypeToken);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    return componentTypeToken.hashCode();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForGenericArray{" +
>, <Line: -                            "componentTypeToken='" + componentTypeToken + '\'' +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A generic type token for a wildcard that is bound below.
>, <Line: -             */
>, <Line: -            class ForLowerBoundWildcard implements GenericTypeToken {
>, <Line: -                 * A token that represents the wildcard's lower bound.
>, <Line: -                private final GenericTypeToken baseType;
>, <Line: -                 * Creates a generic type token for a wildcard that is bound below.
>, <Line: -                 *
>, <Line: -                 * @param baseType A token that represents the wildcard's lower bound.
>, <Line: -                public ForLowerBoundWildcard(GenericTypeToken baseType) {
>, <Line: -                    this.baseType = baseType;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.WILDCARD;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return Generic.OfWildcardType.Latent.boundedBelow(baseType.toGenericType(typePool, typeVariableSource));
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                            && baseType.equals(((ForLowerBoundWildcard) other).baseType);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    return baseType.hashCode();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForLowerBoundWildcard{" +
>, <Line: -                            "baseType=" + baseType +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A generic type token for a wildcard that is bound above.
>, <Line: -             */
>, <Line: -            class ForUpperBoundWildcard implements GenericTypeToken {
>, <Line: -                 * A token that represents the wildcard's upper bound.
>, <Line: -                private final GenericTypeToken baseType;
>, <Line: -                 * Creates a generic type token for a wildcard that is bound above.
>, <Line: -                 *
>, <Line: -                 * @param baseType A token that represents the wildcard's upper bound.
>, <Line: -                public ForUpperBoundWildcard(GenericTypeToken baseType) {
>, <Line: -                    this.baseType = baseType;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.WILDCARD;
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return Generic.OfWildcardType.Latent.boundedAbove(baseType.toGenericType(typePool, typeVariableSource));
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                            && baseType.equals(((ForUpperBoundWildcard) other).baseType);
>, <Line: -                    return baseType.hashCode();
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForUpperBoundWildcard{" +
>, <Line: -                            "baseType=" + baseType +
>, <Line: -             * A generic type token that represents a parameterized type.
>, <Line: -            class ForParameterizedType implements GenericTypeToken {
>, <Line: -                 * The name of the parameterized type's erasure.
>, <Line: -                 * A list of tokens that represent the parameters of the represented type.
>, <Line: -                private final List<GenericTypeToken> parameters;
>, <Line: -                 * Creates a type token that represents a parameterized type.
>, <Line: -                 *
>, <Line: -                 * @param name       The name of the parameterized type's erasure.
>, <Line: -                 * @param parameters A list of tokens that represent the parameters of the represented type.
>, <Line: -                public ForParameterizedType(String name, List<GenericTypeToken> parameters) {
>, <Line: -                    this.name = name;
>, <Line: -                    this.parameters = parameters;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDefinition.Sort getSort() {
>, <Line: -                    return TypeDefinition.Sort.PARAMETERIZED;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                    return new LazyParameterizedType(typePool, typeVariableSource);
>, <Line: -                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                            && name.equals(((ForParameterizedType) other).name)
>, <Line: -                            && parameters.equals(((ForParameterizedType) other).parameters);
>, <Line: -                    return name.hashCode() + 31 * parameters.hashCode();
>, <Line: -                    return "TypePool.LazyTypeDescription.GenericTypeToken.ForParameterizedType{" +
>, <Line: -                            "name='" + name + '\'' +
>, <Line: -                            "parameters=" + parameters +
>, <Line: -                 * A generic type token to describe a parameterized type description with a generic owner type.
>, <Line: -                public static class Nested implements GenericTypeToken {
>, <Line: -                     * The name of the parameterized type's erasure.
>, <Line: -                    private final String name;
>, <Line: -                     * A list of tokens that represent the parameters of the represented type.
>, <Line: -                    private final List<GenericTypeToken> parameters;
>, <Line: -                     * A token that describes the described parameterized type's owner type.
>, <Line: -                    private final GenericTypeToken ownerType;
>, <Line: -                     * Creates a type token that represents a parameterized type.
>, <Line: -                     *
>, <Line: -                     * @param name       The name of the parameterized type's erasure.
>, <Line: -                     * @param parameters A list of tokens that represent the parameters of the represented type.
>, <Line: -                     * @param ownerType  A token that describes the described parameterized type's owner type.
>, <Line: -                    public Nested(String name, List<GenericTypeToken> parameters, GenericTypeToken ownerType) {
>, <Line: -                        this.name = name;
>, <Line: -                        this.parameters = parameters;
>, <Line: -                        this.ownerType = ownerType;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeDefinition.Sort getSort() {
>, <Line: -                        return TypeDefinition.Sort.PARAMETERIZED;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                        return new LazyParameterizedType(typePool, typeVariableSource);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public boolean equals(Object other) {
>, <Line: -                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                                && name.equals(((Nested) other).name)
>, <Line: -                                && ownerType.equals(((Nested) other).ownerType)
>, <Line: -                                && parameters.equals(((Nested) other).parameters);
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public int hashCode() {
>, <Line: -                        return name.hashCode() + 31 * parameters.hashCode();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.LazyTypeDescription.GenericTypeToken.ForParameterizedType.Nested{" +
>, <Line: -                                "name='" + name + '\'' +
>, <Line: -                                "parameters=" + parameters +
>, <Line: -                                "ownerType=" + ownerType +
>, <Line: -                                '}';
>, <Line: -                     * A lazy description of a parameterized type with an owner type.
>, <Line: -                    protected class LazyParameterizedType extends Generic.OfParameterizedType {
>, <Line: -                        /**
>, <Line: -                         * The type pool to be used for locating non-generic type descriptions.
>, <Line: -                         */
>, <Line: -                        private final TypePool typePool;
>, <Line: -                        /**
>, <Line: -                         * The type variable source for locating generic types.
>, <Line: -                         */
>, <Line: -                        private final TypeVariableSource typeVariableSource;
>, <Line: -                        /**
>, <Line: -                         * Creates a lazy description of a parameterized type with an owner type.
>, <Line: -                         *
>, <Line: -                         * @param typePool           The type pool to be used for locating non-generic type descriptions.
>, <Line: -                         * @param typeVariableSource The type variable source for locating generic types.
>, <Line: -                         */
>, <Line: -                        public LazyParameterizedType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                            this.typePool = typePool;
>, <Line: -                            this.typeVariableSource = typeVariableSource;
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeDescription asErasure() {
>, <Line: -                            return typePool.describe(name).resolve();
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public TypeList.Generic getParameters() {
>, <Line: -                            List<Generic> parameterTypes = new ArrayList<Generic>(parameters.size());
>, <Line: -                            for (GenericTypeToken parameter : parameters) {
>, <Line: -                                parameterTypes.add(parameter.toGenericType(typePool, typeVariableSource));
>, <Line: -                            }
>, <Line: -                            return new TypeList.Generic.Explicit(parameterTypes);
>, <Line: -                        }
>, <Line: -                        @Override
>, <Line: -                        public Generic getOwnerType() {
>, <Line: -                            return ownerType.toGenericType(typePool, typeVariableSource);
>, <Line: -                        }
>, <Line: -                }
>, <Line: -                /**
>, <Line: -                 * A generic type description that represents a parameterized type <b>without</b> an enclosing generic owner type.
>, <Line: -                 */
>, <Line: -                protected class LazyParameterizedType extends Generic.OfParameterizedType {
>, <Line: -                     * The type pool that is used for locating a generic type.
>, <Line: -                    private final TypePool typePool;
>, <Line: -                     * The type variable source to use for resolving type variables.
>, <Line: -                    private final TypeVariableSource typeVariableSource;
>, <Line: -                     * Creates a new description of a parameterized type.
>, <Line: -                     * @param typePool           The type pool that is used for locating a generic type.
>, <Line: -                     * @param typeVariableSource The type variable source to use for resolving type variables.
>, <Line: -                    public LazyParameterizedType(TypePool typePool, TypeVariableSource typeVariableSource) {
>, <Line: -                        this.typePool = typePool;
>, <Line: -                        this.typeVariableSource = typeVariableSource;
>, <Line: -                    public TypeDescription asErasure() {
>, <Line: -                        return typePool.describe(name).resolve();
>, <Line: -                    public TypeList.Generic getParameters() {
>, <Line: -                        List<Generic> parameterTypes = new ArrayList<Generic>(parameters.size());
>, <Line: -                        for (GenericTypeToken parameter : parameters) {
>, <Line: -                            parameterTypes.add(parameter.toGenericType(typePool, typeVariableSource));
>, <Line: -                        }
>, <Line: -                        return new TypeList.Generic.Explicit(parameterTypes);
>, <Line: -                    public Generic getOwnerType() {
>, <Line: -                        TypeDescription ownerType = typePool.describe(name).resolve().getEnclosingType();
>, <Line: -                        return ownerType == null
>, <Line: -                                ? UNDEFINED
>, <Line: -                                : ownerType.asGenericType();
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A token for representing collected data on an annotation.
>, <Line: -         */
>, <Line: -        protected static class AnnotationToken {
>, <Line: -            /**
>, <Line: -             * The descriptor of the represented annotation.
>, <Line: -             */
>, <Line: -            private final String descriptor;
>, <Line: -            /**
>, <Line: -             * A map of annotation value names to their value representations.
>, <Line: -             */
>, <Line: -            private final Map<String, AnnotationDescription.AnnotationValue<?, ?>> values;
>, <Line: -            /**
>, <Line: -             * Creates a new annotation token.
>, <Line: -             *
>, <Line: -             * @param descriptor The descriptor of the represented annotation.
>, <Line: -             * @param values     A map of annotation value names to their value representations.
>, <Line: -             */
>, <Line: -            protected AnnotationToken(String descriptor, Map<String, AnnotationDescription.AnnotationValue<?, ?>> values) {
>, <Line: -                this.descriptor = descriptor;
>, <Line: -                this.values = values;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a map of annotation value names to their value representations.
>, <Line: -             *
>, <Line: -             * @return A map of annotation value names to their value representations.
>, <Line: -             */
>, <Line: -            protected Map<String, AnnotationDescription.AnnotationValue<?, ?>> getValues() {
>, <Line: -                return values;
>, <Line: -            }
>, <Line: -             * Returns the annotation type's binary name.
>, <Line: -             *
>, <Line: -             * @return The annotation type's binary name.
>, <Line: -             */
>, <Line: -            protected String getBinaryName() {
>, <Line: -                return descriptor.substring(1, descriptor.length() - 1).replace('/', '.');
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Transforms this token into an annotation description.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to be used for looking up linked types.
>, <Line: -             * @return An optional description of this annotation's token.
>, <Line: -            private Resolution toAnnotationDescription(TypePool typePool) {
>, <Line: -                TypePool.Resolution resolution = typePool.describe(getBinaryName());
>, <Line: -                return resolution.isResolved()
>, <Line: -                        ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))
>, <Line: -                        : new Resolution.Illegal(getBinaryName());
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                AnnotationToken that = (AnnotationToken) other;
>, <Line: -                return descriptor.equals(that.descriptor)
>, <Line: -                        && values.equals(that.values);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = descriptor.hashCode();
>, <Line: -                result = 31 * result + values.hashCode();
>, <Line: -                return result;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.LazyTypeDescription.AnnotationToken{" +
>, <Line: -                        "descriptor='" + descriptor + '\'' +
>, <Line: -                        ", values=" + values +
>, <Line: -                        '}';
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A resolution for an annotation tokens. Any annotation is suppressed if its type is not available.
>, <Line: -             * This conforms to the handling of the Java reflection API.
>, <Line: -             */
>, <Line: -            protected interface Resolution {
>, <Line: -                 * Returns {@code true} if the represented annotation could be resolved.
>, <Line: -                 *
>, <Line: -                 * @return {@code true} if the represented annotation could be resolved.
>, <Line: -                boolean isResolved();
>, <Line: -                 * Returns the resolved annotation. This method throws an exception if this instance is not resolved.
>, <Line: -                 * @return The resolved annotation. This method throws an exception if this instance is not resolved.
>, <Line: -                AnnotationDescription resolve();
>, <Line: -                 * A simple resolved annotation.
>, <Line: -                class Simple implements Resolution {
>, <Line: -                    /**
>, <Line: -                     * The represented annotation description.
>, <Line: -                     */
>, <Line: -                    private final AnnotationDescription annotationDescription;
>, <Line: -                    /**
>, <Line: -                     * Creates a new simple resolution.
>, <Line: -                     *
>, <Line: -                     * @param annotationDescription The represented annotation description.
>, <Line: -                     */
>, <Line: -                    protected Simple(AnnotationDescription annotationDescription) {
>, <Line: -                        this.annotationDescription = annotationDescription;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public boolean isResolved() {
>, <Line: -                        return true;
>, <Line: -                    @Override
>, <Line: -                    public AnnotationDescription resolve() {
>, <Line: -                        return annotationDescription;
>, <Line: -                    @Override
>, <Line: -                    public boolean equals(Object other) {
>, <Line: -                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                                && annotationDescription.equals(((Simple) other).annotationDescription);
>, <Line: -                    @Override
>, <Line: -                    public int hashCode() {
>, <Line: -                        return annotationDescription.hashCode();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.LazyTypeDescription.AnnotationToken.Resolution.Simple{" +
>, <Line: -                                "annotationDescription=" + annotationDescription +
>, <Line: -                                '}';
>, <Line: -                 * An illegal resolution.
>, <Line: -                class Illegal implements Resolution {
>, <Line: -                     * The annotation's binary type name.
>, <Line: -                    private final String annotationType;
>, <Line: -                     * Creates a new illegal resolution.
>, <Line: -                     * @param annotationType The annotation's binary type name.
>, <Line: -                    public Illegal(String annotationType) {
>, <Line: -                    public boolean isResolved() {
>, <Line: -                        return false;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public AnnotationDescription resolve() {
>, <Line: -                        throw new IllegalStateException("Annotation type is not available: " + annotationType);
>, <Line: -                    public boolean equals(Object other) {
>, <Line: -                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: -                                && annotationType.equals(((Illegal) other).annotationType);
>, <Line: -                    public int hashCode() {
>, <Line: -                        return annotationType.hashCode();
>, <Line: -                    public String toString() {
>, <Line: -                        return "TypePool.LazyTypeDescription.AnnotationToken.Resolution.Illegal{" +
>, <Line: -                                "annotationType=" + annotationType +
>, <Line: -                                '}';
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A token for representing collected data on a field.
>, <Line: -         */
>, <Line: -        protected static class FieldToken {
>, <Line: -             * The name of the field.
>, <Line: -            private final String name;
>, <Line: -            /**
>, <Line: -             * The modifiers of the represented field.
>, <Line: -             */
>, <Line: -            private final int modifiers;
>, <Line: -            /**
>, <Line: -             * The descriptor of the field.
>, <Line: -             */
>, <Line: -            private final String descriptor;
>, <Line: -            /**
>, <Line: -             * The resolution of this field's generic type.
>, <Line: -             */
>, <Line: -            private final GenericTypeToken.Resolution.ForField signatureResolution;
>, <Line: -            /**
>, <Line: -             * A list of annotation tokens representing the annotations of the represented field.
>, <Line: -             */
>, <Line: -            private final List<AnnotationToken> annotationTokens;
>, <Line: -            /**
>, <Line: -             * Creates a new field token.
>, <Line: -             *
>, <Line: -             * @param name                The name of the field.
>, <Line: -             * @param modifiers           The modifiers of the represented field.
>, <Line: -             * @param descriptor          The descriptor of the field.
>, <Line: -             * @param signatureResolution The resolution of this field's generic type.
>, <Line: -             * @param annotationTokens    A list of annotation tokens representing the annotations of the represented field.
>, <Line: -             */
>, <Line: -            protected FieldToken(String name,
>, <Line: -                                 int modifiers,
>, <Line: -                                 String descriptor,
>, <Line: -                                 GenericTypeToken.Resolution.ForField signatureResolution,
>, <Line: -                                 List<AnnotationToken> annotationTokens) {
>, <Line: -                this.modifiers = modifiers;
>, <Line: -                this.name = name;
>, <Line: -                this.descriptor = descriptor;
>, <Line: -                this.signatureResolution = signatureResolution;
>, <Line: -                this.annotationTokens = annotationTokens;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the modifiers of the represented field.
>, <Line: -             *
>, <Line: -             * @return The modifiers of the represented field.
>, <Line: -             */
>, <Line: -            protected int getModifiers() {
>, <Line: -                return modifiers;
>, <Line: -             * Returns the name of the represented field.
>, <Line: -             *
>, <Line: -             * @return The name of the represented field.
>, <Line: -            protected String getName() {
>, <Line: -                return name;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the descriptor of the represented field.
>, <Line: -             *
>, <Line: -             * @return The descriptor of the represented field.
>, <Line: -             */
>, <Line: -            protected String getDescriptor() {
>, <Line: -                return descriptor;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the resolution of this field's generic type.
>, <Line: -             *
>, <Line: -             * @return The resolution of this field's generic type.
>, <Line: -             */
>, <Line: -            protected GenericTypeToken.Resolution.ForField getSignatureResolution() {
>, <Line: -                return signatureResolution;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a list of annotation tokens of the represented field.
>, <Line: -             *
>, <Line: -             * @return A list of annotation tokens of the represented field.
>, <Line: -             */
>, <Line: -            protected List<AnnotationToken> getAnnotationTokens() {
>, <Line: -                return annotationTokens;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Transforms this token into a lazy field description.
>, <Line: -             *
>, <Line: -             * @param lazyTypeDescription The lazy type description to attach this field description to.
>, <Line: -             * @return A field description resembling this field token.
>, <Line: -             */
>, <Line: -            private FieldDescription.InDefinedShape toFieldDescription(LazyTypeDescription lazyTypeDescription) {
>, <Line: -                return lazyTypeDescription.new LazyFieldDescription(getName(),
>, <Line: -                        getModifiers(),
>, <Line: -                        getDescriptor(),
>, <Line: -                        getSignatureResolution(),
>, <Line: -                        getAnnotationTokens());
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                FieldToken that = (FieldToken) other;
>, <Line: -                return modifiers == that.modifiers
>, <Line: -                        && annotationTokens.equals(that.annotationTokens)
>, <Line: -                        && descriptor.equals(that.descriptor)
>, <Line: -                        && signatureResolution.equals(that.signatureResolution)
>, <Line: -                        && name.equals(that.name);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = modifiers;
>, <Line: -                result = 31 * result + name.hashCode();
>, <Line: -                result = 31 * result + descriptor.hashCode();
>, <Line: -                result = 31 * result + signatureResolution.hashCode();
>, <Line: -                result = 31 * result + annotationTokens.hashCode();
>, <Line: -                return result;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.LazyTypeDescription.FieldToken{" +
>, <Line: -                        "modifiers=" + modifiers +
>, <Line: -                        ", name='" + name + '\'' +
>, <Line: -                        ", descriptor='" + descriptor + '\'' +
>, <Line: -                        ", signatureResolution=" + signatureResolution +
>, <Line: -                        ", annotationTokens=" + annotationTokens +
>, <Line: -                        '}';
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A token for representing collected data on a method.
>, <Line: -         */
>, <Line: -        protected static class MethodToken {
>, <Line: -            /**
>, <Line: -             * The internal name of the represented method.
>, <Line: -             */
>, <Line: -            private final String name;
>, <Line: -             * The modifiers of the represented method.
>, <Line: -            private final int modifiers;
>, <Line: -            /**
>, <Line: -             * The descriptor of the represented method.
>, <Line: -             */
>, <Line: -            private final String descriptor;
>, <Line: -            /**
>, <Line: -             * The generic type resolution of this method.
>, <Line: -             */
>, <Line: -            private final GenericTypeToken.Resolution.ForMethod signatureResolution;
>, <Line: -            /**
>, <Line: -             * An array of internal names of the exceptions of the represented method or {@code null} if there
>, <Line: -             * are no such exceptions.
>, <Line: -             */
>, <Line: -            private final String[] exceptionName;
>, <Line: -            /**
>, <Line: -             * A list of annotation tokens that are present on the represented method.
>, <Line: -             */
>, <Line: -            private final List<AnnotationToken> annotationTokens;
>, <Line: -            /**
>, <Line: -             * A map of parameter indices to tokens that represent their annotations.
>, <Line: -             */
>, <Line: -            private final Map<Integer, List<AnnotationToken>> parameterAnnotationTokens;
>, <Line: -            /**
>, <Line: -             * A list of tokens describing meta data of the method's parameters.
>, <Line: -             */
>, <Line: -            private final List<ParameterToken> parameterTokens;
>, <Line: -            /**
>, <Line: -             * The default value of this method or {@code null} if there is no such value.
>, <Line: -             */
>, <Line: -            private final AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: -            /**
>, <Line: -             * Creates a new method token.
>, <Line: -             *
>, <Line: -             * @param name                      The name of the method.
>, <Line: -             * @param modifiers                 The modifiers of the represented method.
>, <Line: -             * @param descriptor                The descriptor of the represented method.
>, <Line: -             * @param signatureResolution       The generic type resolution of this method.
>, <Line: -             * @param exceptionName             An array of internal names of the exceptions of the represented method or {@code null} if
>, <Line: -             *                                  there are no such exceptions.
>, <Line: -             * @param annotationTokens          A list of annotation tokens that are present on the represented method.
>, <Line: -             * @param parameterAnnotationTokens A map of parameter indices to tokens that represent their annotations.
>, <Line: -             * @param parameterTokens           A list of tokens describing meta data of the method's parameters.
>, <Line: -             * @param defaultValue              The default value of this method or {@code null} if there is no such value.
>, <Line: -             */
>, <Line: -            protected MethodToken(String name,
>, <Line: -                                  int modifiers,
>, <Line: -                                  String descriptor,
>, <Line: -                                  GenericTypeToken.Resolution.ForMethod signatureResolution,
>, <Line: -                                  String[] exceptionName,
>, <Line: -                                  List<AnnotationToken> annotationTokens,
>, <Line: -                                  Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
>, <Line: -                                  List<ParameterToken> parameterTokens,
>, <Line: -                                  AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
>, <Line: -                this.modifiers = modifiers;
>, <Line: -                this.name = name;
>, <Line: -                this.descriptor = descriptor;
>, <Line: -                this.signatureResolution = signatureResolution;
>, <Line: -                this.exceptionName = exceptionName;
>, <Line: -                this.annotationTokens = annotationTokens;
>, <Line: -                this.parameterAnnotationTokens = parameterAnnotationTokens;
>, <Line: -                this.parameterTokens = parameterTokens;
>, <Line: -                this.defaultValue = defaultValue;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the modifiers of the represented method.
>, <Line: -             *
>, <Line: -             * @return The modifiers of the represented method.
>, <Line: -             */
>, <Line: -            protected int getModifiers() {
>, <Line: -                return modifiers;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the internal name of the represented method.
>, <Line: -             *
>, <Line: -             * @return The internal name of the represented method.
>, <Line: -             */
>, <Line: -            protected String getName() {
>, <Line: -                return name;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the descriptor of the represented method.
>, <Line: -             *
>, <Line: -             * @return The descriptor of the represented method.
>, <Line: -             */
>, <Line: -            protected String getDescriptor() {
>, <Line: -                return descriptor;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the generic type resolution of this method.
>, <Line: -             *
>, <Line: -             * @return The generic type resolution of this method.
>, <Line: -             */
>, <Line: -            protected GenericTypeToken.Resolution.ForMethod getSignatureResolution() {
>, <Line: -                return signatureResolution;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the internal names of the exception type declared of the represented method.
>, <Line: -             *
>, <Line: -             * @return The internal names of the exception type declared of the represented method.
>, <Line: -             */
>, <Line: -            protected String[] getExceptionName() {
>, <Line: -                return exceptionName;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a list of annotation tokens declared by the represented method.
>, <Line: -             *
>, <Line: -             * @return A list of annotation tokens declared by the represented method.
>, <Line: -             */
>, <Line: -            protected List<AnnotationToken> getAnnotationTokens() {
>, <Line: -                return annotationTokens;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns a map of parameter type indices to a list of annotation tokens representing these annotations.
>, <Line: -             *
>, <Line: -             * @return A map of parameter type indices to a list of annotation tokens representing these annotations.
>, <Line: -             */
>, <Line: -            protected Map<Integer, List<AnnotationToken>> getParameterAnnotationTokens() {
>, <Line: -                return parameterAnnotationTokens;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the parameter tokens for this type. These tokens might be out of sync with the method's
>, <Line: -             * parameters if the meta information attached to a method is not available or corrupt.
>, <Line: -             *
>, <Line: -             * @return A list of parameter tokens to the described method.
>, <Line: -             */
>, <Line: -            protected List<ParameterToken> getParameterTokens() {
>, <Line: -                return parameterTokens;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Returns the default value of the represented method or {@code null} if no such values exists.
>, <Line: -             *
>, <Line: -             * @return The default value of the represented method or {@code null} if no such values exists.
>, <Line: -             */
>, <Line: -            protected AnnotationDescription.AnnotationValue<?, ?> getDefaultValue() {
>, <Line: -                return defaultValue;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Transforms this method token to a method description that is attached to a lazy type description.
>, <Line: -             *
>, <Line: -             * @param lazyTypeDescription The lazy type description to attach this method description to.
>, <Line: -             * @return A method description representing this field token.
>, <Line: -             */
>, <Line: -            private MethodDescription.InDefinedShape toMethodDescription(LazyTypeDescription lazyTypeDescription) {
>, <Line: -                return lazyTypeDescription.new LazyMethodDescription(getName(),
>, <Line: -                        getModifiers(),
>, <Line: -                        getDescriptor(),
>, <Line: -                        getSignatureResolution(),
>, <Line: -                        getExceptionName(),
>, <Line: -                        getAnnotationTokens(),
>, <Line: -                        getParameterAnnotationTokens(),
>, <Line: -                        getParameterTokens(),
>, <Line: -                        getDefaultValue());
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                MethodToken that = (MethodToken) other;
>, <Line: -                return modifiers == that.modifiers
>, <Line: -                        && annotationTokens.equals(that.annotationTokens)
>, <Line: -                        && defaultValue.equals(that.defaultValue)
>, <Line: -                        && descriptor.equals(that.descriptor)
>, <Line: -                        && parameterTokens.equals(that.parameterTokens)
>, <Line: -                        && signatureResolution.equals(that.signatureResolution)
>, <Line: -                        && Arrays.equals(exceptionName, that.exceptionName)
>, <Line: -                        && name.equals(that.name)
>, <Line: -                        && parameterAnnotationTokens.equals(that.parameterAnnotationTokens);
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                int result = modifiers;
>, <Line: -                result = 31 * result + name.hashCode();
>, <Line: -                result = 31 * result + descriptor.hashCode();
>, <Line: -                result = 31 * result + signatureResolution.hashCode();
>, <Line: -                result = 31 * result + Arrays.hashCode(exceptionName);
>, <Line: -                result = 31 * result + annotationTokens.hashCode();
>, <Line: -                result = 31 * result + parameterAnnotationTokens.hashCode();
>, <Line: -                result = 31 * result + parameterTokens.hashCode();
>, <Line: -                result = 31 * result + defaultValue.hashCode();
>, <Line: -                return result;
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypePool.LazyTypeDescription.MethodToken{" +
>, <Line: -                        "modifiers=" + modifiers +
>, <Line: -                        ", name='" + name + '\'' +
>, <Line: -                        ", descriptor='" + descriptor + '\'' +
>, <Line: -                        ", signatureResolution=" + signatureResolution +
>, <Line: -                        ", exceptionName=" + Arrays.toString(exceptionName) +
>, <Line: -                        ", annotationTokens=" + annotationTokens +
>, <Line: -                        ", parameterAnnotationTokens=" + parameterAnnotationTokens +
>, <Line: -                        ", parameterTokens=" + parameterTokens +
>, <Line: -                        ", defaultValue=" + defaultValue +
>, <Line: -                        '}';
>, <Line: -             * A token representing a method's parameter.
>, <Line: -            protected static class ParameterToken {
>, <Line: -                 * Donates an unknown name of a parameter.
>, <Line: -                protected static final String NO_NAME = null;
>, <Line: -                 * Donates an unknown modifier of a parameter.
>, <Line: -                protected static final Integer NO_MODIFIERS = null;
>, <Line: -                 * The name of the parameter or {@code null} if no explicit name for this parameter is known.
>, <Line: -                private final String name;
>, <Line: -                 * The modifiers of the parameter or {@code null} if no modifiers are known for this parameter.
>, <Line: -                private final Integer modifiers;
>, <Line: -                 * Creates a parameter token for a parameter without an explicit name and without specific modifiers.
>, <Line: -                protected ParameterToken() {
>, <Line: -                    this(NO_NAME);
>, <Line: -                }
>, <Line: -                 * Creates a parameter token for a parameter with an explicit name and without specific modifiers.
>, <Line: -                 *
>, <Line: -                 * @param name The name of the parameter.
>, <Line: -                protected ParameterToken(String name) {
>, <Line: -                    this(name, NO_MODIFIERS);
>, <Line: -                }
>, <Line: -                 * Creates a parameter token for a parameter with an explicit name and with specific modifiers.
>, <Line: -                 *
>, <Line: -                 * @param name      The name of the parameter.
>, <Line: -                 * @param modifiers The modifiers of the parameter.
>, <Line: -                protected ParameterToken(String name, Integer modifiers) {
>, <Line: -                    this.name = name;
>, <Line: -                    this.modifiers = modifiers;
>, <Line: -                }
>, <Line: -                 * Returns the name of the parameter or {@code null} if there is no such name.
>, <Line: -                 *
>, <Line: -                 * @return The name of the parameter or {@code null} if there is no such name.
>, <Line: -                protected String getName() {
>, <Line: -                    return name;
>, <Line: -                }
>, <Line: -                 * Returns the modifiers of the parameter or {@code null} if no modifiers are known.
>, <Line: -                 *
>, <Line: -                 * @return The modifiers of the parameter or {@code null} if no modifiers are known.
>, <Line: -                protected Integer getModifiers() {
>, <Line: -                    return modifiers;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public boolean equals(Object other) {
>, <Line: -                    if (this == other) return true;
>, <Line: -                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                    ParameterToken that = ((ParameterToken) other);
>, <Line: -                    return !(modifiers != null ? !modifiers.equals(that.modifiers) : that.modifiers != null)
>, <Line: -                            && !(name != null ? !name.equals(that.name) : that.name != null);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int hashCode() {
>, <Line: -                    int result = name != null ? name.hashCode() : 0;
>, <Line: -                    result = 31 * result + (modifiers != null ? modifiers.hashCode() : 0);
>, <Line: -                    return result;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public String toString() {
>, <Line: -                    return "TypePool.LazyTypeDescription.MethodToken.ParameterToken{" +
>, <Line: -                            "name='" + name + '\'' +
>, <Line: -                            ", modifiers=" + modifiers +
>, <Line: -                            '}';
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A lazy description of an annotation that looks up types from a type pool when required.
>, <Line: -         */
>, <Line: -        private static class LazyAnnotationDescription extends AnnotationDescription.AbstractBase {
>, <Line: -            /**
>, <Line: -             * The type pool for looking up type references.
>, <Line: -             */
>, <Line: -            protected final TypePool typePool;
>, <Line: -            /**
>, <Line: -             * The type of this annotation.
>, <Line: -             */
>, <Line: -            private final TypeDescription annotationType;
>, <Line: -            /**
>, <Line: -             * A map of annotation values by their property name.
>, <Line: -             */
>, <Line: -            protected final Map<String, AnnotationValue<?, ?>> values;
>, <Line: -            /**
>, <Line: -             * Creates a new lazy annotation description.
>, <Line: -             *
>, <Line: -             * @param typePool       The type pool to be used for looking up linked types.
>, <Line: -             * @param annotationType The annotation's type.
>, <Line: -             * @param values         A map of annotation value names to their value representations.
>, <Line: -             */
>, <Line: -            private LazyAnnotationDescription(TypePool typePool, TypeDescription annotationType, Map<String, AnnotationValue<?, ?>> values) {
>, <Line: -                this.typePool = typePool;
>, <Line: -                this.annotationType = annotationType;
>, <Line: -                this.values = values;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
>, <Line: -             * a type that cannot be loaded from the type pool is ignored and not included in the list.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to be used for looking up linked types.
>, <Line: -             * @param tokens   The tokens to represent in the list.
>, <Line: -             * @return A list of the loadable annotations.
>, <Line: -             */
>, <Line: -            protected static AnnotationList asList(TypePool typePool, List<? extends AnnotationToken> tokens) {
>, <Line: -                List<AnnotationDescription> annotationDescriptions = new ArrayList<AnnotationDescription>(tokens.size());
>, <Line: -                for (AnnotationToken token : tokens) {
>, <Line: -                    AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);
>, <Line: -                    if (resolution.isResolved()) {
>, <Line: -                        annotationDescriptions.add(resolution.resolve());
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                return new AnnotationList.Explicit(annotationDescriptions);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Object getValue(MethodDescription.InDefinedShape methodDescription) {
>, <Line: -                if (!methodDescription.getDeclaringType().asErasure().equals(annotationType)) {
>, <Line: -                    throw new IllegalArgumentException(methodDescription + " is not declared by " + getAnnotationType());
>, <Line: -                }
>, <Line: -                AnnotationValue<?, ?> annotationValue = values.get(methodDescription.getName());
>, <Line: -                Object value = annotationValue == null
>, <Line: -                        ? getAnnotationType().getDeclaredMethods().filter(is(methodDescription)).getOnly().getDefaultValue()
>, <Line: -                        : annotationValue.resolve();
>, <Line: -                if (value == null) {
>, <Line: -                    throw new IllegalStateException(methodDescription + " is not defined on annotation");
>, <Line: -                }
>, <Line: -                return PropertyDispatcher.of(value.getClass()).conditionalClone(value);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeDescription getAnnotationType() {
>, <Line: -                return annotationType;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public <T extends Annotation> Loadable<T> prepare(Class<T> annotationType) {
>, <Line: -                if (!this.annotationType.represents(annotationType)) {
>, <Line: -                    throw new IllegalArgumentException(annotationType + " does not represent " + this.annotationType);
>, <Line: -                }
>, <Line: -                return new Loadable<T>(typePool, annotationType, values);
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A loadable version of a lazy annotation description.
>, <Line: -             *
>, <Line: -             * @param <S> The annotation type.
>, <Line: -             */
>, <Line: -            private static class Loadable<S extends Annotation> extends LazyAnnotationDescription implements AnnotationDescription.Loadable<S> {
>, <Line: -                 * The loaded annotation type.
>, <Line: -                private final Class<S> annotationType;
>, <Line: -                 * Creates a new loadable version of a lazy annotation.
>, <Line: -                 * @param typePool       The type pool to be used for looking up linked types.
>, <Line: -                 * @param annotationType The annotation's loaded type.
>, <Line: -                 * @param values         A map of annotation value names to their value representations.
>, <Line: -                private Loadable(TypePool typePool, Class<S> annotationType, Map<String, AnnotationValue<?, ?>> values) {
>, <Line: -                    super(typePool, new ForLoadedType(annotationType), values);
>, <Line: -                    this.annotationType = annotationType;
>, <Line: -                public S load() throws ClassNotFoundException {
>, <Line: -                    return load(annotationType.getClassLoader());
>, <Line: -                @SuppressWarnings("unchecked")
>, <Line: -                public S load(ClassLoader classLoader) throws ClassNotFoundException {
>, <Line: -                    return (S) Proxy.newProxyInstance(classLoader,
>, <Line: -                            new Class<?>[]{annotationType},
>, <Line: -                            AnnotationInvocationHandler.of(classLoader, annotationType, values));
>, <Line: -                public S loadSilent() {
>, <Line: -                    try {
>, <Line: -                        return load();
>, <Line: -                    } catch (ClassNotFoundException exception) {
>, <Line: -                        throw new IllegalStateException(ForLoadedAnnotation.ERROR_MESSAGE, exception);
>, <Line: -                public S loadSilent(ClassLoader classLoader) {
>, <Line: -                    try {
>, <Line: -                        return load(classLoader);
>, <Line: -                    } catch (ClassNotFoundException exception) {
>, <Line: -                        throw new IllegalStateException(ForLoadedAnnotation.ERROR_MESSAGE, exception);
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * An implementation of a {@link PackageDescription} that only
>, <Line: -         * loads its annotations on requirement.
>, <Line: -         */
>, <Line: -        private static class LazyPackageDescription extends PackageDescription.AbstractBase {
>, <Line: -            /**
>, <Line: -             * The type pool to use for look-ups.
>, <Line: -             */
>, <Line: -            private final TypePool typePool;
>, <Line: -            /**
>, <Line: -             * The name of the package.
>, <Line: -             */
>, <Line: -            private final String name;
>, <Line: -            /**
>, <Line: -             * Creates a new lazy package description.
>, <Line: -             *
>, <Line: -             * @param typePool The type pool to use for look-ups.
>, <Line: -             * @param name     The name of the package.
>, <Line: -             */
>, <Line: -            private LazyPackageDescription(TypePool typePool, String name) {
>, <Line: -                this.typePool = typePool;
>, <Line: -                this.name = name;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public AnnotationList getDeclaredAnnotations() {
>, <Line: -                Resolution resolution = typePool.describe(name + "." + PackageDescription.PACKAGE_CLASS_NAME);
>, <Line: -                return resolution.isResolved()
>, <Line: -                        ? resolution.resolve().getDeclaredAnnotations()
>, <Line: -                        : new AnnotationList.Empty();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getName() {
>, <Line: -                return name;
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A list that is constructing {@link net.bytebuddy.pool.TypePool.LazyTypeDescription}s.
>, <Line: -         */
>, <Line: -        private static class LazyTypeList extends TypeList.AbstractBase {
>, <Line: -            /**
>, <Line: -             * The type pool to use for locating types.
>, <Line: -             */
>, <Line: -            private final TypePool typePool;
>, <Line: -            /**
>, <Line: -             * A list of type descriptors that this list represents.
>, <Line: -             */
>, <Line: -            private final List<String> descriptors;
>, <Line: -            /**
>, <Line: -             * Creates a list of lazy type descriptions.
>, <Line: -             *
>, <Line: -             * @param typePool    The type pool to use for locating types.
>, <Line: -             * @param descriptors A list of type descriptors that this list represents.
>, <Line: -             */
>, <Line: -            private LazyTypeList(TypePool typePool, List<String> descriptors) {
>, <Line: -                this.typePool = typePool;
>, <Line: -                this.descriptors = descriptors;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeDescription get(int index) {
>, <Line: -                return TokenizedGenericType.toErasure(typePool, descriptors.get(index));
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int size() {
>, <Line: -                return descriptors.size();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String[] toInternalNames() {
>, <Line: -                String[] internalName = new String[descriptors.size()];
>, <Line: -                int index = 0;
>, <Line: -                for (String descriptor : descriptors) {
>, <Line: -                    internalName[index++] = Type.getType(descriptor).getInternalName();
>, <Line: -                }
>, <Line: -                return internalName.length == 0
>, <Line: -                        ? NO_INTERFACES
>, <Line: -                        : internalName;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int getStackSize() {
>, <Line: -                int stackSize = 0;
>, <Line: -                for (String descriptor : descriptors) {
>, <Line: -                    stackSize += Type.getType(descriptor).getSize();
>, <Line: -                }
>, <Line: -                return stackSize;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A generic type list representing raw types.
>, <Line: -             */
>, <Line: -            protected static class Generic extends TypeList.Generic.AbstractBase {
>, <Line: -                /**
>, <Line: -                 * The type pool to use for locating types.
>, <Line: -                 */
>, <Line: -                private final TypePool typePool;
>, <Line: -                /**
>, <Line: -                 * A list of type descriptors that this list represents.
>, <Line: -                 */
>, <Line: -                private final List<String> descriptors;
>, <Line: -                /**
>, <Line: -                 * A generic type list only representing raw types.
>, <Line: -                 *
>, <Line: -                 * @param typePool    The type pool to use for locating types.
>, <Line: -                 * @param descriptors A list of type descriptors that this list represents.
>, <Line: -                 */
>, <Line: -                protected Generic(TypePool typePool, List<String> descriptors) {
>, <Line: -                    this.typePool = typePool;
>, <Line: -                    this.descriptors = descriptors;
>, <Line: -                }
>, <Line: -                public TypeDescription.Generic get(int index) {
>, <Line: -                    return TokenizedGenericType.toErasure(typePool, descriptors.get(index)).asGenericType();
>, <Line: -                public int size() {
>, <Line: -                    return descriptors.size();
>, <Line: -                public TypeList asErasures() {
>, <Line: -                    return new LazyTypeList(typePool, descriptors);
>, <Line: -                public TypeList.Generic asRawTypes() {
>, <Line: -                    return this;
>, <Line: -                public int getStackSize() {
>, <Line: -                    int stackSize = 0;
>, <Line: -                    for (String descriptor : descriptors) {
>, <Line: -                        stackSize += Type.getType(descriptor).getSize();
>, <Line: -                    }
>, <Line: -                    return stackSize;
>, <Line: -         * A representation of a generic type that is described by a {@link GenericTypeToken}.
>, <Line: -        private static class TokenizedGenericType extends Generic.LazyProjection {
>, <Line: -             * The type pool to use for locating referenced types.
>, <Line: -            private final TypePool typePool;
>, <Line: -             * The token that describes the represented generic type.
>, <Line: -            private final GenericTypeToken genericTypeToken;
>, <Line: -             * A descriptor of the generic type's raw type.
>, <Line: -            private final String rawTypeDescriptor;
>, <Line: -             * The closest type variable source of this generic type's declaration context.
>, <Line: -            private final TypeVariableSource typeVariableSource;
>, <Line: -             * Creates a new tokenized generic type.
>, <Line: -             * @param typePool           The type pool to use for locating referenced types.
>, <Line: -             * @param genericTypeToken   The token that describes the represented generic type.
>, <Line: -             * @param rawTypeDescriptor  A descriptor of the generic type's erasure.
>, <Line: -             * @param typeVariableSource The closest type variable source of this generic type's declaration context.
>, <Line: -            protected TokenizedGenericType(TypePool typePool,
>, <Line: -                                           GenericTypeToken genericTypeToken,
>, <Line: -                                           String rawTypeDescriptor,
>, <Line: -                                           TypeVariableSource typeVariableSource) {
>, <Line: -                this.typePool = typePool;
>, <Line: -                this.genericTypeToken = genericTypeToken;
>, <Line: -                this.rawTypeDescriptor = rawTypeDescriptor;
>, <Line: -                this.typeVariableSource = typeVariableSource;
>, <Line: -             * Creates a type description from a descriptor by looking up the corresponding type.
>, <Line: -             * @param typePool   The type pool to use for locating a type.
>, <Line: -             * @param descriptor The descriptor to interpret.
>, <Line: -             * @return A description of the type represented by the descriptor.
>, <Line: -            protected static TypeDescription toErasure(TypePool typePool, String descriptor) {
>, <Line: -                Type type = Type.getType(descriptor);
>, <Line: -                return typePool.describe(type.getSort() == Type.ARRAY
>, <Line: -                        ? type.getInternalName().replace('/', '.')
>, <Line: -                        : type.getClassName()).resolve();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Sort getSort() {
>, <Line: -                return genericTypeToken.getSort();
>, <Line: -            protected Generic resolve() {
>, <Line: -                return genericTypeToken.toGenericType(typePool, typeVariableSource);
>, <Line: -            @Override
>, <Line: -            public TypeDescription asErasure() {
>, <Line: -                return toErasure(typePool, rawTypeDescriptor);
>, <Line: -            }
>, <Line: -             * A tokenized list of generic types.
>, <Line: -            protected static class TokenList extends TypeList.Generic.AbstractBase {
>, <Line: -                /**
>, <Line: -                 * The type pool to use for locating types.
>, <Line: -                 */
>, <Line: -                private final TypePool typePool;
>, <Line: -                /**
>, <Line: -                 * Type tokens that describe the represented generic types.
>, <Line: -                 */
>, <Line: -                private final List<GenericTypeToken> genericTypeTokens;
>, <Line: -                /**
>, <Line: -                 * A list of the generic types' erasures.
>, <Line: -                 */
>, <Line: -                private final List<String> rawTypeDescriptors;
>, <Line: -                /**
>, <Line: -                 * The closest type variable source of this generic type's declaration context.
>, <Line: -                 */
>, <Line: -                private final TypeVariableSource typeVariableSource;
>, <Line: -                /**
>, <Line: -                 * Creates a list of tokenized generic types.
>, <Line: -                 *
>, <Line: -                 * @param typePool           The type pool to use for locating type descriptions.
>, <Line: -                 * @param genericTypeTokens  A list of tokens describing the represented generic types.
>, <Line: -                 * @param rawTypeDescriptors A list of the generic types' erasures.
>, <Line: -                 * @param typeVariableSource The closest type variable source of this generic type's declaration context.
>, <Line: -                 */
>, <Line: -                private TokenList(TypePool typePool,
>, <Line: -                                  List<GenericTypeToken> genericTypeTokens,
>, <Line: -                                  List<String> rawTypeDescriptors,
>, <Line: -                                  TypeVariableSource typeVariableSource) {
>, <Line: -                    this.typePool = typePool;
>, <Line: -                    this.genericTypeTokens = genericTypeTokens;
>, <Line: -                    this.rawTypeDescriptors = rawTypeDescriptors;
>, <Line: -                    this.typeVariableSource = typeVariableSource;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic get(int index) {
>, <Line: -                    return index < genericTypeTokens.size()
>, <Line: -                            ? new TokenizedGenericType(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), typeVariableSource)
>, <Line: -                            : TokenizedGenericType.toErasure(typePool, rawTypeDescriptors.get(index)).asGenericType();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int size() {
>, <Line: -                    return rawTypeDescriptors.size();
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeList asErasures() {
>, <Line: -                    return new LazyTypeList(typePool, rawTypeDescriptors);
>, <Line: -                }
>, <Line: -             * A list of tokenized type variables.
>, <Line: -            protected static class TypeVariableList extends TypeList.Generic.AbstractBase {
>, <Line: -                /**
>, <Line: -                 * The type pool to use for locating types.
>, <Line: -                 */
>, <Line: -                private final TypePool typePool;
>, <Line: -                /**
>, <Line: -                 * Type tokens that describe the represented type variables.
>, <Line: -                 */
>, <Line: -                private final List<GenericTypeToken> typeVariables;
>, <Line: -                /**
>, <Line: -                 * The type variable source of the represented type variables.
>, <Line: -                 */
>, <Line: -                private final TypeVariableSource typeVariableSource;
>, <Line: -                /**
>, <Line: -                 * Creates a list of type variables.
>, <Line: -                 *
>, <Line: -                 * @param typePool           The type pool to use for locating types.
>, <Line: -                 * @param typeVariables      Type tokens that describe the represented generic types.
>, <Line: -                 * @param typeVariableSource The type variable source of the represented type variables.
>, <Line: -                 */
>, <Line: -                protected TypeVariableList(TypePool typePool, List<GenericTypeToken> typeVariables, TypeVariableSource typeVariableSource) {
>, <Line: -                    this.typePool = typePool;
>, <Line: -                    this.typeVariables = typeVariables;
>, <Line: -                    this.typeVariableSource = typeVariableSource;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public Generic get(int index) {
>, <Line: -                    return typeVariables.get(index).toGenericType(typePool, typeVariableSource);
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public int size() {
>, <Line: -                    return typeVariables.size();
>, <Line: -                }
>, <Line: -             * A lazy description of a non-well-defined described generic type.
>, <Line: -            protected static class Malformed extends Generic.LazyProjection {
>, <Line: -                /**
>, <Line: -                 * The type pool to use for locating types.
>, <Line: -                 */
>, <Line: -                private final TypePool typePool;
>, <Line: -                /**
>, <Line: -                 * The descriptor of the type erasure.
>, <Line: -                 */
>, <Line: -                private final String rawTypeDescriptor;
>, <Line: -                /**
>, <Line: -                 * Creates a lazy description of a non-well-defined described generic type.
>, <Line: -                 *
>, <Line: -                 * @param typePool          The type pool to use for locating types.
>, <Line: -                 * @param rawTypeDescriptor The descriptor of the type erasure.
>, <Line: -                 */
>, <Line: -                protected Malformed(TypePool typePool, String rawTypeDescriptor) {
>, <Line: -                    this.typePool = typePool;
>, <Line: -                    this.rawTypeDescriptor = rawTypeDescriptor;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                protected Generic resolve() {
>, <Line: -                    throw new GenericSignatureFormatError();
>, <Line: -                @Override
>, <Line: -                public TypeDescription asErasure() {
>, <Line: -                    return toErasure(typePool, rawTypeDescriptor);
>, <Line: -                /**
>, <Line: -                 * A tokenized list of non-well-defined generic types.
>, <Line: -                 */
>, <Line: -                protected static class TokenList extends TypeList.Generic.AbstractBase {
>, <Line: -                    /**
>, <Line: -                     * The type pool to use for locating types.
>, <Line: -                     */
>, <Line: -                    private final TypePool typePool;
>, <Line: -                    /**
>, <Line: -                     * A list of descriptors of the list's types' erasures.
>, <Line: -                     */
>, <Line: -                    private final List<String> rawTypeDescriptors;
>, <Line: -                    /**
>, <Line: -                     * Creates a new tokenized list of generic types.
>, <Line: -                     *
>, <Line: -                     * @param typePool           The type pool to use for locating types.
>, <Line: -                     * @param rawTypeDescriptors A list of descriptors of the list's types' erasures.
>, <Line: -                     */
>, <Line: -                    protected TokenList(TypePool typePool, List<String> rawTypeDescriptors) {
>, <Line: -                        this.typePool = typePool;
>, <Line: -                        this.rawTypeDescriptors = rawTypeDescriptors;
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public Generic get(int index) {
>, <Line: -                        return new Malformed(typePool, rawTypeDescriptors.get(index));
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public int size() {
>, <Line: -                        return rawTypeDescriptors.size();
>, <Line: -                    }
>, <Line: -                    @Override
>, <Line: -                    public TypeList asErasures() {
>, <Line: -                        return new LazyTypeList(typePool, rawTypeDescriptors);
>, <Line: -                    }
>, <Line: -                }
>, <Line: -         * A lazy field description that only resolved type references when required.
>, <Line: -        private class LazyFieldDescription extends FieldDescription.InDefinedShape.AbstractBase {
>, <Line: -            /**
>, <Line: -             * The name of the field.
>, <Line: -             */
>, <Line: -            private final String name;
>, <Line: -            /**
>, <Line: -             * The modifiers of the field.
>, <Line: -             */
>, <Line: -            private final int modifiers;
>, <Line: -            /**
>, <Line: -             * The descriptor of this field's type.
>, <Line: -             */
>, <Line: -            private final String descriptor;
>, <Line: -             * A resolution of this field's generic type.
>, <Line: -            private final GenericTypeToken.Resolution.ForField signatureResolution;
>, <Line: -             * A list of annotation descriptions of this field.
>, <Line: -            private final List<AnnotationToken> annotationTokens;
>, <Line: -             * Creates a new lazy field description.
>, <Line: -             * @param name                The name of the field.
>, <Line: -             * @param modifiers           The modifiers of the field.
>, <Line: -             * @param descriptor          The descriptor of this field's type.
>, <Line: -             * @param signatureResolution A resolution of this field's generic type.
>, <Line: -             * @param annotationTokens    A list of annotation descriptions of this field.
>, <Line: -            private LazyFieldDescription(String name,
>, <Line: -                                         int modifiers,
>, <Line: -                                         String descriptor,
>, <Line: -                                         GenericTypeToken.Resolution.ForField signatureResolution,
>, <Line: -                                         List<AnnotationToken> annotationTokens) {
>, <Line: -                this.modifiers = modifiers;
>, <Line: -                this.name = name;
>, <Line: -                this.descriptor = descriptor;
>, <Line: -                this.signatureResolution = signatureResolution;
>, <Line: -                this.annotationTokens = annotationTokens;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Generic getType() {
>, <Line: -                return signatureResolution.resolveFieldType(descriptor, typePool, this);
>, <Line: -            public AnnotationList getDeclaredAnnotations() {
>, <Line: -                return LazyAnnotationDescription.asList(typePool, annotationTokens);
>, <Line: -            public String getName() {
>, <Line: -                return name;
>, <Line: -            public TypeDescription getDeclaringType() {
>, <Line: -                return LazyTypeDescription.this;
>, <Line: -            public int getModifiers() {
>, <Line: -                return modifiers;
>, <Line: -         * A lazy representation of a method that resolves references to types only on demand.
>, <Line: -        private class LazyMethodDescription extends MethodDescription.InDefinedShape.AbstractBase {
>, <Line: -            /**
>, <Line: -             * The internal name of this method.
>, <Line: -             */
>, <Line: -            private final String internalName;
>, <Line: -            /**
>, <Line: -             * The modifiers of this method.
>, <Line: -             */
>, <Line: -            private final int modifiers;
>, <Line: -            /**
>, <Line: -             * The descriptor of the return type.
>, <Line: -             */
>, <Line: -            private final String returnTypeDescriptor;
>, <Line: -            /**
>, <Line: -             * The generic type token of this method.
>, <Line: -             */
>, <Line: -            private final GenericTypeToken.Resolution.ForMethod signatureResolution;
>, <Line: -            /**
>, <Line: -             * A list of type descriptions of this method's parameters.
>, <Line: -             */
>, <Line: -            private final List<String> parameterTypeDescriptors;
>, <Line: -            /**
>, <Line: -             * A list of type descriptions of this method's exception types.
>, <Line: -             */
>, <Line: -            private final List<String> exceptionTypeDescriptors;
>, <Line: -            /**
>, <Line: -             * The annotation tokens representing the method's annotations.
>, <Line: -             */
>, <Line: -            private final List<AnnotationToken> annotationTokens;
>, <Line: -            /**
>, <Line: -             * The annotation tokens representing the parameter's annotation. Every index can
>, <Line: -             * contain {@code null} if a parameter does not define any annotations.
>, <Line: -             */
>, <Line: -            private final Map<Integer, List<AnnotationToken>> parameterAnnotationTokens;
>, <Line: -            /**
>, <Line: -             * An array of parameter names which may be {@code null} if no explicit name is known for a parameter.
>, <Line: -             */
>, <Line: -            private final String[] parameterNames;
>, <Line: -             * An array of parameter modifiers which may be {@code null} if no modifiers is known.
>, <Line: -            private final Integer[] parameterModifiers;
>, <Line: -             * The default value of this method or {@code null} if no such value exists.
>, <Line: -            private final AnnotationDescription.AnnotationValue<?, ?> defaultValue;
>, <Line: -             * Creates a new lazy method description.
>, <Line: -             * @param internalName              The internal name of this method.
>, <Line: -             * @param modifiers                 The modifiers of the represented method.
>, <Line: -             * @param methodDescriptor          The method descriptor of this method.
>, <Line: -             * @param signatureResolution       The generic type token of this method.
>, <Line: -             * @param exceptionTypeInternalName The internal names of the exceptions that are declared by this
>, <Line: -             *                                  method or {@code null} if no exceptions are declared by this
>, <Line: -             *                                  method.
>, <Line: -             * @param annotationTokens          The annotation tokens representing the method's annotations.
>, <Line: -             * @param parameterAnnotationTokens The annotation tokens representing the parameter's annotation. Every
>, <Line: -             *                                  index can contain {@code null} if a parameter does not define any annotations.
>, <Line: -             * @param parameterTokens           A list of parameter tokens which might be empty or even out of sync
>, <Line: -             *                                  with the actual parameters if the debugging information found in a
>, <Line: -             *                                  class was corrupt.
>, <Line: -             * @param defaultValue              The default value of this method or {@code null} if there is no
>, <Line: -             *                                  such value.
>, <Line: -            private LazyMethodDescription(String internalName,
>, <Line: -                                          int modifiers,
>, <Line: -                                          String methodDescriptor,
>, <Line: -                                          GenericTypeToken.Resolution.ForMethod signatureResolution,
>, <Line: -                                          String[] exceptionTypeInternalName,
>, <Line: -                                          List<AnnotationToken> annotationTokens,
>, <Line: -                                          Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
>, <Line: -                                          List<MethodToken.ParameterToken> parameterTokens,
>, <Line: -                                          AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
>, <Line: -                this.modifiers = modifiers;
>, <Line: -                this.internalName = internalName;
>, <Line: -                Type methodType = Type.getMethodType(methodDescriptor);
>, <Line: -                Type returnType = methodType.getReturnType();
>, <Line: -                Type[] parameterType = methodType.getArgumentTypes();
>, <Line: -                returnTypeDescriptor = returnType.getDescriptor();
>, <Line: -                parameterTypeDescriptors = new ArrayList<String>(parameterType.length);
>, <Line: -                for (Type type : parameterType) {
>, <Line: -                    parameterTypeDescriptors.add(type.getDescriptor());
>, <Line: -                }
>, <Line: -                this.signatureResolution = signatureResolution;
>, <Line: -                if (exceptionTypeInternalName == null) {
>, <Line: -                    exceptionTypeDescriptors = Collections.emptyList();
>, <Line: -                } else {
>, <Line: -                    exceptionTypeDescriptors = new ArrayList<String>(exceptionTypeInternalName.length);
>, <Line: -                    for (String anExceptionTypeInternalName : exceptionTypeInternalName) {
>, <Line: -                        exceptionTypeDescriptors.add(Type.getObjectType(anExceptionTypeInternalName).getDescriptor());
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                this.annotationTokens = annotationTokens;
>, <Line: -                this.parameterAnnotationTokens = parameterAnnotationTokens;
>, <Line: -                parameterNames = new String[parameterType.length];
>, <Line: -                parameterModifiers = new Integer[parameterType.length];
>, <Line: -                if (parameterTokens.size() == parameterType.length) {
>, <Line: -                    int index = 0;
>, <Line: -                    for (MethodToken.ParameterToken parameterToken : parameterTokens) {
>, <Line: -                        parameterNames[index] = parameterToken.getName();
>, <Line: -                        parameterModifiers[index] = parameterToken.getModifiers();
>, <Line: -                        index++;
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                this.defaultValue = defaultValue;
>, <Line: -            public Generic getReturnType() {
>, <Line: -                return signatureResolution.resolveReturnType(returnTypeDescriptor, typePool, this);
>, <Line: -            public TypeList.Generic getExceptionTypes() {
>, <Line: -                return signatureResolution.resolveExceptionTypes(exceptionTypeDescriptors, typePool, this);
>, <Line: -            public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
>, <Line: -                return new LazyParameterList();
>, <Line: -            public AnnotationList getDeclaredAnnotations() {
>, <Line: -                return LazyAnnotationDescription.asList(typePool, annotationTokens);
>, <Line: -            public String getInternalName() {
>, <Line: -                return internalName;
>, <Line: -            @Override
>, <Line: -            public TypeDescription getDeclaringType() {
>, <Line: -                return LazyTypeDescription.this;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int getModifiers() {
>, <Line: -                return modifiers;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeList.Generic getTypeVariables() {
>, <Line: -                return signatureResolution.resolveTypeVariables(typePool, this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Object getDefaultValue() {
>, <Line: -                return defaultValue == null
>, <Line: -                        ? NO_DEFAULT_VALUE
>, <Line: -                        : defaultValue.resolve();
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A lazy list of parameter descriptions for the enclosing method description.
>, <Line: -             */
>, <Line: -            private class LazyParameterList extends ParameterList.AbstractBase<ParameterDescription.InDefinedShape> {
>, <Line: -                public ParameterDescription.InDefinedShape get(int index) {
>, <Line: -                    return new LazyParameterDescription(index);
>, <Line: -                public boolean hasExplicitMetaData() {
>, <Line: -                    for (int i = 0; i < size(); i++) {
>, <Line: -                        if (parameterNames[i] == null || parameterModifiers[i] == null) {
>, <Line: -                            return false;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    return true;
>, <Line: -                public int size() {
>, <Line: -                    return parameterTypeDescriptors.size();
>, <Line: -                public TypeList.Generic asTypeList() {
>, <Line: -                    return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, LazyMethodDescription.this);
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * A lazy description of a parameters of the enclosing method.
>, <Line: -             */
>, <Line: -            private class LazyParameterDescription extends ParameterDescription.InDefinedShape.AbstractBase {
>, <Line: -                /**
>, <Line: -                 * The index of the described parameter.
>, <Line: -                 */
>, <Line: -                private final int index;
>, <Line: -                /**
>, <Line: -                 * Creates a new description for a given parameter of the enclosing method.
>, <Line: -                 *
>, <Line: -                 * @param index The index of the described parameter.
>, <Line: -                 */
>, <Line: -                protected LazyParameterDescription(int index) {
>, <Line: -                    this.index = index;
>, <Line: -                public MethodDescription.InDefinedShape getDeclaringMethod() {
>, <Line: -                    return LazyMethodDescription.this;
>, <Line: -                public int getIndex() {
>, <Line: -                    return index;
>, <Line: -                public boolean isNamed() {
>, <Line: -                    return parameterNames[index] != null;
>, <Line: -                public boolean hasModifiers() {
>, <Line: -                    return parameterModifiers[index] != null;
>, <Line: -                public String getName() {
>, <Line: -                    return isNamed()
>, <Line: -                            ? parameterNames[index]
>, <Line: -                            : super.getName();
>, <Line: -                public int getModifiers() {
>, <Line: -                    return hasModifiers()
>, <Line: -                            ? parameterModifiers[index]
>, <Line: -                            : super.getModifiers();
>, <Line: -                public Generic getType() {
>, <Line: -                    return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, LazyMethodDescription.this).get(index);
>, <Line: -                public AnnotationList getDeclaredAnnotations() {
>, <Line: -                    List<AnnotationToken> annotationTokens = parameterAnnotationTokens.get(index);
>, <Line: -                    return annotationTokens == null
>, <Line: -                            ? new AnnotationList.Empty()
>, <Line: -                            : LazyAnnotationDescription.asList(typePool, annotationTokens);
>]