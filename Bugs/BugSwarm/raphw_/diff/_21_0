[<Line: +import java.util.concurrent.TimeUnit;
>, <Line: +    Redefining with(RedefinitionStrategy redefinitionStrategy);
>, <Line: +    /**
>, <Line: +     * An agent builder that allows the configuration of how to apply a {@link RedefinitionStrategy}. Such a configuration
>, <Line: +     * is only applied if the redefinition strategy is alive.
>, <Line: +     */
>, <Line: +    interface Redefining extends AgentBuilder {
>, <Line: +        /**
>, <Line: +         * A batch allocator is responsible for diving a redefining of existing types into several chunks. This allows
>, <Line: +         * to narrow down errors for the redefining of specific types or to apply a {@link RedefinitionStrategy.Listener}
>, <Line: +         * action between chunks.
>, <Line: +         *
>, <Line: +         * @param redefinitionBatchAllocator The batch allocator to use.
>, <Line: +         * @return A new instance of this agent builder which makes use of the specified batch allocator.
>, <Line: +         */
>, <Line: +        Redefining with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator);
>, <Line: +        /**
>, <Line: +         * A failure handler is responsible for reacting to failed type redefinitions.
>, <Line: +         *
>, <Line: +         * @param redefinitionFailureHandler The failure handler to apply.
>, <Line: +         * @return A new instance of this agent builder which makes use of the specified failure handler.
>, <Line: +         */
>, <Line: +        Redefining with(RedefinitionStrategy.FailureHandler redefinitionFailureHandler);
>, <Line: +        /**
>, <Line: +         * <p>
>, <Line: +         * A redefinition listener is invoked before each batch of type redefinitions and on every error as well as
>, <Line: +         * after the redefinition was completed. A redefinition listener can be used for debugging or logging purposes
>, <Line: +         * and to apply actions between each batch, e.g. to pause or wait in order to avoid rendering the current VM
>, <Line: +         * non-responsive if a lot of classes are redefined.
>, <Line: +         * </p>
>, <Line: +         * <p>
>, <Line: +         * Adding several listeners does not replace previous listeners but applies them in the registration order.
>, <Line: +         * </p>
>, <Line: +         *
>, <Line: +         * @param redefinitionListener The listener to register.
>, <Line: +         * @return A new instance of this agent builder which notifies the specified listener upon type redefinitions.
>, <Line: +         */
>, <Line: +        Redefining with(RedefinitionStrategy.Listener redefinitionListener);
>, <Line: +    }
>, <Line: +             * <p>
>, <Line: +             * </p>
>, <Line: +             * <p>
>, <Line: +             * <b>Note</b>: This installation strategy does not undo any applied class redefinitions, if such were applied.
>, <Line: +             * </p>
>, <Line: +            protected Delegate<?> make(Default.Transformation transformation) {
>, <Line: +            protected Delegate<?> make(Default.Transformation transformation) {
>, <Line: +                return new Delegate.ForRedefinition(transformation);
>, <Line: +            protected Delegate<?> make(Default.Transformation transformation) {
>, <Line: +                return new Delegate.ForRetransformation(transformation);
>, <Line: +        protected abstract Delegate<?> make(Default.Transformation transformation);
>, <Line: +         * A batch allocator which is responsible for applying a redefinition in a batches. A class redefinition or
>, <Line: +         * retransformation can be a time-consuming operation rendering a JVM non-responsive. In combination with a
>, <Line: +         * a {@link RedefinitionStrategy.Listener}, it is also possible to apply pauses between batches to distribute
>, <Line: +         * the load of a retransformation over time.
>, <Line: +        public interface BatchAllocator {
>, <Line: +             * Splits a list of types to be retransformed into seperate batches.
>, <Line: +             * @param types A list of types which should be retransformed.
>, <Line: +             * @return An iterable of retransformations within a batch.
>, <Line: +            Iterable<? extends List<Class<?>>> batch(List<Class<?>> types);
>, <Line: +             * A batch allocator that includes all types in a single batch.
>, <Line: +            enum ForTotal implements BatchAllocator {
>, <Line: +                /**
>, <Line: +                 * The singleton instance.
>, <Line: +                 */
>, <Line: +                INSTANCE;
>, <Line: +                @Override
>, <Line: +                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
>, <Line: +                    return Collections.singleton(types);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal." + name();
>, <Line: +                }
>, <Line: +            }
>, <Line: +             * A batch allocator that creates chunks with a fixed size as batch jobs.
>, <Line: +            class ForFixedSize implements BatchAllocator {
>, <Line: +                 * The size of each chunk.
>, <Line: +                private final int size;
>, <Line: +                 * Creates a new batch allocator that creates fixed-sized chunks.
>, <Line: +                 *
>, <Line: +                 * @param size The size of each chunk.
>, <Line: +                protected ForFixedSize(int size) {
>, <Line: +                    this.size = size;
>, <Line: +                }
>, <Line: +                 * Creates a new batch allocator that creates chunks of a fixed size.
>, <Line: +                 * @param size The size of each chunk or {@code 0} if the batch should be included in a single chunk.
>, <Line: +                 * @return An appropriate batch allocator.
>, <Line: +                public static BatchAllocator ofSize(int size) {
>, <Line: +                    if (size > 0) {
>, <Line: +                        return new ForFixedSize(size);
>, <Line: +                    } else if (size == 0) {
>, <Line: +                        return ForTotal.INSTANCE;
>, <Line: +                    } else {
>, <Line: +                        throw new IllegalArgumentException("Cannot define a batch with a negative size: " + size);
>, <Line: +                    }
>, <Line: +                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
>, <Line: +                    List<List<Class<?>>> batches = new ArrayList<List<Class<?>>>();
>, <Line: +                    for (int index = 0; index < types.size(); index += size) {
>, <Line: +                        batches.add(new ArrayList<Class<?>>(types.subList(index, Math.min(types.size(), index + size))));
>, <Line: +                    }
>, <Line: +                    return batches;
>, <Line: +                public boolean equals(Object object) {
>, <Line: +                    if (this == object) return true;
>, <Line: +                    if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                    ForFixedSize that = (ForFixedSize) object;
>, <Line: +                    return size == that.size;
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    return size;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize{" +
>, <Line: +                            "size=" + size +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A failure handler to apply during a retransformation.
>, <Line: +         */
>, <Line: +        public interface FailureHandler {
>, <Line: +            /**
>, <Line: +             * Invoked when a batch of a retransformation failed.
>, <Line: +             *
>, <Line: +             * @param types     The types included in the batch.
>, <Line: +             * @param throwable The throwable indicating the failure.
>, <Line: +             * @return {@code true} if the batch failure should be considered as handled.
>, <Line: +             */
>, <Line: +            boolean onBatchFailure(List<Class<?>> types, Throwable throwable);
>, <Line: +            /**
>, <Line: +             * Invoked after all batches were completed.
>, <Line: +             *
>, <Line: +             * @param failures A map of all failures that were not considered as handled.
>, <Line: +             */
>, <Line: +            void onFailure(Map<List<Class<?>>, Throwable> failures);
>, <Line: +            /**
>, <Line: +             * Default implementations of {@link FailureHandler}s.
>, <Line: +             */
>, <Line: +            enum Default implements FailureHandler {
>, <Line: +                 * A fail fast failure handler fails a redefinition on the first failed batch.
>, <Line: +                FAIL_FAST {
>, <Line: +                    @Override
>, <Line: +                    public boolean onBatchFailure(List<Class<?>> types, Throwable throwable) {
>, <Line: +                        throw new IllegalStateException("Could not transform " + types, throwable);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void onFailure(Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                        throw new IllegalStateException("Unexpected recovery from batch failure");
>, <Line: +                },
>, <Line: +                /**
>, <Line: +                 * A fail last failure handler fails a redefinition after all batches were run if at least one batch failed.
>, <Line: +                 */
>, <Line: +                FAIL_LAST {
>, <Line: +                    public boolean onBatchFailure(List<Class<?>> types, Throwable throwable) {
>, <Line: +                        return false;
>, <Line: +                    public void onFailure(Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                        throw new IllegalStateException("Could not transform " + failures);
>, <Line: +                },
>, <Line: +                 * A suppressing failure handler ignores any failed batches.
>, <Line: +                IGNORING {
>, <Line: +                    @Override
>, <Line: +                    public boolean onBatchFailure(List<Class<?>> types, Throwable throwable) {
>, <Line: +                        return false;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public void onFailure(Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                        /* do nothing */
>, <Line: +                },
>, <Line: +                /**
>, <Line: +                 * A suppressing failure handler ignores any failed batches and does not expose them to the any listeners.
>, <Line: +                 */
>, <Line: +                SUPPRESSING {
>, <Line: +                    public boolean onBatchFailure(List<Class<?>> types, Throwable throwable) {
>, <Line: +                        return true;
>, <Line: +                    public void onFailure(Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                        /* do nothing */
>, <Line: +                };
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.FailureHandler.Default." + name();
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A listener to be applied during a redefinition.
>, <Line: +         */
>, <Line: +        public interface Listener {
>, <Line: +            /**
>, <Line: +             * Invoked before applying a batch.
>, <Line: +             *
>, <Line: +             * @param index A running index of the batch starting at {@code 0}.
>, <Line: +             * @param batch The types included in this batch.
>, <Line: +             * @param types All types included in the retransformation.
>, <Line: +             */
>, <Line: +            void onBatch(int index, List<Class<?>> batch, List<Class<?>> types);
>, <Line: +            /**
>, <Line: +             * Invoked upon an error during a batch. This method is not invoked if the failure handler handled this error.
>, <Line: +             *
>, <Line: +             * @param index     A running index of the batch starting at {@code 0}.
>, <Line: +             * @param batch     The types included in this batch.
>, <Line: +             * @param throwable The throwable that caused this invocation.
>, <Line: +             * @param types     All types included in the retransformation.
>, <Line: +             */
>, <Line: +            void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types);
>, <Line: +            /**
>, <Line: +             * Invoked upon completion of all batches.
>, <Line: +             *
>, <Line: +             * @param index    A total amount of batches that were executed.
>, <Line: +             * @param types    All types included in the retransformation.
>, <Line: +             * @param failures A mapping of batch types to their unhandled failures.
>, <Line: +             */
>, <Line: +            void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures);
>, <Line: +            /**
>, <Line: +             * A non-operational listener.
>, <Line: +             */
>, <Line: +            enum NoOp implements Listener {
>, <Line: +                 * The singleton instance.
>, <Line: +                INSTANCE;
>, <Line: +                @Override
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Listener.NoOp." + name();
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A listener that invokes {@link Thread#yield()} prior to every batch but the first batch.
>, <Line: +             */
>, <Line: +            enum Yielding implements Listener {
>, <Line: +                /**
>, <Line: +                 * The singleton instance.
>, <Line: +                 */
>, <Line: +                INSTANCE;
>, <Line: +                @Override
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    if (index > 0) {
>, <Line: +                        Thread.yield();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Listener.Yielding." + name();
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A listener adapter that offers non-operational implementations of all listener methods.
>, <Line: +             */
>, <Line: +            abstract class Adapter implements Listener {
>, <Line: +                @Override
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                    /* do nothing */
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A listener that invokes {@link Thread#sleep(long)} prior to every batch but the first batch.
>, <Line: +             */
>, <Line: +            class Pausing extends Adapter {
>, <Line: +                /**
>, <Line: +                 * The time to sleep in milliseconds between every two batches.
>, <Line: +                 */
>, <Line: +                private final long value;
>, <Line: +                /**
>, <Line: +                 * Creates a new pausing listener.
>, <Line: +                 *
>, <Line: +                 * @param value The time to sleep in milliseconds between every two batches.
>, <Line: +                 */
>, <Line: +                protected Pausing(long value) {
>, <Line: +                    this.value = value;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a listener that pauses for the specified amount of time. If the specified value is {@code 0}, a
>, <Line: +                 * non-operational listener is returned.
>, <Line: +                 *
>, <Line: +                 * @param value    The amount of time to pause between redefinition batches.
>, <Line: +                 * @param timeUnit The time unit of {@code value}.
>, <Line: +                 * @return An appropriate listener.
>, <Line: +                 */
>, <Line: +                public static Listener of(long value, TimeUnit timeUnit) {
>, <Line: +                    if (value > 0L) {
>, <Line: +                        return new Pausing(timeUnit.toMillis(value));
>, <Line: +                    } else if (value == 0L) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    } else {
>, <Line: +                        throw new IllegalArgumentException("Cannot sleep for a non-positive amount of time: " + value);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    if (index > 0) {
>, <Line: +                        try {
>, <Line: +                            Thread.sleep(value);
>, <Line: +                        } catch (InterruptedException exception) {
>, <Line: +                            throw new RuntimeException("Sleep was interrupted", exception);
>, <Line: +                        }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object object) {
>, <Line: +                    if (this == object) return true;
>, <Line: +                    if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                    Pausing pausing = (Pausing) object;
>, <Line: +                    return value == pausing.value;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    return (int) (value ^ (value >>> 32));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Listener.Pausing{" +
>, <Line: +                            "value=" + value +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A listener that writes events to a {@link PrintStream}.
>, <Line: +             */
>, <Line: +            class StreamWriting implements Listener {
>, <Line: +                /**
>, <Line: +                 * The print stream to write any events to.
>, <Line: +                 */
>, <Line: +                private final PrintStream printStream;
>, <Line: +                /**
>, <Line: +                 * Creates a new stream writing listener.
>, <Line: +                 *
>, <Line: +                 * @param printStream The print stream to write any events to.
>, <Line: +                 */
>, <Line: +                public StreamWriting(PrintStream printStream) {
>, <Line: +                    this.printStream = printStream;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Writes the stream result to {@link System#out}.
>, <Line: +                 *
>, <Line: +                 * @return An appropriate listener.
>, <Line: +                 */
>, <Line: +                public static Listener toSystemOut() {
>, <Line: +                    return new StreamWriting(System.out);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Writes the stream result to {@link System#err}.
>, <Line: +                 *
>, <Line: +                 * @return An appropriate listener.
>, <Line: +                 */
>, <Line: +                public static Listener toSystemError() {
>, <Line: +                    return new StreamWriting(System.err);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    printStream.println(AgentBuilder.Listener.StreamWriting.PREFIX + " RETRANSFORM BATCH #" + index + " (" + batch.size() + " types)");
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    synchronized (printStream) {
>, <Line: +                        printStream.println(AgentBuilder.Listener.StreamWriting.PREFIX + " RETRANSFORM ERROR #" + index + " (" + batch.size() + " types)");
>, <Line: +                        throwable.printStackTrace(printStream);
>, <Line: +                @Override
>, <Line: +                public void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                    printStream.println(AgentBuilder.Listener.StreamWriting.PREFIX + " RETRANSFORM COMPLETE " + index + " batches (" + failures.size() + " errors)");
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object object) {
>, <Line: +                    if (this == object) return true;
>, <Line: +                    if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                    StreamWriting streamWriting = (StreamWriting) object;
>, <Line: +                    return printStream.equals(streamWriting.printStream);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    return printStream.hashCode();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Listener.StreamWriting{" +
>, <Line: +                            "printStream=" + printStream +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +             * A compound listener that delegates events to several listeners.
>, <Line: +            class Compound implements Listener {
>, <Line: +                 * The listeners to invoke.
>, <Line: +                private final List<? extends Listener> listeners;
>, <Line: +                 * Creates a new compound listener.
>, <Line: +                 *
>, <Line: +                 * @param listener The listeners to invoke.
>, <Line: +                protected Compound(Listener... listener) {
>, <Line: +                    this(Arrays.asList(listener));
>, <Line: +                }
>, <Line: +                 * Creates a new compound listener.
>, <Line: +                 * @param listeners The listeners to invoke.
>, <Line: +                protected Compound(List<? extends Listener> listeners) {
>, <Line: +                    this.listeners = listeners;
>, <Line: +                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
>, <Line: +                    for (Listener listener : listeners) {
>, <Line: +                        listener.onBatch(index, batch, types);
>, <Line: +                    }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    for (Listener listener : listeners) {
>, <Line: +                        listener.onError(index, batch, throwable, types);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onComplete(int index, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
>, <Line: +                    for (Listener listener : listeners) {
>, <Line: +                        listener.onComplete(index, types, failures);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object object) {
>, <Line: +                    if (this == object) return true;
>, <Line: +                    if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                    Compound compound = (Compound) object;
>, <Line: +                    return listeners.equals(compound.listeners);
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    return listeners.hashCode();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Listener.Compound{" +
>, <Line: +                            "listeners=" + listeners +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A collector is responsible for collecting classes that are to be considered for modification.
>, <Line: +         *
>, <Line: +         * @param <T> The type of element that is supplied to the instrumentation API.
>, <Line: +         */
>, <Line: +        protected abstract static class Delegate<T> {
>, <Line: +            /**
>, <Line: +             * The transformation of the built agent.
>, <Line: +             */
>, <Line: +            protected final Default.Transformation transformation;
>, <Line: +            /**
>, <Line: +             * A list of already collected redefinitions.
>, <Line: +             */
>, <Line: +            protected final List<Class<?>> types;
>, <Line: +            /**
>, <Line: +             * Creates a new delegate.
>, <Line: +             *
>, <Line: +             * @param transformation The transformation of the built agent.
>, <Line: +             */
>, <Line: +            protected Delegate(Default.Transformation transformation) {
>, <Line: +                this.transformation = transformation;
>, <Line: +                types = new ArrayList<Class<?>>();
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Considers the supplied type for redefinition.
>, <Line: +             *
>, <Line: +             * @param ignoredTypeMatcher  The ignored type matcher.
>, <Line: +             * @param listener            The listener to notify.
>, <Line: +             * @param typeDescription     The type's description.
>, <Line: +             * @param type                The type being redefined.
>, <Line: +             * @param classBeingRedefined The type being redefined or {@code null} if it should be considered unavailable.
>, <Line: +             * @param module              The redefined type's module or {@code null} if the current VM does not support the module system.
>, <Line: +             */
>, <Line: +            protected void consider(RawMatcher ignoredTypeMatcher,
>, <Line: +                                    AgentBuilder.Listener listener,
>, <Line: +                                    TypeDescription typeDescription,
>, <Line: +                                    Class<?> type,
>, <Line: +                                    Class<?> classBeingRedefined,
>, <Line: +                                    JavaModule module) {
>, <Line: +                consider(ignoredTypeMatcher, listener, typeDescription, type, classBeingRedefined, module, false);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Considers the supplied type for redefinition.
>, <Line: +             *
>, <Line: +             * @param ignoredTypeMatcher  The ignored type matcher.
>, <Line: +             * @param listener            The listener to notify.
>, <Line: +             * @param typeDescription     The type's description.
>, <Line: +             * @param type                The type being redefined.
>, <Line: +             * @param classBeingRedefined The type being redefined or {@code null} if it should be considered unavailable.
>, <Line: +             * @param module              The redefined type's module or {@code null} if the current VM does not support the module system.
>, <Line: +             * @param unmodifiable        {@code true} if the type should be seen as unmodifiable.
>, <Line: +             */
>, <Line: +            protected void consider(RawMatcher ignoredTypeMatcher,
>, <Line: +                                    AgentBuilder.Listener listener,
>, <Line: +                                    TypeDescription typeDescription,
>, <Line: +                                    Class<?> type,
>, <Line: +                                    Class<?> classBeingRedefined,
>, <Line: +                                    JavaModule module,
>, <Line: +                                    boolean unmodifiable) {
>, <Line: +                if (unmodifiable || !(transformation.isAlive(typeDescription,
>, <Line: +                        type.getClassLoader(),
>, <Line: +                        JavaModule.ofType(type),
>, <Line: +                        classBeingRedefined,
>, <Line: +                        type.getProtectionDomain(),
>, <Line: +                        ignoredTypeMatcher) && types.add(type))) {
>, <Line: +                    try {
>, <Line: +                        try {
>, <Line: +                            listener.onIgnored(typeDescription, type.getClassLoader(), module);
>, <Line: +                        } finally {
>, <Line: +                            listener.onComplete(typeDescription.getName(), type.getClassLoader(), module);
>, <Line: +                        }
>, <Line: +                    } catch (Throwable ignored) {
>, <Line: +                        // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Applies the current retransformation process.
>, <Line: +             *
>, <Line: +             * @param instrumentation            The instrumentation instance to apply the redefinition upon.
>, <Line: +             * @param locationStrategy           The location strategy to use.
>, <Line: +             * @param listener                   The listener to notify.
>, <Line: +             * @param redefinitionBatchAllocator The redefinition batch allocator to use.
>, <Line: +             * @param redefinitionListener       The redefinition listener to use.
>, <Line: +             * @param redefinitionFailureHandler The redefinition failure handler to use.
>, <Line: +             */
>, <Line: +            protected void apply(Instrumentation instrumentation,
>, <Line: +                                 LocationStrategy locationStrategy,
>, <Line: +                                 AgentBuilder.Listener listener,
>, <Line: +                                 BatchAllocator redefinitionBatchAllocator,
>, <Line: +                                 Listener redefinitionListener,
>, <Line: +                                 FailureHandler redefinitionFailureHandler) {
>, <Line: +                int index = 0;
>, <Line: +                Map<List<Class<?>>, Throwable> failures = new HashMap<List<Class<?>>, Throwable>();
>, <Line: +                for (List<Class<?>> batch : redefinitionBatchAllocator.batch(types)) {
>, <Line: +                    List<T> transformations = new ArrayList<T>(batch.size());
>, <Line: +                    for (Class<?> type : batch) {
>, <Line: +                        try {
>, <Line: +                            transformations.add(transform(type, locationStrategy));
>, <Line: +                        } catch (Throwable throwable) {
>, <Line: +                            JavaModule module = JavaModule.ofType(type);
>, <Line: +                                listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, throwable);
>, <Line: +                            } finally {
>, <Line: +                                listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module);
>, <Line: +                    }
>, <Line: +                    redefinitionListener.onBatch(index, batch, types);
>, <Line: +                    if (!transformations.isEmpty()) {
>, <Line: +                        try {
>, <Line: +                            doApply(transformations, instrumentation);
>, <Line: +                        } catch (Throwable throwable) {
>, <Line: +                            if (!redefinitionFailureHandler.onBatchFailure(batch, throwable)) {
>, <Line: +                                failures.put(batch, throwable);
>, <Line: +                                redefinitionListener.onError(index, batch, throwable, types);
>, <Line: +                            }
>, <Line: +                        } finally {
>, <Line: +                            index++;
>, <Line: +                }
>, <Line: +                redefinitionListener.onComplete(index, types, failures);
>, <Line: +                if (!failures.isEmpty()) {
>, <Line: +                    redefinitionFailureHandler.onFailure(failures);
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Turns a type into a transformation-ready primitive of the current redefinition process.
>, <Line: +             *
>, <Line: +             * @param type             The type to transform.
>, <Line: +             * @param locationStrategy The location strategy to use.
>, <Line: +             * @return A primitive of the current redefinition process.
>, <Line: +             * @throws IOException If an I/O error occured.
>, <Line: +             */
>, <Line: +            protected abstract T transform(Class<?> type, LocationStrategy locationStrategy) throws IOException;
>, <Line: +            /**
>, <Line: +             * Applies a type redefinition.
>, <Line: +             *
>, <Line: +             * @param transformations The transformations to apply.
>, <Line: +             * @param instrumentation The instrumentation instance to apply the redefinition on.
>, <Line: +             * @throws UnmodifiableClassException If a class was not modifiable.
>, <Line: +             * @throws ClassNotFoundException     If a class was not found.
>, <Line: +             */
>, <Line: +            protected abstract void doApply(List<T> transformations, Instrumentation instrumentation) throws UnmodifiableClassException, ClassNotFoundException;
>, <Line: +            @Override
>, <Line: +            public String toString() {
>, <Line: +                return "AgentBuilder.RedefinitionStrategy.Delegate." + getClass().getSimpleName() + "{" +
>, <Line: +                        "transformation=" + transformation +
>, <Line: +                        ", types=" + types +
>, <Line: +                        '}';
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A delegate that applies a <b>redefinition</b> of already loaded classes.
>, <Line: +             */
>, <Line: +            protected static class ForRedefinition extends Delegate<ClassDefinition> {
>, <Line: +                /**
>, <Line: +                 * Creates a new delegate for a redefinition.
>, <Line: +                 *
>, <Line: +                 * @param transformation The transformation of the built agent.
>, <Line: +                 */
>, <Line: +                protected ForRedefinition(Default.Transformation transformation) {
>, <Line: +                    super(transformation);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected ClassDefinition transform(Class<?> type, LocationStrategy locationStrategy) throws IOException {
>, <Line: +                    return new ClassDefinition(type, locationStrategy.classFileLocator(type.getClassLoader(), JavaModule.ofType(type))
>, <Line: +                            .locate(TypeDescription.ForLoadedType.getName(type))
>, <Line: +                            .resolve());
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected void doApply(List<ClassDefinition> transformations,
>, <Line: +                                       Instrumentation instrumentation) throws UnmodifiableClassException, ClassNotFoundException {
>, <Line: +                    instrumentation.redefineClasses(transformations.toArray(new ClassDefinition[transformations.size()]));
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A delegate that applies a <b>retransformation</b> of already loaded classes.
>, <Line: +             */
>, <Line: +            protected static class ForRetransformation extends Delegate<Class<?>> {
>, <Line: +                /**
>, <Line: +                 * Creates a new delegate for a retransformation.
>, <Line: +                 *
>, <Line: +                 * @param transformation The transformation to apply.
>, <Line: +                 */
>, <Line: +                protected ForRetransformation(Default.Transformation transformation) {
>, <Line: +                    super(transformation);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Class<?> transform(Class<?> type, LocationStrategy locationStrategy) {
>, <Line: +                    return type;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected void doApply(List<Class<?>> transformations,
>, <Line: +                                       Instrumentation instrumentation) throws UnmodifiableClassException {
>, <Line: +                    instrumentation.retransformClasses(transformations.toArray(new Class<?>[transformations.size()]));
>, <Line: +    class Default implements AgentBuilder.Redefining {
>, <Line: +        /**
>, <Line: +         * The batch allocator for the redefinition strategy to apply.
>, <Line: +         */
>, <Line: +        private final RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator;
>, <Line: +        /**
>, <Line: +         * The failure handler for the redefinition strategy to apply.
>, <Line: +         */
>, <Line: +        private final RedefinitionStrategy.FailureHandler redefinitionFailureHandler;
>, <Line: +        /**
>, <Line: +         * The redefinition listener for the redefinition strategy to apply.
>, <Line: +         */
>, <Line: +        private final RedefinitionStrategy.Listener redefinitionListener;
>, <Line: +                    RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
>, <Line: +                    RedefinitionStrategy.FailureHandler.Default.FAIL_FAST,
>, <Line: +                    RedefinitionStrategy.Listener.NoOp.INSTANCE,
>, <Line: +         * @param redefinitionBatchAllocator    The batch allocator for the redefinition strategy to apply.
>, <Line: +         * @param redefinitionFailureHandler    The failure handler for the redefinition strategy to apply.
>, <Line: +         * @param redefinitionListener          The redefinition listener for the redefinition strategy to apply.
>, <Line: +                          RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
>, <Line: +                          RedefinitionStrategy.FailureHandler redefinitionFailureHandler,
>, <Line: +                          RedefinitionStrategy.Listener redefinitionListener,
>, <Line: +            this.redefinitionBatchAllocator = redefinitionBatchAllocator;
>, <Line: +            this.redefinitionFailureHandler = redefinitionFailureHandler;
>, <Line: +            this.redefinitionListener = redefinitionListener;
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    bootstrapInjectionStrategy,
>, <Line: +                    lambdaInstrumentationStrategy,
>, <Line: +                    descriptionStrategy,
>, <Line: +                    installationStrategy,
>, <Line: +                    fallbackStrategy,
>, <Line: +                    ignoredTypeMatcher,
>, <Line: +                    transformation);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public Redefining with(RedefinitionStrategy redefinitionStrategy) {
>, <Line: +            return new Default(byteBuddy,
>, <Line: +                    listener,
>, <Line: +                    poolStrategy,
>, <Line: +                    typeStrategy,
>, <Line: +                    locationStrategy,
>, <Line: +                    nativeMethodStrategy,
>, <Line: +                    initializationStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
>, <Line: +                    RedefinitionStrategy.FailureHandler.Default.FAIL_FAST,
>, <Line: +                    RedefinitionStrategy.Listener.NoOp.INSTANCE,
>, <Line: +                    bootstrapInjectionStrategy,
>, <Line: +                    lambdaInstrumentationStrategy,
>, <Line: +                    descriptionStrategy,
>, <Line: +                    installationStrategy,
>, <Line: +                    fallbackStrategy,
>, <Line: +                    ignoredTypeMatcher,
>, <Line: +                    transformation);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public Redefining with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator) {
>, <Line: +            return new Default(byteBuddy,
>, <Line: +                    listener,
>, <Line: +                    poolStrategy,
>, <Line: +                    typeStrategy,
>, <Line: +                    locationStrategy,
>, <Line: +                    nativeMethodStrategy,
>, <Line: +                    initializationStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    bootstrapInjectionStrategy,
>, <Line: +                    lambdaInstrumentationStrategy,
>, <Line: +                    descriptionStrategy,
>, <Line: +                    installationStrategy,
>, <Line: +                    fallbackStrategy,
>, <Line: +                    ignoredTypeMatcher,
>, <Line: +                    transformation);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public Redefining with(RedefinitionStrategy.FailureHandler redefinitionFailureHandler) {
>, <Line: +            return new Default(byteBuddy,
>, <Line: +                    listener,
>, <Line: +                    poolStrategy,
>, <Line: +                    typeStrategy,
>, <Line: +                    locationStrategy,
>, <Line: +                    nativeMethodStrategy,
>, <Line: +                    initializationStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +        public Redefining with(RedefinitionStrategy.Listener redefinitionListener) {
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    new RedefinitionStrategy.Listener.Compound(this.redefinitionListener, redefinitionListener),
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    redefinitionBatchAllocator,
>, <Line: +                    redefinitionFailureHandler,
>, <Line: +                    redefinitionListener,
>, <Line: +                    RedefinitionStrategy.Delegate<?> delegate = redefinitionStrategy.make(transformation);
>, <Line: +                                delegate.consider(ignoredTypeMatcher,
>, <Line: +                                        listener,
>, <Line: +                                        descriptionStrategy.apply(TypeDescription.ForLoadedType.getName(type), type, typePool),
>, <Line: +                                        type,
>, <Line: +                                        type,
>, <Line: +                                        module,
>, <Line: +                                        !instrumentation.isModifiableClass(type));
>, <Line: +                                    delegate.consider(ignoredTypeMatcher,
>, <Line: +                                            listener,
>, <Line: +                                            typePool.describe(TypeDescription.ForLoadedType.getName(type)).resolve(),
>, <Line: +                                            type,
>, <Line: +                                            NO_LOADED_TYPE,
>, <Line: +                                            module);
>, <Line: +                    delegate.apply(instrumentation, locationStrategy, listener, redefinitionBatchAllocator, redefinitionListener, redefinitionFailureHandler);
>, <Line: +                    && redefinitionBatchAllocator.equals(aDefault.redefinitionBatchAllocator)
>, <Line: +                    && redefinitionFailureHandler.equals(aDefault.redefinitionFailureHandler)
>, <Line: +                    && redefinitionListener.equals(aDefault.redefinitionListener)
>, <Line: +            result = 31 * result + redefinitionBatchAllocator.hashCode();
>, <Line: +            result = 31 * result + redefinitionFailureHandler.hashCode();
>, <Line: +            result = 31 * result + redefinitionListener.hashCode();
>, <Line: +                    ", redefinitionBatchAllocator=" + redefinitionBatchAllocator +
>, <Line: +                    ", redefinitionFailureHandler=" + redefinitionFailureHandler +
>, <Line: +                    ", redefinitionListener=" + redefinitionListener +
>, <Line: +        protected static class ExecutingTransformer extends ResettableClassFileTransformer.AbstractBase {
>, <Line: +            public Reset reset(Instrumentation instrumentation,
>, <Line: +                               RedefinitionStrategy redefinitionStrategy,
>, <Line: +                               RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
>, <Line: +                               RedefinitionStrategy.Listener redefinitionListener) {
>, <Line: +                    Map<Class<?>, Throwable> failures = new HashMap<Class<?>, Throwable>();
>, <Line: +                    RedefinitionStrategy.Delegate<?> delegate = redefinitionStrategy.make(transformation);
>, <Line: +                        JavaModule module = JavaModule.ofType(type);
>, <Line: +                            delegate.consider(ignoredTypeMatcher,
>, <Line: +                                            poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), module), type.getClassLoader())),
>, <Line: +                                    module,
>, <Line: +                                    delegate.consider(ignoredTypeMatcher,
>, <Line: +                                                    poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), module), type.getClassLoader())),
>, <Line: +                                            module);
>, <Line: +                                    failures.put(type, throwable);
>, <Line: +                                failures.put(type, fallback);
>, <Line: +                    delegate.apply(instrumentation,
>, <Line: +                            locationStrategy,
>, <Line: +                            Listener.NoOp.INSTANCE,
>, <Line: +                            RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
>, <Line: +                            new RedefinitionStrategy.Listener.Compound(new FailureCollectingListener(failures), redefinitionListener),
>, <Line: +                            RedefinitionStrategy.FailureHandler.Default.SUPPRESSING);
>, <Line: +                    return Reset.WithErrors.ofPotentiallyErroneous(failures);
>, <Line: +            /**
>, <Line: +             * A listener that adds all discovered errors to a map.
>, <Line: +             */
>, <Line: +            protected static class FailureCollectingListener extends RedefinitionStrategy.Listener.Adapter {
>, <Line: +                /**
>, <Line: +                 * A mapping of failures by the class that causes this failure.
>, <Line: +                 */
>, <Line: +                private final Map<Class<?>, Throwable> failures;
>, <Line: +                /**
>, <Line: +                 * Creates a new failure collecting listener.
>, <Line: +                 *
>, <Line: +                 * @param failures A mapping of failures by the class that causes this failure.
>, <Line: +                 */
>, <Line: +                protected FailureCollectingListener(Map<Class<?>, Throwable> failures) {
>, <Line: +                    this.failures = failures;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
>, <Line: +                    for (Class<?> type : batch) {
>, <Line: +                        failures.put(type, throwable);
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object object) {
>, <Line: +                    if (this == object) return true;
>, <Line: +                    if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                    FailureCollectingListener that = (FailureCollectingListener) object;
>, <Line: +                    return failures.equals(that.failures);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    return failures.hashCode();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.Default.ExecutingTransformer.FailureCollectingListener{" +
>, <Line: +                            "failures=" + failures +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            public Redefining with(RedefinitionStrategy redefinitionStrategy) {
>, <Line: +                        redefinitionBatchAllocator,
>, <Line: +                        redefinitionFailureHandler,
>, <Line: +                        redefinitionListener,
>, <Line: +                        redefinitionBatchAllocator,
>, <Line: +                        redefinitionFailureHandler,
>, <Line: +                        redefinitionListener,
>]
[<Line: -    AgentBuilder with(RedefinitionStrategy redefinitionStrategy);
>, <Line: -            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: -            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: -                return new Collector.ForRedefinition.Cumulative(transformation);
>, <Line: -            }
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * <p>
>, <Line: -         * Applies a <b>redefinition</b> to all classes that are already loaded and that would have been transformed if
>, <Line: -         * the built agent was registered before they were loaded. The created {@link ClassFileTransformer} is <b>not</b>
>, <Line: -         * registered for applying retransformations.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * Using this strategy, a redefinition is applied in single class chunks. This means that a single illegal
>, <Line: -         * redefinition of a class does not cause the failure of any other redefinition. Chunking the redefinition does
>, <Line: -         * however imply a performance penalty. If at least one redefinition has failed, applying this strategy still causes an
>, <Line: -         * exception to be thrown as a result of the application.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * <b>Note</b>: When applying a redefinition, it is normally required to use a {@link TypeStrategy} that applies
>, <Line: -         * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
>, <Line: -         * the constrains given by this type strategy.
>, <Line: -         * </p>
>, <Line: -         */
>, <Line: -        REDEFINITION_CHUNKED {
>, <Line: -            @Override
>, <Line: -            protected boolean isRetransforming(Instrumentation instrumentation) {
>, <Line: -                return REDEFINITION.isRetransforming(instrumentation);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: -                return new Collector.ForRedefinition.Chunked(transformation);
>, <Line: -            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: -                return new Collector.ForRetransformation.Cumulative(transformation);
>, <Line: -            }
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * <p>
>, <Line: -         * Applies a <b>retransformation</b> to all classes that are already loaded and that would have been transformed if
>, <Line: -         * the built agent was registered before they were loaded. The created {@link ClassFileTransformer} is registered
>, <Line: -         * for applying retransformations.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * Using this strategy, a retransformation is applied in single class chunks. This means that a single illegal
>, <Line: -         * retransformation of a class does not cause the failure of any other redefinition. Chunking the retransformation does
>, <Line: -         * however imply a performance penalty. If at least one retransformation has failed, applying this strategy still causes an
>, <Line: -         * exception to be thrown as a result of the application.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * <b>Note</b>: When applying a redefinition, it is normally required to use a {@link TypeStrategy} that applies
>, <Line: -         * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
>, <Line: -         * the constrains given by this type strategy.
>, <Line: -         * </p>
>, <Line: -         */
>, <Line: -        RETRANSFORMATION_CHUNKED {
>, <Line: -            @Override
>, <Line: -            protected boolean isRetransforming(Instrumentation instrumentation) {
>, <Line: -                return RETRANSFORMATION.isRetransforming(instrumentation);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: -                return new Collector.ForRetransformation.Chunked(transformation);
>, <Line: -        protected abstract Collector makeCollector(Default.Transformation transformation);
>, <Line: -         * A collector is responsible for collecting classes that are to be considered for modification.
>, <Line: -        protected interface Collector {
>, <Line: -             * Considers a loaded class for modification.
>, <Line: -             * @param typeDescription     The type description of the type that is to be considered.
>, <Line: -             * @param type                The loaded representation of the type that is to be considered.
>, <Line: -             * @param classBeingRedefined The loaded representation of the type that is to be considered or {@code null} if the
>, <Line: -             *                            loaded type representation should not be considered.
>, <Line: -             * @param ignoredTypeMatcher  Identifies types that should not be instrumented.
>, <Line: -             * @return {@code true} if the class is considered to be redefined.
>, <Line: -            boolean consider(TypeDescription typeDescription, Class<?> type, Class<?> classBeingRedefined, RawMatcher ignoredTypeMatcher);
>, <Line: -             * Applies this collector.
>, <Line: -             *
>, <Line: -             * @param instrumentation  The instrumentation instance to apply the transformation for.
>, <Line: -             * @param poolStrategy     The type locator to use.
>, <Line: -             * @param locationStrategy The location strategy to use.
>, <Line: -             * @param listener         the listener to notify.
>, <Line: -             * @throws UnmodifiableClassException If a class is not modifiable.
>, <Line: -             * @throws ClassNotFoundException     If a class could not be found.
>, <Line: -            void apply(Instrumentation instrumentation,
>, <Line: -                       PoolStrategy poolStrategy,
>, <Line: -                       LocationStrategy locationStrategy,
>, <Line: -                       Listener listener) throws UnmodifiableClassException, ClassNotFoundException;
>, <Line: -             * A collector that applies a <b>redefinition</b> of already loaded classes.
>, <Line: -            abstract class ForRedefinition implements Collector {
>, <Line: -                 * The transformation of the built agent.
>, <Line: -                protected final Default.Transformation transformation;
>, <Line: -                 * A list of already collected redefinitions.
>, <Line: -                protected final List<Entry> entries;
>, <Line: -                 * Creates a new collector for a redefinition.
>, <Line: -                 * @param transformation The transformation of the built agent.
>, <Line: -                protected ForRedefinition(Default.Transformation transformation) {
>, <Line: -                    this.transformation = transformation;
>, <Line: -                    entries = new ArrayList<Entry>();
>, <Line: -                public boolean consider(TypeDescription typeDescription, Class<?> type, Class<?> classBeingRedefined, RawMatcher ignoredTypeMatcher) {
>, <Line: -                    return transformation.isAlive(typeDescription,
>, <Line: -                            type.getClassLoader(),
>, <Line: -                            JavaModule.ofType(type),
>, <Line: -                            classBeingRedefined,
>, <Line: -                            type.getProtectionDomain(),
>, <Line: -                            ignoredTypeMatcher) && entries.add(new Entry(type));
>, <Line: -                public void apply(Instrumentation instrumentation,
>, <Line: -                                  PoolStrategy poolStrategy,
>, <Line: -                                  LocationStrategy locationStrategy,
>, <Line: -                                  Listener listener) throws UnmodifiableClassException, ClassNotFoundException {
>, <Line: -                    List<ClassDefinition> classDefinitions = new ArrayList<ClassDefinition>(entries.size());
>, <Line: -                    for (Entry entry : entries) {
>, <Line: -                        try {
>, <Line: -                            classDefinitions.add(entry.resolve(locationStrategy));
>, <Line: -                        } catch (Throwable throwable) {
>, <Line: -                            JavaModule module = JavaModule.ofType(entry.getType());
>, <Line: -                            try {
>, <Line: -                                listener.onError(TypeDescription.ForLoadedType.getName(entry.getType()), entry.getType().getClassLoader(), module, throwable);
>, <Line: -                            } finally {
>, <Line: -                                listener.onComplete(TypeDescription.ForLoadedType.getName(entry.getType()), entry.getType().getClassLoader(), module);
>, <Line: -                            }
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                    doApply(instrumentation, classDefinitions);
>, <Line: -                /**
>, <Line: -                 * Applies a redefinition.
>, <Line: -                 *
>, <Line: -                 * @param instrumentation  The instrumentation instance to use.
>, <Line: -                 * @param classDefinitions The class definitions to apply.
>, <Line: -                 * @throws UnmodifiableClassException If a class is not modifiable.
>, <Line: -                 * @throws ClassNotFoundException     If a class could not be found.
>, <Line: -                 */
>, <Line: -                protected abstract void doApply(Instrumentation instrumentation, List<ClassDefinition> classDefinitions) throws UnmodifiableClassException, ClassNotFoundException;
>, <Line: -                 * A collector that applies a redefinition and applies all redefinitions as a single transformation request.
>, <Line: -                protected static class Cumulative extends ForRedefinition {
>, <Line: -                    /**
>, <Line: -                     * Creates a new cumulative redefinition collector.
>, <Line: -                     *
>, <Line: -                     * @param transformation The transformation of the built agent.
>, <Line: -                     */
>, <Line: -                    protected Cumulative(Default.Transformation transformation) {
>, <Line: -                        super(transformation);
>, <Line: -                    protected void doApply(Instrumentation instrumentation, List<ClassDefinition> classDefinitions) throws UnmodifiableClassException, ClassNotFoundException {
>, <Line: -                        if (!classDefinitions.isEmpty()) {
>, <Line: -                            instrumentation.redefineClasses(classDefinitions.toArray(new ClassDefinition[classDefinitions.size()]));
>, <Line: -                        }
>, <Line: -                    public String toString() {
>, <Line: -                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.Cumulative{" +
>, <Line: -                                "transformation=" + transformation +
>, <Line: -                                ", entries=" + entries +
>, <Line: -                                '}';
>, <Line: -                }
>, <Line: -                 * A collector that applies a redefinition and applies all redefinitions as a separate transformation request per class.
>, <Line: -                protected static class Chunked extends ForRedefinition {
>, <Line: -                    /**
>, <Line: -                     * Creates a new chunked redefinition collector.
>, <Line: -                     *
>, <Line: -                     * @param transformation The transformation of the built agent.
>, <Line: -                     */
>, <Line: -                    protected Chunked(Default.Transformation transformation) {
>, <Line: -                        super(transformation);
>, <Line: -                    protected void doApply(Instrumentation instrumentation, List<ClassDefinition> classDefinitions) throws UnmodifiableClassException, ClassNotFoundException {
>, <Line: -                        Map<Class<?>, Exception> exceptions = new HashMap<Class<?>, Exception>();
>, <Line: -                        for (ClassDefinition classDefinition : classDefinitions) {
>, <Line: -                            try {
>, <Line: -                                instrumentation.redefineClasses(classDefinition);
>, <Line: -                            } catch (Exception exception) {
>, <Line: -                                exceptions.put(classDefinition.getDefinitionClass(), exception);
>, <Line: -                            }
>, <Line: -                        }
>, <Line: -                        if (!exceptions.isEmpty()) {
>, <Line: -                            throw new IllegalStateException("Could not retransform at least one class: " + exceptions);
>, <Line: -                        }
>, <Line: -                    public String toString() {
>, <Line: -                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.Chunked{" +
>, <Line: -                                "transformation=" + transformation +
>, <Line: -                                ", entries=" + entries +
>, <Line: -                                '}';
>, <Line: -                 * An entry describing a type redefinition.
>, <Line: -                protected static class Entry {
>, <Line: -                    /**
>, <Line: -                     * The type to be redefined.
>, <Line: -                     */
>, <Line: -                    private final Class<?> type;
>, <Line: -                    /**
>, <Line: -                     * Creates a new entry for a given type.
>, <Line: -                     *
>, <Line: -                     * @param type The type to be redefined.
>, <Line: -                     */
>, <Line: -                    protected Entry(Class<?> type) {
>, <Line: -                        this.type = type;
>, <Line: -                    }
>, <Line: -                    /**
>, <Line: -                     * Returns the type that is being redefined.
>, <Line: -                     *
>, <Line: -                     * @return The type that is being redefined.
>, <Line: -                     */
>, <Line: -                    public Class<?> getType() {
>, <Line: -                        return type;
>, <Line: -                    }
>, <Line: -                    /**
>, <Line: -                     * Resolves the entry to a class definition.
>, <Line: -                     *
>, <Line: -                     * @param locationStrategy A strategy for creating a class file locator.
>, <Line: -                     * @return A class definition representing the redefined class.
>, <Line: -                     * @throws IOException If an I/O exception occurs.
>, <Line: -                     */
>, <Line: -                    protected ClassDefinition resolve(LocationStrategy locationStrategy) throws IOException {
>, <Line: -                        return new ClassDefinition(type, locationStrategy
>, <Line: -                                .classFileLocator(type.getClassLoader(), JavaModule.ofType(type))
>, <Line: -                                .locate(TypeDescription.ForLoadedType.getName(type)).resolve());
>, <Line: -                    @Override
>, <Line: -                    public boolean equals(Object other) {
>, <Line: -                        if (this == other) return true;
>, <Line: -                        if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                        Entry entry = (Entry) other;
>, <Line: -                        return type.equals(entry.type);
>, <Line: -                    @Override
>, <Line: -                    public int hashCode() {
>, <Line: -                        return type.hashCode();
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.Entry{" +
>, <Line: -                                "type=" + type +
>, <Line: -                                '}';
>, <Line: -             * A collector that applies a <b>retransformation</b> of already loaded classes.
>, <Line: -            abstract class ForRetransformation implements Collector {
>, <Line: -                 * The transformation defined by the built agent.
>, <Line: -                protected final Default.Transformation transformation;
>, <Line: -                 * The types that were collected for retransformation.
>, <Line: -                protected final List<Class<?>> types;
>, <Line: -                 * Creates a new collector for a retransformation.
>, <Line: -                 * @param transformation The transformation defined by the built agent.
>, <Line: -                protected ForRetransformation(Default.Transformation transformation) {
>, <Line: -                    this.transformation = transformation;
>, <Line: -                    types = new ArrayList<Class<?>>();
>, <Line: -                public boolean consider(TypeDescription typeDescription, Class<?> type, Class<?> classBeingRedefined, RawMatcher ignoredTypeMatcher) {
>, <Line: -                    return transformation.isAlive(typeDescription,
>, <Line: -                            type.getClassLoader(),
>, <Line: -                            JavaModule.ofType(type),
>, <Line: -                            classBeingRedefined,
>, <Line: -                            type.getProtectionDomain(),
>, <Line: -                            ignoredTypeMatcher) && types.add(type);
>, <Line: -                /**
>, <Line: -                 * A collector that applies a retransformation and applies all redefinitions as a single transformation request.
>, <Line: -                 */
>, <Line: -                protected static class Cumulative extends ForRetransformation {
>, <Line: -                    /**
>, <Line: -                     * Creates a new cumulative retransformation collector.
>, <Line: -                     *
>, <Line: -                     * @param transformation The transformation of the built agent.
>, <Line: -                     */
>, <Line: -                    protected Cumulative(Default.Transformation transformation) {
>, <Line: -                        super(transformation);
>, <Line: -                    @Override
>, <Line: -                    public void apply(Instrumentation instrumentation,
>, <Line: -                                      PoolStrategy poolStrategy,
>, <Line: -                                      LocationStrategy locationStrategy,
>, <Line: -                                      Listener listener) throws UnmodifiableClassException {
>, <Line: -                        if (!types.isEmpty()) {
>, <Line: -                            instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
>, <Line: -                        }
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRetransformation.Cumulative{" +
>, <Line: -                                "transformation=" + transformation +
>, <Line: -                                ", types=" + types +
>, <Line: -                                '}';
>, <Line: -                    }
>, <Line: -                /**
>, <Line: -                 * A collector that applies a retransformation and applies all redefinitions as a chunked transformation request.
>, <Line: -                 */
>, <Line: -                protected static class Chunked extends ForRetransformation {
>, <Line: -                    /**
>, <Line: -                     * Creates a new chunked retransformation collector.
>, <Line: -                     *
>, <Line: -                     * @param transformation The transformation of the built agent.
>, <Line: -                     */
>, <Line: -                    protected Chunked(Default.Transformation transformation) {
>, <Line: -                        super(transformation);
>, <Line: -                    @Override
>, <Line: -                    public void apply(Instrumentation instrumentation,
>, <Line: -                                      PoolStrategy poolStrategy,
>, <Line: -                                      LocationStrategy locationStrategy,
>, <Line: -                                      Listener listener) throws UnmodifiableClassException {
>, <Line: -                        Map<Class<?>, Exception> exceptions = new HashMap<Class<?>, Exception>();
>, <Line: -                        for (Class<?> type : types) {
>, <Line: -                                instrumentation.retransformClasses(type);
>, <Line: -                            } catch (Exception exception) {
>, <Line: -                                exceptions.put(type, exception);
>, <Line: -                        if (!exceptions.isEmpty()) {
>, <Line: -                            throw new IllegalStateException("Could not retransform at least one class: " + exceptions);
>, <Line: -                    @Override
>, <Line: -                    public String toString() {
>, <Line: -                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRetransformation.Chunked{" +
>, <Line: -                                "transformation=" + transformation +
>, <Line: -                                ", types=" + types +
>, <Line: -                                '}';
>, <Line: -                    }
>, <Line: -    class Default implements AgentBuilder {
>, <Line: -        public AgentBuilder with(RedefinitionStrategy redefinitionStrategy) {
>, <Line: -                    RedefinitionStrategy.Collector collector = redefinitionStrategy.makeCollector(transformation);
>, <Line: -                                doConsider(descriptionStrategy.apply(TypeDescription.ForLoadedType.getName(type), type, typePool), type, type, module, collector, !instrumentation.isModifiableClass(type));
>, <Line: -                                    doConsider(typePool.describe(TypeDescription.ForLoadedType.getName(type)).resolve(), type, NO_LOADED_TYPE, module, collector, false);
>, <Line: -                    collector.apply(instrumentation, poolStrategy, locationStrategy, listener);
>, <Line: -        /**
>, <Line: -         * Does consider the retransformation or redefinition of a loaded type.
>, <Line: -         *
>, <Line: -         * @param typeDescription     The type description of the type being considered.
>, <Line: -         * @param type                The loaded type being considered.
>, <Line: -         * @param classBeingRedefined The loaded type being considered or {@code null} if it should be considered non-available.
>, <Line: -         * @param module              The type's Java module or {@code null} if the current VM does not support modules.
>, <Line: -         * @param collector           The collector to apply.
>, <Line: -         * @param unmodifiable        {@code true} if the current type should be considered unmodifiable.
>, <Line: -         */
>, <Line: -        private void doConsider(TypeDescription typeDescription,
>, <Line: -                                Class<?> type,
>, <Line: -                                Class<?> classBeingRedefined,
>, <Line: -                                JavaModule module,
>, <Line: -                                RedefinitionStrategy.Collector collector,
>, <Line: -                                boolean unmodifiable) {
>, <Line: -            doConsider(ignoredTypeMatcher, listener, typeDescription, type, classBeingRedefined, module, collector, unmodifiable);
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * Does consider the retransformation or redefinition of a loaded type.
>, <Line: -         *
>, <Line: -         * @param ignoredTypeMatcher  The ignored type matcher to apply.
>, <Line: -         * @param listener            The listener to apply during the consideration.
>, <Line: -         * @param typeDescription     The type description of the type being considered.
>, <Line: -         * @param type                The loaded type being considered.
>, <Line: -         * @param classBeingRedefined The loaded type being considered or {@code null} if it should be considered non-available.
>, <Line: -         * @param module              The type's Java module or {@code null} if the current VM does not support modules.
>, <Line: -         * @param collector           The collector to apply.
>, <Line: -         * @param unmodifiable        {@code true} if the current type should be considered unmodifiable.
>, <Line: -         */
>, <Line: -        protected static void doConsider(RawMatcher ignoredTypeMatcher,
>, <Line: -                                         Listener listener,
>, <Line: -                                         TypeDescription typeDescription,
>, <Line: -                                         Class<?> type,
>, <Line: -                                         Class<?> classBeingRedefined,
>, <Line: -                                         JavaModule module,
>, <Line: -                                         RedefinitionStrategy.Collector collector,
>, <Line: -                                         boolean unmodifiable) {
>, <Line: -            if (unmodifiable || !collector.consider(typeDescription, type, classBeingRedefined, ignoredTypeMatcher)) {
>, <Line: -                try {
>, <Line: -                    try {
>, <Line: -                        listener.onIgnored(typeDescription, type.getClassLoader(), module);
>, <Line: -                    } finally {
>, <Line: -                        listener.onComplete(typeDescription.getName(), type.getClassLoader(), module);
>, <Line: -                    }
>, <Line: -                } catch (Throwable ignored) {
>, <Line: -                    // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
>, <Line: -                }
>, <Line: -            }
>, <Line: -        }
>, <Line: -        protected static class ExecutingTransformer implements ResettableClassFileTransformer {
>, <Line: -            public synchronized Reset reset(Instrumentation instrumentation, RedefinitionStrategy redefinitionStrategy) {
>, <Line: -                    Map<Class<?>, Throwable> errors = new HashMap<Class<?>, Throwable>();
>, <Line: -                    RedefinitionStrategy.Collector collector = redefinitionStrategy.makeCollector(transformation);
>, <Line: -                            doConsider(ignoredTypeMatcher,
>, <Line: -                                            poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), JavaModule.ofType(type)), type.getClassLoader())),
>, <Line: -                                    JavaModule.ofType(type),
>, <Line: -                                    collector,
>, <Line: -                                    doConsider(ignoredTypeMatcher,
>, <Line: -                                                    poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), JavaModule.ofType(type)), type.getClassLoader())),
>, <Line: -                                            JavaModule.ofType(type),
>, <Line: -                                            collector,
>, <Line: -                                            false);
>, <Line: -                                    errors.put(type, throwable);
>, <Line: -                                errors.put(type, fallback);
>, <Line: -                    try {
>, <Line: -                        collector.apply(instrumentation, poolStrategy, locationStrategy, Listener.NoOp.INSTANCE);
>, <Line: -                    } catch (UnmodifiableClassException exception) {
>, <Line: -                        throw new IllegalStateException("Could not modify classes", exception);
>, <Line: -                    } catch (ClassNotFoundException exception) {
>, <Line: -                        throw new IllegalStateException("Could not find class", exception);
>, <Line: -                    }
>, <Line: -                    return Reset.WithErrors.ofPotentiallyErroneous(errors);
>, <Line: -            public AgentBuilder with(RedefinitionStrategy redefinitionStrategy) {
>]