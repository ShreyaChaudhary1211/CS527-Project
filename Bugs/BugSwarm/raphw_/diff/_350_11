[<Line: +        TypeVariableDefinition<T> typeVariable(String symbol);
>, <Line: +        TypeVariableDefinition<T> typeVariable(String symbol, Type... bound);
>, <Line: +        TypeVariableDefinition<T> typeVariable(String symbol, List<? extends Type> bounds);
>, <Line: +        TypeVariableDefinition<T> typeVariable(String symbol, TypeDefinition... bound);
>, <Line: +        TypeVariableDefinition<T> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
>, <Line: +        /**
>, <Line: +         * A builder for a type variable definition.
>, <Line: +         *
>, <Line: +         * @param <S> A loaded type that the built type is guaranteed to be a subclass of.
>, <Line: +         */
>, <Line: +        interface TypeVariableDefinition<S> extends Builder<S> {
>, <Line: +            /**
>, <Line: +             * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +             *
>, <Line: +             * @param annotation The annotations to declare on the previously defined type variable.
>, <Line: +             * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +             * on the previously defined type variable.
>, <Line: +             */
>, <Line: +            TypeVariableDefinition<S> annotateTypeVariable(Annotation... annotation);
>, <Line: +            /**
>, <Line: +             * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +             *
>, <Line: +             * @param annotations The annotations to declare on the previously defined type variable.
>, <Line: +             * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +             * on the previously defined type variable.
>, <Line: +             */
>, <Line: +            TypeVariableDefinition<S> annotateTypeVariable(List<? extends Annotation> annotations);
>, <Line: +            /**
>, <Line: +             * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +             *
>, <Line: +             * @param annotation The annotations to declare on the previously defined type variable.
>, <Line: +             * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +             * on the previously defined type variable.
>, <Line: +             */
>, <Line: +            TypeVariableDefinition<S> annotateTypeVariable(AnnotationDescription... annotation);
>, <Line: +            /**
>, <Line: +             * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +             *
>, <Line: +             * @param annotations The annotations to declare on the previously defined type variable.
>, <Line: +             * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +             * on the previously defined type variable.
>, <Line: +             */
>, <Line: +            TypeVariableDefinition<S> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations);
>, <Line: +            /**
>, <Line: +             * An abstract base implementation of a type variable definition.
>, <Line: +             *
>, <Line: +             * @param <U> A loaded type that the built type is guaranteed to be a subclass of.
>, <Line: +             */
>, <Line: +            abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements TypeVariableDefinition<U> {
>, <Line: +                @Override
>, <Line: +                public TypeVariableDefinition<U> annotateTypeVariable(Annotation... annotation) {
>, <Line: +                    return annotateTypeVariable(Arrays.asList(annotation));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeVariableDefinition<U> annotateTypeVariable(List<? extends Annotation> annotations) {
>, <Line: +                    return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeVariableDefinition<U> annotateTypeVariable(AnnotationDescription... annotation) {
>, <Line: +                    return annotateTypeVariable(Arrays.asList(annotation));
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +                        return annotateField(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                Annotatable<U> typeVariable(String symbol);
>, <Line: +                Annotatable<U> typeVariable(String symbol, Type... bound);
>, <Line: +                Annotatable<U> typeVariable(String symbol, List<? extends Type> bounds);
>, <Line: +                Annotatable<U> typeVariable(String symbol, TypeDefinition... bound);
>, <Line: +                Annotatable<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
>, <Line: +                /**
>, <Line: +                 * A builder for optionally defining an annotation for a type variable.
>, <Line: +                 *
>, <Line: +                 * @param <V> A loaded type that the built type is guaranteed to be a subclass of.
>, <Line: +                 */
>, <Line: +                interface Annotatable<V> extends TypeVariableDefinition<V> {
>, <Line: +                    /**
>, <Line: +                     * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +                     *
>, <Line: +                     * @param annotation The annotations to declare on the previously defined type variable.
>, <Line: +                     * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +                     * on the previously defined type variable.
>, <Line: +                     */
>, <Line: +                    Annotatable<V> annotateTypeVariable(Annotation... annotation);
>, <Line: +                    /**
>, <Line: +                     * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +                     *
>, <Line: +                     * @param annotations The annotations to declare on the previously defined type variable.
>, <Line: +                     * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +                     * on the previously defined type variable.
>, <Line: +                     */
>, <Line: +                    Annotatable<V> annotateTypeVariable(List<? extends Annotation> annotations);
>, <Line: +                    /**
>, <Line: +                     * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +                     *
>, <Line: +                     * @param annotation The annotations to declare on the previously defined type variable.
>, <Line: +                     * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +                     * on the previously defined type variable.
>, <Line: +                     */
>, <Line: +                    Annotatable<V> annotateTypeVariable(AnnotationDescription... annotation);
>, <Line: +                    /**
>, <Line: +                     * Annotates the previously defined type variable with the supplied annotations.
>, <Line: +                     *
>, <Line: +                     * @param annotations The annotations to declare on the previously defined type variable.
>, <Line: +                     * @return A new builder that is equal to this builder but with the given annotations declared
>, <Line: +                     * on the previously defined type variable.
>, <Line: +                     */
>, <Line: +                    Annotatable<V> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations);
>, <Line: +                    /**
>, <Line: +                     * An abstract base implementation for defining an annotation on a parameter.
>, <Line: +                     *
>, <Line: +                     * @param <W> A loaded type that the built type is guaranteed to be a subclass of.
>, <Line: +                     */
>, <Line: +                    abstract class AbstractBase<W> extends TypeVariableDefinition.AbstractBase<W> implements Annotatable<W> {
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(Annotation... annotation) {
>, <Line: +                            return annotateTypeVariable(Arrays.asList(annotation));
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(List<? extends Annotation> annotations) {
>, <Line: +                            return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(AnnotationDescription... annotation) {
>, <Line: +                            return annotateTypeVariable(Arrays.asList(annotation));
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * An adapter implementation for an annotatable type variable definition.
>, <Line: +                         *
>, <Line: +                         * @param <X> A loaded type that the built type is guaranteed to be a subclass of.
>, <Line: +                         */
>, <Line: +                        protected abstract static class Adapter<X> extends TypeVariableDefinition.Annotatable.AbstractBase<X> {
>, <Line: +                            @Override
>, <Line: +                            public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                                return materialize().typeVariable(symbol, bounds);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public MethodDefinition<X> intercept(Implementation implementation) {
>, <Line: +                                return materialize().intercept(implementation);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public MethodDefinition<X> withoutCode() {
>, <Line: +                                return materialize().withoutCode();
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public MethodDefinition<X> defaultValue(Object value) {
>, <Line: +                                return materialize().defaultValue(value);
>, <Line: +                            }
>, <Line: +                            @Override
>, <Line: +                            public MethodDefinition<X> defaultValue(Object value, Class<?> type) {
>, <Line: +                                return materialize().defaultValue(value, type);
>, <Line: +                            }
>, <Line: +                            /**
>, <Line: +                             * Materializes this instance as a parameter definition with the currently defined properties.
>, <Line: +                             *
>, <Line: +                             * @return A parameter definition with the currently defined properties.
>, <Line: +                             */
>, <Line: +                            protected abstract MethodDefinition.ParameterDefinition<X> materialize();
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                    public Annotatable<V> typeVariable(String symbol) {
>, <Line: +                    public Annotatable<V> typeVariable(String symbol, Type... bound) {
>, <Line: +                    public Annotatable<V> typeVariable(String symbol, List<? extends Type> bounds) {
>, <Line: +                    public Annotatable<V> typeVariable(String symbol, TypeDefinition... bound) {
>, <Line: +                        public ParameterDefinition.Annotatable<W> annotateParameter(Annotation... annotation) {
>, <Line: +                        public ParameterDefinition.Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
>, <Line: +                            return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                        public ParameterDefinition.Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
>, <Line: +                        protected abstract static class Adapter<X> extends ParameterDefinition.Annotatable.AbstractBase<X> {
>, <Line: +                            public ParameterDefinition.Annotatable<X> withParameter(TypeDefinition type, String name, int modifiers) {
>, <Line: +                            public ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
>, <Line: +                            public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                        abstract class AbstractBase<W> extends Simple.AbstractBase<W> implements Annotatable<W> {
>, <Line: +                            public Simple.Annotatable<W> annotateParameter(Annotation... annotation) {
>, <Line: +                            public Simple.Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
>, <Line: +                                return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                            public Simple.Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
>, <Line: +                            protected abstract static class Adapter<X> extends Simple.Annotatable.AbstractBase<X> {
>, <Line: +                                public Simple.Annotatable<X> withParameter(TypeDefinition type) {
>, <Line: +                                public ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
>, <Line: +                                public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                        public Simple.Annotatable<W> withParameter(Type type) {
>, <Line: +                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
>, <Line: +                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
>, <Line: +                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, int modifiers) {
>, <Line: +                    public ParameterDefinition.Annotatable<V> withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
>, <Line: +                    public ParameterDefinition.Annotatable<V> withParameter(TypeDefinition type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
>, <Line: +                    return annotateMethod(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                    return annotateParameter(index, new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +                return annotateType(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +            public TypeVariableDefinition<S> typeVariable(String symbol) {
>, <Line: +            public TypeVariableDefinition<S> typeVariable(String symbol, Type... bound) {
>, <Line: +            public TypeVariableDefinition<S> typeVariable(String symbol, List<? extends Type> bounds) {
>, <Line: +            public TypeVariableDefinition<S> typeVariable(String symbol, TypeDefinition... bound) {
>, <Line: +                public TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                public TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds))));
>, <Line: +                /**
>, <Line: +                 * An adapter for defining a new type variable for the instrumented type.
>, <Line: +                 */
>, <Line: +                protected class TypeVariableDefinitionAdapter extends TypeVariableDefinition.AbstractBase<U> {
>, <Line: +                    /**
>, <Line: +                     * The current definition of the type variable.
>, <Line: +                     */
>, <Line: +                    private final TypeVariableToken token;
>, <Line: +                    /**
>, <Line: +                     * Creates a new type variable definition adapter.
>, <Line: +                     *
>, <Line: +                     * @param token The current definition of the type variable.
>, <Line: +                     */
>, <Line: +                    protected TypeVariableDefinitionAdapter(TypeVariableToken token) {
>, <Line: +                        this.token = token;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeVariableDefinition<U> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                        return new TypeVariableDefinitionAdapter(new TypeVariableToken(token.getSymbol(),
>, <Line: +                                token.getBounds(),
>, <Line: +                                CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected Builder<U> materialize() {
>, <Line: +                        return Adapter.this.materialize(instrumentedType.withTypeVariable(token),
>, <Line: +                                fieldRegistry,
>, <Line: +                                methodRegistry,
>, <Line: +                                typeAttributeAppender,
>, <Line: +                                asmVisitorWrapper,
>, <Line: +                                classFileVersion,
>, <Line: +                                auxiliaryTypeNamingStrategy,
>, <Line: +                                annotationValueFilterFactory,
>, <Line: +                                annotationRetention,
>, <Line: +                                implementationContextFactory,
>, <Line: +                                methodGraphCompiler,
>, <Line: +                                typeValidation,
>, <Line: +                                ignoredMethods);
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Returns the outer instance.
>, <Line: +                     *
>, <Line: +                     * @return The outer instance.
>, <Line: +                     */
>, <Line: +                    private Builder.AbstractBase.Adapter<?> getOuter() {
>, <Line: +                        return Builder.AbstractBase.Adapter.this;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    @SuppressWarnings("unchecked")
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && getOuter().equals(((TypeVariableDefinitionAdapter) other).getOuter())
>, <Line: +                                && token.equals(((TypeVariableDefinitionAdapter) other).token);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = getOuter().hashCode();
>, <Line: +                        result = 31 * result + token.hashCode();
>, <Line: +                        return result;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "DynamicType.Builder.AbstractBase.Adapter.TypeVariableDefinitionAdapter{" +
>, <Line: +                                "adapter=" + getOuter() +
>, <Line: +                                ", token=" + token +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                    public MethodDefinition.TypeVariableDefinition.Annotatable<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: +                        return new TypeVariableAnnotationAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds))));
>, <Line: +                    /**
>, <Line: +                     * An adapter for defining a new type variable for the currently defined method.
>, <Line: +                     */
>, <Line: +                    protected class TypeVariableAnnotationAdapter extends MethodDefinition.TypeVariableDefinition.Annotatable.AbstractBase.Adapter<U> {
>, <Line: +                        /**
>, <Line: +                         * The currently defined type variable.
>, <Line: +                         */
>, <Line: +                        private final TypeVariableToken token;
>, <Line: +                        /**
>, <Line: +                         * Creates a new type variable annotation adapter.
>, <Line: +                         *
>, <Line: +                         * @param token The currently defined type variable.
>, <Line: +                         */
>, <Line: +                        protected TypeVariableAnnotationAdapter(TypeVariableToken token) {
>, <Line: +                            this.token = token;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        protected MethodDefinition.ParameterDefinition<U> materialize() {
>, <Line: +                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getModifiers(),
>, <Line: +                                    CompoundList.of(MethodDefinitionAdapter.this.token.getTypeVariableTokens(), token),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getReturnType(),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getParameterTokens(),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getAnnotations(),
>, <Line: +                                    MethodDefinitionAdapter.this.token.getDefaultValue()));
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public Annotatable<U> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                            return new TypeVariableAnnotationAdapter(new TypeVariableToken(token.getSymbol(),
>, <Line: +                                    token.getBounds(),
>, <Line: +                                    CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private MethodDefinitionAdapter getOuter() {
>, <Line: +                            return MethodDefinitionAdapter.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        @SuppressWarnings("unchecked")
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && token.equals(((TypeVariableAnnotationAdapter) other).token)
>, <Line: +                                    && getOuter().equals(((TypeVariableAnnotationAdapter) other).getOuter());
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return 31 * getOuter().hashCode() + token.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "DynamicType.Builder.AbstractBase.Adapter.MethodDefinitionAdapter.TypeVariableAnnotationAdapter{" +
>, <Line: +                                    "adapter=" + getOuter() +
>, <Line: +                                    ", token=" + token +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                        public MethodDefinition.ParameterDefinition.Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                        public MethodDefinition.ParameterDefinition.Simple.Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
>]
[<Line: -        Builder<T> typeVariable(String symbol);
>, <Line: -        Builder<T> typeVariable(String symbol, Type... bound);
>, <Line: -        Builder<T> typeVariable(String symbol, List<? extends Type> bounds);
>, <Line: -        Builder<T> typeVariable(String symbol, TypeDefinition... bound);
>, <Line: -        Builder<T> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
>, <Line: -                        return annotateField(new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -                TypeVariableDefinition<U> typeVariable(String symbol);
>, <Line: -                TypeVariableDefinition<U> typeVariable(String symbol, Type... bound);
>, <Line: -                TypeVariableDefinition<U> typeVariable(String symbol, List<? extends Type> bounds);
>, <Line: -                TypeVariableDefinition<U> typeVariable(String symbol, TypeDefinition... bound);
>, <Line: -                TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
>, <Line: -                    public TypeVariableDefinition<V> typeVariable(String symbol) {
>, <Line: -                    public TypeVariableDefinition<V> typeVariable(String symbol, Type... bound) {
>, <Line: -                    public TypeVariableDefinition<V> typeVariable(String symbol, List<? extends Type> bounds) {
>, <Line: -                    public TypeVariableDefinition<V> typeVariable(String symbol, TypeDefinition... bound) {
>, <Line: -                        public Annotatable<W> annotateParameter(Annotation... annotation) {
>, <Line: -                        public Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
>, <Line: -                            return annotateParameter(new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -                        public Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
>, <Line: -                        protected abstract static class Adapter<X> extends Annotatable.AbstractBase<X> {
>, <Line: -                            public Annotatable<X> withParameter(TypeDefinition type, String name, int modifiers) {
>, <Line: -                            public MethodDefinition.ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
>, <Line: -                            public MethodDefinition.TypeVariableDefinition<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: -                        abstract class AbstractBase<W> extends ParameterDefinition.Simple.AbstractBase<W> implements Annotatable<W> {
>, <Line: -                            public Annotatable<W> annotateParameter(Annotation... annotation) {
>, <Line: -                            public Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
>, <Line: -                                return annotateParameter(new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -                            public Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
>, <Line: -                            protected abstract static class Adapter<X> extends Annotatable.AbstractBase<X> {
>, <Line: -                                public Annotatable<X> withParameter(TypeDefinition type) {
>, <Line: -                                public MethodDefinition.ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
>, <Line: -                                public MethodDefinition.TypeVariableDefinition<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: -                        public Annotatable<W> withParameter(Type type) {
>, <Line: -                    public Annotatable<V> withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
>, <Line: -                    public Annotatable<V> withParameter(Type type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
>, <Line: -                    public Annotatable<V> withParameter(Type type, String name, int modifiers) {
>, <Line: -                    public Annotatable<V> withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
>, <Line: -                    public Annotatable<V> withParameter(TypeDefinition type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
>, <Line: -                    return annotateMethod(new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -                    return annotateParameter(index, new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -                return annotateType(new AnnotationList.ForLoadedAnnotation(annotations));
>, <Line: -            public Builder<S> typeVariable(String symbol) {
>, <Line: -            public Builder<S> typeVariable(String symbol, Type... bound) {
>, <Line: -            public Builder<S> typeVariable(String symbol, List<? extends Type> bounds) {
>, <Line: -            public Builder<S> typeVariable(String symbol, TypeDefinition... bound) {
>, <Line: -                public Builder<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: -                public Builder<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: -                    return materialize(instrumentedType.withTypeVariable(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds)))),
>, <Line: -                            fieldRegistry,
>, <Line: -                            methodRegistry,
>, <Line: -                            typeAttributeAppender,
>, <Line: -                            asmVisitorWrapper,
>, <Line: -                            classFileVersion,
>, <Line: -                            auxiliaryTypeNamingStrategy,
>, <Line: -                            annotationValueFilterFactory,
>, <Line: -                            annotationRetention,
>, <Line: -                            implementationContextFactory,
>, <Line: -                            methodGraphCompiler,
>, <Line: -                            typeValidation,
>, <Line: -                            ignoredMethods);
>, <Line: -                    public MethodDefinition.TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
>, <Line: -                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),
>, <Line: -                                token.getModifiers(),
>, <Line: -                                CompoundList.of(token.getTypeVariableTokens(), new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds)))),
>, <Line: -                                token.getReturnType(),
>, <Line: -                                token.getParameterTokens(),
>, <Line: -                                token.getExceptionTypes(),
>, <Line: -                                token.getAnnotations(),
>, <Line: -                                token.getDefaultValue()));
>, <Line: -                        public Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
>, <Line: -                        public Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
>]