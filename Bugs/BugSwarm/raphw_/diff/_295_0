[<Line: +import java.lang.instrument.ClassDefinition;
>, <Line: +     * Specifies a strategy for modifying existing types.
>, <Line: +     * @param redefinitionStrategy The redefinition strategy to apply.
>, <Line: +     * @return A new instance of this agent builder that applies the given redefinition strategy.
>, <Line: +    AgentBuilder withRedefinitionStrategy(RedefinitionStrategy redefinitionStrategy);
>, <Line: +         * @param classLoader The class loader of the instrumented type. Might be {@code null} if this class
>, <Line: +         *                    loader represents the bootstrap class loader.
>, <Line: +         * @return This binary locator in its initialized form.
>, <Line: +         */
>, <Line: +        Initialized initialize(ClassLoader classLoader);
>, <Line: +        /**
>, <Line: +         * Initializes this binary locator.
>, <Line: +         *
>, <Line: +         * @param typeName             The binary name of the type that is being instrumented.
>, <Line: +         * @param binaryRepresentation The binary representation of the instrumented type.
>, <Line: +        Initialized initialize(ClassLoader classLoader, String typeName, byte[] binaryRepresentation);
>, <Line: +            public BinaryLocator.Initialized initialize(ClassLoader classLoader, String typeName, byte[] binaryRepresentation) {
>, <Line: +                return Initialized.Extended.of(typeName,
>, <Line: +            @Override
>, <Line: +            public BinaryLocator.Initialized initialize(ClassLoader classLoader) {
>, <Line: +                return Initialized.Simple.of(new TypePool.CacheProvider.Simple(), ClassFileLocator.ForClassLoader.of(classLoader), readerMode);
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A {@link net.bytebuddy.agent.builder.AgentBuilder.BinaryLocator} in initialized state.
>, <Line: +         */
>, <Line: +        interface Initialized {
>, <Line: +            /**
>, <Line: +             * Returns the type pool to be used of an {@link net.bytebuddy.agent.builder.AgentBuilder}.
>, <Line: +             *
>, <Line: +             * @return The type pool to use.
>, <Line: +             */
>, <Line: +            TypePool getTypePool();
>, <Line: +            /**
>, <Line: +             * Returns the class file locator to be used of an {@link net.bytebuddy.agent.builder.AgentBuilder}.
>, <Line: +             *
>, <Line: +             * @return The class file locator to use.
>, <Line: +             */
>, <Line: +            ClassFileLocator getClassFileLocator();
>, <Line: +            /**
>, <Line: +             * A simple initialized binary locator without a shortcut to retriving a prefetched class file.
>, <Line: +             */
>, <Line: +            class Simple implements Initialized {
>, <Line: +                /**
>, <Line: +                 * The type pool to use.
>, <Line: +                 */
>, <Line: +                private final TypePool typePool;
>, <Line: +                /**
>, <Line: +                 * The class file locator to use.
>, <Line: +                 */
>, <Line: +                private final ClassFileLocator classFileLocator;
>, <Line: +                /**
>, <Line: +                 * Creates a new simple, initialized binary locator.
>, <Line: +                 *
>, <Line: +                 * @param typePool         The type pool to use.
>, <Line: +                 * @param classFileLocator The class file locator to use.
>, <Line: +                 */
>, <Line: +                protected Simple(TypePool typePool, ClassFileLocator classFileLocator) {
>, <Line: +                    this.typePool = typePool;
>, <Line: +                    this.classFileLocator = classFileLocator;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a simple initialized binary locator.
>, <Line: +                 *
>, <Line: +                 * @param cacheProvider    The cache provider to use.
>, <Line: +                 * @param classFileLocator The class file locator to use.
>, <Line: +                 * @param readerMode       The reader mode to use.
>, <Line: +                 * @return An appropriate initialized binary locator.
>, <Line: +                 */
>, <Line: +                protected static Initialized of(TypePool.CacheProvider.Simple cacheProvider,
>, <Line: +                                                ClassFileLocator classFileLocator,
>, <Line: +                                                TypePool.Default.ReaderMode readerMode) {
>, <Line: +                    return new Simple(new TypePool.Default(cacheProvider, classFileLocator, readerMode), classFileLocator);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypePool getTypePool() {
>, <Line: +                    return typePool;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public ClassFileLocator getClassFileLocator() {
>, <Line: +                    return classFileLocator;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    if (this == other) return true;
>, <Line: +                    if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                    Simple simple = (Simple) other;
>, <Line: +                    return typePool.equals(simple.typePool) && classFileLocator.equals(simple.classFileLocator);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = typePool.hashCode();
>, <Line: +                    result = 31 * result + classFileLocator.hashCode();
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.BinaryLocator.Initialized.Simple{" +
>, <Line: +                            "typePool=" + typePool +
>, <Line: +                            ", classFileLocator=" + classFileLocator +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            class Extended implements Initialized, ClassFileLocator {
>, <Line: +                protected static Initialized of(String typeName,
>, <Line: +                                                byte[] binaryRepresentation,
>, <Line: +                                                TypePool.CacheProvider cacheProvider,
>, <Line: +                                                ClassFileLocator classFileLocator,
>, <Line: +                                                TypePool.Default.ReaderMode readerMode) {
>, <Line: +                    return new Extended(typeName,
>, <Line: +                protected Extended(String typeName,
>, <Line: +                                   byte[] binaryRepresentation,
>, <Line: +                                   TypePool typePool,
>, <Line: +                                   ClassFileLocator classFileLocator) {
>, <Line: +                    Extended that = (Extended) other;
>, <Line: +                    return "AgentBuilder.BinaryLocator.Initialized.Extended{" +
>, <Line: +    /**
>, <Line: +     * A redefinition strategy regulates how already loaded classes are modified by a built agent.
>, <Line: +     */
>, <Line: +    enum RedefinitionStrategy {
>, <Line: +        /**
>, <Line: +         * Disables redefinition such that already loaded classes are not affected by the agent.
>, <Line: +         */
>, <Line: +        DISABLED {
>, <Line: +            @Override
>, <Line: +            protected boolean isRetransforming(Instrumentation instrumentation) {
>, <Line: +                return false;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: +                throw new IllegalStateException();
>, <Line: +            }
>, <Line: +        },
>, <Line: +        /**
>, <Line: +         * Applies a <b>redefinition</b> to all classes that are already loaded and that would have been transformed if
>, <Line: +         * the built agent was registered before they were loaded.
>, <Line: +         */
>, <Line: +        REDEFINITION {
>, <Line: +            @Override
>, <Line: +            protected boolean isRetransforming(Instrumentation instrumentation) {
>, <Line: +                if (!instrumentation.isRedefineClassesSupported()) {
>, <Line: +                    throw new IllegalStateException("Cannot redefine classes: " + instrumentation);
>, <Line: +                }
>, <Line: +                return false;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: +                return new Collector.ForRedefinition(transformation);
>, <Line: +            }
>, <Line: +        },
>, <Line: +        /**
>, <Line: +         * Applies a <b>retransformation</b> to all classes that are already loaded and that would have been transformed if
>, <Line: +         * the built agent was registered before they were loaded.
>, <Line: +         */
>, <Line: +        RETRANSFORMATION {
>, <Line: +            @Override
>, <Line: +            protected boolean isRetransforming(Instrumentation instrumentation) {
>, <Line: +                if (!instrumentation.isRetransformClassesSupported()) {
>, <Line: +                    throw new IllegalStateException("Cannot retransform classes: " + instrumentation);
>, <Line: +                }
>, <Line: +                return true;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            protected Collector makeCollector(Default.Transformation transformation) {
>, <Line: +                return new Collector.ForRetransformation(transformation);
>, <Line: +            }
>, <Line: +        };
>, <Line: +        /**
>, <Line: +         * Indicates if this strategy requires a class file transformer to be registered with a hint to apply the
>, <Line: +         * transformer for retransformation.
>, <Line: +         *
>, <Line: +         * @param instrumentation The instrumentation instance used.
>, <Line: +         * @return {@code true} if a class file transformer must be registered with a hint for retransformation.
>, <Line: +         */
>, <Line: +        protected abstract boolean isRetransforming(Instrumentation instrumentation);
>, <Line: +        /**
>, <Line: +         * Indicates that this redefinition strategy applies a modification of already loaded classes.
>, <Line: +         *
>, <Line: +         * @return {@code true} if this redefinition strategy applies a modification of already loaded classes.
>, <Line: +         */
>, <Line: +        protected boolean isEnabled() {
>, <Line: +            return this != DISABLED;
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * Creates a collector instance that is responsible for collecting loaded classes for potential retransformation.
>, <Line: +         *
>, <Line: +         * @param transformation The transformation that is registered for the agent.
>, <Line: +         * @return A new collector for collecting already loaded classes for transformation.
>, <Line: +         */
>, <Line: +        protected abstract Collector makeCollector(Default.Transformation transformation);
>, <Line: +        @Override
>, <Line: +        public String toString() {
>, <Line: +            return "AgentBuilder.RedefinitionStrategy." + name();
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * A collector is responsible for collecting classes that are to be considered for modification.
>, <Line: +         */
>, <Line: +        protected interface Collector {
>, <Line: +            /**
>, <Line: +             * Considers a loaded class for modification.
>, <Line: +             *
>, <Line: +             * @param type The type that is to be considered.
>, <Line: +             */
>, <Line: +            void consider(Class<?> type);
>, <Line: +            /**
>, <Line: +             * Applies the represented type modification on all collected types.
>, <Line: +             *
>, <Line: +             * @param instrumentation            The instrumentation to use.
>, <Line: +             * @param byteBuddy                  The Byte Buddy configuration to use.
>, <Line: +             * @param binaryLocator              The binary locator to use.
>, <Line: +             * @param typeStrategy               The type strategy to use.
>, <Line: +             * @param listener                   The listener to report to.
>, <Line: +             * @param nativeMethodStrategy       The native method strategy to apply.
>, <Line: +             * @param accessControlContext       The access control context to use.
>, <Line: +             * @param initializationStrategy     The initialization strategy to use.
>, <Line: +             * @param bootstrapInjectionStrategy The bootrstrap injection strategy to use.
>, <Line: +             * @throws UnmodifiableClassException If an unmodifiable class is attempted to be modified.
>, <Line: +             * @throws ClassNotFoundException     If a class cannot be found while redefining another class.
>, <Line: +             */
>, <Line: +            void apply(Instrumentation instrumentation,
>, <Line: +                       ByteBuddy byteBuddy,
>, <Line: +                       BinaryLocator binaryLocator,
>, <Line: +                       TypeStrategy typeStrategy,
>, <Line: +                       Listener listener,
>, <Line: +                       Default.NativeMethodStrategy nativeMethodStrategy,
>, <Line: +                       AccessControlContext accessControlContext,
>, <Line: +                       InitializationStrategy initializationStrategy,
>, <Line: +                       Default.BootstrapInjectionStrategy bootstrapInjectionStrategy) throws UnmodifiableClassException, ClassNotFoundException;
>, <Line: +            /**
>, <Line: +             * A collector that applies a <b>redefinition</b> of already loaded classes.
>, <Line: +             */
>, <Line: +            class ForRedefinition implements Collector {
>, <Line: +                /**
>, <Line: +                 * The transformation of the built agent.
>, <Line: +                 */
>, <Line: +                private final Default.Transformation transformation;
>, <Line: +                /**
>, <Line: +                 * A list of already collected redefinitions.
>, <Line: +                 */
>, <Line: +                private final List<Entry> entries;
>, <Line: +                /**
>, <Line: +                 * Creates a new collector for a redefinition.
>, <Line: +                 *
>, <Line: +                 * @param transformation The transformation of the built agent.
>, <Line: +                 */
>, <Line: +                protected ForRedefinition(Default.Transformation transformation) {
>, <Line: +                    this.transformation = transformation;
>, <Line: +                    entries = new LinkedList<Entry>();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void consider(Class<?> type) {
>, <Line: +                    Default.Transformation.Resolution resolution = transformation.resolve(new TypeDescription.ForLoadedType(type),
>, <Line: +                            type.getClassLoader(),
>, <Line: +                            type,
>, <Line: +                            type.getProtectionDomain());
>, <Line: +                    if (resolution.isResolved()) {
>, <Line: +                        entries.add(new Entry(type, resolution));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void apply(Instrumentation instrumentation,
>, <Line: +                                  ByteBuddy byteBuddy,
>, <Line: +                                  BinaryLocator binaryLocator,
>, <Line: +                                  TypeStrategy typeStrategy,
>, <Line: +                                  Listener listener,
>, <Line: +                                  Default.NativeMethodStrategy nativeMethodStrategy,
>, <Line: +                                  AccessControlContext accessControlContext,
>, <Line: +                                  InitializationStrategy initializationStrategy,
>, <Line: +                                  Default.BootstrapInjectionStrategy bootstrapInjectionStrategy) throws UnmodifiableClassException, ClassNotFoundException {
>, <Line: +                    List<ClassDefinition> classDefinitions = new ArrayList<ClassDefinition>(entries.size());
>, <Line: +                    for (Entry entry : entries) {
>, <Line: +                        try {
>, <Line: +                            BinaryLocator.Initialized initialized = binaryLocator.initialize(entry.getType().getClassLoader());
>, <Line: +                            try {
>, <Line: +                                classDefinitions.add(entry.resolve(initializationStrategy,
>, <Line: +                                        initialized,
>, <Line: +                                        typeStrategy,
>, <Line: +                                        byteBuddy,
>, <Line: +                                        nativeMethodStrategy.resolve(),
>, <Line: +                                        bootstrapInjectionStrategy,
>, <Line: +                                        accessControlContext,
>, <Line: +                                        listener));
>, <Line: +                            } catch (Throwable throwable) {
>, <Line: +                                listener.onError(entry.getType().getName(), throwable);
>, <Line: +                            } finally {
>, <Line: +                                initialized.getTypePool().clear();
>, <Line: +                            }
>, <Line: +                        } finally {
>, <Line: +                            listener.onComplete(entry.getType().getName());
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    if (!classDefinitions.isEmpty()) {
>, <Line: +                        instrumentation.redefineClasses(classDefinitions.toArray(new ClassDefinition[classDefinitions.size()]));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition{" +
>, <Line: +                            "transformation=" + transformation +
>, <Line: +                            ", entries=" + entries +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * An entry describing a type redefinition.
>, <Line: +                 */
>, <Line: +                protected static class Entry {
>, <Line: +                    /**
>, <Line: +                     * The type to be redefined.
>, <Line: +                     */
>, <Line: +                    private final Class<?> type;
>, <Line: +                    /**
>, <Line: +                     * The resolved transformation for this type.
>, <Line: +                     */
>, <Line: +                    private final Default.Transformation.Resolution resolution;
>, <Line: +                    /**
>, <Line: +                     * @param type       The type to be redefined.
>, <Line: +                     * @param resolution The resolved transformation for this type.
>, <Line: +                     */
>, <Line: +                    protected Entry(Class<?> type, Default.Transformation.Resolution resolution) {
>, <Line: +                        this.type = type;
>, <Line: +                        this.resolution = resolution;
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Returns the type that is being redefined.
>, <Line: +                     *
>, <Line: +                     * @return The type that is being redefined.
>, <Line: +                     */
>, <Line: +                    public Class<?> getType() {
>, <Line: +                        return type;
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Resolves this entry into a fully defined class redefinition.
>, <Line: +                     *
>, <Line: +                     * @param initializationStrategy     The initialization strategy to use.
>, <Line: +                     * @param initialized                The initialize binary locator to use.
>, <Line: +                     * @param typeStrategy               The type strategy to use.
>, <Line: +                     * @param byteBuddy                  The Byte Buddy configuration to use.
>, <Line: +                     * @param methodNameTransformer      The method name transformer to use.
>, <Line: +                     * @param bootstrapInjectionStrategy The bootrap injection strategy to use.
>, <Line: +                     * @param accessControlContext       The access control context to use.
>, <Line: +                     * @param listener                   The listener to report to.
>, <Line: +                     * @return An appropriate class definition.
>, <Line: +                     */
>, <Line: +                    protected ClassDefinition resolve(InitializationStrategy initializationStrategy,
>, <Line: +                                                      BinaryLocator.Initialized initialized,
>, <Line: +                                                      TypeStrategy typeStrategy,
>, <Line: +                                                      ByteBuddy byteBuddy,
>, <Line: +                                                      MethodRebaseResolver.MethodNameTransformer methodNameTransformer,
>, <Line: +                                                      Default.BootstrapInjectionStrategy bootstrapInjectionStrategy,
>, <Line: +                                                      AccessControlContext accessControlContext,
>, <Line: +                                                      Listener listener) {
>, <Line: +                        return new ClassDefinition(type, resolution.apply(initializationStrategy,
>, <Line: +                                initialized,
>, <Line: +                                typeStrategy,
>, <Line: +                                byteBuddy,
>, <Line: +                                methodNameTransformer,
>, <Line: +                                bootstrapInjectionStrategy,
>, <Line: +                                accessControlContext,
>, <Line: +                                listener));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        if (this == other) return true;
>, <Line: +                        if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                        Entry entry = (Entry) other;
>, <Line: +                        return type.equals(entry.type) && resolution.equals(entry.resolution);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = type.hashCode();
>, <Line: +                        result = 31 * result + resolution.hashCode();
>, <Line: +                        return result;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.Entry{" +
>, <Line: +                                "type=" + type +
>, <Line: +                                ", resolution=" + resolution +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A collector that applies a <b>retransformation</b> of already loaded classes.
>, <Line: +             */
>, <Line: +            class ForRetransformation implements Collector {
>, <Line: +                /**
>, <Line: +                 * The transformation defined by the built agent.
>, <Line: +                 */
>, <Line: +                private final Default.Transformation transformation;
>, <Line: +                /**
>, <Line: +                 * The types that were collected for retransformation.
>, <Line: +                 */
>, <Line: +                private final List<Class<?>> types;
>, <Line: +                /**
>, <Line: +                 * Creates a new collector for a retransformation.
>, <Line: +                 *
>, <Line: +                 * @param transformation The transformation defined by the built agent.
>, <Line: +                 */
>, <Line: +                protected ForRetransformation(Default.Transformation transformation) {
>, <Line: +                    this.transformation = transformation;
>, <Line: +                    types = new LinkedList<Class<?>>();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void consider(Class<?> type) {
>, <Line: +                    if (transformation.resolve(new TypeDescription.ForLoadedType(type), type.getClassLoader(), type, type.getProtectionDomain()).isResolved()) {
>, <Line: +                        types.add(type);
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public void apply(Instrumentation instrumentation,
>, <Line: +                                  ByteBuddy byteBuddy,
>, <Line: +                                  BinaryLocator binaryLocator,
>, <Line: +                                  TypeStrategy typeStrategy,
>, <Line: +                                  Listener listener,
>, <Line: +                                  Default.NativeMethodStrategy nativeMethodStrategy,
>, <Line: +                                  AccessControlContext accessControlContext,
>, <Line: +                                  InitializationStrategy initializationStrategy,
>, <Line: +                                  Default.BootstrapInjectionStrategy bootstrapInjectionStrategy) throws UnmodifiableClassException {
>, <Line: +                    if (!types.isEmpty()) {
>, <Line: +                        instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "AgentBuilder.RedefinitionStrategy.Collector.ForRetransformation{" +
>, <Line: +                            "transformation=" + transformation +
>, <Line: +                            ", types=" + types +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +    }
>, <Line: +         * The redefinition strategy to apply.
>, <Line: +        private final RedefinitionStrategy redefinitionStrategy;
>, <Line: +                    RedefinitionStrategy.DISABLED,
>, <Line: +         * @param redefinitionStrategy       The redefinition strategy to apply.
>, <Line: +                          RedefinitionStrategy redefinitionStrategy,
>, <Line: +            this.redefinitionStrategy = redefinitionStrategy;
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +        public AgentBuilder withRedefinitionStrategy(RedefinitionStrategy redefinitionStrategy) {
>, <Line: +                    nonNull(redefinitionStrategy),
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +                    redefinitionStrategy,
>, <Line: +            instrumentation.addTransformer(classFileTransformer, redefinitionStrategy.isRetransforming(instrumentation));
>, <Line: +            if (redefinitionStrategy.isEnabled()) {
>, <Line: +                RedefinitionStrategy.Collector collector = redefinitionStrategy.makeCollector(transformation);
>, <Line: +                    if (instrumentation.isModifiableClass(type)) {
>, <Line: +                        collector.consider(type);
>, <Line: +                try {
>, <Line: +                    collector.apply(instrumentation,
>, <Line: +                            byteBuddy,
>, <Line: +                            binaryLocator,
>, <Line: +                            typeStrategy,
>, <Line: +                            listener,
>, <Line: +                            nativeMethodStrategy,
>, <Line: +                            accessControlContext,
>, <Line: +                            initializationStrategy,
>, <Line: +                            bootstrapInjectionStrategy);
>, <Line: +                } catch (UnmodifiableClassException exception) {
>, <Line: +                    throw new IllegalStateException("Cannot modify at least one class: " + collector, exception);
>, <Line: +                } catch (ClassNotFoundException exception) {
>, <Line: +                    throw new IllegalStateException("Cannot find at least one class class: " + collector, exception);
>, <Line: +                    && redefinitionStrategy == aDefault.redefinitionStrategy
>, <Line: +            result = 31 * result + redefinitionStrategy.hashCode();
>, <Line: +                    ", typeStrategy=" + typeStrategy +
>, <Line: +                    ", redefinitionStrategy=" + redefinitionStrategy +
>, <Line: +                    BinaryLocator.Initialized initialized = binaryLocator.initialize(classLoader, binaryTypeName, binaryRepresentation);
>, <Line: +                    try {
>, <Line: +                        TypeDescription typeDescription = initialized.getTypePool().describe(binaryTypeName).resolve();
>, <Line: +                        return transformation.resolve(typeDescription, classLoader, classBeingRedefined, protectionDomain).apply(initializationStrategy,
>, <Line: +                                initialized,
>, <Line: +                                typeStrategy,
>, <Line: +                                byteBuddy,
>, <Line: +                                nativeMethodStrategy.resolve(),
>, <Line: +                                bootstrapInjectionStrategy,
>, <Line: +                                accessControlContext,
>, <Line: +                                listener);
>, <Line: +                    } catch (Throwable throwable) {
>, <Line: +                        listener.onError(binaryTypeName, throwable);
>, <Line: +                        return NO_TRANSFORMATION;
>, <Line: +                    } finally {
>, <Line: +                        initialized.getTypePool().clear();
>, <Line: +                    }
>, <Line: +                        ", typeStrategy=" + typeStrategy +
>, <Line: +            public AgentBuilder withRedefinitionStrategy(RedefinitionStrategy redefinitionStrategy) {
>, <Line: +                return materialize().withRedefinitionStrategy(redefinitionStrategy);
>, <Line: +                        redefinitionStrategy,
>]
[<Line: -     * Enables retransformation when this agent is installed. Note that retransformation does not currently allow
>, <Line: -     * for adding or removing fields or methods on the HotSpot Virtual machine.
>, <Line: -     * @return A new instance of this agent builder which allows for retransformation.
>, <Line: -    AgentBuilder allowRetransformation();
>, <Line: -         * @param typeName             The binary name of the type that is being instrumented.
>, <Line: -         * @param binaryRepresentation The binary representation of the instrumented type.
>, <Line: -        Initialized initialize(String typeName, byte[] binaryRepresentation, ClassLoader classLoader);
>, <Line: -            public BinaryLocator.Initialized initialize(String typeName, byte[] binaryRepresentation, ClassLoader classLoader) {
>, <Line: -                return Initialized.of(typeName,
>, <Line: -            protected static class Initialized implements BinaryLocator.Initialized, ClassFileLocator {
>, <Line: -                public static BinaryLocator.Initialized of(String typeName,
>, <Line: -                                                           byte[] binaryRepresentation,
>, <Line: -                                                           TypePool.CacheProvider cacheProvider,
>, <Line: -                                                           ClassFileLocator classFileLocator,
>, <Line: -                                                           TypePool.Default.ReaderMode readerMode) {
>, <Line: -                    return new Initialized(typeName,
>, <Line: -                protected Initialized(String typeName,
>, <Line: -                                      byte[] binaryRepresentation,
>, <Line: -                                      TypePool typePool,
>, <Line: -                                      ClassFileLocator classFileLocator) {
>, <Line: -                    Initialized that = (Initialized) other;
>, <Line: -                    return "AgentBuilder.BinaryLocator.Default.Initialized{" +
>, <Line: -        /**
>, <Line: -         * A {@link net.bytebuddy.agent.builder.AgentBuilder.BinaryLocator} in initialized state.
>, <Line: -         */
>, <Line: -        interface Initialized {
>, <Line: -            /**
>, <Line: -             * Returns the type pool to be used of an {@link net.bytebuddy.agent.builder.AgentBuilder}.
>, <Line: -             *
>, <Line: -             * @return The type pool to use.
>, <Line: -             */
>, <Line: -            TypePool getTypePool();
>, <Line: -            /**
>, <Line: -             * Returns the class file locator to be used of an {@link net.bytebuddy.agent.builder.AgentBuilder}.
>, <Line: -             *
>, <Line: -             * @return The class file locator to use.
>, <Line: -             */
>, <Line: -            ClassFileLocator getClassFileLocator();
>, <Line: -        }
>, <Line: -         * {@code true} if the generated {@link java.lang.instrument.ClassFileTransformer} should also apply for
>, <Line: -         * retransformations..
>, <Line: -        private final boolean retransformation;
>, <Line: -                    false,
>, <Line: -         * @param retransformation           {@code true} if the generated
>, <Line: -         *                                   {@link java.lang.instrument.ClassFileTransformer} should also apply
>, <Line: -         *                                   for retransformations.
>, <Line: -                          boolean retransformation,
>, <Line: -            this.retransformation = retransformation;
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -        public AgentBuilder allowRetransformation() {
>, <Line: -                    true,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -                    retransformation,
>, <Line: -            instrumentation.addTransformer(classFileTransformer, retransformation);
>, <Line: -            if (retransformation) { // If retransformation was unsupported the above transformer registration had thrown an exception.
>, <Line: -                List<Class<?>> retransformedTypes = new LinkedList<Class<?>>();
>, <Line: -                    // The list of all loaded types can be significant what can crash the JVM such that this preselection becomes necessary.
>, <Line: -                    if (instrumentation.isModifiableClass(type) && transformation.resolve(new TypeDescription.ForLoadedType(type), type.getClassLoader(),
>, <Line: -                            type, type.getProtectionDomain()).isResolved()) {
>, <Line: -                        retransformedTypes.add(type);
>, <Line: -                if (!retransformedTypes.isEmpty()) {
>, <Line: -                    try {
>, <Line: -                        instrumentation.retransformClasses(retransformedTypes.toArray(new Class<?>[retransformedTypes.size()]));
>, <Line: -                    } catch (UnmodifiableClassException exception) {
>, <Line: -                        throw new IllegalStateException("Cannot modify classes: " + retransformedTypes, exception);
>, <Line: -                    }
>, <Line: -                    && retransformation == aDefault.retransformation
>, <Line: -            result = 31 * result + (retransformation ? 1 : 0);
>, <Line: -                    ", definitionHandler=" + typeStrategy +
>, <Line: -                    ", retransformation=" + retransformation +
>, <Line: -                    BinaryLocator.Initialized initialized = binaryLocator.initialize(binaryTypeName, binaryRepresentation, classLoader);
>, <Line: -                    TypeDescription typeDescription = initialized.getTypePool().describe(binaryTypeName).resolve();
>, <Line: -                    return transformation.resolve(typeDescription, classLoader, classBeingRedefined, protectionDomain).apply(initializationStrategy,
>, <Line: -                            initialized,
>, <Line: -                            typeStrategy,
>, <Line: -                            byteBuddy,
>, <Line: -                            nativeMethodStrategy.resolve(),
>, <Line: -                            bootstrapInjectionStrategy,
>, <Line: -                            accessControlContext,
>, <Line: -                            listener);
>, <Line: -                } catch (Throwable throwable) {
>, <Line: -                    listener.onError(binaryTypeName, throwable);
>, <Line: -                    return NO_TRANSFORMATION;
>, <Line: -                        ", definitionHandler=" + typeStrategy +
>, <Line: -            public AgentBuilder allowRetransformation() {
>, <Line: -                return materialize().allowRetransformation();
>, <Line: -                        retransformation,
>]