[<Line: +        /**
>, <Line: +         * Indicates if this description strategy makes use of loaded type information and yields a different type description if no loaded type is available.
>, <Line: +         *
>, <Line: +         * @return {@code true} if this description strategy prefers loaded type information when describing a type and only uses a type pool
>, <Line: +         * if loaded type information is not available.
>, <Line: +         */
>, <Line: +        boolean isLoadedFirst();
>, <Line: +            @Override
>, <Line: +            public boolean isLoadedFirst() {
>, <Line: +                return loadedFirst;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean isLoadedFirst() {
>, <Line: +                return delegate.isLoadedFirst();
>, <Line: +            }
>, <Line: +             * <p>
>, <Line: +             * <b>Important</b>: This strategy can dead-lock under two circumstances:
>, <Line: +             * <ul>
>, <Line: +             * <li>
>, <Line: +             * <b>Classes declare circularities</b>: Under normal circumstances, such scenarios result in a {@link ClassCircularityError} but
>, <Line: +             * can result in dead-locks when using this instrumentation strategy.
>, <Line: +             * </li>
>, <Line: +             * <li>
>, <Line: +             * <b>Class loaders declare custom locks</b>: If a class loader locks another lock but itself during class loading, this lock cannot
>, <Line: +             * be released by this strategy.
>, <Line: +             * </li>
>, <Line: +             * </ul>
>, <Line: +             * For these reasons, it is not recommended to use this strategy when the target class loader is unknown or if the target application
>, <Line: +             * might contain corrupt class files.
>, <Line: +             * </p>
>, <Line: +                 * @param timeout
>, <Line: +                @Override
>, <Line: +                public boolean isLoadedFirst() {
>, <Line: +                    return delegate.isLoadedFirst();
>, <Line: +                }
>]
[<Line: -        /**
>, <Line: -         * Indicates if this description strategy makes use of loaded type information and yields a different type description if no loaded type is available.
>, <Line: -         *
>, <Line: -         * @return {@code true} if this description strategy prefers loaded type information when describing a type and only uses a type pool
>, <Line: -         * if loaded type information is not available.
>, <Line: -         */
>, <Line: -        boolean isLoadedFirst();
>, <Line: -            @Override
>, <Line: -            public boolean isLoadedFirst() {
>, <Line: -                return loadedFirst;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isLoadedFirst() {
>, <Line: -                return delegate.isLoadedFirst();
>, <Line: -            }
>, <Line: -                @Override
>, <Line: -                public boolean isLoadedFirst() {
>, <Line: -                    return delegate.isLoadedFirst();
>, <Line: -                }
>]