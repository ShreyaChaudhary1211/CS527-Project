[<Line: +                        : new LazyProjection.WithLazyNavigation.Detached(superClass, Generic.Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +                return new TypeList.Generic.ForDetachedTypes.WithLazyResolution(asErasure().getInterfaces(), Generic.Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +                        : new LazyProjection.WithLazyNavigation.Detached(superClass, Generic.Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: +                return new TypeList.Generic.ForDetachedTypes.WithLazyResolution(asErasure().getInterfaces(), Generic.Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: +                /**
>, <Line: +                 * A type description of a generic type that requires attachment unless when reading the erasure of the type description.
>, <Line: +                 * This is only applicable when the represented type is a super type of another type where it is impossible that the
>, <Line: +                 * represented type is a type variable.
>, <Line: +                 */
>, <Line: +                public static class Detached extends WithLazyNavigation {
>, <Line: +                    /**
>, <Line: +                     * The underlying type description.
>, <Line: +                     */
>, <Line: +                    private final Generic delegate;
>, <Line: +                    /**
>, <Line: +                     * The visitor to apply before resolution.
>, <Line: +                     */
>, <Line: +                    private final Visitor<? extends Generic> visitor;
>, <Line: +                    /**
>, <Line: +                     * Creates a new detached generic type description with lazy navigation.
>, <Line: +                     *
>, <Line: +                     * @param delegate The underlying type description.
>, <Line: +                     * @param visitor  The visitor to apply before resolution.
>, <Line: +                     */
>, <Line: +                    public Detached(Generic delegate, Visitor<? extends Generic> visitor) {
>, <Line: +                        this.delegate = delegate;
>, <Line: +                        this.visitor = visitor;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationList getDeclaredAnnotations() {
>, <Line: +                        return delegate.getDeclaredAnnotations();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public TypeDescription asErasure() {
>, <Line: +                        return delegate.asErasure();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    protected Generic resolve() {
>, <Line: +                        return delegate.accept(visitor);
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                protected static class LazySuperClass extends WithLazyNavigation {
>, <Line: +                protected static class LazyInterfaceType extends WithLazyNavigation {
>]
[<Line: -                        : superClass.accept(Generic.Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -                return new TypeList.Generic.ForDetachedTypes(asErasure().getInterfaces(), Generic.Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -                        : superClass.accept(Generic.Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: -                return new TypeList.Generic.ForDetachedTypes(asErasure().getInterfaces(), Generic.Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: -                protected static class LazySuperClass extends LazyProjection.WithLazyNavigation {
>, <Line: -                protected static class LazyInterfaceType extends LazyProjection.WithLazyNavigation {
>]