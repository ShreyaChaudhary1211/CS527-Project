[<Line: +                return new ForNonGenericType(typeDescription.asErasure());
>, <Line: +    /**
>, <Line: +     * <p>
>, <Line: +     * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
>, <Line: +     * representing a minimal erasure compared to Java's full erasure. This means that generic types are preserved as long as they
>, <Line: +     * do not involve a type variable. Nested type variables are erased on the deepest possible level.
>, <Line: +     * </p>
>, <Line: +     * <p>
>, <Line: +     * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
>, <Line: +     * </p>
>, <Line: +     */
>, <Line: +    class ForNonGenericType implements GenericTypeDescription {
>, <Line: +        /**
>, <Line: +         * The represented non-generic type.
>, <Line: +         */
>, <Line: +        private final TypeDescription typeDescription;
>, <Line: +        /**
>, <Line: +         * Creates a new raw type representation.
>, <Line: +         *
>, <Line: +         * @param typeDescription The represented non-generic type.
>, <Line: +         */
>, <Line: +        public ForNonGenericType(TypeDescription typeDescription) {
>, <Line: +            this.typeDescription = typeDescription;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeDescription getSuperType() {
>, <Line: +            return LazyProjection.OfTransformedType.of(typeDescription.getSuperType(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeList getInterfaces() {
>, <Line: +            return new GenericTypeList.OfTransformedTypes(typeDescription.getInterfaces(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public FieldList getDeclaredFields() {
>, <Line: +            return new FieldList.TypeSubstituting(this, typeDescription.getDeclaredFields(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public MethodList getDeclaredMethods() {
>, <Line: +            return new MethodList.TypeSubstituting(this, typeDescription.getDeclaredMethods(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeDescription getOwnerType() {
>, <Line: +            TypeDescription ownerType = typeDescription.getOwnerType();
>, <Line: +            return ownerType == null
>, <Line: +                    ? TypeDescription.UNDEFINED
>, <Line: +                    : new ForNonGenericType(ownerType);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public TypeDescription asErasure() {
>, <Line: +            return typeDescription;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public Sort getSort() {
>, <Line: +            return Sort.NON_GENERIC;
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeList getParameters() {
>, <Line: +            return typeDescription.getParameters();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public <T> T accept(Visitor<T> visitor) {
>, <Line: +            return visitor.onNonGenericType(this);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public String getTypeName() {
>, <Line: +            return typeDescription.getTypeName();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeList getUpperBounds() {
>, <Line: +            return typeDescription.getUpperBounds();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeList getLowerBounds() {
>, <Line: +            return typeDescription.getLowerBounds();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public GenericTypeDescription getComponentType() {
>, <Line: +            TypeDescription componentType = typeDescription.getComponentType();
>, <Line: +            return componentType == null
>, <Line: +                    ? TypeDescription.UNDEFINED
>, <Line: +                    : new ForNonGenericType(componentType);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public TypeVariableSource getVariableSource() {
>, <Line: +            return typeDescription.getVariableSource();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public String getSymbol() {
>, <Line: +            return typeDescription.getSymbol();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public StackSize getStackSize() {
>, <Line: +            return typeDescription.getStackSize();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public String getSourceCodeName() {
>, <Line: +            return typeDescription.getSourceCodeName();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public boolean isArray() {
>, <Line: +            return typeDescription.isArray();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public boolean isPrimitive() {
>, <Line: +            return typeDescription.isPrimitive();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public boolean represents(Type type) {
>, <Line: +            return typeDescription.represents(type);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public Iterator<GenericTypeDescription> iterator() {
>, <Line: +            return new SuperTypeIterator(this);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public int hashCode() {
>, <Line: +            return typeDescription.hashCode();
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
>, <Line: +        public boolean equals(Object other) {
>, <Line: +            return typeDescription.equals(other);
>, <Line: +        }
>, <Line: +        @Override
>, <Line: +        public String toString() {
>, <Line: +            return typeDescription.toString();
>, <Line: +        }
>, <Line: +    }
>, <Line: +            return LazyProjection.OfTransformedType.of(asErasure().getSuperType(), Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: +            return new GenericTypeList.OfTransformedTypes(asErasure().getInterfaces(), Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: +         * A lazy projection of an untransformed type.
>, <Line: +        public static class OfTransformedType extends LazyProjection {
>, <Line: +             * The represented type in its untransformed form.
>, <Line: +            private final GenericTypeDescription untransformedType;
>, <Line: +             * The transformer to apply to the untransformed type.
>, <Line: +             * Creates a new lazy projection of a type that is being transformed.
>, <Line: +             * @param untransformedType The represented type in its untransformed form.
>, <Line: +             * @param transformer       The transformer to apply to the untransformed type.
>, <Line: +            public OfTransformedType(GenericTypeDescription untransformedType, Visitor<? extends GenericTypeDescription> transformer) {
>, <Line: +                this.untransformedType = untransformedType;
>, <Line: +                        : new OfTransformedType(unresolvedType, transformer);
>, <Line: +                return untransformedType.accept(transformer);
>, <Line: +                return untransformedType.asErasure();
>]
[<Line: -                return new ForParameterizedType.Raw(typeDescription.asErasure());
>, <Line: -            return LazyProjection.OfPotentiallyRawType.of(asErasure().getSuperType(), Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: -            return new GenericTypeList.OfPotentiallyRawType(asErasure().getInterfaces(), Visitor.Substitutor.ForTypeVariableBinding.bind(this));
>, <Line: -        /**
>, <Line: -         * <p>
>, <Line: -         * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
>, <Line: -         * representing a minimal erasure compared to Java's full erasure. This means that generic types are preserved as long as they
>, <Line: -         * do not involve a type variable. Nested type variables are erased on the deepest possible level.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
>, <Line: -         * </p>
>, <Line: -         */
>, <Line: -        public static class Raw implements GenericTypeDescription {
>, <Line: -            /**
>, <Line: -             * The represented non-generic type.
>, <Line: -             */
>, <Line: -            private final TypeDescription typeDescription;
>, <Line: -            /**
>, <Line: -             * Creates a new raw type representation.
>, <Line: -             *
>, <Line: -             * @param typeDescription The represented non-generic type.
>, <Line: -             */
>, <Line: -            protected Raw(TypeDescription typeDescription) {
>, <Line: -                this.typeDescription = typeDescription;
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Resolves a generic type to a potentially raw type. A raw type is returned if the given type declares a different number of type variables
>, <Line: -             * than parameters.
>, <Line: -             *
>, <Line: -             * @param typeDescription The type to resolve as a potentially raw type. Only non-generic types
>, <Line: -             *                        ({@link net.bytebuddy.description.type.generic.GenericTypeDescription.Sort#NON_GENERIC}) and parameterized types
>, <Line: -             *                        ({@link net.bytebuddy.description.type.generic.GenericTypeDescription.Sort#PARAMETERIZED}) are well-defined input.
>, <Line: -             * @param transformer     A transformer to apply to a non-raw types.
>, <Line: -             * @return Either a raw type, or a transformed generic type.
>, <Line: -             */
>, <Line: -            public static GenericTypeDescription check(GenericTypeDescription typeDescription, Visitor<? extends GenericTypeDescription> transformer) {
>, <Line: -                return typeDescription.getParameters().size() != typeDescription.asErasure().getTypeVariables().size()
>, <Line: -                        ? new Raw(typeDescription.asErasure())
>, <Line: -                        : typeDescription.accept(transformer);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeDescription getSuperType() {
>, <Line: -                GenericTypeDescription superType = typeDescription.getSuperType();
>, <Line: -                return superType == null
>, <Line: -                        ? TypeDescription.UNDEFINED
>, <Line: -                        : superType.accept(Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeList getInterfaces() {
>, <Line: -                return typeDescription.getInterfaces().accept(Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public FieldList getDeclaredFields() {
>, <Line: -                return new FieldList.TypeSubstituting(this, typeDescription.getDeclaredFields(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public MethodList getDeclaredMethods() {
>, <Line: -                return new MethodList.TypeSubstituting(this, typeDescription.getDeclaredMethods(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeDescription getOwnerType() {
>, <Line: -                TypeDescription ownerType = typeDescription.getOwnerType();
>, <Line: -                return ownerType == null
>, <Line: -                        ? TypeDescription.UNDEFINED
>, <Line: -                        : new Raw(ownerType);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeDescription asErasure() {
>, <Line: -                return typeDescription;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Sort getSort() {
>, <Line: -                return typeDescription.getSort();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeList getParameters() {
>, <Line: -                return typeDescription.getParameters();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public <T> T accept(Visitor<T> visitor) {
>, <Line: -                return visitor.onNonGenericType(this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getTypeName() {
>, <Line: -                return typeDescription.getTypeName();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeList getUpperBounds() {
>, <Line: -                return typeDescription.getUpperBounds();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeList getLowerBounds() {
>, <Line: -                return typeDescription.getLowerBounds();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public GenericTypeDescription getComponentType() {
>, <Line: -                TypeDescription componentType = typeDescription.getComponentType();
>, <Line: -                return componentType == null
>, <Line: -                        ? TypeDescription.UNDEFINED
>, <Line: -                        : new Raw(componentType);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeVariableSource getVariableSource() {
>, <Line: -                return typeDescription.getVariableSource();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getSymbol() {
>, <Line: -                return typeDescription.getSymbol();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public StackSize getStackSize() {
>, <Line: -                return typeDescription.getStackSize();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getSourceCodeName() {
>, <Line: -                return typeDescription.getSourceCodeName();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isArray() {
>, <Line: -                return typeDescription.isArray();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isPrimitive() {
>, <Line: -                return typeDescription.isPrimitive();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean represents(Type type) {
>, <Line: -                return typeDescription.represents(type);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Iterator<GenericTypeDescription> iterator() {
>, <Line: -                return new SuperTypeIterator(this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                return typeDescription.hashCode();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                return typeDescription.equals(other);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return typeDescription.toString();
>, <Line: -            }
>, <Line: -        }
>, <Line: -         * A lazy projection of potentially raw types.
>, <Line: -        public static class OfPotentiallyRawType extends LazyProjection {
>, <Line: -             * The unresolved type to resolve.
>, <Line: -            private final GenericTypeDescription unresolvedType;
>, <Line: -             * The transformer to apply to non-raw types.
>, <Line: -             * Creates a new lazy projection of a potentially raw type.
>, <Line: -             * @param unresolvedType The unresolved type to resolve.
>, <Line: -             * @param transformer    The transformer to apply to non-raw types.
>, <Line: -            public OfPotentiallyRawType(GenericTypeDescription unresolvedType, Visitor<? extends GenericTypeDescription> transformer) {
>, <Line: -                this.unresolvedType = unresolvedType;
>, <Line: -                        : new OfPotentiallyRawType(unresolvedType, transformer);
>, <Line: -                return GenericTypeDescription.ForParameterizedType.Raw.check(unresolvedType, transformer);
>, <Line: -                return unresolvedType.asErasure();
>]