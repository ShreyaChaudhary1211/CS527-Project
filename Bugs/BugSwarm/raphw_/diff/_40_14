[<Line: +package net.bytebuddy.implementation.bytecode.constant;
>, <Line: +import net.bytebuddy.description.method.MethodDescription;
>, <Line: +import net.bytebuddy.description.type.TypeDescription;
>, <Line: +import net.bytebuddy.implementation.Implementation;
>, <Line: +import net.bytebuddy.implementation.bytecode.Duplication;
>, <Line: +import net.bytebuddy.implementation.bytecode.StackManipulation;
>, <Line: +import net.bytebuddy.implementation.bytecode.TypeCreation;
>, <Line: +import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
>, <Line: +import org.objectweb.asm.MethodVisitor;
>, <Line: +import java.io.*;
>, <Line: +/**
>, <Line: + * A constant that represents a value in its serialized form.
>, <Line: + */
>, <Line: +public class SerializedConstant implements StackManipulation {
>, <Line: +    /**
>, <Line: +     * A charset that does not change the supplied byte array upon encoding or decoding.
>, <Line: +     */
>, <Line: +    private static final String CHARSET = "ISO-8859-1";
>, <Line: +    /**
>, <Line: +     * The serialized value.
>, <Line: +     */
>, <Line: +    private final String serialization;
>, <Line: +    /**
>, <Line: +     * Creates a new constant for a serialized value.
>, <Line: +     *
>, <Line: +     * @param serialization The serialized value.
>, <Line: +     */
>, <Line: +    protected SerializedConstant(String serialization) {
>, <Line: +        this.serialization = serialization;
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Creates a new stack manipulation to load the supplied value onto the stack.
>, <Line: +     *
>, <Line: +     * @param value The value to serialize.
>, <Line: +     * @return A stack manipulation to serialize the supplied value.
>, <Line: +     */
>, <Line: +    public static StackManipulation of(Serializable value) {
>, <Line: +        if (value == null) {
>, <Line: +            return NullConstant.INSTANCE;
>, <Line: +        }
>, <Line: +        try {
>, <Line: +            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
>, <Line: +            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
>, <Line: +            try {
>, <Line: +                objectOutputStream.writeObject(value);
>, <Line: +            } finally {
>, <Line: +                objectOutputStream.close();
>, <Line: +            }
>, <Line: +            return new SerializedConstant(byteArrayOutputStream.toString(CHARSET));
>, <Line: +        } catch (IOException exception) {
>, <Line: +            throw new IllegalStateException("Cannot serialize " + value, exception);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean isValid() {
>, <Line: +        return true;
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
>, <Line: +        try {
>, <Line: +            return new StackManipulation.Compound(
>, <Line: +                    TypeCreation.of(new TypeDescription.ForLoadedType(ObjectInputStream.class)),
>, <Line: +                    Duplication.SINGLE,
>, <Line: +                    TypeCreation.of(new TypeDescription.ForLoadedType(ByteArrayInputStream.class)),
>, <Line: +                    Duplication.SINGLE,
>, <Line: +                    new TextConstant(serialization),
>, <Line: +                    new TextConstant(CHARSET),
>, <Line: +                    MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(String.class.getMethod("getBytes", String.class))),
>, <Line: +                    MethodInvocation.invoke(new MethodDescription.ForLoadedConstructor(ByteArrayInputStream.class.getConstructor(byte[].class))),
>, <Line: +                    MethodInvocation.invoke(new MethodDescription.ForLoadedConstructor(ObjectInputStream.class.getConstructor(InputStream.class))),
>, <Line: +                    MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(ObjectInputStream.class.getMethod("readObject")))
>, <Line: +            ).apply(methodVisitor, implementationContext);
>, <Line: +        } catch (NoSuchMethodException exception) {
>, <Line: +            throw new IllegalStateException("Could not locate Java API method", exception);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public boolean equals(Object object) {
>, <Line: +        if (this == object) return true;
>, <Line: +        if (object == null || getClass() != object.getClass()) return false;
>, <Line: +        SerializedConstant that = (SerializedConstant) object;
>, <Line: +        return serialization.equals(that.serialization);
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public int hashCode() {
>, <Line: +        return serialization.hashCode();
>, <Line: +    }
>, <Line: +    @Override
>, <Line: +    public String toString() {
>, <Line: +        return "SerializedConstant{" +
>, <Line: +                "serialization='" + serialization + '\'' +
>, <Line: +                '}';
>, <Line: +    }
>, <Line: +}
>]
[]