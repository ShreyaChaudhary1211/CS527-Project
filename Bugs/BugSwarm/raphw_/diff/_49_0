[<Line: +import java.lang.reflect.Field;
>, <Line: +        private static final Dispatcher.Initializable DISPATCHER = Dispatcher.Resolved.make();
>, <Line: +         * @param classLoader The {@link java.lang.ClassLoader} into which new class definitions are to be injected. Must not be the bootstrap loader.
>, <Line: +         * @param classLoader      The {@link java.lang.ClassLoader} into which new class definitions are to be injected. Must not be the bootstrap loader.
>, <Line: +                        type = dispatcher.defineClass(classLoader, typeName, entry.getValue(), protectionDomain);
>, <Line: +            Class<?> defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, ProtectionDomain protectionDomain);
>, <Line: +             * @param name                  The binary name of the package.
>, <Line: +                                  String name,
>, <Line: +                 * Indicates an reflective access on a static member.
>, <Line: +                 */
>, <Line: +                private static final Object STATIC_MEMBER = null;
>, <Line: +                /**
>, <Line: +                 * An instance of {@link ClassLoader#findLoadedClass(String)}.
>, <Line: +                 * An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
>, <Line: +                private final Method defineClass;
>, <Line: +                 * An instance of {@link ClassLoader#getPackage(String)}.
>, <Line: +                 * An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
>, <Line: +                /**
>, <Line: +                 * An instance of {@code sun.misc.Unsafe#theUnsafe} or {@code null} if it is not available.
>, <Line: +                 */
>, <Line: +                private final Field theUnsafe;
>, <Line: +                /**
>, <Line: +                 * An instance of {@code sun.misc.Unsafe#defineClass(String, byte[], int, int, ClassLoader, ProtectionDomain)}
>, <Line: +                 * or {@code null} if it is not available.
>, <Line: +                 */
>, <Line: +                private final Method defineClassUnsafe;
>, <Line: +                 * @param findLoadedClass   An instance of {@link ClassLoader#findLoadedClass(String)}.
>, <Line: +                 * @param defineClass       An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
>, <Line: +                 * @param getPackage        An instance of {@link ClassLoader#getPackage(String)}.
>, <Line: +                 * @param definePackage     An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
>, <Line: +                 * @param defineClassUnsafe An instance of {@code sun.misc.Unsafe#theUnsafe} or {@code null} if it is not available.
>, <Line: +                 * @param theUnsafe         An instance of {@code sun.misc.Unsafe#defineClass(String, byte[], int, int, ClassLoader, ProtectionDomain)}
>, <Line: +                 *                          or {@code null} if it is not available.
>, <Line: +                protected Resolved(Method findLoadedClass,
>, <Line: +                                   Method defineClass,
>, <Line: +                                   Method getPackage,
>, <Line: +                                   Method definePackage,
>, <Line: +                                   Field theUnsafe,
>, <Line: +                                   Method defineClassUnsafe) {
>, <Line: +                    this.defineClass = defineClass;
>, <Line: +                    this.theUnsafe = theUnsafe;
>, <Line: +                    this.defineClassUnsafe = defineClassUnsafe;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Obtains the reflective instances used by this injector or a no-op instance that throws the exception
>, <Line: +                 * that occurred when attempting to obtain the reflective member instances.
>, <Line: +                 *
>, <Line: +                 * @return A dispatcher for the current VM.
>, <Line: +                 */
>, <Line: +                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
>, <Line: +                protected static Dispatcher.Initializable make() {
>, <Line: +                    Field theUnsafe;
>, <Line: +                    Method defineClass;
>, <Line: +                    try {
>, <Line: +                        Class<?> unsafe = Class.forName("sun.misc.Unsafe");
>, <Line: +                        theUnsafe = unsafe.getDeclaredField("theUnsafe");
>, <Line: +                        defineClass = unsafe.getDeclaredMethod("defineClass",
>, <Line: +                                String.class,
>, <Line: +                                byte[].class,
>, <Line: +                                int.class,
>, <Line: +                                int.class,
>, <Line: +                                ClassLoader.class,
>, <Line: +                                ProtectionDomain.class);
>, <Line: +                    } catch (Throwable ignored) {
>, <Line: +                        theUnsafe = null;
>, <Line: +                        defineClass = null;
>, <Line: +                    }
>, <Line: +                    try {
>, <Line: +                        return new Dispatcher.Resolved(ClassLoader.class.getDeclaredMethod("findLoadedClass", String.class),
>, <Line: +                                ClassLoader.class.getDeclaredMethod("defineClass",
>, <Line: +                                        String.class,
>, <Line: +                                        byte[].class,
>, <Line: +                                        int.class,
>, <Line: +                                        int.class,
>, <Line: +                                        ProtectionDomain.class),
>, <Line: +                                ClassLoader.class.getDeclaredMethod("getPackage", String.class),
>, <Line: +                                ClassLoader.class.getDeclaredMethod("definePackage",
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        String.class,
>, <Line: +                                        URL.class),
>, <Line: +                                theUnsafe,
>, <Line: +                                defineClass);
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        return new Dispatcher.Faulty(exception);
>, <Line: +                    }
>, <Line: +                public Class<?> defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, ProtectionDomain protectionDomain) {
>, <Line: +                        return (Class<?>) defineClass.invoke(classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);
>, <Line: +                                             String name,
>, <Line: +                                name,
>, <Line: +                @SuppressFBWarnings(value = {"DP_DO_INSIDE_DO_PRIVILEGED", "REC_CATCH_EXCEPTION"}, justification = "Privilege is explicit user responsibility")
>, <Line: +                    try {
>, <Line: +                        // This is safe even in a multi-threaded environment as all threads set the instances accessible before invoking any methods.
>, <Line: +                        // By always setting accessibility, the security manager is always triggered if this operation was illegal.
>, <Line: +                        findLoadedClass.setAccessible(true);
>, <Line: +                        defineClass.setAccessible(true);
>, <Line: +                        getPackage.setAccessible(true);
>, <Line: +                        definePackage.setAccessible(true);
>, <Line: +                        return this;
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        if (theUnsafe == null) {
>, <Line: +                            throw exception;
>, <Line: +                        } else {
>, <Line: +                            try {
>, <Line: +                                // This serves as a fallback on environments where accessible reflection on the class loader methods is not available.
>, <Line: +                                theUnsafe.setAccessible(true);
>, <Line: +                                return new UnsafeDispatcher(theUnsafe.get(STATIC_MEMBER), defineClassUnsafe);
>, <Line: +                            } catch (Exception ignored) {
>, <Line: +                                throw exception;
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                            && defineClass.equals(resolved.defineClass)
>, <Line: +                            && definePackage.equals(resolved.definePackage)
>, <Line: +                            && theUnsafe.equals(resolved.theUnsafe)
>, <Line: +                            && defineClassUnsafe.equals(resolved.defineClassUnsafe);
>, <Line: +                    result = 31 * result + defineClass.hashCode();
>, <Line: +                    result = 31 * result + theUnsafe.hashCode();
>, <Line: +                    result = 31 * result + defineClassUnsafe.hashCode();
>, <Line: +                            ", defineClass=" + defineClass +
>, <Line: +                            ", theUnsafe=" + theUnsafe +
>, <Line: +                            ", defineClassUnsafe=" + defineClassUnsafe +
>, <Line: +                /**
>, <Line: +                 * A dispatcher that uses {@code sun.misc.Unsafe} for class loading but which is incapable of defining packages.
>, <Line: +                 */
>, <Line: +                protected static class UnsafeDispatcher implements Dispatcher {
>, <Line: +                    /**
>, <Line: +                     * Indicates a class that is currently not defined.
>, <Line: +                     */
>, <Line: +                    private static final Class<?> UNDEFINED = null;
>, <Line: +                    /**
>, <Line: +                     * An instance of {@code sun.misc.Unsafe}.
>, <Line: +                     */
>, <Line: +                    private final Object unsafe;
>, <Line: +                    /**
>, <Line: +                     * An instance of {@code sun.misc.Unsafe#defineClass(String, byte[], int, int, ClassLoader, ProtectionDomain)}.
>, <Line: +                     */
>, <Line: +                    private final Method defineClass;
>, <Line: +                    /**
>, <Line: +                     * Creates a new unsafe dispatcher.
>, <Line: +                     *
>, <Line: +                     * @param unsafe      An instance of {@code sun.misc.Unsafe}.
>, <Line: +                     * @param defineClass An instance of {@code sun.misc.Unsafe#defineClass(String, byte[], int, int, ClassLoader, ProtectionDomain)}.
>, <Line: +                     */
>, <Line: +                    protected UnsafeDispatcher(Object unsafe, Method defineClass) {
>, <Line: +                        this.unsafe = unsafe;
>, <Line: +                        this.defineClass = defineClass;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Class<?> findClass(ClassLoader classLoader, String name) {
>, <Line: +                        try {
>, <Line: +                            return classLoader.loadClass(name);
>, <Line: +                        } catch (ClassNotFoundException ignored) {
>, <Line: +                            return UNDEFINED;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Class<?> defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, ProtectionDomain protectionDomain) {
>, <Line: +                        try {
>, <Line: +                            return (Class<?>) defineClass.invoke(unsafe,
>, <Line: +                                    name,
>, <Line: +                                    binaryRepresentation,
>, <Line: +                                    0,
>, <Line: +                                    binaryRepresentation.length,
>, <Line: +                                    classLoader,
>, <Line: +                                    protectionDomain);
>, <Line: +                        } catch (IllegalAccessException exception) {
>, <Line: +                            throw new IllegalStateException("Could not access com.sun.Unsafe#defineClass", exception);
>, <Line: +                        } catch (InvocationTargetException exception) {
>, <Line: +                            throw new IllegalStateException("Error invoking com.sun.Unsafe#defineClass", exception.getCause());
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Package getPackage(ClassLoader classLoader, String name) {
>, <Line: +                        throw new UnsupportedOperationException("Cannot get package using unsafe injection dispatcher: " + name);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Package definePackage(ClassLoader classLoader,
>, <Line: +                                                 String name,
>, <Line: +                                                 String specificationTitle,
>, <Line: +                                                 String specificationVersion,
>, <Line: +                                                 String specificationVendor,
>, <Line: +                                                 String implementationTitle,
>, <Line: +                                                 String implementationVersion,
>, <Line: +                                                 String implementationVendor,
>, <Line: +                                                 URL sealBase) {
>, <Line: +                        throw new UnsupportedOperationException("Cannot define package using unsafe injection dispatcher: " + name);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object object) {
>, <Line: +                        if (this == object) return true;
>, <Line: +                        if (object == null || getClass() != object.getClass()) return false;
>, <Line: +                        UnsafeDispatcher that = (UnsafeDispatcher) object;
>, <Line: +                        return unsafe.equals(that.unsafe) && defineClass.equals(that.defineClass);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = unsafe.hashCode();
>, <Line: +                        result = 31 * result + defineClass.hashCode();
>, <Line: +                        return result;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "ClassInjector.UsingReflection.Dispatcher.Resolved.UnsafeDispatcher{" +
>, <Line: +                                "unsafe=" + unsafe +
>, <Line: +                                ", defineClass=" + defineClass +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                }
>]
[<Line: -        /**
>, <Line: -         * Indicates that an array should be included from the first index position. Improves source code readabilty.
>, <Line: -         */
>, <Line: -        private static final int FROM_BEGINNING = 0;
>, <Line: -        private static final Dispatcher.Initializable DISPATCHER = dispatcher();
>, <Line: -        /**
>, <Line: -         * Obtains the reflective instances used by this injector or a no-op instance that throws the exception
>, <Line: -         * that occurred when attempting to obtain the reflective member instances.
>, <Line: -         *
>, <Line: -         * @return A dispatcher for the current VM.
>, <Line: -         */
>, <Line: -        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
>, <Line: -        private static Dispatcher.Initializable dispatcher() {
>, <Line: -            try {
>, <Line: -                return new Dispatcher.Resolved(ClassLoader.class.getDeclaredMethod("findLoadedClass", String.class),
>, <Line: -                        ClassLoader.class.getDeclaredMethod("defineClass",
>, <Line: -                                String.class,
>, <Line: -                                byte[].class,
>, <Line: -                                int.class,
>, <Line: -                                int.class,
>, <Line: -                                ProtectionDomain.class),
>, <Line: -                        ClassLoader.class.getDeclaredMethod("getPackage", String.class),
>, <Line: -                        ClassLoader.class.getDeclaredMethod("definePackage",
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                String.class,
>, <Line: -                                URL.class));
>, <Line: -            } catch (Exception exception) {
>, <Line: -                return new Dispatcher.Faulty(exception);
>, <Line: -            }
>, <Line: -        }
>, <Line: -         * @param classLoader The {@link java.lang.ClassLoader} into which new class definitions are to be injected.
>, <Line: -         * @param classLoader      The {@link java.lang.ClassLoader} into which new class definitions are to be injected.
>, <Line: -                        byte[] binaryRepresentation = entry.getValue();
>, <Line: -                        type = dispatcher.loadClass(classLoader,
>, <Line: -                                typeName,
>, <Line: -                                binaryRepresentation,
>, <Line: -                                FROM_BEGINNING,
>, <Line: -                                binaryRepresentation.length,
>, <Line: -                                protectionDomain);
>, <Line: -             * @param startIndex           The start index of the provided binary representation.
>, <Line: -             * @param endIndex             The final index of the binary representation.
>, <Line: -            Class<?> loadClass(ClassLoader classLoader,
>, <Line: -                               String name,
>, <Line: -                               byte[] binaryRepresentation,
>, <Line: -                               int startIndex,
>, <Line: -                               int endIndex,
>, <Line: -                               ProtectionDomain protectionDomain);
>, <Line: -             * @param packageName           The binary name of the package.
>, <Line: -                                  String packageName,
>, <Line: -                 * An accessible instance of {@link ClassLoader#findLoadedClass(String)}.
>, <Line: -                 * An accessible instance of {@link ClassLoader#loadClass(String)}.
>, <Line: -                private final Method loadClass;
>, <Line: -                 * An accessible instance of {@link ClassLoader#getPackage(String)}.
>, <Line: -                 * An accessible instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
>, <Line: -                 * @param findLoadedClass An accessible instance of {@link ClassLoader#findLoadedClass(String)}.
>, <Line: -                 * @param loadClass       An accessible instance of {@link ClassLoader#loadClass(String)}.
>, <Line: -                 * @param getPackage      An accessible instance of {@link ClassLoader#getPackage(String)}.
>, <Line: -                 * @param definePackage   An accessible instance of
>, <Line: -                 *                        {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
>, <Line: -                protected Resolved(Method findLoadedClass, Method loadClass, Method getPackage, Method definePackage) {
>, <Line: -                    this.loadClass = loadClass;
>, <Line: -                public Class<?> loadClass(ClassLoader classLoader,
>, <Line: -                                          String name,
>, <Line: -                                          byte[] binaryRepresentation,
>, <Line: -                                          int startIndex,
>, <Line: -                                          int endIndex,
>, <Line: -                                          ProtectionDomain protectionDomain) {
>, <Line: -                        return (Class<?>) loadClass.invoke(classLoader, name, binaryRepresentation, startIndex, endIndex, protectionDomain);
>, <Line: -                                             String packageName,
>, <Line: -                                packageName,
>, <Line: -                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
>, <Line: -                    // This is safe even in a multi-threaded environment as all threads set the instances accessible before invoking any methods.
>, <Line: -                    // By always setting accessability, the security manager is always triggered if this operation was illegal.
>, <Line: -                    findLoadedClass.setAccessible(true);
>, <Line: -                    loadClass.setAccessible(true);
>, <Line: -                    getPackage.setAccessible(true);
>, <Line: -                    definePackage.setAccessible(true);
>, <Line: -                    return this;
>, <Line: -                            && loadClass.equals(resolved.loadClass)
>, <Line: -                            && definePackage.equals(resolved.definePackage);
>, <Line: -                    result = 31 * result + loadClass.hashCode();
>, <Line: -                            ", loadClass=" + loadClass +
>]