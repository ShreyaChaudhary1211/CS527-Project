[<Line: +         * @return The corresponding special method invocation which might be illegal if the requested invocation is not legal.
>, <Line: +        /**
>, <Line: +         * Creates a special method invocation for invoking a default method with the given token. The default method call must
>, <Line: +         * not be ambiguous or an illegal special method invocation is returned.
>, <Line: +         *
>, <Line: +         * @param token A token of the method that is to be invoked as a default method.
>, <Line: +         * @return The corresponding default method invocation which might be illegal if the requested invocation is not legal or ambiguous.
>, <Line: +         */
>, <Line: +        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token);
>, <Line: +        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType);
>, <Line: +            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
>, <Line: +                SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;
>, <Line: +                for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures()) {
>, <Line: +                    SpecialMethodInvocation invocation = invokeDefault(token, interfaceType);
>, <Line: +                    if (invocation.isValid()) {
>, <Line: +                        if (specialMethodInvocation.isValid()) {
>, <Line: +                            return SpecialMethodInvocation.Illegal.INSTANCE;
>, <Line: +                        } else {
>, <Line: +                            specialMethodInvocation = invocation;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                return specialMethodInvocation;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
>, <Line: +                return specialMethodInvocation.isValid()
>, <Line: +                        ? specialMethodInvocation
>, <Line: +                        : invokeDefault(token);
>, <Line: +                throw new IllegalStateException("Registration of field accessor was disabled: " + fieldDescription);
>, <Line: +        class Default extends ExtractableView.AbstractBase {
>]
[<Line: -         * @return The corresponding special method invocation which might be illegal if the requested invocation is
>, <Line: -         * not legal.
>, <Line: -        SpecialMethodInvocation invokeDefault(TypeDescription targetType, MethodDescription.SignatureToken token);
>, <Line: -            public SpecialMethodInvocation invokeDefault(TypeDescription targetType, MethodDescription.SignatureToken token) {
>, <Line: -                if (!specialMethodInvocation.isValid()) {
>, <Line: -                    Iterator<TypeDescription> iterator = instrumentedType.getInterfaces().asErasures().iterator();
>, <Line: -                    while (!specialMethodInvocation.isValid() && iterator.hasNext()) {
>, <Line: -                        specialMethodInvocation = invokeDefault(iterator.next(), token);
>, <Line: -                    }
>, <Line: -                    while (iterator.hasNext()) {
>, <Line: -                        if (invokeDefault(iterator.next(), token).isValid()) {
>, <Line: -                            return SpecialMethodInvocation.Illegal.INSTANCE;
>, <Line: -                        }
>, <Line: -                    }
>, <Line: -                }
>, <Line: -                return specialMethodInvocation;
>, <Line: -                throw new IllegalStateException("Registration of field accessor was disabled: " + fieldDescription); // TODO: Test!
>, <Line: -        class Default extends ExtractableView.AbstractBase implements MethodAccessorFactory {
>]