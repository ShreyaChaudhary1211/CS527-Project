[<Line: +import net.bytebuddy.description.annotation.AnnotatedCodeElement;
>, <Line: +    interface Generic extends TypeDefinition, AnnotatedCodeElement {
>, <Line: +         * Returns the type arguments of this type.
>, <Line: +        TypeList.Generic getTypeArguments();
>, <Line: +                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), genericArray.getDeclaredAnnotations());
>, <Line: +                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard.getDeclaredAnnotations());
>, <Line: +                    List<Generic> typeArguments = new ArrayList<Generic>(parameterizedType.getTypeArguments().size());
>, <Line: +                    for (Generic typeArgument : parameterizedType.getTypeArguments()) {
>, <Line: +                        if (typeArgument.accept(TypeVariableErasing.PartialErasureReviser.INSTANCE)) {
>, <Line: +                        typeArguments.add(typeArgument.accept(this));
>, <Line: +                            typeArguments,
>, <Line: +                            parameterizedType.getDeclaredAnnotations());
>, <Line: +                    return new OfNonGenericType.Latent(typeVariable.asErasure(), typeVariable.getDeclaredAnnotations());
>, <Line: +                    return new OfNonGenericType.Latent(typeDescription.asErasure(), typeDescription.getDeclaredAnnotations());
>, <Line: +                    for (Generic typeArgument : ownableType.getTypeArguments()) {
>, <Line: +                        typeArgument.accept(new OfTypeArgument(signatureVisitor));
>, <Line: +                protected static class OfTypeArgument extends ForSignatureVisitor {
>, <Line: +                    protected OfTypeArgument(SignatureVisitor signatureVisitor) {
>, <Line: +                        TypeList.Generic upperBounds = wildcard.getUpperBounds(), lowerBounds = wildcard.getLowerBounds();
>, <Line: +                        return "TypeDescription.Generic.Visitor.ForSignatureVisitor.OfTypeArgument{}";
>, <Line: +                    List<Generic> typeArguments = new ArrayList<Generic>(parameterizedType.getTypeArguments().size());
>, <Line: +                    for (Generic typeArgument : parameterizedType.getTypeArguments()) {
>, <Line: +                        typeArguments.add(typeArgument.accept(this));
>, <Line: +                            typeArguments,
>, <Line: +                            parameterizedType.getDeclaredAnnotations());
>, <Line: +                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), genericArray.getDeclaredAnnotations());
>, <Line: +                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard.getDeclaredAnnotations());
>, <Line: +                    return typeDescription.isArray()
>, <Line: +                            ? new OfGenericArray.Latent(typeDescription.getComponentType().accept(this), typeDescription.getDeclaredAnnotations())
>, <Line: +                            : onSimpleType(typeDescription);
>, <Line: +                            return new AnnotatedTypeVariable(attachedVariable, typeVariable.getDeclaredAnnotations());
>, <Line: +                    /**
>, <Line: +                     * Wraps a formal type variable to allow for representing type annotations.
>, <Line: +                     */
>, <Line: +                    protected static class AnnotatedTypeVariable extends Generic.OfTypeVariable {
>, <Line: +                        /**
>, <Line: +                         * The represented type variable.
>, <Line: +                         */
>, <Line: +                        private final Generic typeVariable;
>, <Line: +                        /**
>, <Line: +                         * The variable's type annotations.
>, <Line: +                         */
>, <Line: +                        private final List<AnnotationDescription> annotations;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotated type variable.
>, <Line: +                         *
>, <Line: +                         * @param typeVariable The represented type variable.
>, <Line: +                         * @param annotations  The variable's type annotations.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedTypeVariable(Generic typeVariable, List<AnnotationDescription> annotations) {
>, <Line: +                            this.typeVariable = typeVariable;
>, <Line: +                            this.annotations = annotations;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeList.Generic getUpperBounds() {
>, <Line: +                            return typeVariable.getUpperBounds();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public TypeVariableSource getVariableSource() {
>, <Line: +                            return typeVariable.getVariableSource();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String getSymbol() {
>, <Line: +                            return typeVariable.getSymbol();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationList getDeclaredAnnotations() {
>, <Line: +                            return new AnnotationList.Explicit(annotations);
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable.getDeclaredAnnotations());
>, <Line: +                            TypeList.Generic typeArguments = typeDescription.getTypeArguments(), typeVariables = typeDescription.asErasure().getTypeVariables();
>, <Line: +                            if (typeArguments.size() != typeVariables.size()) {
>, <Line: +                                bindings.put(typeVariables.get(index), typeArguments.get(index));
>, <Line: +                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable.getDeclaredAnnotations());
>, <Line: +                                TypeList.Generic fromArguments = this.parameterizedType.getTypeArguments(), toArguments = parameterizedType.getTypeArguments();
>, <Line: +                                if (fromArguments.size() == toArguments.size()) {
>, <Line: +                                    for (int index = 0; index < fromArguments.size(); index++) {
>, <Line: +                                        if (!fromArguments.get(index).accept(ParameterAssigner.INSTANCE).isAssignableFrom(toArguments.get(index))) {
>, <Line: +         * An annotation reader is responsible for lazily evaluting type annotations if this language
>, <Line: +         * feature is available on the current JVM.
>, <Line: +        interface AnnotationReader {
>, <Line: +            /**
>, <Line: +             * The dispatcher to use.
>, <Line: +             */
>, <Line: +            Dispatcher DISPATCHER = Dispatcher.ForModernVm.make();
>, <Line: +            /**
>, <Line: +             * Resolves the underlying {@link AnnotatedElement}.
>, <Line: +             *
>, <Line: +             * @return The underlying annotated element.
>, <Line: +             */
>, <Line: +            AnnotatedElement resolve();
>, <Line: +            /**
>, <Line: +             * Returns the underlying type annotations as a list.
>, <Line: +             *
>, <Line: +             * @return The underlying type annotations as a list.
>, <Line: +             */
>, <Line: +            AnnotationList asList();
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of an represented element's wildcard upper bound.
>, <Line: +             *
>, <Line: +             * @param index The wildcard bound's index.
>, <Line: +             * @return An annotation reader for the underlying annotated upper bound.
>, <Line: +             */
>, <Line: +            AnnotationReader ofWildcardUpperBoundType(int index);
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of an represented element's wildcard lower bound.
>, <Line: +             *
>, <Line: +             * @param index The wildcard bound's index.
>, <Line: +             * @return An annotation reader for the underlying annotated lower bound.
>, <Line: +             */
>, <Line: +            AnnotationReader ofWildcardLowerBoundType(int index);
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of a type variable's bound.
>, <Line: +             *
>, <Line: +             * @param index The bound's index.
>, <Line: +             * @return An annotation reader for the underlying annotated bound.
>, <Line: +             */
>, <Line: +            AnnotationReader ofTypeVariableBoundType(int index);
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of a parameterized type's type argument.
>, <Line: +             *
>, <Line: +             * @param index The bound's index.
>, <Line: +             * @return An annotation reader for the underlying annotated bound..
>, <Line: +             */
>, <Line: +            AnnotationReader ofTypeArgument(int index);
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of a parameterized type's owner type.
>, <Line: +             *
>, <Line: +             * @return An annotation reader for the underlying owner type.
>, <Line: +             */
>, <Line: +            AnnotationReader ofOwnerType();
>, <Line: +            /**
>, <Line: +             * Returns a reader for type annotations of an array's component type.
>, <Line: +             *
>, <Line: +             * @return An annotation reader for the underlying component type.
>, <Line: +             */
>, <Line: +            AnnotationReader ofComponentType();
>, <Line: +            /**
>, <Line: +             * A dispatcher that represents the type annotation API via reflective calls if the language feature is available on the current JVM.
>, <Line: +             */
>, <Line: +            interface Dispatcher {
>, <Line: +                /**
>, <Line: +                 * Resolves a formal type variable's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param typeVariable The type variable to represent.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveTypeVariable(TypeVariable<?> typeVariable);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded type's super class's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param type The type to represent.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveSuperType(Class<?> type);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded type's interface type's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param type  The type to represent.
>, <Line: +                 * @param index The index of the interface.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveInterface(Class<?> type, int index);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded field's type's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param field The field to represent.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolve(Field field);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded method's return type's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param method The method to represent.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveReturnType(Method method);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded executable's type argument type's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param executable The executable to represent.
>, <Line: +                 * @param index      The type argument's index.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveParameterType(AccessibleObject executable, int index);
>, <Line: +                /**
>, <Line: +                 * Resolves a loaded executable's exception type's type annotations.
>, <Line: +                 *
>, <Line: +                 * @param executable The executable to represent.
>, <Line: +                 * @param index      The type argument's index.
>, <Line: +                 * @return A suitable annotation reader.
>, <Line: +                 */
>, <Line: +                AnnotationReader resolveExceptionType(AccessibleObject executable, int index);
>, <Line: +                /**
>, <Line: +                 * A dispatcher for {@link AnnotationReader}s on a legacy VM that does not support type annotations.
>, <Line: +                 */
>, <Line: +                enum ForLegacyVm implements Dispatcher {
>, <Line: +                    /**
>, <Line: +                     * The singleton instance.
>, <Line: +                     */
>, <Line: +                    INSTANCE;
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveTypeVariable(TypeVariable<?> typeVariable) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveSuperType(Class<?> type) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveInterface(Class<?> type, int index) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolve(Field field) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveReturnType(Method method) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveParameterType(AccessibleObject executable, int index) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveExceptionType(AccessibleObject executable, int index) {
>, <Line: +                        return NoOp.INSTANCE;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm." + name();
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                 * A dispatcher for a modern JVM that supports type annotations.
>, <Line: +                class ForModernVm implements Dispatcher {
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.Class#getAnnotatedSuperclass} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedSuperclass;
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.Class#getAnnotatedInterfaces} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedInterfaces;
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.reflect.Field#getAnnotatedType} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedType;
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.reflect.Method#getAnnotatedReturnType} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedReturnType;
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.reflect.Executable#getAnnotatedParameterTypes} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedParameterTypes;
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.reflect.Executable#getAnnotatedExceptionTypes} method.
>, <Line: +                     */
>, <Line: +                    private final Method getAnnotatedExceptionTypes;
>, <Line: +                    /**
>, <Line: +                     * Creates a new dispatcher for a VM that supports type annotations.
>, <Line: +                     *
>, <Line: +                     * @param getAnnotatedSuperclass     The {@code java.lang.Class#getAnnotatedSuperclass} method.
>, <Line: +                     * @param getAnnotatedInterfaces     The {@code java.lang.Class#getAnnotatedInterfaces} method.
>, <Line: +                     * @param getAnnotatedType           The {@code java.lang.reflect.Field#getAnnotatedType} method.
>, <Line: +                     * @param getAnnotatedReturnType     The {@code java.lang.reflect.Method#getAnnotatedReturnType} method.
>, <Line: +                     * @param getAnnotatedParameterTypes The {@code java.lang.reflect.Executable#getAnnotatedParameterTypes} method.
>, <Line: +                     * @param getAnnotatedExceptionTypes The {@code java.lang.reflect.Executable#getAnnotatedExceptionTypes} method.
>, <Line: +                     */
>, <Line: +                    protected ForModernVm(Method getAnnotatedSuperclass,
>, <Line: +                                          Method getAnnotatedInterfaces,
>, <Line: +                                          Method getAnnotatedType,
>, <Line: +                                          Method getAnnotatedReturnType,
>, <Line: +                                          Method getAnnotatedParameterTypes,
>, <Line: +                                          Method getAnnotatedExceptionTypes) {
>, <Line: +                        this.getAnnotatedSuperclass = getAnnotatedSuperclass;
>, <Line: +                        this.getAnnotatedInterfaces = getAnnotatedInterfaces;
>, <Line: +                        this.getAnnotatedType = getAnnotatedType;
>, <Line: +                        this.getAnnotatedReturnType = getAnnotatedReturnType;
>, <Line: +                        this.getAnnotatedParameterTypes = getAnnotatedParameterTypes;
>, <Line: +                        this.getAnnotatedExceptionTypes = getAnnotatedExceptionTypes;
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Creates a new annotation reader dispatcher if this is possible or falls back to a no-op version if the
>, <Line: +                     * current JVM does not support this feature.
>, <Line: +                     *
>, <Line: +                     * @return A suitable dispatcher for the current JVM.
>, <Line: +                     */
>, <Line: +                    protected static Dispatcher make() {
>, <Line: +                        try {
>, <Line: +                            return new Dispatcher.ForModernVm(Class.class.getDeclaredMethod("getAnnotatedSuperclass"),
>, <Line: +                                    Class.class.getDeclaredMethod("getAnnotatedInterfaces"),
>, <Line: +                                    Field.class.getDeclaredMethod("getAnnotatedType"),
>, <Line: +                                    Method.class.getDeclaredMethod("getAnnotatedReturnType"),
>, <Line: +                                    Class.forName("java.lang.reflect.Executable").getDeclaredMethod("getAnnotatedParameterTypes"),
>, <Line: +                                    Class.forName("java.lang.reflect.Executable").getDeclaredMethod("getAnnotatedExceptionTypes"));
>, <Line: +                        } catch (RuntimeException exception) {
>, <Line: +                            throw exception;
>, <Line: +                        } catch (Exception ignored) {
>, <Line: +                            return Dispatcher.ForLegacyVm.INSTANCE;
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveTypeVariable(TypeVariable<?> typeVariable) {
>, <Line: +                        return new AnnotatedTypeVariableType(typeVariable);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveSuperType(Class<?> type) {
>, <Line: +                        return new AnnotatedSuperType(type);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveInterface(Class<?> type, int index) {
>, <Line: +                        return new AnnotatedInterfaceType(type, index);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolve(Field field) {
>, <Line: +                        return new AnnotatedFieldType(field);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveReturnType(Method method) {
>, <Line: +                        return new AnnotatedReturnType(method);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveParameterType(AccessibleObject executable, int index) {
>, <Line: +                        return new AnnotatedParameterizedType(executable, index);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotationReader resolveExceptionType(AccessibleObject executable, int index) {
>, <Line: +                        return new AnnotatedExceptionType(executable, index);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        if (this == other) return true;
>, <Line: +                        if (other == null || getClass() != other.getClass()) return false;
>, <Line: +                        ForModernVm that = (ForModernVm) other;
>, <Line: +                        return getAnnotatedSuperclass.equals(that.getAnnotatedSuperclass)
>, <Line: +                                && getAnnotatedInterfaces.equals(that.getAnnotatedInterfaces)
>, <Line: +                                && getAnnotatedType.equals(that.getAnnotatedType)
>, <Line: +                                && getAnnotatedReturnType.equals(that.getAnnotatedReturnType)
>, <Line: +                                && getAnnotatedParameterTypes.equals(that.getAnnotatedParameterTypes)
>, <Line: +                                && getAnnotatedExceptionTypes.equals(that.getAnnotatedExceptionTypes);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        int result = getAnnotatedSuperclass.hashCode();
>, <Line: +                        result = 31 * result + getAnnotatedInterfaces.hashCode();
>, <Line: +                        result = 31 * result + getAnnotatedType.hashCode();
>, <Line: +                        result = 31 * result + getAnnotatedReturnType.hashCode();
>, <Line: +                        result = 31 * result + getAnnotatedParameterTypes.hashCode();
>, <Line: +                        result = 31 * result + getAnnotatedExceptionTypes.hashCode();
>, <Line: +                        return result;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm{" +
>, <Line: +                                "getAnnotatedSuperclass=" + getAnnotatedSuperclass +
>, <Line: +                                ", getAnnotatedInterfaces=" + getAnnotatedInterfaces +
>, <Line: +                                ", getAnnotatedType=" + getAnnotatedType +
>, <Line: +                                ", getAnnotatedReturnType=" + getAnnotatedReturnType +
>, <Line: +                                ", getAnnotatedParameterTypes=" + getAnnotatedParameterTypes +
>, <Line: +                                ", getAnnotatedExceptionTypes=" + getAnnotatedExceptionTypes +
>, <Line: +                                '}';
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegator for an existing {@code java.lang.reflect.Annotatedelement}.
>, <Line: +                     */
>, <Line: +                    protected static class Resolved extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented annotated element.
>, <Line: +                         */
>, <Line: +                        private final AnnotatedElement annotatedElement;
>, <Line: +                        /**
>, <Line: +                         * Creates a new resolved delegator.
>, <Line: +                         *
>, <Line: +                         * @param annotatedElement The represented annotated element.
>, <Line: +                         */
>, <Line: +                        protected Resolved(AnnotatedElement annotatedElement) {
>, <Line: +                            this.annotatedElement = annotatedElement;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            return annotatedElement;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && annotatedElement.equals(((Resolved) other).annotatedElement);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return annotatedElement.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.Resolved{" +
>, <Line: +                                    ", annotatedElement=" + annotatedElement +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated type variable.
>, <Line: +                     */
>, <Line: +                    protected static class AnnotatedTypeVariableType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented type variable.
>, <Line: +                         */
>, <Line: +                        private final TypeVariable<?> typeVariable;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for the given type variable.
>, <Line: +                         *
>, <Line: +                         * @param typeVariable The represented type variable.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedTypeVariableType(TypeVariable<?> typeVariable) {
>, <Line: +                            this.typeVariable = typeVariable;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            return (AnnotatedElement) typeVariable;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotationReader ofTypeVariableBoundType(int index) {
>, <Line: +                            return new ForTypeVariableBoundType.OfFormalTypeVariable(typeVariable, index);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && typeVariable.equals(((AnnotatedTypeVariableType) other).typeVariable);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return typeVariable.hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedTypeVariableType{" +
>, <Line: +                                    ", typeVariable=" + typeVariable +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated super type.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedSuperType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented type.
>, <Line: +                         */
>, <Line: +                        private final Class<?> type;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated super type.
>, <Line: +                         *
>, <Line: +                         * @param type The represented type.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedSuperType(Class<?> type) {
>, <Line: +                            this.type = type;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) getAnnotatedSuperclass.invoke(type);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.Class#getAnnotatedSuperclass", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.Class#getAnnotatedSuperclass", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedSuperType) other).getOuter())
>, <Line: +                                    && type.equals(((AnnotatedSuperType) other).type);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return getOuter().hashCode() + type.hashCode() * 31;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedSuperType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", type=" + type +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated interface type.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedInterfaceType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented interface type.
>, <Line: +                         */
>, <Line: +                        private final Class<?> type;
>, <Line: +                        /**
>, <Line: +                         * The interface type's index.
>, <Line: +                         */
>, <Line: +                        private final int index;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated interface type.
>, <Line: +                         *
>, <Line: +                         * @param type  The represented interface type.
>, <Line: +                         * @param index The interface type's index.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedInterfaceType(Class<?> type, int index) {
>, <Line: +                            this.type = type;
>, <Line: +                            this.index = index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) Array.get(getAnnotatedInterfaces.invoke(type), index);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.Class#getAnnotatedInterfaces", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.Class#getAnnotatedInterfaces", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedInterfaceType) other).getOuter())
>, <Line: +                                    && type.equals(((AnnotatedInterfaceType) other).type)
>, <Line: +                                    && index == ((AnnotatedInterfaceType) other).index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return 31 * (type.hashCode() + 31 * getOuter().hashCode()) + index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedInterfaceType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", type=" + type +
>, <Line: +                                    ", index=" + index +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated field variable.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedFieldType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented field.
>, <Line: +                         */
>, <Line: +                        private final Field field;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated field type.
>, <Line: +                         *
>, <Line: +                         * @param field The represented field.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedFieldType(Field field) {
>, <Line: +                            this.field = field;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) getAnnotatedType.invoke(field);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.reflect.Field#getAnnotatedType", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.reflect.Field#getAnnotatedType", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedFieldType) other).getOuter())
>, <Line: +                                    && field.equals(((AnnotatedFieldType) other).field);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return field.hashCode() + getOuter().hashCode() * 31;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedFieldType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", field=" + field +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated return variable.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedReturnType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented method.
>, <Line: +                         */
>, <Line: +                        private final Method method;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated return type.
>, <Line: +                         *
>, <Line: +                         * @param method The represented method.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedReturnType(Method method) {
>, <Line: +                            this.method = method;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) getAnnotatedReturnType.invoke(method);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.reflect.Method#getAnnotatedReturnType", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.reflect.Method#getAnnotatedReturnType", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedReturnType) other).getOuter())
>, <Line: +                                    && method.equals(((AnnotatedReturnType) other).method);
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return 31 * method.hashCode() + getOuter().hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedReturnType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", method=" + method +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated parameter variable.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedParameterizedType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented executable.
>, <Line: +                         */
>, <Line: +                        private final AccessibleObject executable;
>, <Line: +                        /**
>, <Line: +                         * The type argument's index.
>, <Line: +                         */
>, <Line: +                        private final int index;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated type argument type.
>, <Line: +                         *
>, <Line: +                         * @param executable The represented executable.
>, <Line: +                         * @param index      The type argument's index.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedParameterizedType(AccessibleObject executable, int index) {
>, <Line: +                            this.executable = executable;
>, <Line: +                            this.index = index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) Array.get(getAnnotatedParameterTypes.invoke(executable), index);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.reflect.Executable#getAnnotatedParameterTypes", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.reflect.Executable#getAnnotatedParameterTypes", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedParameterizedType) other).getOuter())
>, <Line: +                                    && executable.equals(((AnnotatedParameterizedType) other).executable)
>, <Line: +                                    && index == ((AnnotatedParameterizedType) other).index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return 31 * (executable.hashCode() + 31 * index) + getOuter().hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedParameterizedType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", executable=" + executable +
>, <Line: +                                    ", index=" + index +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * A delegating annotation reader for an annotated exception variable.
>, <Line: +                     */
>, <Line: +                    protected class AnnotatedExceptionType extends Delegator {
>, <Line: +                        /**
>, <Line: +                         * The represented executable.
>, <Line: +                         */
>, <Line: +                        private final AccessibleObject executable;
>, <Line: +                        /**
>, <Line: +                         * The exception type's index.
>, <Line: +                         */
>, <Line: +                        private final int index;
>, <Line: +                        /**
>, <Line: +                         * Creates a new annotation reader for an annotated exception type.
>, <Line: +                         *
>, <Line: +                         * @param executable The represented executable.
>, <Line: +                         * @param index      The exception type's index.
>, <Line: +                         */
>, <Line: +                        protected AnnotatedExceptionType(AccessibleObject executable, int index) {
>, <Line: +                            this.executable = executable;
>, <Line: +                            this.index = index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public AnnotatedElement resolve() {
>, <Line: +                            try {
>, <Line: +                                return (AnnotatedElement) Array.get(getAnnotatedExceptionTypes.invoke(executable), index);
>, <Line: +                            } catch (IllegalAccessException exception) {
>, <Line: +                                throw new IllegalStateException("Cannot access java.lang.reflect.Executable#getAnnotatedExceptionTypes", exception);
>, <Line: +                            } catch (InvocationTargetException exception) {
>, <Line: +                                throw new IllegalStateException("Error invoking java.lang.reflect.Executable#getAnnotatedExceptionTypes", exception.getCause());
>, <Line: +                            }
>, <Line: +                        }
>, <Line: +                        /**
>, <Line: +                         * Returns the outer instance.
>, <Line: +                         *
>, <Line: +                         * @return The outer instance.
>, <Line: +                         */
>, <Line: +                        private ForModernVm getOuter() {
>, <Line: +                            return ForModernVm.this;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public boolean equals(Object other) {
>, <Line: +                            return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                    && getOuter().equals(((AnnotatedExceptionType) other).getOuter())
>, <Line: +                                    && executable.equals(((AnnotatedExceptionType) other).executable)
>, <Line: +                                    && index == ((AnnotatedExceptionType) other).index;
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public int hashCode() {
>, <Line: +                            return 31 * (executable.hashCode() + 31 * index) + getOuter().hashCode();
>, <Line: +                        }
>, <Line: +                        @Override
>, <Line: +                        public String toString() {
>, <Line: +                            return "TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedExceptionType{" +
>, <Line: +                                    "dispatcher=" + getOuter() +
>, <Line: +                                    ", executable=" + executable +
>, <Line: +                                    ", index=" + index +
>, <Line: +                                    '}';
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A non-operational annotation reader.
>, <Line: +             */
>, <Line: +            enum NoOp implements AnnotationReader, AnnotatedElement {
>, <Line: +                /**
>, <Line: +                 * The singleton instance.
>, <Line: +                 */
>, <Line: +                INSTANCE;
>, <Line: +                @Override
>, <Line: +                public AnnotatedElement resolve() {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList asList() {
>, <Line: +                    return new AnnotationList.Empty();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofWildcardUpperBoundType(int index) {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofWildcardLowerBoundType(int index) {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofTypeVariableBoundType(int index) {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofTypeArgument(int index) {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofOwnerType() {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofComponentType() {
>, <Line: +                    return this;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
>, <Line: +                    throw new IllegalStateException("Cannot resolve annotations for no-op reader: " + this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
>, <Line: +                    throw new IllegalStateException("Cannot resolve annotations for no-op reader: " + this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Annotation[] getAnnotations() {
>, <Line: +                    throw new IllegalStateException("Cannot resolve annotations for no-op reader: " + this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Annotation[] getDeclaredAnnotations() {
>, <Line: +                    return new Annotation[0];
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.NoOp." + name();
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A delegating annotation reader that delegates all invocations to an annotation reader that wraps the previous one.
>, <Line: +             */
>, <Line: +            abstract class Delegator implements AnnotationReader {
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofWildcardUpperBoundType(int index) {
>, <Line: +                    return new ForWildcardUpperBoundType(this, index);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofWildcardLowerBoundType(int index) {
>, <Line: +                    return new ForWildcardLowerBoundType(this, index);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofTypeVariableBoundType(int index) {
>, <Line: +                    return new ForTypeVariableBoundType(this, index);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofTypeArgument(int index) {
>, <Line: +                    return new ForTypeArgument(this, index);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofOwnerType() {
>, <Line: +                    return NoOp.INSTANCE;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationReader ofComponentType() {
>, <Line: +                    return new ForComponentType(this);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList asList() {
>, <Line: +                    return new AnnotationList.ForLoadedAnnotations(resolve().getDeclaredAnnotations());
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A chained delegator that bases its result on an underlying annotation reader.
>, <Line: +                 */
>, <Line: +                protected abstract static class Chained extends Delegator {
>, <Line: +                    /**
>, <Line: +                     * The underlying annotation reader.
>, <Line: +                     */
>, <Line: +                    protected final AnnotationReader annotationReader;
>, <Line: +                    /**
>, <Line: +                     * Creates a new chained annotation reader.
>, <Line: +                     *
>, <Line: +                     * @param annotationReader The underlying annotation reader.
>, <Line: +                     */
>, <Line: +                    protected Chained(AnnotationReader annotationReader) {
>, <Line: +                        this.annotationReader = annotationReader;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotatedElement resolve() {
>, <Line: +                        return resolve(annotationReader.resolve());
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * Resolves the type annotations from a given annotated element into the annotated element that this instance represents.
>, <Line: +                     *
>, <Line: +                     * @param annotatedElement The original annotated element.
>, <Line: +                     * @return The resolved annotated element.
>, <Line: +                     */
>, <Line: +                    protected abstract AnnotatedElement resolve(AnnotatedElement annotatedElement);
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && annotationReader.equals(((Chained) other).annotationReader);
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return annotationReader.hashCode();
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A chained annotation reader for reading a wildcard type's upper bound type.
>, <Line: +             */
>, <Line: +            class ForWildcardUpperBoundType extends Delegator.Chained {
>, <Line: +                /**
>, <Line: +                 * The {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds} method.
>, <Line: +                 */
>, <Line: +                private static final Method GET_ANNOTATED_UPPER_BOUNDS;
>, <Line: +                /*
>, <Line: +                 * Reads the {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds} method.
>, <Line: +                 */
>, <Line: +                static {
>, <Line: +                    Method getAnnotatedUpperBounds;
>, <Line: +                    try {
>, <Line: +                        getAnnotatedUpperBounds = Class.forName("java.lang.reflect.AnnotatedWildcardType").getDeclaredMethod("getAnnotatedUpperBounds");
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        throw exception;
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        getAnnotatedUpperBounds = null;
>, <Line: +                    }
>, <Line: +                    GET_ANNOTATED_UPPER_BOUNDS = getAnnotatedUpperBounds;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * The wildcard bound's index.
>, <Line: +                 */
>, <Line: +                private final int index;
>, <Line: +                /**
>, <Line: +                 * Creates a chained annotation reader for reading a upper-bound wildcard's bound type.
>, <Line: +                 *
>, <Line: +                 * @param annotationReader The annotation reader from which to delegate.
>, <Line: +                 * @param index            The wildcard bound's index.
>, <Line: +                 */
>, <Line: +                protected ForWildcardUpperBoundType(AnnotationReader annotationReader, int index) {
>, <Line: +                    super(annotationReader);
>, <Line: +                    this.index = index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
>, <Line: +                    try {
>, <Line: +                        Object annotatedUpperBounds = GET_ANNOTATED_UPPER_BOUNDS.invoke(annotatedElement);
>, <Line: +                        return Array.getLength(annotatedUpperBounds) == 0 // Wildcards with a lower bound do not define annotations for their implicit upper bound.
>, <Line: +                                ? NoOp.INSTANCE
>, <Line: +                                : (AnnotatedElement) Array.get(annotatedUpperBounds, index);
>, <Line: +                    } catch (IllegalAccessException exception) {
>, <Line: +                        throw new IllegalStateException("Cannot access java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds", exception);
>, <Line: +                    } catch (InvocationTargetException exception) {
>, <Line: +                        throw new IllegalStateException("Error invoking java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds", exception.getCause());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && index == ((ForWildcardUpperBoundType) other).index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + index;
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.ForWildcardUpperBoundType{"
>, <Line: +                            + "annotationReader=" + annotationReader
>, <Line: +                            + ", index=" + index
>, <Line: +                            + '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A chained annotation reader for reading a wildcard type's lower bound type.
>, <Line: +             */
>, <Line: +            class ForWildcardLowerBoundType extends Delegator.Chained {
>, <Line: +                /**
>, <Line: +                 * The {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds} method.
>, <Line: +                 */
>, <Line: +                private static final Method GET_ANNOTATED_LOWER_BOUNDS;
>, <Line: +                /*
>, <Line: +                 * Reads the {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds} method.
>, <Line: +                 */
>, <Line: +                static {
>, <Line: +                    Method getAnnotatedLowerBounds;
>, <Line: +                    try {
>, <Line: +                        getAnnotatedLowerBounds = Class.forName("java.lang.reflect.AnnotatedWildcardType").getDeclaredMethod("getAnnotatedLowerBounds");
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        throw exception;
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        getAnnotatedLowerBounds = null;
>, <Line: +                    }
>, <Line: +                    GET_ANNOTATED_LOWER_BOUNDS = getAnnotatedLowerBounds;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * The wildcard bound's index.
>, <Line: +                 */
>, <Line: +                private final int index;
>, <Line: +                /**
>, <Line: +                 * Creates a chained annotation reader for reading a lower-bound wildcard's bound type.
>, <Line: +                 *
>, <Line: +                 * @param annotationReader The annotation reader from which to delegate.
>, <Line: +                 * @param index            The wildcard bound's index.
>, <Line: +                 */
>, <Line: +                protected ForWildcardLowerBoundType(AnnotationReader annotationReader, int index) {
>, <Line: +                    super(annotationReader);
>, <Line: +                    this.index = index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
>, <Line: +                    try {
>, <Line: +                        return (AnnotatedElement) Array.get(GET_ANNOTATED_LOWER_BOUNDS.invoke(annotatedElement), index);
>, <Line: +                    } catch (IllegalAccessException exception) {
>, <Line: +                        throw new IllegalStateException("Cannot access java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds", exception);
>, <Line: +                    } catch (InvocationTargetException exception) {
>, <Line: +                        throw new IllegalStateException("Error invoking java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds", exception.getCause());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && index == ((ForWildcardLowerBoundType) other).index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + index;
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.ForWildcardLowerBoundType{"
>, <Line: +                            + "annotationReader=" + annotationReader
>, <Line: +                            + ", index=" + index
>, <Line: +                            + '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A chained annotation reader for reading a type variable's type argument.
>, <Line: +             */
>, <Line: +            class ForTypeVariableBoundType extends Delegator.Chained {
>, <Line: +                /**
>, <Line: +                 * The {@code java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds} method.
>, <Line: +                 */
>, <Line: +                private static final Method GET_ANNOTATED_BOUNDS;
>, <Line: +                /*
>, <Line: +                 * Reads the {@code java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds} method.
>, <Line: +                 */
>, <Line: +                static {
>, <Line: +                    Method getAnnotatedBounds;
>, <Line: +                    try {
>, <Line: +                        getAnnotatedBounds = Class.forName("java.lang.reflect.AnnotatedTypeVariable").getDeclaredMethod("getAnnotatedBounds");
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        throw exception;
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        getAnnotatedBounds = null;
>, <Line: +                    }
>, <Line: +                    GET_ANNOTATED_BOUNDS = getAnnotatedBounds;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * The type variable's index.
>, <Line: +                 */
>, <Line: +                private final int index;
>, <Line: +                /**
>, <Line: +                 * Creates a chained annotation reader for reading a type variable's bound type.
>, <Line: +                 *
>, <Line: +                 * @param annotationReader The annotation reader from which to delegate.
>, <Line: +                 * @param index            The type variable's index.
>, <Line: +                 */
>, <Line: +                protected ForTypeVariableBoundType(AnnotationReader annotationReader, int index) {
>, <Line: +                    super(annotationReader);
>, <Line: +                    this.index = index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
>, <Line: +                    try {
>, <Line: +                        return (AnnotatedElement) Array.get(GET_ANNOTATED_BOUNDS.invoke(annotatedElement), index);
>, <Line: +                    } catch (IllegalAccessException exception) {
>, <Line: +                        throw new IllegalStateException("Cannot access java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds", exception);
>, <Line: +                    } catch (InvocationTargetException exception) {
>, <Line: +                        throw new IllegalStateException("Error invoking java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds", exception.getCause());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && index == ((ForTypeVariableBoundType) other).index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + index;
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.ForTypeVariableBoundType{"
>, <Line: +                            + "annotationReader=" + annotationReader
>, <Line: +                            + ", index=" + index
>, <Line: +                            + '}';
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A chained annotation reader for reading a formal type variable's type argument.
>, <Line: +                 */
>, <Line: +                protected static class OfFormalTypeVariable extends Delegator {
>, <Line: +                    /**
>, <Line: +                     * The {@code java.lang.reflect.TypeVariable#getAnnotatedBounds} method.
>, <Line: +                     */
>, <Line: +                    private static final Method GET_ANNOTATED_BOUNDS;
>, <Line: +                    /*
>, <Line: +                     * Reads the {@code java.lang.reflect.TypeVariable#getAnnotatedBounds} method.
>, <Line: +                     */
>, <Line: +                    static {
>, <Line: +                        Method getAnnotatedBounds;
>, <Line: +                        try {
>, <Line: +                            getAnnotatedBounds = TypeVariable.class.getDeclaredMethod("getAnnotatedBounds");
>, <Line: +                        } catch (RuntimeException exception) {
>, <Line: +                            throw exception;
>, <Line: +                        } catch (Exception exception) {
>, <Line: +                            getAnnotatedBounds = null;
>, <Line: +                        }
>, <Line: +                        GET_ANNOTATED_BOUNDS = getAnnotatedBounds;
>, <Line: +                    }
>, <Line: +                    /**
>, <Line: +                     * The represented type variable.
>, <Line: +                     */
>, <Line: +                    private final TypeVariable<?> typeVariable;
>, <Line: +                    /**
>, <Line: +                     * The type variable's index.
>, <Line: +                     */
>, <Line: +                    private final int index;
>, <Line: +                    /**
>, <Line: +                     * Creates a chained annotation reader for reading a formal type variable's bound type.
>, <Line: +                     *
>, <Line: +                     * @param typeVariable The represented type variable.
>, <Line: +                     * @param index        The type variable's index.
>, <Line: +                     */
>, <Line: +                    protected OfFormalTypeVariable(TypeVariable<?> typeVariable, int index) {
>, <Line: +                        this.typeVariable = typeVariable;
>, <Line: +                        this.index = index;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public AnnotatedElement resolve() {
>, <Line: +                        try {
>, <Line: +                            return (AnnotatedElement) Array.get(GET_ANNOTATED_BOUNDS.invoke(typeVariable), index);
>, <Line: +                        } catch (IllegalAccessException exception) {
>, <Line: +                            throw new IllegalStateException("Cannot access java.lang.reflect.TypeVariable#getAnnotatedBounds", exception);
>, <Line: +                        } catch (InvocationTargetException exception) {
>, <Line: +                            throw new IllegalStateException("Error invoking java.lang.reflect.TypeVariable#getAnnotatedBounds", exception.getCause());
>, <Line: +                        }
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public boolean equals(Object other) {
>, <Line: +                        return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                                && typeVariable == ((OfFormalTypeVariable) other).typeVariable
>, <Line: +                                && index == ((OfFormalTypeVariable) other).index;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int hashCode() {
>, <Line: +                        return index + 31 * typeVariable.hashCode();
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public String toString() {
>, <Line: +                        return "TypeDescription.Generic.AnnotationReader.OfFormalTypeVariable{"
>, <Line: +                                + "typeVariable=" + typeVariable
>, <Line: +                                + ", index=" + index
>, <Line: +                                + '}';
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A chained annotation reader for reading a parameterized type's type argument.
>, <Line: +             */
>, <Line: +            class ForTypeArgument extends Delegator.Chained {
>, <Line: +                /**
>, <Line: +                 * The {@code java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments} method.
>, <Line: +                 */
>, <Line: +                private static final Method GET_ANNOTATED_ACTUAL_TYPE_ARGUMENTS;
>, <Line: +                /*
>, <Line: +                 * Reads the {@code java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments} method.
>, <Line: +                 */
>, <Line: +                static {
>, <Line: +                    Method getAnnotatedActualTypeArguments;
>, <Line: +                    try {
>, <Line: +                        getAnnotatedActualTypeArguments = Class.forName("java.lang.reflect.AnnotatedParameterizedType").getDeclaredMethod("getAnnotatedActualTypeArguments");
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        throw exception;
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        getAnnotatedActualTypeArguments = null;
>, <Line: +                    }
>, <Line: +                    GET_ANNOTATED_ACTUAL_TYPE_ARGUMENTS = getAnnotatedActualTypeArguments;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * The type argument's index.
>, <Line: +                 */
>, <Line: +                private final int index;
>, <Line: +                /**
>, <Line: +                 * Creates a chained annotation reader for reading a component type.
>, <Line: +                 *
>, <Line: +                 * @param annotationReader The annotation reader from which to delegate.
>, <Line: +                 * @param index            The type argument's index.
>, <Line: +                 */
>, <Line: +                protected ForTypeArgument(AnnotationReader annotationReader, int index) {
>, <Line: +                    super(annotationReader);
>, <Line: +                    this.index = index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
>, <Line: +                    try {
>, <Line: +                        return (AnnotatedElement) Array.get(GET_ANNOTATED_ACTUAL_TYPE_ARGUMENTS.invoke(annotatedElement), index);
>, <Line: +                    } catch (IllegalAccessException exception) {
>, <Line: +                        throw new IllegalStateException("Cannot access java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments", exception);
>, <Line: +                    } catch (InvocationTargetException exception) {
>, <Line: +                        throw new IllegalStateException("Error invoking java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments", exception.getCause());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && index == ((ForTypeArgument) other).index;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + index;
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.ForTypeArgument{"
>, <Line: +                            + "annotationReader=" + annotationReader
>, <Line: +                            + ", index=" + index
>, <Line: +                            + '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A chained annotation reader for reading a component type.
>, <Line: +             */
>, <Line: +            class ForComponentType extends Delegator.Chained {
>, <Line: +                /**
>, <Line: +                 * The {@code java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType} method.
>, <Line: +                 */
>, <Line: +                private static final Method GET_ANNOTATED_GENERIC_COMPONENT_TYPE;
>, <Line: +                /*
>, <Line: +                 * Reads the {@code java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType} method.
>, <Line: +                 */
>, <Line: +                static {
>, <Line: +                    Method getAnnotatedGenericComponentType;
>, <Line: +                    try {
>, <Line: +                        getAnnotatedGenericComponentType = Class.forName("java.lang.reflect.AnnotatedArrayType").getDeclaredMethod("getAnnotatedGenericComponentType");
>, <Line: +                    } catch (RuntimeException exception) {
>, <Line: +                        throw exception;
>, <Line: +                    } catch (Exception exception) {
>, <Line: +                        getAnnotatedGenericComponentType = null;
>, <Line: +                    }
>, <Line: +                    GET_ANNOTATED_GENERIC_COMPONENT_TYPE = getAnnotatedGenericComponentType;
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a chained annotation reader for reading a component type.
>, <Line: +                 *
>, <Line: +                 * @param annotationReader The annotation reader from which to delegate.
>, <Line: +                 */
>, <Line: +                protected ForComponentType(AnnotationReader annotationReader) {
>, <Line: +                    super(annotationReader);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
>, <Line: +                    try {
>, <Line: +                        return (AnnotatedElement) GET_ANNOTATED_GENERIC_COMPONENT_TYPE.invoke(annotatedElement);
>, <Line: +                    } catch (IllegalAccessException exception) {
>, <Line: +                        throw new IllegalStateException("Cannot access java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType", exception);
>, <Line: +                    } catch (InvocationTargetException exception) {
>, <Line: +                        throw new IllegalStateException("Error invoking java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType", exception.getCause());
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.AnnotationReader.ForComponentType{"
>, <Line: +                            + "annotationReader=" + annotationReader
>, <Line: +                            + '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * An abstract base implementation of a generic type description.
>, <Line: +         */
>, <Line: +        abstract class AbstractBase implements Generic {
>, <Line: +            @Override
>, <Line: +            public Generic asGenericType() {
>, <Line: +                return this;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public Generic asRawType() {
>, <Line: +                return asErasure().asGenericType();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean represents(java.lang.reflect.Type type) {
>, <Line: +                return equals(Sort.describe(type));
>, <Line: +            }
>, <Line: +        }
>, <Line: +        /**
>, <Line: +         * <p>
>, <Line: +         * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
>, <Line: +         * representing a minimal erasure compared to Java's full erasure. This means that generic types are preserved as long as they
>, <Line: +         * do not involve a type variable. Nested type variables are erased on the deepest possible level.
>, <Line: +         * </p>
>, <Line: +         * <p>
>, <Line: +         * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
>, <Line: +         * </p>
>, <Line: +         */
>, <Line: +        abstract class OfNonGenericType extends AbstractBase {
>, <Line: +            @Override
>, <Line: +            public Generic getSuperType() {
>, <Line: +                Generic superType = asErasure().getSuperType();
>, <Line: +                return superType == null
>, <Line: +                        ? UNDEFINED
>, <Line: +                        : superType.accept(Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeList.Generic getInterfaces() {
>, <Line: +                return new TypeList.Generic.ForDetachedTypes(asErasure().getInterfaces(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public FieldList<FieldDescription.InGenericShape> getDeclaredFields() {
>, <Line: +                return new FieldList.TypeSubstituting(this, asErasure().getDeclaredFields(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public MethodList<MethodDescription.InGenericShape> getDeclaredMethods() {
>, <Line: +                return new MethodList.TypeSubstituting(this, asErasure().getDeclaredMethods(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public Generic getOwnerType() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply an owner type: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public Sort getSort() {
>, <Line: +                return Sort.NON_GENERIC;
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeList.Generic getTypeArguments() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply an parameter types: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public <T> T accept(Visitor<T> visitor) {
>, <Line: +                return visitor.onNonGenericType(this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String getTypeName() {
>, <Line: +                return asErasure().getTypeName();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeList.Generic getUpperBounds() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply upper type bounds: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeList.Generic getLowerBounds() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply lower type bounds: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public TypeVariableSource getVariableSource() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply a type variable source: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String getSymbol() {
>, <Line: +                throw new IllegalStateException("A non-generic type does not imply a symbol: " + this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public StackSize getStackSize() {
>, <Line: +                return asErasure().getStackSize();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String getSourceCodeName() {
>, <Line: +                return asErasure().getSourceCodeName();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean isArray() {
>, <Line: +                return asErasure().isArray();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean isPrimitive() {
>, <Line: +                return asErasure().isPrimitive();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public boolean represents(java.lang.reflect.Type type) {
>, <Line: +                return asErasure().represents(type);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public Iterator<TypeDefinition> iterator() {
>, <Line: +                return new SuperTypeIterator(this);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public int hashCode() {
>, <Line: +                return asErasure().hashCode();
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
>, <Line: +            public boolean equals(Object other) {
>, <Line: +                return asErasure().equals(other);
>, <Line: +            }
>, <Line: +            @Override
>, <Line: +            public String toString() {
>, <Line: +                return asErasure().toString();
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Represents a non-generic type for a loaded {@link Class}.
>, <Line: +             */
>, <Line: +            public static class ForLoadedType extends OfNonGenericType {
>, <Line: +                /**
>, <Line: +                 * The type that this instance represents.
>, <Line: +                 */
>, <Line: +                private final Class<?> type;
>, <Line: +                /**
>, <Line: +                 * The annotation reader to query for the non-generic type's annotations.
>, <Line: +                 */
>, <Line: +                private final AnnotationReader annotationReader;
>, <Line: +                /**
>, <Line: +                 * Creates a new description of a generic type of a loaded type.
>, <Line: +                 *
>, <Line: +                 * @param type The represented type.
>, <Line: +                 */
>, <Line: +                public ForLoadedType(Class<?> type) {
>, <Line: +                    this(type, AnnotationReader.NoOp.INSTANCE);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * /**
>, <Line: +                 * Creates a new description of a generic type of a loaded type.
>, <Line: +                 *
>, <Line: +                 * @param type             The represented type.
>, <Line: +                 * @param annotationReader The annotation reader to query for the non-generic type's annotations.
>, <Line: +                 */
>, <Line: +                protected ForLoadedType(Class<?> type, AnnotationReader annotationReader) {
>, <Line: +                    this.type = type;
>, <Line: +                    this.annotationReader = annotationReader;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeDescription asErasure() {
>, <Line: +                    return new TypeDescription.ForLoadedType(type);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public Generic getComponentType() {
>, <Line: +                    Class<?> componentType = this.type.getComponentType();
>, <Line: +                    return componentType == null
>, <Line: +                            ? UNDEFINED
>, <Line: +                            : new ForLoadedType(componentType, annotationReader.ofComponentType());
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return annotationReader.asList();
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Represents a non-generic type for a loaded {@link TypeDescription}.
>, <Line: +             */
>, <Line: +            public static class Latent extends OfNonGenericType {
>, <Line: +                /**
>, <Line: +                 * This type's type annotations.
>, <Line: +                 */
>, <Line: +                private final List<? extends AnnotationDescription> declaredAnnotations;
>, <Line: +                 * @param typeDescription     The represented non-generic type.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public Latent(TypeDescription typeDescription, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    this.declaredAnnotations = declaredAnnotations;
>, <Line: +                @Override
>, <Line: +                public Generic getComponentType() {
>, <Line: +                    TypeDescription componentType = typeDescription.getComponentType();
>, <Line: +                    return componentType == null
>, <Line: +                            ? UNDEFINED
>, <Line: +                            : componentType.asGenericType();
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return new AnnotationList.Explicit(declaredAnnotations);
>, <Line: +                }
>, <Line: +            public TypeList.Generic getTypeArguments() {
>, <Line: +                /**
>, <Line: +                 * The annotation reader to query for the generic array type's annotations.
>, <Line: +                 */
>, <Line: +                private final AnnotationReader annotationReader;
>, <Line: +                    this(genericArrayType, AnnotationReader.NoOp.INSTANCE);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a type description of the given generic array type.
>, <Line: +                 *
>, <Line: +                 * @param genericArrayType The loaded generic array type.
>, <Line: +                 * @param annotationReader The annotation reader to query for the generic array type's annotations.
>, <Line: +                 */
>, <Line: +                protected ForLoadedType(GenericArrayType genericArrayType, AnnotationReader annotationReader) {
>, <Line: +                    this.annotationReader = annotationReader;
>, <Line: +                    return Sort.describe(genericArrayType.getGenericComponentType(), annotationReader.ofComponentType());
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return annotationReader.asList();
>, <Line: +                 * This type's type annotations.
>, <Line: +                private final List<? extends AnnotationDescription> declaredAnnotations;
>, <Line: +                 * @param componentType       The component type.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public Latent(Generic componentType, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    this.declaredAnnotations = declaredAnnotations;
>, <Line: +                @Override
>, <Line: +                public Generic getComponentType() {
>, <Line: +                    return componentType;
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return new AnnotationList.Explicit(declaredAnnotations);
>, <Line: +            public TypeList.Generic getTypeArguments() {
>, <Line: +                /**
>, <Line: +                 * The annotation reader to query for the wildcard type's annotations.
>, <Line: +                 */
>, <Line: +                private final AnnotationReader annotationReader;
>, <Line: +                    this(wildcardType, AnnotationReader.NoOp.INSTANCE);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a description of a loaded wildcard.
>, <Line: +                 *
>, <Line: +                 * @param wildcardType     The represented loaded wildcard type.
>, <Line: +                 * @param annotationReader The annotation reader to query for the wildcard type's annotations.
>, <Line: +                 */
>, <Line: +                protected ForLoadedType(WildcardType wildcardType, AnnotationReader annotationReader) {
>, <Line: +                    this.annotationReader = annotationReader;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public TypeList.Generic getUpperBounds() {
>, <Line: +                    return new WildcardUpperBoundTypeList(wildcardType.getUpperBounds(), annotationReader);
>, <Line: +                    return new WildcardLowerBoundTypeList(wildcardType.getLowerBounds(), annotationReader);
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return annotationReader.asList();
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A type list representing an upper-bound type variable's bound types.
>, <Line: +                 */
>, <Line: +                protected static class WildcardUpperBoundTypeList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The represented upper bounds.
>, <Line: +                     */
>, <Line: +                    private final java.lang.reflect.Type[] upperBound;
>, <Line: +                    /**
>, <Line: +                     * The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    private final AnnotationReader annotationReader;
>, <Line: +                    /**
>, <Line: +                     * Creates a type list for a wildcard type's upper bounds.
>, <Line: +                     *
>, <Line: +                     * @param upperBound       The represented upper bounds.
>, <Line: +                     * @param annotationReader The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    protected WildcardUpperBoundTypeList(java.lang.reflect.Type[] upperBound, AnnotationReader annotationReader) {
>, <Line: +                        this.upperBound = upperBound;
>, <Line: +                        this.annotationReader = annotationReader;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return Sort.describe(upperBound[index], annotationReader.ofWildcardUpperBoundType(index));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return upperBound.length;
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A type list representing an upper-bound type variable's bound types.
>, <Line: +                 */
>, <Line: +                protected static class WildcardLowerBoundTypeList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The represented lower bounds.
>, <Line: +                     */
>, <Line: +                    private final java.lang.reflect.Type[] lowerBound;
>, <Line: +                    /**
>, <Line: +                     * The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    private final AnnotationReader annotationReader;
>, <Line: +                    /**
>, <Line: +                     * Creates a type list for a wildcard type's lower bounds.
>, <Line: +                     *
>, <Line: +                     * @param lowerBound       The represented lower bounds.
>, <Line: +                     * @param annotationReader The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    protected WildcardLowerBoundTypeList(java.lang.reflect.Type[] lowerBound, AnnotationReader annotationReader) {
>, <Line: +                        this.lowerBound = lowerBound;
>, <Line: +                        this.annotationReader = annotationReader;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return Sort.describe(lowerBound[index], annotationReader.ofWildcardLowerBoundType(index));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return lowerBound.length;
>, <Line: +                    }
>, <Line: +                /**
>, <Line: +                 * This type's type annotations.
>, <Line: +                 */
>, <Line: +                private final List<? extends AnnotationDescription> declaredAnnotations;
>, <Line: +                 * @param upperBounds         The wildcard's upper bounds.
>, <Line: +                 * @param lowerBounds         The wildcard's lower bounds.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                protected Latent(List<? extends Generic> upperBounds, List<? extends Generic> lowerBounds, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    this.declaredAnnotations = declaredAnnotations;
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public static Generic unbounded(List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.<Generic>emptyList(), declaredAnnotations);
>, <Line: +                 * @param upperBound          The upper bound of the wildcard.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public static Generic boundedAbove(Generic upperBound, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    return new Latent(Collections.singletonList(upperBound), Collections.<Generic>emptyList(), declaredAnnotations);
>, <Line: +                 * @param lowerBound          The lower bound of the wildcard.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public static Generic boundedBelow(Generic lowerBound, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.singletonList(lowerBound), declaredAnnotations);
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return new AnnotationList.Explicit(declaredAnnotations);
>, <Line: +                }
>, <Line: +                for (Generic typeArgument : getTypeArguments()) {
>, <Line: +                    result = 31 * result + typeArgument.hashCode();
>, <Line: +                        && getTypeArguments().equals(typeDescription.getTypeArguments());
>, <Line: +                TypeList.Generic actualTypeArguments = getTypeArguments();
>, <Line: +                /**
>, <Line: +                 * The annotation reader to query for the parameterized type's annotations.
>, <Line: +                 */
>, <Line: +                private final AnnotationReader annotationReader;
>, <Line: +                    this(parameterizedType, AnnotationReader.NoOp.INSTANCE);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a description of the loaded parameterized type.
>, <Line: +                 *
>, <Line: +                 * @param parameterizedType The represented parameterized type.
>, <Line: +                 * @param annotationReader  The annotation reader to query for the parameterized type's annotations.
>, <Line: +                 */
>, <Line: +                protected ForLoadedType(ParameterizedType parameterizedType, AnnotationReader annotationReader) {
>, <Line: +                    this.annotationReader = annotationReader;
>, <Line: +                public TypeList.Generic getTypeArguments() {
>, <Line: +                    return new ParameterArgumentTypeList(parameterizedType.getActualTypeArguments(), annotationReader);
>, <Line: +                            : Sort.describe(ownerType, annotationReader.ofOwnerType());
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return annotationReader.asList();
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A type list that represents a loaded parameterized type's parameter types.
>, <Line: +                 */
>, <Line: +                protected static class ParameterArgumentTypeList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The represented argument types.
>, <Line: +                     */
>, <Line: +                    private final java.lang.reflect.Type[] argumentType;
>, <Line: +                    /**
>, <Line: +                     * The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    private final AnnotationReader annotationReader;
>, <Line: +                    /**
>, <Line: +                     * Creates a list representing a parameterized type's type arguments.
>, <Line: +                     *
>, <Line: +                     * @param argumentType     The represented argument types.
>, <Line: +                     * @param annotationReader The annotation reader to query for type annotations.
>, <Line: +                     */
>, <Line: +                    protected ParameterArgumentTypeList(java.lang.reflect.Type[] argumentType, AnnotationReader annotationReader) {
>, <Line: +                        this.argumentType = argumentType;
>, <Line: +                        this.annotationReader = annotationReader;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return Sort.describe(argumentType[index], annotationReader.ofTypeArgument(index));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return argumentType.length;
>, <Line: +                    }
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * This type's type annotations.
>, <Line: +                 */
>, <Line: +                private final List<? extends AnnotationDescription> declaredAnnotations;
>, <Line: +                 * @param rawType             The raw type of the described parameterized type.
>, <Line: +                 * @param ownerType           This parameterized type's owner type or {@code null} if no owner type exists.
>, <Line: +                 * @param parameters          The parameters of this parameterized type.
>, <Line: +                 * @param declaredAnnotations This type's type annotations.
>, <Line: +                public Latent(TypeDescription rawType,
>, <Line: +                              Generic ownerType,
>, <Line: +                              List<? extends Generic> parameters,
>, <Line: +                              List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    this.declaredAnnotations = declaredAnnotations;
>, <Line: +                public TypeList.Generic getTypeArguments() {
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return new AnnotationList.Explicit(declaredAnnotations);
>, <Line: +                }
>, <Line: +            public TypeList.Generic getTypeArguments() {
>, <Line: +                /**
>, <Line: +                 * The type variable's type annotations.
>, <Line: +                 */
>, <Line: +                private final List<? extends AnnotationDescription> declaredAnnotations;
>, <Line: +                 * @param symbol              The symbol of the symbolic type variable.
>, <Line: +                 * @param declaredAnnotations The type variable's type annotations.
>, <Line: +                public Symbolic(String symbol, List<? extends AnnotationDescription> declaredAnnotations) {
>, <Line: +                    this.declaredAnnotations = declaredAnnotations;
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return new AnnotationList.Explicit(declaredAnnotations);
>, <Line: +                }
>, <Line: +                public TypeList.Generic getTypeArguments() {
>, <Line: +                /**
>, <Line: +                 * The annotation reader to query for the variable's annotations.
>, <Line: +                 */
>, <Line: +                private final AnnotationReader annotationReader;
>, <Line: +                    this(typeVariable, AnnotationReader.NoOp.INSTANCE);
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a description of a loaded type variable with an annotation.
>, <Line: +                 *
>, <Line: +                 * @param typeVariable     The represented type variable.
>, <Line: +                 * @param annotationReader The annotation reader to query for the variable's annotations.
>, <Line: +                 */
>, <Line: +                protected ForLoadedType(TypeVariable<?> typeVariable, AnnotationReader annotationReader) {
>, <Line: +                    this.annotationReader = annotationReader;
>, <Line: +                    return new TypeVariableBoundList(typeVariable.getBounds(), annotationReader);
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return annotationReader.asList();
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * A list of type variable bounds for a loaded {@link TypeVariable} that resolves annotations..
>, <Line: +                 */
>, <Line: +                protected static class TypeVariableBoundList extends TypeList.Generic.AbstractBase {
>, <Line: +                    /**
>, <Line: +                     * The type variable bounds.
>, <Line: +                     */
>, <Line: +                    private final java.lang.reflect.Type[] bound;
>, <Line: +                    /**
>, <Line: +                     * The annotation reader to query for the type bounds.
>, <Line: +                     */
>, <Line: +                    private final AnnotationReader annotationReader;
>, <Line: +                    /**
>, <Line: +                     * Creates a new list for a {@link TypeVariable}'s bound.
>, <Line: +                     *
>, <Line: +                     * @param bound            The type variable bounds.
>, <Line: +                     * @param annotationReader The annotation reader to query for the type bounds.
>, <Line: +                     */
>, <Line: +                    protected TypeVariableBoundList(java.lang.reflect.Type[] bound, AnnotationReader annotationReader) {
>, <Line: +                        this.bound = bound;
>, <Line: +                        this.annotationReader = annotationReader;
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public Generic get(int index) {
>, <Line: +                        return Sort.describe(bound[index], annotationReader.ofTypeVariableBoundType(index));
>, <Line: +                    }
>, <Line: +                    @Override
>, <Line: +                    public int size() {
>, <Line: +                        return bound.length;
>, <Line: +                    }
>, <Line: +                }
>, <Line: +            public TypeList.Generic getTypeArguments() {
>, <Line: +                return resolve().getTypeArguments();
>, <Line: +            /**
>, <Line: +             * A base implementation of a lazy type projection of an annotated element that resolves its type annotations
>, <Line: +             * via an {@link AnnotationReader}.
>, <Line: +             */
>, <Line: +            protected abstract static class OfAnnotatedElement extends LazyProjection {
>, <Line: +                /**
>, <Line: +                 * Returns the current type's annotation reader.
>, <Line: +                 *
>, <Line: +                 * @return The current type's annotation reader.
>, <Line: +                 */
>, <Line: +                protected abstract AnnotationReader getAnnotationReader();
>, <Line: +                @Override
>, <Line: +                public AnnotationList getDeclaredAnnotations() {
>, <Line: +                    return getAnnotationReader().asList();
>, <Line: +                }
>, <Line: +            }
>, <Line: +            public static class ForLoadedSuperType extends LazyProjection.OfAnnotatedElement {
>, <Line: +                    java.lang.reflect.Type superType = type.getGenericSuperclass();
>, <Line: +                    return superType == null
>, <Line: +                            : Sort.describe(superType, getAnnotationReader());
>, <Line: +                    Class<?> superType = type.getSuperclass();
>, <Line: +                    return superType == null
>, <Line: +                            : new ForLoadedType(superType);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected AnnotationReader getAnnotationReader() {
>, <Line: +                    return AnnotationReader.DISPATCHER.resolveSuperType(type);
>, <Line: +            public static class ForLoadedFieldType extends LazyProjection.OfAnnotatedElement {
>, <Line: +                    return Sort.describe(field.getGenericType(), getAnnotationReader());
>, <Line: +                @Override
>, <Line: +                protected AnnotationReader getAnnotationReader() {
>, <Line: +                    return AnnotationReader.DISPATCHER.resolve(field);
>, <Line: +                }
>, <Line: +            public static class ForLoadedReturnType extends LazyProjection.OfAnnotatedElement {
>, <Line: +                    return Sort.describe(method.getGenericReturnType(), getAnnotationReader());
>, <Line: +                @Override
>, <Line: +                protected AnnotationReader getAnnotationReader() {
>, <Line: +                    return AnnotationReader.DISPATCHER.resolveReturnType(method);
>, <Line: +                }
>, <Line: +            public static class OfConstructorParameter extends LazyProjection.OfAnnotatedElement {
>, <Line: +                            ? Sort.describe(type[index], getAnnotationReader())
>, <Line: +                @Override
>, <Line: +                protected AnnotationReader getAnnotationReader() {
>, <Line: +                    return AnnotationReader.DISPATCHER.resolveParameterType(constructor, index);
>, <Line: +                }
>, <Line: +            public static class OfMethodParameter extends LazyProjection.OfAnnotatedElement {
>, <Line: +                            ? Sort.describe(type[index], getAnnotationReader())
>, <Line: +                @Override
>, <Line: +                protected AnnotationReader getAnnotationReader() {
>, <Line: +                    return AnnotationReader.DISPATCHER.resolveParameterType(method, index);
>, <Line: +                }
>, <Line: +        abstract class Builder {
>, <Line: +             * The type annotations of the current annotated type.
>, <Line: +            protected final List<? extends AnnotationDescription> annotations;
>, <Line: +             * Creates a new builder for a generic type description.
>, <Line: +             * @param annotations The type annotations of the current annotated type.
>, <Line: +            protected Builder(List<? extends AnnotationDescription> annotations) {
>, <Line: +                this.annotations = annotations;
>, <Line: +            public static Builder rawType(TypeDescription type) {
>, <Line: +                return new Builder.OfNonGenericType(type);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates an unbound wildcard without type annotations.
>, <Line: +             *
>, <Line: +             * @return A description of an unbound wildcard without type annotations.
>, <Line: +             */
>, <Line: +            public static Generic unboundWildcard() {
>, <Line: +                return unboundWildcard(Collections.<AnnotationDescription>emptySet());
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates an unbound wildcard.
>, <Line: +             *
>, <Line: +             * @param annotation The type annotations of the unbound wildcard.
>, <Line: +             * @return A description of an unbound wildcard.
>, <Line: +             */
>, <Line: +            public static Generic unboundWildcard(Annotation... annotation) {
>, <Line: +                return unboundWildcard(Arrays.asList(annotation));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates an unbound wildcard.
>, <Line: +             *
>, <Line: +             * @param annotations The type annotations of the unbound wildcard.
>, <Line: +             * @return A description of an unbound wildcard.
>, <Line: +             */
>, <Line: +            public static Generic unboundWildcard(List<? extends Annotation> annotations) {
>, <Line: +                return unboundWildcard(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates an unbound wildcard.
>, <Line: +             *
>, <Line: +             * @param annotation The type annotations of the unbound wildcard.
>, <Line: +             * @return A description of an unbound wildcard.
>, <Line: +             */
>, <Line: +            public static Generic unboundWildcard(AnnotationDescription... annotation) {
>, <Line: +                return unboundWildcard(Arrays.asList(annotation));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates an unbound wildcard.
>, <Line: +             *
>, <Line: +             * @param annotations The type annotations of the unbound wildcard.
>, <Line: +             * @return A description of an unbound wildcard.
>, <Line: +             */
>, <Line: +            public static Generic unboundWildcard(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                return OfWildcardType.Latent.unbounded(new ArrayList<AnnotationDescription>(annotations));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a symolic type variable of the given name.
>, <Line: +             *
>, <Line: +             * @param symbol The symbolic name of the type variable.
>, <Line: +             * @return A builder for creating a type variable.
>, <Line: +             */
>, <Line: +            public static Builder typeVariable(String symbol) {
>, <Line: +                return new OfTypeVariable(symbol);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: +             *
>, <Line: +             * @param rawType   A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param parameter The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(Class<?> rawType, java.lang.reflect.Type... parameter) {
>, <Line: +                return parameterizedType(rawType, Arrays.asList(parameter));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: +             *
>, <Line: +             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(Class<?> rawType, List<? extends java.lang.reflect.Type> parameters) {
>, <Line: +                return parameterizedType(rawType, UNDEFINED, parameters);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type.
>, <Line: +             *
>, <Line: +             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param ownerType  The owner type of the parameterized type.
>, <Line: +             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(Class<?> rawType, java.lang.reflect.Type ownerType, List<? extends java.lang.reflect.Type> parameters) {
>, <Line: +                return parameterizedType(new ForLoadedType(rawType),
>, <Line: +                        ownerType == null
>, <Line: +                                ? null
>, <Line: +                                : Sort.describe(ownerType),
>, <Line: +                        new TypeList.Generic.ForLoadedTypes(parameters));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: +             *
>, <Line: +             * @param rawType   A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param parameter The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
>, <Line: +                return parameterizedType(rawType, Arrays.asList(parameter));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: +             *
>, <Line: +             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(TypeDescription rawType, Collection<? extends TypeDefinition> parameters) {
>, <Line: +                return parameterizedType(rawType, Generic.UNDEFINED, parameters);
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Creates a parameterized type.
>, <Line: +             *
>, <Line: +             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: +             * @param ownerType  The owner type of the parameterized type.
>, <Line: +             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: +             * @return A builder for creating a parameterized type.
>, <Line: +             */
>, <Line: +            public static Builder parameterizedType(TypeDescription rawType, Generic ownerType, Collection<? extends TypeDefinition> parameters) {
>, <Line: +                TypeDescription declaringType = rawType.getDeclaringType();
>, <Line: +                if (ownerType == null && declaringType != null && rawType.isStatic()) {
>, <Line: +                    ownerType = declaringType.asGenericType();
>, <Line: +                }
>, <Line: +                if (ownerType == null && declaringType != null && !rawType.isStatic()) {
>, <Line: +                    throw new IllegalArgumentException(rawType + " requires an owner type");
>, <Line: +                } else if (ownerType != null && !ownerType.asErasure().equals(declaringType)) {
>, <Line: +                    throw new IllegalArgumentException(ownerType + " does not represent required owner for " + rawType);
>, <Line: +                } else if (ownerType != null && (rawType.isStatic() ^ ownerType.getSort().isNonGeneric())) {
>, <Line: +                    throw new IllegalArgumentException(ownerType + " does not define the correct parameters for owning " + rawType);
>, <Line: +                } else if (rawType.getTypeVariables().size() != parameters.size()) {
>, <Line: +                    throw new IllegalArgumentException(parameters + " does not contain number of required parameters for " + rawType);
>, <Line: +                }
>, <Line: +                return new Builder.OfParameterizedType(rawType, ownerType, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(parameters)));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the upper bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardUpperBound() {
>, <Line: +                return asWildcardUpperBound(Collections.<AnnotationDescription>emptySet());
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the upper bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotation Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardUpperBound(Annotation... annotation) {
>, <Line: +                return asWildcardUpperBound(Arrays.asList(annotation));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the upper bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotations Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardUpperBound(List<? extends Annotation> annotations) {
>, <Line: +                return asWildcardUpperBound(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the upper bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotation Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardUpperBound(AnnotationDescription... annotation) {
>, <Line: +                return asWildcardUpperBound(Arrays.asList(annotation));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the upper bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotations Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardUpperBound(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                return OfWildcardType.Latent.boundedAbove(build(), new ArrayList<AnnotationDescription>(annotations));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the lower bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardLowerBound() {
>, <Line: +                return asWildcardLowerBound(Collections.<AnnotationDescription>emptySet());
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the lower bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotation Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardLowerBound(Annotation... annotation) {
>, <Line: +                return asWildcardLowerBound(Arrays.asList(annotation));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the lower bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotations Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardLowerBound(List<? extends Annotation> annotations) {
>, <Line: +                return asWildcardLowerBound(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * Transforms this type into the lower bound of a wildcard type.
>, <Line: +             *
>, <Line: +             * @param annotation Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: +             */
>, <Line: +            public Generic asWildcardLowerBound(AnnotationDescription... annotation) {
>, <Line: +                return asWildcardLowerBound(Arrays.asList(annotation));
>, <Line: +             * Transforms this type into the lower bound of a wildcard type.
>, <Line: +             * @param annotations Type annotations to be declared by the wildcard type.
>, <Line: +             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: +            public Generic asWildcardLowerBound(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                return OfWildcardType.Latent.boundedBelow(build(), new ArrayList<AnnotationDescription>(annotations));
>, <Line: +             * Represents the built type into an array.
>, <Line: +             * @return A builder for creating an array of the currently built type.
>, <Line: +            public Builder asArray() {
>, <Line: +                return asArray(1);
>, <Line: +             * Represents the built type into an array.
>, <Line: +             * @param arity The arity of the array.
>, <Line: +             * @return A builder for creating an array of the currently built type.
>, <Line: +            public Builder asArray(int arity) {
>, <Line: +                if (arity < 1) {
>, <Line: +                    throw new IllegalArgumentException("Cannot define an array of a non-positive arity: " + arity);
>, <Line: +                }
>, <Line: +                TypeDescription.Generic typeDescription = build();
>, <Line: +                while (--arity > 0) {
>, <Line: +                    typeDescription = new OfGenericArray.Latent(typeDescription, Collections.<AnnotationDescription>emptyList());
>, <Line: +                }
>, <Line: +                return new Builder.OfGenericArrayType(typeDescription);
>, <Line: +             * Defines type annotations to be declared by the current type.
>, <Line: +             * @param annotation Type annotations to be declared by the current type.
>, <Line: +             * @return A new builder where the current type declares the supplied type annotations.
>, <Line: +            public Builder annotate(Annotation... annotation) {
>, <Line: +                return annotate(Arrays.asList(annotation));
>, <Line: +             * Defines type annotations to be declared by the current type.
>, <Line: +             * @param annotations Type annotations to be declared by the current type.
>, <Line: +             * @return A new builder where the current type declares the supplied type annotations.
>, <Line: +            public Builder annotate(List<? extends Annotation> annotations) {
>, <Line: +                return annotate(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +             * Defines type annotations to be declared by the current type.
>, <Line: +             * @param annotation Type annotations to be declared by the current type.
>, <Line: +             * @return A new builder where the current type declares the supplied type annotations.
>, <Line: +            public Builder annotate(AnnotationDescription... annotation) {
>, <Line: +                return annotate(Arrays.asList(annotation));
>, <Line: +             * Defines type annotations to be declared by the current type.
>, <Line: +             * @param annotations Type annotations to be declared by the current type.
>, <Line: +             * @return A new builder where the current type declares the supplied type annotations.
>, <Line: +            public Builder annotate(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                return doAnnotate(new ArrayList<AnnotationDescription>(annotations));
>, <Line: +             * Creates a new builder for the current type and the spplied type annotations.
>, <Line: +             * @param annotations Type annotations to be declared by the current type.
>, <Line: +             * @return A new builder where the current type declares the supplied type annotations.
>, <Line: +            protected abstract Builder doAnnotate(List<? extends AnnotationDescription> annotations);
>, <Line: +             * Finalizes the build and finalizes the created type as a generic type description.
>, <Line: +             * @return A generic type description of the built type.
>, <Line: +            public Generic build() {
>, <Line: +                return doBuild();
>, <Line: +             * Finalizes the build and finalizes the created type as a generic type description.
>, <Line: +             * @param annotation Type annotations place for the built generic type to declare.
>, <Line: +             * @return A generic type description of the built type.
>, <Line: +            public Generic build(Annotation... annotation) {
>, <Line: +                return build(Arrays.asList(annotation));
>, <Line: +             * Finalizes the build and finalizes the created type as a generic type description.
>, <Line: +             * @param annotations Type annotations place for the built generic type to declare.
>, <Line: +             * @return A generic type description of the built type.
>, <Line: +            public Generic build(List<? extends Annotation> annotations) {
>, <Line: +                return build(new AnnotationList.ForLoadedAnnotations(annotations));
>, <Line: +             * Finalizes the build and finalizes the created type as a generic type description.
>, <Line: +             * @param annotation Type annotations place for the built generic type to declare.
>, <Line: +             * @return A generic type description of the built type.
>, <Line: +            public Generic build(AnnotationDescription... annotation) {
>, <Line: +                return build(Arrays.asList(annotation));
>, <Line: +             * @param annotations Type annotations place for the built generic type to declare.
>, <Line: +            public Generic build(Collection<? extends AnnotationDescription> annotations) {
>, <Line: +                return doAnnotate(new ArrayList<AnnotationDescription>(annotations)).doBuild();
>, <Line: +            /**
>, <Line: +             * Builds the generic type.
>, <Line: +             *
>, <Line: +             * @return The generic type.
>, <Line: +             */
>, <Line: +            protected abstract Generic doBuild();
>, <Line: +                return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                        && annotations.equals(((Builder) other).annotations);
>, <Line: +                return annotations.hashCode();
>, <Line: +            /**
>, <Line: +             * A generic type builder for building a non-generic type.
>, <Line: +             */
>, <Line: +            protected static class OfNonGenericType extends Builder {
>, <Line: +                /**
>, <Line: +                 * The type's erasure.
>, <Line: +                 */
>, <Line: +                private final TypeDescription typeDescription;
>, <Line: +                /**
>, <Line: +                 * Creates a builder for a non-generic type.
>, <Line: +                 *
>, <Line: +                 * @param typeDescription The type's erasure.
>, <Line: +                 */
>, <Line: +                protected OfNonGenericType(TypeDescription typeDescription) {
>, <Line: +                    this(typeDescription, Collections.<AnnotationDescription>emptyList());
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a builder for a non-generic type.
>, <Line: +                 *
>, <Line: +                 * @param typeDescription The type's erasure.
>, <Line: +                 * @param annotations     The type's type annotations.
>, <Line: +                 */
>, <Line: +                protected OfNonGenericType(TypeDescription typeDescription, List<? extends AnnotationDescription> annotations) {
>, <Line: +                    super(annotations);
>, <Line: +                    this.typeDescription = typeDescription;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Builder doAnnotate(List<? extends AnnotationDescription> annotations) {
>, <Line: +                    return new OfNonGenericType(typeDescription, CompoundList.of(this.annotations, annotations));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Generic doBuild() {
>, <Line: +                    return new Generic.OfNonGenericType.Latent(typeDescription, annotations);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && typeDescription.equals(((OfNonGenericType) other).typeDescription);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + typeDescription.hashCode();
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.Builder.OfNonGenericType{" +
>, <Line: +                            "annotations=" + annotations +
>, <Line: +                            ", typeDescription=" + typeDescription +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A generic type builder for building a parameterized type.
>, <Line: +             */
>, <Line: +            protected static class OfParameterizedType extends Builder {
>, <Line: +                /**
>, <Line: +                 * The raw base type.
>, <Line: +                 */
>, <Line: +                private final TypeDescription rawType;
>, <Line: +                /**
>, <Line: +                 * The generic owner type.
>, <Line: +                 */
>, <Line: +                private final Generic ownerType;
>, <Line: +                /**
>, <Line: +                 * The parameter types.
>, <Line: +                 */
>, <Line: +                private final List<? extends Generic> parameterTypes;
>, <Line: +                /**
>, <Line: +                 * Creates a builder for a parameterized type.
>, <Line: +                 *
>, <Line: +                 * @param rawType        The raw base type.
>, <Line: +                 * @param ownerType      The generic owner type.
>, <Line: +                 * @param parameterTypes The parameter types.
>, <Line: +                 */
>, <Line: +                protected OfParameterizedType(TypeDescription rawType, Generic ownerType, List<? extends Generic> parameterTypes) {
>, <Line: +                    this(rawType, ownerType, parameterTypes, Collections.<AnnotationDescription>emptyList());
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a builder for a parameterized type.
>, <Line: +                 *
>, <Line: +                 * @param rawType        The raw base type.
>, <Line: +                 * @param ownerType      The generic owner type.
>, <Line: +                 * @param parameterTypes The parameter types.
>, <Line: +                 * @param annotations    The type's type annotations.
>, <Line: +                 */
>, <Line: +                protected OfParameterizedType(TypeDescription rawType,
>, <Line: +                                              Generic ownerType,
>, <Line: +                                              List<? extends Generic> parameterTypes,
>, <Line: +                                              List<? extends AnnotationDescription> annotations) {
>, <Line: +                    super(annotations);
>, <Line: +                    this.rawType = rawType;
>, <Line: +                    this.ownerType = ownerType;
>, <Line: +                    this.parameterTypes = parameterTypes;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Builder doAnnotate(List<? extends AnnotationDescription> annotations) {
>, <Line: +                    return new OfParameterizedType(rawType, ownerType, parameterTypes, CompoundList.of(this.annotations, annotations));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Generic doBuild() {
>, <Line: +                    return new Generic.OfParameterizedType.Latent(rawType, ownerType, parameterTypes, annotations);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && rawType.equals(((OfParameterizedType) other).rawType)
>, <Line: +                            && ownerType.equals(((OfParameterizedType) other).ownerType)
>, <Line: +                            && parameterTypes.equals(((OfParameterizedType) other).parameterTypes);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + rawType.hashCode();
>, <Line: +                    result = 31 * result + ownerType.hashCode();
>, <Line: +                    result = 31 * result + parameterTypes.hashCode();
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.Builder.OfParameterizedType{" +
>, <Line: +                            "annotations=" + annotations +
>, <Line: +                            ", rawType=" + rawType +
>, <Line: +                            ", ownerType=" + ownerType +
>, <Line: +                            ", parameterTypes=" + parameterTypes +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A generic type builder building a generic array type.
>, <Line: +             */
>, <Line: +            protected static class OfGenericArrayType extends Builder {
>, <Line: +                /**
>, <Line: +                 * The generic component type.
>, <Line: +                 */
>, <Line: +                private final Generic componentType;
>, <Line: +                /**
>, <Line: +                 * Creates a type builder for building a generic array type.
>, <Line: +                 *
>, <Line: +                 * @param componentType The generic component type.
>, <Line: +                 */
>, <Line: +                protected OfGenericArrayType(Generic componentType) {
>, <Line: +                    this(componentType, Collections.<AnnotationDescription>emptyList());
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a type builder for building a generic array type.
>, <Line: +                 *
>, <Line: +                 * @param componentType The generic component type.
>, <Line: +                 * @param annotations   The type's type annotations.
>, <Line: +                 */
>, <Line: +                protected OfGenericArrayType(Generic componentType, List<? extends AnnotationDescription> annotations) {
>, <Line: +                    super(annotations);
>, <Line: +                    this.componentType = componentType;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Builder doAnnotate(List<? extends AnnotationDescription> annotations) {
>, <Line: +                    return new OfGenericArrayType(componentType, CompoundList.of(this.annotations, annotations));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Generic doBuild() {
>, <Line: +                    return new Generic.OfGenericArray.Latent(componentType, annotations);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && componentType.equals(((OfGenericArrayType) other).componentType);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + componentType.hashCode();
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.Builder.OfGenericArrayType{" +
>, <Line: +                            "annotations=" + annotations +
>, <Line: +                            ", componentType=" + componentType +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            }
>, <Line: +            /**
>, <Line: +             * A generic type builder building a symbolic type variable.
>, <Line: +             */
>, <Line: +            protected static class OfTypeVariable extends Builder {
>, <Line: +                /**
>, <Line: +                 * The variable's symbol.
>, <Line: +                 */
>, <Line: +                private final String symbol;
>, <Line: +                /**
>, <Line: +                 * Creates a new builder for a symbolic type variable.
>, <Line: +                 *
>, <Line: +                 * @param symbol The variable's symbol.
>, <Line: +                 */
>, <Line: +                protected OfTypeVariable(String symbol) {
>, <Line: +                    this(symbol, Collections.<AnnotationDescription>emptyList());
>, <Line: +                }
>, <Line: +                /**
>, <Line: +                 * Creates a new builder for a symbolic type variable.
>, <Line: +                 *
>, <Line: +                 * @param symbol      The variable's symbol.
>, <Line: +                 * @param annotations The type's type annotations.
>, <Line: +                 */
>, <Line: +                protected OfTypeVariable(String symbol, List<? extends AnnotationDescription> annotations) {
>, <Line: +                    super(annotations);
>, <Line: +                    this.symbol = symbol;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Builder doAnnotate(List<? extends AnnotationDescription> annotations) {
>, <Line: +                    return new OfTypeVariable(symbol, CompoundList.of(this.annotations, annotations));
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                protected Generic doBuild() {
>, <Line: +                    return new Generic.OfTypeVariable.Symbolic(symbol, annotations);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public boolean equals(Object other) {
>, <Line: +                    return this == other || !(other == null || getClass() != other.getClass())
>, <Line: +                            && super.equals(other)
>, <Line: +                            && symbol.equals(((OfTypeVariable) other).symbol);
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public int hashCode() {
>, <Line: +                    int result = super.hashCode();
>, <Line: +                    result = 31 * result + symbol.hashCode();
>, <Line: +                    return result;
>, <Line: +                }
>, <Line: +                @Override
>, <Line: +                public String toString() {
>, <Line: +                    return "TypeDescription.Generic.Builder.OfTypeVariable{" +
>, <Line: +                            "annotations=" + annotations +
>, <Line: +                            ", symbol=" + symbol +
>, <Line: +                            '}';
>, <Line: +                }
>, <Line: +            return new Generic.OfNonGenericType.Latent(this, Collections.<AnnotationDescription>emptyList());
>, <Line: +            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(type);
>, <Line: +            return new AnnotationList.ForLoadedAnnotations(type.getDeclaredAnnotations());
>]
[<Line: -    interface Generic extends TypeDefinition {
>, <Line: -         * Returns the type parameters of this type.
>, <Line: -        TypeList.Generic getParameters();
>, <Line: -                    return OfGenericArray.Latent.of(genericArray.getComponentType().accept(this), 1);
>, <Line: -                    TypeList.Generic lowerBounds = wildcard.getLowerBounds();
>, <Line: -                    return lowerBounds.isEmpty()
>, <Line: -                            ? OfWildcardType.Latent.boundedAbove(wildcard.getUpperBounds().getOnly().accept(this))
>, <Line: -                            : OfWildcardType.Latent.boundedBelow(lowerBounds.getOnly().accept(this));
>, <Line: -                    List<Generic> parameters = new ArrayList<Generic>(parameterizedType.getParameters().size());
>, <Line: -                    for (Generic parameter : parameterizedType.getParameters()) {
>, <Line: -                        if (parameter.accept(TypeVariableErasing.PartialErasureReviser.INSTANCE)) {
>, <Line: -                        parameters.add(parameter.accept(this));
>, <Line: -                            parameters);
>, <Line: -                    return typeVariable.asRawType();
>, <Line: -                    return new OfNonGenericType.Latent(typeDescription.asErasure());
>, <Line: -                    for (Generic upperBound : ownableType.getParameters()) {
>, <Line: -                        upperBound.accept(new ForSignatureVisitor.OfParameter(signatureVisitor));
>, <Line: -                protected static class OfParameter extends ForSignatureVisitor {
>, <Line: -                    protected OfParameter(SignatureVisitor signatureVisitor) {
>, <Line: -                        TypeList.Generic upperBounds = wildcard.getUpperBounds();
>, <Line: -                        TypeList.Generic lowerBounds = wildcard.getLowerBounds();
>, <Line: -                        return "TypeDescription.Generic.Visitor.ForSignatureVisitor.OfParameter{}";
>, <Line: -                    List<Generic> parameters = new ArrayList<Generic>(parameterizedType.getParameters().size());
>, <Line: -                    for (Generic parameter : parameterizedType.getParameters()) {
>, <Line: -                        parameters.add(parameter.accept(this));
>, <Line: -                            parameters);
>, <Line: -                    return OfGenericArray.Latent.of(genericArray.getComponentType().accept(this), 1);
>, <Line: -                    TypeList.Generic lowerBounds = wildcard.getLowerBounds();
>, <Line: -                    return lowerBounds.isEmpty()
>, <Line: -                            ? OfWildcardType.Latent.boundedAbove(wildcard.getUpperBounds().getOnly().accept(this))
>, <Line: -                            : OfWildcardType.Latent.boundedBelow(lowerBounds.getOnly().accept(this));
>, <Line: -                    int arity = 0;
>, <Line: -                    while (typeDescription.isArray()) {
>, <Line: -                        typeDescription = typeDescription.getComponentType();
>, <Line: -                        arity++;
>, <Line: -                    }
>, <Line: -                    return OfGenericArray.Latent.of(onSimpleType(typeDescription), arity);
>, <Line: -                            return attachedVariable;
>, <Line: -                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol());
>, <Line: -                            TypeList.Generic parameters = typeDescription.getParameters();
>, <Line: -                            TypeList.Generic typeVariables = typeDescription.asErasure().getTypeVariables();
>, <Line: -                            if (parameters.size() != typeVariables.size()) {
>, <Line: -                                bindings.put(typeVariables.get(index), parameters.get(index));
>, <Line: -                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol());
>, <Line: -                                TypeList.Generic fromParameters = this.parameterizedType.getParameters(), toParameters = parameterizedType.getParameters();
>, <Line: -                                if (fromParameters.size() == toParameters.size()) {
>, <Line: -                                    for (int index = 0; index < fromParameters.size(); index++) {
>, <Line: -                                        if (!fromParameters.get(index).accept(ParameterAssigner.INSTANCE).isAssignableFrom(toParameters.get(index))) {
>, <Line: -         * An abstract base implementation of a generic type description.
>, <Line: -        abstract class AbstractBase implements Generic {
>, <Line: -            @Override
>, <Line: -            public Generic asGenericType() {
>, <Line: -                return this;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Generic asRawType() {
>, <Line: -                return asErasure().asGenericType();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean represents(java.lang.reflect.Type type) {
>, <Line: -                return equals(Sort.describe(type));
>, <Line: -            }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * <p>
>, <Line: -         * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
>, <Line: -         * representing a minimal erasure compared to Java's full erasure. This means that generic types are preserved as long as they
>, <Line: -         * do not involve a type variable. Nested type variables are erased on the deepest possible level.
>, <Line: -         * </p>
>, <Line: -         * <p>
>, <Line: -         * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
>, <Line: -         * </p>
>, <Line: -         */
>, <Line: -        abstract class OfNonGenericType extends AbstractBase {
>, <Line: -            @Override
>, <Line: -            public Generic getSuperType() {
>, <Line: -                Generic superType = asErasure().getSuperType();
>, <Line: -                return superType == null
>, <Line: -                        ? UNDEFINED
>, <Line: -                        : superType.accept(Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeList.Generic getInterfaces() {
>, <Line: -                return new TypeList.Generic.ForDetachedTypes(asErasure().getInterfaces(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public FieldList<FieldDescription.InGenericShape> getDeclaredFields() {
>, <Line: -                return new FieldList.TypeSubstituting(this, asErasure().getDeclaredFields(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public MethodList<MethodDescription.InGenericShape> getDeclaredMethods() {
>, <Line: -                return new MethodList.TypeSubstituting(this, asErasure().getDeclaredMethods(), Visitor.TypeVariableErasing.INSTANCE);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Generic getOwnerType() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply an owner type: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Sort getSort() {
>, <Line: -                return Sort.NON_GENERIC;
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeList.Generic getParameters() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply an parameter types: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public <T> T accept(Visitor<T> visitor) {
>, <Line: -                return visitor.onNonGenericType(this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getTypeName() {
>, <Line: -                return asErasure().getTypeName();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeList.Generic getUpperBounds() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply upper type bounds: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeList.Generic getLowerBounds() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply lower type bounds: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Generic getComponentType() {
>, <Line: -                TypeDescription componentType = asErasure().getComponentType();
>, <Line: -                return componentType == null
>, <Line: -                        ? UNDEFINED
>, <Line: -                        : new OfNonGenericType.Latent(componentType);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public TypeVariableSource getVariableSource() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply a type variable source: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getSymbol() {
>, <Line: -                throw new IllegalStateException("A non-generic type does not imply a symbol: " + this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public StackSize getStackSize() {
>, <Line: -                return asErasure().getStackSize();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String getSourceCodeName() {
>, <Line: -                return asErasure().getSourceCodeName();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isArray() {
>, <Line: -                return asErasure().isArray();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean isPrimitive() {
>, <Line: -                return asErasure().isPrimitive();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public boolean represents(java.lang.reflect.Type type) {
>, <Line: -                return asErasure().represents(type);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public Iterator<TypeDefinition> iterator() {
>, <Line: -                return new SuperTypeIterator(this);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public int hashCode() {
>, <Line: -                return asErasure().hashCode();
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
>, <Line: -            public boolean equals(Object other) {
>, <Line: -                return asErasure().equals(other);
>, <Line: -            }
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return asErasure().toString();
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Represents a non-generic type for a loaded {@link Class}.
>, <Line: -             */
>, <Line: -            public static class ForLoadedType extends OfNonGenericType {
>, <Line: -                 * The type that this instance represents.
>, <Line: -                private final Class<?> type;
>, <Line: -                /**
>, <Line: -                 * Creates a new description of a generic type of a loaded type.
>, <Line: -                 *
>, <Line: -                 * @param type The represented type.
>, <Line: -                 */
>, <Line: -                public ForLoadedType(Class<?> type) {
>, <Line: -                    this.type = type;
>, <Line: -                }
>, <Line: -                @Override
>, <Line: -                public TypeDescription asErasure() {
>, <Line: -                    return new TypeDescription.ForLoadedType(type);
>, <Line: -                }
>, <Line: -            }
>, <Line: -            /**
>, <Line: -             * Represents a non-generic type for a loaded {@link TypeDescription}.
>, <Line: -             */
>, <Line: -            public static class Latent extends OfNonGenericType {
>, <Line: -                 * @param typeDescription The represented non-generic type.
>, <Line: -                public Latent(TypeDescription typeDescription) {
>, <Line: -            public TypeList.Generic getParameters() {
>, <Line: -                    return Sort.describe(genericArrayType.getGenericComponentType());
>, <Line: -                 * The arity of the generic array.
>, <Line: -                private final int arity;
>, <Line: -                 * @param componentType The component type.
>, <Line: -                 * @param arity         The arity of this array.
>, <Line: -                protected Latent(Generic componentType, int arity) {
>, <Line: -                    this.arity = arity;
>, <Line: -                /**
>, <Line: -                 * Returns a description of the given component type.
>, <Line: -                 *
>, <Line: -                 * @param componentType The component type of the array type to create.
>, <Line: -                 * @param arity         The arity of the generic array to create.
>, <Line: -                 * @return A description of the requested array. If the component type is non-generic, a non-generic array type is returned.
>, <Line: -                 */
>, <Line: -                public static Generic of(Generic componentType, int arity) {
>, <Line: -                    if (arity < 0) {
>, <Line: -                        throw new IllegalArgumentException("Arrays cannot have a negative arity");
>, <Line: -                    }
>, <Line: -                    while (componentType.getSort().isGenericArray()) {
>, <Line: -                        componentType = componentType.getComponentType();
>, <Line: -                        arity++;
>, <Line: -                    }
>, <Line: -                    return arity == 0
>, <Line: -                            ? componentType
>, <Line: -                            : new Latent(componentType, arity);
>, <Line: -                public Generic getComponentType() {
>, <Line: -                    return arity == 1
>, <Line: -                            ? componentType
>, <Line: -                            : new Latent(componentType, arity - 1);
>, <Line: -            public TypeList.Generic getParameters() {
>, <Line: -                    return new TypeList.Generic.ForLoadedTypes(wildcardType.getLowerBounds());
>, <Line: -                public TypeList.Generic getUpperBounds() {
>, <Line: -                    return new TypeList.Generic.ForLoadedTypes(wildcardType.getUpperBounds());
>, <Line: -                 * @param upperBounds The wildcard's upper bounds.
>, <Line: -                 * @param lowerBounds The wildcard's lower bounds.
>, <Line: -                protected Latent(List<? extends Generic> upperBounds, List<? extends Generic> lowerBounds) {
>, <Line: -                public static Generic unbounded() {
>, <Line: -                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.<Generic>emptyList());
>, <Line: -                 * @param upperBound The upper bound of the wildcard.
>, <Line: -                public static Generic boundedAbove(Generic upperBound) {
>, <Line: -                    return new Latent(Collections.singletonList(upperBound), Collections.<Generic>emptyList());
>, <Line: -                 * @param lowerBound The lower bound of the wildcard.
>, <Line: -                public static Generic boundedBelow(Generic lowerBound) {
>, <Line: -                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.singletonList(lowerBound));
>, <Line: -                for (Generic parameterType : getParameters()) {
>, <Line: -                    result = 31 * result + parameterType.hashCode();
>, <Line: -                        && getParameters().equals(typeDescription.getParameters());
>, <Line: -                TypeList.Generic actualTypeArguments = getParameters();
>, <Line: -                public TypeList.Generic getParameters() {
>, <Line: -                    return new TypeList.Generic.ForLoadedTypes(parameterizedType.getActualTypeArguments());
>, <Line: -                            : Sort.describe(ownerType);
>, <Line: -                 * @param rawType    The raw type of the described parameterized type.
>, <Line: -                 * @param parameters The parameters of this parameterized type.
>, <Line: -                 * @param ownerType  This parameterized type's owner type or {@code null} if no owner type exists.
>, <Line: -                public Latent(TypeDescription rawType, Generic ownerType, List<? extends Generic> parameters) {
>, <Line: -                public TypeList.Generic getParameters() {
>, <Line: -            public TypeList.Generic getParameters() {
>, <Line: -                 * @param symbol The symbol of the symbolic type variable.
>, <Line: -                public Symbolic(String symbol) {
>, <Line: -                public TypeList.Generic getParameters() {
>, <Line: -                    return new TypeList.Generic.ForLoadedTypes(typeVariable.getBounds());
>, <Line: -            public TypeList.Generic getParameters() {
>, <Line: -                return resolve().getParameters();
>, <Line: -            public static class ForLoadedSuperType extends LazyProjection {
>, <Line: -                    java.lang.reflect.Type superClass = type.getGenericSuperclass();
>, <Line: -                    return superClass == null
>, <Line: -                            : Sort.describe(superClass);
>, <Line: -                    Class<?> superClass = type.getSuperclass();
>, <Line: -                    return superClass == null
>, <Line: -                            : new ForLoadedType(superClass);
>, <Line: -            public static class ForLoadedFieldType extends LazyProjection {
>, <Line: -                    return Sort.describe(field.getGenericType());
>, <Line: -            public static class ForLoadedReturnType extends LazyProjection {
>, <Line: -                    return Sort.describe(method.getGenericReturnType());
>, <Line: -            public static class OfConstructorParameter extends LazyProjection {
>, <Line: -                            ? Sort.describe(type[index])
>, <Line: -            public static class OfMethodParameter extends LazyProjection {
>, <Line: -                            ? Sort.describe(type[index])
>, <Line: -        class Builder {
>, <Line: -             * The type description this builder is currently assembling.
>, <Line: -            private final Generic typeDescription;
>, <Line: -             * Creates a new builder.
>, <Line: -             * @param typeDescription The type description this builder is currently assembling.
>, <Line: -            protected Builder(Generic typeDescription) {
>, <Line: -                this.typeDescription = typeDescription;
>, <Line: -            public static Builder rawType(TypeDescription type) {
>, <Line: -                return new Builder(type.asGenericType());
>, <Line: -             * Creates an unbound wildcard.
>, <Line: -             * @return A description of an unbound wildcard.
>, <Line: -            public static Generic unboundWildcard() {
>, <Line: -                return OfWildcardType.Latent.unbounded();
>, <Line: -             * Creates a description of a type variable in detached state.
>, <Line: -             * @param symbol The symbol of the type variable.
>, <Line: -             * @return A detached description of the given type variable.
>, <Line: -            public static Generic typeVariable(String symbol) {
>, <Line: -                return new OfTypeVariable.Symbolic(symbol);
>, <Line: -             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: -             * @param rawType   A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param parameter The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(Class<?> rawType, java.lang.reflect.Type... parameter) {
>, <Line: -                return parameterizedType(rawType, Arrays.asList(parameter));
>, <Line: -             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: -             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(Class<?> rawType, List<? extends java.lang.reflect.Type> parameters) {
>, <Line: -                return parameterizedType(rawType, UNDEFINED, parameters);
>, <Line: -             * Creates a parameterized type.
>, <Line: -             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param ownerType  The owner type of the parameterized type.
>, <Line: -             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(Class<?> rawType, java.lang.reflect.Type ownerType, List<? extends java.lang.reflect.Type> parameters) {
>, <Line: -                return parameterizedType(new ForLoadedType(rawType),
>, <Line: -                        ownerType == null
>, <Line: -                                ? null
>, <Line: -                                : Sort.describe(ownerType),
>, <Line: -                        new TypeList.Generic.ForLoadedTypes(parameters));
>, <Line: -             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: -             * @param rawType   A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param parameter The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
>, <Line: -                return parameterizedType(rawType, Arrays.asList(parameter));
>, <Line: -             * Creates a parameterized type without an owner type or with a non-generic owner type.
>, <Line: -             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(TypeDescription rawType, List<? extends TypeDefinition> parameters) {
>, <Line: -                return parameterizedType(rawType, Generic.UNDEFINED, parameters);
>, <Line: -             * Creates a parameterized type.
>, <Line: -             * @param rawType    A raw version of the type to describe as a parameterized type.
>, <Line: -             * @param ownerType  The owner type of the parameterized type.
>, <Line: -             * @param parameters The type arguments to attach to the raw type as parameters.
>, <Line: -             * @return A builder for creating a parameterized type.
>, <Line: -            public static Builder parameterizedType(TypeDescription rawType, Generic ownerType, List<? extends TypeDefinition> parameters) {
>, <Line: -                TypeDescription declaringType = rawType.getDeclaringType();
>, <Line: -                if (ownerType == null && declaringType != null && rawType.isStatic()) {
>, <Line: -                    ownerType = declaringType.asGenericType();
>, <Line: -                }
>, <Line: -                if (ownerType == null && declaringType != null && !rawType.isStatic()) {
>, <Line: -                    throw new IllegalArgumentException(rawType + " requires an owner type");
>, <Line: -                } else if (ownerType != null && !ownerType.asErasure().equals(declaringType)) {
>, <Line: -                    throw new IllegalArgumentException(ownerType + " does not represent required owner for " + rawType);
>, <Line: -                } else if (ownerType != null && (rawType.isStatic() ^ ownerType.getSort().isNonGeneric())) {
>, <Line: -                    throw new IllegalArgumentException(ownerType + " does not define the correct parameters for owning " + rawType);
>, <Line: -                } else if (rawType.getTypeVariables().size() != parameters.size()) {
>, <Line: -                    throw new IllegalArgumentException(parameters + " does not contain number of required parameters for " + rawType);
>, <Line: -                }
>, <Line: -                return new Builder(new OfParameterizedType.Latent(rawType, ownerType, new TypeList.Generic.Explicit(parameters)));
>, <Line: -            }
>, <Line: -             * Transforms this type into the upper bound of a wildcard type.
>, <Line: -             * @return A generic type description of a wildcard type with this builder's type as an upper bound.
>, <Line: -            public Generic asWildcardUpperBound() {
>, <Line: -                return OfWildcardType.Latent.boundedAbove(typeDescription);
>, <Line: -             * Transforms this type into the lower bound of a wildcard type.
>, <Line: -             * @return A generic type description of a wildcard type with this builder's type as an lower bound.
>, <Line: -            public Generic asWildcardLowerBound() {
>, <Line: -                return OfWildcardType.Latent.boundedBelow(typeDescription);
>, <Line: -             * Represents the built type into an array.
>, <Line: -             * @return A builder for creating an array of the currently built type.
>, <Line: -            public Builder asArray() {
>, <Line: -                return asArray(1);
>, <Line: -             * Represents the built type into an array.
>, <Line: -             * @param arity The arity of the array.
>, <Line: -             * @return A builder for creating an array of the currently built type.
>, <Line: -            public Builder asArray(int arity) {
>, <Line: -                return new Builder(OfGenericArray.Latent.of(typeDescription, arity));
>, <Line: -            public Generic asType() {
>, <Line: -                return typeDescription;
>, <Line: -                if (this == other) return true;
>, <Line: -                if (other == null || getClass() != other.getClass()) return false;
>, <Line: -                Builder builder = (Builder) other;
>, <Line: -                return typeDescription.equals(builder.typeDescription);
>, <Line: -                return typeDescription.hashCode();
>, <Line: -            @Override
>, <Line: -            public String toString() {
>, <Line: -                return "TypeDescription.Generic.Builder{" +
>, <Line: -                        "typeDescription=" + typeDescription +
>, <Line: -                        '}';
>, <Line: -            return new Generic.OfNonGenericType.Latent(this);
>, <Line: -            return new TypeList.Generic.ForLoadedTypes(type.getTypeParameters());
>, <Line: -            return new AnnotationList.ForLoadedAnnotation(type.getDeclaredAnnotations());
>]