[<Line: + * order of the elements or add new elements on the end. Main benefit of a trailing
>, <Line: + * comma is that when you add new entry to an array, no surrounding lines are changed.
>, <Line: + * The check demands a comma at the end if neither left nor right curly braces
>, <Line: + * are on the same line as the last element of the array.
>, <Line: + * </p>
>, <Line: + * <pre>
>, <Line: + * return new int[] { 0 };
>, <Line: + * return new int[] { 0
>, <Line: + *     };
>, <Line: + * return new int[] {
>, <Line: + *     0 };
>, <Line: + * </pre>
>, <Line: + * <pre>
>, <Line: + * {
>, <Line: + *     100000000000000000000,
>, <Line: + *     200000000000000000000, // OK
>, <Line: + * }
>, <Line: + *
>, <Line: + * {
>, <Line: + *     100000000000000000000,
>, <Line: + *     200000000000000000000,
>, <Line: + *     300000000000000000000,  // Just this line added, no other changes
>, <Line: + * }
>, <Line: + * </pre>
>, <Line: + * <p>
>, <Line: + * If closing brace is on the same line as training comma, this benefit is gone
>, <Line: + * (as the Check does not demand a certain location of curly braces the following
>, <Line: + * two cases will not produce a violation):
>, <Line: + * </p>
>, <Line: + * <pre>
>, <Line: + * {100000000000000000000,
>, <Line: + *     200000000000000000000,} // Trailing comma not needed, line needs to be modified anyway
>, <Line: + *
>, <Line: + * {100000000000000000000,
>, <Line: + *     200000000000000000000, // Modified line
>, <Line: + *     300000000000000000000,} // Added line
>, <Line: + * </pre>
>, <Line: + * <p>
>, <Line: + * If opening brace is on the same line as training comma there's also (more arguable) problem:
>, <Line: + * </p>
>, <Line: + * <pre>
>, <Line: + * {100000000000000000000, // Line cannot be just duplicated to slightly modify entry
>, <Line: + * }
>, <Line: + *
>, <Line: + * {100000000000000000000,
>, <Line: + *     100000000000000000001, // More work needed to duplicate
>, <Line: + * }
>, <Line: + * </pre>
>, <Line: + * <p>
>, <Line: +        final DetailAST previousSibling = rcurly.getPreviousSibling();
>, <Line: +                && arrayInit.getChildCount() != 1
>, <Line: +                && rcurly.getLineNo() != previousSibling.getLineNo()
>, <Line: +                && arrayInit.getLineNo() != previousSibling.getLineNo()
>, <Line: +                && previousSibling.getType() != TokenTypes.COMMA) {
>, <Line: +            log(rcurly.getLineNo(), MSG_KEY);
>]
[<Line: - * order of the elements or add new elements on the end.
>, <Line: -        // if curlies are on the same line
>, <Line: -        // or array is empty then check nothing
>, <Line: -            && arrayInit.getChildCount() != 1) {
>, <Line: -            final DetailAST prev = rcurly.getPreviousSibling();
>, <Line: -            if (prev.getType() != TokenTypes.COMMA) {
>, <Line: -                log(rcurly.getLineNo(), MSG_KEY);
>, <Line: -            }
>]