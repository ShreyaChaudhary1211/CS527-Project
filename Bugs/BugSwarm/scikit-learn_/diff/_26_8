[<Line: +        predictions = np.vstack([est.predict(X) for est in self.estimators_]).T
>, <Line: +        confidences = np.vstack([_predict_binary(est, X) for est in self.estimators_]).T
>, <Line: +        return _ovr_decision_function(predictions, confidences,
>, <Line: +                                      len(self.classes_))
>, <Line: +def _ovr_decision_function(predictions, confidences, n_classes):
>, <Line: +    """Compute a continuous, tie-breaking ovr decision function.
>, <Line: +    It is important to include a continuous value, not only votes,
>, <Line: +    to make computing AUC or calibration meaningful.
>, <Line: +    Parameters
>, <Line: +    ----------
>, <Line: +    predictions : array-like, shape (n_samples, n_classifiers)
>, <Line: +        Predicted classes for each binary classifier.
>, <Line: +    confidences : array-like, shape (n_samples, n_classifiers)
>, <Line: +        Decision functions or predicted probabilities for positive class
>, <Line: +        for each binary classifier.
>, <Line: +    n_classes : int
>, <Line: +        Number of classes. n_classifiers must be
>, <Line: +        ``n_classes * (n_classes - 1 ) / 2``
>, <Line: +    """
>, <Line: +    n_samples = predictions.shape[0]
>, <Line: +    votes = np.zeros((n_samples, n_classes))
>, <Line: +    sum_of_confidences = np.zeros((n_samples, n_classes))
>, <Line: +    k = 0
>, <Line: +    for i in range(n_classes):
>, <Line: +        for j in range(i + 1, n_classes):
>, <Line: +            sum_of_confidences[:, i] -= confidences[:, k]
>, <Line: +            sum_of_confidences[:, j] += confidences[:, k]
>, <Line: +            votes[predictions[:, k] == 0, i] += 1
>, <Line: +            votes[predictions[:, k] == 1, j] += 1
>, <Line: +            k += 1
>, <Line: +    max_confidences = sum_of_confidences.max()
>, <Line: +    min_confidences = sum_of_confidences.min()
>, <Line: +    if max_confidences == min_confidences:
>, <Line: +        return votes
>, <Line: +    # Scale the sum_of_confidences to (-0.5, 0.5) and add it with votes.
>, <Line: +    # The motivation is to use confidence levels as a way to break ties in
>, <Line: +    # the votes without switching any decision made based on a difference
>, <Line: +    # of 1 vote.
>, <Line: +    eps = np.finfo(sum_of_confidences.dtype).eps
>, <Line: +    max_abs_confidence = max(abs(max_confidences), abs(min_confidences))
>, <Line: +    scale = (0.5 - eps) / max_abs_confidence
>, <Line: +    return votes + sum_of_confidences * scale
>]
[<Line: -        n_samples = X.shape[0]
>, <Line: -        n_classes = self.classes_.shape[0]
>, <Line: -        votes = np.zeros((n_samples, n_classes))
>, <Line: -        sum_of_confidences = np.zeros((n_samples, n_classes))
>, <Line: -        k = 0
>, <Line: -        for i in range(n_classes):
>, <Line: -            for j in range(i + 1, n_classes):
>, <Line: -                pred = self.estimators_[k].predict(X)
>, <Line: -                confidence_levels_ij = _predict_binary(self.estimators_[k], X)
>, <Line: -                sum_of_confidences[:, i] -= confidence_levels_ij
>, <Line: -                sum_of_confidences[:, j] += confidence_levels_ij
>, <Line: -                votes[pred == 0, i] += 1
>, <Line: -                votes[pred == 1, j] += 1
>, <Line: -                k += 1
>, <Line: -        max_confidences = sum_of_confidences.max()
>, <Line: -        min_confidences = sum_of_confidences.min()
>, <Line: -        if max_confidences == min_confidences:
>, <Line: -            return votes
>, <Line: -        # Scale the sum_of_confidences to (-0.5, 0.5) and add it with votes.
>, <Line: -        # The motivation is to use confidence levels as a way to break ties in
>, <Line: -        # the votes without switching any decision made based on a difference
>, <Line: -        # of 1 vote.
>, <Line: -        eps = np.finfo(sum_of_confidences.dtype).eps
>, <Line: -        max_abs_confidence = max(abs(max_confidences), abs(min_confidences))
>, <Line: -        scale = (0.5 - eps) / max_abs_confidence
>, <Line: -        return votes + sum_of_confidences * scale
>]