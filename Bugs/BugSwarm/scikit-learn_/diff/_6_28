[<Line: +        cdef int current_index = our_rand_r(&self.seed) % n
>, <Line: +        self.current_index = current_index
>, <Line: +        return current_index
>, <Line: +    def _shuffle_py(self, np.uint32_t seed):
>, <Line: +        """python function used for easy testing"""
>, <Line: +        self.shuffle(seed)
>, <Line: +    def _next_py(self):
>, <Line: +        """python function used for easy testing"""
>, <Line: +        cdef int current_index = self._get_next_index()
>, <Line: +        return self._sample_py(current_index)
>, <Line: +    def _random_py(self):
>, <Line: +        """python function used for easy testing"""
>, <Line: +        cdef int current_index = self._get_random_index()
>, <Line: +        return self._sample_py(current_index)
>, <Line: +    def _sample_py(self, int current_index):
>, <Line: +        """python function used for easy testing"""
>, <Line: +        cdef double* x_data_ptr
>, <Line: +        cdef int* x_indices_ptr
>, <Line: +        cdef int nnz
>, <Line: +        cdef double y, sample_weight
>, <Line: +        # call _sample in cython
>, <Line: +        self._sample(&x_data_ptr, &x_indices_ptr, &nnz, &y, &sample_weight,
>, <Line: +                     current_index)
>, <Line: +        # transform the pointed data in numpy CSR array
>, <Line: +        cdef np.ndarray[double, ndim=1] x_data = np.empty(nnz)
>, <Line: +        cdef np.ndarray[int, ndim=1] x_indices = np.empty(nnz, dtype=np.int32)
>, <Line: +        cdef np.ndarray[int, ndim=1] x_indptr = np.asarray([0, nnz],
>, <Line: +                                                           dtype=np.int32)
>, <Line: +        for j in range(nnz):
>, <Line: +            x_data[j] = x_data_ptr[j]
>, <Line: +            x_indices[j] = x_indices_ptr[j]
>, <Line: +        cdef int sample_idx = self.index_data_ptr[current_index]
>, <Line: +        return (x_data, x_indices, x_indptr), y, sample_weight, sample_idx
>, <Line: +                  np.uint32_t seed=1):
>, <Line: +        # keep a reference to the data to prevent garbage collection
>, <Line: +        self.X = X
>, <Line: +        self.Y = Y
>, <Line: +        self.sample_weights = sample_weights
>, <Line: +        cdef np.ndarray[int, ndim=1, mode='c'] feature_indices = np.arange(
>, <Line: +            0, self.n_features, dtype=np.intc)
>, <Line: +        # seed should not be 0 for our_rand_r
>, <Line: +        self.seed = max(seed, 1)
>, <Line: +                  np.ndarray[double, ndim=1, mode='c'] sample_weights,
>, <Line: +                  np.uint32_t seed=1):
>, <Line: +        # keep a reference to the data to prevent garbage collection
>, <Line: +        self.X_data = X_data
>, <Line: +        self.X_indptr = X_indptr
>, <Line: +        self.X_indices = X_indices
>, <Line: +        self.Y = Y
>, <Line: +        self.sample_weights = sample_weights
>, <Line: +        self.sample_weight_data = <double *>sample_weights.data
>, <Line: +        # seed should not be 0 for our_rand_r
>, <Line: +        self.seed = max(seed, 1)
>]
[<Line: -from libc.stdlib cimport rand, srand, RAND_MAX
>, <Line: -        return (int)(1.0 * rand() / RAND_MAX * n)
>, <Line: -                  int seed=0):
>, <Line: -        cdef np.ndarray[int, ndim=1,
>, <Line: -                        mode='c'] feature_indices = np.arange(0, self.n_features,
>, <Line: -                                                              dtype=np.intc)
>, <Line: -        srand(seed)
>, <Line: -    cdef void next(self, double **x_data_ptr, int **x_ind_ptr,
>, <Line: -                   int *nnz, double *y, double *sample_weight) nogil:
>, <Line: -        cdef int current_index = self._get_next_index()
>, <Line: -        self._sample(x_data_ptr, x_ind_ptr, nnz, y,
>, <Line: -                     sample_weight, current_index)
>, <Line: -                  np.ndarray[double, ndim=1, mode='c'] sample_weight,
>, <Line: -                  int seed=0):
>, <Line: -        self.sample_weight_data = <double *>sample_weight.data
>, <Line: -        srand(seed)
>]