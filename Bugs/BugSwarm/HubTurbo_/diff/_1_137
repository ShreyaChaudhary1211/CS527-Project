[<Line: +import org.apache.logging.log4j.LogManager;
>, <Line: +import org.apache.logging.log4j.Logger;
>, <Line: +import org.eclipse.egit.github.core.RepositoryId;
>, <Line: +import javax.swing.*;
>, <Line: +import java.awt.*;
>, <Line: +import java.io.*;
>, <Line: +import java.nio.file.Files;
>, <Line: +import java.util.Date;
>, <Line: +import java.util.List;
>, <Line: +import java.util.Optional;
>, <Line: +import java.util.TimeZone;
>, <Line: +import java.util.concurrent.CompletableFuture;
>, <Line: +import java.util.concurrent.Executor;
>, <Line: +import java.util.concurrent.Executors;
>, <Line: +public class Utility {
>, <Line: +	private static final Logger logger = LogManager.getLogger(Utility.class.getName());
>, <Line: +	/**
>, <Line: +	 * Returns a CompletableFuture that will be completed 'later' with the given result.
>, <Line: +	 * 'Later' is defined loosely. This implementation utilises a secondary thread to do it.
>, <Line: +	 *
>, <Line: +	 * The use case is if you want to return a CompletableFuture that just completes
>, <Line: +	 * trivially, for example if you detect an error occurring early and don't want/need
>, <Line: +	 * to go through the whole async task that the CompletableFuture represents. You can't
>, <Line: +	 * complete the future synchronously because that wouldn't trigger all the callbacks
>, <Line: +	 * attached to it.
>, <Line: +	 *
>, <Line: +	 * The name comes from the monadic interpretation of CompletableFutures.
>, <Line: +	 * @param result the result that the unit CompletableFuture will be completed with
>, <Line: +	 * @param <T> the type of the CompletableFuture result
>, <Line: +	 * @return the unit future
>, <Line: +	 */
>, <Line: +	private static Executor unitFutureExecutor = Executors.newSingleThreadExecutor();
>, <Line: +	public static <T> CompletableFuture<T> unitFutureOf(T result) {
>, <Line: +		CompletableFuture<T> f = new CompletableFuture<>();
>, <Line: +//		Platform.runLater(() -> f.complete(result));
>, <Line: +		unitFutureExecutor.execute(() -> f.complete(result));
>, <Line: +		return f;
>, <Line: +	}
>, <Line: +	public static boolean isWellFormedRepoId(String owner, String repo) {
>, <Line: +		if (owner == null || owner.isEmpty() || repo == null || repo.isEmpty()) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		return isWellFormedRepoId(RepositoryId.create(owner, repo).generateId());
>, <Line: +	}
>, <Line: +	public static boolean isWellFormedRepoId(String repoId) {
>, <Line: +		return repoId != null && !repoId.isEmpty()
>, <Line: +			&& RepositoryId.createFromId(repoId).generateId().equals(repoId);
>, <Line: +	}
>, <Line: +	public static Optional<String> readFile(String filename) {
>, <Line: +		try {
>, <Line: +			return Optional.of(new String(Files.readAllBytes(new File(filename).toPath())));
>, <Line: +		} catch (IOException e) {
>, <Line: +			logger.error(e.getLocalizedMessage(), e);
>, <Line: +		}
>, <Line: +		return Optional.empty();
>, <Line: +	}
>, <Line: +	public static void writeFile(String fileName, String content) {
>, <Line: +		PrintWriter writer;
>, <Line: +		try {
>, <Line: +			writer = new PrintWriter(fileName, "UTF-8");
>, <Line: +			writer.println(content);
>, <Line: +			writer.close();
>, <Line: +		} catch (FileNotFoundException | UnsupportedEncodingException e) {
>, <Line: +			logger.error(e.getLocalizedMessage(), e);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public static <T> CompletableFuture<List<T>> sequence(List<CompletableFuture<T>> futures) {
>, <Line: +		CompletableFuture<Void> allDoneFuture =
>, <Line: +			CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));
>, <Line: +		return allDoneFuture.thenApply(v ->
>, <Line: +				futures.stream().
>, <Line: +					map(CompletableFuture::join)
>, <Line: +					.collect(Collectors.<T>toList())
>, <Line: +		);
>]
[<Line: -import java.awt.Dimension;
>, <Line: -import java.awt.GraphicsEnvironment;
>, <Line: -import java.awt.Rectangle;
>, <Line: -import java.awt.Toolkit;
>, <Line: -import java.util.*;
>, <Line: -import javax.swing.UIManager;
>, <Line: -import model.TurboLabel;
>, <Line: -import org.apache.logging.log4j.LogManager;
>, <Line: -import org.apache.logging.log4j.Logger;
>, <Line: -import org.eclipse.egit.github.core.Comment;
>, <Line: -import com.google.common.base.Joiner;
>, <Line: -public class Utility {
>, <Line: -	private static final Logger logger = LogManager.getLogger(Utility.class.getName());
>, <Line: -	public static String stringify(Collection<TurboLabel> labels) {
>, <Line: -		return "[" + Joiner.on(", ").join(labels.stream().map(TurboLabel::logString).collect(Collectors.toList())) + "]";
>]