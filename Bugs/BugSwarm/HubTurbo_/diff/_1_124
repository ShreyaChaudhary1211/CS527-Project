[<Line: +import backend.interfaces.IModel;
>, <Line: +import backend.resource.TurboIssue;
>, <Line: +import backend.resource.TurboUser;
>, <Line: +import filter.ParseException;
>, <Line: +import filter.Parser;
>, <Line: +import filter.QualifierApplicationException;
>, <Line: +import filter.expression.FilterExpression;
>, <Line: +import filter.expression.Qualifier;
>, <Line: +import util.events.ModelUpdatedEventHandler;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Arrays;
>, <Line: +import java.util.List;
>, <Line: +import java.util.function.Predicate;
>, <Line: +import java.util.stream.Collectors;
>, <Line: +	public IssueColumn(UI ui, IModel model, ColumnControl parentColumnControl, int columnIndex) {
>, <Line: +		super(model, parentColumnControl, columnIndex);
>, <Line: +//		setupIssueColumnDragEvents(model, columnIndex);
>, <Line: +//	private void setupIssueColumnDragEvents(Model model, int columnIndex) {
>, <Line: +//		setOnDragOver(e -> {
>, <Line: +//			if (e.getGestureSource() != this && e.getDragboard().hasString()) {
>, <Line: +//				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: +//				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: +//					e.acceptTransferModes(TransferMode.MOVE);
>, <Line: +//				}
>, <Line: +//			}
>, <Line: +//		});
>, <Line: +//
>, <Line: +//		setOnDragDropped(e -> {
>, <Line: +//			Dragboard db = e.getDragboard();
>, <Line: +//			boolean success = false;
>, <Line: +//
>, <Line: +//			if (db.hasString()) {
>, <Line: +//				success = true;
>, <Line: +//				DragData dd = DragData.deserialise(db.getString());
>, <Line: +//				if (dd.getColumnIndex() != columnIndex) {
>, <Line: +//					Optional<TurboIssue> rightIssue = model.getIssueById(dd.getIssueIndex());
>, <Line: +//					assert rightIssue.isPresent();
>, <Line: +//					applyCurrentFilterExpressionToIssue(rightIssue.get(), true);
>, <Line: +//				}
>, <Line: +//			}
>, <Line: +//			e.setDropCompleted(success);
>, <Line: +//
>, <Line: +//			e.consume();
>, <Line: +//		});
>, <Line: +//	}
>, <Line: +	private final ModelUpdatedEventHandler onModelUpdate = e -> {
>, <Line: +		List<String> all = new ArrayList<>(Arrays.asList(
>, <Line: +			"label", "milestone",
>, <Line: +			"involves", "assignee", "author",
>, <Line: +			"title", "body",
>, <Line: +			"is", "issue", "pr", "merged", "unmerged",
>, <Line: +			"no", "type", "has",
>, <Line: +			"state", "open", "closed",
>, <Line: +			"created",
>, <Line: +			"updated"));
>, <Line: +		all.addAll(e.model.getUsers().stream()
>, <Line: +			.map(TurboUser::getLoginName)
>, <Line: +			.collect(Collectors.toList()));
>, <Line: +		filterTextField.setKeywords(all);
>, <Line: +	};
>, <Line: +		ui.registerEvent(onModelUpdate);
>, <Line: +		filterTextField.setOnMouseClicked(e -> ui.triggerEvent(new ColumnClickedEvent(columnIndex)));
>, <Line: +//		setupIssueDragEvents(filterTextField);
>, <Line: +//	private void setupIssueDragEvents(Node filterBox) {
>, <Line: +//		filterBox.setOnDragOver(e -> {
>, <Line: +//			if (e.getGestureSource() != this && e.getDragboard().hasString()) {
>, <Line: +//				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: +//				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: +//					e.acceptTransferModes(TransferMode.MOVE);
>, <Line: +//				} else if (dd.getSource() == DragData.Source.LABEL_TAB
>, <Line: +//						|| dd.getSource() == DragData.Source.ASSIGNEE_TAB
>, <Line: +//						|| dd.getSource() == DragData.Source.MILESTONE_TAB) {
>, <Line: +//					e.acceptTransferModes(TransferMode.COPY);
>, <Line: +//				}
>, <Line: +//			}
>, <Line: +//		});
>, <Line: +//
>, <Line: +//		filterBox.setOnDragEntered(e -> {
>, <Line: +//			if (e.getDragboard().hasString()) {
>, <Line: +//				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: +//				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: +//					filterBox.getStyleClass().add("dragged-over");
>, <Line: +//				} else if (dd.getSource() == DragData.Source.COLUMN) {
>, <Line: +//					if (parentColumnControl.getCurrentlyDraggedColumnIndex() != columnIndex) {
>, <Line: +//						// Apparently the dragboard can't be updated while
>, <Line: +//						// the drag is in progress. This is why we use an
>, <Line: +//						// external source for updates.
>, <Line: +//						assert parentColumnControl.getCurrentlyDraggedColumnIndex() != -1;
>, <Line: +//						int previous = parentColumnControl.getCurrentlyDraggedColumnIndex();
>, <Line: +//						parentColumnControl.setCurrentlyDraggedColumnIndex(columnIndex);
>, <Line: +//						parentColumnControl.swapColumns(previous, columnIndex);
>, <Line: +//					}
>, <Line: +//				}
>, <Line: +//			}
>, <Line: +//			e.consume();
>, <Line: +//		});
>, <Line: +//
>, <Line: +//		filterBox.setOnDragExited(e -> {
>, <Line: +//			filterBox.getStyleClass().remove("dragged-over");
>, <Line: +//			e.consume();
>, <Line: +//		});
>, <Line: +//
>, <Line: +//		filterBox.setOnDragDropped(e -> {
>, <Line: +//			Dragboard db = e.getDragboard();
>, <Line: +//			boolean success = false;
>, <Line: +//			if (db.hasString()) {
>, <Line: +//				success = true;
>, <Line: +//				DragData dd = DragData.deserialise(db.getString());
>, <Line: +//				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: +//
>, <Line: +//					assert model.getIssueById(dd.getIssueIndex()).isPresent();
>, <Line: +//					TurboIssue rightIssue = model.getIssueById(dd.getIssueIndex()).get();
>, <Line: +//					if (rightIssue.getLabels().size() == 0) {
>, <Line: +//						// If the issue has no labels, show it by its title to inform
>, <Line: +//						// the user that there are no similar issues
>, <Line: +//						filter(new Qualifier("keyword", rightIssue.getTitle()));
>, <Line: +//					} else {
>, <Line: +//						// Otherwise, take the disjunction of its labels to show similar
>, <Line: +//						// issues.
>, <Line: +//						List<TurboLabel> labels = model.getLabelsOfIssue(rightIssue);
>, <Line: +//						FilterExpression result = new Qualifier("label", labels.get(0).getName());
>, <Line: +//						List<FilterExpression> rest = labels.stream()
>, <Line: +//							.skip(1)
>, <Line: +//							.map(label -> new Qualifier("label", label.getName()))
>, <Line: +//							.collect(Collectors.toList());
>, <Line: +//
>, <Line: +//						for (FilterExpression label : rest) {
>, <Line: +//							result = new Disjunction(label, result);
>, <Line: +//						}
>, <Line: +//
>, <Line: +//						filter(result);
>, <Line: +//					}
>, <Line: +//				} else if (dd.getSource() == DragData.Source.COLUMN) {
>, <Line: +//					// This event is never triggered when the drag is ended.
>, <Line: +//					// It's not a huge deal, as this is only used to
>, <Line: +//					// reinitialise the currently-dragged slot in ColumnControl.
>, <Line: +//					// The other main consequence of this is that we can't
>, <Line: +//					// assert to check if the slot has been cleared when starting a drag-swap.
>, <Line: +//				} else if (dd.getSource() == DragData.Source.LABEL_TAB) {
>, <Line: +//					filter(new Qualifier("label", dd.getEntityName()));
>, <Line: +//				} else if (dd.getSource() == DragData.Source.ASSIGNEE_TAB) {
>, <Line: +//					filter(new Qualifier("assignee", dd.getEntityName()));
>, <Line: +//				} else if (dd.getSource() == DragData.Source.MILESTONE_TAB) {
>, <Line: +//					filter(new Qualifier("milestone", dd.getEntityName()));
>, <Line: +//				}
>, <Line: +//
>, <Line: +//			}
>, <Line: +//			e.setDropCompleted(success);
>, <Line: +//			e.consume();
>, <Line: +//		});
>, <Line: +//	}
>, <Line: +			UI.status.clear();
>, <Line: +			UI.status.displayMessage("Panel " + (columnIndex + 1) + ": Parse error in filter: " + ex.getMessage());
>, <Line: +		applyCurrentFilterExpression();
>, <Line: +	/**
>, <Line: +	 * Same as applyFilterExpression, but does not call refreshItems or change the
>, <Line: +	 * current filter. Meant to be called from refreshItems() so as not to go into
>, <Line: +	 * infinite mutual recursion.
>, <Line: +	 */
>, <Line: +	private void applyCurrentFilterExpression() {
>, <Line: +		predicate = issue -> Qualifier.process(model, currentFilterExpression, issue);
>, <Line: +		Qualifier.processMetaQualifierEffects(currentFilterExpression, qualifier -> {
>, <Line: +			if (qualifier.getName().equals("repo") && qualifier.getContent().isPresent()) {
>, <Line: +				ui.logic.openRepository(qualifier.getContent().get());
>, <Line: +			}
>, <Line: +		});
>, <Line: +	}
>, <Line: +	// triggered through the text contents of the input area changing.
>, <Line: +					// TODO re-enable
>, <Line: +//					TurboIssue clone = new TurboIssue(issue);
>, <Line: +						// TODO re-enable
>, <Line: +//						dragAndDropExecutor.executeCommand(CommandType.EDIT_ISSUE, models, clone, issue);
>, <Line: +					throw new QualifierApplicationException(
>, <Line: +						"Could not apply predicate " + currentFilterExpression + ".");
>, <Line: +				UI.status.displayMessage(ex.getMessage());
>, <Line: +	@Override
>, <Line: +	public void close() {
>, <Line: +		ui.unregisterEvent(onModelUpdate);
>, <Line: +	}
>, <Line: +		applyCurrentFilterExpression();
>, <Line: +		transformedIssueList = new FilteredList<>(issues, predicate);
>]
[<Line: -import java.util.Comparator;
>, <Line: -import java.util.List;
>, <Line: -import java.util.function.Predicate;
>, <Line: -import java.util.stream.Collectors;
>, <Line: -import javafx.collections.transformation.SortedList;
>, <Line: -import javafx.scene.input.Dragboard;
>, <Line: -import javafx.scene.input.TransferMode;
>, <Line: -import javafx.stage.Stage;
>, <Line: -import model.Model;
>, <Line: -import model.TurboIssue;
>, <Line: -import service.ServiceManager;
>, <Line: -import ui.DragData;
>, <Line: -import ui.components.HTStatusBar;
>, <Line: -import command.CommandType;
>, <Line: -import command.TurboCommandExecutor;
>, <Line: -import filter.ParseException;
>, <Line: -import filter.Parser;
>, <Line: -import filter.QualifierApplicationException;
>, <Line: -import filter.expression.Disjunction;
>, <Line: -import filter.expression.FilterExpression;
>, <Line: -import filter.expression.Qualifier;
>, <Line: -	public IssueColumn(UI ui, Stage mainStage, Model model, ColumnControl parentColumnControl,
>, <Line: -			int columnIndex, TurboCommandExecutor dragAndDropExecutor) {
>, <Line: -		super(mainStage, model, parentColumnControl, columnIndex, dragAndDropExecutor);
>, <Line: -		setupIssueColumnDragEvents(model, columnIndex);
>, <Line: -	private void setupIssueColumnDragEvents(Model model, int columnIndex) {
>, <Line: -		setOnDragOver(e -> {
>, <Line: -			if (e.getGestureSource() != this && e.getDragboard().hasString()) {
>, <Line: -				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: -				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: -					e.acceptTransferModes(TransferMode.MOVE);
>, <Line: -				}
>, <Line: -			}
>, <Line: -		});
>, <Line: -		setOnDragDropped(e -> {
>, <Line: -			Dragboard db = e.getDragboard();
>, <Line: -			boolean success = false;
>, <Line: -			if (db.hasString()) {
>, <Line: -				success = true;
>, <Line: -				DragData dd = DragData.deserialise(db.getString());
>, <Line: -				if (dd.getColumnIndex() != columnIndex) {
>, <Line: -					TurboIssue rightIssue = model.getIssueWithId(dd.getIssueIndex());
>, <Line: -					applyCurrentFilterExpressionToIssue(rightIssue, true);
>, <Line: -				}
>, <Line: -			}
>, <Line: -			e.setDropCompleted(success);
>, <Line: -			e.consume();
>, <Line: -		});
>, <Line: -	}
>, <Line: -		List<String> collaboratorNames = ServiceManager.getInstance().getModel().getCollaborators()
>, <Line: -			.stream().map(c -> c.getGithubName()).collect(Collectors.toList());
>, <Line: -		filterTextField.addKeywords(collaboratorNames);
>, <Line: -		filterTextField.setOnMouseClicked(e-> {ui.triggerEvent(new ColumnClickedEvent(columnIndex));});
>, <Line: -		setupIssueDragEvents(filterTextField);
>, <Line: -	private void setupIssueDragEvents(Node filterBox) {
>, <Line: -		filterBox.setOnDragOver(e -> {
>, <Line: -			if (e.getGestureSource() != this && e.getDragboard().hasString()) {
>, <Line: -				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: -				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: -					e.acceptTransferModes(TransferMode.MOVE);
>, <Line: -				} else if (dd.getSource() == DragData.Source.LABEL_TAB
>, <Line: -						|| dd.getSource() == DragData.Source.ASSIGNEE_TAB
>, <Line: -						|| dd.getSource() == DragData.Source.MILESTONE_TAB) {
>, <Line: -					e.acceptTransferModes(TransferMode.COPY);
>, <Line: -				}
>, <Line: -			}
>, <Line: -		});
>, <Line: -		filterBox.setOnDragEntered(e -> {
>, <Line: -			if (e.getDragboard().hasString()) {
>, <Line: -				DragData dd = DragData.deserialise(e.getDragboard().getString());
>, <Line: -				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: -					filterBox.getStyleClass().add("dragged-over");
>, <Line: -				} else if (dd.getSource() == DragData.Source.COLUMN) {
>, <Line: -					if (parentColumnControl.getCurrentlyDraggedColumnIndex() != columnIndex) {
>, <Line: -						// Apparently the dragboard can't be updated while
>, <Line: -						// the drag is in progress. This is why we use an
>, <Line: -						// external source for updates.
>, <Line: -						assert parentColumnControl.getCurrentlyDraggedColumnIndex() != -1;
>, <Line: -						int previous = parentColumnControl.getCurrentlyDraggedColumnIndex();
>, <Line: -						parentColumnControl.setCurrentlyDraggedColumnIndex(columnIndex);
>, <Line: -						parentColumnControl.swapColumns(previous, columnIndex);
>, <Line: -					}
>, <Line: -				}
>, <Line: -			}
>, <Line: -			e.consume();
>, <Line: -		});
>, <Line: -		filterBox.setOnDragExited(e -> {
>, <Line: -			filterBox.getStyleClass().remove("dragged-over");
>, <Line: -			e.consume();
>, <Line: -		});
>, <Line: -		filterBox.setOnDragDropped(e -> {
>, <Line: -			Dragboard db = e.getDragboard();
>, <Line: -			boolean success = false;
>, <Line: -			if (db.hasString()) {
>, <Line: -				success = true;
>, <Line: -				DragData dd = DragData.deserialise(db.getString());
>, <Line: -				if (dd.getSource() == DragData.Source.ISSUE_CARD) {
>, <Line: -					TurboIssue rightIssue = model.getIssueWithId(dd.getIssueIndex());
>, <Line: -					if (rightIssue.getLabels().size() == 0) {
>, <Line: -						// If the issue has no labels, show it by its title to inform
>, <Line: -						// the user that there are no similar issues
>, <Line: -						filter(new Qualifier("keyword", rightIssue.getTitle()));
>, <Line: -					} else {
>, <Line: -						// Otherwise, take the disjunction of its labels to show similar
>, <Line: -						// issues.
>, <Line: -						FilterExpression result = new Qualifier("label", rightIssue.getLabels().get(0).getName());
>, <Line: -						List<FilterExpression> rest = rightIssue.getLabels().stream()
>, <Line: -								.skip(1)
>, <Line: -								.map(label -> new Qualifier("label", label.getName()))
>, <Line: -								.collect(Collectors.toList());
>, <Line: -						for (FilterExpression label : rest) {
>, <Line: -							result = new Disjunction(label, result);
>, <Line: -						}
>, <Line: -						filter(result);
>, <Line: -					}
>, <Line: -				} else if (dd.getSource() == DragData.Source.COLUMN) {
>, <Line: -					// This event is never triggered when the drag is ended.
>, <Line: -					// It's not a huge deal, as this is only used to
>, <Line: -					// reinitialise the currently-dragged slot in ColumnControl.
>, <Line: -					// The other main consequence of this is that we can't
>, <Line: -					// assert to check if the slot has been cleared when starting a drag-swap.
>, <Line: -				} else if (dd.getSource() == DragData.Source.LABEL_TAB) {
>, <Line: -					filter(new Qualifier("label", dd.getEntityName()));
>, <Line: -				} else if (dd.getSource() == DragData.Source.ASSIGNEE_TAB) {
>, <Line: -					filter(new Qualifier("assignee", dd.getEntityName()));
>, <Line: -				} else if (dd.getSource() == DragData.Source.MILESTONE_TAB) {
>, <Line: -					filter(new Qualifier("milestone", dd.getEntityName()));
>, <Line: -				}
>, <Line: -			}
>, <Line: -			e.setDropCompleted(success);
>, <Line: -			e.consume();
>, <Line: -		});
>, <Line: -	}
>, <Line: -			HTStatusBar.displayMessage("");
>, <Line: -			HTStatusBar.displayMessage("Panel " + (columnIndex + 1) + ": Parse error in filter: " + ex.getMessage());
>, <Line: -		predicate = issue -> Qualifier.process(filter, issue);
>, <Line: -	// triggered
>, <Line: -	// through the text contents of the input area changing.
>, <Line: -					TurboIssue clone = new TurboIssue(issue);
>, <Line: -						dragAndDropExecutor.executeCommand(CommandType.EDIT_ISSUE, model, clone, issue);
>, <Line: -					throw new QualifierApplicationException("Could not apply predicate " + currentFilterExpression
>, <Line: -							+ ".");
>, <Line: -				parentColumnControl.displayMessage(ex.getMessage());
>, <Line: -	/**
>, <Line: -	 * To be overridden by subclasses.
>, <Line: -	 * 
>, <Line: -	 * See docs in Column for refreshItems.
>, <Line: -	 * 
>, <Line: -	 */
>, <Line: -	// deselect is not overriden
>, <Line: -		transformedIssueList = new FilteredList<TurboIssue>(issues, predicate);
>, <Line: -		// If parent issue, sort child issues by depth
>, <Line: -		if (currentFilterExpression instanceof filter.expression.Qualifier) {
>, <Line: -			List<String> names = ((filter.expression.Qualifier) currentFilterExpression).getQualifierNames();
>, <Line: -			if (names.size() == 1 && names.get(0).equals("parent")) {
>, <Line: -				transformedIssueList = new SortedList<>(transformedIssueList, new Comparator<TurboIssue>() {
>, <Line: -					@Override
>, <Line: -					public int compare(TurboIssue a, TurboIssue b) {
>, <Line: -						return a.getDepth() - b.getDepth();
>, <Line: -					}
>, <Line: -				});
>, <Line: -			}
>, <Line: -		}
>]