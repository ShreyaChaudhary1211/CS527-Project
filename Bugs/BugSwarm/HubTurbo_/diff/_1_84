[]
[<Line: -package model;
>, <Line: -import java.io.IOException;
>, <Line: -import java.net.SocketTimeoutException;
>, <Line: -import java.net.UnknownHostException;
>, <Line: -import java.util.*;
>, <Line: -import java.util.concurrent.CompletableFuture;
>, <Line: -import java.util.concurrent.CountDownLatch;
>, <Line: -import java.util.function.BiConsumer;
>, <Line: -import java.util.stream.Collectors;
>, <Line: -import javafx.application.Platform;
>, <Line: -import org.apache.logging.log4j.LogManager;
>, <Line: -import org.apache.logging.log4j.Logger;
>, <Line: -import org.eclipse.egit.github.core.IRepositoryIdProvider;
>, <Line: -import org.eclipse.egit.github.core.Issue;
>, <Line: -import org.eclipse.egit.github.core.Label;
>, <Line: -import org.eclipse.egit.github.core.Milestone;
>, <Line: -import org.eclipse.egit.github.core.RepositoryId;
>, <Line: -import org.eclipse.egit.github.core.User;
>, <Line: -import service.RepositoryResources;
>, <Line: -import service.ServiceManager;
>, <Line: -import service.UpdateSignature;
>, <Line: -import storage.CacheFileHandler;
>, <Line: -import ui.UI;
>, <Line: -import ui.components.HTStatusBar;
>, <Line: -import util.CollectionUtilities;
>, <Line: -import util.DialogMessage;
>, <Line: -import util.events.EventDispatcher;
>, <Line: -import util.events.ModelChangedEvent;
>, <Line: -import com.google.common.eventbus.EventBus;
>, <Line: -/**
>, <Line: - * Aggregates collections of all resources: issues, labels, milestones,
>, <Line: - * users/collaborators. Provides methods to access them, and method for updating
>, <Line: - * them from different sources (cache (Turbo* resource)/GitHub (regular
>, <Line: - * resource)).
>, <Line: - *
>, <Line: - * When modifying this class, it is important that you modify ModelStub as well,
>, <Line: - * to add stub versions of new methods. Platform.runLater should be removed.
>, <Line: - * Other things like network operations or file access may not be needed
>, <Line: - * depending on the intent of the test.
>, <Line: - *
>, <Line: - * TODO use a proper data structure in updateCachedList and get rid of untyped
>, <Line: - * methods
>, <Line: - */
>, <Line: -@SuppressWarnings("unused")
>, <Line: -public class Model {
>, <Line: -	private static final Logger logger = LogManager.getLogger(Model.class.getName());
>, <Line: -	public static boolean isInTestMode = false;
>, <Line: -	private List<TurboIssue> issues = new ArrayList<>();
>, <Line: -	private List<TurboUser> collaborators = new ArrayList<>();
>, <Line: -	private List<TurboLabel> labels = new ArrayList<>();
>, <Line: -	private List<TurboMilestone> milestones = new ArrayList<>();
>, <Line: -	// TODO make final when the model is constructed with this
>, <Line: -	private IRepositoryIdProvider repoId;
>, <Line: -	private CacheFileHandler dcHandler = null;
>, <Line: -	private EventDispatcher eventDispatcher = null;
>, <Line: -	private EventBus testEvents = null;
>, <Line: -	public Model() {
>, <Line: -		if (isInTestMode) {
>, <Line: -			testEvents = new EventBus();
>, <Line: -			// TODO fix tests
>, <Line: -//			eventDispatcher = new ModelEventDispatcherStub(testEvents);
>, <Line: -			eventDispatcher = UI.getInstance();
>, <Line: -		} else {
>, <Line: -			eventDispatcher = UI.getInstance();
>, <Line: -		}
>, <Line: -	}
>, <Line: -	private void ______MODEL_FUNCTIONALITY______() {
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Executes a block of code in the current thread in test mode,
>, <Line: -	 * otherwise executes it on the JavaFX thread.
>, <Line: -	 * @param action
>, <Line: -	 */
>, <Line: -	private void run(Runnable action) {
>, <Line: -		if (isInTestMode) {
>, <Line: -			action.run();
>, <Line: -		} else {
>, <Line: -			Platform.runLater(action);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Notifies subscribers that the model has changed. May be disabled to batch
>, <Line: -	 * a set of changes.
>, <Line: -	 */
>, <Line: -	public void triggerModelChangeEvent() {
>, <Line: -		if (modelChangeCounter == 0) {
>, <Line: -			// TODO in future this should do a deep copy to ensure
>, <Line: -			// that the actual model resources are not mutated
>, <Line: -			eventDispatcher.triggerEvent(new ModelChangedEvent(getIssues(), getMilestones(), getLabels(), getCollaborators()));
>, <Line: -		}
>, <Line: -	}
>, <Line: -	private int modelChangeCounter = 0;
>, <Line: -	public void disableModelChanges() {
>, <Line: -		++modelChangeCounter;
>, <Line: -	}
>, <Line: -	public void enableModelChanges() {
>, <Line: -		--modelChangeCounter;
>, <Line: -	}
>, <Line: -	public IRepositoryIdProvider getRepoId() {
>, <Line: -		return repoId;
>, <Line: -	}
>, <Line: -	// TODO get rid of this
>, <Line: -	public void setRepoId(IRepositoryIdProvider repoId) {
>, <Line: -		this.repoId = repoId;
>, <Line: -	}
>, <Line: -	public void setDataCacheFileHandler(CacheFileHandler dcHandler) {
>, <Line: -		this.dcHandler = dcHandler;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a repository id, downloads its resources from GitHub, then
>, <Line: -	 * populates fields in this class with them.
>, <Line: -	 *
>, <Line: -	 * Does not perform network operations in test mode, and always loads
>, <Line: -	 * stub data from cache.
>, <Line: -	 *
>, <Line: -	 * @param repoId the repository to load
>, <Line: -	 * @param taskUpdate a callback to handle progress updates
>, <Line: -	 * @return true on success, false otherwise
>, <Line: -	 * @throws IOException
>, <Line: -	 */
>, <Line: -	public boolean loadComponents(RepositoryId repoId, BiConsumer<String, Float> taskUpdate) throws IOException {
>, <Line: -		if (isInTestMode) {
>, <Line: -			// TODO will not be needed when the model is constructed with this
>, <Line: -			this.repoId = repoId;
>, <Line: -			// TODO fix tests
>, <Line: -//			populateComponents(repoId, TestUtils.getStubTurboResourcesFromCache(this, 10));
>, <Line: -			return true;
>, <Line: -		}
>, <Line: -		try {
>, <Line: -			RepositoryResources resources = ServiceManager.getInstance().getResources(repoId, taskUpdate);
>, <Line: -			populateComponents(repoId, resources);
>, <Line: -			return true;
>, <Line: -		} catch (SocketTimeoutException e) {
>, <Line: -			Platform.runLater(() -> {
>, <Line: -				DialogMessage.showWarningDialog("Internet Connection is down",
>, <Line: -						"Timeout while loading items from GitHub. Please check your internet connection.");
>, <Line: -			});
>, <Line: -			logger.info("Timeout while loading items from GitHub: " + e.getLocalizedMessage());
>, <Line: -			return false;
>, <Line: -		} catch (UnknownHostException e) {
>, <Line: -			Platform.runLater(() -> {
>, <Line: -				DialogMessage.showWarningDialog("No Internet Connection",
>, <Line: -						"Please check your internet connection and try again");
>, <Line: -			});
>, <Line: -			logger.info("No internet connection: " + e.getLocalizedMessage());
>, <Line: -			return false;
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Downloads the resources of the current repository from GitHub, bypassing
>, <Line: -	 * the cache, then populates the fields of this class with them.
>, <Line: -	 *
>, <Line: -	 * Does not perform network operations in test mode, instead loading stub
>, <Line: -	 * data from cache.
>, <Line: -	 *
>, <Line: -	 * @param taskUpdate a callback to handle progress updates
>, <Line: -	 * @throws IOException
>, <Line: -	 */
>, <Line: -	public void forceReloadComponents(BiConsumer<String, Float> taskUpdate) throws IOException {
>, <Line: -		if (isInTestMode) {
>, <Line: -			// TODO fix tests
>, <Line: -//			populateComponents(repoId, TestUtils.getStubResources(this, 10));
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		RepositoryResources items = ServiceManager.getInstance().getGitHubResources(taskUpdate);
>, <Line: -		populateComponents(repoId, items);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a repository id and a data structure containing resources,
>, <Line: -	 * populates the fields of this class with them
>, <Line: -	 *
>, <Line: -	 * @param repoId
>, <Line: -	 * @param resources
>, <Line: -	 */
>, <Line: -	public void populateComponents(IRepositoryIdProvider repoId, RepositoryResources resources) {
>, <Line: -		this.repoId = repoId;
>, <Line: -		boolean loadedFromCache = resources.isCached();
>, <Line: -		boolean isPublicRepo = resources.isCached()
>, <Line: -			? resources.getTurboUsers().isEmpty()
>, <Line: -			: resources.getUsers().isEmpty();
>, <Line: -		CountDownLatch latch = new CountDownLatch(4);
>, <Line: -		if (loadedFromCache) {
>, <Line: -			loadTurboResources(latch, resources);
>, <Line: -		} else {
>, <Line: -			loadGitHubResources(latch, resources, isPublicRepo);
>, <Line: -		}
>, <Line: -		try {
>, <Line: -			latch.await();
>, <Line: -		} catch (InterruptedException e) {
>, <Line: -			logger.error(e.getLocalizedMessage(), e);
>, <Line: -		}
>, <Line: -		updateCache();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a data structure containing resources loaded from the cache,
>, <Line: -	 * populates the fields of this class with them.
>, <Line: -	 *
>, <Line: -	 * @param turboResources
>, <Line: -	 */
>, <Line: -	private void loadTurboResources(CountDownLatch latch, RepositoryResources turboResources) {
>, <Line: -		run(() -> {
>, <Line: -			disableModelChanges();
>, <Line: -			logger.info("Loading collaborators from cache...");
>, <Line: -			loadTurboCollaborators(turboResources.getTurboUsers());
>, <Line: -			latch.countDown();
>, <Line: -			logger.info("Loading labels from cache...");
>, <Line: -			loadTurboLabels(turboResources.getTurboLabels());
>, <Line: -			latch.countDown();
>, <Line: -			logger.info("Loading milestones from cache...");
>, <Line: -			loadTurboMilestones(turboResources.getTurboMilestones());
>, <Line: -			latch.countDown();
>, <Line: -			List<TurboIssue> issues = turboResources.getTurboIssues();
>, <Line: -			logger.info("Loading issues from cache...");
>, <Line: -			loadTurboIssues(issues);
>, <Line: -			enableModelChanges();
>, <Line: -			triggerModelChangeEvent();
>, <Line: -			latch.countDown();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a data structure containing resources loaded from the cache,
>, <Line: -	 * populates the fields of this class with them.
>, <Line: -	 */
>, <Line: -	private void loadGitHubResources(CountDownLatch latch, RepositoryResources resources, boolean isPublicRepo) {
>, <Line: -		run(() -> {
>, <Line: -			disableModelChanges();
>, <Line: -			if (isPublicRepo) {
>, <Line: -				// We can't get collaborators from a public repo. Remove any collaborators
>, <Line: -				// left over from a previous repo instead.
>, <Line: -				logger.info("Public repo: cannot get collaborators");
>, <Line: -				clearCollaborators();
>, <Line: -			} else {
>, <Line: -				logger.info("Loading collaborators from GitHub...");
>, <Line: -				loadCollaborators(resources.getUsers());
>, <Line: -			}
>, <Line: -			latch.countDown();
>, <Line: -			logger.info("Loading labels from GitHub...");
>, <Line: -			loadLabels(resources.getLabels());
>, <Line: -			latch.countDown();
>, <Line: -			logger.info("Loading milestones from GitHub...");
>, <Line: -			loadMilestones(resources.getMilestones());
>, <Line: -			latch.countDown();
>, <Line: -			logger.info("Loading issues from GitHub...");
>, <Line: -			loadIssues(resources.getIssues());
>, <Line: -			enableModelChanges();
>, <Line: -			triggerModelChangeEvent();
>, <Line: -			latch.countDown();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given two lists of one type of resource (one being the current set, and
>, <Line: -	 * one being the new set), updates the current set with the contents of the
>, <Line: -	 * new set, then writes the current set to cache.
>, <Line: -	 *
>, <Line: -	 * @param list
>, <Line: -	 * @param newList
>, <Line: -	 * @param repoId
>, <Line: -	 */
>, <Line: -	private <T extends TurboResource> void updateCachedList(List<T> list, List<T> newList,
>, <Line: -	                                                        String repoId, CompletableFuture<Integer> response) {
>, <Line: -		if (newList.size() == 0) {
>, <Line: -			// No updates to speak of
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		assert !(newList.get(0) instanceof TurboIssue) : "updatedCachedIssues should be used for issues";
>, <Line: -		HashMap<String, HashSet<T>> changes = CollectionUtilities.getChangesToList(list, newList);
>, <Line: -		HashSet<T> removed = changes.get(CollectionUtilities.REMOVED_TAG);
>, <Line: -		run(() -> {
>, <Line: -			list.removeAll(removed);
>, <Line: -			assert newList.size() > 0;
>, <Line: -			ArrayList<T> buffer = new ArrayList<>();
>, <Line: -			for (T item : newList) {
>, <Line: -				int index = list.indexOf(item);
>, <Line: -				if (index != -1) {
>, <Line: -					T existingItem = list.get(index);
>, <Line: -					existingItem.copyValuesFrom(item);
>, <Line: -				} else {
>, <Line: -					buffer.add(item);
>, <Line: -				}
>, <Line: -			}
>, <Line: -			list.addAll(buffer);
>, <Line: -			response.complete(newList.size());
>, <Line: -		});
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Updates the cache with the provided values for ETags and issueCheckTime
>, <Line: -	 */
>, <Line: -	public void updateCache(UpdateSignature updateSignature) {
>, <Line: -		if (!isInTestMode) {
>, <Line: -			dcHandler.writeToFile(repoId.toString(), updateSignature.issuesETag, updateSignature.labelsETag,
>, <Line: -				updateSignature.milestonesETag, updateSignature.collaboratorsETag,
>, <Line: -				updateSignature.lastCheckTime, collaborators, labels, milestones, issues);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Updates the cache with default values for ETags (nothing) and issueCheckTime (current time)
>, <Line: -	 */
>, <Line: -	public void updateCache() {
>, <Line: -		if (!isInTestMode) {
>, <Line: -			dcHandler.writeToFile(repoId.toString(), null, null, null, null,
>, <Line: -				new Date(), collaborators, labels, milestones, issues);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public void refresh() {
>, <Line: -		ServiceManager.getInstance().updateModelNow();
>, <Line: -	}
>, <Line: -	private void ______ISSUES______() {
>, <Line: -	}
>, <Line: -	public List<TurboIssue> getIssues() {
>, <Line: -		return Collections.unmodifiableList(issues);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a list of Issues, loads them into the issue collection.
>, <Line: -	 * @param ghIssues
>, <Line: -	 */
>, <Line: -	public void loadIssues(List<Issue> ghIssues) {
>, <Line: -		issues = CollectionUtilities.getHubTurboIssueList(ghIssues);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given the id of an issue, returns its index in the issue collection
>, <Line: -	 * TODO change to optional
>, <Line: -	 * TODO index may no longer be applicable if we don't use
>, <Line: -	 * a list to store issues, re-evaluate uses of this method
>, <Line: -	 *
>, <Line: -	 * @param issueId
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public int getIndexOfIssue(int issueId) {
>, <Line: -		assert issueId >= 1 : "Invalid issue with id " + issueId;
>, <Line: -		int i = 0;
>, <Line: -		for (TurboIssue issue : issues) {
>, <Line: -			if (issue.getId() == issueId) {
>, <Line: -				return i;
>, <Line: -			}
>, <Line: -			i++;
>, <Line: -		}
>, <Line: -		return -1;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given the id of a issue, returns a reference to it
>, <Line: -	 * TODO change to optional
>, <Line: -	 *
>, <Line: -	 * @param issueId
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public TurboIssue getIssueWithId(int issueId) {
>, <Line: -		assert issueId >= 1 : "Invalid issue with id " + issueId;
>, <Line: -		for (TurboIssue issue : getIssues()) {
>, <Line: -			if (issue.getId() == issueId) {
>, <Line: -				return issue;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return null;
>, <Line: -	}
>, <Line: -	private void ______CACHED_ISSUES______() {
>, <Line: -	}
>, <Line: -	public void loadTurboIssues(List<TurboIssue> list) {
>, <Line: -		issues.clear();
>, <Line: -		issues.addAll(list);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void appendToCachedIssues(TurboIssue issue) {
>, <Line: -		issues.add(0, issue);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void updateCachedIssues(CompletableFuture<Integer> response, List<Issue> newIssues, String repoId) {
>, <Line: -		if (newIssues.size() == 0) {
>, <Line: -			assert false : "updateCachedIssues should not be called before issues have been loaded";
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		run(() -> {
>, <Line: -			for (int i = newIssues.size() - 1; i >= 0; i--) {
>, <Line: -				Issue issue = newIssues.get(i);
>, <Line: -				TurboIssue newCached = new TurboIssue(issue, Model.this);
>, <Line: -				updateCachedIssue(newCached);
>, <Line: -			}
>, <Line: -			response.complete(newIssues.size());
>, <Line: -		});
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Given a TurboIssue, adds it to the model if it is not yet in it,
>, <Line: -	 * otherwise updates the corresponding issue in the model with its fields.
>, <Line: -	 *
>, <Line: -	 * @param issue
>, <Line: -	 */
>, <Line: -	public void updateCachedIssue(TurboIssue issue) {
>, <Line: -		TurboIssue tIssue = getIssueWithId(issue.getId());
>, <Line: -		if (tIssue != null) {
>, <Line: -			tIssue.copyValuesFrom(issue);
>, <Line: -			logger.info("Updated issue: " + issue.getId());
>, <Line: -		} else {
>, <Line: -			issues.add(0, issue);
>, <Line: -			logger.info("Added issue: " + issue.getId());
>, <Line: -		}
>, <Line: -	}
>, <Line: -	private void ______LABELS______() {
>, <Line: -	}
>, <Line: -	public List<TurboLabel> getLabels() {
>, <Line: -		return Collections.unmodifiableList(labels);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Returns a reference to the TurboLabel given its full name on GitHub.
>, <Line: -	 * TODO change to optional
>, <Line: -	 *
>, <Line: -	 * @param name
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public TurboLabel getLabelByGhName(String name) {
>, <Line: -		for (int i = 0; i < labels.size(); i++) {
>, <Line: -			if (labels.get(i).toGhName().equals(name)) {
>, <Line: -				return labels.get(i);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return null;
>, <Line: -	}
>, <Line: -	public void addLabel(TurboLabel label) {
>, <Line: -		run(() -> {
>, <Line: -			labels.add(label);
>, <Line: -			triggerModelChangeEvent();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Tests to see if all labels of a group are exclusive. If one is not
>, <Line: -	 * exclusive, all are not exclusive.
>, <Line: -	 *
>, <Line: -	 * @param group
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public boolean isExclusiveLabelGroup(String group) {
>, <Line: -		List<TurboLabel> labelsInGrp = labels.stream().filter(l -> group.equals(l.getGroup()))
>, <Line: -				.collect(Collectors.toList());
>, <Line: -		for (TurboLabel label : labelsInGrp) {
>, <Line: -			if (!label.isExclusive()) {
>, <Line: -				return false;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return true;
>, <Line: -	}
>, <Line: -	public void deleteLabel(TurboLabel label) {
>, <Line: -		run(() -> {
>, <Line: -			labels.remove(label);
>, <Line: -			triggerModelChangeEvent();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	public void loadLabels(List<Label> ghLabels) {
>, <Line: -		labels = CollectionUtilities.getHubTurboLabelList(ghLabels);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	private void ______CACHED_LABELS______() {
>, <Line: -	}
>, <Line: -	public void loadTurboLabels(List<TurboLabel> list) {
>, <Line: -		labels = new ArrayList<>(list);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void updateCachedLabels(CompletableFuture<Integer> response, List<Label> ghLabels, String repoId) {
>, <Line: -		ArrayList<TurboLabel> newLabels = CollectionUtilities.getHubTurboLabelList(ghLabels);
>, <Line: -		updateCachedList(labels, newLabels, repoId, response);
>, <Line: -	}
>, <Line: -	private void ______MILESTONES______() {
>, <Line: -	}
>, <Line: -	public List<TurboMilestone> getMilestones() {
>, <Line: -		return Collections.unmodifiableList(milestones);
>, <Line: -	}
>, <Line: -	public void loadMilestones(List<Milestone> ghMilestones) {
>, <Line: -		milestones = CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Returns a reference to the TurboLabel given its title on GitHub.
>, <Line: -	 * TODO change to optional
>, <Line: -	 *
>, <Line: -	 * @param title
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public TurboMilestone getMilestoneByTitle(String title) {
>, <Line: -		for (int i = 0; i < milestones.size(); i++) {
>, <Line: -			if (milestones.get(i).getTitle().equals(title)) {
>, <Line: -				return milestones.get(i);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return null;
>, <Line: -	}
>, <Line: -	public void addMilestone(TurboMilestone milestone) {
>, <Line: -		run(() -> {
>, <Line: -			milestones.add(milestone);
>, <Line: -			triggerModelChangeEvent();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	public void deleteMilestone(TurboMilestone milestone) {
>, <Line: -		run(() -> {
>, <Line: -			milestones.remove(milestone);
>, <Line: -			triggerModelChangeEvent();
>, <Line: -		});
>, <Line: -	}
>, <Line: -	private void ______CACHED_MILESTONES______() {
>, <Line: -	}
>, <Line: -	public void loadTurboMilestones(List<TurboMilestone> list) {
>, <Line: -		milestones.clear();
>, <Line: -		milestones.addAll(list);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void updateCachedMilestones(CompletableFuture<Integer> response,
>, <Line: -	                                   List<Milestone> ghMilestones, String repoId) {
>, <Line: -		ArrayList<TurboMilestone> newMilestones = CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
>, <Line: -		updateCachedList(milestones, newMilestones, repoId, response);
>, <Line: -	}
>, <Line: -	private void ______COLLABORATORS______() {
>, <Line: -	}
>, <Line: -	public void addCollaborator(TurboUser user) {
>, <Line: -		collaborators.add(user);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public List<TurboUser> getCollaborators() {
>, <Line: -		return Collections.unmodifiableList(collaborators);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Returns a reference to a TurboUser given his/her login name on GitHub.
>, <Line: -	 * TODO change to optional TODO make naming of method more consistent, use
>, <Line: -	 * login for one
>, <Line: -	 *
>, <Line: -	 * @param name
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public TurboUser getUserByGhName(String name) {
>, <Line: -		for (int i = 0; i < collaborators.size(); i++) {
>, <Line: -			if (collaborators.get(i).getGithubName().equals(name)) {
>, <Line: -				return collaborators.get(i);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return null;
>, <Line: -	}
>, <Line: -	public void loadCollaborators(List<User> ghCollaborators) {
>, <Line: -		collaborators = CollectionUtilities.getHubTurboUserList(ghCollaborators);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void clearCollaborators() {
>, <Line: -		collaborators.clear();
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	private void ______CACHED_COLLABORATORS______() {
>, <Line: -	}
>, <Line: -	public void loadTurboCollaborators(List<TurboUser> list) {
>, <Line: -		collaborators.clear();
>, <Line: -		collaborators.addAll(list);
>, <Line: -		triggerModelChangeEvent();
>, <Line: -	}
>, <Line: -	public void updateCachedCollaborators(CompletableFuture<Integer> response,
>, <Line: -	                                      List<User> ghCollaborators, String repoId) {
>, <Line: -		ArrayList<TurboUser> newCollaborators = CollectionUtilities.getHubTurboUserList(ghCollaborators);
>, <Line: -		updateCachedList(collaborators, newCollaborators, repoId, response);
>, <Line: -	}
>, <Line: -	private void ______RESOURCE_METADATA______() {
>, <Line: -	}
>, <Line: -	private void ______TESTING______() {
>, <Line: -	}
>, <Line: -	public EventBus getTestEvents() {
>, <Line: -		assert isInTestMode : "This function should not be called outside test mode";
>, <Line: -		return testEvents;
>, <Line: -	}
>, <Line: -	public List<TurboIssue> getIssuesRef() {
>, <Line: -		assert isInTestMode : "This function should not be called outside test mode";
>, <Line: -		return issues;
>, <Line: -	}
>, <Line: -	public List<TurboUser> getCollaboratorsRef() {
>, <Line: -		assert isInTestMode : "This function should not be called outside test mode";
>, <Line: -		return collaborators;
>, <Line: -	}
>, <Line: -	public List<TurboLabel> getLabelsRef() {
>, <Line: -		assert isInTestMode : "This function should not be called outside test mode";
>, <Line: -		return labels;
>, <Line: -	}
>, <Line: -	public List<TurboMilestone> getMilestonesRef() {
>, <Line: -		assert isInTestMode : "This function should not be called outside test mode";
>, <Line: -		return milestones;
>, <Line: -	}
>, <Line: -}
>]