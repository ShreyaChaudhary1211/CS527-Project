[<Line: +import org.sonar.php.checks.utils.TokenVisitor;
>, <Line: +import org.sonar.php.tree.impl.PHPTree;
>, <Line: +import org.sonar.plugins.php.api.tree.ScriptTree;
>, <Line: +import org.sonar.plugins.php.api.tree.Tree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.FunctionDeclarationTree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.MethodDeclarationTree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.ParameterListTree;
>, <Line: +import org.sonar.plugins.php.api.tree.expression.FunctionCallTree;
>, <Line: +import org.sonar.plugins.php.api.tree.expression.FunctionExpressionTree;
>, <Line: +import org.sonar.plugins.php.api.tree.expression.LexicalVariablesTree;
>, <Line: +import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
>, <Line: +import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import java.util.List;
>, <Line: +public class FunctionSpacingCheck extends PHPVisitorCheck implements FormattingCheck {
>, <Line: +  private static final String METHOD_NAME_SPACES_MESSAGE = "Remove all space between the method name \"%s\" and the opening parenthesis.";
>, <Line: +  private static final String CLOSURE_SPACES_MESSAGE = "Put exactly one space between the \"function\" keyword and the opening parenthesis.";
>, <Line: +  private static final String CLOSURE_LEXICAL_VARS_SPACES_MESSAGE = "Put exactly one space before and after the \"use\" keyword.";
>, <Line: +  private static final String[] COMMA_SPACES_MESSAGE = {
>, <Line: +    "Remove any space before comma separated arguments.",
>, <Line: +    "Put exactly one space after comma separated arguments.",
>, <Line: +    "Remove any space before comma separated arguments and put exactly one space after comma separated arguments."
>, <Line: +  };
>, <Line: +  private FormattingStandardCheck check;
>, <Line: +  @Override
>, <Line: +  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
>, <Line: +    this.check = formattingCheck;
>, <Line: +    super.visitScript(scriptTree);
>, <Line: +  @Override
>, <Line: +  public void visitParameterList(ParameterListTree tree) {
>, <Line: +    checkSpaceForComma(new TokenVisitor(tree), tree.parameters().getSeparators(), tree);
>, <Line: +    super.visitParameterList(tree);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionCall(FunctionCallTree tree) {
>, <Line: +    if (!check.isInternalFunction(tree.callee())) {
>, <Line: +      checkSpaceForComma(new TokenVisitor(tree), tree.arguments().getSeparators(), tree.openParenthesisToken());
>, <Line: +      checkSpaceAfterFunctionName(((PHPTree) tree.callee()).getLastToken(), tree.openParenthesisToken());
>, <Line: +    super.visitFunctionCall(tree);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitMethodDeclaration(MethodDeclarationTree tree) {
>, <Line: +    checkSpaceAfterFunctionName(tree.name().token(), tree.parameters().openParenthesisToken());
>, <Line: +    super.visitMethodDeclaration(tree);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
>, <Line: +    checkSpaceAfterFunctionName(tree.name().token(), tree.parameters().openParenthesisToken());
>, <Line: +    super.visitFunctionDeclaration(tree);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionExpression(FunctionExpressionTree tree) {
>, <Line: +    checkClosureSpacing(tree.functionToken(), tree.parameters(), tree.lexicalVars());
>, <Line: +    super.visitFunctionExpression(tree);
>, <Line: +  }
>, <Line: +  private void checkClosureSpacing(SyntaxToken functionKeyword, ParameterListTree parameters, @Nullable LexicalVariablesTree lexicalVars) {
>, <Line: +    if (check.isClosureSpacing) {
>, <Line: +      if (TokenUtils.getNbSpaceBetween(functionKeyword, parameters.openParenthesisToken()) != 1) {
>, <Line: +        check.reportIssue(CLOSURE_SPACES_MESSAGE, functionKeyword);
>, <Line: +      }
>, <Line: +      if (lexicalVars != null) {
>, <Line: +        int spaceBeforeUse = TokenUtils.getNbSpaceBetween(parameters.closeParenthesisToken(), lexicalVars.useToken());
>, <Line: +        int spaceAfterUse = TokenUtils.getNbSpaceBetween(lexicalVars.useToken(), lexicalVars.openParenthesisToken());
>, <Line: +        if (spaceBeforeUse != 1 || spaceAfterUse != 1) {
>, <Line: +          check.reportIssue(CLOSURE_LEXICAL_VARS_SPACES_MESSAGE, lexicalVars);
>, <Line: +        }
>, <Line: +      }
>, <Line: +  private void checkSpaceAfterFunctionName(SyntaxToken functionName, SyntaxToken openParenthesis) {
>, <Line: +    if (check.isNoSpaceAfterMethodName && TokenUtils.getNbSpaceBetween(functionName, openParenthesis) != 0) {
>, <Line: +      check.reportIssue(String.format(METHOD_NAME_SPACES_MESSAGE, functionName.text()), functionName);
>, <Line: +  private void checkSpaceForComma(TokenVisitor tokenVisitor, List<SyntaxToken> commas, Tree tree) {
>, <Line: +    if (check.isOneSpaceAfterComma) {
>, <Line: +      for (SyntaxToken commaToken : commas) {
>, <Line: +        SyntaxToken nextToken = tokenVisitor.nextToken(commaToken);
>, <Line: +        SyntaxToken previousToken = tokenVisitor.prevToken(commaToken);
>, <Line: +        if (TokenUtils.isOnSameLine(previousToken, commaToken, nextToken)) {
>, <Line: +          boolean isSpaceBeforeOK = TokenUtils.getNbSpaceBetween(previousToken, commaToken) == 0;
>, <Line: +          boolean isSpaceAfterOK = TokenUtils.getNbSpaceBetween(commaToken, nextToken) == 1;
>, <Line: +          if (!isSpaceBeforeOK && isSpaceAfterOK && msgIndex < 0) {
>, <Line: +            msgIndex = 0;
>, <Line: +          } else if (isSpaceBeforeOK && !isSpaceAfterOK && msgIndex < 0) {
>, <Line: +            msgIndex = 1;
>, <Line: +          } else if (!isSpaceBeforeOK && !isSpaceAfterOK) {
>, <Line: +            msgIndex = 2;
>, <Line: +            break;
>, <Line: +          }
>, <Line: +      if (msgIndex > -1) {
>, <Line: +        check.reportIssue(COMMA_SPACES_MESSAGE[msgIndex], tree);
>, <Line: +      }
>]
[<Line: -import com.sonar.sslr.api.AstNode;
>, <Line: -import com.sonar.sslr.api.Token;
>, <Line: -import org.sonar.php.api.PHPKeyword;
>, <Line: -import org.sonar.php.api.PHPPunctuator;
>, <Line: -import org.sonar.php.parser.PHPGrammar;
>, <Line: -public class FunctionSpacingCheck extends SpacingCheck {
>, <Line: -  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    if (formattingCheck.isOneSpaceAfterComma && node.is(PHPGrammar.PARAMETER_LIST, PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
>, <Line: -      checkSpaceForComma(formattingCheck, node);
>, <Line: -    }
>, <Line: -    if (formattingCheck.isNoSpaceAfterMethodName && node.is(PHPGrammar.FUNCTION_DECLARATION, PHPGrammar.METHOD_DECLARATION, PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
>, <Line: -      checkSpaceAfterFunctionName(formattingCheck, node);
>, <Line: -    }
>, <Line: -    if (formattingCheck.isClosureSpacing && node.is(PHPGrammar.FUNCTION_EXPRESSION)) {
>, <Line: -      checkClosureSpacing(formattingCheck, node);
>, <Line: -    }
>, <Line: -  private void checkClosureSpacing(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    Token lParenToken = node.getFirstChild(PHPPunctuator.LPARENTHESIS).getToken();
>, <Line: -    Token functionKeyword = node.getFirstChild(PHPKeyword.FUNCTION).getToken();
>, <Line: -    if (getNbSpaceBetween(functionKeyword, lParenToken) != 1) {
>, <Line: -      formattingCheck.reportIssue("Put exactly one space between the \"function\" keyword and the opening parenthesis.", node);
>, <Line: -    AstNode lexicalVars = node.getFirstChild(PHPGrammar.LEXICAL_VARS);
>, <Line: -    if (lexicalVars != null && !isSpaceAround(lexicalVars.getFirstChild(PHPKeyword.USE), 1 /* space before */, 1 /* space after */)) {
>, <Line: -      formattingCheck.reportIssue("Put exactly one space before and after the \"use\" keyword.", lexicalVars);
>, <Line: -  private void checkSpaceAfterFunctionName(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    Token lParenToken = node.getFirstChild(PHPPunctuator.LPARENTHESIS).getToken();
>, <Line: -    Token funcNameToken = node.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST) ?
>, <Line: -      node.getPreviousAstNode().getLastToken() : node.getFirstChild(PHPGrammar.IDENTIFIER).getToken();
>, <Line: -    if (getNbSpaceBetween(funcNameToken, lParenToken) != 0) {
>, <Line: -      formattingCheck.reportIssue("Remove all space between the method name \"" + funcNameToken.getOriginalValue() + "\" and the opening parenthesis.", node);
>, <Line: -  private void checkSpaceForComma(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    String[] msg = {
>, <Line: -      "Remove any space before comma separated arguments.",
>, <Line: -      "Put exactly one space after comma separated arguments.",
>, <Line: -      "Remove any space before comma separated arguments and put exactly one space after comma separated arguments."
>, <Line: -    };
>, <Line: -    for (AstNode comma : node.getChildren(PHPPunctuator.COMMA)) {
>, <Line: -      Token commaToken = comma.getToken();
>, <Line: -      Token nextToken = comma.getNextSibling().getToken();
>, <Line: -      Token previousToken = comma.getPreviousSibling().getLastToken();
>, <Line: -      if (isOnSameLine(previousToken, commaToken, nextToken)) {
>, <Line: -        boolean isSpaceBeforeOK = getNbSpaceBetween(previousToken, commaToken) == 0;
>, <Line: -        boolean isSpaceAfterOK = getNbSpaceBetween(commaToken, nextToken) == 1;
>, <Line: -        if (!isSpaceBeforeOK && isSpaceAfterOK && msgIndex < 0) {
>, <Line: -          msgIndex = 0;
>, <Line: -        } else if (isSpaceBeforeOK && !isSpaceAfterOK && msgIndex < 0) {
>, <Line: -          msgIndex = 1;
>, <Line: -        } else if (!isSpaceBeforeOK && !isSpaceAfterOK) {
>, <Line: -          msgIndex = 2;
>, <Line: -          break;
>, <Line: -    }
>, <Line: -    if (msgIndex > -1) {
>, <Line: -      formattingCheck.reportIssue(msg[msgIndex], node);
>]