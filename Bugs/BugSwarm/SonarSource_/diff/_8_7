[<Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import org.sonar.php.tree.impl.PHPTree;
>, <Line: +import org.sonar.plugins.php.api.tree.ScriptTree;
>, <Line: +import org.sonar.plugins.php.api.tree.SeparatedList;
>, <Line: +import org.sonar.plugins.php.api.tree.Tree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.ClassDeclarationTree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.FunctionDeclarationTree;
>, <Line: +import org.sonar.plugins.php.api.tree.declaration.MethodDeclarationTree;
>, <Line: +import org.sonar.plugins.php.api.tree.expression.FunctionCallTree;
>, <Line: +import org.sonar.plugins.php.api.tree.expression.FunctionExpressionTree;
>, <Line: +import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
>, <Line: +import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import java.util.HashMap;
>, <Line: +import java.util.Map;
>, <Line: +public class IndentationCheck extends PHPVisitorCheck implements FormattingCheck {
>, <Line: +  private static final String ARGUMENT_LINE_SPLIT_MESSAGE =
>, <Line: +    "Either split this list into multiple lines, aligned at column \"%s\" or put all arguments on line \"%s\".";
>, <Line: +  private static final String ARGUMENT_INDENTATION_MESSAGE = "Align all arguments in this list at column \"%s\".";
>, <Line: +  private static final String FUNCTION_CALL_PARENTHESIS_MESSAGE = "Move the closing parenthesis on the next line.";
>, <Line: +  private static final String FUNCTION_DEC_PARENTHESIS_MESSAGE = "Move the closing parenthesis with the opening brace on the next line.";
>, <Line: +  private static final String INTERFACE_SPLIT_MESSAGE = "Either split this list into multiple lines or move it on the same line \"%s\".";
>, <Line: +  private static final String INTERFACE_INDENTATION = "Align all interfaces in this list at column \"%s\".";
>, <Line: +  private FormattingStandardCheck check;
>, <Line: +  private Map<Integer, Integer> startColumnByLine = new HashMap<>();
>, <Line: +  @Override
>, <Line: +  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
>, <Line: +    this.check = formattingCheck;
>, <Line: +    this.startColumnByLine.clear();
>, <Line: +    super.visitScript(scriptTree);
>, <Line: +  }
>, <Line: +  public void visitToken(SyntaxToken token) {
>, <Line: +    if (startColumnByLine.get(token.line()) == null) {
>, <Line: +      startColumnByLine.put(token.line(), token.column());
>, <Line: +    super.visitToken(token);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionCall(FunctionCallTree tree) {
>, <Line: +    super.visitFunctionCall(tree);
>, <Line: +    if (check.isFunctionCallsArgumentsIndentation && !check.isInternalFunction(tree.callee())) {
>, <Line: +      SyntaxToken calleeLastToken = ((PHPTree) tree.callee()).getLastToken();
>, <Line: +      checkArgumentsIndentation(
>, <Line: +        tree.arguments(),
>, <Line: +        calleeLastToken,
>, <Line: +        startColumnForLine(calleeLastToken.line()),
>, <Line: +        tree.closeParenthesisToken(), true);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
>, <Line: +    super.visitFunctionDeclaration(tree);
>, <Line: +    if (check.isMethodArgumentsIndentation) {
>, <Line: +      checkArgumentsIndentation(
>, <Line: +        tree.parameters().parameters(),
>, <Line: +        tree.name().token(),
>, <Line: +        startColumnForLine(tree.functionToken().line()),
>, <Line: +        tree.parameters().closeParenthesisToken(), false);
>, <Line: +  @Override
>, <Line: +  public void visitMethodDeclaration(MethodDeclarationTree tree) {
>, <Line: +    super.visitMethodDeclaration(tree);
>, <Line: +    if (check.isMethodArgumentsIndentation) {
>, <Line: +      checkArgumentsIndentation(
>, <Line: +        tree.parameters().parameters(),
>, <Line: +        tree.name().token(),
>, <Line: +        startColumnForLine(tree.functionToken().line()),
>, <Line: +        (tree.parameters().closeParenthesisToken()), false);
>, <Line: +    }
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitFunctionExpression(FunctionExpressionTree tree) {
>, <Line: +    super.visitFunctionExpression(tree);
>, <Line: +    if (check.isMethodArgumentsIndentation) {
>, <Line: +      checkArgumentsIndentation(
>, <Line: +        tree.parameters().parameters(),
>, <Line: +        tree.functionToken(),
>, <Line: +        startColumnForLine(tree.functionToken().line()),
>, <Line: +        (tree.parameters().closeParenthesisToken()), false);
>, <Line: +    }
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitClassDeclaration(ClassDeclarationTree tree) {
>, <Line: +    super.visitClassDeclaration(tree);
>, <Line: +    checkImplementListIndentation(tree);
>, <Line: +  }
>, <Line: +  private void checkImplementListIndentation(ClassDeclarationTree classTree) {
>, <Line: +    if (check.isInterfacesIndentation && classTree.is(Tree.Kind.CLASS_DECLARATION) && !classTree.superInterfaces().isEmpty()) {
>, <Line: +      List<Tree> interfaceList = ImmutableList.<Tree>copyOf(classTree.superInterfaces());
>, <Line: +      SyntaxToken classToken = classTree.classEntryTypeToken();
>, <Line: +      SyntaxToken lastInterfaceToken = ((PHPTree) Iterables.getLast(classTree.superInterfaces())).getFirstToken();
>, <Line: +      int expectedColumn = classToken.column() + PSR2_INDENTATION;
>, <Line: +      if (!TokenUtils.isOnSameLine(classToken, lastInterfaceToken)) {
>, <Line: +        if (!isCorrectlySplitOnLines(classToken.line(), interfaceList)) {
>, <Line: +          check.reportIssue(String.format(INTERFACE_SPLIT_MESSAGE, classToken.line()), classTree.superInterfaces().get(0));
>, <Line: +          check.reportIssue(String.format(INTERFACE_INDENTATION, expectedColumn), classTree.superInterfaces().get(0));
>, <Line: +  private void checkArgumentsIndentation(SeparatedList arguments, SyntaxToken functionName, int baseColumn, @Nullable SyntaxToken closeParenthesis, boolean isFunctionCall) {
>, <Line: +      SyntaxToken lastArg = ((PHPTree) Iterables.getLast(arguments)).getLastToken();
>, <Line: +      Tree firstArg = (Tree) arguments.get(0);
>, <Line: +      int expectedIndentationColumn = baseColumn + PSR2_INDENTATION;
>, <Line: +      int callingLine = functionName.line();
>, <Line: +      if (!TokenUtils.isOnSameLine(functionName, lastArg)) {
>, <Line: +        if (!isCorrectlySplitOnLines(callingLine, arguments)) {
>, <Line: +          check.reportIssue(String.format(ARGUMENT_LINE_SPLIT_MESSAGE, expectedIndentationColumn, callingLine), firstArg);
>, <Line: +          check.reportIssue(String.format(ARGUMENT_INDENTATION_MESSAGE, expectedIndentationColumn), firstArg);
>, <Line: +        // Checking parenthesis
>, <Line: +        if (closeParenthesis != null) {
>, <Line: +          checkClosingParenthesisLocation((Tree) Iterables.getLast(arguments), closeParenthesis, isFunctionCall);
>, <Line: +        }
>, <Line: +      }
>, <Line: +  private void checkClosingParenthesisLocation(Tree lastArgument, SyntaxToken closeParenthesis, boolean isFunctionCall) {
>, <Line: +    if (!((PHPTree) lastArgument).getLastToken().text().equals(PHPPunctuator.RPARENTHESIS.getValue()) && TokenUtils.isOnSameLine(((PHPTree) lastArgument).getLastToken(), closeParenthesis)) {
>, <Line: +      check.reportIssue(
>, <Line: +        isFunctionCall ? FUNCTION_CALL_PARENTHESIS_MESSAGE : FUNCTION_DEC_PARENTHESIS_MESSAGE,
>, <Line: +        closeParenthesis);
>, <Line: +  private boolean isCorrectlyIndented(int expectedColumn, List<Tree> items) {
>, <Line: +    for (Tree item : items) {
>, <Line: +      if (((PHPTree) item).getFirstToken().column() != expectedColumn) {
>, <Line: +  private boolean isCorrectlySplitOnLines(int referenceLine, List<Tree> items) {
>, <Line: +    for (Tree item : items) {
>, <Line: +      if (((PHPTree) item).getFirstToken().line() < expectedLine) {
>, <Line: +  private int startColumnForLine(int line) {
>, <Line: +    return startColumnByLine.get(line);
>, <Line: +  }
>]
[<Line: -import com.sonar.sslr.api.AstNode;
>, <Line: -import com.sonar.sslr.api.AstNodeType;
>, <Line: -import com.sonar.sslr.api.Token;
>, <Line: -import org.sonar.php.parser.PHPGrammar;
>, <Line: -public class IndentationCheck extends SpacingCheck {
>, <Line: -  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    if (formattingCheck.isFunctionCallsArgumentsIndentation && node.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
>, <Line: -      checkArgumentsIndentation(formattingCheck, node, PHPGrammar.PARAMETER_LIST_FOR_CALL);
>, <Line: -    if (formattingCheck.isMethodArgumentsIndentation && node.is(PHPGrammar.PARAMETER_LIST)) {
>, <Line: -      checkArgumentsIndentation(formattingCheck, node, PHPGrammar.PARAMETER);
>, <Line: -    if (formattingCheck.isInterfacesIndentation && node.is(PHPGrammar.CLASS_DECLARATION)) {
>, <Line: -      checkImplementListIndentation(formattingCheck, node);
>, <Line: -  private void checkImplementListIndentation(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    AstNode implementList = node.getFirstChild(PHPGrammar.IMPLEMENTS_LIST);
>, <Line: -    if (implementList != null) {
>, <Line: -      List<AstNode> interfaceList = implementList.getFirstChild(PHPGrammar.INTERFACE_LIST).getChildren(PHPGrammar.FULLY_QUALIFIED_CLASS_NAME);
>, <Line: -      int classDecLine = node.getTokenLine();
>, <Line: -      int expectedColumn = getLineStartingColumn(node) + PSR2_INDENTATION;
>, <Line: -      if (!isOnSameLine(node.getToken(), Iterables.getLast(interfaceList).getToken())) {
>, <Line: -        if (!isCorrectlySplittedOnLines(classDecLine, interfaceList)) {
>, <Line: -          formattingCheck.reportIssue("Either split this list into multiple lines or move it on the same line \"" + classDecLine + "\".",
>, <Line: -            interfaceList.get(0));
>, <Line: -          formattingCheck.reportIssue("Align all interfaces in this list at column \"" + expectedColumn + "\".", interfaceList.get(0));
>, <Line: -  private void checkArgumentsIndentation(FormattingStandardCheck formattingCheck, AstNode node, AstNodeType parameterNodeType) {
>, <Line: -    List<AstNode> arguments = node.getChildren(parameterNodeType);
>, <Line: -      Token lastParam = Iterables.getLast(arguments).getLastToken();
>, <Line: -      AstNode methodName = node.getPreviousAstNode();
>, <Line: -      AstNode firstParam = arguments.get(0);
>, <Line: -      int expectedIndentationColumn = getLineStartingColumn(node.getParent()) + PSR2_INDENTATION;
>, <Line: -      int callingLine = methodName.getTokenLine();
>, <Line: -      if (!isOnSameLine(methodName.getToken(), lastParam)) {
>, <Line: -        if (!isCorrectlySplittedOnLines(callingLine, arguments)) {
>, <Line: -          formattingCheck.reportIssue("Either split this list into multiple lines, aligned at column \""
>, <Line: -            + expectedIndentationColumn + "\" or put all arguments on line \""
>, <Line: -            + callingLine + "\".", firstParam);
>, <Line: -          formattingCheck.reportIssue("Align all arguments in this list at column \"" + expectedIndentationColumn + "\".", firstParam);
>, <Line: -        checkClosingParenthesisLocation(formattingCheck, node, lastParam);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  private void checkClosingParenthesisLocation(FormattingStandardCheck formattingCheck, AstNode paramList, Token lastParam) {
>, <Line: -    AstNode rParenthesis;
>, <Line: -    String msg;
>, <Line: -    if (paramList.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
>, <Line: -      rParenthesis = paramList.getFirstChild(PHPPunctuator.RPARENTHESIS);
>, <Line: -      msg = "Move the closing parenthesis on the next line.";
>, <Line: -    } else {
>, <Line: -      rParenthesis = paramList.getParent().getFirstChild(PHPPunctuator.RPARENTHESIS);
>, <Line: -      msg = "Move the closing parenthesis with the opening brace on the next line.";
>, <Line: -    }
>, <Line: -    if (!lastParam.getType().equals(PHPPunctuator.RPARENTHESIS) && isOnSameLine(lastParam, rParenthesis.getToken())) {
>, <Line: -      formattingCheck.reportIssue(msg, rParenthesis);
>, <Line: -  private int getLineStartingColumn(AstNode node) {
>, <Line: -    int line = node.getTokenLine();
>, <Line: -    AstNode previousNode = node.getPreviousAstNode();
>, <Line: -    int column = node.getToken().getColumn();
>, <Line: -    while (previousNode != null && previousNode.getToken().getLine() == line) {
>, <Line: -      column = previousNode.getToken().getColumn();
>, <Line: -      previousNode = previousNode.getParent();
>, <Line: -    return column;
>, <Line: -  private boolean isCorrectlyIndented(int expectedColumn, List<AstNode> items) {
>, <Line: -    for (AstNode item : items) {
>, <Line: -      if (item.getToken().getColumn() != expectedColumn) {
>, <Line: -  private boolean isCorrectlySplittedOnLines(int referenceLine, List<AstNode> items) {
>, <Line: -    for (AstNode item : items) {
>, <Line: -      if (item.getTokenLine() < expectedLine) {
>]