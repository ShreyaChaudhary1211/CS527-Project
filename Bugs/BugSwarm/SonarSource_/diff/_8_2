[<Line: +import com.google.common.collect.ImmutableList;
>, <Line: +import org.sonar.php.checks.utils.TokenVisitor;
>, <Line: +import org.sonar.php.tree.impl.PHPTree;
>, <Line: +import org.sonar.plugins.php.api.tree.ScriptTree;
>, <Line: +import org.sonar.plugins.php.api.tree.Tree;
>, <Line: +import org.sonar.plugins.php.api.tree.Tree.Kind;
>, <Line: +import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
>, <Line: +import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
>, <Line: +import org.sonar.plugins.php.api.tree.statement.TryStatementTree;
>, <Line: +import org.sonar.plugins.php.api.visitors.PHPSubscriptionCheck;
>, <Line: +import javax.annotation.Nullable;
>, <Line: +import java.util.Iterator;
>, <Line: +import java.util.List;
>, <Line: +public class ControlStructureSpacingCheck extends PHPSubscriptionCheck implements FormattingCheck {
>, <Line: +  private static final String CONTROL_STRUCTURES_KEYWORD_MESSAGE = "between this \"%s\" keyword and the opening %s";
>, <Line: +  private static final String FOR_SEMICOLON_MESSAGE = "Put exactly one space after each \";\" character in the \"for\" statement.";
>, <Line: +  private static final String FOREACH_MESSAGE = "Put exactly one space after and before %s in \"foreach\" statement.";
>, <Line: +  private static final Kind[] CONTROL_STRUCTURES = {
>, <Line: +    Kind.IF_STATEMENT,
>, <Line: +    Kind.ELSEIF_CLAUSE,
>, <Line: +    Kind.ELSE_CLAUSE,
>, <Line: +    Kind.DO_WHILE_STATEMENT,
>, <Line: +    Kind.WHILE_STATEMENT,
>, <Line: +    Kind.FOR_STATEMENT,
>, <Line: +    Kind.FOREACH_STATEMENT,
>, <Line: +    Kind.SWITCH_STATEMENT,
>, <Line: +    Kind.TRY_STATEMENT,
>, <Line: +    Kind.CATCH_BLOCK
>, <Line: +  };
>, <Line: +  private FormattingStandardCheck check;
>, <Line: +  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
>, <Line: +    this.check = formattingCheck;
>, <Line: +    this.scanTree(scriptTree);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public List<Kind> nodesToVisit() {
>, <Line: +    return ImmutableList.copyOf(CONTROL_STRUCTURES);
>, <Line: +  }
>, <Line: +  @Override
>, <Line: +  public void visitNode(Tree tree) {
>, <Line: +    if (check.isOneSpaceBetweenKeywordAndNextToken) {
>, <Line: +      checkSpaceBetweenKeywordAndNextNode(new TokenVisitor(tree), tree);
>, <Line: +    if (check.isOneSpaceAfterForLoopSemicolon && tree.is(Kind.FOR_STATEMENT)) {
>, <Line: +      checkSpaceForStatement(tree);
>, <Line: +    if (check.isSpaceForeachStatement && tree.is(Kind.FOREACH_STATEMENT)) {
>, <Line: +      ForEachStatementTree foreachLoop = (ForEachStatementTree) tree;
>, <Line: +      checkForeachStatement(new TokenVisitor(tree), foreachLoop, foreachLoop.asToken(), foreachLoop.doubleArrowToken());
>, <Line: +  private void checkForeachStatement(TokenVisitor tokenVisitor, ForEachStatementTree foreachLoop, SyntaxToken asKeyword, @Nullable SyntaxToken doubleArrow) {
>, <Line: +    boolean isSpaceCorrectAs = isExactlyOneSpaceAround(tokenVisitor, asKeyword);
>, <Line: +    boolean isSpaceCorrectDoubleArrow = doubleArrow == null || isExactlyOneSpaceAround(tokenVisitor, doubleArrow);
>, <Line: +    String messageDetail = null;
>, <Line: +      messageDetail = "\"as\"";
>, <Line: +      messageDetail = "\"=>\"";
>, <Line: +     messageDetail = "\"as\" and \"=>\"";
>, <Line: +    if (messageDetail != null) {
>, <Line: +      check.reportIssue(String.format(FOREACH_MESSAGE, messageDetail), foreachLoop);
>, <Line: +  private static boolean isExactlyOneSpaceAround(TokenVisitor tokenVisitor, SyntaxToken token) {
>, <Line: +    return TokenUtils.getNbSpaceBetween(tokenVisitor.prevToken(token), token) == 1
>, <Line: +      && TokenUtils.getNbSpaceBetween(token,tokenVisitor.nextToken(token)) == 1;
>, <Line: +  }
>, <Line: +  private void checkSpaceForStatement(Tree tree) {
>, <Line: +    Iterator<Tree> iterator = ((PHPTree) tree).childrenIterator();
>, <Line: +    Tree next;
>, <Line: +    Tree previous = null;
>, <Line: +    while (iterator.hasNext()) {
>, <Line: +      next = iterator.next();
>, <Line: +      if (isSemicolon(previous)) {
>, <Line: +        SyntaxToken semicolonToken = (SyntaxToken) previous;
>, <Line: +        SyntaxToken nextToken = ((PHPTree) next).getFirstToken();
>, <Line: +        int nbSpace = TokenUtils.getNbSpaceBetween(semicolonToken, nextToken);
>, <Line: +        if (nbSpace != 1 && TokenUtils.isOnSameLine(semicolonToken, nextToken)) {
>, <Line: +          check.reportIssue(FOR_SEMICOLON_MESSAGE, tree);
>, <Line: +          break;
>, <Line: +        }
>, <Line: +      previous = next;
>, <Line: +  }
>, <Line: +  private static boolean isSemicolon(@Nullable Tree tree) {
>, <Line: +    return tree != null && tree.is(Kind.TOKEN) && TokenUtils.isType((SyntaxToken) tree, PHPPunctuator.SEMICOLON);
>, <Line: +  }
>, <Line: +  private void checkSpaceBetweenKeywordAndNextNode(TokenVisitor tokenVisitor, Tree tree) {
>, <Line: +    SyntaxToken keyword = tokenVisitor.tokenByValue(PHPKeyword.getKeywordValues());
>, <Line: +    if (tree.is(Kind.TRY_STATEMENT)) {
>, <Line: +      TryStatementTree tryStatement = (TryStatementTree) tree;
>, <Line: +      if (tryStatement.finallyToken() != null) {
>, <Line: +        SyntaxToken finallyKeyword = tryStatement.finallyToken();
>, <Line: +        checkSpaceBetweenKeywordAndNextNode(finallyKeyword, tokenVisitor.nextToken(finallyKeyword));
>, <Line: +      }
>, <Line: +    checkSpaceBetweenKeywordAndNextNode(keyword, tokenVisitor.nextToken(keyword));
>, <Line: +  private void checkSpaceBetweenKeywordAndNextNode(SyntaxToken keyword, SyntaxToken nextToken) {
>, <Line: +    if (TokenUtils.isType(nextToken, PHPPunctuator.LCURLYBRACE, PHPPunctuator.LPARENTHESIS) && TokenUtils.isOnSameLine(keyword, nextToken)) {
>, <Line: +      int nbSpace = TokenUtils.getNbSpaceBetween(keyword, nextToken);
>, <Line: +        String endMessage = String.format(
>, <Line: +          CONTROL_STRUCTURES_KEYWORD_MESSAGE,
>, <Line: +          keyword.text(),
>, <Line: +          TokenUtils.isType(nextToken, PHPPunctuator.LPARENTHESIS) ? "parenthesis." : "curly brace.");
>, <Line: +        check.reportIssue(TokenUtils.buildIssueMsg(nbSpace, endMessage), keyword);
>]
[<Line: -import com.sonar.sslr.api.AstNode;
>, <Line: -import com.sonar.sslr.api.Token;
>, <Line: -import org.sonar.php.parser.PHPGrammar;
>, <Line: -public class ControlStructureSpacingCheck extends SpacingCheck {
>, <Line: -  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    if (formattingCheck.isOneSpaceBetweenKeywordAndNextToken && node.is(FormattingStandardCheck.getControlStructureNodes())) {
>, <Line: -      checkSpaceBetweenKeywordAndNextNode(formattingCheck, node);
>, <Line: -    if (formattingCheck.isOneSpaceAfterForLoopSemicolon && node.is(PHPGrammar.FOR_STATEMENT)) {
>, <Line: -      checkSpaceForStatement(formattingCheck, node);
>, <Line: -    if (formattingCheck.isSpaceForeachStatement && node.is(PHPGrammar.FOREACH_STATEMENT)) {
>, <Line: -      checkForeachStatement(formattingCheck, node);
>, <Line: -  private void checkForeachStatement(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    AstNode foreachExpr = node.getFirstChild(PHPGrammar.FOREACH_EXPR);
>, <Line: -    AstNode asKeyword = foreachExpr.getFirstChild(PHPKeyword.AS);
>, <Line: -    AstNode doubleArrow = foreachExpr.getFirstChild(PHPPunctuator.DOUBLEARROW);
>, <Line: -    boolean isSpaceCorrectAs = isSpaceAround(asKeyword, 1 /* space before*/, 1/* space after */);
>, <Line: -    boolean isSpaceCorrectDoubleArrow = doubleArrow == null || isSpaceAround(doubleArrow, 1/* space before*/, 1/* space after */);
>, <Line: -    String keyword = null;
>, <Line: -      keyword = "\"" + asKeyword.getTokenOriginalValue() + "\"";
>, <Line: -      keyword = "\"" + doubleArrow.getTokenOriginalValue() + "\"";
>, <Line: -      keyword = "\"" + asKeyword.getTokenOriginalValue() + "\" and \"" + doubleArrow.getTokenOriginalValue() + "\"";
>, <Line: -    if (keyword != null) {
>, <Line: -      formattingCheck.reportIssue("Put exactly one space after and before " + keyword + " in \"foreach\" statement.", node);
>, <Line: -  private void checkSpaceForStatement(FormattingStandardCheck formattingCheck, AstNode node) {
>, <Line: -    boolean shouldReportIssue = false;
>, <Line: -    for (AstNode semicolon : node.getChildren(PHPPunctuator.SEMICOLON)) {
>, <Line: -      Token semicolonToken = semicolon.getToken();
>, <Line: -      Token nextToken = semicolon.getNextAstNode().getToken();
>, <Line: -      int nbSpace = getNbSpaceBetween(semicolonToken, nextToken);
>, <Line: -      if (nbSpace != 1 && isOnSameLine(semicolonToken, nextToken)) {
>, <Line: -        shouldReportIssue = true;
>, <Line: -    if (shouldReportIssue) {
>, <Line: -      formattingCheck.reportIssue("Put exactly one space after each \";\" character in the \"for\" statement.", node);
>, <Line: -  private void checkSpaceBetweenKeywordAndNextNode(FormattingStandardCheck formattingCheck, AstNode controlStructure) {
>, <Line: -    AstNode keyword = controlStructure.getFirstChild(PHPKeyword.values());
>, <Line: -    Token nextToken = keyword.getNextAstNode().getToken();
>, <Line: -    if (isType(nextToken, PHPPunctuator.LCURLYBRACE, PHPPunctuator.LPARENTHESIS) && isOnSameLine(keyword.getToken(), nextToken)) {
>, <Line: -      int nbSpace = getNbSpaceBetween(keyword.getToken(), nextToken);
>, <Line: -        String endMsg = "between this \"" + keyword.getTokenOriginalValue() + "\" keyword and the opening "
>, <Line: -          + (isType(nextToken, PHPPunctuator.LPARENTHESIS) ? "parenthesis." : "curly brace.");
>, <Line: -        formattingCheck.reportIssue(buildIssueMsg(nbSpace, endMsg), keyword);
>]