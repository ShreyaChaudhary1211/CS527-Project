[<Line: +/*
>, <Line: + * Copyright (C) 2015 Square, Inc.
>, <Line: + *
>, <Line: + * Licensed under the Apache License, Version 2.0 (the "License");
>, <Line: + * you may not use this file except in compliance with the License.
>, <Line: + * You may obtain a copy of the License at
>, <Line: + *
>, <Line: + *      http://www.apache.org/licenses/LICENSE-2.0
>, <Line: + *
>, <Line: + * Unless required by applicable law or agreed to in writing, software
>, <Line: + * distributed under the License is distributed on an "AS IS" BASIS,
>, <Line: + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>, <Line: + * See the License for the specific language governing permissions and
>, <Line: + * limitations under the License.
>, <Line: + */
>, <Line: +package okio;
>, <Line: +import java.io.IOException;
>, <Line: +import java.io.OutputStream;
>, <Line: +import java.util.Arrays;
>, <Line: +import static okio.Util.arrayRangeEquals;
>, <Line: +import static okio.Util.checkOffsetAndCount;
>, <Line: +/**
>, <Line: + * An immutable byte string composed of segments of byte arrays. This class exists to implement
>, <Line: + * efficient snapshots of buffers. It is implemented as an array of segments, plus a directory in
>, <Line: + * two halves that describes how the segments compose this byte string.
>, <Line: + *
>, <Line: + * <p>The first half of the directory is the cumulative byte count covered by each segment. The
>, <Line: + * element at {@code directory[0]} contains the number of bytes held in {@code segments[0]}; the
>, <Line: + * element at {@code directory[1]} contains the number of bytes held in {@code segments[0] +
>, <Line: + * segments[1]}, and so on. The element at {@code directory[segments.length - 1]} contains the total
>, <Line: + * size of this byte string. The first half of the directory is always monotonically increasing.
>, <Line: + *
>, <Line: + * <p>The second half of the directory is the offset in {@code segments} of the first content byte.
>, <Line: + * Bytes preceding this offset are unused, as are bytes beyond the segment's effective size.
>, <Line: + *
>, <Line: + * <p>Suppose we have a byte string, {@code [A, B, C, D, E, F, G, H, I, J, K, L, M]} that is stored
>, <Line: + * across three byte arrays: {@code [x, x, x, x, A, B, C, D, E, x, x, x]}, {@code [x, F, G]}, and
>, <Line: + * {@code [H, I, J, K, L, M, x, x, x, x, x, x]}. The three byte arrays would be stored in {@code
>, <Line: + * segments} in order. Since the arrays contribute 5, 2, and 6 elements respectively, the directory
>, <Line: + * starts with {@code [5, 7, 13} to hold the cumulative total at each position. Since the offsets
>, <Line: + * into the arrays are 4, 1, and 0 respectively, the directory ends with {@code 4, 1, 0]}.
>, <Line: + * Concatenating these two halves, the complete directory is {@code [5, 7, 13, 4, 1, 0]}.
>, <Line: + *
>, <Line: + * <p>This structure is chosen so that the segment holding a particular offset can be found by
>, <Line: + * binary search. We use one array rather than two for the directory as a micro-optimization.
>, <Line: + */
>, <Line: +final class SegmentedByteString extends ByteString {
>, <Line: +  transient final byte[][] segments;
>, <Line: +  transient final int[] directory;
>, <Line: +  SegmentedByteString(Buffer buffer, int byteCount) {
>, <Line: +    super(null);
>, <Line: +    checkOffsetAndCount(buffer.size, 0, byteCount);
>, <Line: +    // Walk through the buffer to count how many segments we'll need.
>, <Line: +    int offset = 0;
>, <Line: +    int segmentCount = 0;
>, <Line: +    for (Segment s = buffer.head; offset < byteCount; s = s.next) {
>, <Line: +      if (s.limit == s.pos) {
>, <Line: +        throw new AssertionError("s.limit == s.pos"); // Empty segment. This should not happen!
>, <Line: +      }
>, <Line: +      offset += s.limit - s.pos;
>, <Line: +      segmentCount++;
>, <Line: +    }
>, <Line: +    // Walk through the buffer again to assign segments and build the directory.
>, <Line: +    this.segments = new byte[segmentCount][];
>, <Line: +    this.directory = new int[segmentCount * 2];
>, <Line: +    offset = 0;
>, <Line: +    segmentCount = 0;
>, <Line: +    for (Segment s = buffer.head; offset < byteCount; s = s.next) {
>, <Line: +      segments[segmentCount] = s.data;
>, <Line: +      offset += s.limit - s.pos;
>, <Line: +      directory[segmentCount] = offset;
>, <Line: +      directory[segmentCount + segments.length] = s.pos;
>, <Line: +      s.shared = true;
>, <Line: +      segmentCount++;
>, <Line: +    }
>, <Line: +  }
>, <Line: +  @Override public String utf8() {
>, <Line: +    return toByteString().utf8();
>, <Line: +  }
>, <Line: +  @Override public String base64() {
>, <Line: +    return toByteString().base64();
>, <Line: +  }
>, <Line: +  @Override public String hex() {
>, <Line: +    return toByteString().hex();
>, <Line: +  }
>, <Line: +  @Override public ByteString toAsciiLowercase() {
>, <Line: +    return toByteString().toAsciiLowercase();
>, <Line: +  }
>, <Line: +  @Override public ByteString toAsciiUppercase() {
>, <Line: +    return toByteString().toAsciiUppercase();
>, <Line: +  }
>, <Line: +  @Override public byte getByte(int pos) {
>, <Line: +    checkOffsetAndCount(directory[segments.length - 1], pos, 1);
>, <Line: +    int segment = segment(pos);
>, <Line: +    int segmentOffset = segment == 0 ? 0 : directory[segment - 1];
>, <Line: +    int segmentPos = directory[segment + segments.length];
>, <Line: +    return segments[segment][pos - segmentOffset + segmentPos];
>, <Line: +  }
>, <Line: +  /** Returns the index of the segment that contains the byte at {@code pos}. */
>, <Line: +  private int segment(int pos) {
>, <Line: +    // Search for (pos + 1) instead of (pos) because the directory holds sizes, not indexes.
>, <Line: +    int i = Arrays.binarySearch(directory, 0, segments.length, pos + 1);
>, <Line: +    return i >= 0 ? i : ~i; // If i is negative, bitflip to get the insert position.
>, <Line: +  }
>, <Line: +  @Override public int size() {
>, <Line: +    return directory[segments.length - 1];
>, <Line: +  }
>, <Line: +  @Override public byte[] toByteArray() {
>, <Line: +    byte[] result = new byte[directory[segments.length - 1]];
>, <Line: +    int segmentOffset = 0;
>, <Line: +    for (int s = 0, segmentCount = segments.length; s < segmentCount; s++) {
>, <Line: +      int segmentPos = directory[segmentCount + s];
>, <Line: +      int nextSegmentOffset = directory[s];
>, <Line: +      System.arraycopy(segments[s], segmentPos, result, segmentOffset,
>, <Line: +          nextSegmentOffset - segmentOffset);
>, <Line: +      segmentOffset = nextSegmentOffset;
>, <Line: +    }
>, <Line: +    return result;
>, <Line: +  }
>, <Line: +  @Override public void write(OutputStream out) throws IOException {
>, <Line: +    if (out == null) throw new IllegalArgumentException("out == null");
>, <Line: +    int segmentOffset = 0;
>, <Line: +    for (int s = 0, segmentCount = segments.length; s < segmentCount; s++) {
>, <Line: +      int segmentPos = directory[segmentCount + s];
>, <Line: +      int nextSegmentOffset = directory[s];
>, <Line: +      out.write(segments[s], segmentPos, nextSegmentOffset - segmentOffset);
>, <Line: +      segmentOffset = nextSegmentOffset;
>, <Line: +    }
>, <Line: +  }
>, <Line: +  @Override void write(Buffer buffer) {
>, <Line: +    int segmentOffset = 0;
>, <Line: +    for (int s = 0, segmentCount = segments.length; s < segmentCount; s++) {
>, <Line: +      int segmentPos = directory[segmentCount + s];
>, <Line: +      int nextSegmentOffset = directory[s];
>, <Line: +      Segment segment = new Segment(segments[s], segmentPos,
>, <Line: +          segmentPos + nextSegmentOffset - segmentOffset);
>, <Line: +      if (buffer.head == null) {
>, <Line: +        buffer.head = segment.next = segment.prev = segment;
>, <Line: +      } else {
>, <Line: +        buffer.head.prev.push(segment);
>, <Line: +      }
>, <Line: +      segmentOffset = nextSegmentOffset;
>, <Line: +    }
>, <Line: +    buffer.size += segmentOffset;
>, <Line: +  }
>, <Line: +  @Override public boolean rangeEquals(
>, <Line: +      int offset, ByteString other, int otherOffset, int byteCount) {
>, <Line: +    if (offset > size() - byteCount) return false;
>, <Line: +    // Go segment-by-segment through this, passing arrays to other's rangeEquals().
>, <Line: +    for (int s = segment(offset); byteCount > 0; s++) {
>, <Line: +      int segmentOffset = s == 0 ? 0 : directory[s - 1];
>, <Line: +      int segmentSize = directory[s] - segmentOffset;
>, <Line: +      int stepSize = Math.min(byteCount, segmentOffset + segmentSize - offset);
>, <Line: +      int segmentPos = directory[segments.length + s];
>, <Line: +      int arrayOffset = offset - segmentOffset + segmentPos;
>, <Line: +      if (!other.rangeEquals(otherOffset, segments[s], arrayOffset, stepSize)) return false;
>, <Line: +      offset += stepSize;
>, <Line: +      otherOffset += stepSize;
>, <Line: +      byteCount -= stepSize;
>, <Line: +    }
>, <Line: +    return true;
>, <Line: +  }
>, <Line: +  @Override public boolean rangeEquals(int offset, byte[] other, int otherOffset, int byteCount) {
>, <Line: +    if (offset > size() - byteCount || otherOffset > other.length - byteCount) return false;
>, <Line: +    // Go segment-by-segment through this, comparing ranges of arrays.
>, <Line: +    for (int s = segment(offset); byteCount > 0; s++) {
>, <Line: +      int segmentOffset = s == 0 ? 0 : directory[s - 1];
>, <Line: +      int segmentSize = directory[s] - segmentOffset;
>, <Line: +      int stepSize = Math.min(byteCount, segmentOffset + segmentSize - offset);
>, <Line: +      int segmentPos = directory[segments.length + s];
>, <Line: +      int arrayOffset = offset - segmentOffset + segmentPos;
>, <Line: +      if (!arrayRangeEquals(segments[s], arrayOffset, other, otherOffset, stepSize)) return false;
>, <Line: +      offset += stepSize;
>, <Line: +      otherOffset += stepSize;
>, <Line: +      byteCount -= stepSize;
>, <Line: +    }
>, <Line: +    return true;
>, <Line: +  }
>, <Line: +  /** Returns a copy as a non-segmented byte string. */
>, <Line: +  private ByteString toByteString() {
>, <Line: +    return new ByteString(toByteArray());
>, <Line: +  }
>, <Line: +  @Override public boolean equals(Object o) {
>, <Line: +    if (o == this) return true;
>, <Line: +    return o instanceof ByteString
>, <Line: +        && ((ByteString) o).size() == size()
>, <Line: +        && rangeEquals(0, ((ByteString) o), 0, size());
>, <Line: +  }
>, <Line: +  @Override public int hashCode() {
>, <Line: +    int result = hashCode;
>, <Line: +    if (result != 0) return result;
>, <Line: +    // Equivalent to Arrays.hashCode(toByteArray()).
>, <Line: +    result = 1;
>, <Line: +    int segmentOffset = 0;
>, <Line: +    for (int s = 0, segmentCount = segments.length; s < segmentCount; s++) {
>, <Line: +      byte[] segment = segments[s];
>, <Line: +      int segmentPos = directory[segmentCount + s];
>, <Line: +      int nextSegmentOffset = directory[s];
>, <Line: +      int segmentSize = nextSegmentOffset - segmentOffset;
>, <Line: +      for (int i = segmentPos, limit = segmentPos + segmentSize; i < limit; i++) {
>, <Line: +        result = (31 * result) + segment[i];
>, <Line: +      }
>, <Line: +      segmentOffset = nextSegmentOffset;
>, <Line: +    }
>, <Line: +    return (hashCode = result);
>, <Line: +  }
>, <Line: +  @Override public String toString() {
>, <Line: +    return toByteString().toString();
>, <Line: +  }
>, <Line: +  private Object writeReplace() {
>, <Line: +    return toByteString();
>, <Line: +  }
>, <Line: +}
>]
[]