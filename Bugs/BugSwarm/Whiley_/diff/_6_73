[<Line: +package wyjc.util;
>, <Line: +import static jasm.lang.JvmTypes.JAVA_LANG_OBJECT;
>, <Line: +import static jasm.lang.Modifier.*;
>, <Line: +import static wyjc.Wyil2JavaBuilder.JAVA_LANG_OBJECT_ARRAY;
>, <Line: +import static wyjc.Wyil2JavaBuilder.WHILEYLAMBDA;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.Arrays;
>, <Line: +import java.util.List;
>, <Line: +import jasm.attributes.Code.Handler;
>, <Line: +import jasm.lang.Bytecode;
>, <Line: +import jasm.lang.ClassFile;
>, <Line: +import jasm.lang.JvmType;
>, <Line: +import jasm.lang.JvmTypes;
>, <Line: +import jasm.lang.Modifier;
>, <Line: +import wyjc.Wyil2JavaBuilder;
>, <Line: +/**
>, <Line: + * This is a template for generating a "lambda class", which is used to
>, <Line: + * represent lambda's in Whiley. The basic form of the generated class is:
>, <Line: + * 
>, <Line: + * <pre>
>, <Line: + * final class NN extends WyLambda {
>, <Line: + *    private final T1 r1;
>, <Line: + *    ...
>, <Line: + *    private final Tn rn;
>, <Line: + *    
>, <Line: + *    public NN(T1 r1, ... Tn rn) {
>, <Line: + *       super();
>, <Line: + *       this.r1 = r1;
>, <Line: + *       ...
>, <Line: + *       this.rn = rn;
>, <Line: + *    }
>, <Line: + *    
>, <Line: + *    public Object call(Object... params) {
>, <Line: + *      return C.m(params[0], ... params[m], r1, ..., rn);
>, <Line: + *    }
>, <Line: + * }
>, <Line: + * </pre>
>, <Line: + * 
>, <Line: + * Here, the fields <code>r1</code> to <code>rn</code> correspond to the
>, <Line: + * "environment". Those are variables from the enclosing scope which are passed
>, <Line: + * through to the lambda body. In this case, the body always consists of a
>, <Line: + * static method call to a given method.
>, <Line: + * 
>, <Line: + * @author David J. Pearce
>, <Line: + *
>, <Line: + */
>, <Line: +public class LambdaTemplate {
>, <Line: +	/**
>, <Line: +	 * JVM Class version number to use (e.g. 49)
>, <Line: +	 */
>, <Line: +	private final int version;
>, <Line: +	/**
>, <Line: +	 * The class that this template will generate
>, <Line: +	 */
>, <Line: +	private final JvmType.Clazz thisClass;	
>, <Line: +	/**
>, <Line: +	 * The enclosing class of the target method. That is the static method which
>, <Line: +	 * will be invoked by this lambda.
>, <Line: +	 */
>, <Line: +	private final JvmType.Clazz targetClass;
>, <Line: +	/**
>, <Line: +	 * The name of the target method.  That is the static method which
>, <Line: +	 * will be invoked by this lambda.
>, <Line: +	 */ 
>, <Line: +	private final String targetMethod;
>, <Line: +	/**
>, <Line: +	 * The type of the target function. This excludes the "environment" which
>, <Line: +	 * will extend the set of concrete parameter types.
>, <Line: +	 */
>, <Line: +	private final JvmType.Function type;
>, <Line: +	/**
>, <Line: +	 * The set of environment variables which will be stored as fields
>, <Line: +	 */
>, <Line: +	private final JvmType[] environment;
>, <Line: +	/**
>, <Line: +	 * Create a given LambdaTemplate with which a special lambda class can be
>, <Line: +	 * constructed.
>, <Line: +	 * 
>, <Line: +	 * @param version
>, <Line: +	 *            JVM Class version number to use (e.g. 49)
>, <Line: +	 * @param thisClass
>, <Line: +	 *            The class that this template will generate
>, <Line: +	 * @param targetClass
>, <Line: +	 *            The enclosing class of the target method. That is the static
>, <Line: +	 *            method which will be invoked by this lambda.
>, <Line: +	 * @param targetMethod
>, <Line: +	 *            The name of the target method. That is the static method which
>, <Line: +	 *            will be invoked by this lambda.
>, <Line: +	 * @param type
>, <Line: +	 *            The type of the target function. This excludes the
>, <Line: +	 *            "environment" which will extend the set of concrete parameter
>, <Line: +	 *            types.
>, <Line: +	 * @param environment
>, <Line: +	 *            The set of environment variables which will be stored as
>, <Line: +	 *            fields
>, <Line: +	 */
>, <Line: +	public LambdaTemplate(int version, JvmType.Clazz thisClass, JvmType.Clazz targetClass, String targetMethod,
>, <Line: +			JvmType.Function type, JvmType... environment) {
>, <Line: +		this.version = version;
>, <Line: +		this.thisClass = thisClass;
>, <Line: +		this.targetClass = targetClass;
>, <Line: +		this.targetMethod = targetMethod;
>, <Line: +		this.type = type;
>, <Line: +		this.environment = environment;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate the lambda class.
>, <Line: +	 * 
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public ClassFile generateClass() {
>, <Line: +		// Construct empty class
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);
>, <Line: +		ClassFile cf = new ClassFile(version, thisClass, WHILEYLAMBDA, new ArrayList<JvmType.Clazz>(),
>, <Line: +				modifiers);
>, <Line: +		// Add Fields
>, <Line: +		for(int i=0;i!=environment.length;++i) {
>, <Line: +			String name = "r" + i;
>, <Line: +			cf.fields().add(generateField(name,environment[i]));
>, <Line: +		}		
>, <Line: +		// Add Constructor
>, <Line: +		cf.methods().add(generateConstructor());
>, <Line: +		// Add implementation of WyLambda.call(Object[]) ===
>, <Line: +		cf.methods().add(generateCallMethod());
>, <Line: +		// Done
>, <Line: +		return cf;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Build a constructor for a lambda expression. This constructor accepts
>, <Line: +	 * zero or more parameters which constitute the "environment". That is,
>, <Line: +	 * variables from the enclosing scope of the lambda which will be passed
>, <Line: +	 * through and stored in the lambda class itself.
>, <Line: +	 * 
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private ClassFile.Method generateConstructor() {
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC);
>, <Line: +		JvmType.Function superConstructorType = new JvmType.Function(JvmTypes.T_VOID);
>, <Line: +		JvmType.Function constructorType = new JvmType.Function(JvmTypes.T_VOID, environment);
>, <Line: +		// Create constructor method
>, <Line: +		ClassFile.Method constructor = new ClassFile.Method("<init>", constructorType, modifiers);
>, <Line: +		// Create body of constructor which called super-class constructor, and
>, <Line: +		// assigns each environment parameter to a corresponding field.
>, <Line: +		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: +		// Call superclass constructor
>, <Line: +		bytecodes.add(new Bytecode.Load(0, thisClass));
>, <Line: +		bytecodes.add(new Bytecode.Invoke(Wyil2JavaBuilder.WHILEYLAMBDA, "<init>", superConstructorType,
>, <Line: +				Bytecode.InvokeMode.SPECIAL));
>, <Line: +		// Assign each parameter to a corresponding named field.
>, <Line: +		for (int i = 0; i != environment.length; ++i) {
>, <Line: +			JvmType fieldType = environment[i];
>, <Line: +			bytecodes.add(new Bytecode.Load(0, thisClass));
>, <Line: +			bytecodes.add(new Bytecode.Load(i + 1, fieldType));
>, <Line: +			bytecodes.add(new Bytecode.PutField(thisClass, "r" + i, fieldType, Bytecode.FieldMode.NONSTATIC));
>, <Line: +		}
>, <Line: +		bytecodes.add(new Bytecode.Return(null));
>, <Line: +		// Add code attribute to constructor
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), constructor);
>, <Line: +		constructor.attributes().add(code);
>, <Line: +		//
>, <Line: +		return constructor;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Build a method implementing the body of this lambda. In this case, the
>, <Line: +	 * body consists of invoking a given method in the target class. The
>, <Line: +	 * parameters for the invocation are formed from two sources. First, the
>, <Line: +	 * parameters which are passed in to the call itself as an object array;
>, <Line: +	 * Second, the parameters originally passed to the constructor and now
>, <Line: +	 * stored as fields.
>, <Line: +	 * 
>, <Line: +	 * @param lambdaClassType
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private ClassFile.Method generateCallMethod() {
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);		
>, <Line: +		// Create constructor method
>, <Line: +		JvmType.Function callType = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
>, <Line: +		ClassFile.Method method = new ClassFile.Method("call", callType, modifiers);
>, <Line: +		// Create body of call method
>, <Line: +		List<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: +		// Load parameters onto stack from the parameters array
>, <Line: +		decodeLambdaParameterArray(1,type.parameterTypes(),bytecodes);
>, <Line: +		// Load environment onto stack
>, <Line: +		loadEnvironment(bytecodes);
>, <Line: +		// Construct the actual target type
>, <Line: +		ArrayList<JvmType> actualParameterTypes = new ArrayList<JvmType>(type.parameterTypes());
>, <Line: +		actualParameterTypes.addAll(Arrays.asList(environment));
>, <Line: +		JvmType.Function actualType = new JvmType.Function(type.returnType(), actualParameterTypes);
>, <Line: +		// Now, invoke the target method
>, <Line: +		bytecodes.add(new Bytecode.Invoke(targetClass, targetMethod, actualType, Bytecode.InvokeMode.STATIC));
>, <Line: +		// Deal with return values (if applicable)
>, <Line: +		if (type.returnType() instanceof JvmType.Void) {
>, <Line: +			// Called function doesn't return anything, but we have to as the
>, <Line: +			// type of WyLambda.call dictates this. Therefore, push on dummy
>, <Line: +			// null value.
>, <Line: +			bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: +		} 
>, <Line: +		bytecodes.add(new Bytecode.Return(JAVA_LANG_OBJECT));		
>, <Line: +		// Add code attribute to call method
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), method);
>, <Line: +		method.attributes().add(code);
>, <Line: +		// Done
>, <Line: +		return method;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate a field in which the given environment variable can be stored.
>, <Line: +	 * 
>, <Line: +	 * @param name
>, <Line: +	 * @param type
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private ClassFile.Field generateField(String name, JvmType type) {
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PRIVATE, ACC_FINAL);
>, <Line: +		return new ClassFile.Field(name, type, modifiers);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Given an array of objects, load each element onto the stack in order of
>, <Line: +	 * occurrence and convert them into the appropriate form.
>, <Line: +	 * 
>, <Line: +	 * @param source
>, <Line: +	 *            Source register containing the array
>, <Line: +	 * @param types
>, <Line: +	 *            the target type of each element
>, <Line: +	 * @param bytecodes
>, <Line: +	 */
>, <Line: +	private void decodeLambdaParameterArray(int source, List<JvmType> types, List<Bytecode> bytecodes) {
>, <Line: +		for (int i = 0; i != types.size(); ++i) {
>, <Line: +			bytecodes.add(new Bytecode.Load(source, JAVA_LANG_OBJECT_ARRAY));
>, <Line: +			bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: +			bytecodes.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +			bytecodes.add(new Bytecode.CheckCast(types.get(i)));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Load each environment variable onto the stack
>, <Line: +	 * 
>, <Line: +	 * @param bytecodes
>, <Line: +	 */
>, <Line: +	private void loadEnvironment(List<Bytecode> bytecodes) {
>, <Line: +		for (int i = 0; i != environment.length; ++i) {
>, <Line: +			String name = "r" + i;
>, <Line: +			bytecodes.add(new Bytecode.Load(0,thisClass));
>, <Line: +			bytecodes.add(new Bytecode.GetField(thisClass, name, environment[i], Bytecode.FieldMode.NONSTATIC));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a list of modifiers from an array of (potentially null)
>, <Line: +	 * modifiers.
>, <Line: +	 * 
>, <Line: +	 * @param mods
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private static List<Modifier> modifiers(Modifier... mods) {
>, <Line: +		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: +		for (Modifier m : mods) {
>, <Line: +			if (m != null) {
>, <Line: +				modifiers.add(m);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return modifiers;
>, <Line: +	}
>, <Line: +}
>]
[]