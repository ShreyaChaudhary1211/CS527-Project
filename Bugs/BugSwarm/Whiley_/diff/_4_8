[<Line: +		return new Return(new Type[0]);
>, <Line: +		return new Return(types, operands);
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return BinaryOperator(type(0), nTargets[0], nOperands[0], nOperands[1],
>, <Line: +			return kind + " %" + target(0) + " = %" + operand(0) + ", %"
>, <Line: +					+ operand(1) + " : " + type(0);
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Convert(type(0), nTargets[0], nOperands[0], result);
>, <Line: +			return "convert %" + target(0) + " = %" + operand(0) + " " + result
>, <Line: +					+ " : " + type(0);
>, <Line: +		@Override
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Assign(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "assign %" + target(0) + " = %" + operand(0) + " " + " : " + type(0);
>, <Line: +	public static final class FieldLoad extends AbstractUnaryAssignable<Type.EffectiveRecord> {
>, <Line: +		private FieldLoad(Type.EffectiveRecord type, int target, int operand, String field) {
>, <Line: +			super((Type) type, target, operand);
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return FieldLoad(type(0), nTargets[0], nOperands[0], field);
>, <Line: +			return type(0).fields().get(field);
>, <Line: +			return "fieldload %" + target(0) + " = %" + operand(0) + " " + field
>, <Line: +					+ " : " + type(0);
>, <Line: +			super(new Type.FunctionOrMethod[]{type}, targets, append(operand,operands));
>, <Line: +			if (type(0) instanceof Type.Function) {
>, <Line: +			return IndirectInvoke(type(0), nTargets, nOperands[0],
>, <Line: +					+ arrayToString(parameters()) + " : " + type(0);			
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Not(nTargets[0], nOperands[0]);
>, <Line: +			return "not %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +			super(new Type.FunctionOrMethod[]{type}, targets, operands);
>, <Line: +			if (type(0) instanceof Type.Function) {
>, <Line: +			return Invoke(type(0), nTargets, nOperands, name);
>, <Line: +					+ type(0);			
>, <Line: +			AbstractMultiNaryAssignable<Type.FunctionOrMethod> {
>, <Line: +			if (type(0) instanceof Type.Function) {
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Lambda(type(0), nTargets[0], nOperands, name);
>, <Line: +			return "lambda %" + target(0) + " = " + arrayToString(operands()) + " "
>, <Line: +					+ name + " : " + type(0);
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return ArrayGenerator(type(0), nTargets[0], nOperands[0],nOperands[1]);
>, <Line: +			return "arraygen %" + target(0) + " = [" + operand(0) + "; " + operand(1) + "]" + " : " + type(0);
>, <Line: +	public static final class LengthOf extends AbstractUnaryAssignable<Type.EffectiveArray> {
>, <Line: +			super((Type) type, target, operand);
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return LengthOf(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "lengthof %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +	public static final class IndexOf extends AbstractBinaryAssignable<Type.EffectiveArray> {
>, <Line: +			super((Type) type, target, sourceOperand, keyOperand);
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return IndexOf(type(0), nTargets[0], nOperands[0], nOperands[1]);
>, <Line: +			return "indexof %" + target(0) + " = %" + operand(0) + ", %" + operand(1) + " : " + type(0);
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Move(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "move %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +	public static final class Update extends AbstractMultiNaryAssignable<Type>
>, <Line: +			if (type(0) instanceof Type.Reference) {
>, <Line: +		public final Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Update(type(0), nTargets[0],
>, <Line: +			String r = "%" + target(0);
>, <Line: +			return "update " + r + " = %" + result() + " : " + type(0) + " -> " + afterType;
>, <Line: +			AbstractMultiNaryAssignable<Type.Record> {
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return NewRecord(type(0), nTargets[0], nOperands);
>, <Line: +			return "newrecord %" + target(0) + " = " + arrayToString(operands()) + " : " + type(0);
>, <Line: +	public static final class NewArray extends AbstractMultiNaryAssignable<Type.Array> {
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return NewArray(type(0), nTargets[0], nOperands);
>, <Line: +			return "newlist %" + target(0) + " = " + arrayToString(operands()) + " : " + type(0);
>, <Line: +		private Return(Type[] types, int... operands) {
>, <Line: +			super(types, new int[0], operands);			
>, <Line: +			return new Return(Arrays.copyOf(types, types.length), nOperands);
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Invert(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "invert %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return NewObject(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "newobject %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Dereference(type(0), nTargets[0], nOperands[0]);
>, <Line: +			return "deref %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +		public Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return UnaryOperator(type(0), nTargets[0], nOperands[0], kind);
>, <Line: +			return kind + " %" + target(0) + " = %" + operand(0) + " : " + type(0);
>, <Line: +	public static class Void extends AbstractMultiNaryAssignable<Type> {
>, <Line: +		@Override
>, <Line: +		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
>, <Line: +			return Void(type(0), nOperands);
>]
[<Line: -		// FIXME: this is completely broken!
>, <Line: -		return new Return(Type.T_VOID);
>, <Line: -		// FIXME: this is completely broken!
>, <Line: -		if(types.length == 0) {
>, <Line: -			return new Return(Type.T_VOID, operands);
>, <Line: -		} else {
>, <Line: -			return new Return(types[0], operands);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Construct a return bytecode which reads a value from the operand register
>, <Line: -	 * and returns it.
>, <Line: -	 *
>, <Line: -	 * @param type
>, <Line: -	 *            --- type of the value to be returned (cannot be void).
>, <Line: -	 * @param operand
>, <Line: -	 *            --- register to read return value from.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public static Return Return(List<Type> types, int... operands) {
>, <Line: -		// FIXME: this is completely broken!
>, <Line: -		if(types.size() == 0) {
>, <Line: -			return new Return(Type.T_VOID, operands);
>, <Line: -		} else {
>, <Line: -			return new Return(types.get(0), operands);
>, <Line: -		}
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return BinaryOperator(type(), nTarget, nOperands[0], nOperands[1],
>, <Line: -			return kind + " %" + target() + " = %" + operand(0) + ", %"
>, <Line: -					+ operand(1) + " : " + type();
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Convert(type(), nTarget, nOperands[0], result);
>, <Line: -			return "convert %" + target() + " = %" + operand(0) + " " + result
>, <Line: -					+ " : " + type();
>, <Line: -		public Type assignedType() {
>, <Line: -			return (Type) constant.type();
>, <Line: -		}
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Assign(type(), nTarget, nOperands[0]);
>, <Line: -			return "assign %" + target() + " = %" + operand(0) + " " + " : " + type();
>, <Line: -	public static final class FieldLoad extends
>, <Line: -			AbstractUnaryAssignable<Type.EffectiveRecord> {
>, <Line: -		private FieldLoad(Type.EffectiveRecord type, int target, int operand,
>, <Line: -				String field) {
>, <Line: -			super(type, target, operand);
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return FieldLoad(type(), nTarget, nOperands[0], field);
>, <Line: -			return type().fields().get(field);
>, <Line: -		}
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().fields().get(field);
>, <Line: -			return "fieldload %" + target() + " = %" + operand(0) + " " + field
>, <Line: -					+ " : " + type();
>, <Line: -			super(type, targets, append(operand,operands));
>, <Line: -			if (type() instanceof Type.Function) {
>, <Line: -			return IndirectInvoke(type(), nTargets, nOperands[0],
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().returns().get(0);
>, <Line: -		}
>, <Line: -					+ arrayToString(parameters()) + " : " + type();			
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Not(nTarget, nOperands[0]);
>, <Line: -			return "not %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -			super(type, targets, operands);
>, <Line: -			if (type() instanceof Type.Function) {
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().returns().get(0);
>, <Line: -		}
>, <Line: -			return Invoke(type(), nTargets, nOperands, name);
>, <Line: -					+ type();			
>, <Line: -			AbstractNaryAssignable<Type.FunctionOrMethod> {
>, <Line: -			if (type() instanceof Type.Function) {
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().returns().get(0);
>, <Line: -		}
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Lambda(type(), nTarget, nOperands, name);
>, <Line: -			return "lambda %" + target() + " = " + arrayToString(operands()) + " "
>, <Line: -					+ name + " : " + type();
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return ArrayGenerator(type(), nTarget, nOperands[0],nOperands[1]);
>, <Line: -			return "listgen %" + target() + " = [" + operand(0) + "; " + operand(1) + "]" + " : " + type();
>, <Line: -	public static final class LengthOf extends
>, <Line: -			AbstractUnaryAssignable<Type.EffectiveArray> {
>, <Line: -			super(type, target, operand);
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return LengthOf(type(), nTarget, nOperands[0]);
>, <Line: -		}
>, <Line: -		public Type assignedType() {
>, <Line: -			return Type.T_INT;
>, <Line: -			return "lengthof %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -	public static final class IndexOf extends
>, <Line: -			AbstractBinaryAssignable<Type.EffectiveArray> {
>, <Line: -			super(type, target, sourceOperand, keyOperand);
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return IndexOf(type(), nTarget, nOperands[0], nOperands[1]);
>, <Line: -		}
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().element();
>, <Line: -			return "indexof %" + target() + " = %" + operand(0) + ", %"
>, <Line: -					+ operand(1) + " : " + type();
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Move(type(), nTarget, nOperands[0]);
>, <Line: -			return "move %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -	public static final class Update extends AbstractNaryAssignable<Type>
>, <Line: -			if (type() instanceof Type.Reference) {
>, <Line: -		public Type assignedType() {
>, <Line: -			return afterType;
>, <Line: -		}
>, <Line: -		public final Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Update(type(), nTarget,
>, <Line: -			String r = "%" + target();
>, <Line: -			return "update " + r + " = %" + result() + " : " + type() + " -> "
>, <Line: -					+ afterType;
>, <Line: -			AbstractNaryAssignable<Type.Record> {
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return NewRecord(type(), nTarget, nOperands);
>, <Line: -			return "newrecord %" + target() + " = " + arrayToString(operands())
>, <Line: -					+ " : " + type();
>, <Line: -	public static final class NewArray extends AbstractNaryAssignable<Type.Array> {
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return NewArray(type(), nTarget, nOperands);
>, <Line: -			return "newlist %" + target() + " = " + arrayToString(operands())
>, <Line: -					+ " : " + type();
>, <Line: -		private Return(Type type, int... operands) {
>, <Line: -			super(type, new int[0], operands);			
>, <Line: -		}
>, <Line: -		public List<Type> types() {
>, <Line: -			// FIXME: also clearly broken.
>, <Line: -			ArrayList<Type> types = new ArrayList<Type>();
>, <Line: -			for(int i=0;i!=operands.length;++i) {
>, <Line: -				types.add(type());
>, <Line: -			}
>, <Line: -			return types;
>, <Line: -			return new Return(type, nOperands);
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Invert(type(), nTarget, nOperands[0]);
>, <Line: -			return "invert %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return NewObject(type(), nTarget, nOperands[0]);
>, <Line: -			return "newobject %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -		public Type assignedType() {
>, <Line: -			return type().element();
>, <Line: -		}
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Dereference(type(), nTarget, nOperands[0]);
>, <Line: -			return "deref %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -		public Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return UnaryOperator(type(), nTarget, nOperands[0], kind);
>, <Line: -			return kind + " %" + target() + " = %" + operand(0) + " : " + type();
>, <Line: -	public static class Void extends AbstractNaryAssignable<Type> {
>, <Line: -		protected Code.Unit clone(int nTarget, int[] nOperands) {
>, <Line: -			return Void(type(), nOperands);
>, <Line: -		}
>, <Line: -		public Type assignedType() {
>, <Line: -			return Type.T_VOID;
>]