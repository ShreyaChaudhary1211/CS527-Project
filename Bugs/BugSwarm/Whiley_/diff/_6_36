[]
[<Line: -// All rights reserved.
>, <Line: -//
>, <Line: -// Redistribution and use in source and binary forms, with or without
>, <Line: -// modification, are permitted provided that the following conditions are met:
>, <Line: -//    * Redistributions of source code must retain the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer.
>, <Line: -//    * Redistributions in binary form must reproduce the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer in the
>, <Line: -//      documentation and/or other materials provided with the distribution.
>, <Line: -//    * Neither the name of the <organization> nor the
>, <Line: -//      names of its contributors may be used to endorse or promote products
>, <Line: -//      derived from this software without specific prior written permission.
>, <Line: -//
>, <Line: -// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
>, <Line: -// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
>, <Line: -// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
>, <Line: -// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
>, <Line: -// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
>, <Line: -// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
>, <Line: -// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
>, <Line: -// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
>, <Line: -// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
>, <Line: -// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>, <Line: -package wyil.builders;
>, <Line: -import wycc.lang.SyntaxError.InternalFailure;
>, <Line: -import wycc.lang.SyntaxError;
>, <Line: -import static wyil.util.ErrorMessages.*;
>, <Line: -import java.io.IOException;
>, <Line: -import java.math.BigDecimal;
>, <Line: -import java.math.BigInteger;
>, <Line: -import java.util.*;
>, <Line: -import wybs.lang.*;
>, <Line: -import wyfs.lang.Path;
>, <Line: -import wyfs.util.Trie;
>, <Line: -import wyil.attributes.VariableDeclarations;
>, <Line: -import wyil.builders.VcBranch.State;
>, <Line: -import wyil.lang.*;
>, <Line: -import wyil.lang.BytecodeForest.Index;
>, <Line: -import wyil.util.ErrorMessages;
>, <Line: -import wyil.util.TypeExpander;
>, <Line: -import wycc.lang.Attribute;
>, <Line: -import wycc.lang.NameID;
>, <Line: -import wycc.util.Pair;
>, <Line: -import wycc.util.ResolveError;
>, <Line: -import wycs.core.SemanticType;
>, <Line: -import wycs.core.Value;
>, <Line: -import wycs.syntax.*;
>, <Line: -import wycs.syntax.Expr.Is;
>, <Line: -import wycs.syntax.TypePattern.Tuple;
>, <Line: -/**
>, <Line: - * Responsible for converting a given Wyil bytecode into an appropriate
>, <Line: - * constraint which encodes its semantics.
>, <Line: - *
>, <Line: - * @author David J. Pearce
>, <Line: - *
>, <Line: - */
>, <Line: -public class VcGenerator {
>, <Line: -	private final Builder builder;
>, <Line: -	private final TypeExpander expander;
>, <Line: -	private VcExprGenerator unitGen;
>, <Line: -	private VcUtils utils;
>, <Line: -	private String filename;
>, <Line: -	private WyalFile wyalFile;
>, <Line: -	WyilFile.FunctionOrMethod method;
>, <Line: -	public VcGenerator(Builder builder) {
>, <Line: -		this.builder = builder;
>, <Line: -		this.expander = new TypeExpander(builder.project());
>, <Line: -	}
>, <Line: -	// ===============================================================================
>, <Line: -	// Top-Level Controller
>, <Line: -	// ===============================================================================
>, <Line: -	protected WyalFile transform(WyilFile wyilFile) {
>, <Line: -		filename = wyilFile.filename();
>, <Line: -		utils = new VcUtils(filename,builder,expander);
>, <Line: -		unitGen = new VcExprGenerator(filename,builder,utils);
>, <Line: -		wyalFile = new WyalFile(wyilFile.id(), filename);
>, <Line: -		addImports();
>, <Line: -		for (WyilFile.Block b : wyilFile.blocks()) {
>, <Line: -			if (b instanceof WyilFile.Constant) {
>, <Line: -				transform((WyilFile.Constant) b, wyilFile);
>, <Line: -			} else if (b instanceof WyilFile.Type) {
>, <Line: -				transform((WyilFile.Type) b, wyilFile);
>, <Line: -			} else if (b instanceof WyilFile.FunctionOrMethod) {
>, <Line: -				WyilFile.FunctionOrMethod method = (WyilFile.FunctionOrMethod) b;				
>, <Line: -				transform(method, wyilFile);				
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return wyalFile;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Add necessary imports from the theorem prover's library.
>, <Line: -	 */
>, <Line: -	private void addImports() {
>, <Line: -	}
>, <Line: -	protected void transform(WyilFile.Constant decl, WyilFile wyilFile) {
>, <Line: -		NameID name = new NameID(wyilFile.id(), decl.name());
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Transform a type declaration into verification conditions as necessary.
>, <Line: -	 * In particular, the type should be "inhabitable". This means, for example,
>, <Line: -	 * that the invariant does not contradict itself. Furthermore, we need to
>, <Line: -	 * transform the type invariant into a macro block.
>, <Line: -	 * 
>, <Line: -	 * @param typeDecl
>, <Line: -	 * @param wyilFile
>, <Line: -	 */
>, <Line: -	protected void transform(WyilFile.Type typeDecl, WyilFile wyilFile) {
>, <Line: -		BytecodeForest forest = typeDecl.invariant();
>, <Line: -		Expr invariant = null;
>, <Line: -		// FIXME: get the register prefix!
>, <Line: -		Expr.Variable var = new Expr.Variable("r0");
>, <Line: -		if (forest.numBlocks() > 0) {
>, <Line: -			BytecodeForest.Index root = new BytecodeForest.Index(forest.getRoot(0), 0);
>, <Line: -			VcBranch master = new VcBranch(Math.max(1, forest.numRegisters()), root, null);
>, <Line: -			master.write(0, var);
>, <Line: -			// Pass the given branch through the type invariant, producing
>, <Line: -			// exactly one exit branch from which we can generate the invariant
>, <Line: -			// expression.
>, <Line: -			Type[] environment = new Type[] { typeDecl.type() };
>, <Line: -			List<VcBranch> exitBranches = transform(master, root, true, environment, forest);
>, <Line: -			// At this point, we are guaranteed exactly one exit branch because
>, <Line: -			// there is only ever one exit point from an invariant.
>, <Line: -			for (VcBranch exitBranch : exitBranches) {
>, <Line: -				if (exitBranch.state() == VcBranch.State.TERMINATED) {
>, <Line: -					invariant = generateAssumptions(exitBranch, null);
>, <Line: -					break;
>, <Line: -				}
>, <Line: -			}
>, <Line: -			// FIXME: Need to add the inhabitable check here. This has to be an
>, <Line: -			// existential quantifier.
>, <Line: -		}
>, <Line: -		TypePattern.Leaf pattern = new TypePattern.Leaf(utils.convert(typeDecl.type(), Collections.EMPTY_LIST), var);
>, <Line: -		wyalFile.add(wyalFile.new Type(typeDecl.name(), Collections.EMPTY_LIST,
>, <Line: -				pattern, invariant, VcUtils.toWycsAttributes(typeDecl.attributes())));
>, <Line: -	}
>, <Line: -	protected void transform(WyilFile.FunctionOrMethod method, WyilFile wyilFile) {
>, <Line: -		this.method = method;
>, <Line: -		Type.FunctionOrMethod fmm = method.type();
>, <Line: -		BytecodeForest forest = method.code();
>, <Line: -		int[] preconditions = method.preconditions();
>, <Line: -		int[] postconditions = method.postconditions();				
>, <Line: -		// First, translate pre- and post-conditions into macro blocks. These
>, <Line: -		// can then be used in various places to assume or enforce pre /
>, <Line: -		// post-conditions. For example, when ensure a pre-condition is met at
>, <Line: -		// an invocation site, we can call this macro directly.
>, <Line: -		String prefix = method.name() + "_requires_";
>, <Line: -		for (int i = 0; i != preconditions.length; ++i) {
>, <Line: -			BytecodeForest.Index pc = new BytecodeForest.Index(preconditions[i], 0);
>, <Line: -			buildMacroBlock(prefix + i, pc, forest, fmm.params(), true);
>, <Line: -		}
>, <Line: -		prefix = method.name() + "_ensures_";
>, <Line: -		List<Type> postEnvironment = append(fmm.params(), fmm.returns());		
>, <Line: -		for (int i = 0; i != postconditions.length; ++i) {
>, <Line: -			BytecodeForest.Index pc = new BytecodeForest.Index(postconditions[i], 0);
>, <Line: -			buildMacroBlock(prefix + i, pc, forest, postEnvironment, true);
>, <Line: -		}
>, <Line: -		// Finally, add a function representing this function or method.
>, <Line: -		utils.createFunctionPrototype(wyalFile, method.name(), fmm.params(), fmm.returns());
>, <Line: -		if (method.hasModifier(Modifier.NATIVE)) {
>, <Line: -			// We don't consider native methods because they have empty bodies,
>, <Line: -			// and attempting to pass these through to the verification
>, <Line: -			// condition generator will cause problems.
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		Pair<String[], Type[]> registerInfo = VcUtils.parseRegisterDeclarations(forest);
>, <Line: -		String[] prefixes = registerInfo.first();
>, <Line: -		Type[] bodyEnvironment = registerInfo.second();
>, <Line: -		// Construct the master branch and initialise all parameters with their
>, <Line: -		// declared types in the master branch. The master branch needs to have
>, <Line: -		// at least as many slots as there are parameters, though may require
>, <Line: -		// more if the body uses them.
>, <Line: -		BytecodeForest.Index pc = new BytecodeForest.Index(method.body(), 0);
>, <Line: -		VcBranch master = new VcBranch(Math.max(forest.numRegisters(), fmm.params().size()), pc, prefixes);
>, <Line: -		Expr[] arguments = new Expr[fmm.params().size()];
>, <Line: -		for (int i = 0; i != fmm.params().size(); ++i) {
>, <Line: -			Expr.Variable v = new Expr.Variable(prefixes[i]);
>, <Line: -			master.write(i, v);
>, <Line: -			arguments[i] = v;
>, <Line: -		}
>, <Line: -		// Second, assume all preconditions. To do this, we simply invoke the
>, <Line: -		// precondition macro for each one.
>, <Line: -		prefix = method.name() + "_requires_";
>, <Line: -		for (int i = 0; i != preconditions.length; ++i) {
>, <Line: -			Expr arg = arguments.length == 1 ? arguments[0] : new Expr.Nary(
>, <Line: -					Expr.Nary.Op.TUPLE, arguments);
>, <Line: -			Expr.Invoke macro = new Expr.Invoke(prefix + i, wyilFile.id(),
>, <Line: -					Collections.EMPTY_LIST, arg);
>, <Line: -			master.assume(macro);
>, <Line: -		}
>, <Line: -		// Traverse the function or method's body. This can produce potentially
>, <Line: -		// many terminated and failed branches, though none should still be
>, <Line: -		// active. Terminated branches are those which have reached a return
>, <Line: -		// statement, whilst failed branches are those which have reached a fail
>, <Line: -		// statement.
>, <Line: -		List<VcBranch> exitBranches = transform(master, pc, false, bodyEnvironment, forest);
>, <Line: -		// Examine all branches produced from the body. Each should be in one of
>, <Line: -		// two states: terminated or failed. Failed states indicate some
>, <Line: -		// internal assertion was not met (for example, a loop invariant was not
>, <Line: -		// restored, etc). In contrast, terminated states indicate those which
>, <Line: -		// have successfully reached the end of the function. For these cases,
>, <Line: -		// we need to then check the post-condition.
>, <Line: -		for (VcBranch branch : exitBranches) {
>, <Line: -			switch (branch.state()) {
>, <Line: -			case FAILED: {
>, <Line: -				// This is a failed branch state. In this case, we construct a
>, <Line: -				// verification condition which enforces that the constraints
>, <Line: -				// leading up to this position cannot hold. In other words, that
>, <Line: -				// this is an unreachable path.
>, <Line: -				Expr vc = buildVerificationCondition(new Expr.Constant(Value.Bool(false)), branch, bodyEnvironment,
>, <Line: -						forest);
>, <Line: -				wyalFile.add(wyalFile.new Assert("assertion failed", vc,
>, <Line: -						VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes())));
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case TERMINATED: {
>, <Line: -				if (fmm.returns().isEmpty()) {
>, <Line: -					// In this case, there is not return value and, hence, there
>, <Line: -					// is no need to ensure the postcondition holds.
>, <Line: -				} else {
>, <Line: -					List<wyil.lang.Attribute> attributes = forest.get(branch.pc()).attributes();
>, <Line: -					Collection<wycc.lang.Attribute> wycsAttributes = VcUtils.toWycsAttributes(attributes);
>, <Line: -					// Find the return statement in question
>, <Line: -					Bytecode.Return ret = (Bytecode.Return) forest.get(branch.pc()).code();
>, <Line: -					// Construct verification check to ensure that return
>, <Line: -					// type invariant holds
>, <Line: -					// FIXME: need proper support for multiple returns
>, <Line: -					Expr returnedOperand = branch.read(ret.operand(0));					
>, <Line: -					Type rawType = expand(bodyEnvironment[ret.operand(0)],attributes);
>, <Line: -					Expr rawTest = new Expr.Is(returnedOperand,
>, <Line: -							utils.convert(rawType, attributes));
>, <Line: -					// FIXME: needs to handle all returns
>, <Line: -					if (utils.containsNominal(fmm.returns().get(0),attributes)) {
>, <Line: -						// FIXME: we need the raw test here, because the
>, <Line: -						// verifier can't work out the type of the expression
>, <Line: -						// otherwise.						
>, <Line: -						Expr nominalTest = new Expr.Is(returnedOperand,
>, <Line: -								utils.convert(fmm.returns().get(0), attributes));
>, <Line: -						Expr vc = buildVerificationCondition(nominalTest,
>, <Line: -								branch, bodyEnvironment, forest, rawTest);
>, <Line: -						// FIXME: add contextual information here
>, <Line: -						wyalFile.add(wyalFile.new Assert(
>, <Line: -								"return type invariant not satisfied", vc,
>, <Line: -								wycsAttributes));
>, <Line: -					}
>, <Line: -					// Construct arguments for the macro invocation. Only
>, <Line: -					// the returned value is read from the branch at the current
>, <Line: -					// pc. The other arguments correspond to the parameters
>, <Line: -					// which held on entry to this function.
>, <Line: -					arguments = new Expr[fmm.params().size() + 1];
>, <Line: -					for (int i = 0; i != fmm.params().size(); ++i) {
>, <Line: -						arguments[i] = new Expr.Variable(prefixes[i]);
>, <Line: -					}
>, <Line: -					arguments[fmm.params().size()] = returnedOperand;
>, <Line: -					// For each postcondition generate a separate
>, <Line: -					// verification condition. Doing this allows us to gather
>, <Line: -					// more detailed context information in the case of a
>, <Line: -					// failure about which post-condition is failing.
>, <Line: -					prefix = method.name() + "_ensures_";
>, <Line: -					for (int i = 0; i != postconditions.length; ++i) {
>, <Line: -						Expr arg = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: -						Expr.Invoke macro = new Expr.Invoke(prefix + i, wyilFile.id(), Collections.EMPTY_LIST, arg);
>, <Line: -						Expr vc = buildVerificationCondition(macro, branch, bodyEnvironment, forest, rawTest);
>, <Line: -						// FIXME: add contextual information here
>, <Line: -						wyalFile.add(wyalFile.new Assert("postcondition not satisfied", vc,
>, <Line: -								VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes())));
>, <Line: -					}
>, <Line: -				}
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			default:
>, <Line: -				// This should be impossible to reach!
>, <Line: -				internalFailure("unreachable code reached! (" + branch.state() + ")", filename,
>, <Line: -						forest.get(branch.pc()).attributes());
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -	// ===============================================================================
>, <Line: -	// Block controller
>, <Line: -	// ===============================================================================
>, <Line: -	/**
>, <Line: -	 * Transform a branch through a given outermost block, producing the
>, <Line: -	 * constraints which hold at the end. In the case of a function or method
>, <Line: -	 * body, every branch will be terminated with a return statement and, in
>, <Line: -	 * this case only, this will return null.
>, <Line: -	 * 
>, <Line: -	 * @param branch
>, <Line: -	 *            Branch state going into the block
>, <Line: -	 * @param block
>, <Line: -	 *            Block being transformed over
>, <Line: -	 * 
>, <Line: -	 * @return List of branches which reach the end of the block.
>, <Line: -	 */
>, <Line: -	public List<VcBranch> transform(VcBranch branch, BytecodeForest.Index root, boolean isInvariant, Type[] environment,
>, <Line: -			BytecodeForest forest) {
>, <Line: -		// Construct the label map which is needed for conditional branches
>, <Line: -		Map<String, BytecodeForest.Index> labels = Bytecode.buildLabelMap(forest);
>, <Line: -		Pair<VcBranch, List<VcBranch>> p = transform(root.block(), 0, null, branch, false, isInvariant, environment,
>, <Line: -				labels, forest);
>, <Line: -		// Ok, return list of exit branches
>, <Line: -		return p.second();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a given branch over a block of zero or more statements. In the
>, <Line: -	 * case of a straight-line sequence, this is guaranteed to produce at most
>, <Line: -	 * one outgoing branch (zero is possible if sequence includes a return). For
>, <Line: -	 * an instruction sequence with one or more conditional branches, multiple
>, <Line: -	 * branches may be produced representing the different possible traversals.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * This function symbolically executes each branch it is maintaining until
>, <Line: -	 * it either terminates (e.g. returns), or leaves the block. Furthermore,
>, <Line: -	 * branches which terminate at the same pc are joined together. This ensures
>, <Line: -	 * that, for example, only one branch is returned in the case of blocks with
>, <Line: -	 * single exit paths.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param parent
>, <Line: -	 *            The index in the root block of the given block being iterated
>, <Line: -	 *            over.
>, <Line: -	 * @param offset
>, <Line: -	 *            The offset within the block to start from. In most cases, this
>, <Line: -	 *            is zero (i.e. the start of the block). However, to support
>, <Line: -	 *            loop invariants, we need the ability to restart a block from
>, <Line: -	 *            just after the invariant.
>, <Line: -	 * @param entryState
>, <Line: -	 *            The initial state on entry to the block. This is assumed to be
>, <Line: -	 *            located at the first instruction of the block.
>, <Line: -	 * @param breakOnInvariant
>, <Line: -	 *            With this flag enabled, the transformer will continue looping
>, <Line: -	 *            around the block until an invariant bytecode is found, at
>, <Line: -	 *            which point it will break. If no invariant is found, this will
>, <Line: -	 *            loop forever.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The map from labels to their block locations
>, <Line: -	 * @param block
>, <Line: -	 *            The block being transformed over.
>, <Line: -	 * @return A pair consisting of: the active branch (if any) which has fallen
>, <Line: -	 *         through the end of the block and is now located at the
>, <Line: -	 *         instruction following the parent; and, the list of zero or more
>, <Line: -	 *         branches which have terminated or failed. Note, when there is no
>, <Line: -	 *         parent, then there can be no fall-through either and, instead,
>, <Line: -	 *         this is marked as terminated.
>, <Line: -	 * 
>, <Line: -	 */
>, <Line: -	protected Pair<VcBranch, List<VcBranch>> transform(int block, int offset, BytecodeForest.Index parent,
>, <Line: -			VcBranch entryState, boolean breakOnInvariant, boolean isInvariant, Type[] environment,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		// Move state to correct location
>, <Line: -		entryState.goTo(new BytecodeForest.Index(block, offset));
>, <Line: -		BytecodeForest.Block blk = forest.get(block);
>, <Line: -		// Construct list of branches being processed.
>, <Line: -		Stack<VcBranch> worklist = new Stack<VcBranch>();
>, <Line: -		ArrayList<VcBranch> exitBranches = new ArrayList<VcBranch>();
>, <Line: -		ArrayList<VcBranch> fallThruBranches = new ArrayList<VcBranch>();		
>, <Line: -		worklist.push(entryState);
>, <Line: -		// Process all branches in the worklist until it is empty and there are
>, <Line: -		// none left to process.
>, <Line: -		while (worklist.size() > 0) {
>, <Line: -			VcBranch branch = worklist.pop();
>, <Line: -			// The program counter represents the current position of the branch
>, <Line: -			// being explored.
>, <Line: -			BytecodeForest.Index pc = branch.pc();
>, <Line: -			// Determine whether to continue executing this branch, or whether
>, <Line: -			// it has completed within this scope.
>, <Line: -			if (pc.block() != block || branch.state() != VcBranch.State.ACTIVE) {
>, <Line: -				// This indicates the given branch has either exited this block
>, <Line: -				// via a non-local branch, or terminated in some fashion.
>, <Line: -				// Therefore, this branch is moved into the list of exit
>, <Line: -				// branches.
>, <Line: -				exitBranches.add(branch);
>, <Line: -			} else if (pc.block() == block && pc.offset() >= blk.size()) {
>, <Line: -				// This indicates the given branch has exited this block by
>, <Line: -				// falling through. We now need to check for breakOnInvariant.
>, <Line: -				if (breakOnInvariant) {
>, <Line: -					// Break On Invariant is enabled, therefore continue going
>, <Line: -					// around.
>, <Line: -					branch.goTo(parent);
>, <Line: -				} else if (parent != null) {
>, <Line: -					// No reset, allow to exit branch as normal. First, set
>, <Line: -					// branch location to the next instruction following the
>, <Line: -					// parent instruction containing this block.
>, <Line: -					branch.goTo(parent.next());
>, <Line: -				} else {
>, <Line: -					internalFailure("unreachable code reached!", filename, forest.get(pc).attributes());
>, <Line: -				}
>, <Line: -				fallThruBranches.add(branch);
>, <Line: -			} else {
>, <Line: -				// Continue executing this branch as it is still within the
>, <Line: -				// scope of this block.
>, <Line: -				Bytecode code = forest.get(pc).code();
>, <Line: -				// Now, dispatch statements. Control statements are treated
>, <Line: -				// specially from unit statements.
>, <Line: -				if (code instanceof Bytecode.AssertOrAssume) {
>, <Line: -					if (breakOnInvariant && code instanceof Bytecode.Invariant) {
>, <Line: -						// In this special case, we have reached the invariant
>, <Line: -						// bytecode and, hence, we break out of this loop. This
>, <Line: -						// is needed for handling loop invariants where we need
>, <Line: -						// to do special things when the invariant is
>, <Line: -						// encountered.
>, <Line: -						fallThruBranches.add(branch);
>, <Line: -					} else {
>, <Line: -						boolean isAssert = code instanceof Bytecode.Assert;
>, <Line: -						Pair<VcBranch, List<VcBranch>> p = transform((Bytecode.AssertOrAssume) code, isAssert, branch,
>, <Line: -								environment, labels, forest);
>, <Line: -						if(p.first() != null) {
>, <Line: -							worklist.add(p.first());
>, <Line: -						}
>, <Line: -						worklist.addAll(p.second());
>, <Line: -					}
>, <Line: -				} else if (code instanceof Bytecode.If
>, <Line: -						|| code instanceof Bytecode.IfIs
>, <Line: -						|| code instanceof Bytecode.Switch
>, <Line: -						|| code instanceof Bytecode.Compound) {
>, <Line: -					List<VcBranch> bs;
>, <Line: -					if (code instanceof Bytecode.If) {
>, <Line: -						bs = transform((Bytecode.If) code, branch, labels, forest);
>, <Line: -					} else if (code instanceof Bytecode.IfIs) {
>, <Line: -						bs = transform((Bytecode.IfIs) code, branch, labels, forest);
>, <Line: -					} else if (code instanceof Bytecode.Switch) {
>, <Line: -						bs = transform((Bytecode.Switch) code, branch, labels,
>, <Line: -								forest);
>, <Line: -					} else if (code instanceof Bytecode.Quantify) {
>, <Line: -						bs = transform((Bytecode.Quantify) code, branch,
>, <Line: -								isInvariant, environment, labels, forest);
>, <Line: -					} else {
>, <Line: -						bs = transform((Bytecode.Loop) code, branch, environment,
>, <Line: -								labels, forest);
>, <Line: -					}
>, <Line: -					worklist.addAll(bs);
>, <Line: -				} else if (code instanceof Bytecode.Goto) {
>, <Line: -					transform((Bytecode.Goto) code, branch, labels, forest);
>, <Line: -					worklist.push(branch);
>, <Line: -				} else if (code instanceof Bytecode.Return) {
>, <Line: -					transform((Bytecode.Return) code, branch);
>, <Line: -					exitBranches.add(branch);
>, <Line: -				} else if (code instanceof Bytecode.Fail) {
>, <Line: -					transform((Bytecode.Fail) code, branch, forest);
>, <Line: -					exitBranches.add(branch);
>, <Line: -				} else {
>, <Line: -					// Unit statement. First, check whether or not there are any
>, <Line: -					// preconditions for this statement and, if so, add
>, <Line: -					// appropriate verification conditions to enforce them.
>, <Line: -					if (!isInvariant) {
>, <Line: -						Pair<String, Expr>[] preconditions = utils.getPreconditions(code, branch, environment, forest);
>, <Line: -						if (preconditions.length > 0) {
>, <Line: -							// This bytecode has one or more preconditions which
>, <Line: -							// need to be asserted. Therefore, for each, create
>, <Line: -							// a
>, <Line: -							// failed branch to ensure the precondition is met.
>, <Line: -							for (int i = 0; i != preconditions.length; ++i) {
>, <Line: -								Pair<String, Expr> p = preconditions[i];
>, <Line: -								Expr vc = buildVerificationCondition(
>, <Line: -										p.second(), branch, environment, forest);
>, <Line: -								wyalFile.add(wyalFile.new Assert(p.first(), vc,
>, <Line: -										VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes())));
>, <Line: -							}
>, <Line: -							// We need to fork the branch here, because it must
>, <Line: -							// have
>, <Line: -							// INTERNAL state by now (i.e. because of the forks
>, <Line: -							// above).
>, <Line: -							branch = branch.fork();
>, <Line: -						}
>, <Line: -					}
>, <Line: -					//
>, <Line: -					unitGen.transform(code, forest, branch);
>, <Line: -					branch.goTo(pc.next());
>, <Line: -					worklist.push(branch);
>, <Line: -				}
>, <Line: -			}
>, <Line: -		}
>, <Line: -		joinAll(exitBranches);
>, <Line: -		joinAll(fallThruBranches);
>, <Line: -		VcBranch fallThru = null;
>, <Line: -		// Select the fall through branch
>, <Line: -		if (fallThruBranches.size() == 1) {
>, <Line: -			fallThru = fallThruBranches.get(0);
>, <Line: -		} else if (fallThruBranches.size() > 1) {
>, <Line: -			// Should be unreachable. Sanity check for now.
>, <Line: -			internalFailure("unreacahble code reached", filename, forest.get(parent).attributes());
>, <Line: -		}
>, <Line: -		return new Pair<VcBranch, List<VcBranch>>(fallThru, exitBranches);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Join all branches with matching PC locations. Branches are joined by
>, <Line: -	 * taking the disjunction of those paths which differ, whilst still
>, <Line: -	 * including those common to both as a conjunction.
>, <Line: -	 * 
>, <Line: -	 * @param branches
>, <Line: -	 */
>, <Line: -	private void joinAll(ArrayList<VcBranch> branches) {
>, <Line: -		// First, go through and join all branches with the same pc using the
>, <Line: -		// lower numbered branch as the "master". Once a branch has been joined,
>, <Line: -		// simply null it out.
>, <Line: -		for (int i = 0; i < branches.size(); ++i) {
>, <Line: -			VcBranch i_branch = branches.get(i);
>, <Line: -			if (i_branch != null) {
>, <Line: -				BytecodeForest.Index i_pc = i_branch.pc();
>, <Line: -				// Now, the goal is to identify all remaining branches which are
>, <Line: -				// at the same location. These can then be all joined together
>, <Line: -				// in one go. First, we count how many their are
>, <Line: -				int count = 0;
>, <Line: -				for (int j = i + 1; j < branches.size(); ++j) {
>, <Line: -					VcBranch j_branch = branches.get(j);
>, <Line: -					if (j_branch != null && i_pc.equals(j_branch.pc())) {
>, <Line: -						count = count + 1;
>, <Line: -					}
>, <Line: -				}
>, <Line: -				// Second, we store them up into the array and remove them from
>, <Line: -				// the branches array.
>, <Line: -				VcBranch[] matches = new VcBranch[count];
>, <Line: -				count = 0;
>, <Line: -				for (int j = i + 1; j < branches.size(); ++j) {
>, <Line: -					VcBranch j_branch = branches.get(j);
>, <Line: -					if (j_branch != null && i_pc.equals(j_branch.pc())) {
>, <Line: -						matches[count++] = j_branch;
>, <Line: -						branches.set(j, null);
>, <Line: -					}
>, <Line: -				}
>, <Line: -				// Finally, if there are matching branches, we them all together
>, <Line: -				// producing an updated branch which lives on.
>, <Line: -				if (matches.length > 0) {
>, <Line: -					VcBranch nBranch = i_branch.join(matches);
>, <Line: -					branches.set(i, nBranch);
>, <Line: -				}
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// At this stage, the branches array may contain null entries as a
>, <Line: -		// result of the joining process. We now go through and compact all the
>, <Line: -		// remaining branches to the lower indices, and the null entries to the
>, <Line: -		// upper indices.
>, <Line: -		int j = 0;
>, <Line: -		for (int i = 0; i != branches.size(); ++i) {
>, <Line: -			VcBranch b = branches.get(i);
>, <Line: -			if (b != null) {
>, <Line: -				branches.set(j++, b);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// Finally, remove all null entries at the top of the branches array.
>, <Line: -		while (branches.size() != j) {
>, <Line: -			branches.remove(j);
>, <Line: -		}
>, <Line: -		// Done.
>, <Line: -	}
>, <Line: -	// ===============================================================================
>, <Line: -	// Control Bytecodes
>, <Line: -	// ===============================================================================
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a loop bytecode. This is done by splitting the
>, <Line: -	 * entry branch into the case for the loop body, and the case for the loop
>, <Line: -	 * after. First, modified variables are invalidated to disconnect them from
>, <Line: -	 * information which held before the loop. Second, the loop invariant is
>, <Line: -	 * assumed as this provides the only information known about modified
>, <Line: -	 * variables.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * <p>
>, <Line: -	 * For the case of the loop body, there are several scenarios. For branches
>, <Line: -	 * which make it to the end of the body, the loop invariant must be
>, <Line: -	 * reestablished. For branches which exit the loop, these are then folded
>, <Line: -	 * into enclosing scope.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The enclosing loop bytecode to be transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch state going into this bytecode.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The mapping of labels to locations in the given block.
>, <Line: -	 * @param block
>, <Line: -	 *            The enclosing code block. This is needed to access source
>, <Line: -	 *            location information.
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> transform(Bytecode.Loop code, VcBranch branch,
>, <Line: -			Type[] environment, Map<String, BytecodeForest.Index> labels,
>, <Line: -			BytecodeForest forest) {
>, <Line: -		return transformLoopHelper(code, branch, environment, labels, forest).second();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a loop bytecode. This is done by splitting the
>, <Line: -	 * entry branch into the case for the loop body, and the case for the loop
>, <Line: -	 * after. First, modified variables are invalidated to disconnect them from
>, <Line: -	 * information which held before the loop. Second, the loop invariant is
>, <Line: -	 * assumed as this provides the only information known about modified
>, <Line: -	 * variables.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * <p>
>, <Line: -	 * For the case of the loop body, there are several scenarios. For branches
>, <Line: -	 * which make it to the end of the body, the loop invariant must be
>, <Line: -	 * reestablished. For branches which exit the loop, these are then folded
>, <Line: -	 * into enclosing scope.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The map from labels to their block locations
>, <Line: -	 * @param block
>, <Line: -	 *            The block being transformed over.
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> transform(Bytecode.Quantify code, VcBranch branch,
>, <Line: -			boolean isInvariant, Type[] environment,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		// Write an arbitrary value to the index operand. This is necessary to
>, <Line: -		// ensure that there is something there if it is used within the loop
>, <Line: -		// body.
>, <Line: -		branch.havoc(code.indexOperand());
>, <Line: -		//
>, <Line: -		VcBranch original = branch.fork();
>, <Line: -		branch = branch.fork();
>, <Line: -		// This represents a quantifier looop
>, <Line: -		Pair<VcBranch, List<VcBranch>> p = transformQuantifierHelper(code,
>, <Line: -				branch, isInvariant, environment, labels, forest);
>, <Line: -		return extractQuantifiers(code, original, p.first(), p.second());
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * This extracts quantifiers from exit branches of a forall loop. There are
>, <Line: -	 * two kinds of quantifiers which will be generated. A universal quantifier
>, <Line: -	 * is created for the fall thru branch, whilst existential quantifiers are
>, <Line: -	 * created for exit branches which are either still active (i.e. still
>, <Line: -	 * progressing) or have terminated or failed.
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 * @param root
>, <Line: -	 * @param fallThru
>, <Line: -	 * @param exitBranches
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> extractQuantifiers(Bytecode.Quantify code,
>, <Line: -			VcBranch root, VcBranch fallThru, List<VcBranch> exitBranches) {
>, <Line: -		// First, setup some helper variables for use in the remainder.
>, <Line: -		SyntacticType elementType = utils.convert(Type.T_INT,
>, <Line: -				Collections.EMPTY_LIST);
>, <Line: -		Expr index = root.read(code.indexOperand());
>, <Line: -		TypePattern pattern = new TypePattern.Leaf(elementType,
>, <Line: -				(Expr.Variable) index);		
>, <Line: -		Expr lowerBound = new Expr.Binary(Expr.Binary.Op.LTEQ,
>, <Line: -				root.read(code.startOperand()), index);
>, <Line: -		Expr upperBound = new Expr.Binary(Expr.Binary.Op.LT, index,
>, <Line: -				root.read(code.endOperand()));
>, <Line: -		Expr range = new Expr.Binary(Expr.Binary.Op.AND, lowerBound, upperBound);
>, <Line: -		ArrayList<VcBranch> qBranches = new ArrayList<VcBranch>();
>, <Line: -		// Second, deal with the universally quantified fall-thru branch. We
>, <Line: -		// fork the root for this in order not to disturb it. We also must
>, <Line: -		// include the elementOf which implies for the forall body.
>, <Line: -		Expr forallBody = generateAssumptions(fallThru, root);
>, <Line: -		fallThru = root.fork();
>, <Line: -		fallThru.assume(new Expr.ForAll(pattern, new Expr.Binary(
>, <Line: -				Expr.Binary.Op.IMPLIES, range, forallBody)));
>, <Line: -		fallThru.goTo(fallThru.pc().next());
>, <Line: -		qBranches.add(fallThru);
>, <Line: -		// Finally, deal with existential branches next. We must fork the root
>, <Line: -		// again for this, since it will now be immutable.
>, <Line: -		for (int i = 0; i != exitBranches.size(); ++i) {
>, <Line: -			VcBranch b = exitBranches.get(i);
>, <Line: -			Expr body = generateAssumptions(b, root);
>, <Line: -			body = new Expr.Binary(Expr.Binary.Op.AND, range, body);
>, <Line: -			BytecodeForest.Index target = b.pc();
>, <Line: -			b = root.fork();
>, <Line: -			b.assume(new Expr.Exists(pattern, body));
>, <Line: -			b.goTo(target);
>, <Line: -			qBranches.add(b);
>, <Line: -		}
>, <Line: -		return qBranches;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Transform an arbitrary quantifier. Quantifiers are treated differently
>, <Line: -	 * from loop bytecodes as they do not include loop invariants, and generate
>, <Line: -	 * quantified formulae.
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The enclosing loop bytecode to be transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch state going into this bytecode.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The mapping of labels to locations in the given block.
>, <Line: -	 * @param block
>, <Line: -	 *            The enclosing code block. This is needed to access source
>, <Line: -	 *            location information.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected Pair<VcBranch, List<VcBranch>> transformQuantifierHelper(
>, <Line: -			Bytecode.Loop code, VcBranch branch, boolean isInvariant,
>, <Line: -			Type[] environment, Map<String, BytecodeForest.Index> labels,
>, <Line: -			BytecodeForest forest) {
>, <Line: -		// The loopPc gives the block index of the loop bytecode.
>, <Line: -		BytecodeForest.Index loopPc = branch.pc();
>, <Line: -		// This is the easy case, as there is no loop invariant. Therefore,
>, <Line: -		// we just havoc modified variables at the beginning and then allow
>, <Line: -		// branches to exit the loop as normal. Branches which reach the end
>, <Line: -		// of the loop body are returned to be universally quantified
>, <Line: -		havocVariables(code.modifiedOperands(), branch);
>, <Line: -		VcBranch activeBranch = branch.fork();
>, <Line: -		// Now, run through loop body. This will produce several kinds of
>, <Line: -		// branch. Those which have terminated or branched out of the loop body,
>, <Line: -		// and those which have reached the end of the loop body. ).
>, <Line: -		return transform(code.block(),0,loopPc, activeBranch, false, isInvariant, environment, labels, forest);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Transform an arbitrary loop (i.e. one that could be generic or forall
>, <Line: -	 * loop). This will first determine whether or not a loop invariant is
>, <Line: -	 * present. If not, then a conservative approach to dealing with modified
>, <Line: -	 * variables is taken. If so, then the loop invariant must be established on
>, <Line: -	 * entry, and then restored on subsequence iterations assuming it held on
>, <Line: -	 * the iteration before (i.e. the inductive hypothesis).
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The enclosing loop bytecode to be transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch state going into this bytecode.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The mapping of labels to locations in the given block.
>, <Line: -	 * @param block
>, <Line: -	 *            The enclosing code block. This is needed to access source
>, <Line: -	 *            location information.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected Pair<VcBranch, List<VcBranch>> transformLoopHelper(Bytecode.Loop code, VcBranch branch, Type[] environment,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		// The loopPc gives the block index of the loop bytecode.
>, <Line: -		BytecodeForest.Index loopPc = branch.pc();
>, <Line: -		int invariantOffset = getInvariantOffset(code,forest);
>, <Line: -		// First thing we need to do is determine whether or not this loop has a
>, <Line: -		// loop invariant, as this affects how we will approach it.
>, <Line: -		if (invariantOffset == -1) {
>, <Line: -			return transformLoopWithoutInvariant(code, branch, environment, labels, forest);
>, <Line: -		} else {
>, <Line: -			// Determine how many invariant blocks there are, as there might be
>, <Line: -			// more than one. In the case that there is more than one, they are
>, <Line: -			// assumed to be arranged consecutively one after the other.
>, <Line: -			BytecodeForest.Block block = forest.get(code.block());
>, <Line: -			int numberOfInvariants = 0;
>, <Line: -			for (int i = invariantOffset; i < block.size()
>, <Line: -					&& block.get(i).first() instanceof Bytecode.Invariant; ++i) {
>, <Line: -				numberOfInvariants = numberOfInvariants+1;
>, <Line: -			}
>, <Line: -			//
>, <Line: -			BytecodeForest.Index firstInvariantPc = new BytecodeForest.Index(code.block(), invariantOffset);
>, <Line: -			String invariantMacroPrefix = method.name() + "_loopinvariant_";
>, <Line: -			// FIXME: this is a hack to determine which variables should be
>, <Line: -			// passed into the loop invariant macro. However, it really is a
>, <Line: -			// hack. Firstly, we use the prefixes to ensure that only named
>, <Line: -			// variables are included in the loop invariant. Secondly, we check
>, <Line: -			// whether the variable in question has been defined yet to further
>, <Line: -			// eliminate variables.
>, <Line: -			String[] prefixes = branch.prefixes();
>, <Line: -			boolean[] variables = new boolean[environment.length];
>, <Line: -			for (int i = 0; i != variables.length; ++i) {
>, <Line: -				if (branch.read(i) != null && prefixes[i] != null) {
>, <Line: -					variables[i] = true;
>, <Line: -				}
>, <Line: -			}
>, <Line: -			// *** END ***
>, <Line: -			for(int i=0;i!=numberOfInvariants;++i) {
>, <Line: -				buildInvariantMacro(firstInvariantPc.next(i), variables, environment, forest);
>, <Line: -			}
>, <Line: -			// This is the harder case as we must account for the loop invariant
>, <Line: -			// properly. To do this, we allow the loop to execute upto the loop
>, <Line: -			// invariant using the current branch state. At this point, we havoc
>, <Line: -			// modified variables and then assume the loop invariant, before
>, <Line: -			// running through the loop until the invariant is reached again.
>, <Line: -			Pair<VcBranch, List<VcBranch>> p = transform(code.block(), 0, loopPc, branch, true, false, environment, labels, forest);
>, <Line: -			// At this point, any branch which has terminated or branched out of
>, <Line: -			// the loop represents a true execution path. Any branch which has
>, <Line: -			// failed corresponds to ensuring the loop invariant on entry.
>, <Line: -			// Active branches which reach the invariant need special
>, <Line: -			// processing.
>, <Line: -			VcBranch activeBranch = p.first();
>, <Line: -			List<VcBranch> exitBranches = p.second();
>, <Line: -			// Enforce invariants on entry. To do this, we generate a
>, <Line: -			// verification condition that asserts each invariant macro given the
>, <Line: -			// current branch state.
>, <Line: -			for (int i = 0; i != numberOfInvariants; ++i) {
>, <Line: -				BytecodeForest.Index invariantPc = firstInvariantPc.next(i);
>, <Line: -				String invariantMacroName = invariantMacroPrefix + invariantPc.toString().replace(":", "_");
>, <Line: -				Expr.Invoke invariant = buildInvariantCall(activeBranch, invariantMacroName, variables);
>, <Line: -				Expr vc = buildVerificationCondition(invariant, activeBranch, environment, forest);
>, <Line: -				wyalFile.add(wyalFile.new Assert("loop invariant does not hold on entry", vc,
>, <Line: -						VcUtils.toWycsAttributes(forest.get(invariantPc).attributes())));
>, <Line: -			}
>, <Line: -			// Assume invariant holds for inductive case. To this, we first
>, <Line: -			// havoc all modified variables to ensure that information about
>, <Line: -			// them is not carried forward from before the loop. Then, we assume
>, <Line: -			// the invariant macro holds in the current branch state.
>, <Line: -			havocVariables(code.modifiedOperands(), activeBranch);
>, <Line: -			for (int i = 0; i != numberOfInvariants; ++i) {
>, <Line: -				BytecodeForest.Index invariantPc = firstInvariantPc.next(i);
>, <Line: -				String invariantMacroName = invariantMacroPrefix
>, <Line: -						+ invariantPc.toString().replace(":", "_");
>, <Line: -				Expr.Invoke invariant = buildInvariantCall(activeBranch, invariantMacroName,
>, <Line: -						variables);
>, <Line: -				activeBranch.assume(invariant);
>, <Line: -			}
>, <Line: -			// Process inductive case for this branch by allowing it to
>, <Line: -			// execute around the loop until the invariant is found again.
>, <Line: -			// Branches which prematurely exit the loop are passed into the list
>, <Line: -			// of exit branches. These are valid as they only have information
>, <Line: -			// from the loop invariant.
>, <Line: -			p = transform(code.block(), invariantOffset + numberOfInvariants, loopPc, activeBranch, true, false,
>, <Line: -					environment, labels, forest);
>, <Line: -			activeBranch = p.first();
>, <Line: -			exitBranches.addAll(p.second());
>, <Line: -			// Reestablish loop invariant. To do this, we generate a
>, <Line: -			// verification condition that asserts the invariant macro given the
>, <Line: -			// current branch state.
>, <Line: -			for (int i = 0; i != numberOfInvariants; ++i) {
>, <Line: -				BytecodeForest.Index invariantPc = firstInvariantPc.next(i);
>, <Line: -				String invariantMacroName = invariantMacroPrefix
>, <Line: -						+ invariantPc.toString().replace(":", "_");
>, <Line: -				Expr.Invoke invariant = buildInvariantCall(activeBranch,
>, <Line: -						invariantMacroName, variables);
>, <Line: -				Expr vc = buildVerificationCondition(invariant, activeBranch,
>, <Line: -						environment, forest);
>, <Line: -				wyalFile.add(wyalFile.new Assert("loop invariant not restored",
>, <Line: -						vc, VcUtils.toWycsAttributes(forest.get(invariantPc).attributes())));
>, <Line: -			}
>, <Line: -			// Reposition fall-through
>, <Line: -			activeBranch.goTo(loopPc.next());
>, <Line: -			// Done.
>, <Line: -			return new Pair<VcBranch, List<VcBranch>>(activeBranch,
>, <Line: -					exitBranches);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Transform the loop assuming it has no loop invariant. This means that
>, <Line: -	 * effectively all information about variables modified in the loop is
>, <Line: -	 * discarded.
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The enclosing loop bytecode to be transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch state going into this bytecode.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The mapping of labels to locations in the given block.
>, <Line: -	 * @param block
>, <Line: -	 *            The enclosing code block. This is needed to access source
>, <Line: -	 *            location information.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected Pair<VcBranch, List<VcBranch>> transformLoopWithoutInvariant(
>, <Line: -			Bytecode.Loop code, VcBranch branch, Type[] environment,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		BytecodeForest.Index loopPc = branch.pc();
>, <Line: -		// This is the easy case, as there is no loop invariant. Therefore,
>, <Line: -		// we just havoc modified variables at the beginning and then allow
>, <Line: -		// branches to exit the loop as normal. Branches which reach the end
>, <Line: -		// of the loop body can be discarded as they represent correct
>, <Line: -		// execution through the loop.
>, <Line: -		havocVariables(code.modifiedOperands(), branch);
>, <Line: -		VcBranch fallThru = branch.fork();
>, <Line: -		VcBranch activeBranch = branch.fork();
>, <Line: -		// Now, run through loop body. This will produce several kinds of
>, <Line: -		// branch. Those which have terminated or branched out of the loop body,
>, <Line: -		// and those which have reached the end of the loop body. All branches
>, <Line: -		// in the former case go straight onto the list of returned branches.
>, <Line: -		// Those in the latter case are discarded (as discussed above).
>, <Line: -		Pair<VcBranch, List<VcBranch>> p = transform(code.block(), 0, loopPc, activeBranch, false, false, environment, labels,
>, <Line: -				forest);
>, <Line: -		fallThru.goTo(loopPc.next());
>, <Line: -		return new Pair<VcBranch, List<VcBranch>>(fallThru, p.second());
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Construct a macro in the generated Wyal file which embodies the given
>, <Line: -	 * loop invariant. Thus, the loop invariant can be asserted by asserting
>, <Line: -	 * this macro, and can be assumed by assuming this macro (with appropriate
>, <Line: -	 * arguments of course). For simplicity, the generated macro will accept all
>, <Line: -	 * active variables (i.e. rather than one-time temporaries). This is not
>, <Line: -	 * completely efficient in the case of variables which are not referenced by
>, <Line: -	 * the invariant, but it's a simple and pragmatic choice.
>, <Line: -	 * 
>, <Line: -	 * @param invariantPC
>, <Line: -	 *            The location of the invariant. This is used simply to give the
>, <Line: -	 *            invariant a unique identifier to distinguish it from other
>, <Line: -	 *            invariants in the same function or method.
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param block
>, <Line: -	 *            The enclosing code block
>, <Line: -	 */
>, <Line: -	private void buildInvariantMacro(BytecodeForest.Index invariantPC,
>, <Line: -			boolean[] variables, Type[] environment, BytecodeForest forest) {
>, <Line: -		Bytecode.Invariant code = (Bytecode.Invariant) forest.get(invariantPC).first();
>, <Line: -		// FIXME: we don't need to include all variables, only those which are
>, <Line: -		// "active".
>, <Line: -		ArrayList<Type> types = new ArrayList<Type>();
>, <Line: -		for (int i = 0; i != variables.length; ++i) {
>, <Line: -			if (variables[i]) {
>, <Line: -				types.add(environment[i]);
>, <Line: -			} else {
>, <Line: -				types.add(null);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		String pc = invariantPC.block() + "_" + invariantPC.offset();
>, <Line: -		BytecodeForest.Index root = new BytecodeForest.Index(code.block(),0);
>, <Line: -		buildMacroBlock(method.name() + "_loopinvariant_" + pc, root, forest, types, true);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Construct invocation of loop invariant macro. This is used both for
>, <Line: -	 * asserting and assuming the invariant holds at different positions
>, <Line: -	 * throughout the process.
>, <Line: -	 * 
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch in which the call is being constructed. This is
>, <Line: -	 *            needed to access the current state of relevant varibles.
>, <Line: -	 * @param name
>, <Line: -	 *            The name of the loop invariant macro. This is determined using
>, <Line: -	 *            the current method name and pc location.
>, <Line: -	 * @param variables
>, <Line: -	 *            the list of variables which are passed into the macro.
>, <Line: -	 *            Essentially, this is the list of variables which existed
>, <Line: -	 *            before the loop (i.e. rather than those local to the loop).
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected Expr.Invoke buildInvariantCall(VcBranch branch, String name,
>, <Line: -			boolean[] variables) {
>, <Line: -		List<Expr> arguments = new ArrayList<Expr>();
>, <Line: -		for (int i = 0; i != variables.length; ++i) {
>, <Line: -			if (variables[i]) {
>, <Line: -				arguments.add(branch.read(i));
>, <Line: -			}
>, <Line: -		}
>, <Line: -		Expr argument = arguments.size() == 1 ? arguments.get(0)
>, <Line: -				: new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: -		return new Expr.Invoke(name, wyalFile.id(), Collections.EMPTY_LIST,
>, <Line: -				argument);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Check whether a given loop bytecode contains an invariant, or not.
>, <Line: -	 * 
>, <Line: -	 * @param branch
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private int getInvariantOffset(Bytecode.Loop loop, BytecodeForest forest) {
>, <Line: -		BytecodeForest.Block block = forest.get(loop.block());
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			if (block.get(i).first() instanceof Bytecode.Invariant) {
>, <Line: -				return i;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return -1;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Send a given set of variables to havoc. This means that any knowledge of
>, <Line: -	 * the current variables' state is discarded. In the context of a loop, this
>, <Line: -	 * is necessary to account for the fact that variables modified in the loop
>, <Line: -	 * have a range of unknown values.
>, <Line: -	 * 
>, <Line: -	 * @param variables
>, <Line: -	 *            The set of variables to be sent to havoc.
>, <Line: -	 * @param branch
>, <Line: -	 *            The branch in which to havoc the variables.
>, <Line: -	 */
>, <Line: -	public void havocVariables(int[] variables, VcBranch branch) {
>, <Line: -		for (int i = 0; i != variables.length; ++i) {
>, <Line: -			int var = variables[i];
>, <Line: -			Expr e = branch.read(var);
>, <Line: -			if (e != null) {
>, <Line: -				// FIXME: We only havoc variables that have already been
>, <Line: -				// defined. This is possibly a workaround for a bug, where the
>, <Line: -				// loop modified variables can contain variables local to the
>, <Line: -				// loop.
>, <Line: -				branch.havoc(var);
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a conditional bytecode. This is done by
>, <Line: -	 * splitting the entry branch into the case for the true branch and the case
>, <Line: -	 * for the false branch. Control then continues down each branch.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * On the true branch, the condition is assumed to hold. In contrast, the
>, <Line: -	 * condition's inverse is assumed to hold on the false branch.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> transform(Bytecode.If code, VcBranch branch,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		// First, clone and register the true branch
>, <Line: -		VcBranch trueBranch = branch.fork();
>, <Line: -		VcBranch falseBranch = branch.fork();
>, <Line: -		// Second assume the condition on each branch
>, <Line: -		Expr.Binary trueTest = buildCondition(branch.read(code.operand(0)),forest,branch);
>, <Line: -		trueBranch.assume(trueTest);
>, <Line: -		falseBranch.assume(utils.invert(trueTest));
>, <Line: -		// Third, dispatch branches to their targets
>, <Line: -		falseBranch.goTo(branch.pc().next());
>, <Line: -		trueBranch.goTo(labels.get(code.destination()));
>, <Line: -		// Finally, return the branches
>, <Line: -		ArrayList<VcBranch> exitBranches = new ArrayList<VcBranch>();
>, <Line: -		exitBranches.add(trueBranch);
>, <Line: -		exitBranches.add(falseBranch);
>, <Line: -		return exitBranches;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a conditional bytecode. This is done by
>, <Line: -	 * splitting the entry branch into the case for the true branch and the case
>, <Line: -	 * for the false branch. Control then continues down each branch.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * On the true branch, the condition is assumed to hold. In contrast, the
>, <Line: -	 * condition's inverse is assumed to hold on the false branch.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> transform(Bytecode.IfIs code, VcBranch branch,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		ArrayList<VcBranch> exitBranches = new ArrayList<VcBranch>();
>, <Line: -		// In this case, both branches are reachable.
>, <Line: -		// First, clone and register the branch
>, <Line: -		VcBranch falseBranch = branch.fork();
>, <Line: -		VcBranch trueBranch = branch.fork();
>, <Line: -		// Second add appropriate runtime type tests
>, <Line: -		List<wyil.lang.Attribute> attributes = forest.get(branch.pc()).attributes();
>, <Line: -		Collection<wycc.lang.Attribute> wycsAttributes = VcUtils.toWycsAttributes(attributes); 
>, <Line: -		SyntacticType trueType = utils.convert(code.rightOperand(), attributes);
>, <Line: -		SyntacticType falseType = new SyntacticType.Negation(utils.convert(code.rightOperand(),
>, <Line: -				attributes), wycsAttributes);
>, <Line: -		trueBranch.assume(new Expr.Is(branch.read(code.operand(0)), trueType,
>, <Line: -				wycsAttributes));
>, <Line: -		falseBranch.assume(new Expr.Is(branch.read(code.operand(0)), falseType,
>, <Line: -				wycsAttributes));
>, <Line: -		// Finally dispatch the branches
>, <Line: -		falseBranch.goTo(branch.pc().next());
>, <Line: -		trueBranch.goTo(labels.get(code.destination()));
>, <Line: -		//
>, <Line: -		exitBranches.add(trueBranch);
>, <Line: -		exitBranches.add(falseBranch);
>, <Line: -		// done
>, <Line: -		return exitBranches;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a switch bytecode. This is done by splitting
>, <Line: -	 * the entry branch into separate branches for each case. The entry branch
>, <Line: -	 * then follows the default branch.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected List<VcBranch> transform(Bytecode.Switch code, VcBranch branch,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		ArrayList<VcBranch> exitBranches = new ArrayList<VcBranch>();
>, <Line: -		VcBranch defaultBranch = branch.fork();
>, <Line: -		// Process each case individually, whilst also updating the default
>, <Line: -		// branch.
>, <Line: -		for (int i = 0; i != code.branches().size(); ++i) {
>, <Line: -			// First, for each case fork a new branch to traverse it.
>, <Line: -			VcBranch caseBranch = branch.fork();
>, <Line: -			// Second, for each case, assume that the variable switched on
>, <Line: -			// matches the give case value. Likewise, assume that the default
>, <Line: -			// branch does *not* equal this value.
>, <Line: -			Constant caseValue = code.branches().get(i).first();
>, <Line: -			// Second, on the new branch we need assume that the variable being
>, <Line: -			// switched on matches the given value.
>, <Line: -			Expr src = branch.read(code.operand(0));
>, <Line: -			Expr constant = new Expr.Constant(utils.convert(caseValue, forest, branch),
>, <Line: -					VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes()));
>, <Line: -			caseBranch.assume(new Expr.Binary(Expr.Binary.Op.EQ, src, constant,
>, <Line: -					VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes())));
>, <Line: -			// Third, on the default branch we can assume that the variable
>, <Line: -			// being switched is *not* the given value.
>, <Line: -			defaultBranch.assume(new Expr.Binary(Expr.Binary.Op.NEQ, src,
>, <Line: -					constant, VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes())));
>, <Line: -			// Finally, dispatch branch
>, <Line: -			caseBranch.goTo(labels.get(code.branches().get(i).second()));
>, <Line: -			exitBranches.add(caseBranch);
>, <Line: -		}
>, <Line: -		// Finally, the dispatch the default branch to the default target.
>, <Line: -		defaultBranch.goTo(labels.get(code.defaultTarget()));
>, <Line: -		exitBranches.add(defaultBranch);
>, <Line: -		// TODO: here is where we can add a coverage check. Specifically, that
>, <Line: -		// all cases of the input variable have been covered or not. This would
>, <Line: -		// be in the case that there is no explicit default branch target.
>, <Line: -		return exitBranches;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform an assert, assume or invariant bytecode. This is done by
>, <Line: -	 * transforming the contained bytecode block and processing the resulting
>, <Line: -	 * branches depending on whether or not this is an assert or assume
>, <Line: -	 * bytecode. In the former case, all failing branches give rise to
>, <Line: -	 * corresponding verification conditions. In the latter case, all failing
>, <Line: -	 * branches are simply ignored as we're assuming they don't happen.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param environment
>, <Line: -	 *            The mapping of registers to their declared types.
>, <Line: -	 * @param labels
>, <Line: -	 *            The map from labels to their block locations
>, <Line: -	 * @param block
>, <Line: -	 *            The block being transformed over.
>, <Line: -	 * @return A pair consisting of: the active branch (if any) which has fallen
>, <Line: -	 *         through the end of the block and is now located at the
>, <Line: -	 *         instruction following the parent; and, the list of zero or more
>, <Line: -	 *         branches which have terminated or failed.
>, <Line: -	 */
>, <Line: -	protected Pair<VcBranch, List<VcBranch>> transform(
>, <Line: -			Bytecode.AssertOrAssume code, boolean isAssert, VcBranch branch,
>, <Line: -			Type[] environment, Map<String, BytecodeForest.Index> labels,
>, <Line: -			BytecodeForest forest) {
>, <Line: -		int start = wyalFile.declarations().size();
>, <Line: -		// First, transform the given branch through the assert or assume block.
>, <Line: -		// This will produce one or more exit branches, some of which may have
>, <Line: -		// reached failed states and need to be turned into verification
>, <Line: -		// conditions (for asserts only).
>, <Line: -		BytecodeForest.Index pc = branch.pc();
>, <Line: -		Pair<VcBranch, List<VcBranch>> p = transform(code.block(), 0, pc, branch, false, true, environment, labels,
>, <Line: -				forest);
>, <Line: -		List<VcBranch> exitBranches = p.second();
>, <Line: -		// Second, examine the list of exit branches and decide what to do with
>, <Line: -		// them. In the case of a failing branch then we need to generate an
>, <Line: -		// appropriate verification condition.
>, <Line: -		for (int i = 0; i != exitBranches.size(); ++i) {
>, <Line: -			VcBranch b = exitBranches.get(i);
>, <Line: -			if (b.state() == VcBranch.State.FAILED && !isAssert) {
>, <Line: -				// In the case of an assume state, we just ignore all
>, <Line: -				// failing branches as we are simply "assuming" they don't
>, <Line: -				// happen. Therefore, we silently remove them from the list of
>, <Line: -				// exit branches.
>, <Line: -				exitBranches.remove(i--);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// Third, in the case of an assumption, we need to remove any
>, <Line: -		// verification conditions that were generated when processing this
>, <Line: -		// block.
>, <Line: -		if(!isAssert) {
>, <Line: -			// FIXME: this is something of a hack for now. A better solution would
>, <Line: -			// be to pass a variable recursively down through the call stack which
>, <Line: -			// signaled that no verification conditions should be generated.
>, <Line: -			while(wyalFile.declarations().size() > start) {
>, <Line: -				wyalFile.declarations().remove(wyalFile.declarations().size()-1);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// Done
>, <Line: -		return p;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through an unconditional branching bytecode. This is
>, <Line: -	 * pretty straightforward, and the branch is just directed to the given
>, <Line: -	 * location.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected void transform(Bytecode.Goto code, final VcBranch branch,
>, <Line: -			Map<String, BytecodeForest.Index> labels, BytecodeForest forest) {
>, <Line: -		branch.goTo(labels.get(code.destination()));
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through the special fail bytecode. In the normal case,
>, <Line: -	 * we must establish this branch is unreachable. However, in the case that
>, <Line: -	 * we are within an enclosing assume statement, then we can simply discard
>, <Line: -	 * this branch.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branchIndex
>, <Line: -	 *            The index of the branch (in branches) which holds on entry to
>, <Line: -	 *            the bytecode.
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected void transform(Bytecode.Fail code, VcBranch branch,
>, <Line: -			BytecodeForest forest) {
>, <Line: -		// Update status of this branch to failed. This simply indicates that
>, <Line: -		// this branch's location should be unreachable and, hence, we need a
>, <Line: -		// verification condition to enforce this.
>, <Line: -		branch.setState(VcBranch.State.FAILED);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Transform a branch through a return bytecode. In this case, we need to
>, <Line: -	 * ensure that the postcondition holds. After that, we can drop the branch
>, <Line: -	 * since it is completed.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param code
>, <Line: -	 *            The bytecode being transformed.
>, <Line: -	 * @param branch
>, <Line: -	 *            The current branch being transformed
>, <Line: -	 * @param branches
>, <Line: -	 *            The list of branches currently being managed.
>, <Line: -	 */
>, <Line: -	protected void transform(Bytecode.Return code, VcBranch branch) {
>, <Line: -		// Marking the branch as terminated indicates that it is no longer
>, <Line: -		// active. Thus, the original callers of this block transformation can
>, <Line: -		// subsequently extract the constraints which hold at the point of the
>, <Line: -		// return.
>, <Line: -		branch.setState(VcBranch.State.TERMINATED);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Construct a macro with a given name representing a block of code. The
>, <Line: -	 * macro can then be called elsewhere as a predicate. For example, a macro
>, <Line: -	 * can be construct to represent the precondition of a function. This can
>, <Line: -	 * then be assumed at the start of the function's block. Or, it can ensured
>, <Line: -	 * at the point of an invocation.
>, <Line: -	 *
>, <Line: -	 * @param name
>, <Line: -	 *            --- the nameto give to the generated macro.
>, <Line: -	 * @param block
>, <Line: -	 *            --- the block of code being translated.
>, <Line: -	 * @param types
>, <Line: -	 *            --- operand register in containing branch which should map to
>, <Line: -	 *            the inputs of the block being translated.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected void buildMacroBlock(String name, BytecodeForest.Index root,
>, <Line: -			BytecodeForest forest, List<Type> types, boolean isInvariant) {
>, <Line: -		int start = wyalFile.declarations().size();
>, <Line: -		// first, generate a branch for traversing the external block.
>, <Line: -		VcBranch master = new VcBranch(Math.max(forest.numRegisters(), types.size()), root, null);
>, <Line: -		Type[] environment = new Type[types.size()];
>, <Line: -		ArrayList<TypePattern.Leaf> declarations = new ArrayList<TypePattern.Leaf>();
>, <Line: -		// second, set initial environment
>, <Line: -		for (int i = 0; i != types.size(); ++i) {
>, <Line: -			Type type = types.get(i);
>, <Line: -			environment[i] = type;
>, <Line: -			if (type != null) {
>, <Line: -				Expr.Variable v = new Expr.Variable("r" + i);
>, <Line: -				master.write(i, v);
>, <Line: -				// FIXME: what attributes to pass into convert?
>, <Line: -				declarations.add(new TypePattern.Leaf(utils.convert(type,
>, <Line: -						Collections.EMPTY_LIST), v));
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// Construct the type declaration for the new block macro
>, <Line: -		TypePattern type;
>, <Line: -		if (declarations.size() == 1) {
>, <Line: -			type = declarations.get(0);
>, <Line: -		} else {
>, <Line: -			type = new TypePattern.Tuple(
>, <Line: -					declarations.toArray(new TypePattern.Leaf[declarations
>, <Line: -							.size()]));
>, <Line: -		}
>, <Line: -		// At this point, we are guaranteed exactly one branch because there
>, <Line: -		// is only ever one exit point from a pre-/post-condition.
>, <Line: -		List<VcBranch> exitBranches = transform(master, root, isInvariant, environment, forest);
>, <Line: -		// Remove any verification conditions that were generated when
>, <Line: -		// processing this block.  		
>, <Line: -		// FIXME: this is something of a hack for now. A better solution would
>, <Line: -		// be for the verification conditions to be returned so that they
>, <Line: -		// can be discussed.
>, <Line: -		while(wyalFile.declarations().size() > start) {
>, <Line: -			wyalFile.declarations().remove(wyalFile.declarations().size()-1);
>, <Line: -		}
>, <Line: -		//
>, <Line: -		for (VcBranch exitBranch : exitBranches) {
>, <Line: -			if (exitBranch.state() == VcBranch.State.TERMINATED) {
>, <Line: -				Expr body = generateAssumptions(exitBranch, null);
>, <Line: -				wyalFile.add(wyalFile.new Macro(name, Collections.EMPTY_LIST,
>, <Line: -						type, body));
>, <Line: -				return;
>, <Line: -			}
>, <Line: -		}		
>, <Line: -		// It should be impossible to reach here.
>, <Line: -		internalFailure("unreachable code", filename);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Construct a verification condition which asserts a given expression on
>, <Line: -	 * the current branch. Thus, all relevant assumptions are taken from the
>, <Line: -	 * current branch (and its ancestors) to form the verification condition.
>, <Line: -	 * This function must additional type each variable used within the
>, <Line: -	 * verification condition.
>, <Line: -	 * 
>, <Line: -	 * @param assertion
>, <Line: -	 *            --- The assertion which is to be ensured by the verification
>, <Line: -	 *            condition, assuming the assumptions held.
>, <Line: -	 * @param branch
>, <Line: -	 *            --- The branch from which the verification condition is being
>, <Line: -	 *            generated.
>, <Line: -	 * @param block
>, <Line: -	 *            --- The enclosing attributed block for this assertion.
>, <Line: -	 * @param assumptions
>, <Line: -	 *            --- Additional assumptions to take into consideration.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected Expr buildVerificationCondition(Expr assertion, VcBranch branch,
>, <Line: -			Type[] environment, BytecodeForest forest, Expr... extraAssumptions) {
>, <Line: -		// First construct the assertion which forms the basis of the
>, <Line: -		// verification condition. The assertion must be shown to hold assuming
>, <Line: -		// the assumptions did. Therefore, we construct an implication to
>, <Line: -		// establish this.
>, <Line: -		Expr assumptions = generateAssumptions(branch, null);
>, <Line: -		for(Expr ea : extraAssumptions) {
>, <Line: -			assumptions = new Expr.Binary(Expr.Binary.Op.AND, assumptions, ea);
>, <Line: -		}
>, <Line: -		assertion = new Expr.Binary(Expr.Binary.Op.IMPLIES, assumptions,
>, <Line: -				assertion, VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes()));
>, <Line: -		// Next, we determine the set of used variables within the assertion.
>, <Line: -		// This is done to minimise the number of variables present in the final
>, <Line: -		// verification condition as otherwise this can, potentially, make life
>, <Line: -		// harder for the verifier.
>, <Line: -		HashSet<String> uses = new HashSet<String>();
>, <Line: -		assertion.freeVariables(uses);
>, <Line: -		// Now, we determine the correct type for all used variables.
>, <Line: -		// FIXME: this does not actually always find the correct type of a
>, <Line: -		// variable. That's because it always uses the current type of a
>, <Line: -		// variable, rather than the type which held at a given position. This
>, <Line: -		// should be resolved by removing type tracking altogether and replacing
>, <Line: -		// it with the use of type tests (see #316).
>, <Line: -		ArrayList<TypePattern> vars = new ArrayList<TypePattern>();
>, <Line: -		for (String var : uses) {
>, <Line: -			Type type;
>, <Line: -			if (var.startsWith("_")) {
>, <Line: -				// FIXME: this is a hack to handle the fact that forall index
>, <Line: -				// variables are not explicit. However, we know that they are
>, <Line: -				// always integers.
>, <Line: -				type = Type.T_INT;
>, <Line: -			} else if (var.startsWith("null$")) {
>, <Line: -				// FIXME: this is also something of a hack to deal with
>, <Line: -				// expressions which currently have no sensible translation into
>, <Line: -				// WyAL.
>, <Line: -				type = Type.T_ANY;
>, <Line: -			} else {
>, <Line: -				int reg = VcUtils.determineRegister(var, branch.prefixes());
>, <Line: -				type = environment[reg];
>, <Line: -			}
>, <Line: -			SyntacticType t = utils.convert(type, forest.get(branch.pc()).attributes());
>, <Line: -			Expr.Variable v = new Expr.Variable(var);
>, <Line: -			vars.add(new TypePattern.Leaf(t, v));
>, <Line: -		}
>, <Line: -		// Finally, we construct the verification condition. This is done by
>, <Line: -		// universally quantifying each variable used in the assertion with its
>, <Line: -		// corresponding type.
>, <Line: -		if (vars.size() == 0) {
>, <Line: -			// we have nothing to parameterise, so ignore it and just return the
>, <Line: -			// assertion without any quantification.
>, <Line: -			return assertion;
>, <Line: -		} else if (vars.size() == 1) {
>, <Line: -			return new Expr.ForAll(vars.get(0), assertion);
>, <Line: -		} else {
>, <Line: -			return new Expr.ForAll(new TypePattern.Tuple(vars), assertion);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Generate all constraints from a given branch. Those are the set of
>, <Line: -	 * complete constraints which are known to hold in this branch and any of
>, <Line: -	 * its ancestors. To do this, we need to traverse the branch graph and then
>, <Line: -	 * recombine everything in the correct order. For example, consider this
>, <Line: -	 * graph:
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * <pre>
>, <Line: -	 *      #1: y>=0
>, <Line: -	 *    //  \\
>, <Line: -	 *   //    \\
>, <Line: -	 *  //      \\
>, <Line: -	 * ||        ||   
>, <Line: -	 * #2: x>=y  #3: x<y
>, <Line: -	 * ||        ||
>, <Line: -	 * ||        #4: z = 0
>, <Line: -	 *  \\      //
>, <Line: -	 *   \\    //
>, <Line: -	 *    \\  //
>, <Line: -	 *      #5:
>, <Line: -	 * </pre>
>, <Line: -	 * <p>
>, <Line: -	 * Here, the assumptions are being generated from branch #5. To do this, we
>, <Line: -	 * traverse backwards from #5. Constraints from the left-branch are
>, <Line: -	 * disjuncted with those from the right branch, whilst those common to both
>, <Line: -	 * are conjuncted with all. Thus, the resulting expressions would be:
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * <pre>
>, <Line: -	 * y &gt;= 0 &amp;&amp; (x &gt;= y || (x &lt; y || z == 0))
>, <Line: -	 * </pre>
>, <Line: -	 */
>, <Line: -	private Expr generateAssumptions(VcBranch b, VcBranch end) {
>, <Line: -		// We need to clone the return expression here to ensure there is no
>, <Line: -		// aliasing between generated verification conditions as this can lead
>, <Line: -		// to problems later on.
>, <Line: -		return generateAssumptionsHelper(b,end).copy();
>, <Line: -	}
>, <Line: -	private Expr generateAssumptionsHelper(VcBranch b, VcBranch end) {
>, <Line: -		if (b == end) {
>, <Line: -			// The termination condition is reached.
>, <Line: -			return new Expr.Constant(Value.Bool(true));
>, <Line: -		} else {
>, <Line: -			// FIXME: this method is not efficient and does not generate an
>, <Line: -			// optimal decomposition of the branch graph.
>, <Line: -			// First, compute disjunction of parent constraints.
>, <Line: -			VcBranch[] b_parents = b.parents();
>, <Line: -			Expr parents = null;
>, <Line: -			for (int i = 0; i != b_parents.length; ++i) {
>, <Line: -				VcBranch parent = b_parents[i];
>, <Line: -				Expr parent_constraints = generateAssumptionsHelper(parent, end);
>, <Line: -				if (i == 0) {
>, <Line: -					parents = parent_constraints;
>, <Line: -				} else if(parent_constraints instanceof Expr.Constant) {
>, <Line: -					Expr.Constant c = (Expr.Constant) parent_constraints;
>, <Line: -					Value.Bool v = (Value.Bool) c.value;					
>, <Line: -					if(v.value) {
>, <Line: -						// can short-circuit this
>, <Line: -						parents = c;
>, <Line: -						break;
>, <Line: -					} else {
>, <Line: -						// ignore false						
>, <Line: -					}
>, <Line: -				} else {
>, <Line: -					parents = new Expr.Binary(Expr.Binary.Op.OR, parents,
>, <Line: -							parent_constraints);
>, <Line: -				}
>, <Line: -			}
>, <Line: -			// Second, include constraints from this node.
>, <Line: -			Expr b_constraints = b.constraints();			
>, <Line: -			if (parents == null) {
>, <Line: -				return b.constraints();
>, <Line: -			} else if(parents instanceof Expr.Constant) {
>, <Line: -				Expr.Constant c = (Expr.Constant) parents;
>, <Line: -				Value.Bool v = (Value.Bool) c.value;					
>, <Line: -				if(v.value) {
>, <Line: -					return b_constraints;
>, <Line: -				} else {
>, <Line: -					return c;
>, <Line: -				}
>, <Line: -			} else {
>, <Line: -				return new Expr.Binary(Expr.Binary.Op.AND, parents,
>, <Line: -						b_constraints);
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Generate a formula representing a condition from an conditional bytecode.
>, <Line: -	 *
>, <Line: -	 * @param op
>, <Line: -	 * @param stack
>, <Line: -	 * @param elem
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private Expr.Binary buildCondition(Expr test, BytecodeForest forest, VcBranch branch) {
>, <Line: -		if (test instanceof Expr.Binary) {
>, <Line: -			return (Expr.Binary) test;
>, <Line: -		} else {
>, <Line: -			Collection<Attribute> attributes = VcUtils.toWycsAttributes(forest.get(branch.pc()).attributes());
>, <Line: -			Expr.Constant tt = new Expr.Constant(Value.Bool(true), attributes);  
>, <Line: -			return new Expr.Binary(Expr.Binary.Op.EQ, test, tt, attributes);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	private Type expand(Type t, Collection<wyil.lang.Attribute> attributes) {
>, <Line: -		try {
>, <Line: -			return expander.getUnderlyingType(t);
>, <Line: -		} catch (ResolveError re) {
>, <Line: -			internalFailure(re.getMessage(), filename, attributes);
>, <Line: -		} catch (IOException re) {
>, <Line: -			internalFailure(re.getMessage(), filename, attributes);
>, <Line: -		}
>, <Line: -		return null; // dead-code
>, <Line: -	}
>, <Line: -	private static <T> List<T> append(List<T> xs, List<T> ys) {
>, <Line: -		ArrayList<T> rs = new ArrayList<T>();
>, <Line: -		rs.addAll(xs);
>, <Line: -		rs.addAll(ys);		
>, <Line: -		return rs;
>, <Line: -	}
>, <Line: -}
>]