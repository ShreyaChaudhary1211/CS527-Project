[<Line: +import wycc.lang.Attribute;
>, <Line: +import wycc.lang.SyntacticElement;
>, <Line: +import wyil.lang.Bytecode.Extras;
>, <Line: +import wyil.lang.Bytecode.Operands;
>, <Line: +import wyil.lang.Bytecode.Schema;
>, <Line: +import wyil.util.AbstractBytecode;
>, <Line: + * <i>operand registers</i>, <i>operand groups</i>, <i>blocks</code> and
>, <Line: + * <i>other items</i> used (e.g. names, constants, etc). The generic
>, <Line: + * organisation of a bytecode is as follows:
>, <Line: + * +--------+----------+----------------+--------+-------------+
>, <Line: + * | opcode | operands | operand groups | blocks | other items |
>, <Line: + * +--------+----------+----------------+--------+-------------+
>, <Line: + * etc), whilst <i>fmt</i> identifies the bytecode format.
>, <Line: +public interface Bytecode {
>, <Line: +	/**
>, <Line: +	 * Return the top-level operands in this bytecode.
>, <Line: +	 *
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public int[] getOperands();
>, <Line: +	 * Get the number of operands in this bytecode
>, <Line: +	public int numberOfOperands();
>, <Line: +	 * Return the ith top-level operand in this bytecode.
>, <Line: +	 * @param i
>, <Line: +	public int getOperand(int i);
>, <Line: +	 * Get the number of operand groups in this bytecode
>, <Line: +	public int numberOfOperandGroups();
>, <Line: +	 * Get the ith operand group in this bytecode
>, <Line: +	 * 
>, <Line: +	public int[] getOperandGroup(int i);
>, <Line: +	 * 
>, <Line: +	public int getOpcode();
>, <Line: +	// ===============================================================
>, <Line: +	// Bytecode Expressions
>, <Line: +	// ===============================================================
>, <Line: +	 * Represents the class of bytecodes which correspond to expressions in the
>, <Line: +	 * source language.
>, <Line: +	public interface Expr extends Bytecode {
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * A convert bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+---------+
>, <Line: +	 * | opcode | operand |
>, <Line: +	 * +--------+---------+
>, <Line: +	 * </pre>
>, <Line: +	 *
>, <Line: +	 * <p>
>, <Line: +	 * This corresponds to an explicit or implicit cast in the source language.
>, <Line: +	 * This bytecode is the only way to change the type of a value. It's purpose
>, <Line: +	 * is to simplify implementations which have different representations of
>, <Line: +	 * data types. A convert bytecode must be inserted whenever the type of a
>, <Line: +	 * value changes. For example, when a variable is retyped using the
>, <Line: +	 * <code>is</code> operator, we must convert its value into a value of the
>, <Line: +	 * new type.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * <b>NOTE:</b> In many cases, this bytecode may correspond to a nop on the
>, <Line: +	 * hardware. Consider converting from <code>any[]</code> to <code>any</code>
>, <Line: +	 * . On the JVM, <code>any</code> translates to <code>Object</code>, whilst
>, <Line: +	 * <code>any[]</code> translates to <code>List</code> (which is an instance
>, <Line: +	 * of <code>Object</code>). Thus, no conversion is necessary since
>, <Line: +	 * <code>List</code> can safely flow into <code>Object</code>.
>, <Line: +	 * </p>
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static final class Convert extends AbstractBytecode implements Expr {
>, <Line: +		public Convert(int operand) {
>, <Line: +			super(operand);
>, <Line: +		public int operand() {
>, <Line: +			return getOperand(0);
>, <Line: +		}
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_convert;
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "castt " + Util.arrayToString(getOperands());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * A constant bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+----------+
>, <Line: +	 * | opcode | constant |
>, <Line: +	 * +--------+----------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * Here, constant represents a value, such as an <i>integer</i>,
>, <Line: +	 * <i>array</i>, etc.
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static final class Const extends AbstractBytecode implements Expr {
>, <Line: +		private final Constant constant;
>, <Line: +		public Const(Constant constant) {
>, <Line: +			this.constant = constant;
>, <Line: +		}
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_const;
>, <Line: +		}
>, <Line: +		public Constant constant() {
>, <Line: +			return constant;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +			return constant.hashCode();
>, <Line: +		@Override
>, <Line: +			if (o instanceof Const) {
>, <Line: +				Const c = (Const) o;
>, <Line: +				return constant.equals(c.constant);
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "const " + constant.toString();
>, <Line: +		}
>, <Line: +	 * <p>
>, <Line: +	 * A field load bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+---------+-----------+
>, <Line: +	 * | opcode | operand | fieldName |
>, <Line: +	 * +--------+---------+-----------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * The bytecode reads the field of the given name out of the record value
>, <Line: +	 * returned by the operand
>, <Line: +	 * </p>
>, <Line: +	public static final class FieldLoad extends AbstractBytecode implements Expr {
>, <Line: +		private final String field;
>, <Line: +		public FieldLoad(int operand, String field) {
>, <Line: +			super(operand);
>, <Line: +			if (field == null) {
>, <Line: +				throw new IllegalArgumentException("FieldLoad field argument cannot be null");
>, <Line: +			}
>, <Line: +			this.field = field;
>, <Line: +		}
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_fieldload;
>, <Line: +		public int operand() {
>, <Line: +			return getOperand(0);
>, <Line: +		public String fieldName() {
>, <Line: +			return field;
>, <Line: +		@Override
>, <Line: +			if (o instanceof FieldLoad) {
>, <Line: +				FieldLoad i = (FieldLoad) o;
>, <Line: +				return super.equals(i) && field.equals(i.field);
>, <Line: +		@Override
>, <Line: +		public int hashCode() {
>, <Line: +			return super.hashCode() + field.hashCode();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "recfield %" + getOperand(0) + " " + field;
>, <Line: +		}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * A lambda bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+------+-------------+---------------+
>, <Line: +	 * | opcode | body | parameter[] | environment[] |
>, <Line: +	 * +--------+------+-------------+---------------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, the body operand identifies an expression which constitutes the
>, <Line: +	 * body of this lambda. The parameters are those variables which are
>, <Line: +	 * declared by the lambda itself for use within the lambda body. The
>, <Line: +	 * environment identifies those variables from the surrounding environment.
>, <Line: +	 * </p>
>, <Line: +	 */
>, <Line: +	public static final class Lambda extends AbstractBytecode implements Expr {
>, <Line: +		private final Type.FunctionOrMethod type;
>, <Line: +		/**
>, <Line: +		 * Create a new lambda bytecode
>, <Line: +		 * 
>, <Line: +		 * @param type
>, <Line: +		 *            The type of the resulting lambda.
>, <Line: +		 * @param body
>, <Line: +		 *            The expression corresponding to the body of the lambda
>, <Line: +		 *            expression.
>, <Line: +		 * @param parameters
>, <Line: +		 *            The set of declared variables using within the lambda
>, <Line: +		 *            expression.
>, <Line: +		 * @param environment
>, <Line: +		 *            The set of variables from the enclosing scope which are
>, <Line: +		 *            used within the lambda body.
>, <Line: +		 */
>, <Line: +		public Lambda(Type.FunctionOrMethod type, int body, int[] parameters, int[] environment) {
>, <Line: +			super(body, new int[][]{parameters, environment});
>, <Line: +			this.type = type;
>, <Line: +		}
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_lambda;
>, <Line: +		}
>, <Line: +		public Type.FunctionOrMethod type() {
>, <Line: +			return type;
>, <Line: +		}
>, <Line: +		public int body() {
>, <Line: +			return getOperand(0);
>, <Line: +		};
>, <Line: +		public int[] parameters() {
>, <Line: +			return getOperandGroup(0);
>, <Line: +		}
>, <Line: +		public int[] environment() {
>, <Line: +			return getOperandGroup(1);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean equals(Object o) {
>, <Line: +			if (o instanceof Lambda) {
>, <Line: +				Lambda i = (Lambda) o;
>, <Line: +				return type.equals(i.type) && super.equals(i);
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public int hashCode() {
>, <Line: +			return type.hashCode() + super.hashCode();
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "lambda " + Util.arrayToString(getOperands()) + " " + type;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	 * Represents the set of valid operators (e.g. '+','-',etc).
>, <Line: +		NEG(OPCODE_neg) {
>, <Line: +		NOT(OPCODE_logicalnot) {
>, <Line: +		BITWISEINVERT(OPCODE_bitwiseinvert) {
>, <Line: +		DEREFERENCE(OPCODE_dereference) {
>, <Line: +		ARRAYLENGTH(OPCODE_arraylength) {
>, <Line: +				return "arrlen";
>, <Line: +		ADD(OPCODE_add) {
>, <Line: +		SUB(OPCODE_sub) {
>, <Line: +		MUL(OPCODE_mul) {
>, <Line: +		DIV(OPCODE_div) {
>, <Line: +		REM(OPCODE_rem) {
>, <Line: +		EQ(OPCODE_eq) {
>, <Line: +		NEQ(OPCODE_ne) {
>, <Line: +				return "neq";
>, <Line: +		LT(OPCODE_lt) {
>, <Line: +		LTEQ(OPCODE_le) {
>, <Line: +				return "lteq";
>, <Line: +		GT(OPCODE_gt) {
>, <Line: +		GTEQ(OPCODE_ge) {
>, <Line: +				return "gteq";
>, <Line: +		AND(OPCODE_logicaland) {
>, <Line: +				return "land";
>, <Line: +		OR(OPCODE_logicalor) {
>, <Line: +				return "lor";
>, <Line: +		BITWISEOR(OPCODE_bitwiseor) {
>, <Line: +				return "bor";
>, <Line: +		BITWISEXOR(OPCODE_bitwisexor) {
>, <Line: +				return "bxor";
>, <Line: +		BITWISEAND(OPCODE_bitwiseand) {
>, <Line: +				return "band";
>, <Line: +		LEFTSHIFT(OPCODE_shl) {
>, <Line: +				return "bshl";
>, <Line: +		RIGHTSHIFT(OPCODE_shr) {
>, <Line: +				return "bshr";
>, <Line: +		ARRAYINDEX(OPCODE_arrayindex) {
>, <Line: +				return "arridx";
>, <Line: +		ARRAYGENERATOR(OPCODE_arraygen) {
>, <Line: +				return "arrgen";
>, <Line: +		ARRAYCONSTRUCTOR(OPCODE_array) {
>, <Line: +				return "arrinit";
>, <Line: +			}
>, <Line: +		},
>, <Line: +		RECORDCONSTRUCTOR(OPCODE_record) {
>, <Line: +			public String toString() {
>, <Line: +				return "recinit";
>, <Line: +			}
>, <Line: +		},
>, <Line: +		IS(OPCODE_is) {
>, <Line: +			public String toString() {
>, <Line: +				return "istype";
>, <Line: +		NEW(OPCODE_newobject) {
>, <Line: +				return "new";
>, <Line: +		public int opcode;
>, <Line: +			this.opcode = offset;
>, <Line: +	 * An operator bytecode has the following layout:
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * | opcode | operand[] |
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the operand array identifies one or more operands in which this
>, <Line: +	 * operator operators.  The operator produces exactly one value.
>, <Line: +	 * </p>
>, <Line: +	public static final class Operator extends AbstractBytecode implements Expr {
>, <Line: +		public Operator(int[] operands, OperatorKind bop) {
>, <Line: +			super(operands);
>, <Line: +		public int getOpcode() {
>, <Line: +			return kind().opcode;
>, <Line: +		public OperatorKind kind() {
>, <Line: +			return kind;
>, <Line: +			return kind() + " " + Util.arrayToString(getOperands());
>, <Line: +	}
>, <Line: +	public enum QuantifierKind {
>, <Line: +		SOME(OPCODE_some), ALL(OPCODE_all);
>, <Line: +		public int opcode;
>, <Line: +		private QuantifierKind(int offset) {
>, <Line: +			this.opcode = offset;
>, <Line: +	 * <p>
>, <Line: +	 * A quantifier bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+-----------+---------+-----+---------+
>, <Line: +	 * | opcode | condition | range[] | ... | range[] |
>, <Line: +	 * +--------+-----------+---------+-----+---------+
>, <Line: +	 * Here, the condition operand identifies an expression which the quantifier
>, <Line: +	 * is asserting over the given ranges. The ranges themselves identifier one
>, <Line: +	 * or more operand groups, each of which holds three entries: the declared
>, <Line: +	 * variable, the start operand, the end operand.
>, <Line: +	public static final class Quantifier extends AbstractBytecode implements Expr {
>, <Line: +		private final QuantifierKind kind;
>, <Line: +		public Quantifier(QuantifierKind kind, int operand, Range... ranges) {
>, <Line: +			super(operand, extract(ranges));
>, <Line: +			this.kind = kind;
>, <Line: +		public QuantifierKind kind() {
>, <Line: +			return kind;
>, <Line: +		public int getOpcode() {
>, <Line: +			return kind.opcode;
>, <Line: +		public int body() {
>, <Line: +			return getOperand(0);
>, <Line: +		public Range[] ranges() {
>, <Line: +			Bytecode.Range[] ranges = new Bytecode.Range[numberOfOperandGroups()];
>, <Line: +			for (int i = 0; i != ranges.length; i = i + 1) {
>, <Line: +				int[] group = getOperandGroup(i);
>, <Line: +				ranges[i] = new Bytecode.Range(group[0], group[1], group[2]);
>, <Line: +			}
>, <Line: +			return ranges;
>, <Line: +		private static int[][] extract(Range[] ranges) {
>, <Line: +			int[][] groups = new int[ranges.length][3];
>, <Line: +			for (int i = 0; i != ranges.length; ++i) {
>, <Line: +				Range r = ranges[i];
>, <Line: +				groups[i][0] = r.variable;
>, <Line: +				groups[i][1] = r.startOperand;
>, <Line: +				groups[i][2] = r.endOperand;
>, <Line: +			}
>, <Line: +			return groups;
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "quantifier";
>, <Line: +	}
>, <Line: +	public static final class Range {
>, <Line: +		private final int variable;
>, <Line: +		private final int startOperand;
>, <Line: +		private final int endOperand;
>, <Line: +		public Range(int variable, int startOperand, int endOperand) {
>, <Line: +			this.variable = variable;
>, <Line: +			this.startOperand = startOperand;
>, <Line: +			this.endOperand = endOperand;
>, <Line: +		/**
>, <Line: +		 * Return the location index for the variable this range is declaring.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int variable() {
>, <Line: +			return variable;
>, <Line: +		/**
>, <Line: +		 * Return the start operand of this range.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int startOperand() {
>, <Line: +			return startOperand;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Return the end operand of this range.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int endOperand() {
>, <Line: +			return endOperand;
>, <Line: +		}
>, <Line: +		public boolean equals(Object o) {
>, <Line: +			if (o instanceof Range) {
>, <Line: +				Range r = (Range) o;
>, <Line: +				return variable == r.variable && startOperand == r.startOperand && r.endOperand == endOperand;
>, <Line: +		public int hashCode() {
>, <Line: +			return variable ^ startOperand ^ endOperand;
>, <Line: +	 * <p>
>, <Line: +	 * A variable access bytecode represents a specific read of a given variable.
>, <Line: +	 * </p>
>, <Line: +	 * +--------+---------+
>, <Line: +	 * | opcode | operand |
>, <Line: +	 * +--------+---------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the operand refers to the variable declaration corresponding to
>, <Line: +	 * this variable Access.
>, <Line: +	 * </p>
>, <Line: +	 */
>, <Line: +	public static final class VariableAccess extends AbstractBytecode implements Expr {
>, <Line: +		public VariableAccess(int operand) {
>, <Line: +			super(operand);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_varaccess;
>, <Line: +		}
>, <Line: +		public String toString() {
>, <Line: +			return "read " + Util.arrayToString(getOperands());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// ===============================================================
>, <Line: +	// Bytecode Statements
>, <Line: +	// ===============================================================
>, <Line: +	/**
>, <Line: +	 * A statement bytecode represents a bytecode that contains a sequence of
>, <Line: +	 * zero or more bytecodes. For example, a loop bytecode contains its loop
>, <Line: +	 * body. The nested blocks of bytecodes are represented as a block
>, <Line: +	 * identifier in the enclosing forest.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public interface Stmt extends Bytecode {
>, <Line: +		/**
>, <Line: +		 * Determine the number of blocks contained in this bytecode.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int numberOfBlocks();
>, <Line: +		/**
>, <Line: +		 * Get the ith block contained in this statement
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int getBlock(int i);
>, <Line: +		/**
>, <Line: +		 * Get the blocks contained in this statement
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int[] getBlocks();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * An alias declaration bytecode has the following form:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+---------+
>, <Line: +	 * | opcode | operand |
>, <Line: +	 * +--------+---------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the operand identifies the variable declaration being aliased
>, <Line: +	 * (which may be an alias declaration itself).
>, <Line: +	 * </p>
>, <Line: +	public static final class AliasDeclaration extends AbstractBytecode implements Stmt {
>, <Line: +		public AliasDeclaration(int initialiser) {
>, <Line: +			super(initialiser);
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {			
>, <Line: +			return OPCODE_aliasdecl;
>, <Line: +			return "alias (%" + getOperand(0) + ")";
>, <Line: +	 * <code>assume</code> bytecode.
>, <Line: +	public static abstract class AssertOrAssume extends AbstractBytecode implements Stmt {
>, <Line: +		private AssertOrAssume(int operand) {
>, <Line: +			super(operand);
>, <Line: +		}
>, <Line: +		public int operand() {
>, <Line: +			return getOperand(0);
>, <Line: +	 * <p>
>, <Line: +	 * An assert bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * | opcode | condition |
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, the condition identifies an operand which should always evaluate to
>, <Line: +	 * true. This condition should be enforced at compile time.
>, <Line: +	 * </p>
>, <Line: +		public Assert(int operand) {
>, <Line: +			super(operand);
>, <Line: +		public int getOpcode() {
>, <Line: +		@Override
>, <Line: +			return "assert %" + getOperand(0);
>, <Line: +	 * <p>
>, <Line: +	 * An assignment bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+----------------+-----------------+
>, <Line: +	 * | opcode | leftHandSide[] | rightHandSide[] |
>, <Line: +	 * +--------+----------------+-----------------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, the left-hand side identifies zero or more operands which are being
>, <Line: +	 * assigned to, whilst the right-hand side identifies one or more operands
>, <Line: +	 * which whose results are being assigned. The left-hand side may have fewer
>, <Line: +	 * operands than the right-hand side. This happens, for example, in the case
>, <Line: +	 * of an invocation where the result is ignored.
>, <Line: +	 * </p>
>, <Line: +	public static final class Assign extends AbstractBytecode implements Stmt {
>, <Line: +		/**
>, <Line: +		 * Construct an assignment from a right-hand operand to a left-hand
>, <Line: +		 * operand.
>, <Line: +		 *
>, <Line: +		 * @param lhs
>, <Line: +		 *            LVal on left-hand side which is assigned to
>, <Line: +		 * @param rhs
>, <Line: +		 *            Operand on right-hand side whose value is assigned
>, <Line: +		 */
>, <Line: +		public Assign(int lhs, int rhs) {
>, <Line: +			this(new int[] { lhs }, new int[] { rhs });
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Construct an assignment from a right-hand operand to a left-hand
>, <Line: +		 * operand.
>, <Line: +		 *
>, <Line: +		 * @param lhs
>, <Line: +		 *            LVal on left-hand side which is assigned to
>, <Line: +		 * @param rhs
>, <Line: +		 *            Operand on right-hand side whose value is assigned
>, <Line: +		 */
>, <Line: +		public Assign(int[] lhs, int[] rhs) {
>, <Line: +			super(new int[][] { lhs, rhs });
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_assign;
>, <Line: +		/**
>, <Line: +		 * Returns operand(s) from which assigned value is written to. This is
>, <Line: +		 * also known as the "left-hand side".
>, <Line: +		 *
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int[] leftHandSide() {
>, <Line: +			return getOperandGroup(0);
>, <Line: +		/**
>, <Line: +		 * Returns operand(s) from which assigned value is read. This is also
>, <Line: +		 * known as the "right-hand side".
>, <Line: +		 *
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int[] rightHandSide() {
>, <Line: +			return getOperandGroup(1);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "assign " + Util.arrayToString(leftHandSide()) + " = " + Util.arrayToString(rightHandSide());
>, <Line: +	 * <p>
>, <Line: +	 * An assume bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * | opcode | condition |
>, <Line: +	 * +--------+-----------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, the condition identifies an operand which is assumed to always
>, <Line: +	 * evaluate to true.  This assumption should be tested at runtime.
>, <Line: +	 * </p>
>, <Line: +	public static final class Assume extends AssertOrAssume {
>, <Line: +		public Assume(int operand) {
>, <Line: +			super(operand);
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_assume;
>, <Line: +		@Override
>, <Line: +			return "assume %" + operand();
>, <Line: +	 * <p>
>, <Line: +	 * A break bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+
>, <Line: +	 * | opcode |
>, <Line: +	 * +--------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, control will immediately exit the enclosing loop upon executing
>, <Line: +	 * this bytecode.
>, <Line: +	 * </p>
>, <Line: +	public static final class Break extends AbstractBytecode implements Stmt {
>, <Line: +		public Break() {
>, <Line: +			super(new int[0]);
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_break;
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "break ";
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * A continue bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+
>, <Line: +	 * | opcode |
>, <Line: +	 * +--------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, control will immediately complete the enclosing loop body upon
>, <Line: +	 * executing this bytecode.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static final class Continue extends AbstractBytecode implements Stmt {
>, <Line: +		public Continue() {
>, <Line: +			super(new int[]{});
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_continue;
>, <Line: +		@Override
>, <Line: +			return "cont";
>, <Line: +	 * <p>
>, <Line: +	 * A debug bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+--------+
>, <Line: +	 * | opcode | string |
>, <Line: +	 * +--------+--------+
>, <Line: +	 * Here, the string identifies an operand returning a string result which
>, <Line: +	 * will be printed to the debug console.
>, <Line: +	 * <b>NOTE</b> This bytecode is not intended to form part of the program's
>, <Line: +	 * operation. Rather, it is to facilitate debugging within functions (since
>, <Line: +	 * they cannot have side-effects). Furthermore, if debugging is disabled,
>, <Line: +	 * this bytecode is a nop.
>, <Line: +	 *
>, <Line: +	public static final class Debug extends AbstractBytecode implements Stmt {
>, <Line: +		public Debug(int operand) {
>, <Line: +			super(operand);
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_debug;
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "debug %" + getOperand(0);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * A Do While bytecode has the same format as the underlying loop bytecode.
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static class DoWhile extends Loop {
>, <Line: +		public DoWhile(int body, int condition, int[] invariants, int[] modified) {
>, <Line: +			super(body, condition, invariants, modified);
>, <Line: +		}
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_dowhile;
>, <Line: +		@Override
>, <Line: +			return "dowhile";
>, <Line: +	 * A panic bytecode has the following layout:
>, <Line: +	 * +--------+
>, <Line: +	 * | opcode |
>, <Line: +	 * +--------+
>, <Line: +	 * <p>
>, <Line: +	 * Upon execution of this bytecode, the machine will halt immediately and
>, <Line: +	 * indicate an unrecoverable error. At this time, there is no way to recover
>, <Line: +	 * from a panic, though this may be supported in the future.
>, <Line: +	 * </p>
>, <Line: +	public static final class Fail extends AbstractBytecode implements Stmt {
>, <Line: +		// FIXME: should be renamed to panic as this is a more descriptive name
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_fail;
>, <Line: +		@Override
>, <Line: +			return "fail";
>, <Line: +	 * <p>
>, <Line: +	 * An if bytecode has one of the the following layouts:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+-----------+------------+
>, <Line: +	 * | opcode | condition | trueBranch |
>, <Line: +	 * +--------+-----------+------------+
>, <Line: +	 * +--------+-----------+------------+-------------+
>, <Line: +	 * | opcode | condition | trueBranch | falseBranch |
>, <Line: +	 * +--------+-----------+------------+-------------+
>, <Line: +	 * Here, the condition identifies the condition which determines whether the
>, <Line: +	 * true branch is taken or not. If not, and there is a false branch, then
>, <Line: +	 * that is executed. Otherwise, control proceeds to the next logical
>, <Line: +	 * statement in the enclosing block.
>, <Line: +	 public static final class If extends AbstractBytecode implements Stmt {
>, <Line: +		public If(int operand, int trueBranch) {
>, <Line: +			super(operand, null, new int[] {trueBranch});			
>, <Line: +		public If(int operand, int trueBranch, int falseBranch) {
>, <Line: +			super(operand, null, new int[]{trueBranch, falseBranch});
>, <Line: +		public int getOpcode() {
>, <Line: +			return numberOfBlocks() == 1 ? OPCODE_if : OPCODE_ifelse;
>, <Line: +		public int condition() {
>, <Line: +			return getOperand(0);
>, <Line: +		/**
>, <Line: +		 * Check whether this bytecode has a false branch of not.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public boolean hasFalseBranch() {
>, <Line: +			return numberOfBlocks() > 1;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Return the block identifier for the true branch associated with this
>, <Line: +		 * bytecode.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int trueBranch() {
>, <Line: +			return getBlock(0);
>, <Line: +		/**
>, <Line: +		 * Return the block identifier for the false branch associated with this
>, <Line: +		 * bytecode.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int falseBranch() {
>, <Line: +			return getBlock(1);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +			int c = getOperand(0);
>, <Line: +			int tb = trueBranch();
>, <Line: +			if (hasFalseBranch()) {
>, <Line: +				int fb = falseBranch();
>, <Line: +				return "if" + " (%" + c + ", %" + tb + ", %" + fb + ")";
>, <Line: +			} else {
>, <Line: +				return "if" + " (%" + c + ", %" + tb + ")";
>, <Line: +			}
>, <Line: +	 * <p>
>, <Line: +	 * A loop bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+-----------+--------------+------------+------+
>, <Line: +	 * | opcode | condition | invariants[] | modified[] | body |
>, <Line: +	 * +--------+-----------+--------------+------------+------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the condition identifies the loop condition which, when false, will
>, <Line: +	 * cause the loop to terminate. The invariants identifies zero or more
>, <Line: +	 * operands which must be true on every iteration of the loop. The modified
>, <Line: +	 * variables are those variables which are, in some sense, modified in the
>, <Line: +	 * body of the loop. The body identifies a block which forms the body of the
>, <Line: +	 * loop.
>, <Line: +	 * </p>
>, <Line: +	public static abstract class Loop extends AbstractBytecode implements Stmt {
>, <Line: +		public Loop(int body, int condition, int[] invariants, int[] modified) {
>, <Line: +			super(condition, new int[][]{invariants,modified}, new int[]{body});			
>, <Line: +		}
>, <Line: +		 * Return the block identifier of the loop body.
>, <Line: +		 * @return
>, <Line: +		public int body() {
>, <Line: +			return getBlock(0);
>, <Line: +		 * Return the loop condition operand. This must be true for iteration to
>, <Line: +		 * continue around the loop.
>, <Line: +		public int condition() {
>, <Line: +			return getOperand(0);
>, <Line: +		 * Return the array of operands making up the loop invariant. Each of
>, <Line: +		 * these corresponds to a "where" clause in the original program.
>, <Line: +		public int[] invariants() {
>, <Line: +			return getOperandGroup(0);
>, <Line: +		 * Return the array of modified variables which are those assigned (in
>, <Line: +		 * some way) in the body of the loop. These cannot be operands, they
>, <Line: +		 * must be variables. These are needed for verification.
>, <Line: +		public int[] modifiedVariables() {
>, <Line: +			return getOperandGroup(1);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * A While bytecode has the same format as the underlying loop bytecode. The
>, <Line: +	 * loop invariant must hold on entry to the loop, and will hold on normal
>, <Line: +	 * exit (though not necessarily for a break exit).
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static class While extends Loop {
>, <Line: +		public While(int body, int condition, int[] invariants, int[] modified) {
>, <Line: +			super(body, condition, invariants, modified);
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_while;
>, <Line: +		@Override
>, <Line: +			return "while " + condition() + " do " + getBlock(0);
>, <Line: +	 * <p>
>, <Line: +	 * A return bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+------------+
>, <Line: +	 * | opcode | operands[] |
>, <Line: +	 * +--------+------------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * Here, there are zero or more operands which can be returned.
>, <Line: +	 * </p>
>, <Line: +	public static final class Return extends AbstractBytecode implements Stmt {
>, <Line: +		public Return() {
>, <Line: +		public Return(int... operands) {
>, <Line: +			super(operands);
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_return;
>, <Line: +		@Override
>, <Line: +		public String toString() {			
>, <Line: +			return "return " + Util.arrayToString(getOperands());			
>, <Line: +	 * <p>
>, <Line: +	 * A skip bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+
>, <Line: +	 * | opcode |
>, <Line: +	 * +--------+
>, <Line: +	 * <p>
>, <Line: +	 * Upon execution of this bytecode, the machine simply moves on to the next
>, <Line: +	 * instruction.
>, <Line: +	 * </p>
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static final class Skip extends AbstractBytecode implements Stmt {
>, <Line: +		// FIXME: should be renamed to panic as this is a more descriptive name
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_skip;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "skip";
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * A switch bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+-----------+-------+-----+-------+------------+-----+------------+
>, <Line: +	 * | opcode | condition | block | ... | block | Constant[] | ... | Constant[] |
>, <Line: +	 * +--------+-----------+-------+-----+-------+------------+-----+------------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the condition identifies the expression being switched on. There
>, <Line: +	 * are zero or more case blocks, and the same number of constant arrays. An
>, <Line: +	 * empty constant array indicates the default block.
>, <Line: +	 * </p>
>, <Line: +	public static final class Switch extends AbstractBytecode implements Stmt {
>, <Line: +		private final Constant[][] constants;
>, <Line: +		public Switch(int operand, Case[] cases) {
>, <Line: +			super(operand, null, extractBlocks(cases));
>, <Line: +			this.constants = extractConstants(cases);
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_switch;
>, <Line: +		public int operand() {
>, <Line: +			return getOperand(0);
>, <Line: +		public Case[] cases() {
>, <Line: +			Case[] cases = new Case[numberOfBlocks()];
>, <Line: +			for (int i = 0; i != cases.length; ++i) {
>, <Line: +				cases[i] = new Case(getBlock(i), constants[i]);
>, <Line: +			}
>, <Line: +			return cases;
>, <Line: +			if (o instanceof Switch) {
>, <Line: +				Switch s = (Switch) o;
>, <Line: +				return Arrays.deepEquals(constants, s.constants) && super.equals(s);
>, <Line: +		@Override
>, <Line: +			return Arrays.hashCode(constants) ^ super.hashCode();
>, <Line: +		public String toString() {
>, <Line: +			return "switch";
>, <Line: +		}
>, <Line: +		private static int[] extractBlocks(Case[] cases) {
>, <Line: +			int[] blocks = new int[cases.length];
>, <Line: +			for(int i=0;i!=cases.length;++i) {
>, <Line: +				blocks[i] = cases[i].block;
>, <Line: +			return blocks;
>, <Line: +		private static Constant[][] extractConstants(Case[] cases) {
>, <Line: +			Constant[][] blocks = new Constant[cases.length][];
>, <Line: +			for (int i = 0; i != cases.length; ++i) {
>, <Line: +				blocks[i] = cases[i].values;
>, <Line: +			}
>, <Line: +			return blocks;
>, <Line: +	public static final class Case {
>, <Line: +		private final Constant[] values;
>, <Line: +		private final int block;
>, <Line: +		public Case(int block, Constant... values) {
>, <Line: +			this.block = block;
>, <Line: +			this.values = values;
>, <Line: +		public Case(int block, List<Constant> values) {
>, <Line: +			this.block = block;
>, <Line: +			this.values = values.toArray(new Constant[values.size()]);
>, <Line: +		public boolean isDefault() {
>, <Line: +			return values.length == 0;
>, <Line: +		public int block() {
>, <Line: +			return block;
>, <Line: +		public Constant[] values() {
>, <Line: +			return values;
>, <Line: +		@Override
>, <Line: +			if (o instanceof Case) {
>, <Line: +				Case c = (Case) o;
>, <Line: +				return block == c.block && Arrays.equals(values, c.values);
>, <Line: +		@Override
>, <Line: +		public int hashCode() {
>, <Line: +			return block ^ Arrays.hashCode(values);
>, <Line: +	 * <p>
>, <Line: +	 * A variable declaration bytecode has one of the following two layouts:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+------+
>, <Line: +	 * | opcode | name |
>, <Line: +	 * +--------+------+
>, <Line: +	 * Or, with an initialiser operand:
>, <Line: +	 * +--------+---------+------+
>, <Line: +	 * | opcode | operand | name |
>, <Line: +	 * +--------+---------+------+
>, <Line: +	 * Here, the condition identifies the expression being switched on. There
>, <Line: +	 * are zero or more case blocks, and the same number of constant arrays. An
>, <Line: +	 * empty constant array indicates the default block.
>, <Line: +	public static final class VariableDeclaration extends AbstractBytecode implements Stmt {
>, <Line: +		/**
>, <Line: +		 * Variable name
>, <Line: +		 */
>, <Line: +		private final String name;
>, <Line: +		public VariableDeclaration(String name) {
>, <Line: +			super();
>, <Line: +			this.name = name;
>, <Line: +		}
>, <Line: +		public VariableDeclaration(String name, int initialiser) {
>, <Line: +			super(initialiser);
>, <Line: +			this.name = name;
>, <Line: +		}
>, <Line: +		public String getName() {
>, <Line: +			return name;
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			if (numberOfOperands() == 0) {
>, <Line: +				return OPCODE_vardecl;
>, <Line: +			} else {
>, <Line: +				return OPCODE_vardeclinit;
>, <Line: +			}
>, <Line: +			if(o instanceof VariableDeclaration) {
>, <Line: +				VariableDeclaration vd = (VariableDeclaration) o;
>, <Line: +				return name.equals(vd.name) && super.equals(o);
>, <Line: +		public int hashCode() {
>, <Line: +			return name.hashCode() ^ super.hashCode();
>, <Line: +			if(numberOfOperands() == 0) {
>, <Line: +				return "decl " + name;
>, <Line: +			} else {
>, <Line: +				return "decl " + name + " = " + getOperand(0);
>, <Line: +			}
>, <Line: +	// ===============================================================
>, <Line: +	// Bytecode Block & Index
>, <Line: +	// ===============================================================
>, <Line: +	public static class Block extends AbstractBytecode implements Bytecode {
>, <Line: +		public Block(int... operands) {
>, <Line: +			super(operands);
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_block;
>, <Line: +		public String toString() {
>, <Line: +			return "block " + Util.arrayToString(getOperands());
>, <Line: +	}
>, <Line: +	public static final class NamedBlock extends AbstractBytecode implements Bytecode.Stmt {
>, <Line: +		private final String name;		
>, <Line: +		public NamedBlock(int block, String name) {
>, <Line: +			super(new int[0], new int[0][], new int[] { block });
>, <Line: +			this.name = name;
>, <Line: +		}
>, <Line: +		public String getName() {
>, <Line: +			return name;
>, <Line: +		@Override
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_namedblock;
>, <Line: +		@Override
>, <Line: +			if(o instanceof NamedBlock) {
>, <Line: +				NamedBlock n = (NamedBlock) o;
>, <Line: +				return name.equals(n.name) && super.equals(o);
>, <Line: +		@Override
>, <Line: +		public int hashCode() {
>, <Line: +			return super.hashCode() ^ name.hashCode();
>, <Line: +		public String toString() {
>, <Line: +			return "block(" + name +") " + Util.arrayToString(getBlocks());
>, <Line: +	 * Represents a bytecode location within a code forest. This is simply a
>, <Line: +	 * pair of the block identifier and the position within that block.
>, <Line: +	public static final class Index {
>, <Line: +		private int block;
>, <Line: +		private int offset;
>, <Line: +		public Index(int block, int offset) {
>, <Line: +			this.block = block;
>, <Line: +			this.offset = offset;
>, <Line: +		public int block() {
>, <Line: +			return block;
>, <Line: +		public int offset() {
>, <Line: +			return offset;
>, <Line: +		}
>, <Line: +		public boolean equals(Object o) {
>, <Line: +			if (o instanceof Index) {
>, <Line: +				Index i = (Index) o;
>, <Line: +				return block == i.block && offset == i.offset;
>, <Line: +			return false;
>, <Line: +		public int hashCode() {
>, <Line: +			return block ^ offset;
>, <Line: +		public Index next() {
>, <Line: +			return new Index(block, offset + 1);
>, <Line: +		public Index next(int i) {
>, <Line: +			return new Index(block, offset + i);
>, <Line: +		public String toString() {
>, <Line: +			return block + ":" + offset;
>, <Line: +	// ===============================================================
>, <Line: +	// Bytecode "Statement Expressions"
>, <Line: +	// ===============================================================
>, <Line: +	/**
>, <Line: +	 * A "statement expression" is a rather unusual beast. It is both a
>, <Line: +	 * statement and an expression! There are very few bytecodes which can be
>, <Line: +	 * classified in this way.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public interface StmtExpr extends Expr,Stmt {
>, <Line: +	}
>, <Line: +	 * An indirect invocation bytecode has the following layout:
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * +--------+---------+-------------+------+
>, <Line: +	 * | opcode | operand | parameter[] | type |
>, <Line: +	 * +--------+---------+-------------+------+
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * Here, the operand returns the function pointer which this bytecode
>, <Line: +	 * indirects upon. The parameter array identifies zero or more operands
>, <Line: +	 * which are pass as arguments, whilst the type gives the signature of the
>, <Line: +	 * target function/method. For example, consider the following:
>, <Line: +	 * <pre>
>, <Line: +	 * type func_t is function(int)->int
>, <Line: +	 * 
>, <Line: +	 * function fun(func_t f, int x) -> int:
>, <Line: +	 *    return f(x)
>, <Line: +	 * </pre>
>, <Line: +	 *
>, <Line: +	 * Here, the function call <code>f(x)</code> is indirect as the called
>, <Line: +	 * function is determined by the variable <code>f</code>.
>, <Line: +	 *
>, <Line: +	public static final class IndirectInvoke extends AbstractBytecode implements StmtExpr {
>, <Line: +		private final Type.FunctionOrMethod type;
>, <Line: +		 * Construct an indirect invocation bytecode which assigns to an
>, <Line: +		 * optional target register the result from indirectly invoking a
>, <Line: +		 * function in a given operand with a given set of parameter operands.
>, <Line: +		 * @param type.
>, <Line: +		 *            Function or method type.
>, <Line: +		 *            Operand holding function pointer through which indirect
>, <Line: +		 *            invocation is made.
>, <Line: +		 * @param operands
>, <Line: +		 *            Operands holding parameters for the invoked function
>, <Line: +		public IndirectInvoke(Type.FunctionOrMethod type, int operand, int[] operands) {
>, <Line: +			super(operand, new int[][]{operands});
>, <Line: +			this.type = type;
>, <Line: +		 * Return operand holding the indirect function/method reference.
>, <Line: +		public int reference() {
>, <Line: +			return getOperand(0);
>, <Line: +		 * Return operand holding the ith parameter for the invoked function.
>, <Line: +		 * @param i
>, <Line: +		public int argument(int i) {
>, <Line: +			return getOperandGroup(0)[i];
>, <Line: +		 * Return operands holding parameters for the invoked function.
>, <Line: +		public int[] arguments() {
>, <Line: +			return getOperandGroup(0);
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_indirectinvoke;
>, <Line: +		public Type.FunctionOrMethod type() {
>, <Line: +			return type;
>, <Line: +		@Override
>, <Line: +			if (o instanceof IndirectInvoke) {
>, <Line: +				IndirectInvoke i = (IndirectInvoke) o;
>, <Line: +				return type.equals(i.type) && super.equals(o);
>, <Line: +		public int hashCode() {
>, <Line: +			return super.hashCode() + type.hashCode();
>, <Line: +		@Override
>, <Line: +			return "icall %" + reference() + " " + Util.arrayToString(arguments());
>, <Line: +	 * <p>
>, <Line: +	 * An indirect invocation bytecode has the following layout:
>, <Line: +	 * </p>
>, <Line: +	 * +--------+-------------+------+------+
>, <Line: +	 * | opcode | parameter[] | type | name |
>, <Line: +	 * +--------+-------------+------+------+
>, <Line: +	 * <p>
>, <Line: +	 * Here, the parameter array identifies zero or more operands which are pass
>, <Line: +	 * as arguments, whilst the type gives the signature of the target
>, <Line: +	 * function/method and name identifies it's fully qualitified name.
>, <Line: +	public static final class Invoke extends AbstractBytecode implements StmtExpr {
>, <Line: +		private final NameID name;
>, <Line: +		private final Type.FunctionOrMethod type;
>, <Line: +		public Invoke(Type.FunctionOrMethod type, int[] operands, NameID name) {
>, <Line: +			super(operands);
>, <Line: +			this.name = name;
>, <Line: +			this.type = type;
>, <Line: +		public int getOpcode() {
>, <Line: +			return OPCODE_invoke;
>, <Line: +		public NameID name() {
>, <Line: +			return name;
>, <Line: +		}
>, <Line: +		public Type.FunctionOrMethod type() {
>, <Line: +			return type;
>, <Line: +		@Override
>, <Line: +			if (o instanceof Invoke) {
>, <Line: +				Invoke i = (Invoke) o;
>, <Line: +				return name().equals(i.name) && super.equals(i);
>, <Line: +		@Override
>, <Line: +		public int hashCode() {
>, <Line: +			return name.hashCode() + super.hashCode();
>, <Line: +		@Override
>, <Line: +		public String toString() {
>, <Line: +			return "call " + name + Util.arrayToString(getOperands());
>, <Line: +	// ===============================================================
>, <Line: +	// ===============================================================
>, <Line: +	public static final class Util {
>, <Line: +		public static String arrayToString(int... operands) {
>, <Line: +			String r = "(";
>, <Line: +			for (int i = 0; i != operands.length; ++i) {
>, <Line: +				if (i != 0) {
>, <Line: +					r = r + ", ";
>, <Line: +				}
>, <Line: +				r = r + "%" + operands[i];
>, <Line: +			return r + ")";
>, <Line: +	public static final int OPCODE_vardecl = 0;
>, <Line: +	public static final int OPCODE_fail = 1;
>, <Line: +	public static final int OPCODE_assert = 2;
>, <Line: +	public static final int OPCODE_assume = 3;
>, <Line: +	public static final int OPCODE_break = 4;
>, <Line: +	public static final int OPCODE_continue = 5;
>, <Line: +	public static final int OPCODE_vardeclinit = 6;
>, <Line: +	public static final int OPCODE_aliasdecl = 7;
>, <Line: +	public static final int UNARY_OPERATOR = 8;
>, <Line: +	public static final int OPCODE_return = UNARY_OPERATOR + 0;
>, <Line: +	public static final int OPCODE_ifis = UNARY_OPERATOR + 1;
>, <Line: +	public static final int OPCODE_switch = UNARY_OPERATOR + 2;
>, <Line: +	public static final int OPCODE_skip = UNARY_OPERATOR + 3;
>, <Line: +	public static final int OPCODE_debug = UNARY_OPERATOR + 4;
>, <Line: +	public static final int UNARY_ASSIGNABLE = UNARY_OPERATOR + 5;
>, <Line: +	public static final int OPCODE_fieldload = UNARY_ASSIGNABLE + 7;
>, <Line: +	public static final int OPCODE_convert = UNARY_ASSIGNABLE + 8;
>, <Line: +	public static final int OPCODE_const = UNARY_ASSIGNABLE + 9;
>, <Line: +	public static final int BINARY_OPERATOR = UNARY_ASSIGNABLE + 10;
>, <Line: +	public static final int OPCODE_if = BINARY_OPERATOR + 0;
>, <Line: +	public static final int OPCODE_ifelse = BINARY_OPERATOR + 1;
>, <Line: +	public static final int BINARY_ASSIGNABLE = BINARY_OPERATOR + 6;
>, <Line: +	public static final int OPCODE_neg = BINARY_ASSIGNABLE + 0;
>, <Line: +	public static final int OPCODE_add = BINARY_ASSIGNABLE + 1;
>, <Line: +	public static final int OPCODE_sub = BINARY_ASSIGNABLE + 2;
>, <Line: +	public static final int OPCODE_mul = BINARY_ASSIGNABLE + 3;
>, <Line: +	public static final int OPCODE_div = BINARY_ASSIGNABLE + 4;
>, <Line: +	public static final int OPCODE_rem = BINARY_ASSIGNABLE + 5;
>, <Line: +	public static final int OPCODE_eq = BINARY_ASSIGNABLE + 6;
>, <Line: +	public static final int OPCODE_ne = BINARY_ASSIGNABLE + 7;
>, <Line: +	public static final int OPCODE_lt = BINARY_ASSIGNABLE + 8;
>, <Line: +	public static final int OPCODE_le = BINARY_ASSIGNABLE + 9;
>, <Line: +	public static final int OPCODE_gt = BINARY_ASSIGNABLE + 10;
>, <Line: +	public static final int OPCODE_ge = BINARY_ASSIGNABLE + 11;
>, <Line: +	public static final int OPCODE_logicalnot = BINARY_ASSIGNABLE + 12;
>, <Line: +	public static final int OPCODE_logicaland = BINARY_ASSIGNABLE + 13;
>, <Line: +	public static final int OPCODE_logicalor = BINARY_ASSIGNABLE + 14;
>, <Line: +	public static final int OPCODE_bitwiseinvert = BINARY_ASSIGNABLE + 15;
>, <Line: +	public static final int OPCODE_bitwiseor = BINARY_ASSIGNABLE + 16;
>, <Line: +	public static final int OPCODE_bitwisexor = BINARY_ASSIGNABLE + 17;
>, <Line: +	public static final int OPCODE_bitwiseand = BINARY_ASSIGNABLE + 18;
>, <Line: +	public static final int OPCODE_shl = BINARY_ASSIGNABLE + 19;
>, <Line: +	public static final int OPCODE_shr = BINARY_ASSIGNABLE + 20;
>, <Line: +	public static final int OPCODE_arraylength = BINARY_ASSIGNABLE + 21;
>, <Line: +	public static final int OPCODE_arrayindex = BINARY_ASSIGNABLE + 22;
>, <Line: +	public static final int OPCODE_arraygen = BINARY_ASSIGNABLE + 23;
>, <Line: +	public static final int OPCODE_array = BINARY_ASSIGNABLE + 24;
>, <Line: +	public static final int OPCODE_record = BINARY_ASSIGNABLE + 25;
>, <Line: +	public static final int OPCODE_is = BINARY_ASSIGNABLE + 26;
>, <Line: +	public static final int OPCODE_dereference = BINARY_ASSIGNABLE + 27;
>, <Line: +	public static final int OPCODE_newobject = BINARY_ASSIGNABLE + 28;
>, <Line: +	public static final int OPCODE_varaccess = BINARY_ASSIGNABLE + 29;
>, <Line: +	public static final int NARY_ASSIGNABLE = BINARY_ASSIGNABLE + 30;
>, <Line: +	public static final int OPCODE_invoke = NARY_ASSIGNABLE + 2;
>, <Line: +	public static final int OPCODE_indirectinvoke = NARY_ASSIGNABLE + 3;
>, <Line: +	public static final int OPCODE_lambda = NARY_ASSIGNABLE + 4;
>, <Line: +	public static final int OPCODE_while = NARY_ASSIGNABLE + 5;
>, <Line: +	public static final int OPCODE_dowhile = NARY_ASSIGNABLE + 6;
>, <Line: +	public static final int OPCODE_some = NARY_ASSIGNABLE + 8;
>, <Line: +	public static final int OPCODE_all = NARY_ASSIGNABLE + 9;
>, <Line: +	public static final int OPCODE_assign = NARY_ASSIGNABLE + 10;
>, <Line: +	public static final int OPCODE_block = NARY_ASSIGNABLE + 11;
>, <Line: +	public static final int OPCODE_namedblock = NARY_ASSIGNABLE + 12;
>, <Line: +	public enum Operands {
>, <Line: +	public enum OperandGroups {
>, <Line: +	public enum Blocks {
>, <Line: +		TYPE, // index into type pool
>, <Line: +		private final OperandGroups groups;
>, <Line: +		private final Blocks blocks;
>, <Line: +		public Schema(Operands operands, Extras... extras) {
>, <Line: +			this.operands = operands;
>, <Line: +			this.groups = OperandGroups.ZERO;
>, <Line: +			this.blocks = Blocks.ZERO;
>, <Line: +			this.extras = extras;
>, <Line: +		}
>, <Line: +		public Schema(Operands operands, OperandGroups groups, Extras... extras) {
>, <Line: +			this.operands = operands;
>, <Line: +			this.groups = groups;
>, <Line: +			this.blocks = Blocks.ZERO;
>, <Line: +			this.extras = extras;
>, <Line: +		}
>, <Line: +		public Schema(Operands operands, OperandGroups groups, Blocks blocks, Extras... extras) {
>, <Line: +			this.groups = groups;
>, <Line: +			this.blocks = blocks;
>, <Line: +		public Operands getOperands() {
>, <Line: +			return operands;
>, <Line: +		}
>, <Line: +		public OperandGroups getOperandGroups() {
>, <Line: +			return groups;
>, <Line: +		}
>, <Line: +		public Blocks getBlocks() {
>, <Line: +			return blocks;
>, <Line: +		}
>, <Line: +		public abstract Bytecode construct(int opcode, int[] operands, int[][] groups, int[] blocks, Object[] extras);
>, <Line: +			return "<" + operands + " operands, " + Arrays.toString(extras) + ">";
>]
[<Line: -import wycc.util.Pair;
>, <Line: - * Represents a WyIL bytecode. The Whiley Intermediate Language (WyIL) employs
>, <Line: - * register-based bytecodes (as opposed to e.g. the Java Virtual Machine, which
>, <Line: - * uses stack-based bytecodes). During execution, one can think of the "machine"
>, <Line: - * as maintaining a call stack made up of "frames". For each function or method
>, <Line: - * on the call stack, the corresponding frame consists of zero or more
>, <Line: - * <i>registers</i>. Bytecodes may read/write values from registers. Like the
>, <Line: - * Java Virtual Machine, WyIL uses unstructured control-flow. However, unlike
>, <Line: - * the JVM, it also allows variables to be automatically retyped by runtime type
>, <Line: - * tests. The following illustrates:
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * function sum(int[] data) -> int:
>, <Line: - *    int r = 0
>, <Line: - *    for item in data:
>, <Line: - *       r = r + item
>, <Line: - *    return r
>, <Line: - * </pre>
>, <Line: - *
>, <Line: - * This function is compiled into the following WyIL bytecode:
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * function sum(int[] data) -> int:
>, <Line: - * body:
>, <Line: - *   const %1 = 0          : int
>, <Line: - *   assign %2 = %0        : [int]
>, <Line: - *   forall %3 in %2 ()    : [int]
>, <Line: - *       assign %4 = %1    : int
>, <Line: - *       add %1 = %4, %3   : int
>, <Line: - *   return %1             : int
>, <Line: - * </pre>
>, <Line: - *
>, <Line: - * <p>
>, <Line: - * Here, we can see that every bytecode is associated with one (or more) types.
>, <Line: - * These types are inferred by the compiler during type propagation.
>, <Line: - * </p>
>, <Line: - *
>, <Line: - * <i>target registers</i>, <i>operand registers</i> <i>types</i> and <i>other
>, <Line: - * items</i> used (e.g. names, constants, etc). The generic organisation of a
>, <Line: - * bytecode is as follows:
>, <Line: - * +--------+---------+----------+-------+-------------+
>, <Line: - * | opcode | targets | operands | types | other items |
>, <Line: - * +--------+---------+----------+-------+-------------+
>, <Line: - * etc), whilst <i>fmt</i> identifies the bytecode format. Different formats are
>, <Line: - * used to specify common bytecode layouts:
>, <Line: - * <pre>
>, <Line: - * fmt | constaints
>, <Line: - * ----+-----------
>, <Line: - *  00 | none
>, <Line: - *  01 | zero targets
>, <Line: - *  10 | one target
>, <Line: - *  11 | unused
>, <Line: - * </pre>
>, <Line: -public abstract class Bytecode {
>, <Line: -	protected final Type[] types;
>, <Line: -	private final int[] targets;
>, <Line: -	protected final int[] operands;		
>, <Line: -	public Bytecode(Type type, int target, int... operands) {			
>, <Line: -		this.types = new Type[]{type};
>, <Line: -		this.targets = new int[] {target};
>, <Line: -		this.operands = operands;
>, <Line: -	}
>, <Line: -	public Bytecode(Type[] types, int[] targets, int... operands) {			
>, <Line: -		this.types = types;
>, <Line: -		this.targets = targets;
>, <Line: -		this.operands = operands;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public int hashCode() {
>, <Line: -		return Arrays.hashCode(types) + Arrays.hashCode(targets()) + Arrays.hashCode(operands());
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public boolean equals(Object o) {
>, <Line: -		if (o instanceof Bytecode) {
>, <Line: -			Bytecode bo = (Bytecode) o;
>, <Line: -			return Arrays.equals(targets(), bo.targets()) && Arrays.equals(operands(), bo.operands())
>, <Line: -					&& Arrays.equals(types, bo.types);
>, <Line: -		}
>, <Line: -		return false;
>, <Line: -	}
>, <Line: -	public Type[] types() {
>, <Line: -		return types;
>, <Line: -	}
>, <Line: -	public Type type(int i) {
>, <Line: -		return (Type) types[i];
>, <Line: -	}
>, <Line: -	 * Return a specific target register assigned by this bytecode.
>, <Line: -	public int target(int i) {
>, <Line: -		return targets[i];
>, <Line: -	}
>, <Line: -	 * Return the target registers assigned by this bytecode.
>, <Line: -	public int[] targets() {
>, <Line: -		return targets;
>, <Line: -	}		
>, <Line: -	 * Return the operand registers assigned by this bytecode.
>, <Line: -	public int[] operands() {
>, <Line: -		return operands;
>, <Line: -	}
>, <Line: -	 * Return the ith operand read by this bytecode.
>, <Line: -	public int operand(int i) {
>, <Line: -		return operands[i];
>, <Line: -	}	
>, <Line: -	public abstract int opcode();
>, <Line: -	 * A compound bytecode represents a bytecode that contains sequence of zero
>, <Line: -	 * or more bytecodes. For example, the loop bytecode contains its loop body.
>, <Line: -	 * The nested block of bytecodes is represented as a block identifier in the
>, <Line: -	 * enclosing forest.
>, <Line: -	public static abstract class Compound extends Bytecode {
>, <Line: -		protected final int block;
>, <Line: -		public Compound(int block, Type[] types, int[] targets, int... operands) {
>, <Line: -			super(types, targets, operands);
>, <Line: -			this.block = block;
>, <Line: -		public int block() {
>, <Line: -			return block;
>, <Line: -			return super.hashCode() ^ block;
>, <Line: -			if(o instanceof Compound) {
>, <Line: -				Compound abc = (Compound) o;
>, <Line: -				return block == abc.block && super.equals(o);
>, <Line: -	 * A compound bytecode represents a bytecode that contains sequence of zero
>, <Line: -	 * or more bytecodes. For example, the loop bytecode contains its loop body.
>, <Line: -	 * The nested block of bytecodes is represented as a block identifier in the
>, <Line: -	 * enclosing forest.
>, <Line: -	public static abstract class Branching extends Bytecode {
>, <Line: -		protected final String destination;
>, <Line: -		public Branching(String destination, Type[] types, int[] targets, int... operands) {
>, <Line: -			super(types, targets, operands);
>, <Line: -			this.destination = destination;
>, <Line: -		public String destination() {
>, <Line: -			return destination;
>, <Line: -		public int hashCode() {
>, <Line: -			return super.hashCode() ^ destination.hashCode();
>, <Line: -			if(o instanceof Branching) {
>, <Line: -				Branching abc = (Branching) o;
>, <Line: -				return destination.equals(abc.destination) && super.equals(o);
>, <Line: -	// ===============================================================
>, <Line: -	// Bytecode Implementations
>, <Line: -	// ===============================================================
>, <Line: -	 * Represents a binary operator (e.g. '+','-',etc) that is provided to a
>, <Line: -	 * <code>BinOp</code> bytecode.
>, <Line: -		NEG(0) {
>, <Line: -		NOT(1) {
>, <Line: -		BITWISEINVERT(2) {
>, <Line: -		DEREFERENCE(3) {
>, <Line: -		ARRAYLENGTH(4) {
>, <Line: -				return "length";
>, <Line: -		ADD(5) {
>, <Line: -		SUB(6) {
>, <Line: -		MUL(7) {
>, <Line: -		DIV(8) {
>, <Line: -		REM(9) {
>, <Line: -		EQ(10) {
>, <Line: -		NEQ(11) {
>, <Line: -				return "ne";
>, <Line: -		LT(12) {
>, <Line: -		LTEQ(13) {
>, <Line: -				return "le";
>, <Line: -		GT(14) {
>, <Line: -		GTEQ(15) {
>, <Line: -				return "ge";
>, <Line: -		BITWISEOR(16) {
>, <Line: -				return "or";
>, <Line: -		BITWISEXOR(17) {
>, <Line: -				return "xor";
>, <Line: -		BITWISEAND(18) {
>, <Line: -				return "and";
>, <Line: -		LEFTSHIFT(19) {
>, <Line: -				return "shl";
>, <Line: -		RIGHTSHIFT(20) {
>, <Line: -				return "shr";
>, <Line: -		ARRAYINDEX(21) {
>, <Line: -				return "indexof";
>, <Line: -		ARRAYGENERATOR(22) {
>, <Line: -				return "arraygen";
>, <Line: -		ARRAYCONSTRUCTOR(23) {
>, <Line: -				return "array";
>, <Line: -		RECORDCONSTRUCTOR(24) {
>, <Line: -				return "record";
>, <Line: -		NEW(25) {
>, <Line: -				return "new";
>, <Line: -		ASSIGN(26) {
>, <Line: -				return "assign";
>, <Line: -		public int offset;
>, <Line: -			this.offset = offset;
>, <Line: -	 * A binary operation which reads two numeric values from the operand
>, <Line: -	 * registers, performs an operation on them and writes the result to the
>, <Line: -	 * target register. The binary operators are:
>, <Line: -	 * <ul>
>, <Line: -	 * <li><i>add, subtract, multiply, divide, remainder</i>. Both operands must
>, <Line: -	 * be either integers or reals (but not one or the other). A value of the
>, <Line: -	 * same type is produced.</li>
>, <Line: -	 * <li><i>bitwiseor, bitwisexor, bitwiseand</i></li>
>, <Line: -	 * <li><i>leftshift,rightshift</i></li>
>, <Line: -	 * </ul>
>, <Line: -	 * For example, the following Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 *     return ((x * y) + 1) / 2
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     mul %2 = %0, %1   : int
>, <Line: -	 *     const %3 = 1      : int
>, <Line: -	 *     add %2 = %2, %3   : int
>, <Line: -	 *     const %3 = 2      : int
>, <Line: -	 *     const %4 = 0      : int
>, <Line: -	 *     assertne %3, %4 "division by zero" : int
>, <Line: -	 *     div %2 = %2, %3   : int
>, <Line: -	 *     return %2         : int
>, <Line: -	 * Here, the <code>assertne</code> bytecode has been included to check
>, <Line: -	 * against division-by-zero. In this particular case the assertion is known
>, <Line: -	 * true at compile time and, in practice, would be compiled away.
>, <Line: -	public static final class Operator extends Bytecode {
>, <Line: -		public Operator(Type type, int[] targets, int[] operands, OperatorKind bop) {
>, <Line: -			super(new Type[] { type }, targets, operands);
>, <Line: -			if (bop == null) {
>, <Line: -				throw new IllegalArgumentException("Operator kind cannot be null");
>, <Line: -			}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_neg + kind().offset;
>, <Line: -		}
>, <Line: -		public int hashCode() {
>, <Line: -			return kind.hashCode() + super.hashCode();
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof Operator) {
>, <Line: -				Operator bo = (Operator) o;
>, <Line: -				return kind.equals(bo.kind) && super.equals(bo);
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -			return kind() + " %" + target(0) + " = " + arrayToString(operands()) + " : " + type(0);
>, <Line: -		public OperatorKind kind() {
>, <Line: -			return kind;
>, <Line: -	 * Reads a value from the operand register, converts it to a given type and
>, <Line: -	 * writes the result to the target register. This bytecode is the only way
>, <Line: -	 * to change the type of a value. It's purpose is to simplify
>, <Line: -	 * implementations which have different representations of data types. A
>, <Line: -	 * convert bytecode must be inserted whenever the type of a register
>, <Line: -	 * changes. This includes at control-flow meet points, when the value is
>, <Line: -	 * passed as a parameter, assigned to a field, etc. For example, the
>, <Line: -	 * following Whiley code:
>, <Line: -	 * function f(int x) -> real:
>, <Line: -	 *     return x + 1
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x) -> real:
>, <Line: -	 * body:
>, <Line: -	 *     const %2 = 1           : int
>, <Line: -	 *     add %1 = %0, %2        : int
>, <Line: -	 *     convert %1 = %1 real   : int
>, <Line: -	 *     return %1              : real
>, <Line: -	 * </pre>
>, <Line: -	 * Here, we see that the <code>int</code> value in register <code>%1</code>
>, <Line: -	 * must be explicitly converted into a <code>real</code> value before it can
>, <Line: -	 * be returned from this function.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * <b>NOTE:</b> In many cases, this bytecode may correspond to a nop on the
>, <Line: -	 * hardware. Consider converting from <code>[any]</code> to <code>any</code>
>, <Line: -	 * . On the JVM, <code>any</code> translates to <code>Object</code>, whilst
>, <Line: -	 * <code>[any]</code> translates to <code>List</code> (which is an instance
>, <Line: -	 * of <code>Object</code>). Thus, no conversion is necessary since
>, <Line: -	 * <code>List</code> can safely flow into <code>Object</code>.
>, <Line: -	 *
>, <Line: -	public static final class Convert extends Bytecode {
>, <Line: -		public Convert(Type from, int target, int operand, Type result) {
>, <Line: -			super(new Type[] { from, result }, new int[] { target }, operand);
>, <Line: -		public Type result() {
>, <Line: -			return type(1);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_convert;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof Convert && super.equals(o);
>, <Line: -		public String toString() {
>, <Line: -			return "convert %" + target(0) + " = %" + operand(0) + " " + result() + " : " + type(0);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Writes a constant value to a target register. This includes
>, <Line: -	 * <i>integers</i>, <i>rationals</i>, <i>lists</i>, <i>sets</i>, <i>maps</i>
>, <Line: -	 * , etc. For example, the following Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x) -> int:
>, <Line: -	 *     xs = {1,2.12}
>, <Line: -	 *     return |xs| + 1
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     var xs
>, <Line: -	 *     const %2 = 1               : int
>, <Line: -	 *     convert %2 = % 2 int|real  : int
>, <Line: -	 *     const %3 = 2.12            : real
>, <Line: -	 *     convert %3 = % 3 int|real  : real
>, <Line: -	 *     newset %1 = (%2, %3)       : {int|real}
>, <Line: -	 *     assign %3 = %1             : {int|real}
>, <Line: -	 *     lengthof %3 = % 3          : {int|real}
>, <Line: -	 *     const %4 = 1               : int
>, <Line: -	 *     add %2 = % 3, %4           : int
>, <Line: -	 *     return %2                  : int
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * Here, we see two kinds of constants values being used: integers (i.e.
>, <Line: -	 * <code>const %2 = 1</code>) and rationals (i.e.
>, <Line: -	 * <code>const %3 = 2.12</code>).
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static final class Const extends Bytecode {
>, <Line: -		private final Constant constant;
>, <Line: -		public Const(int target, Constant constant) {
>, <Line: -			super(new Type[0], new int[] { target }, new int[0]);
>, <Line: -			this.constant = constant;
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_const;
>, <Line: -		public int target() {
>, <Line: -			return targets()[0];
>, <Line: -		}
>, <Line: -		public Constant constant() {
>, <Line: -			return constant;
>, <Line: -		public int hashCode() {
>, <Line: -			return constant.hashCode() + targets()[0];
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof Const) {
>, <Line: -				Const c = (Const) o;
>, <Line: -				return constant.equals(c.constant) && Arrays.equals(targets(), c.targets());
>, <Line: -		public String toString() {
>, <Line: -			return "const %" + targets()[0] + " = " + constant + " : " + constant.type();
>, <Line: -	 * Read a string from the operand register and prints it to the debug
>, <Line: -	 * console. For example, the following Whiley code:
>, <Line: -	 * method f(int x):
>, <Line: -	 *     debug "X = " + x
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * method f(int x):
>, <Line: -	 * body:
>, <Line: -	 *     const %2 = "X = "       : string
>, <Line: -	 *     convert %0 = %0 any     : int
>, <Line: -	 *     invoke %0 (%0) whiley/lang/Any:toString : string(any)
>, <Line: -	 *     strappend %1 = %2, %0   : string
>, <Line: -	 *     debug %1                : string
>, <Line: -	 *     return
>, <Line: -	 * <b>NOTE</b> This bytecode is not intended to form part of the program's
>, <Line: -	 * operation. Rather, it is to facilitate debugging within functions (since
>, <Line: -	 * they cannot have side-effects). Furthermore, if debugging is disabled,
>, <Line: -	 * this bytecode is a nop.
>, <Line: -	public static final class Debug extends Bytecode {
>, <Line: -		public Debug(int operand) {
>, <Line: -			super(new Type[] { Type.Array(Type.T_INT, false) }, new int[0], operand);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_debug;
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof Debug && super.equals(o);
>, <Line: -			return "debug %" + operands[0] + " " + " : " + types[0];
>, <Line: -	 * <code>assume</code> bytecode block.
>, <Line: -	public static abstract class AssertOrAssume extends Compound {
>, <Line: -		private AssertOrAssume(int block) {
>, <Line: -			super(block, new Type[0], new int[0], new int[0]);
>, <Line: -	 * Represents a block of bytecode instructions representing an assertion.
>, <Line: -		public Assert(int block) {
>, <Line: -			super(block);
>, <Line: -		public int opcode() {
>, <Line: -			return "assert #" + block;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof Assume && super.equals(o);
>, <Line: -		}
>, <Line: -	 * Represents a block of bytecode instructions representing an assumption.
>, <Line: -	public static final class Assume extends AssertOrAssume {
>, <Line: -		public Assume(int block) {
>, <Line: -			super(block);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_assume;
>, <Line: -		public String toString() {
>, <Line: -			return "assume #" + block;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof Assume && super.equals(o);
>, <Line: -	 * A bytecode that halts execution by raising a runtime fault. This bytecode
>, <Line: -	 * signals that some has gone wrong, and is typically used to signal an
>, <Line: -	 * assertion failure.
>, <Line: -	public static final class Fail extends Bytecode {
>, <Line: -		public Fail() {
>, <Line: -			super(new Type[0], new int[0]);
>, <Line: -		@Override
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_fail;
>, <Line: -			return "fail";
>, <Line: -	 * Reads a record value from an operand register, extracts the value of a
>, <Line: -	 * given field and writes this to the target register. For example, the
>, <Line: -	 * following Whiley code:
>, <Line: -	 * type Point is {int x, int y}
>, <Line: -	 *
>, <Line: -	 * function f(Point p) -> int:
>, <Line: -	 *     return p.x + p.y
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f({int x,int y} p) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     fieldload %2 = %0 x    : {int x,int y}
>, <Line: -	 *     fieldload %3 = %0 y    : {int x,int y}
>, <Line: -	 *     add %1 = %2, %3        : int
>, <Line: -	 *     return %1              : int
>, <Line: -	 * </pre>
>, <Line: -	public static final class FieldLoad extends Bytecode {
>, <Line: -		private final String field;
>, <Line: -		public FieldLoad(Type.EffectiveRecord type, int target, int operand, String field) {
>, <Line: -			super((Type) type, target, operand);
>, <Line: -			if (field == null) {
>, <Line: -				throw new IllegalArgumentException("FieldLoad field argument cannot be null");
>, <Line: -			}
>, <Line: -			this.field = field;
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_fieldload;
>, <Line: -		public int hashCode() {
>, <Line: -			return super.hashCode() + field.hashCode();
>, <Line: -		public Type fieldType() {
>, <Line: -			Type.EffectiveRecord er = (Type.EffectiveRecord) type(0);
>, <Line: -			return er.fields().get(field);
>, <Line: -		}
>, <Line: -		public String fieldName() {
>, <Line: -			return field;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof FieldLoad) {
>, <Line: -				FieldLoad i = (FieldLoad) o;
>, <Line: -				return super.equals(i) && field.equals(i.field);
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -			return "fieldload %" + target(0) + " = %" + operand(0) + " " + field + " : " + type(0);
>, <Line: -	 * Branches unconditionally to the given label. This is typically used for
>, <Line: -	 * if/else statements. For example, the following Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x) -> int:
>, <Line: -	 *     if x >= 0:
>, <Line: -	 *         x = 1
>, <Line: -	 *     else:
>, <Line: -	 *         x = -1
>, <Line: -	 *     return x
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function f(int x) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     const %1 = 0             : int
>, <Line: -	 *     iflt %0, %1 goto blklab0 : int
>, <Line: -	 *     const %0 = 1             : int
>, <Line: -	 *     goto blklab1
>, <Line: -	 * .blklab0
>, <Line: -	 *     const %0 = 1             : int
>, <Line: -	 *     neg %0 = % 0             : int
>, <Line: -	 * .blklab1
>, <Line: -	 *     return %0                : int
>, <Line: -	 * Here, we see the <code>goto</code> bytecode being used to jump from the
>, <Line: -	 * end of the true branch over the false branch.
>, <Line: -	 *
>, <Line: -	 * <b>Note:</b> in WyIL bytecode, <i>such branches may only go forward</i>.
>, <Line: -	 * Thus, a <code>goto</code> bytecode cannot be used to implement the
>, <Line: -	 * back-edge of a loop. Rather, a loop block must be used for this purpose.
>, <Line: -	public static final class Goto extends Branching {
>, <Line: -		public Goto(String target) {
>, <Line: -			super(target, new Type[0], new int[0]);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_goto;
>, <Line: -		public Goto relabel(Map<String, String> labels) {
>, <Line: -			String nlabel = labels.get(destination());
>, <Line: -			if (nlabel == null) {
>, <Line: -				return this;
>, <Line: -			} else {
>, <Line: -				return new Goto(nlabel);
>, <Line: -			}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof Goto && super.equals(o);
>, <Line: -			return "goto " + destination();
>, <Line: -	 * Branches conditionally to the given label by reading the values from two
>, <Line: -	 * operand registers and comparing them. The possible comparators are:
>, <Line: -	 * <ul>
>, <Line: -	 * <li><i>equals (eq) and not-equals (ne)</i>. Both operands must have the
>, <Line: -	 * given type.</li>
>, <Line: -	 * <li><i>less-than (lt), less-than-or-equals (le), greater-than (gt) and
>, <Line: -	 * great-than-or-equals (ge).</i> Both operands must have the given type,
>, <Line: -	 * which additionally must by either <code>char</code>, <code>int</code> or
>, <Line: -	 * <code>real</code>.</li>
>, <Line: -	 * <li><i>element of (in).</i> The second operand must be a set whose
>, <Line: -	 * element type is that of the first.</li>
>, <Line: -	 * </ul>
>, <Line: -	 * For example, the following Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 *     if x < y:
>, <Line: -	 *         return -1
>, <Line: -	 *     else if x > y:
>, <Line: -	 *         return 1
>, <Line: -	 *     else:
>, <Line: -	 *         return 0
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     ifge %0, %1 goto blklab0 : int
>, <Line: -	 *     const %2 = -1 : int
>, <Line: -	 *     return %2 : int
>, <Line: -	 * .blklab0
>, <Line: -	 *     ifle %0, %1 goto blklab2 : int
>, <Line: -	 *     const %2 = 1 : int
>, <Line: -	 *     return %2 : int
>, <Line: -	 * .blklab2
>, <Line: -	 *     const %2 = 0 : int
>, <Line: -	 *     return %2 : int
>, <Line: -	 * <b>Note:</b> in WyIL bytecode, <i>such branches may only go forward</i>.
>, <Line: -	 * Thus, an <code>ifgoto</code> bytecode cannot be used to implement the
>, <Line: -	 * back-edge of a loop. Rather, a loop block must be used for this purpose.
>, <Line: -	public static final class If extends Branching {
>, <Line: -		public If(Type type, int operand, String target) {
>, <Line: -			super(target, new Type[] { type }, new int[0], operand);
>, <Line: -		}
>, <Line: -		public If relabel(Map<String, String> labels) {
>, <Line: -			String nlabel = labels.get(destination());
>, <Line: -			if (nlabel == null) {
>, <Line: -				return this;
>, <Line: -			} else {
>, <Line: -				return new If(types[0], operands[0], nlabel);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_if;
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof If && super.equals(o);			
>, <Line: -			return "if" + " %" + operands[0] + " goto " + destination() + " : " + types[0];
>, <Line: -	 * Branches conditionally to the given label based on the result of a
>, <Line: -	 * runtime type test against a value from the operand register. More
>, <Line: -	 * specifically, it checks whether the value is a subtype of the type test.
>, <Line: -	 * The operand register is automatically <i>retyped</i> as a result of the
>, <Line: -	 * type test. On the true branch, its type is intersected with type test. On
>, <Line: -	 * the false branch, its type is intersected with the <i>negation</i> of the
>, <Line: -	 * type test. For example, the following Whiley code:
>, <Line: -	 * function f(int|int[] x) -> int:
>, <Line: -	 *     if x is int[]:
>, <Line: -	 *         return |x|
>, <Line: -	 *     else:
>, <Line: -	 *         return x
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 *
>, <Line: -	 * function f(int|int[] x) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     ifis %0, int[] goto lab    : int|int[]
>, <Line: -	 *     return %0                  : int
>, <Line: -	 * .lab
>, <Line: -	 *     lengthof %0 = %0           : int[]
>, <Line: -	 *     return %0                  : int
>, <Line: -	 * Here, we see that, on the false branch, register <code>%0</code> is
>, <Line: -	 * automatically given type <code>int</code>, whilst on the true branch it
>, <Line: -	 * is automatically given type <code>int[]</code>.
>, <Line: -	 *
>, <Line: -	 * <b>Note:</b> in WyIL bytecode, <i>such branches may only go forward</i>.
>, <Line: -	 * Thus, an <code>ifis</code> bytecode cannot be used to implement the
>, <Line: -	 * back-edge of a loop. Rather, a loop block must be used for this purpose.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	public static final class IfIs extends Branching {
>, <Line: -		public IfIs(Type type, int leftOperand, Type rightOperand, String target) {
>, <Line: -			super(target, new Type[] { type, rightOperand }, new int[0], leftOperand);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_ifis;
>, <Line: -		public Type rightOperand() {
>, <Line: -			return type(1);
>, <Line: -		public IfIs relabel(Map<String, String> labels) {
>, <Line: -			String nlabel = labels.get(destination());
>, <Line: -			if (nlabel == null) {
>, <Line: -				return this;
>, <Line: -			} else {
>, <Line: -				return new IfIs(types[0], operands[0], types[1], nlabel);
>, <Line: -			}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof IfIs && super.equals(o);
>, <Line: -			return "ifis" + " %" + operands[0] + ", " + types[1] + " goto " + destination() + " : " + types[0];
>, <Line: -	 * Represents an indirect function call. For example, consider the
>, <Line: -	 * following:
>, <Line: -	 * function fun(function (int)->int f, int x) -> int:
>, <Line: -	 *    return f(x)
>, <Line: -	 * Here, the function call <code>f(x)</code> is indirect as the called
>, <Line: -	 * function is determined by the variable <code>f</code>.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	public static final class IndirectInvoke extends Bytecode {
>, <Line: -		 * Construct an indirect invocation bytecode which assigns to an
>, <Line: -		 * optional target register the result from indirectly invoking a
>, <Line: -		 * function in a given operand with a given set of parameter operands.
>, <Line: -		 * @param type
>, <Line: -		 * @param target
>, <Line: -		 *            Register (optional) to which result of invocation is
>, <Line: -		 *            assigned.
>, <Line: -		 * @param operand
>, <Line: -		 *            Register holding function point through which indirect
>, <Line: -		 *            invocation is made.
>, <Line: -		 * @param operands
>, <Line: -		 *            Registers holding parameters for the invoked function
>, <Line: -		public IndirectInvoke(Type.FunctionOrMethod type, int[] targets, int operand, int[] operands) {
>, <Line: -			super(new Type.FunctionOrMethod[] { type }, targets, append(operand, operands));
>, <Line: -		 * Return register holding the indirect function/method reference.
>, <Line: -		public int reference() {
>, <Line: -			return operands()[0];
>, <Line: -		 * Return register holding the ith parameter for the invoked function.
>, <Line: -		 * @param i
>, <Line: -		public int parameter(int i) {
>, <Line: -			return operands()[i + 1];
>, <Line: -		 * Return registers holding parameters for the invoked function.
>, <Line: -		 *
>, <Line: -		 * @param i
>, <Line: -		 * @return
>, <Line: -		public int[] parameters() {
>, <Line: -			return Arrays.copyOfRange(operands(), 1, operands().length);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_indirectinvoke;
>, <Line: -		public Type.FunctionOrMethod type(int i) {
>, <Line: -			return (Type.FunctionOrMethod) super.type(i);
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			return o instanceof IndirectInvoke && super.equals(o);
>, <Line: -			return "indirectinvoke " + arrayToString(targets()) + " = %" + reference() + " "
>, <Line: -					+ arrayToString(parameters()) + " : " + type(0);
>, <Line: -	 * Represents a block of bytecode instructions representing an assertion.
>, <Line: -	public static class Invariant extends Assert {
>, <Line: -		public Invariant(int block) {
>, <Line: -			super(block);
>, <Line: -		}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_invariant;
>, <Line: -		public String toString() {
>, <Line: -			return "invariant";
>, <Line: -		public int hashCode() {
>, <Line: -			return block;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof Invariant) {
>, <Line: -				Invariant f = (Invariant) o;
>, <Line: -				return block == f.block;
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -	 * Corresponds to a function or method call whose parameters are read from
>, <Line: -	 * zero or more operand registers. If a return value is required, this is
>, <Line: -	 * written to a target register afterwards. For example, the following
>, <Line: -	 * Whiley code:
>, <Line: -	 * function g(int x, int y, int z) -> int:
>, <Line: -	 *     return x * y * z
>, <Line: -	 *
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 *     r = g(x,y,3)
>, <Line: -	 *     return r + 1
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function g(int x, int y, int z) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     mul %3 = %0, %1   : int
>, <Line: -	 *     mul %3 = %3, %2   : int
>, <Line: -	 *     return %3         : int
>, <Line: -	 *
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     const %2 = 3                    : int
>, <Line: -	 *     invoke %2 = (%0, %1, %2) test:g   : int(int,int,int)
>, <Line: -	 *     const %3 = 1                    : int
>, <Line: -	 *     add %2 = (%2, %3)                : int
>, <Line: -	 *     return %2                       : int
>, <Line: -	 * Here, we see that arguments to the <code>invoke</code> bytecode are
>, <Line: -	 * supplied in the order they are given in the function or method's
>, <Line: -	 * declaration.
>, <Line: -	public static final class Invoke extends Bytecode {
>, <Line: -		private final NameID name;
>, <Line: -		public Invoke(Type.FunctionOrMethod type, int[] targets, int[] operands, NameID name) {
>, <Line: -			super(new Type.FunctionOrMethod[] { type }, targets, operands);
>, <Line: -			this.name = name;
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_invoke;
>, <Line: -		public NameID name() {
>, <Line: -			return name;
>, <Line: -		public int hashCode() {
>, <Line: -			return name.hashCode() + super.hashCode();
>, <Line: -		public Type.FunctionOrMethod type(int i) {
>, <Line: -			return (Type.FunctionOrMethod) super.type(i);
>, <Line: -		}
>, <Line: -			if (o instanceof Invoke) {
>, <Line: -				Invoke i = (Invoke) o;
>, <Line: -				return name().equals(i.name) && super.equals(i);
>, <Line: -		public String toString() {
>, <Line: -			return "invoke " + arrayToString(targets()) + " = " + arrayToString(operands()) + " " + name + " : "
>, <Line: -					+ type(0);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public static final class Lambda extends Bytecode {
>, <Line: -		private final NameID name;
>, <Line: -		public Lambda(Type.FunctionOrMethod type, int target, int[] operands, NameID name) {
>, <Line: -			super(type, target, operands);
>, <Line: -			this.name = name;
>, <Line: -		}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_lambda;
>, <Line: -		}
>, <Line: -		public NameID name() {
>, <Line: -			return name;
>, <Line: -		}
>, <Line: -			return name.hashCode() + super.hashCode();
>, <Line: -		public Type.FunctionOrMethod type(int i) {
>, <Line: -			return (Type.FunctionOrMethod) super.type(i);
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof Lambda) {
>, <Line: -				Lambda i = (Lambda) o;
>, <Line: -				return name().equals(i.name()) && super.equals(i);
>, <Line: -			return false;
>, <Line: -		public String toString() {
>, <Line: -			return "lambda %" + target(0) + " = " + arrayToString(operands()) + " " + name + " : " + type(0);
>, <Line: -	/**
>, <Line: -	 * Represents the labelled destination of a branch or loop statement.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static class Label extends Bytecode {
>, <Line: -		private final String label;
>, <Line: -		public Label(String label) {
>, <Line: -			super(new Type[0], new int[0], new int[0]);
>, <Line: -			this.label = label;
>, <Line: -		public int opcode() {
>, <Line: -			return -1;
>, <Line: -		public String label() {
>, <Line: -			return label;
>, <Line: -		public Label relabel(Map<String, String> labels) {
>, <Line: -			String nlabel = labels.get(label);
>, <Line: -			if (nlabel == null) {
>, <Line: -				return this;
>, <Line: -			} else {
>, <Line: -				return new Label(nlabel);
>, <Line: -			}
>, <Line: -		public int hashCode() {
>, <Line: -			return label().hashCode();
>, <Line: -			if (o instanceof Label) {
>, <Line: -				return label.equals(((Label) o).label);
>, <Line: -		public String toString() {
>, <Line: -			return "." + label;
>, <Line: -	 * Represents a block of code which loops continuously until e.g. a
>, <Line: -	 * conditional branch is taken out of the block. For example:
>, <Line: -	 * function f() -> int:
>, <Line: -	 *     r = 0
>, <Line: -	 *     while r < 10:
>, <Line: -	 *         r = r + 1
>, <Line: -	 *     return r
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function f() -> int:
>, <Line: -	 * body:
>, <Line: -	 *     const %0 = 0             : int
>, <Line: -	 *     loop (%0)
>, <Line: -	 *         const %1 = 10        : int
>, <Line: -	 *         ifge %0, %1 goto blklab0 : int
>, <Line: -	 *         const %1 = 1         : int
>, <Line: -	 *         add %0 = %0, %1      : int
>, <Line: -	 * .blklab0
>, <Line: -	 *     return %0                : int
>, <Line: -	 * Here, we see a loop which increments an accumulator register
>, <Line: -	 * <code>%0</code> until it reaches <code>10</code>, and then exits the loop
>, <Line: -	 * block.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * The <i>modified operands</i> of a loop bytecode (shown in brackets
>, <Line: -	 * alongside the bytecode) indicate those operands which are modified at
>, <Line: -	 * some point within the loop.
>, <Line: -	public static class Loop extends Compound {
>, <Line: -		public Loop(int[] targets, int block, int... operands) {
>, <Line: -			super(block, new Type[0], targets, operands);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_loop;
>, <Line: -			if (o instanceof Loop) {
>, <Line: -				Loop f = (Loop) o;
>, <Line: -				return block == f.block && super.equals(f);
>, <Line: -		public int[] modifiedOperands() {
>, <Line: -			return targets();
>, <Line: -			return "loop " + arrayToString(targets()) + " = " + block;
>, <Line: -	public static final class Quantify extends Loop {
>, <Line: -		public Quantify(int startOperand, int endOperand, int indexOperand, int[] targets, int block) {
>, <Line: -			super(targets, block, startOperand, endOperand, indexOperand);
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_quantify;
>, <Line: -		public int startOperand() {
>, <Line: -			return operands[0];
>, <Line: -		public int endOperand() {
>, <Line: -			return operands[1];
>, <Line: -		public int indexOperand() {
>, <Line: -			return operands[2];
>, <Line: -			if (o instanceof Quantify) {
>, <Line: -				Quantify f = (Quantify) o;
>, <Line: -				return super.equals(f);
>, <Line: -		public String toString() {
>, <Line: -			return "quantify " + arrayToString(targets()) + " = #" + block() + arrayToString(operands());
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Represents a type which may appear on the left of an assignment
>, <Line: -	 * expression. Arrays, Records and References are the only valid types for
>, <Line: -	 * an lval.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static abstract class LVal<T> {
>, <Line: -		protected T type;
>, <Line: -		public LVal(T t) {
>, <Line: -			this.type = t;
>, <Line: -		public T rawType() {
>, <Line: -			return type;
>, <Line: -	 * An LVal with array type.
>, <Line: -	public static final class ArrayLVal extends LVal<Type.EffectiveArray> {
>, <Line: -		public final int indexOperand;
>, <Line: -		public ArrayLVal(Type.EffectiveArray t, int indexOperand) {
>, <Line: -			super(t);
>, <Line: -			this.indexOperand = indexOperand;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * An LVal with list type.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static final class ReferenceLVal extends LVal<Type.Reference> {
>, <Line: -		public ReferenceLVal(Type.Reference t) {
>, <Line: -			super(t);
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * An LVal with record type.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static final class RecordLVal extends LVal<Type.EffectiveRecord> {
>, <Line: -		public final String field;
>, <Line: -		public RecordLVal(Type.EffectiveRecord t, String field) {
>, <Line: -			super(t);
>, <Line: -			this.field = field;
>, <Line: -			if (!t.fields().containsKey(field)) {
>, <Line: -				throw new IllegalArgumentException("invalid Record Type");
>, <Line: -	}
>, <Line: -	private static final class UpdateIterator implements Iterator<LVal> {
>, <Line: -		private final ArrayList<String> fields;
>, <Line: -		private final int[] operands;
>, <Line: -		private Type iter;
>, <Line: -		private int fieldIndex;
>, <Line: -		private int operandIndex;
>, <Line: -		private int index;
>, <Line: -		public UpdateIterator(Type type, int level, int[] operands, ArrayList<String> fields) {
>, <Line: -			this.fields = fields;
>, <Line: -			this.iter = type;
>, <Line: -			this.index = level;
>, <Line: -			this.operands = operands;
>, <Line: -		public LVal next() {
>, <Line: -			Type raw = iter;
>, <Line: -			index--;
>, <Line: -			if (iter instanceof Type.Reference) {
>, <Line: -				Type.Reference ref = (Type.Reference) iter;
>, <Line: -				iter = ref.element();
>, <Line: -				return new ReferenceLVal(ref);
>, <Line: -			} else if (iter instanceof Type.EffectiveArray) {
>, <Line: -				Type.EffectiveArray list = (Type.EffectiveArray) iter;
>, <Line: -				iter = list.element();
>, <Line: -				return new ArrayLVal(list, operands[operandIndex++]);
>, <Line: -			} else if (iter instanceof Type.EffectiveRecord) {
>, <Line: -				Type.EffectiveRecord rec = (Type.EffectiveRecord) iter;
>, <Line: -				String field = fields.get(fieldIndex++);
>, <Line: -				iter = rec.fields().get(field);
>, <Line: -				return new RecordLVal(rec, field);
>, <Line: -			} else {
>, <Line: -				throw new IllegalArgumentException("Invalid type for Update: " + iter);
>, <Line: -			}
>, <Line: -		public boolean hasNext() {
>, <Line: -			return index > 0;
>, <Line: -		public void remove() {
>, <Line: -			throw new UnsupportedOperationException("UpdateIterator is unmodifiable");
>, <Line: -	 * Pops a compound structure, zero or more indices and a value from the
>, <Line: -	 * stack and updates the compound structure with the given value. Valid
>, <Line: -	 * compound structures are lists, dictionaries, strings, records and
>, <Line: -	 * references.
>, <Line: -	 * Ideally, this operation is done in-place, meaning the operation is
>, <Line: -	 * constant time. However, to support Whiley's value semantics this bytecode
>, <Line: -	 * may require (in some cases) a clone of the underlying data-structure.
>, <Line: -	 * Thus, the worst-case runtime of this operation is linear in the size of
>, <Line: -	 * the compound structure.
>, <Line: -	public static final class Update extends Bytecode implements Iterable<LVal> {
>, <Line: -		public final ArrayList<String> fields;
>, <Line: -		 * Construct an Update bytecode which assigns to a given operand to a
>, <Line: -		 * set of target registers. For indirect map/list updates, an additional
>, <Line: -		 * set of operands is used to generate the appropriate keys. For field
>, <Line: -		 * assignments, a set of fields is provided.
>, <Line: -		 * @param beforeType
>, <Line: -		 * @param target
>, <Line: -		 *            Register being assigned
>, <Line: -		 * @param operands
>, <Line: -		 *            Registers used for keys on left-hand side in map/list
>, <Line: -		 *            updates
>, <Line: -		 *            Register on right-hand side whose value is assigned
>, <Line: -		 * @param afterType
>, <Line: -		 * @param fields
>, <Line: -		 *            Fields for record updates
>, <Line: -		public Update(Type beforeType, int target, int[] operands, int operand, Type afterType,
>, <Line: -				Collection<String> fields) {
>, <Line: -			super(new Type[] { beforeType, afterType }, new int[] { target }, append(operands, operand));
>, <Line: -			if (fields == null) {
>, <Line: -				throw new IllegalArgumentException("FieldStore fields argument cannot be null");
>, <Line: -			}
>, <Line: -			this.fields = new ArrayList<String>(fields);
>, <Line: -		}
>, <Line: -		// Helper used for clone()
>, <Line: -		private Update(Type[] types, int[] targets, int[] operands, Collection<String> fields) {
>, <Line: -			super(types, targets, operands);
>, <Line: -			if (fields == null) {
>, <Line: -				throw new IllegalArgumentException("FieldStore fields argument cannot be null");
>, <Line: -			}
>, <Line: -			this.fields = new ArrayList<String>(fields);
>, <Line: -		}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_update;
>, <Line: -		 * Returns register from which assigned value is read. This is also
>, <Line: -		 * known as the "right-hand side".
>, <Line: -		public int result() {
>, <Line: -			return operands()[operands().length - 1];
>, <Line: -		 * Get the given key register (in order of appearance from the left)
>, <Line: -		 * used in a map or list update.
>, <Line: -		 * @param index
>, <Line: -		public int key(int index) {
>, <Line: -			return operands()[index];
>, <Line: -		 * Return the registers used to hold key values for map or list updates.
>, <Line: -		public int[] keys() {
>, <Line: -			return Arrays.copyOf(operands(), operands().length - 1);
>, <Line: -		}
>, <Line: -		public int level() {
>, <Line: -			int base = -1; // because last operand is rhs
>, <Line: -			if (type(0) instanceof Type.Reference) {
>, <Line: -				base++;
>, <Line: -			}
>, <Line: -			return base + fields.size() + operands().length;
>, <Line: -		public Iterator<LVal> iterator() {
>, <Line: -			return new UpdateIterator(afterType(), level(), keys(), fields);
>, <Line: -		}
>, <Line: -		public Type afterType() {
>, <Line: -			return types[1];
>, <Line: -		/**
>, <Line: -		 * Extract the type for the right-hand side of this assignment.
>, <Line: -		 *
>, <Line: -		 * @return
>, <Line: -		 */
>, <Line: -		public Type rhs() {
>, <Line: -			Type iter = afterType();
>, <Line: -			int fieldIndex = 0;
>, <Line: -			for (int i = 0; i != level(); ++i) {
>, <Line: -				if (iter instanceof Type.Reference) {
>, <Line: -					Type.Reference proc = Type.effectiveReference(iter);
>, <Line: -					iter = proc.element();
>, <Line: -				} else if (iter instanceof Type.EffectiveArray) {
>, <Line: -					Type.EffectiveArray list = (Type.EffectiveArray) iter;
>, <Line: -					iter = list.element();
>, <Line: -				} else if (iter instanceof Type.EffectiveRecord) {
>, <Line: -					Type.EffectiveRecord rec = (Type.EffectiveRecord) iter;
>, <Line: -					String field = fields.get(fieldIndex++);
>, <Line: -					iter = rec.fields().get(field);
>, <Line: -				} else {
>, <Line: -					throw new IllegalArgumentException("Invalid type for Update: " + iter);
>, <Line: -				}
>, <Line: -			}
>, <Line: -			return iter;
>, <Line: -			if (o instanceof Update) {
>, <Line: -				Update i = (Update) o;
>, <Line: -				return super.equals(o) && fields.equals(i.fields);
>, <Line: -		public String toString() {
>, <Line: -			String r = "%" + target(0);
>, <Line: -			for (LVal lv : this) {
>, <Line: -				if (lv instanceof ArrayLVal) {
>, <Line: -					ArrayLVal l = (ArrayLVal) lv;
>, <Line: -					r = r + "[%" + l.indexOperand + "]";
>, <Line: -				} else if (lv instanceof RecordLVal) {
>, <Line: -					RecordLVal l = (RecordLVal) lv;
>, <Line: -					r = r + "." + l.field;
>, <Line: -				} else {
>, <Line: -					ReferenceLVal l = (ReferenceLVal) lv;
>, <Line: -					r = "(*" + r + ")";
>, <Line: -				}
>, <Line: -			}
>, <Line: -			return "update " + r + " = %" + result() + " : " + type(0) + " -> " + afterType();
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Returns from the enclosing function or method, possibly returning a
>, <Line: -	 * value. For example, the following Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 *     return x + y
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x, int y) -> int:
>, <Line: -	 * body:
>, <Line: -	 *     assign %3 = %0    : int
>, <Line: -	 *     assign %4 = %1    : int
>, <Line: -	 *     add %2 = % 3, %4  : int
>, <Line: -	 *     return %2         : int
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * Here, the <code>return<code> bytecode returns the value of its operand
>, <Line: -	 * register.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static final class Return extends Bytecode {
>, <Line: -		public Return() {
>, <Line: -			super(new Type[0], new int[0], new int[0]);
>, <Line: -		}
>, <Line: -		public Return(Type[] types, int... operands) {
>, <Line: -			super(types, new int[0], operands);
>, <Line: -		}
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_return;
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof Return) {
>, <Line: -				return super.equals(o);
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -			String r = "return";
>, <Line: -			for (int i = 0; i != operands.length; ++i) {
>, <Line: -				if (i != 0) {
>, <Line: -					r += ",";
>, <Line: -				}
>, <Line: -				r += " %" + operands[i];
>, <Line: -			}
>, <Line: -			return r;
>, <Line: -	 * Performs a multi-way branch based on the value contained in the operand
>, <Line: -	 * register. A <i>dispatch table</i> is provided which maps individual
>, <Line: -	 * matched values to their destination labels. For example, the following
>, <Line: -	 * Whiley code:
>, <Line: -	 *
>, <Line: -	 * <pre>
>, <Line: -	 * function f(int x) -> string:
>, <Line: -	 *     switch x:
>, <Line: -	 *         case 1:
>, <Line: -	 *             return "ONE"
>, <Line: -	 *         case 2:
>, <Line: -	 *             return "TWO"
>, <Line: -	 *         default:
>, <Line: -	 *             return "OTHER"
>, <Line: -	 * </pre>
>, <Line: -	 *
>, <Line: -	 * can be translated into the following WyIL code:
>, <Line: -	 * function f(int x) -> string:
>, <Line: -	 * body:
>, <Line: -	 *     switch %0 1->blklab1, 2->blklab2, *->blklab3
>, <Line: -	 * .blklab1
>, <Line: -	 *     const %1 = "ONE" : string
>, <Line: -	 *     return %1 : string
>, <Line: -	 * .blklab2
>, <Line: -	 *     const %1 = "TWO" : string
>, <Line: -	 *     return %1 : string
>, <Line: -	 * .blklab3
>, <Line: -	 *     const %1 = "OTHER" : string
>, <Line: -	 *     return %1 : string
>, <Line: -	 * Here, we see how e.g. value <code>1</code> is mapped to the label
>, <Line: -	 * <code>blklab1</code>. Thus, if the operand register <code>%0</code>
>, <Line: -	 * contains value <code>1</code>, then control will be transferred to that
>, <Line: -	 * label. The final mapping <code>*->blklab3</code> covers the default case
>, <Line: -	 * where the value in the operand is not otherwise matched.
>, <Line: -	public static final class Switch extends Bytecode {
>, <Line: -		private final ArrayList<Pair<Constant, String>> branches;
>, <Line: -		private final String defaultTarget;
>, <Line: -		public Switch(Type type, int operand, String defaultTarget, Collection<Pair<Constant, String>> branches) {
>, <Line: -			super(new Type[] { type }, new int[0], operand);
>, <Line: -			this.branches = new ArrayList<Pair<Constant, String>>(branches);
>, <Line: -			this.defaultTarget = defaultTarget;
>, <Line: -		@Override
>, <Line: -		public int opcode() {
>, <Line: -			return OPCODE_switch;
>, <Line: -		public Switch relabel(Map<String, String> labels) {
>, <Line: -			ArrayList<Pair<Constant, String>> nbranches = new ArrayList();
>, <Line: -			for (Pair<Constant, String> p : branches()) {
>, <Line: -				String nlabel = labels.get(p.second());
>, <Line: -				if (nlabel == null) {
>, <Line: -					nbranches.add(p);
>, <Line: -				} else {
>, <Line: -					nbranches.add(new Pair(p.first(), nlabel));
>, <Line: -				}
>, <Line: -			}
>, <Line: -			String nlabel = labels.get(defaultTarget());
>, <Line: -			if (nlabel == null) {
>, <Line: -				return new Switch(types[0], operands[0], defaultTarget(), nbranches);
>, <Line: -			} else {
>, <Line: -				return new Switch(types[0], operands[0], nlabel, nbranches);
>, <Line: -			}
>, <Line: -			if (o instanceof Switch) {
>, <Line: -				Switch ig = (Switch) o;
>, <Line: -				return operands[0] == ig.operands[0] && defaultTarget().equals(ig.defaultTarget())
>, <Line: -						&& branches().equals(ig.branches()) && types[0].equals(ig.types[0]);
>, <Line: -		public String toString() {
>, <Line: -			String table = "";
>, <Line: -			boolean firstTime = true;
>, <Line: -			for (Pair<Constant, String> p : branches()) {
>, <Line: -				if (!firstTime) {
>, <Line: -					table += ", ";
>, <Line: -				}
>, <Line: -				firstTime = false;
>, <Line: -				table += p.first() + "->" + p.second();
>, <Line: -			}
>, <Line: -			table += ", *->" + defaultTarget();
>, <Line: -			return "switch %" + operands[0] + " " + table;
>, <Line: -		}
>, <Line: -		public String defaultTarget() {
>, <Line: -			return defaultTarget;
>, <Line: -		public ArrayList<Pair<Constant, String>> branches() {
>, <Line: -			return branches;
>, <Line: -	// =============================================================
>, <Line: -	// =============================================================
>, <Line: -	/**
>, <Line: -	 * Construct a mapping from labels to their block indices within a root
>, <Line: -	 * block. This is useful so they can easily be resolved during the
>, <Line: -	 * subsequent traversal of the block.
>, <Line: -	 * 
>, <Line: -	 * @param block
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public static Map<String, BytecodeForest.Index> buildLabelMap(BytecodeForest forest) {
>, <Line: -		HashMap<String, BytecodeForest.Index> labels = new HashMap<String, BytecodeForest.Index>();
>, <Line: -		for (int i = 0; i != forest.numBlocks(); ++i) {
>, <Line: -			BytecodeForest.Block block = forest.get(i);
>, <Line: -			for (int j = 0; j != block.size(); ++j) {
>, <Line: -				Bytecode code = block.get(j).code();
>, <Line: -				if (code instanceof Bytecode.Label) {
>, <Line: -					// Found a label, so register it in the labels map
>, <Line: -					Bytecode.Label label = (Bytecode.Label) code;
>, <Line: -					labels.put(label.label(), new BytecodeForest.Index(i, j));
>, <Line: -				}
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return labels;
>, <Line: -	}
>, <Line: -	private static String arrayToString(int... operands) {
>, <Line: -		String r = "(";
>, <Line: -		for (int i = 0; i != operands.length; ++i) {
>, <Line: -			if (i != 0) {
>, <Line: -				r = r + ", ";
>, <Line: -			r = r + "%" + operands[i];			
>, <Line: -		return r + ")";
>, <Line: -	}
>, <Line: -	private static int[] append(int[] operands, int operand) {
>, <Line: -		int[] noperands = Arrays.copyOf(operands, operands.length + 1);
>, <Line: -		noperands[operands.length] = operand;
>, <Line: -		return noperands;
>, <Line: -	private static int[] append(int operand, int[] operands) {
>, <Line: -		int[] noperands = new int[operands.length + 1];
>, <Line: -		System.arraycopy(operands, 0, noperands, 1, operands.length);
>, <Line: -		noperands[0] = operand;
>, <Line: -		return noperands;
>, <Line: -	}
>, <Line: -	public static final int OPCODE_goto      = 1;
>, <Line: -	public static final int OPCODE_fail      = 2;
>, <Line: -	public static final int OPCODE_assert    = 4;
>, <Line: -	public static final int OPCODE_assume    = 5;
>, <Line: -	public static final int OPCODE_invariant = 6;
>, <Line: -	public static final int UNARY_OPERATOR = 7;
>, <Line: -	public static final int OPCODE_debug    = UNARY_OPERATOR+0;
>, <Line: -	public static final int OPCODE_return   = UNARY_OPERATOR+1;
>, <Line: -	public static final int OPCODE_ifis     = UNARY_OPERATOR+2;
>, <Line: -	public static final int OPCODE_switch   = UNARY_OPERATOR+3;
>, <Line: -	public static final int UNARY_ASSIGNABLE = UNARY_OPERATOR+5;
>, <Line: -	public static final int OPCODE_fieldload   = UNARY_ASSIGNABLE+8;
>, <Line: -	public static final int OPCODE_convert     = UNARY_ASSIGNABLE+9;
>, <Line: -	public static final int OPCODE_const       = UNARY_ASSIGNABLE+10;
>, <Line: -	public static final int BINARY_OPERATOR = UNARY_ASSIGNABLE+11;
>, <Line: -	public static final int OPCODE_if         = BINARY_OPERATOR+0;
>, <Line: -	public static final int BINARY_ASSIGNABLE = BINARY_OPERATOR+6;
>, <Line: -	public static final int OPCODE_neg         = BINARY_ASSIGNABLE+0;
>, <Line: -	public static final int OPCODE_not         = BINARY_ASSIGNABLE+1;
>, <Line: -	public static final int OPCODE_arrayinvert = BINARY_ASSIGNABLE+2;	
>, <Line: -	public static final int OPCODE_dereference = BINARY_ASSIGNABLE+3;
>, <Line: -	public static final int OPCODE_arraylength = BINARY_ASSIGNABLE+4;	
>, <Line: -	public static final int OPCODE_add         = BINARY_ASSIGNABLE+5;
>, <Line: -	public static final int OPCODE_sub         = BINARY_ASSIGNABLE+6;
>, <Line: -	public static final int OPCODE_mul         = BINARY_ASSIGNABLE+7;
>, <Line: -	public static final int OPCODE_div         = BINARY_ASSIGNABLE+8;
>, <Line: -	public static final int OPCODE_rem         = BINARY_ASSIGNABLE+9;
>, <Line: -	public static final int OPCODE_eq          = BINARY_ASSIGNABLE+10;
>, <Line: -	public static final int OPCODE_ne          = BINARY_ASSIGNABLE+11;
>, <Line: -	public static final int OPCODE_lt          = BINARY_ASSIGNABLE+12;
>, <Line: -	public static final int OPCODE_le          = BINARY_ASSIGNABLE+13;
>, <Line: -	public static final int OPCODE_gt          = BINARY_ASSIGNABLE+14;
>, <Line: -	public static final int OPCODE_ge          = BINARY_ASSIGNABLE+15;
>, <Line: -	public static final int OPCODE_bitwiseor   = BINARY_ASSIGNABLE+16;
>, <Line: -	public static final int OPCODE_bitwisexor  = BINARY_ASSIGNABLE+17;
>, <Line: -	public static final int OPCODE_bitwiseand  = BINARY_ASSIGNABLE+18;
>, <Line: -	public static final int OPCODE_lshr        = BINARY_ASSIGNABLE+19;
>, <Line: -	public static final int OPCODE_rshr        = BINARY_ASSIGNABLE+20;
>, <Line: -	public static final int OPCODE_arrayindex  = BINARY_ASSIGNABLE+21;	
>, <Line: -	public static final int OPCODE_arrygen     = BINARY_ASSIGNABLE+22;
>, <Line: -	public static final int OPCODE_array       = BINARY_ASSIGNABLE+23;
>, <Line: -	public static final int OPCODE_record      = BINARY_ASSIGNABLE+24;
>, <Line: -	public static final int OPCODE_newobject   = BINARY_ASSIGNABLE+25;
>, <Line: -	public static final int OPCODE_assign      = BINARY_ASSIGNABLE+26;
>, <Line: -	public static final int NARY_ASSIGNABLE = BINARY_ASSIGNABLE+26;
>, <Line: -	public static final int OPCODE_invoke           = NARY_ASSIGNABLE+2;
>, <Line: -	public static final int OPCODE_indirectinvoke   = NARY_ASSIGNABLE+3;
>, <Line: -	public static final int OPCODE_lambda           = NARY_ASSIGNABLE+4;
>, <Line: -	public static final int OPCODE_loop             = NARY_ASSIGNABLE+5;	
>, <Line: -	public static final int OPCODE_quantify         = NARY_ASSIGNABLE+6;
>, <Line: -	public static final int OPCODE_update           = NARY_ASSIGNABLE+7;	
>, <Line: -	public enum Targets {
>, <Line: -	public enum Operands {
>, <Line: -	public enum Types {
>, <Line: -		TARGET, // branch target
>, <Line: -		BLOCK, // block index
>, <Line: -		private final Targets targets;
>, <Line: -		private final Types types;
>, <Line: -		public Schema(Targets targets, Operands operands, Types types, Extras... extras) {
>, <Line: -			this.targets = targets;
>, <Line: -			this.types = types;
>, <Line: -		public abstract Bytecode construct(int opcode, int[] targets, int[] operands, Type[] types, Object[] extras);
>, <Line: -			return "<" + targets.toString() + " targets, " + operands + " operands, " + types + " types, " + Arrays.toString(extras) + ">";
>]