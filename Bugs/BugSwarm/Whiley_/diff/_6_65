[<Line: +import wycc.lang.Attribute;
>, <Line: +import wycc.lang.SyntaxError.InternalFailure;
>, <Line: +import wycc.util.Triple;
>, <Line: +import wyil.lang.SyntaxTree.Location;
>, <Line: +import wyil.lang.Bytecode.Operator;
>, <Line: +import wyil.lang.Bytecode.VariableDeclaration;
>, <Line: +import wyil.util.TypeSystem;
>, <Line: +import static wyjc.Wyil2JavaBuilder.WHILEYBOOL;
>, <Line: +import static wyjc.Wyil2JavaBuilder.WHILEYTYPE;
>, <Line: +import wyjc.util.LambdaTemplate;
>, <Line: +import static jasm.lang.Modifier.*;
>, <Line: +	 * The type system is useful for managing nominal types and converting them
>, <Line: +	 * into their underlying types.
>, <Line: +	protected final TypeSystem typeSystem;
>, <Line: +	private ArrayList<ClassFile> lambdaClasses;
>, <Line: +	/**
>, <Line: +	 * List of temporary methods created to implement lambda expressions
>, <Line: +	 */
>, <Line: +	private ArrayList<ClassFile.Method> lambdaMethods;
>, <Line: +		this.typeSystem = new TypeSystem(project);
>, <Line: +	public Set<Path.Entry<?>> build(Collection<Pair<Path.Entry<?>, Path.Root>> delta) throws IOException {
>, <Line: +			Path.Entry<ClassFile> df = dst.create(sf.id(), WyjcBuildTask.ContentType);
>, <Line: +			// FIXME: put these in the context?
>, <Line: +			lambdaClasses = new ArrayList<ClassFile>();
>, <Line: +			lambdaMethods = new ArrayList<ClassFile.Method>();
>, <Line: +			ClassFile contents = build(sf.read());
>, <Line: +			contents.methods().addAll(lambdaMethods);
>, <Line: +			//new ClassFileVerifier().apply(contents);
>, <Line: +			// Finally, write out any lambda classes + methods created to
>, <Line: +			// support the main class. This is necessary because every
>, <Line: +			// occurrence of a lambda expression in the WyilFile generates an
>, <Line: +			// inner class responsible for calling the given function.
>, <Line: +			for (int i = 0; i != lambdaClasses.size(); ++i) {
>, <Line: +				Path.Entry<ClassFile> lf = dst.create(id, WyjcBuildTask.ContentType);
>, <Line: +				ClassFile lc = lambdaClasses.get(i);
>, <Line: +				// Verify generated class file
>, <Line: +				new ClassFileVerifier().apply(lc);
>, <Line: +				lf.write(lc);
>, <Line: +		logger.logTimedMessage("Wyil => Java: compiled " + delta.size() + " file(s)", endTime - start,
>, <Line: +				memory - runtime.freeMemory());
>, <Line: +		owner = new JvmType.Clazz(module.id().parent().toString().replace('.', '/'), module.id().last());
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);
>, <Line: +		ClassFile cf = new ClassFile(CLASS_VERSION, owner, JAVA_LANG_OBJECT, new ArrayList<JvmType.Clazz>(), modifiers);
>, <Line: +		buildConstants(constants, lambdaClasses, cf);
>, <Line: +	private void buildConstants(HashMap<JvmConstant, Integer> constants, ArrayList<ClassFile> lambdas, ClassFile cf) {
>, <Line: +	private void buildValues(HashMap<JvmConstant, Integer> constants, ArrayList<ClassFile> lambdas, ClassFile cf) {
>, <Line: +		Context context = new Context();
>, <Line: +				List<Modifier> fmods = modifiers(ACC_PRIVATE, ACC_STATIC, ACC_FINAL);
>, <Line: +				JvmType type = toJvmType(constant.type());
>, <Line: +				translateConstant(constant, context);
>, <Line: +				context.add(new Bytecode.PutField(owner, name, type, Bytecode.FieldMode.STATIC));
>, <Line: +			context.add(new Bytecode.Return(null));
>, <Line: +			List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC);
>, <Line: +			ClassFile.Method clinit = new ClassFile.Method("<clinit>", ftype, modifiers);
>, <Line: +			jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), Collections.EMPTY_LIST, clinit);
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_SYNTHETIC, ACC_STATIC);
>, <Line: +		JvmType.Function ft1 = new JvmType.Function(T_VOID, new JvmType.Array(JAVA_LANG_STRING));
>, <Line: +		ft1 = new JvmType.Function(WHILEYRECORD, new JvmType.Array(JAVA_LANG_STRING));
>, <Line: +		codes.add(new Bytecode.Invoke(WHILEYUTIL, "systemConsole", ft1, Bytecode.InvokeMode.STATIC));
>, <Line: +		Type.Method wyft = Type.Method(new Type[0], Collections.<String> emptySet(), Collections.<String> emptyList(),
>, <Line: +				WHILEY_SYSTEM_T);
>, <Line: +		codes.add(new Bytecode.Invoke(owner, nameMangle("main", wyft), ft3, Bytecode.InvokeMode.STATIC));
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(codes, new ArrayList(), cm);
>, <Line: +		List<Location<Expr>> td_invariants = td.getInvariant();
>, <Line: +		//
>, <Line: +		JvmType underlyingType = toJvmType(td.type());
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC);
>, <Line: +		ClassFile.Method cm = new ClassFile.Method(td.name() + "$typeof", funType, modifiers);
>, <Line: +		// Generate code for testing implicit invariants of type (if any). That
>, <Line: +		// is, invariants implied by (nominal) component types.
>, <Line: +		Context context = new Context();
>, <Line: +		String falseLabel = freshLabel();
>, <Line: +		translateInvariantTest(falseLabel, td.type(), 0, 1, context);
>, <Line: +		// Generate code for testing explicit invariants of type (if any). To do
>, <Line: +		// this, we chain them together into a sequence of checks.
>, <Line: +		for (int i = 0; i != td_invariants.size(); ++i) {
>, <Line: +			translateExpression(td_invariants.get(i), context);
>, <Line: +			JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +		}			
>, <Line: +		// If we reach this point, then invariants must hold.
>, <Line: +		context.add(new Bytecode.LoadConst(true));
>, <Line: +		context.add(new Bytecode.Return(new JvmType.Bool()));
>, <Line: +		// Add the false label (in case it was used)
>, <Line: +		context.add(new Bytecode.Label(falseLabel));
>, <Line: +		context.add(new Bytecode.LoadConst(false));
>, <Line: +		context.add(new Bytecode.Return(new JvmType.Bool()));
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), new ArrayList(), cm);
>, <Line: +	/**
>, <Line: +	 * Construct a trampoline for handling native or export methods. In the
>, <Line: +	 * context of native methods, this generates a method which redirects to a
>, <Line: +	 * method which has the same name, but with "$native" appended on the end.
>, <Line: +	 * This method is implemented elsewhere and must be provided by the author
>, <Line: +	 * of this module. For export methods, this means providing a method without
>, <Line: +	 * name mangling which redirects to the method with name mangling.
>, <Line: +	 * 
>, <Line: +	 * @param method
>, <Line: +	 * @param constants
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +		// Preliminaries
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_STATIC,
>, <Line: +				method.hasModifier(wyil.lang.Modifier.PUBLIC) ? ACC_PUBLIC : null);
>, <Line: +		// Apply name mangling (if applicable)
>, <Line: +		// Construct method body
>, <Line: +		ArrayList<Bytecode> codes = translateNativeOrExport(method);
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(codes, Collections.EMPTY_LIST, cm);
>, <Line: +		// Done
>, <Line: +	/**
>, <Line: +	 * Construct the body a "trampoline" method for handling native and export
>, <Line: +	 * methods.
>, <Line: +	 * 
>, <Line: +	 * @param method
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private ArrayList<Bytecode> translateNativeOrExport(WyilFile.FunctionOrMethod method) {
>, <Line: +		// Load all parameters provided to this method ontot he stack
>, <Line: +			bytecodes.add(new Bytecode.Load(slot++, toJvmType(param)));
>, <Line: +		// Determine the target class and method for the invocation
>, <Line: +		JvmType.Clazz targetClass;
>, <Line: +		String targetMethod;
>, <Line: +			targetClass = new JvmType.Clazz(owner.pkg(), owner.components().get(0).first(), "native");
>, <Line: +			targetMethod = method.name();
>, <Line: +			targetClass = new JvmType.Clazz(owner.pkg(), owner.components().get(0).first());
>, <Line: +			targetMethod = nameMangle(method.name(), method.type());
>, <Line: +		// Perform the invocation itself which constitutes the "trampoline"
>, <Line: +		bytecodes.add(new Bytecode.Invoke(targetClass, targetMethod, convertFunType(ft), Bytecode.InvokeMode.STATIC));
>, <Line: +		// Finally, return any values obtained from the invocation as necessary
>, <Line: +		JvmType returnType = null;
>, <Line: +		if (!ft.returns().isEmpty()) {
>, <Line: +			returnType = toJvmType(ft.returns().get(0));
>, <Line: +		bytecodes.add(new Bytecode.Return(returnType));
>, <Line: +		// Done
>, <Line: +	/**
>, <Line: +	 * Translate a given method or function. This generates a corresponding
>, <Line: +	 * function or method on the JVM which has the same name, plus a type
>, <Line: +	 * mangle.
>, <Line: +	 * 
>, <Line: +	 * @param method
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +		// Preliminaries
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_STATIC,
>, <Line: +				method.hasModifier(wyil.lang.Modifier.PUBLIC) ? ACC_PUBLIC : null);
>, <Line: +		// Construct the method itself
>, <Line: +		// Translate the method body
>, <Line: +		Context context = new Context();		
>, <Line: +		translateBlock(method.getBody(),context);
>, <Line: +		// Add return bytecode (if necessary)
>, <Line: +		addReturnBytecode(context);
>, <Line: +		//
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), Collections.EMPTY_LIST, cm);
>, <Line: +		// Done
>, <Line: +	 * Every JVM method must be terminated by a return bytecode. This method
>, <Line: +	 * simply adds one if none was already generated.
>, <Line: +	 * @param context
>, <Line: +	private void addReturnBytecode(Context context) {
>, <Line: +		List<Bytecode> bytecodes = context.getBytecodes();
>, <Line: +		if (bytecodes.size() > 0) {
>, <Line: +			Bytecode last = bytecodes.get(bytecodes.size() - 1);
>, <Line: +			if (last instanceof Bytecode.Return) {
>, <Line: +				// No return bytecode is needed
>, <Line: +				return;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// A return bytecode is needed
>, <Line: +		bytecodes.add(new Bytecode.Return(null));
>, <Line: +	// ===============================================================================
>, <Line: +	// Statements & Blocks
>, <Line: +	// ===============================================================================
>, <Line: +	private void translateBlock(SyntaxTree.Location<Block> block, Context context) {
>, <Line: +		for(int i=0;i!=block.numberOfOperands();++i) {
>, <Line: +			translateStatement(block.getOperand(i), context);
>, <Line: +	private void translateStatement(Location<?> stmt, Context context) {
>, <Line: +			switch (stmt.getOpcode()) {
>, <Line: +			case OPCODE_assert:
>, <Line: +			case OPCODE_assume:
>, <Line: +				translateAssertOrAssume((Location<AssertOrAssume>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_assign:
>, <Line: +				translateAssign((Location<Assign>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_break:
>, <Line: +				translateBreak((Location<Break>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_continue:
>, <Line: +				translateContinue((Location<Continue>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_debug:
>, <Line: +				translateDebug((Location<Debug>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_dowhile:
>, <Line: +				translateDoWhile((Location<DoWhile>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_fail:
>, <Line: +				translateFail((Location<Fail>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_if:
>, <Line: +			case OPCODE_ifelse:
>, <Line: +				translateIf((Location<If>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_invoke:
>, <Line: +			case OPCODE_indirectinvoke:
>, <Line: +				translateInvokeAsStmt(stmt,context);
>, <Line: +				break;
>, <Line: +			case OPCODE_namedblock:
>, <Line: +				translateNamedBlock((Location<NamedBlock>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_while:
>, <Line: +				translateWhile((Location<While>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_return:
>, <Line: +				translateReturn((Location<Return>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_skip:
>, <Line: +				translateSkip((Location<Skip>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_switch:
>, <Line: +				translateSwitch((Location<Switch>) stmt, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_vardecl:
>, <Line: +			case OPCODE_vardeclinit:
>, <Line: +				translateVariableDeclaration((Location<VariableDeclaration>) stmt, context);
>, <Line: +				break;	
>, <Line: +			default:
>, <Line: +				internalFailure("unknown bytecode encountered (" + stmt + ")", filename,
>, <Line: +						stmt.attribute(Attribute.Source.class));
>, <Line: +		} catch (InternalFailure ex) {
>, <Line: +			throw ex;
>, <Line: +			internalFailure(ex.getMessage(), filename, ex, stmt.attribute(Attribute.Source.class));
>, <Line: +	private void translateAssertOrAssume(Location<AssertOrAssume> c, Context context) {
>, <Line: +		String trueLabel = freshLabel();
>, <Line: +		translateCondition(c.getOperand(0), trueLabel, null, context);
>, <Line: +		context.construct(JAVA_LANG_RUNTIMEEXCEPTION);
>, <Line: +		context.add(new Bytecode.Throw());
>, <Line: +		context.add(new Bytecode.Label(trueLabel));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assignment statement.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	private void translateAssign(Location<Assign> code, Context context) {
>, <Line: +		Location<?>[] lhs = code.getOperandGroup(0);
>, <Line: +		Location<?>[] rhs = code.getOperandGroup(1);
>, <Line: +		// Translate and construct the lvals for this assignment. This
>, <Line: +		// will store all lval operands (e.g. array indices) into their
>, <Line: +		// corresponding operand register. To preserve the semantics of Whiley,
>, <Line: +		// we must translate the lhs before the rhs.
>, <Line: +		LVal[] lvals = translateLVals(lhs, context);
>, <Line: +		// Translate the operands in reverse order onto the stack, produce a
>, <Line: +		// type for each operand produced. The number of types may be larger
>, <Line: +		// than the number of rhs opeands in the case of an operand with
>, <Line: +		// multiple return values.
>, <Line: +		List<JvmType> types = translateExpressions(rhs, context);
>, <Line: +		// Now, store each operand into the slot location so that we can more
>, <Line: +		// easily access it later. This basically relies on an assumption that
>, <Line: +		// translateSimpleAssign() does not use any free registers during its
>, <Line: +		// translation.
>, <Line: +		int freeRegister = getFirstFreeRegister(code.getEnclosingTree());
>, <Line: +		for (int i = types.size() - 1; i >= 0; i = i - 1) {
>, <Line: +			context.add(new Bytecode.Store(freeRegister+i, types.get(i)));
>, <Line: +		}
>, <Line: +		// Assign each operand to the target lval.
>, <Line: +		int i = 0;
>, <Line: +		for (; i != lhs.length; ++i) {
>, <Line: +			translateSimpleAssign(lvals[i], freeRegister+i, types.get(i), context);
>, <Line: +		}
>, <Line: +		// Finally, pop any remaining operands off the stack. This can happen if
>, <Line: +		// values are being discarded.
>, <Line: +		for (; i < types.size(); ++i) {
>, <Line: +			context.add(new Bytecode.Pop(types.get(i)));
>, <Line: +	/**
>, <Line: +	 * Translate a simple assignment statement. This is one which is assigning a
>, <Line: +	 * single value into an lval, which could be either a variable, a field
>, <Line: +	 * assignment, an array element assignment or a dereference assignment. The
>, <Line: +	 * assigned value is assumed to have already been loaded on the stack.
>, <Line: +	 * 
>, <Line: +	 * @param lhs
>, <Line: +	 * @param rhsType
>, <Line: +	 */
>, <Line: +	private void translateSimpleAssign(LVal lhs, int rhs, JvmType type, Context context) {
>, <Line: +		if (lhs.path.size() > 0) {
>, <Line: +			// This is the complex case of an assignment to an element of a
>, <Line: +			// compound.
>, <Line: +			context.add(new Bytecode.Load(lhs.variable, type));
>, <Line: +			translateUpdate(lhs.path.iterator(), rhs, context);
>, <Line: +			context.add(new Bytecode.Store(lhs.variable, type));
>, <Line: +			// This is the simple case of a direct assignment to a single
>, <Line: +			// variable.
>, <Line: +			context.add(new Bytecode.Load(rhs, type));
>, <Line: +			context.add(new Bytecode.Store(lhs.variable, type));
>, <Line: +	 * @param context
>, <Line: +	private void translateUpdate(Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
>, <Line: +		LVal.Element<?> lv = iterator.next();
>, <Line: +		if (lv instanceof LVal.Array) {
>, <Line: +			translateUpdate((LVal.Array) lv, iterator, rhs, context);
>, <Line: +		} else if (lv instanceof LVal.Record) {
>, <Line: +			translateUpdate((LVal.Record) lv, iterator, rhs, context);
>, <Line: +			translateUpdate((LVal.Reference) lv, iterator, rhs, context);
>, <Line: +	private void translateUpdate(LVal.Array lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
>, <Line: +		if (iterator.hasNext()) {
>, <Line: +			context.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: +			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYARRAY, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
>, <Line: +			context.addReadConversion(lval.type.element());
>, <Line: +			translateUpdate(iterator, rhs, context);
>, <Line: +			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
>, <Line: +			context.add(new Bytecode.Swap());
>, <Line: +			Type type = lval.type.element();
>, <Line: +			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
>, <Line: +			context.add(new Bytecode.Load(rhs, toJvmType(type)));
>, <Line: +			context.addWriteConversion(type);
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYARRAY, "set", setFunType, Bytecode.InvokeMode.STATIC));
>, <Line: +	private void translateUpdate(LVal.Record lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
>, <Line: +		Type.EffectiveRecord type = lval.type;
>, <Line: +		if (iterator.hasNext()) {
>, <Line: +			context.add(new Bytecode.Dup(WHILEYRECORD));
>, <Line: +			context.add(new Bytecode.LoadConst(lval.field));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYRECORD, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
>, <Line: +			context.addReadConversion(type.field(lval.field));
>, <Line: +			translateUpdate(iterator, rhs, context);
>, <Line: +			context.add(new Bytecode.LoadConst(lval.field));
>, <Line: +			context.add(new Bytecode.Swap());
>, <Line: +			context.add(new Bytecode.LoadConst(lval.field));
>, <Line: +			context.add(new Bytecode.Load(rhs, toJvmType(type.field(lval.field))));
>, <Line: +			context.addWriteConversion(type.field(lval.field));
>, <Line: +		JvmType.Function putFunType = new JvmType.Function(WHILEYRECORD, WHILEYRECORD, JAVA_LANG_STRING,
>, <Line: +				JAVA_LANG_OBJECT);
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYRECORD, "put", putFunType, Bytecode.InvokeMode.STATIC));
>, <Line: +	private void translateUpdate(LVal.Reference lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
>, <Line: +		if (iterator.hasNext()) {
>, <Line: +			context.add(new Bytecode.Dup(WHILEYOBJECT));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYOBJECT, "state", getFunType, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.addReadConversion(lval.type.element());
>, <Line: +			translateUpdate(iterator, rhs, context);
>, <Line: +			JvmType rhsJvmType = toJvmType(lval.type.element());
>, <Line: +			context.add(new Bytecode.Load(rhs, rhsJvmType));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYOBJECT, "setState", setFunType, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +	private void translateBreak(Location<Break> c, Context context) {
>, <Line: +		context.add(new Bytecode.Goto(context.getBreakLabel()));
>, <Line: +	private void translateContinue(Location<Continue> c, Context context) {
>, <Line: +		context.add(new Bytecode.Goto(context.getContinueLabel()));
>, <Line: +	}
>, <Line: +	private void translateDebug(Location<Debug> c, Context context) {
>, <Line: +		JvmType.Function ftype = new JvmType.Function(T_VOID, WHILEYARRAY);
>, <Line: +		translateExpression(c.getOperand(0), context);
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYUTIL, "print", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +	}
>, <Line: +	private void translateDoWhile(Location<DoWhile> c, Context context) {
>, <Line: +		// Allocate header label for loop
>, <Line: +		String headerLabel = freshLabel();
>, <Line: +		String breakLabel = freshLabel();
>, <Line: +		context.add(new Bytecode.Label(headerLabel));
>, <Line: +		// Translate body of loop.
>, <Line: +		translateBlock(c.getBlock(0),context.newLoopBlock(breakLabel, headerLabel));
>, <Line: +		// Translate the loop condition.
>, <Line: +		translateCondition(c.getOperand(0), headerLabel, null, context);
>, <Line: +		context.add(new Bytecode.Label(breakLabel));
>, <Line: +	}
>, <Line: +	private void translateFail(Location<Fail> c, Context context) {
>, <Line: +		context.add(new Bytecode.New(JAVA_LANG_RUNTIMEEXCEPTION));
>, <Line: +		context.add(new Bytecode.Dup(JAVA_LANG_RUNTIMEEXCEPTION));
>, <Line: +		context.add(new Bytecode.LoadConst("runtime fault encountered"));
>, <Line: +		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_STRING);
>, <Line: +		context.add(new Bytecode.Invoke(JAVA_LANG_RUNTIMEEXCEPTION, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: +		context.add(new Bytecode.Throw());
>, <Line: +	}
>, <Line: +	private void translateIf(Location<If> code, Context context) {
>, <Line: +		If bytecode = code.getBytecode();
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		String falseLabel = bytecode.hasFalseBranch() ? freshLabel() : exitLabel;
>, <Line: +		// First, translate the condition
>, <Line: +		translateCondition(code.getOperand(0), null, falseLabel, context);
>, <Line: +		// Second, translate the true branch
>, <Line: +		translateBlock(code.getBlock(SyntaxTree.TRUEBRANCH), context);
>, <Line: +		if (bytecode.hasFalseBranch()) {
>, <Line: +			// Third, translate false branch (if applicable)
>, <Line: +			context.add(new Bytecode.Goto(exitLabel));
>, <Line: +			context.add(new Bytecode.Label(falseLabel));
>, <Line: +			translateBlock(code.getBlock(SyntaxTree.FALSEBRANCH), context);
>, <Line: +			context.add(new Bytecode.Label(exitLabel));
>, <Line: +			context.add(new Bytecode.Label(falseLabel));
>, <Line: +	private void translateReturn(Location<Return> c, Context context) {
>, <Line: +		Location<?>[] operands = c.getOperands();
>, <Line: +		JvmType rt;
>, <Line: +		switch (operands.length) {
>, <Line: +		case 0:
>, <Line: +			// No return value.
>, <Line: +			rt = null;
>, <Line: +			break;
>, <Line: +		case 1:
>, <Line: +			// Exactly one return value, so we can (potentially) return it
>, <Line: +			// directly.
>, <Line: +			Location<?> operand = operands[0];
>, <Line: +			if(operand.numberOfTypes() == 1) {
>, <Line: +				// Yes, we can return directly.
>, <Line: +				translateExpression(operand, context);
>, <Line: +				// Determine return type
>, <Line: +				rt = toJvmType(operand.getType());
>, <Line: +				break;
>, <Line: +		default:
>, <Line: +			// More than one return value. In this case, we need to encode the
>, <Line: +			// return values into an object array. This is annoying, but it's
>, <Line: +			// because Java doesn't support multiple return values.
>, <Line: +			int freeRegister = getFirstFreeRegister(c.getEnclosingTree());
>, <Line: +			translateExpressionsToArray(operands, freeRegister, context);
>, <Line: +			rt = JAVA_LANG_OBJECT_ARRAY;			
>, <Line: +		// Done
>, <Line: +		context.add(new Bytecode.Return(rt));
>, <Line: +	private void translateSkip(Location<Skip> code, Context context) {
>, <Line: +		context.add(new Bytecode.Nop()); // easy
>, <Line: +	private void translateSwitch(Location<Switch> code, Context context) {
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		Location<?> condition = code.getOperand(0);
>, <Line: +		JvmType type = toJvmType(condition.getType());
>, <Line: +		// Translate condition into a value and store into a temporary register.
>, <Line: +		// This is necessary because, according to the semantics of Whiley, we
>, <Line: +		// can only execute the condition expression once.
>, <Line: +		translateExpression(condition, context);
>, <Line: +		context.add(new Bytecode.Store(condition.getIndex(), type));
>, <Line: +		ArrayList<String> labels = new ArrayList<String>();
>, <Line: +		// Generate the dispatch table which checks the condition value against
>, <Line: +		// each of the case constants. If a match is found, we branch to a given
>, <Line: +		// label demarking the start of the case body (which will be translated
>, <Line: +		// later). In principle, using a tableswitch bytecode would be better
>, <Line: +		// here.
>, <Line: +		boolean hasDefault = false;
>, <Line: +		Case[] cases = code.getBytecode().cases();
>, <Line: +		for (int i = 0; i != code.numberOfBlocks(); ++i) {
>, <Line: +			Constant[] values = cases[i].values();
>, <Line: +			String caseLabel = freshLabel();
>, <Line: +			if (values.length == 0) {
>, <Line: +				// In this case, we have a default target which corresponds to
>, <Line: +				// an unconditional branch
>, <Line: +				context.add(new Bytecode.Goto(caseLabel));
>, <Line: +				hasDefault = true;
>, <Line: +			} else {
>, <Line: +				for (Constant value : values) {
>, <Line: +					translateConstant(value, context);
>, <Line: +					context.add(new Bytecode.Load(condition.getIndex(), type));
>, <Line: +					JvmType.Function ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
>, <Line: +					context.add(new Bytecode.Invoke(WHILEYUTIL, "equals", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +					context.add(new Bytecode.If(Bytecode.IfMode.NE, caseLabel));
>, <Line: +			labels.add(caseLabel);
>, <Line: +		// If there was no default case, then add an unconditional branch over
>, <Line: +		// the case bodies to the end of the switch.
>, <Line: +		if (!hasDefault) {
>, <Line: +			context.add(new Bytecode.Goto(exitLabel));
>, <Line: +		// Translate each of the case bodies in turn.
>, <Line: +		for (int i = 0; i != cases.length; ++i) {
>, <Line: +			context.add(new Bytecode.Label(labels.get(i)));
>, <Line: +			translateBlock(code.getBlock(i), context);
>, <Line: +			context.add(new Bytecode.Goto(exitLabel));
>, <Line: +		// Finally, mark out the exit point of the switch
>, <Line: +		context.add(new Bytecode.Label(exitLabel));
>, <Line: +	private void translateNamedBlock(Location<NamedBlock> c, Context context) {
>, <Line: +		translateBlock(c.getBlock(0),context);
>, <Line: +	}
>, <Line: +	private void translateWhile(Location<While> c, Context context) {
>, <Line: +		// Allocate header label for loop
>, <Line: +		String headerLabel = freshLabel();
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		context.add(new Bytecode.Label(headerLabel));
>, <Line: +		// Translate the loop condition.
>, <Line: +		translateCondition(c.getOperand(0), null, exitLabel, context);
>, <Line: +		// Translate body of loop.
>, <Line: +		translateBlock(c.getBlock(0),context.newLoopBlock(exitLabel, headerLabel));
>, <Line: +		// Terminate loop by branching back to head of loop
>, <Line: +		context.add(new Bytecode.Goto(headerLabel));
>, <Line: +		// This is where we exit the loop
>, <Line: +		context.add(new Bytecode.Label(exitLabel));
>, <Line: +	}
>, <Line: +	private void translateInvokeAsStmt(Location<?> stmt, Context context) {
>, <Line: +		// First, translate the invocation
>, <Line: +		List<Type> returns;		
>, <Line: +		if(stmt.getOpcode() == OPCODE_invoke) {
>, <Line: +			Location<Invoke> e = (Location<Invoke>) stmt; 			
>, <Line: +			translateInvoke(e, context);
>, <Line: +			returns = e.getBytecode().type().returns();
>, <Line: +			Location<IndirectInvoke> e = (Location<IndirectInvoke>) stmt;
>, <Line: +			translateIndirectInvoke(e, context);
>, <Line: +			returns = e.getBytecode().type().returns();
>, <Line: +		}		
>, <Line: +		// Second, if there are results, pop them off the stack		
>, <Line: +		for(int i=0;i!=returns.size();++i) {
>, <Line: +			JvmType returnType = context.toJvmType(returns.get(i));
>, <Line: +			context.add(new Bytecode.Pop(returnType));
>, <Line: +	private void translateVariableDeclaration(Location<VariableDeclaration> code, Context context) {
>, <Line: +		if(code.numberOfOperands() > 0) {
>, <Line: +			JvmType type = context.toJvmType(code.getType());
>, <Line: +			translateExpression(code.getOperand(0),context);
>, <Line: +			context.add(new Bytecode.Store(code.getIndex(),type));
>, <Line: +	// ===============================================================================
>, <Line: +	// LVals
>, <Line: +	// ===============================================================================
>, <Line: +	/**
>, <Line: +	 * Construct an array of LVals, one for each operand on the left-hand side
>, <Line: +	 * of an assignment. Each LVal provides a simple "path" representation of
>, <Line: +	 * the left-hand side with which we can more easily generate code for
>, <Line: +	 * implement the update.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            LVal operand to translate
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public LVal[] translateLVals(Location<?>[] lvals, Context context) {
>, <Line: +		LVal[] vals = new LVal[lvals.length];
>, <Line: +		for (int i = 0; i != vals.length; ++i) {
>, <Line: +			LVal lval = generateLVal(lvals[i], context);
>, <Line: +			translateLVal(lval, context);
>, <Line: +			vals[i] = lval;
>, <Line: +		}
>, <Line: +		return vals;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * Translate any operands for an LVal expression in left-to-right order.
>, <Line: +	 * This only applies to array lvals, as these have operands which need to be
>, <Line: +	 * evaluated.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * <b>NOTE:</b> For simplicity, we just load any lval operands into their
>, <Line: +	 * corresponding bytecode registers.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	public void translateLVal(LVal lval, Context context) {
>, <Line: +		for (LVal.Element<?> e : lval.path) {
>, <Line: +			if (e instanceof LVal.Array) {
>, <Line: +				LVal.Array ae = (LVal.Array) e;
>, <Line: +				translateExpression(ae.index, context);
>, <Line: +				context.add(new Bytecode.Store(ae.index.getIndex(), WHILEYINT));
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate an LVal expression from the left-hand side of an assignment. An
>, <Line: +	 * LVal expression is basically just a path representation of the lhs
>, <Line: +	 * expression.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            LVal operand to translate
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public LVal generateLVal(Location<?> lval, Context context) {
>, <Line: +		ArrayList<LVal.Element<?>> path = new ArrayList<LVal.Element<?>>();
>, <Line: +		while (lval.getOpcode() != OPCODE_varaccess) {
>, <Line: +			try {
>, <Line: +				wyil.lang.Bytecode.Expr code = (wyil.lang.Bytecode.Expr) lval.getBytecode();
>, <Line: +				switch (code.getOpcode()) {
>, <Line: +				case OPCODE_fieldload:
>, <Line: +					lval = lval.getOperand(0);
>, <Line: +					Type.EffectiveRecord recType = typeSystem.expandAsEffectiveRecord(lval.getType());
>, <Line: +					wyil.lang.Bytecode.FieldLoad fl = (wyil.lang.Bytecode.FieldLoad) code;
>, <Line: +					path.add(new LVal.Record(recType, fl.fieldName()));
>, <Line: +					break;
>, <Line: +				case OPCODE_arrayindex:
>, <Line: +					Location<?> index = lval.getOperand(1);
>, <Line: +					lval = lval.getOperand(0);
>, <Line: +					Type.EffectiveArray arrayType = typeSystem.expandAsEffectiveArray(lval.getType());
>, <Line: +					path.add(new LVal.Array(arrayType, index));
>, <Line: +					break;
>, <Line: +				case OPCODE_dereference:
>, <Line: +					lval = lval.getOperand(0);
>, <Line: +					Type.Reference refType = typeSystem.expandAsReference(lval.getType());
>, <Line: +					path.add(new LVal.Reference(refType));
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					internalFailure("unknown bytecode encountered (" + code + ")", filename,
>, <Line: +							lval.attribute(Attribute.Source.class));
>, <Line: +				}
>, <Line: +			} catch (ResolveError e) {
>, <Line: +				internalFailure(e.getMessage(), filename, e, lval.attribute(Attribute.Source.class));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// At this point, we have to reverse the lvals because they were put
>, <Line: +		// into the array in the wrong order.
>, <Line: +		Collections.reverse(path);
>, <Line: +		// Done
>, <Line: +		Location<VariableDeclaration> decl = getVariableDeclaration(lval);
>, <Line: +		return new LVal(decl.getIndex(), path);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Represents a type which may appear on the left of an assignment
>, <Line: +	 * expression. Arrays, Records and References are the only valid types for
>, <Line: +	 * an lval.
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static class LVal {
>, <Line: +		public final int variable;
>, <Line: +		public final List<Element<?>> path;
>, <Line: +		public LVal(int variable, List<Element<?>> path) {
>, <Line: +			this.variable = variable;
>, <Line: +			this.path = new ArrayList<Element<?>>(path);
>, <Line: +		}
>, <Line: +		public static class Element<T> {
>, <Line: +			public final T type;
>, <Line: +			public Element(T type) {
>, <Line: +				this.type = type;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		public static class Record extends Element<Type.EffectiveRecord> {
>, <Line: +			public final String field;
>, <Line: +			public Record(Type.EffectiveRecord type, String field) {
>, <Line: +				super(type);
>, <Line: +				this.field = field;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		public static class Array extends Element<Type.EffectiveArray> {
>, <Line: +			public final Location<?> index;
>, <Line: +			public Array(Type.EffectiveArray type, Location<?> index) {
>, <Line: +				super(type);
>, <Line: +				this.index = index;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		public static class Reference extends Element<Type.Reference> {
>, <Line: +			public Reference(Type.Reference type) {
>, <Line: +				super(type);
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Conditions
>, <Line: +	// ===============================================================================
>, <Line: +	/**
>, <Line: +	 * <p>
>, <Line: +	 * Translate a given condition to determine whether it holds or not, then
>, <Line: +	 * branch to an appropriate label. If so, branch to the given true label, or
>, <Line: +	 * continue to next logical instruction if null. If not, branch to the given
>, <Line: +	 * false label, or continue to next logical instruction if null.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * <p>
>, <Line: +	 * <b>NOTE:</b> Exactly one of trueLabel or falseLabel must be null to
>, <Line: +	 * represent the fall-thru case.
>, <Line: +	 * </p>
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateCondition(Location<?> condition, String trueLabel, String falseLabel, Context enclosing) {
>, <Line: +		// First, handle the special cases as necessar.
>, <Line: +		switch (condition.getOpcode()) {
>, <Line: +		case OPCODE_logicalnot:
>, <Line: +			translateNotCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
>, <Line: +			return;
>, <Line: +		case OPCODE_logicaland:
>, <Line: +			translateShortcircuitAndCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
>, <Line: +			return;
>, <Line: +		case OPCODE_logicalor:
>, <Line: +			translateShortcircuitOrCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
>, <Line: +			return;
>, <Line: +		case OPCODE_all:
>, <Line: +		case OPCODE_some:
>, <Line: +			translateQuantifierCondition((Location<Quantifier>) condition, trueLabel, falseLabel, enclosing);
>, <Line: +			return;
>, <Line: +		case OPCODE_is:
>, <Line: +			translateIsCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		// We can't use a condition branch, so fall back to the default. In this
>, <Line: +		// case, we just evaluate the condition as normal which will result in a
>, <Line: +		// 1 or 0 being loaded on the stack. We can then perform a condition
>, <Line: +		// branch from that.
>, <Line: +		translateExpression(condition, enclosing);
>, <Line: +		// Now, dig a true boolean about of the WyBool object
>, <Line: +		JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
>, <Line: +		enclosing.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +		// Finally, branch as necessary
>, <Line: +		if (trueLabel == null) {
>, <Line: +			enclosing.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +		} else {
>, <Line: +			enclosing.add(new Bytecode.If(Bytecode.IfMode.NE, trueLabel));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a logical not condition.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateNotCondition(Location<?> code, String trueLabel, String falseLabel,
>, <Line: +			Context enclosing) {
>, <Line: +		// This case is very easy, as we can just swap the true and false
>, <Line: +		// labels.
>, <Line: +		translateCondition(code.getOperand(0), falseLabel, trueLabel, enclosing);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a logical and condition with short circuiting semantics.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateShortcircuitAndCondition(Location<?> code, String trueLabel, String falseLabel,
>, <Line: +			Context enclosing) {
>, <Line: +		if (trueLabel == null) {
>, <Line: +			translateCondition(code.getOperand(0), null, falseLabel, enclosing);
>, <Line: +			translateCondition(code.getOperand(1), null, falseLabel, enclosing);
>, <Line: +		} else {
>, <Line: +			// implies falseLabel should be null
>, <Line: +			String exitLabel = freshLabel();
>, <Line: +			translateCondition(code.getOperand(0), null, exitLabel, enclosing);
>, <Line: +			translateCondition(code.getOperand(1), trueLabel, null, enclosing);
>, <Line: +			enclosing.add(new Bytecode.Label(exitLabel));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a logical or condition with short circuiting semantics.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateShortcircuitOrCondition(Location<?> code, String trueLabel, String falseLabel,
>, <Line: +			Context enclosing) {
>, <Line: +		if (trueLabel == null) {
>, <Line: +			// implies false label is non-null
>, <Line: +			String exitLabel = freshLabel();
>, <Line: +			translateCondition(code.getOperand(0), exitLabel, null, enclosing);
>, <Line: +			translateCondition(code.getOperand(1), null, falseLabel, enclosing);
>, <Line: +			enclosing.add(new Bytecode.Label(exitLabel));
>, <Line: +		} else {
>, <Line: +			// implies false label is null
>, <Line: +			translateCondition(code.getOperand(0), trueLabel, null, enclosing);
>, <Line: +			translateCondition(code.getOperand(1), trueLabel, null, enclosing);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a quantifier condition into a set of nested loops with the
>, <Line: +	 * condition itself located in the innermost position.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateQuantifierCondition(Location<?> condition, String trueLabel, String falseLabel,
>, <Line: +			Context context) {
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		if(trueLabel == null) {
>, <Line: +			trueLabel = exitLabel;
>, <Line: +		} else {
>, <Line: +			falseLabel = exitLabel;
>, <Line: +		}
>, <Line: +		translateQuantifierCondition(0, condition, trueLabel, falseLabel, context);
>, <Line: +		// Add complete branch (if necessary)
>, <Line: +		switch(condition.getOpcode()) {
>, <Line: +		case OPCODE_all:
>, <Line: +			if(trueLabel != exitLabel) {
>, <Line: +				context.add(new Bytecode.Goto(trueLabel));
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		case OPCODE_some:
>, <Line: +		default:
>, <Line: +			if(falseLabel != exitLabel) {
>, <Line: +				context.add(new Bytecode.Goto(falseLabel));
>, <Line: +			}
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		context.add(new Bytecode.Label(exitLabel));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Helper function for translating quantifiers. The range index indicates
>, <Line: +	 * which range we are currently translating. We essentially recursve for
>, <Line: +	 * each range translating them one at a time into an enclosing loop. When
>, <Line: +	 * the innermost loop body is reached, we can then evaluate the condition
>, <Line: +	 * for the given range positions.
>, <Line: +	 * 
>, <Line: +	 * @param index
>, <Line: +	 *            Index into quantifier ranges. If matches number of ranges,
>, <Line: +	 *            then innermost position is reached.
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateQuantifierCondition(int index, Location<?> condition, String trueLabel,
>, <Line: +			String falseLabel, Context context) {
>, <Line: +		if (index == condition.numberOfOperandGroups()) {
>, <Line: +			// This is the innermost case. At this point, we are in the body of
>, <Line: +			// the innermost loop.  First, determine what is true and false :) 
>, <Line: +			String myTrueLabel = null;
>, <Line: +			String myFalseLabel = null;
>, <Line: +			switch(condition.getOpcode()) {
>, <Line: +			case OPCODE_all:
>, <Line: +				// if condition false, terminate early and return false.
>, <Line: +				myFalseLabel = falseLabel;
>, <Line: +				break;
>, <Line: +			case OPCODE_some:
>, <Line: +			default:
>, <Line: +				// if condition true, terminate early and return true.
>, <Line: +				myTrueLabel = trueLabel;
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			// Translate the quantifier condition and, depending on the kind of
>, <Line: +			// quantifier, branch to either the true or false label.
>, <Line: +			translateCondition(condition.getOperand(0),myTrueLabel,myFalseLabel,context);
>, <Line: +		} else {
>, <Line: +			// This is the recursive case. Here, we need to construct an
>, <Line: +			// appropriate loop to iterate through the range.
>, <Line: +			Location<?>[] range = condition.getOperandGroup(index);
>, <Line: +			Location<?> var = range[SyntaxTree.VARIABLE];
>, <Line: +			Location<?> start = range[SyntaxTree.START];
>, <Line: +			Location<?> end = range[SyntaxTree.END];
>, <Line: +			translateExpression(start,context);
>, <Line: +			translateExpression(end,context);
>, <Line: +			context.add(new Bytecode.Store(end.getIndex(),WHILEYINT));
>, <Line: +			context.add(new Bytecode.Store(var.getIndex(),WHILEYINT));
>, <Line: +			// Create loop
>, <Line: +			String headerLabel = freshLabel();
>, <Line: +			String exitLabel = freshLabel();
>, <Line: +			// Generate loop condition
>, <Line: +			context.add(new Bytecode.Label(headerLabel));
>, <Line: +			context.add(new Bytecode.Load(var.getIndex(),WHILEYINT));
>, <Line: +			context.add(new Bytecode.Load(end.getIndex(),WHILEYINT));
>, <Line: +			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYUTIL, "equal", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +			ftype = new JvmType.Function(JvmTypes.T_BOOL);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.NE, exitLabel));
>, <Line: +			// Recursively translate remainder of quantifier
>, <Line: +			translateQuantifierCondition(index+1,condition,trueLabel,falseLabel,context);
>, <Line: +			// Increment index variable
>, <Line: +			context.add(new Bytecode.Load(var.getIndex(), WHILEYINT));
>, <Line: +			context.add(new Bytecode.GetField(WHILEYINT, "ONE", WHILEYINT, Bytecode.FieldMode.STATIC));
>, <Line: +			ftype = new JvmType.Function(WHILEYINT, WHILEYINT);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYINT, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.Store(var.getIndex(), WHILEYINT));
>, <Line: +			// Branch back to top of loop
>, <Line: +			context.add(new Bytecode.Goto(headerLabel));
>, <Line: +			context.add(new Bytecode.Label(exitLabel));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a type test condition. This is done here to ensure that we cast
>, <Line: +	 * the type appropriately before moving on to the true/false branches. For
>, <Line: +	 * example:
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * function f(int|null x) -> (int r):
>, <Line: +	 *     if x is int:
>, <Line: +	 *         return x
>, <Line: +	 *     else:
>, <Line: +	 *         return 0
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * In this case, the type of <code>x</code> will be <code>Object</code>, and
>, <Line: +	 * it must be cast to <code>int</code> on the true branch of the type test.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Type test to evaluate to see whether it is true or false
>, <Line: +	 * @param trueLabel
>, <Line: +	 *            Destination for when the condition is true. If null, execution
>, <Line: +	 *            continues to next logical instruction when condition holds.
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination for when the condition is false. If null,
>, <Line: +	 *            execution continues to next logical instruction when condition
>, <Line: +	 *            doesn't hold.
>, <Line: +	 * @param context
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateIsCondition(Location<Operator> test, String trueLabel, String falseLabel,
>, <Line: +			Context context) {
>, <Line: +		Location<Const> rhs = (Location<Const>) test.getOperand(1);
>, <Line: +		Type rhsType = ((Constant.Type) rhs.getBytecode().constant()).value();
>, <Line: +		//
>, <Line: +		// Translate the type test itself
>, <Line: +		translateExpressions(test.getOperands(), context);
>, <Line: +		JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT);
>, <Line: +		context.add(new Bytecode.Swap());
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYTYPE, "is", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +		// Add the necessary branching instruction
>, <Line: +		JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +		// Determine the appropriate types for the true and false branches
>, <Line: +		Pair<Type,Type> flowTypes = determineFlowTypes(test,context);
>, <Line: +		// Add the necessary branch
>, <Line: +		if(flowTypes == null) {
>, <Line: +			// FIXME: bug here in case where constrained type is being tested
>, <Line: +			// In this case, no retyping is possible. Therefore, we branch
>, <Line: +			// directly to the relevant destination.
>, <Line: +			if(trueLabel == null) {
>, <Line: +				context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +			} else {		
>, <Line: +				context.add(new Bytecode.If(Bytecode.IfMode.NE, trueLabel));
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			// In this case, a variable is being tested directly and, hence,
>, <Line: +			// needs to be retyped on both branches.
>, <Line: +			Location<VariableAccess> lhs = (Location<VariableAccess>) test.getOperand(0);
>, <Line: +			Location<VariableDeclaration> decl = getVariableDeclaration(lhs);
>, <Line: +			String tmpFalseLabel = freshLabel();
>, <Line: +			String tmpTrueLabel = freshLabel();
>, <Line: +			if(trueLabel == null) {		
>, <Line: +				context.add(new Bytecode.If(Bytecode.IfMode.NE, tmpTrueLabel));
>, <Line: +				context.add(new Bytecode.Label(tmpFalseLabel));
>, <Line: +				// This is the false branch. Apply the necessary cast.
>, <Line: +				retypeLocation(lhs,flowTypes.second(),context);
>, <Line: +				context.add(new Bytecode.Goto(falseLabel));
>, <Line: +				context.add(new Bytecode.Label(tmpTrueLabel));
>, <Line: +				// This is the true branch. Apply the necessary cast.
>, <Line: +				retypeLocation(lhs,flowTypes.first(),context);
>, <Line: +				// Now, check any invariants hold (or not)
>, <Line: +				int freeRegister = getFirstFreeRegister(test.getEnclosingTree());
>, <Line: +				translateInvariantTest(tmpFalseLabel, rhsType, decl.getIndex(), freeRegister, context);
>, <Line: +			} else {
>, <Line: +				context.add(new Bytecode.If(Bytecode.IfMode.EQ, tmpFalseLabel));
>, <Line: +				// This is the true branch. Apply the necessary cast.
>, <Line: +				retypeLocation(lhs,flowTypes.first(),context);
>, <Line: +				// Now, check any invariants hold (or not)
>, <Line: +				int freeRegister = getFirstFreeRegister(test.getEnclosingTree());
>, <Line: +				translateInvariantTest(tmpFalseLabel, rhsType, decl.getIndex(), freeRegister, context);
>, <Line: +				context.add(new Bytecode.Goto(trueLabel));
>, <Line: +				// This is the false branch. Apply the necessary cast.
>, <Line: +				context.add(new Bytecode.Label(tmpFalseLabel));
>, <Line: +				retypeLocation(lhs,flowTypes.second(),context);
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Determine the appropriate types for the true and false branches of a type
>, <Line: +	 * test.These are critical to determining the correct type to cast the
>, <Line: +	 * variable's contents to. The presence of constrained types complicates
>, <Line: +	 * this. For example, consider:
>, <Line: +	 *
>, <Line: +	 * <pre>
>, <Line: +	 *	 type nat is (int n) where n >= 0
>, <Line: +	 *	
>, <Line: +	 *	 function f(int|bool|null x) -> bool:
>, <Line: +	 *	 if x is nat|bool:
>, <Line: +	 *	 ...
>, <Line: +	 *	 else:
>, <Line: +	 *	 ...
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * 
>, <Line: +	 * Here, the type of x on the true branch is int|bool, whilst on the false
>, <Line: +	 * branch it is int|null. To correctly handle this, we need to determine
>, <Line: +	 * maximal type which is fully consumed by another. In this case, the
>, <Line: +	 * maximal type fully consumed by nat|bool is bool and, hence, the type on
>, <Line: +	 * the false branch is int|bool|null - bool == int|null.
>, <Line: +	 * 
>, <Line: +	 * @param test
>, <Line: +	 * @param enclosing
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Type, Type> determineFlowTypes(Location<Operator> test, Context enclosing) {
>, <Line: +		Location<?> lhs = test.getOperand(0);
>, <Line: +		Location<Const> rhs = (Location<Const>) test.getOperand(1);		
>, <Line: +		if(lhs.getBytecode() instanceof VariableAccess) {					
>, <Line: +			Type maximalConsumedType;
>, <Line: +			Type expandedLhsType;
>, <Line: +			Type expandedRhsType;
>, <Line: +			Type lhsType = lhs.getType();
>, <Line: +			Type rhsType = ((Constant.Type) rhs.getBytecode().constant()).value();
>, <Line: +			// Determine the maximally consumed type, and the underlying type.
>, <Line: +			try {
>, <Line: +				maximalConsumedType = typeSystem.getMaximallyConsumedType(rhsType);
>, <Line: +				expandedLhsType = typeSystem.getUnderlyingType(lhsType);
>, <Line: +				expandedRhsType = typeSystem.getUnderlyingType(rhsType);
>, <Line: +			} catch (Exception e) {
>, <Line: +				internalFailure("error computing maximally consumed type: " + rhsType, filename, e);
>, <Line: +				return null;
>, <Line: +			}
>, <Line: +			// Create the relevant types
>, <Line: +			Type typeOnTrueBranch = Type.intersect(expandedLhsType, expandedRhsType);
>, <Line: +			Type typeOnFalseBranch = Type.intersect(expandedLhsType, Type.Negation(maximalConsumedType));
>, <Line: +			return new Pair<Type,Type>(typeOnTrueBranch,typeOnFalseBranch);
>, <Line: +		} else {
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Retype a given variable. This is done by casting the variable into the
>, <Line: +	 * appropriate type and assigning this over the original value.
>, <Line: +	 * 
>, <Line: +	 * @param location
>, <Line: +	 *            Variable to be retyped.
>, <Line: +	 * @param type
>, <Line: +	 *            Type variable should become
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context.
>, <Line: +	 */
>, <Line: +	private void retypeLocation(Location<VariableAccess> location, Type type, Context enclosing) {
>, <Line: +		Location<VariableDeclaration> decl = getVariableDeclaration(location);
>, <Line: +		enclosing.add(new Bytecode.Load(decl.getIndex(), toJvmType(type)));
>, <Line: +		enclosing.addReadConversion(type);
>, <Line: +		enclosing.add(new Bytecode.Store(decl.getIndex(), toJvmType(type)));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate any invariants contained in a given type. In the case the
>, <Line: +	 * invariant doesn't hold, we dispatch to a given false destination.
>, <Line: +	 * Otherwise, we fall through to the following instruction.
>, <Line: +	 * 
>, <Line: +	 * @param falseTarget
>, <Line: +	 *            Destination to branch if invariant is false
>, <Line: +	 * @param type
>, <Line: +	 *            Type whose invariants are being tested
>, <Line: +	 * @param variableRegister
>, <Line: +	 *            JVM register slot of variable which is being tested
>, <Line: +	 * @param freeRegister
>, <Line: +	 *            First free JVM register slot which can be used by this method
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	private void translateInvariantTest(String falseTarget, Type type, int variableRegister, int freeRegister,
>, <Line: +			Context context) {
>, <Line: +		//
>, <Line: +		JvmType underlyingType = toJvmType(type);
>, <Line: +		//
>, <Line: +		if (type instanceof Type.Nominal) {
>, <Line: +			Type.Nominal c = (Type.Nominal) type;
>, <Line: +			Path.ID mid = c.name().module();
>, <Line: +			JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
>, <Line: +			JvmType.Function fnType = new JvmType.Function(new JvmType.Bool(), toJvmType(c));
>, <Line: +			context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
>, <Line: +			context.add(new Bytecode.Invoke(owner, c.name().name() + "$typeof", fnType, Bytecode.InvokeMode.STATIC));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
>, <Line: +		} else if (type instanceof Type.Leaf) {
>, <Line: +			// Do nout
>, <Line: +		} else if (type instanceof Type.Reference) {
>, <Line: +			Type.Reference rt = (Type.Reference) type;
>, <Line: +			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT);
>, <Line: +			context.add(new Bytecode.Load(variableRegister, underlyingType));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.addReadConversion(rt.element());
>, <Line: +			context.add(new Bytecode.Store(freeRegister, toJvmType(rt.element())));
>, <Line: +			translateInvariantTest(falseTarget, rt.element(), freeRegister, freeRegister + 1, context);
>, <Line: +		} else if (type instanceof Type.EffectiveArray) {
>, <Line: +			Type.EffectiveArray ts = (Type.EffectiveArray) type;
>, <Line: +			Triple<String, String, String> loopLabels = translateLoopBegin(variableRegister, freeRegister, context);
>, <Line: +			context.addReadConversion(ts.element());
>, <Line: +			context.add(new Bytecode.Store(freeRegister + 1, toJvmType(ts.element())));
>, <Line: +			translateInvariantTest(falseTarget, ts.element(), freeRegister + 1, freeRegister + 2, context);
>, <Line: +			translateLoopEnd(loopLabels, context);
>, <Line: +		} else if (type instanceof Type.Record) {
>, <Line: +			Type.Record tt = (Type.Record) type;
>, <Line: +			HashMap<String, Type> fields = tt.fields();
>, <Line: +			ArrayList<String> fieldNames = new ArrayList<String>(fields.keySet());
>, <Line: +			Collections.sort(fieldNames);
>, <Line: +			for (int i = 0; i != fieldNames.size(); ++i) {
>, <Line: +				String field = fieldNames.get(i);
>, <Line: +				Type fieldType = fields.get(field);
>, <Line: +				JvmType underlyingFieldType = toJvmType(fieldType);
>, <Line: +				context.add(new Bytecode.Load(variableRegister, underlyingType));
>, <Line: +				context.add(new Bytecode.LoadConst(field));
>, <Line: +				JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_STRING);
>, <Line: +				context.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +				context.addReadConversion(fieldType);
>, <Line: +				context.add(new Bytecode.Store(freeRegister, underlyingFieldType));
>, <Line: +				translateInvariantTest(falseTarget, fieldType, freeRegister, freeRegister + 1, context);
>, <Line: +			}
>, <Line: +		} else if (type instanceof Type.FunctionOrMethod) {
>, <Line: +			// FIXME: this is clearly a bug. However, it's not completely
>, <Line: +			// straightforward to fix, since there is currently no way to get
>, <Line: +			// runtime type information about a function or method reference. In
>, <Line: +			// principle, this could be encoded in the WyLambda in some way.
>, <Line: +		} else if (type instanceof Type.Negation) {
>, <Line: +			Type.Reference rt = (Type.Reference) type;
>, <Line: +			String trueTarget = freshLabel();
>, <Line: +			translateInvariantTest(trueTarget, rt.element(), variableRegister, freeRegister, context);
>, <Line: +			context.add(new Bytecode.Goto(falseTarget));
>, <Line: +			context.add(new Bytecode.Label(trueTarget));
>, <Line: +		} else if (type instanceof Type.Union) {
>, <Line: +			Type.Union ut = (Type.Union) type;
>, <Line: +			String trueLabel = freshLabel();
>, <Line: +			for (Type bound : ut.bounds()) {
>, <Line: +				try {
>, <Line: +					Type underlyingBound = typeSystem.getUnderlyingType(bound);
>, <Line: +					String nextLabel = freshLabel();
>, <Line: +					context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
>, <Line: +					translateTypeTest(nextLabel, underlyingBound, context);
>, <Line: +					context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
>, <Line: +					context.addReadConversion(bound);
>, <Line: +					context.add(new Bytecode.Store(freeRegister, toJvmType(bound)));
>, <Line: +					translateInvariantTest(nextLabel, bound, freeRegister, freeRegister + 1, context);
>, <Line: +					context.add(new Bytecode.Goto(trueLabel));
>, <Line: +					context.add(new Bytecode.Label(nextLabel));
>, <Line: +				} catch (ResolveError e) {
>, <Line: +					internalFailure(e.getMessage(), filename, e);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			context.add(new Bytecode.Goto(falseTarget));
>, <Line: +			context.add(new Bytecode.Label(trueLabel));
>, <Line: +		} else {
>, <Line: +			internalFailure("unknown type encountered: " + type, filename);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct generic code for iterating over a collection (e.g. a Whiley
>, <Line: +	 * List or Set). This code will not leave anything on the stack and will
>, <Line: +	 * store the iterator variable in a given slot. This means that things can
>, <Line: +	 * be passed on the stack from before the loop into the loop body.
>, <Line: +	 * 
>, <Line: +	 * @param freeSlot
>, <Line: +	 *            The variable slot into which the iterator variable should be
>, <Line: +	 *            stored.
>, <Line: +	 * @param exitLabel
>, <Line: +	 *            The label which will represents after the end of the loop.
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context
>, <Line: +	 */
>, <Line: +	private Triple<String, String, String> translateLoopBegin(
>, <Line: +			int sourceSlot, int freeSlot, Context context) {
>, <Line: +		String loopHeader = freshLabel();
>, <Line: +		String loopFooter = freshLabel();
>, <Line: +		String loopExit = freshLabel();
>, <Line: +		// First, call Collection.iterator() on the source collection and write
>, <Line: +		// it into the free slot.
>, <Line: +		context.add(new Bytecode.Load(sourceSlot, JAVA_LANG_ITERABLE));
>, <Line: +		context.add(new Bytecode.Invoke(JAVA_LANG_ITERABLE, "iterator",
>, <Line: +				new JvmType.Function(JAVA_UTIL_ITERATOR),Bytecode.InvokeMode.INTERFACE));
>, <Line: +		context.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: +		// Second, construct the loop header, which consists of the test to
>, <Line: +		// check whether or not there are any elements left in the collection to
>, <Line: +		// visit.
>, <Line: +		context.add(new Bytecode.Label(loopHeader));
>, <Line: +		context.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: +		context.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext",
>, <Line: +				new JvmType.Function(T_BOOL), Bytecode.InvokeMode.INTERFACE));
>, <Line: +		context.add(new Bytecode.If(Bytecode.IfMode.EQ, loopExit));
>, <Line: +		// Finally, get the current element out of the iterator by invoking
>, <Line: +		// Iterator.next();
>, <Line: +		context.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: +		context.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next",
>, <Line: +				new JvmType.Function(JAVA_LANG_OBJECT),
>, <Line: +				Bytecode.InvokeMode.INTERFACE));
>, <Line: +		// Done
>, <Line: +		return new Triple<String,String,String>(loopHeader, loopFooter, loopExit);
>, <Line: +	}
>, <Line: +	private void translateLoopEnd(Triple<String, String, String> labels, Context context) {
>, <Line: +		context.add(new Bytecode.Label(labels.second()));
>, <Line: +		context.add(new Bytecode.Goto(labels.first()));
>, <Line: +		context.add(new Bytecode.Label(labels.third()));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * The purpose of this method is to translate a type test. We're testing to
>, <Line: +	 * see whether what's on the top of the stack (the value) is a subtype of
>, <Line: +	 * the type being tested. Note, constants must be provided as a parameter
>, <Line: +	 * 
>, <Line: +	 * @param falseLabel
>, <Line: +	 *            Destination to branch if not true
>, <Line: +	 * @param type
>, <Line: +	 *            Type being tested
>, <Line: +	 * @param context
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	protected void translateTypeTest(String falseLabel, Type test, Context context) {
>, <Line: +		// First, try for the easy cases
>, <Line: +		if (test instanceof Type.Null) {
>, <Line: +			// Easy case
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.NONNULL, falseLabel));
>, <Line: +		} else if (test instanceof Type.Bool) {
>, <Line: +			context.add(new Bytecode.InstanceOf(WHILEYBOOL));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +		} else if (test instanceof Type.Int) {
>, <Line: +			context.add(new Bytecode.InstanceOf(WHILEYINT));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +		} else {
>, <Line: +			// Fall-back to an external (recursive) check
>, <Line: +			Constant constant = new Constant.Type(test);
>, <Line: +			int id = JvmValue.get(constant, constants);
>, <Line: +			String name = "constant$" + id;
>, <Line: +			context.add(new Bytecode.GetField(owner, name, WHILEYTYPE, Bytecode.FieldMode.STATIC));
>, <Line: +			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT);
>, <Line: +			context.add(new Bytecode.Swap());
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYTYPE, "is", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Expressions
>, <Line: +	// ===============================================================================
>, <Line: +	/**
>, <Line: +	 * Translate one or more operands into JVM Bytecodes. Execution follows the
>, <Line: +	 * order of operands given, with the first operand being evaluated before
>, <Line: +	 * the others. Likewise, the results are pushed on the stack in the order of
>, <Line: +	 * operands given. So, the result of the first operand is pushed onto the
>, <Line: +	 * stack first, etc.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return The set of JVM types representing the actual operands pushed on
>, <Line: +	 *         the stack. This maybe be larger than the number of operands
>, <Line: +	 *         provided in the case that one or more of those operands had
>, <Line: +	 *         multiple return values.
>, <Line: +	 */
>, <Line: +	public List<JvmType> translateExpressions(Location<?>[] operands, Context enclosing) {
>, <Line: +		ArrayList<JvmType> types = new ArrayList<JvmType>();
>, <Line: +		for (int i = 0; i != operands.length; ++i) {
>, <Line: +			Location<?> operand = operands[i];
>, <Line: +			// Translate operand
>, <Line: +			translateExpression(operand, enclosing);
>, <Line: +			// Determine type(s) for operand
>, <Line: +			for (int j = 0; j != operand.numberOfTypes(); ++j) {
>, <Line: +				types.add(toJvmType(operand.getType(j)));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return types;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate one or more operands into JVM Bytecodes and store them in an
>, <Line: +	 * object array. Execution follows the order of operands given, with the
>, <Line: +	 * first operand being evaluated before the others. Likewise, the results
>, <Line: +	 * are pushed on the stack in the order of operands given. So, the result of
>, <Line: +	 * the first operand is pushed onto the stack first, etc.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param freeRegister
>, <Line: +	 *            First free JVM register slot which can be used by this method
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 */
>, <Line: +	private void translateExpressionsToArray(Location<?>[] operands, int freeRegister, Context context) {
>, <Line: +		int size = countLocationTypes(operands);
>, <Line: +		ArrayList<Type> types = new ArrayList<Type>();
>, <Line: +		// Translate every operand giving size elements on stack
>, <Line: +		for (int i = 0; i < operands.length; i = i + 1) {
>, <Line: +			Location<?> operand = operands[i];
>, <Line: +			// Translate expression itself
>, <Line: +			translateExpression(operand, context);
>, <Line: +			// record the types now loaded on the stack
>, <Line: +			for (int j = 0; j != operand.numberOfTypes(); ++j) {
>, <Line: +				types.add(operand.getType(j));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Construct the target array
>, <Line: +		context.add(new Bytecode.LoadConst(size));
>, <Line: +		context.add(new Bytecode.New(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +		context.add(new Bytecode.Store(freeRegister, JAVA_LANG_OBJECT_ARRAY));
>, <Line: +		// Process each stack element in turn. This has to be done in reverse
>, <Line: +		// order since that's how they're laid out on the stack
>, <Line: +		for (int i = size - 1; i >= 0; i = i - 1) {
>, <Line: +			context.add(new Bytecode.Load(freeRegister, JAVA_LANG_OBJECT_ARRAY));
>, <Line: +			context.add(new Bytecode.Swap());
>, <Line: +			context.add(new Bytecode.LoadConst(i));
>, <Line: +			context.add(new Bytecode.Swap());
>, <Line: +			context.addWriteConversion(types.get(i));
>, <Line: +			context.add(new Bytecode.ArrayStore(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +		}
>, <Line: +		// Done
>, <Line: +		context.add(new Bytecode.Load(freeRegister, JAVA_LANG_OBJECT_ARRAY));
>, <Line: +	}
>, <Line: +	private int countLocationTypes(Location<?>...locations) {
>, <Line: +		int count = 0 ;
>, <Line: +		for(int i=0;i!=locations.length;++i) {
>, <Line: +			count += locations[i].numberOfTypes();
>, <Line: +		}
>, <Line: +		return count;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an operand into one or more JVM Bytecodes. The result of this
>, <Line: +	 * operand will be pushed onto the stack at the end.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateExpression(Location<?> expr, Context context) {
>, <Line: +		try {
>, <Line: +			switch (expr.getOpcode()) {
>, <Line: +			case OPCODE_convert:
>, <Line: +				translateConvert((Location<Convert>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_const:
>, <Line: +				translateConst((Location<Const>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_fieldload:
>, <Line: +				translateFieldLoad((Location<FieldLoad>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_all:
>, <Line: +			case OPCODE_some:
>, <Line: +				translateQuantifier((Location<Quantifier>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_indirectinvoke:
>, <Line: +				translateIndirectInvoke((Location<IndirectInvoke>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_invoke:
>, <Line: +				translateInvoke((Location<Invoke>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_lambda:
>, <Line: +				translateLambda((Location<Lambda>) expr, context);
>, <Line: +				break;
>, <Line: +			case OPCODE_varaccess:
>, <Line: +				translateVariableAccess((Location<VariableAccess>) expr, context);
>, <Line: +				break;
>, <Line: +			default:				
>, <Line: +				translateOperator((Location<Operator>) expr, context);				
>, <Line: +			}
>, <Line: +		} catch(InternalFailure ex) {
>, <Line: +			throw ex;
>, <Line: +		} catch (Exception ex) {
>, <Line: +			internalFailure(ex.getMessage(), filename, ex, expr.attributes());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a constant into JVM bytecodes and load it onto the stack. In
>, <Line: +	 * some cases, this can be done directly. For example, <code>null</code> can
>, <Line: +	 * be loaded onto the stack using the <code>aconst_null</code> bytecode. In
>, <Line: +	 * other cases (e.g. for array constants), we have to construct one or more
>, <Line: +	 * objects to represent the constant. To avoid doing this everytime such a
>, <Line: +	 * constant is encountered, we create the constants in the static
>, <Line: +	 * initialiser of this class, and store them in static fields for later
>, <Line: +	 * recall.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateConst(Location<Const> c, Context context) throws ResolveError {
>, <Line: +		Constant constant = c.getBytecode().constant();
>, <Line: +		// At this point, we need to normalise the constant. This is because the
>, <Line: +		// constant may involve one or more nominal types. These types don't
>, <Line: +		// make sense at runtime, and we want to get rid of them where possible.
>, <Line: +		constant = normalise(constant);		
>, <Line: +		JvmType jt = toJvmType(constant.type());
>, <Line: +		// Check whether this constant can be translated as a primitive, and
>, <Line: +		// encoded directly within a bytecode.
>, <Line: +		if (constant instanceof Constant.Bool || constant instanceof Constant.Null
>, <Line: +				|| constant instanceof Constant.Byte) {
>, <Line: +			// Yes, it can.
>, <Line: +			translateConstant(constant, context);
>, <Line: +		} else {
>, <Line: +			// No, this needs to be constructed elsewhere as a static field.
>, <Line: +			// Then, we can load it onto the stack here.
>, <Line: +			int id = JvmValue.get(constant, constants);
>, <Line: +			String name = "constant$" + id;
>, <Line: +			context.add(new Bytecode.GetField(owner, name, jt, Bytecode.FieldMode.STATIC));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Make sure any type constants are fully expanded. This is to ensure that
>, <Line: +	 * nominal types are not present at runtime (unless they are specifically
>, <Line: +	 * protected in some way).
>, <Line: +	 * 
>, <Line: +	 * @param constant
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant normalise(Constant constant) throws ResolveError {		
>, <Line: +		if(constant instanceof Constant.Type) {
>, <Line: +			Constant.Type ct = (Constant.Type) constant;
>, <Line: +			Type type = ct.value();
>, <Line: +			Type underlyingType;			
>, <Line: +			underlyingType = typeSystem.getUnderlyingType(type);			
>, <Line: +			return new Constant.Type(underlyingType);
>, <Line: +		} else {
>, <Line: +			return constant;
>, <Line: +		}		
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Coerce one data value into another. In what situations do we actually
>, <Line: +	 * have to do work?
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateConvert(Location<Convert> c, Context context) {
>, <Line: +		// Translate the operand
>, <Line: +		translateExpression(c.getOperand(0), context);
>, <Line: +		// Do nothing :)
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Load the value of a given field from a record.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateFieldLoad(Location<FieldLoad> c, Context context) throws ResolveError {
>, <Line: +		Location<?> srcOperand = c.getOperand(0);
>, <Line: +		Type.EffectiveRecord type = typeSystem.expandAsEffectiveRecord(srcOperand.getType());
>, <Line: +		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYRECORD, JAVA_LANG_STRING);
>, <Line: +		// Translate the source operand
>, <Line: +		translateExpression(srcOperand, context);
>, <Line: +		context.add(new Bytecode.LoadConst(c.getBytecode().fieldName()));
>, <Line: +		// Load the field out of the resulting record
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +		// Add a read conversion (if necessary) to unbox the value
>, <Line: +		context.addReadConversion(type.field(c.getBytecode().fieldName()));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Apply a unary, binary or ternary operator to a given set of operands.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateOperator(Location<Operator> c, Context context) throws ResolveError {
>, <Line: +		// First, translate each operand and load its value onto the stack
>, <Line: +		switch (c.getOpcode()) {
>, <Line: +		case OPCODE_logicaland:
>, <Line: +		case OPCODE_logicalor:
>, <Line: +			// These two operators need to be handled specially because they
>, <Line: +			// require short-circuiting semantics.
>, <Line: +			translateExpressionAsCondition(c,context);
>, <Line: +			break;
>, <Line: +		case OPCODE_record:
>, <Line: +			translateRecordConstructor(c, context);
>, <Line: +			break;
>, <Line: +		case OPCODE_array:
>, <Line: +			translateArrayConstructor(c, context);
>, <Line: +			break;
>, <Line: +		default:			
>, <Line: +			translateExpressions(c.getOperands(), context);
>, <Line: +			// Second, dispatch to a specific translator for this opcode kind.
>, <Line: +			generators[c.getOpcode()].translate(c, context);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public void translateExpressionAsCondition(Location<Operator> bytecode, Context context) throws ResolveError {
>, <Line: +		String trueLabel = freshLabel();
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		translateCondition(bytecode,trueLabel,null,context);
>, <Line: +		context.add(new Bytecode.GetField(WHILEYBOOL, "FALSE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
>, <Line: +		context.add(new Bytecode.Goto(exitLabel));
>, <Line: +		context.add(new Bytecode.Label(trueLabel));
>, <Line: +		context.add(new Bytecode.GetField(WHILEYBOOL, "TRUE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
>, <Line: +		context.add(new Bytecode.Label(exitLabel));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a RecordConstructor operand.
>, <Line: +	 * 
>, <Line: +	 * @param bytecode
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	public void translateRecordConstructor(Location<Operator> bytecode, Context context) throws ResolveError {
>, <Line: +		Type.EffectiveRecord recType = typeSystem.expandAsEffectiveRecord(bytecode.getType());
>, <Line: +		JvmType.Function ftype = new JvmType.Function(WHILEYRECORD, WHILEYRECORD, JAVA_LANG_STRING, JAVA_LANG_OBJECT);
>, <Line: +		context.construct(WHILEYRECORD);
>, <Line: +		ArrayList<String> keys = new ArrayList<String>(recType.fields().keySet());
>, <Line: +		Collections.sort(keys);
>, <Line: +		for (int i = 0; i != bytecode.getOperands().length; i++) {
>, <Line: +			String key = keys.get(i);
>, <Line: +			Type fieldType = recType.field(key);
>, <Line: +			context.add(new Bytecode.LoadConst(key));
>, <Line: +			translateExpression(bytecode.getOperand(i), context);
>, <Line: +			context.addWriteConversion(fieldType);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an ArrayConstructor operand
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateArrayConstructor(Location<Operator> code, Context context) throws ResolveError {
>, <Line: +		Type.EffectiveArray arrType = typeSystem.expandAsEffectiveArray(code.getType());
>, <Line: +		JvmType.Function initJvmType = new JvmType.Function(T_VOID, T_INT);
>, <Line: +		JvmType.Function ftype = new JvmType.Function(WHILEYARRAY, WHILEYARRAY, JAVA_LANG_OBJECT);
>, <Line: +		context.add(new Bytecode.New(WHILEYARRAY));
>, <Line: +		context.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: +		context.add(new Bytecode.LoadConst(code.getOperands().length));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", initJvmType, Bytecode.InvokeMode.SPECIAL));
>, <Line: +		for (int i = 0; i != code.getOperands().length; ++i) {
>, <Line: +			translateExpression(code.getOperand(i), context);
>, <Line: +			context.addWriteConversion(arrType.element());
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYARRAY, "internal_add", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a lambda expression into a sequence of JVM bytecodes. This is
>, <Line: +	 * done by constructing a separate class extending WyLambda. This class
>, <Line: +	 * contains as fields any local variables from the current method/function
>, <Line: +	 * which are accessed within the body of the lambda (the so-called
>, <Line: +	 * "binding").
>, <Line: +	 * 
>, <Line: +	 * @param c
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	private void translateLambda(Location<Lambda> c, Context context) {
>, <Line: +		Lambda bytecode = c.getBytecode();
>, <Line: +		Location<?>[] environment = c.getOperandGroup(1);
>, <Line: +		int lambda_id = lambdaClasses.size();
>, <Line: +		String lambdaMethod = "$lambda" + lambda_id;
>, <Line: +		JvmType[] jvmEnvironment = buildLambdaEnvironment(environment);
>, <Line: +		// First, we construct and instantiate the lambda
>, <Line: +		ClassFile lambda = buildLambda(owner, lambdaMethod, bytecode.type(), jvmEnvironment);
>, <Line: +		lambdaClasses.add(lambda);
>, <Line: +		//
>, <Line: +		context.add(new Bytecode.New(lambda.type()));
>, <Line: +		context.add(new Bytecode.Dup(lambda.type()));
>, <Line: +		for (int i = 0; i != environment.length; ++i) {
>, <Line: +			Location<?> e = environment[i];
>, <Line: +			context.add(new Bytecode.Load(e.getIndex(), jvmEnvironment[i]));
>, <Line: +		}
>, <Line: +		JvmType.Function ftype = new JvmType.Function(T_VOID, jvmEnvironment);
>, <Line: +		context.add(new Bytecode.Invoke(lambda.type(), "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: +		// Second, we translate the body of the lambda and construct a new
>, <Line: +		// method to represent it. This method will then be called from the
>, <Line: +		// lambda class created above.
>, <Line: +		ClassFile.Method method = buildLambdaMethod(c, lambdaMethod, context);
>, <Line: +		//
>, <Line: +		lambdaMethods.add(method);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Perform a direct method or function invocation.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateInvoke(Location<Invoke> c, Context context) {
>, <Line: +		Invoke bytecode = c.getBytecode();
>, <Line: +		// Translate each operand and load its value onto the stack
>, <Line: +		translateExpressions(c.getOperands(), context);
>, <Line: +		// Construct the invocation bytecode
>, <Line: +		context.add(createMethodInvocation(bytecode.name(), bytecode.type()));
>, <Line: +		// 
>, <Line: +		List<Type> returnTypes = bytecode.type().returns();
>, <Line: +		if(returnTypes.size() > 1) {
>, <Line: +			decodeOperandArray(returnTypes,context);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Perform an indirect method or function invocation.
>, <Line: +	 * 
>, <Line: +	 * @param code
>, <Line: +	 *            The WyIL operand being translated.
>, <Line: +	 * @param enclosing
>, <Line: +	 *            The enclosing context for this operand.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void translateIndirectInvoke(Location<IndirectInvoke> c, Context context) {
>, <Line: +		IndirectInvoke bytecode = c.getBytecode();
>, <Line: +		Type.FunctionOrMethod ft = bytecode.type();
>, <Line: +		JvmType.Clazz owner = (JvmType.Clazz) toJvmType(ft);
>, <Line: +		// First, translate reference operand which returns the function/method
>, <Line: +		// object we will dispatch upon. This extends the WyLambda class.
>, <Line: +		translateExpression(c.getOperand(0), context);
>, <Line: +		// Second, translate each argument and store it into an object array
>, <Line: +		int freeRegister = getFirstFreeRegister(c.getEnclosingTree());
>, <Line: +		translateExpressionsToArray(c.getOperandGroup(0), freeRegister, context);
>, <Line: +		// Third, make the indirect method or function call. This is done by
>, <Line: +		// invoking the "call" method on the function / method object returned
>, <Line: +		// from the reference operand.
>, <Line: +		JvmType.Function type = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
>, <Line: +		context.add(new Bytecode.Invoke(owner, "call", type, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +		// Cast return value to expected type
>, <Line: +		List<Type> returnTypes = bytecode.type().returns();
>, <Line: +		if (returnTypes.size() == 1) {
>, <Line: +			JvmType returnType = toJvmType(ft.returns().get(0));
>, <Line: +			context.addCheckCast(returnType);
>, <Line: +		} else if (returnTypes.size() > 1) {
>, <Line: +			decodeOperandArray(returnTypes, context);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a quantifier into a set of nested loops with the condition
>, <Line: +	 * itself located in the innermost position.
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false 
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateQuantifier(Location<Quantifier> condition, Context context) {
>, <Line: +		String trueLabel = freshLabel();
>, <Line: +		String exitLabel = freshLabel();
>, <Line: +		translateQuantifierCondition(condition, trueLabel, null, context);
>, <Line: +		context.add(new Bytecode.GetField(WHILEYBOOL, "FALSE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
>, <Line: +		context.add(new Bytecode.Goto(exitLabel));
>, <Line: +		context.add(new Bytecode.Label(trueLabel));
>, <Line: +		context.add(new Bytecode.GetField(WHILEYBOOL, "TRUE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
>, <Line: +		context.add(new Bytecode.Label(exitLabel));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a variable access into a simple variable load instruction
>, <Line: +	 * 
>, <Line: +	 * @param condition
>, <Line: +	 *            Operand to evaluate to see whether it is true or false
>, <Line: +	 * @param enclosing
>, <Line: +	 *            Enclosing context
>, <Line: +	 */
>, <Line: +	private void translateVariableAccess(Location<VariableAccess> expr, Context context) {		
>, <Line: +		JvmType type = context.toJvmType(expr.getType());
>, <Line: +		Location<VariableDeclaration> decl = getVariableDeclaration(expr);
>, <Line: +		context.add(new Bytecode.Load(decl.getIndex(), type));
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Constants
>, <Line: +	// ===============================================================================
>, <Line: +	/**
>, <Line: +	 * Translate a give constant value and load it onto the stack. Some of the
>, <Line: +	 * translations are more expensive that others. Primitive types (e.g. null,
>, <Line: +	 * bool, integer) can be loaded directly. Others require constructing
>, <Line: +	 * objects and should, ideally, be done only once.
>, <Line: +	 * 
>, <Line: +	 * @param v
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	private void translateConstant(Constant v, Context context) {
>, <Line: +		if (v instanceof Constant.Null) {
>, <Line: +			translateConstant((Constant.Null) v, context);
>, <Line: +		} else if (v instanceof Constant.Bool) {
>, <Line: +			translateConstant((Constant.Bool) v, context);
>, <Line: +		} else if (v instanceof Constant.Byte) {
>, <Line: +			translateConstant((Constant.Byte) v, context);
>, <Line: +		} else if (v instanceof Constant.Integer) {
>, <Line: +			translateConstant((Constant.Integer) v, context);
>, <Line: +		} else if (v instanceof Constant.Type) {
>, <Line: +			translateConstant((Constant.Type) v, context);
>, <Line: +		} else if (v instanceof Constant.Array) {
>, <Line: +			translateConstant((Constant.Array) v, context);
>, <Line: +		} else if (v instanceof Constant.Record) {
>, <Line: +			translateConstant((Constant.Record) v, context);
>, <Line: +		} else if (v instanceof Constant.FunctionOrMethod) {
>, <Line: +			translateConstant((Constant.FunctionOrMethod) v, context);
>, <Line: +		} else if (v instanceof Constant.Type) {
>, <Line: +			translateConstant((Constant.Type) v, context);
>, <Line: +		} else {
>, <Line: +			throw new IllegalArgumentException("unknown value encountered:" + v);
>, <Line: +	}
>, <Line: +	protected void translateConstant(Constant.Null e, Context context) {
>, <Line: +		context.add(new Bytecode.LoadConst(null));
>, <Line: +	}
>, <Line: +	protected void translateConstant(Constant.Bool e, Context context) {
>, <Line: +		context.add(new Bytecode.LoadConst(e.value()));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYBOOL, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +	protected void translateConstant(Constant.Type e, Context context) {
>, <Line: +		context.add(new Bytecode.LoadConst(jout.toString()));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYTYPE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +	protected void translateConstant(Constant.Byte e, Context context) {
>, <Line: +		context.add(new Bytecode.LoadConst(e.value()));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYBYTE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +	protected void translateConstant(Constant.Integer e, Context context) {
>, <Line: +			context.add(new Bytecode.LoadConst(num.intValue()));
>, <Line: +			context.add(new Bytecode.Conversion(T_INT, T_LONG));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +			context.add(new Bytecode.LoadConst(num.longValue()));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: +			context.add(new Bytecode.New(WHILEYINT));
>, <Line: +			context.add(new Bytecode.Dup(WHILEYINT));
>, <Line: +			context.add(new Bytecode.LoadConst(bytes.length));
>, <Line: +			context.add(new Bytecode.New(bat));
>, <Line: +				context.add(new Bytecode.Dup(bat));
>, <Line: +				context.add(new Bytecode.LoadConst(i));
>, <Line: +				context.add(new Bytecode.LoadConst(bytes[i]));
>, <Line: +				context.add(new Bytecode.ArrayStore(bat));
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYINT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: +	protected void translateConstant(Constant.Array lv, Context context) {
>, <Line: +		context.add(new Bytecode.New(WHILEYARRAY));
>, <Line: +		context.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: +		context.add(new Bytecode.LoadConst(lv.values().size()));
>, <Line: +		context.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: +			context.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: +			translateConstant(e, context);
>, <Line: +			context.addWriteConversion(e.type());
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.Pop(T_BOOL));
>, <Line: +	protected void translateConstant(Constant.Record expr, Context context) {
>, <Line: +		context.construct(WHILEYRECORD);
>, <Line: +			context.add(new Bytecode.Dup(WHILEYRECORD));
>, <Line: +			context.add(new Bytecode.LoadConst(e.getKey()));
>, <Line: +			translateConstant(e.getValue(), context);
>, <Line: +			context.addWriteConversion(et);
>, <Line: +			context.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: +			context.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
>, <Line: +	/**
>, <Line: +	 * Translate a constant representing a given function or method into an
>, <Line: +	 * instance of a special lambda class. The lambda class extends WyLambda and
>, <Line: +	 * looks just like any other lambda function. However, when invoked, it will
>, <Line: +	 * call the function or method determined by the class directly.
>, <Line: +	 */
>, <Line: +	protected void translateConstant(Constant.FunctionOrMethod c, Context context) {
>, <Line: +		// First, build the lambda
>, <Line: +		NameID target = c.name();
>, <Line: +		ClassFile lambda = buildLambda(getModuleClass(target.module()), target.name(), c.type());
>, <Line: +		lambdaClasses.add(lambda);
>, <Line: +		// Finally, construct an instance of the class itself
>, <Line: +		context.construct(lambda.type());
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Lambdas
>, <Line: +	// ===============================================================================
>, <Line: +	 * Create a method representing the body of a lambda. This will then be
>, <Line: +	 * called by the lambda class created from the LambdaTemplate. Creating a
>, <Line: +	 * method like this is not necessarily optimal, but it allows me to simplify
>, <Line: +	 * the translation process (e.g. as locations still correspond to register
>, <Line: +	 * numbers, etc).
>, <Line: +	 * @param lambdaMethod
>, <Line: +	 * @param context
>, <Line: +	public ClassFile.Method buildLambdaMethod(Location<Lambda> e, String lambdaMethod, Context context) {
>, <Line: +		Lambda l = e.getBytecode();
>, <Line: +		JvmType.Function type = buildLambdaMethodType(l.type(), e.getOperandGroup(1));
>, <Line: +		Context bodyContext = new Context();
>, <Line: +		// Move environment into correct register slots. First, push them all
>, <Line: +		// onto the stack
>, <Line: +		shiftLambdaMethodParameters(e.getOperandGroup(0), e.getOperandGroup(1), bodyContext);
>, <Line: +		// Translate the body of the lambda expression
>, <Line: +		translateExpression(e.getOperand(0), bodyContext);
>, <Line: +		// Add the return value (if applicable)
>, <Line: +		if (type.returnType() instanceof JvmType.Void) {
>, <Line: +			bodyContext.add(new Bytecode.Return(null));
>, <Line: +			bodyContext.add(new Bytecode.Return(type.returnType()));
>, <Line: +		}
>, <Line: +		// Create the method itself
>, <Line: +		String lambdaMethodMangled = nameMangle(lambdaMethod, l.type());
>, <Line: +		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_FINAL);
>, <Line: +		ClassFile.Method method = new ClassFile.Method(lambdaMethodMangled, type, modifiers);
>, <Line: +		// Add the code attribute
>, <Line: +		jasm.attributes.Code code = new jasm.attributes.Code(bodyContext.getBytecodes(), Collections.EMPTY_LIST,
>, <Line: +				method);
>, <Line: +		method.attributes().add(code);
>, <Line: +		//
>, <Line: +		return method;
>, <Line: +	 * Shift the parameters passed into this lambda method into the desired
>, <Line: +	 * target registers.
>, <Line: +	 * @param parameters
>, <Line: +	 *            Actual parameter of the lambda itself
>, <Line: +	 * @param environment
>, <Line: +	 *            Environment variables used from the enclosing scope within the
>, <Line: +	 *            lambda body
>, <Line: +	 * @param bodyContext
>, <Line: +	private void shiftLambdaMethodParameters(Location<?>[] parameters, Location<?>[] environment, Context bodyContext) {
>, <Line: +		parameters = append(parameters,environment);
>, <Line: +		for(int i=0;i!=parameters.length;++i) {
>, <Line: +			Location<?> p = parameters[i];
>, <Line: +			int slot = p.getIndex();
>, <Line: +			if(slot != i) {
>, <Line: +				bodyContext.add(new Bytecode.Load(i, toJvmType(p.getType())));
>, <Line: +		// Second, pop them all into the right register
>, <Line: +		for(int i=parameters.length-1;i>=0;--i) {
>, <Line: +			Location<?> p = parameters[i];
>, <Line: +			int slot = p.getIndex();
>, <Line: +			if(slot != i) {
>, <Line: +				bodyContext.add(new Bytecode.Store(slot, toJvmType(p.getType())));
>, <Line: +	 * Construct the true method type for a lambda body. This is the type of the
>, <Line: +	 * lambda itself, along with the types for any environment variables which
>, <Line: +	 * are required.
>, <Line: +	 * @param type
>, <Line: +	 * @param environment
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	public JvmType.Function buildLambdaMethodType(Type.FunctionOrMethod type, Location<?>[] environment) {
>, <Line: +		JvmType.Function jvmType = convertFunType(type);
>, <Line: +		ArrayList<JvmType> actualParameterTypes = new ArrayList<JvmType>(jvmType.parameterTypes());
>, <Line: +		for (int i = 0; i != environment.length; ++i) {
>, <Line: +			Location<?> loc = environment[i];
>, <Line: +			actualParameterTypes.add(toJvmType(loc.getType()));
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return new JvmType.Function(jvmType.returnType(), actualParameterTypes);
>, <Line: +	 * Determine the types for the environment variables of a lambda expression.
>, <Line: +	 * @param environment
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	public JvmType[] buildLambdaEnvironment(Location<?>[] environment) {
>, <Line: +		JvmType[] envTypes = new JvmType[environment.length];
>, <Line: +		for (int i = 0; i != environment.length; ++i) {
>, <Line: +			Location<?> loc = environment[i];
>, <Line: +			envTypes[i] = toJvmType(loc.getType());
>, <Line: +		return envTypes;
>, <Line: +	public ClassFile buildLambda(JvmType.Clazz targetClass, String targetMethod, Type.FunctionOrMethod type,
>, <Line: +			JvmType... environment) {
>, <Line: +		int lambda_id = lambdaClasses.size();
>, <Line: +		// Determine name of the lambda class. This class will extend class
>, <Line: +		// wyjc.runtime.WyLambda.
>, <Line: +		JvmType.Clazz lambdaClass = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
>, <Line: +				Integer.toString(lambda_id));
>, <Line: +		// Determine mangled name of function or method
>, <Line: +		String targetMethodMangled = nameMangle(targetMethod, type);
>, <Line: +		// Determine JvmType of function or method
>, <Line: +		JvmType.Function jvmType = convertFunType(type);
>, <Line: +		// Determine the Jvm types for the environment		
>, <Line: +		// Create the lambda template
>, <Line: +		LambdaTemplate template = new LambdaTemplate(CLASS_VERSION, lambdaClass, targetClass, targetMethodMangled,
>, <Line: +				jvmType, environment);
>, <Line: +		// Instantiate the template to generate the lambda class
>, <Line: +		return template.generateClass();
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Helpers
>, <Line: +	// ===============================================================================
>, <Line: +	public Location<VariableDeclaration> getVariableDeclaration(Location<?> decl) {
>, <Line: +		switch (decl.getOpcode()) {
>, <Line: +		case OPCODE_aliasdecl:
>, <Line: +		case OPCODE_varaccess:
>, <Line: +			return getVariableDeclaration(decl.getOperand(0));
>, <Line: +		case OPCODE_vardecl:
>, <Line: +		case OPCODE_vardeclinit:
>, <Line: +			return (Location<VariableDeclaration>) decl;
>, <Line: +		default:
>, <Line: +			throw new RuntimeException("internal failure --- dead code reached");
>, <Line: +	 * Create an invocation bytecode for a given WyIL function or method. This
>, <Line: +	 * is just a convenience method which takes care of name mangling, etc.
>, <Line: +	 * 
>, <Line: +	 * @param name
>, <Line: +	 *            Name and module of function or method to be invoked
>, <Line: +	 * @param type
>, <Line: +	 *            Type of function or method to be invoked
>, <Line: +	 * @return
>, <Line: +	public Bytecode.Invoke createMethodInvocation(NameID name, Type.FunctionOrMethod type) {
>, <Line: +		// Determine name of class corresponding to the given module
>, <Line: +		JvmType.Clazz owner = getModuleClass(name.module());
>, <Line: +		// Determine mangled name for function/method being invoked
>, <Line: +		String mangled = nameMangle(name.name(), type);
>, <Line: +		// Convert the type of the function/method being invoked
>, <Line: +		JvmType.Function fnType = convertFunType(type);
>, <Line: +		// Create the invocation!
>, <Line: +		return new Bytecode.Invoke(owner, mangled, fnType, Bytecode.InvokeMode.STATIC);
>, <Line: +	 * Given an object array on the stack, take everything out of it an leave it
>, <Line: +	 * on the stack. This is needed to help handle multiple returns which are
>, <Line: +	 * packaged into object arrays.
>, <Line: +	 * @param types
>, <Line: +	 *            The list of types which are stored in the object array
>, <Line: +	 * @param context
>, <Line: +	private void decodeOperandArray(List<Type> types, Context context) {
>, <Line: +		for (int i = 0; i != types.size(); ++i) {
>, <Line: +			Type type = types.get(i);
>, <Line: +			context.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +			context.add(new Bytecode.LoadConst(i));
>, <Line: +			context.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +			context.addReadConversion(type);
>, <Line: +			// At this point, we have the value on top of the stack and then the
>, <Line: +			// array reference. So, we can just swap them to get the desired
>, <Line: +			// order. 
>, <Line: +			context.add(new Bytecode.Swap());			
>, <Line: +		}
>, <Line: +		context.add(new Bytecode.Pop(JAVA_LANG_OBJECT_ARRAY));
>, <Line: +	}
>, <Line: +	public final static Type WHILEY_SYSTEM_T = Type
>, <Line: +			.Nominal(new NameID(Trie.fromString("whiley/lang/System"), "Console"));
>, <Line: +	public final static JvmType.Clazz WHILEYUTIL = new JvmType.Clazz("wyjc.runtime", "Util");
>, <Line: +	public final static JvmType.Clazz WHILEYARRAY = new JvmType.Clazz("wyjc.runtime", "WyArray");
>, <Line: +	public final static JvmType.Clazz WHILEYTYPE = new JvmType.Clazz("wyjc.runtime", "WyType");
>, <Line: +	public final static JvmType.Clazz WHILEYRECORD = new JvmType.Clazz("wyjc.runtime", "WyRecord");
>, <Line: +	public final static JvmType.Clazz WHILEYOBJECT = new JvmType.Clazz("wyjc.runtime", "WyObject");
>, <Line: +	public final static JvmType.Clazz WHILEYBOOL = new JvmType.Clazz("wyjc.runtime", "WyBool");
>, <Line: +	public final static JvmType.Clazz WHILEYBYTE = new JvmType.Clazz("wyjc.runtime", "WyByte");
>, <Line: +	public final static JvmType.Clazz WHILEYINT = new JvmType.Clazz("java.math", "BigInteger");
>, <Line: +	public final static JvmType.Clazz WHILEYLAMBDA = new JvmType.Clazz("wyjc.runtime", "WyLambda");
>, <Line: +	private static final JvmType.Clazz JAVA_LANG_CHARACTER = new JvmType.Clazz("java.lang", "Character");
>, <Line: +	private static final JvmType.Clazz JAVA_LANG_SYSTEM = new JvmType.Clazz("java.lang", "System");
>, <Line: +	private static final JvmType.Clazz JAVA_LANG_ITERABLE = new JvmType.Clazz("java.lang", "Iterable");
>, <Line: +	public static final JvmType.Array JAVA_LANG_OBJECT_ARRAY = new JvmType.Array(JAVA_LANG_OBJECT);
>, <Line: +	private static final JvmType.Clazz JAVA_UTIL_LIST = new JvmType.Clazz("java.util", "List");
>, <Line: +	private static final JvmType.Clazz JAVA_UTIL_SET = new JvmType.Clazz("java.util", "Set");
>, <Line: +	private static final JvmType.Clazz JAVA_IO_PRINTSTREAM = new JvmType.Clazz("java.io", "PrintStream");
>, <Line: +	private static final JvmType.Clazz JAVA_LANG_RUNTIMEEXCEPTION = new JvmType.Clazz("java.lang", "RuntimeException");
>, <Line: +	private static final JvmType.Clazz JAVA_LANG_ASSERTIONERROR = new JvmType.Clazz("java.lang", "AssertionError");
>, <Line: +	private static final JvmType.Clazz JAVA_UTIL_COLLECTION = new JvmType.Clazz("java.util", "Collection");
>, <Line: +			paramTypes.add(toJvmType(pt));
>, <Line: +		switch (ft.returns().size()) {
>, <Line: +			rt = toJvmType(ft.returns().get(0));
>, <Line: +	private JvmType toJvmType(Type t) {
>, <Line: +			for (Type bound : ut.bounds()) {
>, <Line: +				JvmType r = toJvmType(bound);
>, <Line: +				if (result == null) {
>, <Line: +				Type expanded = typeSystem.getUnderlyingType(t);
>, <Line: +				return toJvmType(expanded);
>, <Line: +			} catch (InternalFailure ex) {
>, <Line: +				throw ex;
>, <Line: +	/**
>, <Line: +	 * Get the JvmType.Clazz associated with a given WyIL module.
>, <Line: +	 * 
>, <Line: +	 * @param mid
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private JvmType.Clazz getModuleClass(Path.ID mid) {
>, <Line: +		return new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a list of modifiers from an array of (potentially null)
>, <Line: +	 * modifiers.
>, <Line: +	 * 
>, <Line: +	 * @param mods
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private static List<Modifier> modifiers(Modifier... mods) {
>, <Line: +		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: +		for (Modifier m : mods) {
>, <Line: +			if (m != null) {
>, <Line: +				modifiers.add(m);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return modifiers;
>, <Line: +	}
>, <Line: +	private static String typeMangle(Type.FunctionOrMethod ft) throws IOException {
>, <Line: +	private static <T> T[] append(T[] lhs, T... rhs) {
>, <Line: +		T[] noperands = Arrays.copyOf(lhs,lhs.length+rhs.length);		
>, <Line: +		System.arraycopy(rhs, 0, noperands, lhs.length, rhs.length);
>, <Line: +		return noperands;
>, <Line: +	}
>, <Line: +	private static int getFirstFreeRegister(SyntaxTree tree) {
>, <Line: +		return tree.getLocations().size();
>, <Line: +	}
>, <Line: +		public static int get(Constant value, HashMap<JvmConstant, Integer> constants) {
>, <Line: +	public class Context {
>, <Line: +		/**
>, <Line: +		 * The list of bytecodes that have been generated so far
>, <Line: +		 */
>, <Line: +		private final ArrayList<Bytecode> bytecodes;
>, <Line: +		/**
>, <Line: +		 * Determine the branch target for a break statement
>, <Line: +		 */
>, <Line: +		private final String breakLabel;
>, <Line: +		/**
>, <Line: +		 * Determine the branch target for a continue statement
>, <Line: +		 */
>, <Line: +		private final String continueLabel;
>, <Line: +		public Context() {
>, <Line: +			this(new ArrayList<Bytecode>(),null,null);
>, <Line: +		public Context(ArrayList<Bytecode> bytecodes, String breakLabel, String continueLabel) {
>, <Line: +			this.bytecodes = bytecodes;
>, <Line: +			this.breakLabel = breakLabel;
>, <Line: +			this.continueLabel = continueLabel;
>, <Line: +		public List<Bytecode> getBytecodes() {
>, <Line: +			return bytecodes;
>, <Line: +		public String getBreakLabel() {
>, <Line: +			return breakLabel;
>, <Line: +		public String getContinueLabel() {
>, <Line: +			return continueLabel;
>, <Line: +		}
>, <Line: +		public Context newLoopBlock(String breakLabel, String continueLabel) {
>, <Line: +			return new Context(bytecodes, breakLabel, continueLabel);
>, <Line: +		 * The write conversion is necessary in situations where we're write a value
>, <Line: +		 * from the stack into a collection (e.g. WhileyList, WhileySet, etc). In
>, <Line: +		 * such case, we need to convert boolean values from bool primitives to
>, <Line: +		 * Boolean objects.
>, <Line: +		public void addWriteConversion(Type type) {
>, <Line: +			// This currently does nothing since there are currently no data types
>, <Line: +			// implemented as primitives.
>, <Line: +		}
>, <Line: +		 * The read conversion is necessary in situations where we're reading a
>, <Line: +		 * value from a collection (e.g. WhileyList, WhileySet, etc) and then
>, <Line: +		 * putting it on the stack. In such case, we need to convert boolean values
>, <Line: +		 * from Boolean objects to bool primitives.
>, <Line: +		public void addReadConversion(Type type) {
>, <Line: +			// This doesn't do anything extra since there are currently no data
>, <Line: +			// types implemented as primitives.
>, <Line: +			addCheckCast(toJvmType(type));
>, <Line: +		}
>, <Line: +		private void addCheckCast(JvmType type) {
>, <Line: +			// The following can happen in situations where a variable has type
>, <Line: +			// void. In principle, we could remove this as obvious dead-code, but
>, <Line: +			// for now I just avoid it.
>, <Line: +			if (type instanceof JvmType.Void) {
>, <Line: +				return;
>, <Line: +			} else if (!type.equals(JAVA_LANG_OBJECT)) {
>, <Line: +				// pointless to add a cast for object
>, <Line: +				add(new Bytecode.CheckCast(type));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		 * The construct method provides a generic way to construct a Java object.
>, <Line: +		 *
>, <Line: +		 * @param owner
>, <Line: +		 * @param context
>, <Line: +		 * @param params
>, <Line: +		private void construct(JvmType.Clazz owner) {
>, <Line: +			add(new Bytecode.New(owner));
>, <Line: +			add(new Bytecode.Dup(owner));
>, <Line: +			ArrayList<JvmType> paramTypes = new ArrayList<JvmType>();
>, <Line: +			JvmType.Function ftype = new JvmType.Function(T_VOID, paramTypes);
>, <Line: +			add(new Bytecode.Invoke(owner, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: +		public JvmType toJvmType(Type type) {
>, <Line: +			return Wyil2JavaBuilder.this.toJvmType(type);
>, <Line: +		public Type.EffectiveArray expandAsEffectiveArray(Type type) throws ResolveError {
>, <Line: +			return typeSystem.expandAsEffectiveArray(type);
>, <Line: +		public Type.EffectiveRecord expandAsEffectiveRecord(Type type) throws ResolveError {
>, <Line: +			return typeSystem.expandAsEffectiveRecord(type);
>, <Line: +		public Type.Reference expandAsReference(Type type) throws ResolveError {
>, <Line: +			return typeSystem.expandAsReference(type);
>, <Line: +		public void add(Bytecode bytecode) {
>, <Line: +			bytecodes.add(bytecode);
>, <Line: +		void translate(Location<Operator> bytecode, Context context) throws ResolveError;
>]
[<Line: -import wyautl.util.BigRational;
>, <Line: -import wyil.attributes.SourceLocation;
>, <Line: -import wyil.util.TypeExpander;
>, <Line: -import jasm.attributes.Code.Handler;
>, <Line: -import jasm.util.Triple;
>, <Line: -	 * The type expander is useful for managing nominal types and converting
>, <Line: -	 * them into their underlying types.
>, <Line: -	protected final TypeExpander expander;
>, <Line: -	private ArrayList<ClassFile> lambdas;
>, <Line: -		this.expander = new TypeExpander(project);
>, <Line: -	public Set<Path.Entry<?>> build(
>, <Line: -			Collection<Pair<Path.Entry<?>, Path.Root>> delta)
>, <Line: -			throws IOException {
>, <Line: -			Path.Entry<ClassFile> df = dst.create(sf.id(),
>, <Line: -					WyjcBuildTask.ContentType);
>, <Line: -			lambdas = new ArrayList<ClassFile>();
>, <Line: -			ClassFile contents = build(sf.read());
>, <Line: -			// FIXME: deadCode elimination is currently unsafe because the
>, <Line: -			// LineNumberTable and Exceptions attributes do not deal with
>, <Line: -			// rewrites
>, <Line: -			// properly.
>, <Line: -			// eliminate any dead code that was introduced.
>, <Line: -			// new DeadCodeElimination().apply(file);
>, <Line: -			// new ClassFileVerifier().apply(contents);
>, <Line: -			// Finally, write out any lambda classes created to support the
>, <Line: -			// main class. This is necessary because every occurrence of a
>, <Line: -			// lambda expression in the WyilFile generates an inner class
>, <Line: -			// responsible for calling the given function.
>, <Line: -			for (int i = 0; i != lambdas.size(); ++i) {
>, <Line: -				Path.Entry<ClassFile> lf = dst.create(id,
>, <Line: -						WyjcBuildTask.ContentType);
>, <Line: -				lf.write(lambdas.get(i));
>, <Line: -		logger.logTimedMessage("Wyil => Java: compiled " + delta.size()
>, <Line: -				+ " file(s)", endTime - start, memory - runtime.freeMemory());
>, <Line: -		owner = new JvmType.Clazz(module.id().parent().toString()
>, <Line: -				.replace('.', '/'), module.id().last());
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		modifiers.add(Modifier.ACC_FINAL);
>, <Line: -		ClassFile cf = new ClassFile(CLASS_VERSION, owner, JAVA_LANG_OBJECT,
>, <Line: -				new ArrayList<JvmType.Clazz>(), modifiers);
>, <Line: -		buildConstants(constants, lambdas, cf);
>, <Line: -	private void buildConstants(HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<ClassFile> lambdas, ClassFile cf) {
>, <Line: -		buildCoercions(constants, cf);
>, <Line: -	private void buildCoercions(HashMap<JvmConstant, Integer> constants,
>, <Line: -			ClassFile cf) {
>, <Line: -		HashSet<JvmConstant> done = new HashSet<JvmConstant>();
>, <Line: -		HashMap<JvmConstant, Integer> original = constants;
>, <Line: -		// this could be a little more efficient I think!!
>, <Line: -		while (done.size() != constants.size()) {
>, <Line: -			// We have to clone the constants map, since it may be expanded as a
>, <Line: -			// result of buildCoercion(). This will occur if the coercion
>, <Line: -			// constructed requires a helper coercion that was not in the
>, <Line: -			// original constants map.
>, <Line: -			HashMap<JvmConstant, Integer> nconstants = new HashMap<JvmConstant, Integer>(
>, <Line: -					constants);
>, <Line: -			for (Map.Entry<JvmConstant, Integer> entry : constants.entrySet()) {
>, <Line: -				JvmConstant e = entry.getKey();
>, <Line: -				if (!done.contains(e) && e instanceof JvmCoercion) {
>, <Line: -					JvmCoercion c = (JvmCoercion) e;
>, <Line: -					buildCoercion(c.from, c.to, entry.getValue(), nconstants,
>, <Line: -							cf);
>, <Line: -				}
>, <Line: -				done.add(e);
>, <Line: -			}
>, <Line: -			constants = nconstants;
>, <Line: -		}
>, <Line: -		original.putAll(constants);
>, <Line: -	}
>, <Line: -	private void buildValues(HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<ClassFile> lambdas, ClassFile cf) {
>, <Line: -		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: -				ArrayList<Modifier> fmods = new ArrayList<Modifier>();
>, <Line: -				fmods.add(Modifier.ACC_PRIVATE);
>, <Line: -				fmods.add(Modifier.ACC_STATIC);
>, <Line: -				fmods.add(Modifier.ACC_FINAL);
>, <Line: -				JvmType type = convertUnderlyingType(constant.type());
>, <Line: -				translate(constant, 0, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.PutField(owner, name, type,
>, <Line: -						Bytecode.FieldMode.STATIC));
>, <Line: -			bytecodes.add(new Bytecode.Return(null));
>, <Line: -			ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -			modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -			modifiers.add(Modifier.ACC_STATIC);
>, <Line: -			modifiers.add(Modifier.ACC_SYNTHETIC);
>, <Line: -			ClassFile.Method clinit = new ClassFile.Method("<clinit>", ftype,
>, <Line: -					modifiers);
>, <Line: -			jasm.attributes.Code code = new jasm.attributes.Code(bytecodes,
>, <Line: -					new ArrayList(), clinit);
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		modifiers.add(Modifier.ACC_STATIC);
>, <Line: -		modifiers.add(Modifier.ACC_SYNTHETIC);
>, <Line: -		JvmType.Function ft1 = new JvmType.Function(T_VOID, new JvmType.Array(
>, <Line: -				JAVA_LANG_STRING));
>, <Line: -		ft1 = new JvmType.Function(WHILEYRECORD, new JvmType.Array(
>, <Line: -				JAVA_LANG_STRING));
>, <Line: -		codes.add(new Bytecode.Invoke(WHILEYUTIL, "systemConsole", ft1,
>, <Line: -				Bytecode.InvokeMode.STATIC));
>, <Line: -		Type.Method wyft = Type.Method(new Type[0], Collections.<String>emptySet(),
>, <Line: -				Collections.<String>emptyList(), WHILEY_SYSTEM_T);
>, <Line: -		codes.add(new Bytecode.Invoke(owner, nameMangle("main", wyft), ft3,
>, <Line: -				Bytecode.InvokeMode.STATIC));
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(codes,
>, <Line: -				new ArrayList(), cm);
>, <Line: -		JvmType underlyingType = convertUnderlyingType(td.type());
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		modifiers.add(Modifier.ACC_STATIC);
>, <Line: -		modifiers.add(Modifier.ACC_SYNTHETIC);
>, <Line: -		ClassFile.Method cm = new ClassFile.Method(td.name() + "$typeof",
>, <Line: -				funType, modifiers);
>, <Line: -		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: -		// First, generate code for testing elements of type (if any)
>, <Line: -		String falseBranch = freshLabel();
>, <Line: -		// FIXME: this is inefficient in cases where there are no invariants in
>, <Line: -		// component types (e.g. there are no component types).
>, <Line: -		translateInvariantTest(falseBranch, td.type(), 0, 1, constants, bytecodes);
>, <Line: -		// Second, generate code for invariant (if applicable).
>, <Line: -		// FIXME: use of patchInvariantBlock is not ideal
>, <Line: -		BytecodeForest invariant = patchInvariantBlock(falseBranch, td.invariant());
>, <Line: -		for(int i=0;i!=invariant.numRoots();++i) {				
>, <Line: -			translate(invariant.getRoot(i), 1, invariant, bytecodes);
>, <Line: -		}
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(true));
>, <Line: -		bytecodes.add(new Bytecode.Return(new JvmType.Bool()));
>, <Line: -		bytecodes.add(new Bytecode.Label(falseBranch));
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(false));
>, <Line: -		bytecodes.add(new Bytecode.Return(new JvmType.Bool()));
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes,
>, <Line: -				new ArrayList(), cm);
>, <Line: -	/**
>, <Line: -	 * Update the invariant block to replace fail and return statements with
>, <Line: -	 * goto's and nops (respectively).
>, <Line: -	 * 
>, <Line: -	 * @param falseBranch
>, <Line: -	 * @param forest
>, <Line: -	 */
>, <Line: -	private BytecodeForest patchInvariantBlock(String falseBranch, BytecodeForest forest) {
>, <Line: -		BytecodeForest nForest = new BytecodeForest(forest);
>, <Line: -		for(int i=0;i!=forest.numBlocks();++i) {
>, <Line: -			patchInvariantBlockHelper(falseBranch, nForest.get(i));
>, <Line: -		}
>, <Line: -		return nForest;
>, <Line: -	}
>, <Line: -	private void patchInvariantBlockHelper(String falseBranch, BytecodeForest.Block block) {
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			// This is still a valid index
>, <Line: -			BytecodeForest.Entry e = block.get(i);
>, <Line: -			wyil.lang.Bytecode c = e.code();
>, <Line: -			if (c instanceof Return) {
>, <Line: -				// first patch point
>, <Line: -				block.set(i, new Operator(Type.T_VOID, new int[0], new int[0], OperatorKind.ASSIGN));
>, <Line: -			} else if (c instanceof Fail) {
>, <Line: -				// second patch point
>, <Line: -				block.set(i, new Goto(falseBranch));
>, <Line: -			} 
>, <Line: -		}
>, <Line: -	}
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		if (method.hasModifier(wyil.lang.Modifier.PUBLIC)
>, <Line: -				|| method.hasModifier(wyil.lang.Modifier.PUBLIC)) {
>, <Line: -			modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		}
>, <Line: -		modifiers.add(Modifier.ACC_STATIC);
>, <Line: -		ArrayList<Bytecode> codes;
>, <Line: -		codes = translateNativeOrExport(method);
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(codes,
>, <Line: -				Collections.EMPTY_LIST, cm);
>, <Line: -	private ArrayList<Bytecode> translateNativeOrExport(
>, <Line: -			WyilFile.FunctionOrMethod method) {
>, <Line: -			bytecodes.add(new Bytecode.Load(slot++,
>, <Line: -					convertUnderlyingType(param)));
>, <Line: -			JvmType.Clazz redirect = new JvmType.Clazz(owner.pkg(), owner
>, <Line: -					.components().get(0).first(), "native");
>, <Line: -			bytecodes.add(new Bytecode.Invoke(redirect, method.name(),
>, <Line: -					convertFunType(ft), Bytecode.InvokeMode.STATIC));
>, <Line: -			JvmType.Clazz redirect = new JvmType.Clazz(owner.pkg(), owner
>, <Line: -					.components().get(0).first());
>, <Line: -			bytecodes.add(new Bytecode.Invoke(redirect, nameMangle(
>, <Line: -					method.name(), method.type()), convertFunType(ft),
>, <Line: -					Bytecode.InvokeMode.STATIC));
>, <Line: -		if (ft.returns().isEmpty()) {
>, <Line: -			bytecodes.add(new Bytecode.Return(null));
>, <Line: -		} else {
>, <Line: -			bytecodes.add(new Bytecode.Return(convertUnderlyingType(ft.returns().get(0))));
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		if (method.hasModifier(wyil.lang.Modifier.PUBLIC)) {
>, <Line: -			modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		}
>, <Line: -		modifiers.add(Modifier.ACC_STATIC);
>, <Line: -		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: -		BytecodeForest forest = method.code();
>, <Line: -		translate(method.body(), forest.numRegisters(), forest, bytecodes);
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes,
>, <Line: -				Collections.EMPTY_LIST, cm);
>, <Line: -	 * Translate the given block into bytecodes.
>, <Line: -	 * @param blk
>, <Line: -	 *            --- wyil block to be translated.
>, <Line: -	 * @param freeSlot
>, <Line: -	 *            --- identifies the first unsused bytecode register.
>, <Line: -	 * @param bytecodes
>, <Line: -	 *            --- list to insert bytecodes into *
>, <Line: -	private void translate(int blk, int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		translate(new BytecodeForest.Index(blk, 0), freeSlot, forest, bytecodes);
>, <Line: -	 * @param freeSlot
>, <Line: -	 *            First available free slot
>, <Line: -	private void translate(BytecodeForest.Index pc, int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		BytecodeForest.Block block = forest.get(pc.block());
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			BytecodeForest.Index index = new BytecodeForest.Index(pc.block(), i);
>, <Line: -			SourceLocation loc = forest.get(index).attribute(SourceLocation.class);
>, <Line: -			if (loc != null) {
>, <Line: -				// FIXME: figure our how to get line number!
>, <Line: -				// lineNumbers.add(new
>, <Line: -				// LineNumberTable.Entry(bytecodes.size(),loc.line));
>, <Line: -			}
>, <Line: -			freeSlot = translate(index, block.get(i).code(), freeSlot, forest, bytecodes);
>, <Line: -	 * @param pc
>, <Line: -	 *            The index of the WyIL bytecode being translated in the
>, <Line: -	 *            forest.
>, <Line: -	 * @param code
>, <Line: -	 *            The WyIL bytecode being translated.
>, <Line: -	 * @param freeSlot
>, <Line: -	 *            The first available free JVM register slot
>, <Line: -	 * @param bytecodes
>, <Line: -	 *            The list of bytecodes being accumulated
>, <Line: -	 * @return
>, <Line: -	private int translate(BytecodeForest.Index pc, wyil.lang.Bytecode code, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -			if (code instanceof Operator) {
>, <Line: -				translate(pc, (Operator) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Convert) {
>, <Line: -				translate(pc, (Convert) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Const) {
>, <Line: -				translate(pc, (Const) code, freeSlot, forest,bytecodes);
>, <Line: -			} else if (code instanceof Debug) {
>, <Line: -				translate(pc, (Debug) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof AssertOrAssume) {
>, <Line: -				translate(pc, (AssertOrAssume) code, freeSlot, forest,
>, <Line: -						bytecodes);
>, <Line: -			} else if (code instanceof Fail) {
>, <Line: -				translate(pc, (Fail) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof FieldLoad) {
>, <Line: -				translate(pc, (FieldLoad) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Quantify) {
>, <Line: -				freeSlot = translate(pc, (Quantify) code, freeSlot,
>, <Line: -						 forest, bytecodes);
>, <Line: -			} else if (code instanceof Goto) {
>, <Line: -				translate(pc, (Goto) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof If) {
>, <Line: -				translateIfGoto(pc, (If) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof IfIs) {
>, <Line: -				translate(pc, (IfIs) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof IndirectInvoke) {
>, <Line: -				translate(pc, (IndirectInvoke) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Invoke) {
>, <Line: -				translate(pc, (Invoke) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Label) {
>, <Line: -				translate(pc, (Label) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Lambda) {
>, <Line: -				translate(pc, (Lambda) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Loop) {
>, <Line: -				translate(pc, (Loop) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Update) {
>, <Line: -				translate(pc, (Update) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Return) {
>, <Line: -				translate(pc, (Return) code, freeSlot, forest, bytecodes);
>, <Line: -			} else if (code instanceof Switch) {
>, <Line: -				translate(pc, (Switch) code, freeSlot, forest, bytecodes);
>, <Line: -			} else {
>, <Line: -				internalFailure("unknown wyil code encountered (" + code + ")",
>, <Line: -						filename,
>, <Line: -						forest.get(pc).attribute(SourceLocation.class));
>, <Line: -			internalFailure(ex.getMessage(), filename, ex,
>, <Line: -					forest.get(pc).attribute(SourceLocation.class));
>, <Line: -		return freeSlot;
>, <Line: -	private void translate(BytecodeForest.Index index, AssertOrAssume c,
>, <Line: -			int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		BytecodeForest.Index pc = new BytecodeForest.Index(c.block(), 0);
>, <Line: -		if(c instanceof Invariant) {
>, <Line: -			// essentially a no-op for now			
>, <Line: -		} else {
>, <Line: -			translate(pc, freeSlot, forest, bytecodes);
>, <Line: -	private void translate(BytecodeForest.Index index, Const c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		Constant constant = c.constant();
>, <Line: -		JvmType jt = convertUnderlyingType(constant.type());
>, <Line: -		if (constant instanceof Constant.Bool
>, <Line: -				|| constant instanceof Constant.Null
>, <Line: -				|| constant instanceof Constant.Byte) {
>, <Line: -			translate(constant, freeSlot, bytecodes);
>, <Line: -			int id = JvmValue.get(constant, constants);
>, <Line: -			String name = "constant$" + id;
>, <Line: -			bytecodes.add(new Bytecode.GetField(owner, name, jt,
>, <Line: -					Bytecode.FieldMode.STATIC));
>, <Line: -		bytecodes.add(new Bytecode.Store(c.target(), jt));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Convert c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -		addCoercion(c.type(0), c.result(), freeSlot, constants, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.result())));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Update code, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Load(code.target(0), convertUnderlyingType(code.type(0))));
>, <Line: -		translateUpdate(code.iterator(), code, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(code.target(0), convertUnderlyingType(code.afterType())));
>, <Line: -	 * @param code
>, <Line: -	 *            --- The enclosing bytecode.
>, <Line: -	 * @param bytecodes
>, <Line: -	 *            --- List of bytecodes to append to.
>, <Line: -	private void translateUpdate(Iterator<LVal> iterator,
>, <Line: -			Update code, ArrayList<Bytecode> bytecodes) {
>, <Line: -		LVal lv = iterator.next();
>, <Line: -		if (lv instanceof ArrayLVal) {
>, <Line: -			translateUpdate((ArrayLVal) lv,iterator,code,bytecodes);
>, <Line: -		} else if (lv instanceof RecordLVal) {
>, <Line: -			translateUpdate((RecordLVal) lv,iterator,code,bytecodes);
>, <Line: -			translateUpdate((ReferenceLVal) lv,iterator,code,bytecodes);
>, <Line: -	private void translateUpdate(ArrayLVal lval, Iterator<LVal> iterator, Update code,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		if(iterator.hasNext()) {
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: -			bytecodes.add(new Bytecode.Load(lval.indexOperand, WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
>, <Line: -			addReadConversion(lval.rawType().element(), bytecodes);
>, <Line: -			translateUpdate(iterator, code, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Load(lval.indexOperand, WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.Swap());
>, <Line: -			bytecodes.add(new Bytecode.Load(lval.indexOperand, WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.Load(code.result(), convertUnderlyingType(lval.rawType().element())));
>, <Line: -			addWriteConversion(code.rhs(), bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "set", setFunType, Bytecode.InvokeMode.STATIC));
>, <Line: -	private void translateUpdate(RecordLVal lval, Iterator<LVal> iterator, Update code,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		Type.EffectiveRecord type = lval.rawType();
>, <Line: -		if(iterator.hasNext()) {
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYRECORD));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(lval.field));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
>, <Line: -			addReadConversion(type.field(lval.field), bytecodes);
>, <Line: -			translateUpdate(iterator, code, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(lval.field));
>, <Line: -			bytecodes.add(new Bytecode.Swap());		
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(lval.field));
>, <Line: -			bytecodes.add(new Bytecode.Load(code.result(), convertUnderlyingType(type.field(lval.field))));
>, <Line: -			addWriteConversion(type.field(lval.field), bytecodes);
>, <Line: -		JvmType.Function putFunType = new JvmType.Function(WHILEYRECORD, WHILEYRECORD, JAVA_LANG_STRING, JAVA_LANG_OBJECT);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", putFunType, Bytecode.InvokeMode.STATIC));
>, <Line: -	private void translateUpdate(ReferenceLVal lval, Iterator<LVal> iterator, Update code,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		if(iterator.hasNext()) {
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYOBJECT));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "state", getFunType, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			addReadConversion(lval.rawType().element(), bytecodes);
>, <Line: -			translateUpdate(iterator, code, bytecodes);
>, <Line: -			JvmType rhsJvmType = convertUnderlyingType(code.rhs());
>, <Line: -			bytecodes.add(new Bytecode.Load(code.result(),rhsJvmType));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "setState", setFunType, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Return c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		JvmType jt = null;
>, <Line: -		int[] operands = c.operands();
>, <Line: -		 if(operands.length == 1) {
>, <Line: -			jt = convertUnderlyingType(c.type(0));
>, <Line: -			bytecodes.add(new Bytecode.Load(operands[0], jt));
>, <Line: -			bytecodes.add(new Bytecode.Return(jt));
>, <Line: -		} else if(operands.length > 1){
>, <Line: -			jt = JAVA_LANG_OBJECT_ARRAY;
>, <Line: -			encodeOperandArray(c.types(),c.operands(),bytecodes);			
>, <Line: -		}
>, <Line: -		bytecodes.add(new Bytecode.Return(jt));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Switch c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		ArrayList<jasm.util.Pair<Integer, String>> cases = new ArrayList();
>, <Line: -		boolean canUseSwitchBytecode = true;
>, <Line: -		for (Pair<Constant, String> p : c.branches()) {
>, <Line: -			// first, check whether the switch value is indeed an integer.
>, <Line: -			Constant v = (Constant) p.first();
>, <Line: -			if (!(v instanceof Constant.Integer)) {
>, <Line: -				canUseSwitchBytecode = false;
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			// second, check whether integer value can fit into a Java int
>, <Line: -			Constant.Integer vi = (Constant.Integer) v;
>, <Line: -			int iv = vi.value().intValue();
>, <Line: -			if (!BigInteger.valueOf(iv).equals(vi.value())) {
>, <Line: -				canUseSwitchBytecode = false;
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			// ok, we're all good so far
>, <Line: -			cases.add(new jasm.util.Pair(iv, p.second()));
>, <Line: -		}
>, <Line: -		if (canUseSwitchBytecode) {
>, <Line: -			JvmType.Function ftype = new JvmType.Function(T_INT);
>, <Line: -			bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "intValue", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			bytecodes.add(new Bytecode.Switch(c.defaultTarget(), cases));
>, <Line: -		} else {
>, <Line: -			// ok, in this case we have to fall back to series of the if
>, <Line: -			// conditions. Not ideal.
>, <Line: -			for (Pair<Constant, String> p : c.branches()) {
>, <Line: -				Constant value = p.first();
>, <Line: -				String target = p.second();
>, <Line: -				translate(value, freeSlot, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -				JvmType.Function ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
>, <Line: -				bytecodes.add(new Bytecode.Invoke(WHILEYUTIL, "equals", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -				bytecodes.add(new Bytecode.If(Bytecode.IfMode.NE, target));
>, <Line: -			}
>, <Line: -			bytecodes.add(new Bytecode.Goto(c.defaultTarget()));
>, <Line: -		}
>, <Line: -	private void translateIfGoto(BytecodeForest.Index index, If code, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		JvmType jt = convertUnderlyingType(code.type(0));
>, <Line: -		bytecodes.add(new Bytecode.Load(code.operand(0), jt));
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_BOOL);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYBOOL, "value", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -		bytecodes.add(new Bytecode.If(Bytecode.IfMode.NE, code.destination()));
>, <Line: -	private void translate(BytecodeForest.Index index, IfIs c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		// In this case, we're updating the type of a local variable. To
>, <Line: -		// make this work, we must update the JVM type of that slot as well
>, <Line: -		// using a checkcast on both branches. The key challenge here lies with
>, <Line: -		// the resulting types on the true and false branches of the
>, <Line: -		// conditional. These are critical to determining the correct type to
>, <Line: -		// cast the variable's contents to. The presence of constrained types
>, <Line: -		// complicates this. For example, consider:
>, <Line: -		//
>, <Line: -		// <pre>
>, <Line: -		// type nat is (int n) where n >= 0
>, <Line: -		//
>, <Line: -		// function f(int|bool|null x) -> bool:
>, <Line: -		// if x is nat|bool:
>, <Line: -		// ...
>, <Line: -		// else:
>, <Line: -		// ...
>, <Line: -		// </pre>
>, <Line: -		//
>, <Line: -		// Here, the type of x on the true branch is int|bool, whilst on the
>, <Line: -		// false
>, <Line: -		// branch it is int|null. To correctly handle this, we need to determine
>, <Line: -		// maximal type which is fully consumed by another. In this case, the
>, <Line: -		// maximal type fully consumed by nat|bool is bool and, hence, the type
>, <Line: -		// on the false branch is int|bool|null - bool == int|null.
>, <Line: -		//
>, <Line: -		// First, calculate the underlying and maximal consumed types, which
>, <Line: -		// we'll need later.
>, <Line: -		Type targetType = c.rightOperand();
>, <Line: -		Type maximalConsumedType;
>, <Line: -		Type underlyingType;
>, <Line: -		try {
>, <Line: -			maximalConsumedType = expander.getMaximallyConsumedType(targetType);
>, <Line: -			underlyingType = expander.getUnderlyingType(targetType);
>, <Line: -		} catch (Exception e) {
>, <Line: -			internalFailure("error computing maximally consumed type: " + targetType, filename, e);
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		// The false label will determine the destination where the variable
>, <Line: -		// will be retyped on the false branch begins.
>, <Line: -		String falseLabel = freshLabel();
>, <Line: -		// Second, translate the raw type test. This will direct all values
>, <Line: -		// matching the underlying type towards the step label. At that point,
>, <Line: -		// we need to check whether the necessary constrained (if applicable)
>, <Line: -		// are met.
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -		translateTypeTest(falseLabel, underlyingType, constants, bytecodes);
>, <Line: -		// Third, update the type of the variable on the true branch. This is
>, <Line: -		// the intersection of its original type with that of the test to
>, <Line: -		// produce the most precise type possible.
>, <Line: -		Type typeOnTrueBranch = Type.intersect(c.type(0), underlyingType);
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -		addReadConversion(typeOnTrueBranch, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(c.operand(0), convertUnderlyingType(typeOnTrueBranch)));
>, <Line: -		// Fourth handle constrained types by invoking a function which will
>, <Line: -		// execute any and all constraints associated with the type. For
>, <Line: -		// recursive types, this may result in recursive calls.
>, <Line: -		translateInvariantTest(falseLabel, targetType, c.operand(0), freeSlot, constants, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Goto(c.destination()));
>, <Line: -		// Finally, construct false branch and retype the variable on the false
>, <Line: -		// branch to ensure it has the most precise type we know at this point.
>, <Line: -		bytecodes.add(new Bytecode.Label(falseLabel));
>, <Line: -		Type typeOnFalseBranch = Type.intersect(c.type(0), Type.Negation(maximalConsumedType));
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
>, <Line: -		addReadConversion(typeOnFalseBranch, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(c.operand(0), convertUnderlyingType(typeOnFalseBranch)));
>, <Line: -	}
>, <Line: -	// The purpose of this method is to translate a type test. We're testing to
>, <Line: -	// see whether what's on the top of the stack (the value) is a subtype of
>, <Line: -	// the type being tested. Note, constants must be provided as a parameter
>, <Line: -	// since this function may be called from buildCoercion()
>, <Line: -	protected void translateTypeTest(String falseTarget, Type test,
>, <Line: -			HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// First, try for the easy cases
>, <Line: -		if (test instanceof Type.Null) {
>, <Line: -			// Easy case
>, <Line: -			bytecodes
>, <Line: -					.add(new Bytecode.If(Bytecode.IfMode.NONNULL, falseTarget));
>, <Line: -		} else if (test instanceof Type.Bool) {
>, <Line: -			bytecodes.add(new Bytecode.InstanceOf(WHILEYBOOL));
>, <Line: -			bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
>, <Line: -		} else if (test instanceof Type.Int) {
>, <Line: -			bytecodes.add(new Bytecode.InstanceOf(WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
>, <Line: -			// Fall-back to an external (recursive) check
>, <Line: -			Constant constant = new Constant.Type(test);
>, <Line: -			int id = JvmValue.get(constant, constants);
>, <Line: -			String name = "constant$" + id;
>, <Line: -			bytecodes.add(new Bytecode.GetField(owner, name, WHILEYTYPE,
>, <Line: -					Bytecode.FieldMode.STATIC));
>, <Line: -			JvmType.Function ftype = new JvmType.Function(T_BOOL,
>, <Line: -					JAVA_LANG_OBJECT, WHILEYTYPE);
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYUTIL, "instanceOf", ftype,
>, <Line: -					Bytecode.InvokeMode.STATIC));
>, <Line: -			bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
>, <Line: -	private void translateInvariantTest(String falseTarget, Type type, int rootSlot, int freeSlot,
>, <Line: -			HashMap<JvmConstant, Integer> constants, ArrayList<Bytecode> bytecodes) {
>, <Line: -		//
>, <Line: -		JvmType underlyingType = convertUnderlyingType(type);
>, <Line: -		if (type instanceof Type.Nominal) {
>, <Line: -			Type.Nominal c = (Type.Nominal) type;
>, <Line: -			Path.ID mid = c.name().module();
>, <Line: -			JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
>, <Line: -			JvmType.Function fnType = new JvmType.Function(new JvmType.Bool(), convertUnderlyingType(c));
>, <Line: -			bytecodes.add(new Bytecode.Load(rootSlot, convertUnderlyingType(type)));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(owner, c.name().name() + "$typeof", fnType, Bytecode.InvokeMode.STATIC));
>, <Line: -			bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
>, <Line: -		} else if (type instanceof Type.Leaf) {
>, <Line: -			// Do nout
>, <Line: -		} else if (type instanceof Type.Reference) {
>, <Line: -			Type.Reference rt = (Type.Reference) type;
>, <Line: -			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT);
>, <Line: -			bytecodes.add(new Bytecode.Load(rootSlot, underlyingType));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			addReadConversion(rt.element(), bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Store(freeSlot, convertUnderlyingType(rt.element())));
>, <Line: -			translateInvariantTest(falseTarget, rt.element(), freeSlot, freeSlot + 1, constants, bytecodes);
>, <Line: -		} else if (type instanceof Type.EffectiveArray) {
>, <Line: -			Type.EffectiveArray ts = (Type.EffectiveArray) type;
>, <Line: -			Triple<String, String, String> loopLabels = translateLoopBegin(bytecodes, rootSlot, freeSlot);
>, <Line: -			addReadConversion(ts.element(), bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Store(freeSlot + 1, convertUnderlyingType(ts.element())));
>, <Line: -			translateInvariantTest(falseTarget, ts.element(), freeSlot + 1, freeSlot + 2, constants, bytecodes);
>, <Line: -			translateLoopEnd(bytecodes, loopLabels);
>, <Line: -		} else if (type instanceof Type.Record) {
>, <Line: -			Type.Record tt = (Type.Record) type;
>, <Line: -			HashMap<String, Type> fields = tt.fields();
>, <Line: -			ArrayList<String> fieldNames = new ArrayList<>(fields.keySet());
>, <Line: -			Collections.sort(fieldNames);
>, <Line: -			for (int i = 0; i != fieldNames.size(); ++i) {
>, <Line: -				String field = fieldNames.get(i);
>, <Line: -				Type fieldType = fields.get(field);
>, <Line: -				JvmType underlyingFieldType = convertUnderlyingType(fieldType);
>, <Line: -				bytecodes.add(new Bytecode.Load(rootSlot, underlyingType));
>, <Line: -				bytecodes.add(new Bytecode.LoadConst(field));
>, <Line: -				JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_STRING);
>, <Line: -				bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -				addReadConversion(fieldType, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.Store(freeSlot, underlyingFieldType));
>, <Line: -				translateInvariantTest(falseTarget, fieldType, freeSlot, freeSlot + 1, constants, bytecodes);
>, <Line: -			}
>, <Line: -		} else if (type instanceof Type.FunctionOrMethod) {
>, <Line: -			// FIXME: this is clearly a bug. However, it's not completely
>, <Line: -			// straightforward to fix, since there is currently no way to get
>, <Line: -			// runtime type information about a function or method reference. In
>, <Line: -			// principle, this could be encoded in the WyLambda in some way.
>, <Line: -		} else if (type instanceof Type.Negation) {
>, <Line: -			Type.Reference rt = (Type.Reference) type;
>, <Line: -			String trueTarget = freshLabel();
>, <Line: -			translateInvariantTest(trueTarget, rt.element(), rootSlot, freeSlot, constants, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Goto(falseTarget));
>, <Line: -			bytecodes.add(new Bytecode.Label(trueTarget));
>, <Line: -		} else if (type instanceof Type.Union) {
>, <Line: -			Type.Union ut = (Type.Union) type;
>, <Line: -			String trueLabel = freshLabel();
>, <Line: -			for (Type bound : ut.bounds()) {
>, <Line: -				try {
>, <Line: -					Type underlyingBound = expander.getUnderlyingType(bound);
>, <Line: -					String nextLabel = freshLabel();
>, <Line: -					bytecodes.add(new Bytecode.Load(rootSlot, convertUnderlyingType(type)));
>, <Line: -					translateTypeTest(nextLabel, underlyingBound, constants, bytecodes);
>, <Line: -					bytecodes.add(new Bytecode.Load(rootSlot, convertUnderlyingType(type)));
>, <Line: -					addReadConversion(bound, bytecodes);
>, <Line: -					bytecodes.add(new Bytecode.Store(freeSlot, convertUnderlyingType(bound)));
>, <Line: -					translateInvariantTest(nextLabel, bound, freeSlot, freeSlot + 1, constants, bytecodes);
>, <Line: -					bytecodes.add(new Bytecode.Goto(trueLabel));
>, <Line: -					bytecodes.add(new Bytecode.Label(nextLabel));
>, <Line: -				} catch (ResolveError e) {
>, <Line: -					internalFailure(e.getMessage(), filename, e);
>, <Line: -				} catch (IOException e) {
>, <Line: -					internalFailure(e.getMessage(), filename, e);
>, <Line: -				}
>, <Line: -			bytecodes.add(new Bytecode.Goto(falseTarget));
>, <Line: -			bytecodes.add(new Bytecode.Label(trueLabel));
>, <Line: -		} else {
>, <Line: -			internalFailure("unknown type encountered: " + type, filename);
>, <Line: -	private void translate(BytecodeForest.Index index, Loop c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// Allocate header label for loop
>, <Line: -		String loopHeader = freshLabel();
>, <Line: -		bytecodes.add(new Bytecode.Label(loopHeader));
>, <Line: -		// Translate body of loop. The cast is required to ensure correct method
>, <Line: -		// is called.
>, <Line: -		translate(new BytecodeForest.Index(c.block(), 0), freeSlot, forest, bytecodes);
>, <Line: -		// Terminate loop by branching back to head of loop
>, <Line: -		bytecodes.add(new Bytecode.Goto(loopHeader));
>, <Line: -	}
>, <Line: -	private int translate(BytecodeForest.Index index, Quantify c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Load(c.startOperand(), WHILEYINT));
>, <Line: -		bytecodes.add(new Bytecode.Load(c.endOperand(), WHILEYINT));
>, <Line: -		JvmType.Function ftype = new JvmType.Function(WHILEYARRAY, WHILEYINT, WHILEYINT);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "range", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -		ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_COLLECTION, "iterator", ftype, Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		String loopHeader = freshLabel();
>, <Line: -		String loopExit = freshLabel();
>, <Line: -		bytecodes.add(new Bytecode.Label(loopHeader));
>, <Line: -		ftype = new JvmType.Function(T_BOOL);
>, <Line: -		bytecodes.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext", ftype, Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, loopExit));
>, <Line: -		bytecodes.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		ftype = new JvmType.Function(JAVA_LANG_OBJECT);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next", ftype, Bytecode.InvokeMode.INTERFACE));
>, <Line: -		addReadConversion(Type.T_INT, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(c.indexOperand(), convertUnderlyingType(Type.T_INT)));
>, <Line: -		// Translate body of loop. The cast is required to ensure correct method
>, <Line: -		// is called.
>, <Line: -		translate(new BytecodeForest.Index(c.block(), 0), freeSlot + 1, forest, bytecodes);
>, <Line: -		// Terminate loop by branching back to head of loop
>, <Line: -		bytecodes.add(new Bytecode.Goto(loopHeader));
>, <Line: -		bytecodes.add(new Bytecode.Label(loopExit));
>, <Line: -		return freeSlot;
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Goto c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Goto(c.destination()));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Label c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Label(c.label()));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Debug c, int freeSlot,
>, <Line: -			BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_VOID, WHILEYARRAY);
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYUTIL, "print", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Fail c, int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.New(JAVA_LANG_RUNTIMEEXCEPTION));
>, <Line: -		bytecodes.add(new Bytecode.Dup(JAVA_LANG_RUNTIMEEXCEPTION));
>, <Line: -		bytecodes.add(new Bytecode.LoadConst("runtime fault encountered"));
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_STRING);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_RUNTIMEEXCEPTION, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -		bytecodes.add(new Bytecode.Throw());
>, <Line: -	private void translate(BytecodeForest.Index index, FieldLoad c, int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYRECORD));
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(c.fieldName()));
>, <Line: -		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYRECORD, JAVA_LANG_STRING);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -		addReadConversion(c.fieldType(), bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.fieldType())));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Operator c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		Context context = new Context(forest, index, freeSlot, bytecodes);
>, <Line: -		generators[c.opcode()].translate(c, context);
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Lambda c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// First, build and register lambda class which calls the given function
>, <Line: -		// or method. This class will extend class wyjc.runtime.WyLambda.
>, <Line: -		Type.FunctionOrMethod lamType = (Type.FunctionOrMethod) c.type(0); 
>, <Line: -		int lambda_id = lambdas.size();
>, <Line: -		lambdas.add(buildLambda(c.name(), lamType, lambda_id));
>, <Line: -		// Second, create and duplicate new lambda object. This will then stay
>, <Line: -		// on the stack (whilst the parameters are constructed) until the
>, <Line: -		// object's constructor is called.
>, <Line: -		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner
>, <Line: -				.lastComponent().first(), Integer.toString(lambda_id));
>, <Line: -		bytecodes.add(new Bytecode.New(lambdaClassType));
>, <Line: -		bytecodes.add(new Bytecode.Dup(lambdaClassType));
>, <Line: -		// Third, construct the parameter for lambda class constructor. In the
>, <Line: -		// case that a binding is given for this lambda, then we need to supply
>, <Line: -		// this as an argument to the lambda class constructor; otherwise, we
>, <Line: -		// just pass null. To do this, we first check whether or not a binding
>, <Line: -		// is required.
>, <Line: -		int[] c_operands = c.operands();
>, <Line: -		if (c_operands.length > 0) {
>, <Line: -			// Yes, binding is required.				
>, <Line: -			int numParams = lamType.params().size();
>, <Line: -			int numBlanks = numParams - c_operands.length;
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(numParams));
>, <Line: -			bytecodes.add(new Bytecode.New(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -			for(int i=0;i<numParams;++i) {
>, <Line: -				bytecodes.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));				
>, <Line: -				bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: -				if(i < numBlanks) {
>, <Line: -					bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: -				} else {
>, <Line: -					int operand = c.operands()[i-numBlanks];
>, <Line: -					Type pt = c.type(0).params().get(i);
>, <Line: -					bytecodes.add(new Bytecode.Load(operand, convertUnderlyingType(pt)));
>, <Line: -					addWriteConversion(pt, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.ArrayStore(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -		} else {
>, <Line: -			// No, binding not required.
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: -		// Fifth, invoke lambda class constructor
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT_ARRAY);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -		// Sixth, assign newly created lambda object to target register
>, <Line: -		JvmType.Clazz clazz = (JvmType.Clazz) convertUnderlyingType(c.type(0));
>, <Line: -		bytecodes.add(new Bytecode.Store(c.target(0), clazz));
>, <Line: -	}
>, <Line: -	private void translate(BytecodeForest.Index index, Invoke c, int freeSlot, BytecodeForest forest,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		for (int i = 0; i != c.operands().length; ++i) {
>, <Line: -			int register = c.operands()[i];
>, <Line: -			JvmType parameterType = convertUnderlyingType(c.type(0).params().get(i));
>, <Line: -			bytecodes.add(new Bytecode.Load(register, parameterType));
>, <Line: -		Path.ID mid = c.name().module();
>, <Line: -		String mangled = nameMangle(c.name().name(), c.type(0));
>, <Line: -		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
>, <Line: -		JvmType.Function type = convertFunType(c.type(0));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(owner, mangled, type, Bytecode.InvokeMode.STATIC));
>, <Line: -		int[] targets = c.targets();
>, <Line: -		List<Type> returns = c.type(0).returns();
>, <Line: -		if (targets.length == 0 && !returns.isEmpty()) {
>, <Line: -			bytecodes.add(new Bytecode.Pop(convertUnderlyingType(c.type(0).returns().get(0))));
>, <Line: -		} else if (targets.length == 1) {
>, <Line: -			bytecodes.add(new Bytecode.Store(targets[0], convertUnderlyingType(returns.get(0))));
>, <Line: -		} else if (targets.length > 1) {
>, <Line: -			// Multiple return values are provided, and these will have been
>, <Line: -			// encoded into an object array.
>, <Line: -			decodeOperandArray(c.type(0).returns(), targets, bytecodes);
>, <Line: -	private void translate(BytecodeForest.Index index, IndirectInvoke c, int freeSlot, BytecodeForest forest, ArrayList<Bytecode> bytecodes) {
>, <Line: -		Type.FunctionOrMethod ft = c.type(0);
>, <Line: -		JvmType.Clazz owner = (JvmType.Clazz) convertUnderlyingType(ft);
>, <Line: -		bytecodes.add(new Bytecode.Load(c.reference(), convertUnderlyingType(ft)));
>, <Line: -		encodeOperandArray(ft.params(), c.parameters(), bytecodes);
>, <Line: -		JvmType.Function type = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(owner, "call", type, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -		int[] targets = c.targets();
>, <Line: -		List<Type> returns = ft.returns();
>, <Line: -		if (targets.length == 0) {
>, <Line: -			// handles the case of an invoke which returns a value that should
>, <Line: -			// be discarded.
>, <Line: -			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
>, <Line: -		} else if (targets.length == 1) {
>, <Line: -			// Only a single return value, which means it is passed directly as
>, <Line: -			// a return value rather then being encoded into an object array.
>, <Line: -			addReadConversion(returns.get(0), bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Store(targets[0], convertUnderlyingType(returns.get(0))));
>, <Line: -			// Multiple return values, which must be encoded into an object
>, <Line: -			// array.
>, <Line: -			internalFailure("multiple returns not supported", filename,
>, <Line: -					forest.get(index).attribute(SourceLocation.class));
>, <Line: -	private void translate(Constant v, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -		if (v instanceof Constant.Null) {
>, <Line: -			translate((Constant.Null) v, freeSlot, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Bool) {
>, <Line: -			translate((Constant.Bool) v, freeSlot, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Byte) {
>, <Line: -			translate((Constant.Byte) v, freeSlot, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Integer) {
>, <Line: -			translate((Constant.Integer) v, freeSlot, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Type) {
>, <Line: -			translate((Constant.Type) v, freeSlot, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Array) {
>, <Line: -			translate((Constant.Array) v, freeSlot, lambdas, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Record) {
>, <Line: -			translate((Constant.Record) v, freeSlot, lambdas, bytecodes);
>, <Line: -		} else if (v instanceof Constant.Lambda) {
>, <Line: -			translate((Constant.Lambda) v, freeSlot, lambdas, bytecodes);
>, <Line: -		} else {
>, <Line: -			throw new IllegalArgumentException("unknown value encountered:" + v);
>, <Line: -	protected void translate(Constant.Null e, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: -	}
>, <Line: -	protected void translate(Constant.Bool e, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -		if (e.value()) {
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(1));
>, <Line: -		} else {
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(0));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYBOOL, "valueOf", ftype,
>, <Line: -				Bytecode.InvokeMode.STATIC));
>, <Line: -	protected void translate(Constant.Type e, int freeSlot,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(jout.toString()));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYTYPE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -	protected void translate(Constant.Byte e, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(e.value()));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYBYTE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -	protected void translate(Constant.Integer e, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(num.intValue()));
>, <Line: -			bytecodes.add(new Bytecode.Conversion(T_INT, T_LONG));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(num.longValue()));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
>, <Line: -			bytecodes.add(new Bytecode.New(WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYINT));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(bytes.length));
>, <Line: -			bytecodes.add(new Bytecode.New(bat));
>, <Line: -				bytecodes.add(new Bytecode.Dup(bat));
>, <Line: -				bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: -				bytecodes.add(new Bytecode.LoadConst(bytes[i]));
>, <Line: -				bytecodes.add(new Bytecode.ArrayStore(bat));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -	protected void translate(Constant.Array lv, int freeSlot, ArrayList<ClassFile> lambdas,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.New(WHILEYARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(lv.values().size()));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
>, <Line: -			translate(e, freeSlot, bytecodes);
>, <Line: -			addWriteConversion(e.type(), bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			bytecodes.add(new Bytecode.Pop(T_BOOL));
>, <Line: -	protected void translate(Constant.Record expr, int freeSlot, ArrayList<ClassFile> lambdas,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		construct(WHILEYRECORD, freeSlot, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Dup(WHILEYRECORD));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(e.getKey()));
>, <Line: -			translate(e.getValue(), freeSlot, bytecodes);
>, <Line: -			addWriteConversion(et, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
>, <Line: -	protected void translate(Constant.Lambda c, int freeSlot, ArrayList<ClassFile> lambdas,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// First, build and register lambda class which calls the given function
>, <Line: -		// or method. This class will extend class wyjc.runtime.WyLambda.
>, <Line: -		int lambda_id = lambdas.size();
>, <Line: -		lambdas.add(buildLambda(c.name(), c.type(), lambda_id));
>, <Line: -		// Second, create and duplicate new lambda object. This will then stay
>, <Line: -		// on the stack (whilst the parameters are constructed) until the
>, <Line: -		// object's constructor is called.
>, <Line: -		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
>, <Line: -				Integer.toString(lambda_id));
>, <Line: -		bytecodes.add(new Bytecode.New(lambdaClassType));
>, <Line: -		bytecodes.add(new Bytecode.Dup(lambdaClassType));
>, <Line: -		// Third, invoke lambda class constructor
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT_ARRAY);
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -	}
>, <Line: -	 * Construct a class which implements a lambda expression. This must be a
>, <Line: -	 * subtype of wyjc.runtime.WyLambda and must call the given function, whilst
>, <Line: -	 * decoding and passing through the appropriate parameters.
>, <Line: -	 * @param name
>, <Line: -	 *            Name of function or method which this lambda should invoke.
>, <Line: -	 *            Type of function or method which this lambda should invoke.
>, <Line: -	protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type, int id) {
>, <Line: -		// === (1) Determine the fully qualified type of the lambda class ===
>, <Line: -		// start with fully qualified type of this class.
>, <Line: -		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
>, <Line: -				Integer.toString(id));
>, <Line: -		// === (2) Construct an empty class ===
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		modifiers.add(Modifier.ACC_FINAL);
>, <Line: -		ClassFile cf = new ClassFile(CLASS_VERSION, lambdaClassType, WHILEYLAMBDA, new ArrayList<JvmType.Clazz>(),
>, <Line: -				modifiers);
>, <Line: -		// === (3) Add constructor ===
>, <Line: -		modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		JvmType.Function constructorType = new JvmType.Function(JvmTypes.T_VOID, JAVA_LANG_OBJECT_ARRAY);
>, <Line: -		// Create constructor method
>, <Line: -		ClassFile.Method constructor = new ClassFile.Method("<init>", constructorType, modifiers);
>, <Line: -		cf.methods().add(constructor);
>, <Line: -		// Create body of constructor
>, <Line: -		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: -		bytecodes.add(new Bytecode.Load(0, lambdaClassType));
>, <Line: -		bytecodes.add(new Bytecode.Load(1, JAVA_LANG_OBJECT_ARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYLAMBDA, "<init>", constructorType, Bytecode.InvokeMode.SPECIAL));
>, <Line: -		bytecodes.add(new Bytecode.Return(null));
>, <Line: -		// Add code attribute to constructor
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), constructor);
>, <Line: -		constructor.attributes().add(code);
>, <Line: -		// === (4) Add implementation of WyLambda.call(Object[]) ===
>, <Line: -		modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PUBLIC);
>, <Line: -		modifiers.add(Modifier.ACC_FINAL);
>, <Line: -		JvmType.Function callFnType = new JvmType.Function(JvmTypes.JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
>, <Line: -		// Create constructor method
>, <Line: -		ClassFile.Method callFn = new ClassFile.Method("call", callFnType, modifiers);
>, <Line: -		cf.methods().add(callFn);
>, <Line: -		// Create body of call method
>, <Line: -		bytecodes = new ArrayList<Bytecode>();
>, <Line: -		// Call WyFunction.bindParameters()
>, <Line: -		bytecodes.add(new Bytecode.Load(0, lambdaClassType));
>, <Line: -		bytecodes.add(new Bytecode.Load(1, JAVA_LANG_OBJECT_ARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYLAMBDA, "bindParameters",
>, <Line: -				new JvmType.Function(JAVA_LANG_OBJECT_ARRAY, JAVA_LANG_OBJECT_ARRAY), Bytecode.InvokeMode.VIRTUAL));
>, <Line: -		bytecodes.add(new Bytecode.Store(1, JAVA_LANG_OBJECT_ARRAY));
>, <Line: -		// Load parameters onto stack
>, <Line: -		List<Type> type_params = type.params();
>, <Line: -		for (int i = 0; i != type_params.size(); ++i) {
>, <Line: -			bytecodes.add(new Bytecode.Load(1, JAVA_LANG_OBJECT_ARRAY));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: -			bytecodes.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -			addReadConversion(type_params.get(i), bytecodes);
>, <Line: -		}
>, <Line: -		Path.ID mid = name.module();
>, <Line: -		String mangled = nameMangle(name.name(), type);
>, <Line: -		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
>, <Line: -		JvmType.Function fnType = convertFunType(type);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(owner, mangled, fnType, Bytecode.InvokeMode.STATIC));
>, <Line: -		if (type.returns().isEmpty()) {
>, <Line: -			// Called function doesn't return anything, but we have to.
>, <Line: -			// Therefore, push on dummy null value.
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(null));
>, <Line: -		} else {
>, <Line: -			addWriteConversion(type.returns().get(0), bytecodes);
>, <Line: -		}
>, <Line: -		bytecodes.add(new Bytecode.Return(JAVA_LANG_OBJECT));
>, <Line: -		// Add code attribute to call method
>, <Line: -		code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), callFn);
>, <Line: -		callFn.attributes().add(code);
>, <Line: -		// Done
>, <Line: -		return cf;
>, <Line: -	}
>, <Line: -	protected void addCoercion(Type from, Type to, int freeSlot, HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// First, deal with coercions which require a change of representation
>, <Line: -		// when going into a union. For example, bool must => Boolean.
>, <Line: -		if (!(to instanceof Type.Bool) && from instanceof Type.Bool) {
>, <Line: -			// this is either going into a union type, or the any type
>, <Line: -			buildCoercion((Type.Bool) from, to, freeSlot, bytecodes);
>, <Line: -		} else if (from == Type.T_BYTE) {
>, <Line: -			buildCoercion((Type.Byte) from, to, freeSlot, bytecodes);
>, <Line: -		} else if (Type.intersect(from, to).equals(from)) {
>, <Line: -			// do nothing!
>, <Line: -			// (note, need to check this after primitive types to avoid risk of
>, <Line: -			// missing coercion to any)
>, <Line: -		} else if (from == Type.T_INT) {
>, <Line: -			// do nothing!
>, <Line: -			// ok, it's a harder case so we use an explicit coercion function
>, <Line: -			int id = JvmCoercion.get(from, to, constants);
>, <Line: -			String name = "coercion$" + id;
>, <Line: -			JvmType.Function ft = new JvmType.Function(convertUnderlyingType(to), convertUnderlyingType(from));
>, <Line: -			bytecodes.add(new Bytecode.Invoke(owner, name, ft, Bytecode.InvokeMode.STATIC));
>, <Line: -		}
>, <Line: -	}
>, <Line: -	private void buildCoercion(Type.Bool fromType, Type toType, int freeSlot,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// done deal!
>, <Line: -	}
>, <Line: -	private void buildCoercion(Type.Byte fromType, Type toType, int freeSlot,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_BYTE, T_BYTE);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_BYTE, "valueOf", ftype,
>, <Line: -				Bytecode.InvokeMode.STATIC));
>, <Line: -		// done deal!
>, <Line: -	 * The build coercion method constructs a static final private method which
>, <Line: -	 * accepts a value of type "from", and coerces it into a value of type "to".
>, <Line: -	 *
>, <Line: -	 * @param to
>, <Line: -	 * @param from
>, <Line: -	protected void buildCoercion(Type from, Type to, int id,
>, <Line: -			HashMap<JvmConstant, Integer> constants, ClassFile cf) {
>, <Line: -		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
>, <Line: -		int freeSlot = 1;
>, <Line: -		bytecodes.add(new Bytecode.Load(0, convertUnderlyingType(from)));
>, <Line: -		buildCoercion(from, to, freeSlot, constants, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Return(convertUnderlyingType(to)));
>, <Line: -		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
>, <Line: -		modifiers.add(Modifier.ACC_PRIVATE);
>, <Line: -		modifiers.add(Modifier.ACC_STATIC);
>, <Line: -		modifiers.add(Modifier.ACC_SYNTHETIC);
>, <Line: -		JvmType.Function ftype = new JvmType.Function(
>, <Line: -				convertUnderlyingType(to), convertUnderlyingType(from));
>, <Line: -		String name = "coercion$" + id;
>, <Line: -		ClassFile.Method method = new ClassFile.Method(name, ftype, modifiers);
>, <Line: -		cf.methods().add(method);
>, <Line: -		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes,
>, <Line: -				new ArrayList(), method);
>, <Line: -		method.attributes().add(code);
>, <Line: -	}
>, <Line: -	protected void buildCoercion(Type from, Type to, int freeSlot,
>, <Line: -			HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		// Second, case analysis on the various kinds of coercion
>, <Line: -		if (from instanceof Type.Reference
>, <Line: -				&& to instanceof Type.Reference) {
>, <Line: -			// TODO
>, <Line: -		} else if (from instanceof Type.Array && to instanceof Type.Array) {
>, <Line: -			buildCoercion((Type.Array) from, (Type.Array) to, freeSlot,
>, <Line: -					constants, bytecodes);
>, <Line: -		} else if (to instanceof Type.Record && from instanceof Type.Record) {
>, <Line: -			buildCoercion((Type.Record) from, (Type.Record) to, freeSlot,
>, <Line: -					constants, bytecodes);
>, <Line: -		} else if (to instanceof Type.Function && from instanceof Type.Function) {
>, <Line: -			// TODO
>, <Line: -		} else if (from instanceof Type.Negation || to instanceof Type.Negation) {
>, <Line: -			// no need to do anything, since convertType on a negation returns
>, <Line: -			// java/lang/Object
>, <Line: -		} else if (from instanceof Type.Union) {
>, <Line: -			buildCoercion((Type.Union) from, to, freeSlot, constants, bytecodes);
>, <Line: -		} else if (to instanceof Type.Union) {
>, <Line: -			buildCoercion(from, (Type.Union) to, freeSlot, constants, bytecodes);
>, <Line: -		} else {
>, <Line: -			throw new RuntimeException("invalid coercion encountered: " + from
>, <Line: -					+ " => " + to);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	protected void buildCoercion(Type.Array fromType, Type.Array toType,
>, <Line: -			int freeSlot, HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		if (fromType.element() == Type.T_VOID) {
>, <Line: -			// nothing to do, in this particular case
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		// The following piece of code implements a java for-each loop which
>, <Line: -		// iterates every element of the input collection, and recursively
>, <Line: -		// converts it before loading it back onto a new WhileyList.
>, <Line: -		String loopLabel = freshLabel();
>, <Line: -		String exitLabel = freshLabel();
>, <Line: -		int iter = freeSlot++;
>, <Line: -		int tmp = freeSlot++;
>, <Line: -		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_COLLECTION, "iterator",
>, <Line: -				ftype, Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.Store(iter, JAVA_UTIL_ITERATOR));
>, <Line: -		construct(WHILEYARRAY, freeSlot, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(tmp, WHILEYARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Label(loopLabel));
>, <Line: -		ftype = new JvmType.Function(T_BOOL);
>, <Line: -		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext", ftype,
>, <Line: -				Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, exitLabel));
>, <Line: -		bytecodes.add(new Bytecode.Load(tmp, WHILEYARRAY));
>, <Line: -		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
>, <Line: -		ftype = new JvmType.Function(JAVA_LANG_OBJECT);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next", ftype,
>, <Line: -				Bytecode.InvokeMode.INTERFACE));
>, <Line: -		addReadConversion(fromType.element(), bytecodes);
>, <Line: -		addCoercion(fromType.element(), toType.element(), freeSlot, constants,
>, <Line: -				bytecodes);
>, <Line: -		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype,
>, <Line: -				Bytecode.InvokeMode.VIRTUAL));
>, <Line: -		bytecodes.add(new Bytecode.Pop(T_BOOL));
>, <Line: -		bytecodes.add(new Bytecode.Goto(loopLabel));
>, <Line: -		bytecodes.add(new Bytecode.Label(exitLabel));
>, <Line: -		bytecodes.add(new Bytecode.Load(tmp, WHILEYARRAY));
>, <Line: -	}
>, <Line: -	private void buildCoercion(Type.Record fromType, Type.Record toType,
>, <Line: -			int freeSlot, HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		int oldSlot = freeSlot++;
>, <Line: -		int newSlot = freeSlot++;
>, <Line: -		bytecodes.add(new Bytecode.Store(oldSlot, WHILEYRECORD));
>, <Line: -		construct(WHILEYRECORD, freeSlot, bytecodes);
>, <Line: -		bytecodes.add(new Bytecode.Store(newSlot, WHILEYRECORD));
>, <Line: -		Map<String, Type> toFields = toType.fields();
>, <Line: -		Map<String, Type> fromFields = fromType.fields();
>, <Line: -		for (String key : toFields.keySet()) {
>, <Line: -			Type to = toFields.get(key);
>, <Line: -			Type from = fromFields.get(key);
>, <Line: -			bytecodes.add(new Bytecode.Load(newSlot, WHILEYRECORD));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(key));
>, <Line: -			bytecodes.add(new Bytecode.Load(oldSlot, WHILEYRECORD));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(key));
>, <Line: -			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
>, <Line: -					JAVA_LANG_OBJECT);
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype,
>, <Line: -					Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			// TODO: in cases when the read conversion is a no-op, we can do
>, <Line: -			// better here.
>, <Line: -			addReadConversion(from, bytecodes);
>, <Line: -			addCoercion(from, to, freeSlot, constants, bytecodes);
>, <Line: -			addWriteConversion(from, bytecodes);
>, <Line: -			ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT,
>, <Line: -					JAVA_LANG_OBJECT);
>, <Line: -			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype,
>, <Line: -					Bytecode.InvokeMode.VIRTUAL));
>, <Line: -			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
>, <Line: -		}
>, <Line: -		bytecodes.add(new Bytecode.Load(newSlot, WHILEYRECORD));
>, <Line: -	}
>, <Line: -	private void buildCoercion(Type.Union from, Type to, int freeSlot,
>, <Line: -			HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		String exitLabel = freshLabel();
>, <Line: -		List<Type> fromBounds = new ArrayList<Type>(from.bounds());
>, <Line: -		// For each bound in the union, go through and check whether the given
>, <Line: -		// value (which is currently on the stack) is an instance of that bound.
>, <Line: -		// When we find the right one, then we recursively build a coercion from
>, <Line: -		// that type to the target type. In general, this could certainly be
>, <Line: -		// more efficient.
>, <Line: -		for (int i = 0; i != fromBounds.size(); ++i) {
>, <Line: -			Type bound = fromBounds.get(i);
>, <Line: -			if ((i + 1) == fromBounds.size()) {
>, <Line: -				// In the last case, we just assume that the value matches
>, <Line: -				// (since otherwise something very strange has happened).
>, <Line: -				addReadConversion(bound, bytecodes);
>, <Line: -				addCoercion(bound, to, freeSlot, constants, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.Goto(exitLabel));
>, <Line: -			} else {
>, <Line: -				// There is at least one more bound after this. In such case, we
>, <Line: -				// check whether the given value matches this bound. If so, we
>, <Line: -				// recursively build a coercion for that to the target type. If
>, <Line: -				// not, we branch to the next bound
>, <Line: -				String nextLabel = freshLabel();
>, <Line: -				bytecodes.add(new Bytecode.Dup(convertUnderlyingType(from)));
>, <Line: -				translateTypeTest(nextLabel, bound, constants, bytecodes);
>, <Line: -				addReadConversion(bound, bytecodes);
>, <Line: -				addCoercion(bound, to, freeSlot, constants, bytecodes);
>, <Line: -				bytecodes.add(new Bytecode.Goto(exitLabel));
>, <Line: -				bytecodes.add(new Bytecode.Label(nextLabel));
>, <Line: -			}
>, <Line: -		}
>, <Line: -		bytecodes.add(new Bytecode.Label(exitLabel));
>, <Line: -	}
>, <Line: -	private void buildCoercion(Type from, Type.Union to, int freeSlot,
>, <Line: -			HashMap<JvmConstant, Integer> constants,
>, <Line: -			ArrayList<Bytecode> bytecodes) {
>, <Line: -		Type.Union t2 = (Type.Union) to;
>, <Line: -		// First, check for identical type (i.e. no coercion necessary)
>, <Line: -		for (Type b : t2.bounds()) {
>, <Line: -			if (from.equals(b)) {
>, <Line: -				// nothing to do
>, <Line: -				return;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		// Second, check for single non-coercive match
>, <Line: -		for (Type b : t2.bounds()) {
>, <Line: -			if (Type.isSubtype(b, from)) {
>, <Line: -				buildCoercion(from, b, freeSlot, constants, bytecodes);
>, <Line: -				return;
>, <Line: -		// Third, test for single coercive match
>, <Line: -		for (Type b : t2.bounds()) {
>, <Line: -			if (Type.isExplicitCoerciveSubtype(b, from)) {
>, <Line: -				buildCoercion(from, b, freeSlot, constants, bytecodes);
>, <Line: -				return;
>, <Line: -		// I don't think we should be able to get here!
>, <Line: -	 * Construct generic code for iterating over a collection (e.g. a Whiley
>, <Line: -	 * List or Set). This code will not leave anything on the stack and will
>, <Line: -	 * store the iterator variable in a given slot. This means that things can
>, <Line: -	 * be passed on the stack from before the loop into the loop body.
>, <Line: -	 * @param bytecodes
>, <Line: -	 *            The list of bytecodes onto which the loop code should be added
>, <Line: -	 * @param freeSlot
>, <Line: -	 *            The variable slot into which the iterator variable should be
>, <Line: -	 *            stored.
>, <Line: -	 * @param exitLabel
>, <Line: -	 *            The label which will represents after the end of the loop.
>, <Line: -	private Triple<String, String, String> translateLoopBegin(
>, <Line: -			ArrayList<Bytecode> bytecodes, int sourceSlot, int freeSlot) {
>, <Line: -		String loopHeader = freshLabel();
>, <Line: -		String loopFooter = freshLabel();
>, <Line: -		String loopExit = freshLabel();
>, <Line: -		// First, call Collection.iterator() on the source collection and write
>, <Line: -		// it into the free slot.
>, <Line: -		bytecodes.add(new Bytecode.Load(sourceSlot, JAVA_LANG_ITERABLE));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_ITERABLE, "iterator",
>, <Line: -				new JvmType.Function(JAVA_UTIL_ITERATOR),Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		// Second, construct the loop header, which consists of the test to
>, <Line: -		// check whether or not there are any elements left in the collection to
>, <Line: -		// visit.
>, <Line: -		bytecodes.add(new Bytecode.Label(loopHeader));
>, <Line: -		bytecodes.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext",
>, <Line: -				new JvmType.Function(T_BOOL), Bytecode.InvokeMode.INTERFACE));
>, <Line: -		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, loopExit));
>, <Line: -		// Finally, get the current element out of the iterator by invoking
>, <Line: -		// Iterator.next();
>, <Line: -		bytecodes.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
>, <Line: -		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next",
>, <Line: -				new JvmType.Function(JAVA_LANG_OBJECT),
>, <Line: -				Bytecode.InvokeMode.INTERFACE));
>, <Line: -		// Done
>, <Line: -		return new Triple<>(loopHeader, loopFooter, loopExit);
>, <Line: -	}
>, <Line: -	private void translateLoopEnd(ArrayList<Bytecode> bytecodes,
>, <Line: -			Triple<String, String, String> labels) {
>, <Line: -		bytecodes.add(new Bytecode.Label(labels.second()));
>, <Line: -		bytecodes.add(new Bytecode.Goto(labels.first()));
>, <Line: -		bytecodes.add(new Bytecode.Label(labels.third()));
>, <Line: -	}
>, <Line: -	private void encodeOperandArray(List<Type> types, int[] operands, ArrayList<Bytecode> bytecodes) {
>, <Line: -		encodeOperandArray(types.toArray(new Type[types.size()]),operands,bytecodes);
>, <Line: -	 * Create an Object[] array from a list of operands. This involves
>, <Line: -	 * appropriately coercing primitives as necessary.
>, <Line: -	 * @param types
>, <Line: -	 * @param operands
>, <Line: -	 * @param bytecodes
>, <Line: -	private void encodeOperandArray(Type[] types, int[] operands, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.LoadConst(operands.length));
>, <Line: -		bytecodes.add(new Bytecode.New(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -		for (int i = 0; i != operands.length; ++i) {
>, <Line: -			int register = operands[i];
>, <Line: -			Type type = types[i];
>, <Line: -			JvmType jvmType = convertUnderlyingType(type);
>, <Line: -			bytecodes.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: -			bytecodes.add(new Bytecode.Load(register, jvmType));
>, <Line: -			addWriteConversion(type, bytecodes);
>, <Line: -			bytecodes.add(new Bytecode.ArrayStore(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -	private void decodeOperandArray(List<Type> types, int[] targets, ArrayList<Bytecode> bytecodes) {
>, <Line: -		for (int i = 0; i != targets.length; ++i) {
>, <Line: -			int register = targets[i];
>, <Line: -			Type type = types.get(i);
>, <Line: -			bytecodes.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -			bytecodes.add(new Bytecode.LoadConst(i));
>, <Line: -			bytecodes.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));			
>, <Line: -			addReadConversion(type, bytecodes);
>, <Line: -			JvmType jvmType = convertUnderlyingType(type);
>, <Line: -			bytecodes.add(new Bytecode.Store(register, jvmType));
>, <Line: -		bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT_ARRAY));
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * The read conversion is necessary in situations where we're reading a
>, <Line: -	 * value from a collection (e.g. WhileyList, WhileySet, etc) and then
>, <Line: -	 * putting it on the stack. In such case, we need to convert boolean values
>, <Line: -	 * from Boolean objects to bool primitives.
>, <Line: -	 */
>, <Line: -	private void addReadConversion(Type et, ArrayList<Bytecode> bytecodes) {
>, <Line: -		// This doesn't do anything extrac since there are currently no data
>, <Line: -		// types implemented as primitives.
>, <Line: -		addCheckCast(convertUnderlyingType(et), bytecodes);
>, <Line: -	 * The write conversion is necessary in situations where we're write a value
>, <Line: -	 * from the stack into a collection (e.g. WhileyList, WhileySet, etc). In
>, <Line: -	 * such case, we need to convert boolean values from bool primitives to
>, <Line: -	 * Boolean objects.
>, <Line: -	private void addWriteConversion(Type et, ArrayList<Bytecode> bytecodes) {
>, <Line: -		// This currently does nothing since there are currently no data types
>, <Line: -		// implemented as primitives.
>, <Line: -	}
>, <Line: -	private void addCheckCast(JvmType type, ArrayList<Bytecode> bytecodes) {
>, <Line: -		// The following can happen in situations where a variable has type
>, <Line: -		// void. In principle, we could remove this as obvious dead-code, but
>, <Line: -		// for now I just avoid it.
>, <Line: -		if (type instanceof JvmType.Void) {
>, <Line: -			return;
>, <Line: -		} else if (!type.equals(JAVA_LANG_OBJECT)) {
>, <Line: -			// pointless to add a cast for object
>, <Line: -			bytecodes.add(new Bytecode.CheckCast(type));
>, <Line: -		}
>, <Line: -	 * The construct method provides a generic way to construct a Java object.
>, <Line: -	 * @param owner
>, <Line: -	 * @param freeSlot
>, <Line: -	 * @param bytecodes
>, <Line: -	 * @param params
>, <Line: -	private void construct(JvmType.Clazz owner, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -		bytecodes.add(new Bytecode.New(owner));
>, <Line: -		bytecodes.add(new Bytecode.Dup(owner));
>, <Line: -		ArrayList<JvmType> paramTypes = new ArrayList<JvmType>();
>, <Line: -		JvmType.Function ftype = new JvmType.Function(T_VOID, paramTypes);
>, <Line: -		bytecodes.add(new Bytecode.Invoke(owner, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
>, <Line: -	}
>, <Line: -	public final static Type WHILEY_SYSTEM_T = Type.Nominal(new NameID(Trie
>, <Line: -			.fromString("whiley/lang/System"), "Console"));
>, <Line: -	public final static JvmType.Clazz WHILEYUTIL = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "Util");
>, <Line: -	public final static JvmType.Clazz WHILEYARRAY = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyArray");
>, <Line: -	public final static JvmType.Clazz WHILEYTYPE = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyType");
>, <Line: -	public final static JvmType.Clazz WHILEYRECORD = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyRecord");
>, <Line: -	public final static JvmType.Clazz WHILEYOBJECT = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyObject");
>, <Line: -	public final static JvmType.Clazz WHILEYBOOL = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyBool");
>, <Line: -	public final static JvmType.Clazz WHILEYBYTE = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyByte");
>, <Line: -	public final static JvmType.Clazz WHILEYINT = new JvmType.Clazz(
>, <Line: -			"java.math", "BigInteger");
>, <Line: -	public final static JvmType.Clazz WHILEYLAMBDA = new JvmType.Clazz(
>, <Line: -			"wyjc.runtime", "WyLambda");
>, <Line: -	private static final JvmType.Clazz JAVA_LANG_CHARACTER = new JvmType.Clazz(
>, <Line: -			"java.lang", "Character");
>, <Line: -	private static final JvmType.Clazz JAVA_LANG_SYSTEM = new JvmType.Clazz(
>, <Line: -			"java.lang", "System");
>, <Line: -	private static final JvmType.Clazz JAVA_LANG_ITERABLE = new JvmType.Clazz(
>, <Line: -			"java.lang", "Iterable");
>, <Line: -	private static final JvmType.Array JAVA_LANG_OBJECT_ARRAY = new JvmType.Array(
>, <Line: -			JAVA_LANG_OBJECT);
>, <Line: -	private static final JvmType.Clazz JAVA_UTIL_LIST = new JvmType.Clazz(
>, <Line: -			"java.util", "List");
>, <Line: -	private static final JvmType.Clazz JAVA_UTIL_SET = new JvmType.Clazz(
>, <Line: -			"java.util", "Set");
>, <Line: -	private static final JvmType.Clazz JAVA_IO_PRINTSTREAM = new JvmType.Clazz(
>, <Line: -			"java.io", "PrintStream");
>, <Line: -	private static final JvmType.Clazz JAVA_LANG_RUNTIMEEXCEPTION = new JvmType.Clazz(
>, <Line: -			"java.lang", "RuntimeException");
>, <Line: -	private static final JvmType.Clazz JAVA_LANG_ASSERTIONERROR = new JvmType.Clazz(
>, <Line: -			"java.lang", "AssertionError");
>, <Line: -	private static final JvmType.Clazz JAVA_UTIL_COLLECTION = new JvmType.Clazz(
>, <Line: -			"java.util", "Collection");
>, <Line: -			paramTypes.add(convertUnderlyingType(pt));
>, <Line: -		switch(ft.returns().size()) {
>, <Line: -			rt = convertUnderlyingType(ft.returns().get(0));
>, <Line: -	private JvmType convertUnderlyingType(Type t) {
>, <Line: -			for(Type bound : ut.bounds()) {
>, <Line: -				JvmType r = convertUnderlyingType(bound);
>, <Line: -				if(result == null) {
>, <Line: -				Type expanded = expander.getUnderlyingType(t);
>, <Line: -				return convertUnderlyingType(expanded);
>, <Line: -	private static String typeMangle(Type.FunctionOrMethod ft)
>, <Line: -			throws IOException {
>, <Line: -		public static int get(Constant value,
>, <Line: -				HashMap<JvmConstant, Integer> constants) {
>, <Line: -	private static final class JvmCoercion extends JvmConstant {
>, <Line: -		public final Type from;
>, <Line: -		public final Type to;
>, <Line: -		public JvmCoercion(Type from, Type to) {
>, <Line: -			this.from = from;
>, <Line: -			this.to = to;
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof JvmCoercion) {
>, <Line: -				JvmCoercion c = (JvmCoercion) o;
>, <Line: -				return from.equals(c.from) && to.equals(c.to);
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -		public int hashCode() {
>, <Line: -			return from.hashCode() + to.hashCode();
>, <Line: -		public static int get(Type from, Type to,
>, <Line: -				HashMap<JvmConstant, Integer> constants) {
>, <Line: -			JvmCoercion vc = new JvmCoercion(from, to);
>, <Line: -			Integer r = constants.get(vc);
>, <Line: -			if (r != null) {
>, <Line: -				return r;
>, <Line: -			} else {
>, <Line: -				int x = constants.size();
>, <Line: -				constants.put(vc, x);
>, <Line: -				return x;
>, <Line: -			}
>, <Line: -	}
>, <Line: -	private static class UnresolvedHandler {
>, <Line: -		public String start;
>, <Line: -		public String end;
>, <Line: -		public String target;
>, <Line: -		public JvmType.Clazz exception;
>, <Line: -		public UnresolvedHandler(String start, String end, String target,
>, <Line: -				JvmType.Clazz exception) {
>, <Line: -			this.start = start;
>, <Line: -			this.end = end;
>, <Line: -			this.target = target;
>, <Line: -			this.exception = exception;
>, <Line: -	}
>, <Line: -	public final class Context {
>, <Line: -		 * The code forest in which we are currently operating
>, <Line: -		private final BytecodeForest forest;
>, <Line: -		 * The index of the bytecode being translated
>, <Line: -		private final BytecodeForest.Index pc;
>, <Line: -		/**
>, <Line: -		 * The list of bytecodes that have been generated so far
>, <Line: -		 */
>, <Line: -		private final ArrayList<Bytecode> bytecodes;
>, <Line: -		 * The next available free register slot
>, <Line: -		private final int freeSlot;
>, <Line: -		public Context(BytecodeForest forest, BytecodeForest.Index pc, int freeSlot, ArrayList<Bytecode> bytecodes) {
>, <Line: -			this.forest = forest;
>, <Line: -			this.bytecodes = bytecodes;
>, <Line: -			this.pc = pc;
>, <Line: -			this.freeSlot = freeSlot;
>, <Line: -		public void add(Bytecode bytecode) {
>, <Line: -			bytecodes.add(bytecode);
>, <Line: -		public void addReadConversion(Type type) {
>, <Line: -			Wyil2JavaBuilder.this.addReadConversion(type,bytecodes);
>, <Line: -		public void addWriteConversion(Type type) {
>, <Line: -			Wyil2JavaBuilder.this.addWriteConversion(type,bytecodes);
>, <Line: -		public void construct(JvmType.Clazz type) {
>, <Line: -			Wyil2JavaBuilder.this.construct(type,freeSlot,bytecodes);
>, <Line: -		public JvmType toJvmType(Type type) {
>, <Line: -			return convertUnderlyingType(type);
>, <Line: -		void translate(Operator bytecode, Context context);
>]