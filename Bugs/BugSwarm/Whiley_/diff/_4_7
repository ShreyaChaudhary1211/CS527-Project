[<Line: +		 * Return a specific target register assigned by this bytecode.
>, <Line: +		public int target(int i) {
>, <Line: +			return targets[0];
>, <Line: +		}
>, <Line: +		 * Return the target registers assigned by this bytecode.
>, <Line: +		protected final Type[] types;
>, <Line: +		public AbstractMultiNaryAssignable(Type type, int target, int... operands) {
>, <Line: +			super(target);			
>, <Line: +			this.types = new Type[]{type};
>, <Line: +			this.operands = operands;
>, <Line: +		}
>, <Line: +		public AbstractMultiNaryAssignable(Type[] types, int[] targets, int[] operands) {
>, <Line: +			this.types = types;
>, <Line: +				registers.add(operands[i]);
>, <Line: +		@Override
>, <Line: +			return Arrays.hashCode(types) + Arrays.hashCode(targets()) + Arrays.hashCode(operands());
>, <Line: +		@Override
>, <Line: +			if (o instanceof AbstractMultiNaryAssignable) {
>, <Line: +						&& Arrays.equals(types, bo.types);
>, <Line: +		public Type[] types() {
>, <Line: +			return types;
>, <Line: +		public T type(int i) {
>, <Line: +			return (T) types[i];
>, <Line: +	public static abstract class AbstractUnaryAssignable<T> extends AbstractMultiNaryAssignable<T> {
>, <Line: +		public AbstractUnaryAssignable(Type type, int target, int operand) {
>, <Line: +	public static abstract class AbstractBinaryAssignable<T> extends AbstractMultiNaryAssignable<T> {
>, <Line: +		public AbstractBinaryAssignable(Type type, int target, int leftOperand, int rightOperand) {
>, <Line: +			super(type, target, leftOperand, rightOperand);
>]
[<Line: -		 * Return the type of value assigned to the target register by this
>, <Line: -		 * bytecode.
>, <Line: -		public abstract Type assignedType();
>, <Line: -		 * Return the target register assigned by this bytecode.
>, <Line: -		protected final T type;
>, <Line: -		public AbstractMultiNaryAssignable(T type, int[] targets, int... operands) {
>, <Line: -			if (type == null) {
>, <Line: -				throw new IllegalArgumentException(
>, <Line: -						"AbstractBinOp type argument cannot be null");
>, <Line: -			}
>, <Line: -			this.type = type;
>, <Line: -				registers.add(operands()[i]);
>, <Line: -		public Type assignedType() {
>, <Line: -			return (Type) this.type();
>, <Line: -		}
>, <Line: -			return type().hashCode() + Arrays.hashCode(targets()) + Arrays.hashCode(operands());
>, <Line: -			if (o instanceof AbstractNaryAssignable) {
>, <Line: -						&& type().equals(bo.type());
>, <Line: -		public T type() {
>, <Line: -			return type;
>, <Line: -		public int[] operands() {
>, <Line: -			return operands;
>, <Line: -		}
>, <Line: -		/**
>, <Line: -		 * Return the ith operand read by this bytecode.
>, <Line: -		 * @param i
>, <Line: -		 * @return
>, <Line: -		 */
>, <Line: -		public int operand(int i) {
>, <Line: -			return operands[i];
>, <Line: -		}	
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Represents the set of all bytecodes which take an arbitrary number of
>, <Line: -	 * register operands and write a result to the target register.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 * @param <T>
>, <Line: -	 *            --- the type associated with this bytecode.
>, <Line: -	 */
>, <Line: -	public static abstract class AbstractNaryAssignable<T> extends
>, <Line: -			AbstractAssignable {
>, <Line: -		protected final T type;
>, <Line: -		protected final int[] operands;
>, <Line: -		public AbstractNaryAssignable(T type, int target, int... operands) {
>, <Line: -			super(target);
>, <Line: -			if (type == null) {
>, <Line: -				throw new IllegalArgumentException(
>, <Line: -						"AbstractBinOp type argument cannot be null");
>, <Line: -			}
>, <Line: -			this.type = type;
>, <Line: -			this.operands = operands;
>, <Line: -		}
>, <Line: -		@Override
>, <Line: -		public final void registers(java.util.Set<Integer> registers) {
>, <Line: -			if (target() >= 0) {
>, <Line: -				registers.add(target());
>, <Line: -			}
>, <Line: -			for (int i = 0; i != operands().length; ++i) {
>, <Line: -				registers.add(operands()[i]);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		@Override
>, <Line: -		public final Code.Unit remap(Map<Integer, Integer> binding) {
>, <Line: -			Integer nTarget = binding.get(target());
>, <Line: -			int[] nOperands = remapOperands(binding, operands());
>, <Line: -			if (nTarget != null || nOperands != operands()) {
>, <Line: -				nTarget = nTarget != null ? nTarget : target();
>, <Line: -				return clone(nTarget, nOperands);
>, <Line: -			}
>, <Line: -			return this;
>, <Line: -		}
>, <Line: -		public Type assignedType() {
>, <Line: -			return (Type) this.type();
>, <Line: -		}
>, <Line: -		protected abstract Code.Unit clone(int nTarget, int[] nOperands);
>, <Line: -		public int hashCode() {
>, <Line: -			return type().hashCode() + target() + Arrays.hashCode(operands());
>, <Line: -		}
>, <Line: -		public boolean equals(Object o) {
>, <Line: -			if (o instanceof AbstractNaryAssignable) {
>, <Line: -				AbstractNaryAssignable bo = (AbstractNaryAssignable) o;
>, <Line: -				return target() == bo.target()
>, <Line: -						&& Arrays.equals(operands(), bo.operands())
>, <Line: -						&& type().equals(bo.type());
>, <Line: -			}
>, <Line: -			return false;
>, <Line: -		}
>, <Line: -		public int target() {
>, <Line: -			return targets()[0];
>, <Line: -		}
>, <Line: -		public T type() {
>, <Line: -			return type;
>, <Line: -	public static abstract class AbstractUnaryAssignable<T> extends
>, <Line: -			AbstractNaryAssignable<T> {
>, <Line: -		public AbstractUnaryAssignable(T type, int target, int operand) {
>, <Line: -	public static abstract class AbstractBinaryAssignable<T> extends
>, <Line: -			AbstractNaryAssignable<T> {
>, <Line: -		public AbstractBinaryAssignable(T type, int target, int leftOperand,
>, <Line: -				int rightOperand) {
>, <Line: -			super(type,target,leftOperand,rightOperand);
>]