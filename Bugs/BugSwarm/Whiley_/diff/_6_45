[<Line: +import wyil.lang.SyntaxTree.Location;
>, <Line: +import wyil.util.AbstractBytecode;
>, <Line: +			} else if (val instanceof Constant.FunctionOrMethod) {
>, <Line: +				Constant.FunctionOrMethod fm = (Constant.FunctionOrMethod) val;
>, <Line: +			} else if (val instanceof Constant.Type) {
>, <Line: +				Constant.Type ct = (Constant.Type) val;
>, <Line: +				output.write_uv(CONSTANT_Type);
>, <Line: +				output.write_uv(typeCache.get(ct.value()));				
>, <Line: +	 * | uv : nInvariants       |
>, <Line: +	 * +------------------------+ 
>, <Line: +	 * | uv[nInvariants]        |
>, <Line: +	 * | SyntaxTree             |
>, <Line: +	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: +		//
>, <Line: +		int nameIdx = stringCache.get(td.name());
>, <Line: +		int modifiers = generateModifiers(td.modifiers());
>, <Line: +		int typeIdx = typeCache.get(td.type());
>, <Line: +		List<Location<Bytecode.Expr>> invariant = td.getInvariant();
>, <Line: +		//
>, <Line: +		output.write_uv(nameIdx);
>, <Line: +		output.write_uv(modifiers);
>, <Line: +		output.write_uv(typeIdx);
>, <Line: +		output.write_uv(invariant.size());
>, <Line: +		for(Location<?> clause : invariant) {
>, <Line: +			output.write_uv(clause.getIndex());
>, <Line: +		}
>, <Line: +		writeSyntaxTree(td.getTree(),output);
>, <Line: +	 * | uv : nPreconditions    |
>, <Line: +	 * | uv : nPostconditions   |
>, <Line: +	 * | uv[nPreconditions]     |
>, <Line: +	 * +------------------------+
>, <Line: +	 * | uv[nPostconditions]    |
>, <Line: +	 * +------------------------+
>, <Line: +	 * | uv : body              |
>, <Line: +	 * | SyntaTree              |
>, <Line: +	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: +	 * type itself. 
>, <Line: +		//
>, <Line: +		int nameIdx = stringCache.get(md.name());
>, <Line: +		int modifiers = generateModifiers(md.modifiers());
>, <Line: +		int typeIdx = typeCache.get(md.type());
>, <Line: +		List<Location<Bytecode.Expr>> precondition = md.getPrecondition();
>, <Line: +		List<Location<Bytecode.Expr>> postcondition = md.getPostcondition();		
>, <Line: +		//
>, <Line: +		output.write_uv(nameIdx);
>, <Line: +		output.write_uv(modifiers);
>, <Line: +		output.write_uv(typeIdx);
>, <Line: +		output.write_uv(precondition.size());
>, <Line: +		output.write_uv(postcondition.size());
>, <Line: +		//
>, <Line: +		for(Location<Bytecode.Expr> clause : precondition) {
>, <Line: +			output.write_uv(clause.getIndex());
>, <Line: +		for(Location<Bytecode.Expr> clause : postcondition) {
>, <Line: +			output.write_uv(clause.getIndex());
>, <Line: +		output.write_uv(md.getBody().getIndex());
>, <Line: +		writeSyntaxTree(md.getTree(),output);		
>, <Line: +		return bytes.toByteArray();
>, <Line: +	 * Write a syntax tree to the output stream. The format
>, <Line: +	 * of a syntax tree is one of the following:
>, <Line: +	 * | uv : nLocs        |
>, <Line: +	 * | Locations[nLocs]  |
>, <Line: +	 * 
>, <Line: +	 * 
>, <Line: +	private void writeSyntaxTree(SyntaxTree tree, BinaryOutputStream output) throws IOException {
>, <Line: +		List<Location<?>> locations = tree.getLocations();
>, <Line: +		output.write_uv(locations.size());
>, <Line: +		for(int i=0;i!=locations.size();++i) {
>, <Line: +			Location<?> location = locations.get(i);
>, <Line: +			writeLocation(location,output);
>, <Line: +		}		
>, <Line: +	 * Write details of a Location to the output stream. The format
>, <Line: +	 * of a location is:
>, <Line: +	 * | uv : nTypes       |
>, <Line: +	 * +-------------------+
>, <Line: +	 * | uv[] : typeIdxs   |
>, <Line: +	 * | Bytecode          |
>, <Line: +	private void writeLocation(SyntaxTree.Location<?> location, BinaryOutputStream output) throws IOException {
>, <Line: +		output.write_uv(location.numberOfTypes());
>, <Line: +		for(int i=0;i!=location.numberOfTypes();++i) {
>, <Line: +			output.write_uv(typeCache.get(location.getType(i)));
>, <Line: +		output.write_uv(0); // no attributes for now
>, <Line: +		writeBytecode(location.getBytecode(), output);
>, <Line: +	 * Write out a given bytecode whose format is currently given as follows:
>, <Line: +	 *        ...
>, <Line: +	 * 
>, <Line: +	private void writeBytecode(Bytecode code, BinaryOutputStream output)
>, <Line: +		output.write_u8(code.getOpcode());
>, <Line: +		output.write_uv(0); // attributes
>, <Line: +		writeOperands(code,output);
>, <Line: +		writeOperandGroups(code,output);
>, <Line: +		if (code instanceof Bytecode.Stmt) {
>, <Line: +			writeBlocks((Bytecode.Stmt) code, output);
>, <Line: +		}
>, <Line: +		writeExtras(code, output);
>, <Line: +	private void writeOperands(Bytecode code, BinaryOutputStream output) throws IOException {
>, <Line: +		Bytecode.Schema schema = AbstractBytecode.schemas[code.getOpcode()];
>, <Line: +		switch(schema.getOperands()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			break;
>, <Line: +		case ONE:
>, <Line: +			output.write_uv(code.getOperand(0));
>, <Line: +			break;
>, <Line: +		case TWO:
>, <Line: +			output.write_uv(code.getOperand(0));
>, <Line: +			output.write_uv(code.getOperand(1));
>, <Line: +			break;
>, <Line: +		case MANY:
>, <Line: +			writeUnboundArray(code.getOperands(),output);
>, <Line: +	}
>, <Line: +	private void writeOperandGroups(Bytecode code, BinaryOutputStream output) throws IOException {		
>, <Line: +		Bytecode.Schema schema = AbstractBytecode.schemas[code.getOpcode()];
>, <Line: +		switch(schema.getOperandGroups()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			break;
>, <Line: +		case ONE:
>, <Line: +			writeUnboundArray(code.getOperandGroup(0),output);
>, <Line: +			break;
>, <Line: +		case TWO:			
>, <Line: +			writeUnboundArray(code.getOperandGroup(0),output);
>, <Line: +			writeUnboundArray(code.getOperandGroup(1),output);
>, <Line: +			break;
>, <Line: +		case MANY:
>, <Line: +			output.write_uv(code.numberOfOperandGroups());
>, <Line: +			for(int i=0;i!=code.numberOfOperandGroups();++i) {
>, <Line: +				writeUnboundArray(code.getOperandGroup(i),output);
>, <Line: +			}			
>, <Line: +		}		
>, <Line: +	}
>, <Line: +	private void writeBlocks(Bytecode.Stmt code, BinaryOutputStream output) throws IOException {
>, <Line: +		Bytecode.Schema schema = AbstractBytecode.schemas[code.getOpcode()];
>, <Line: +		switch(schema.getBlocks()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			break;
>, <Line: +		case ONE:
>, <Line: +			output.write_uv(code.getBlock(0));
>, <Line: +			break;
>, <Line: +		case TWO:
>, <Line: +			output.write_uv(code.getBlock(0));
>, <Line: +			output.write_uv(code.getBlock(1));
>, <Line: +			break;
>, <Line: +		case MANY:
>, <Line: +			writeUnboundArray(code.getBlocks(),output);
>, <Line: +	}
>, <Line: +	private void writeUnboundArray(int[] values, BinaryOutputStream output) throws IOException {
>, <Line: +		output.write_uv(values.length);	
>, <Line: +		// Write operand locations
>, <Line: +		for (int i = 0; i != values.length; ++i) {
>, <Line: +			output.write_uv(values[i]);
>, <Line: +	private void writeExtras(Bytecode code, BinaryOutputStream output) throws IOException {
>, <Line: +		//
>, <Line: +		switch (code.getOpcode()) {		
>, <Line: +		case Bytecode.OPCODE_const: {
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_fieldload: {
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_indirectinvoke: {
>, <Line: +			Bytecode.IndirectInvoke c = (Bytecode.IndirectInvoke) code;
>, <Line: +			output.write_uv(typeCache.get(c.type()));
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_namedblock: {
>, <Line: +			Bytecode.NamedBlock c = (Bytecode.NamedBlock) code;
>, <Line: +			output.write_uv(stringCache.get(c.getName()));
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_invoke: {
>, <Line: +			output.write_uv(typeCache.get(c.type()));
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_lambda: {
>, <Line: +			output.write_uv(typeCache.get(c.type()));
>, <Line: +			break;
>, <Line: +		}		
>, <Line: +		case Bytecode.OPCODE_switch: {
>, <Line: +			Bytecode.Case[] cases = c.cases();
>, <Line: +			output.write_uv(cases.length);
>, <Line: +			for (int i = 0; i != cases.length; ++i) {
>, <Line: +				Bytecode.Case cAse = cases[i];
>, <Line: +				Constant[] values = cAse.values();
>, <Line: +				output.write_uv(cAse.block());
>, <Line: +				output.write_uv(values.length);
>, <Line: +				for (int j = 0; j != values.length; ++j) {
>, <Line: +					output.write_uv(constantCache.get(values[j]));
>, <Line: +				}
>, <Line: +			break;
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_vardecl:
>, <Line: +		case Bytecode.OPCODE_vardeclinit: {
>, <Line: +			Bytecode.VariableDeclaration d = (Bytecode.VariableDeclaration) code;
>, <Line: +			output.write_uv(stringCache.get(d.getName()));
>, <Line: +			break;
>, <Line: +		}
>, <Line: +	private void buildPools(WyilFile.Constant declaration) {
>, <Line: +		addConstantItem(declaration.constant());
>, <Line: +	private void buildPools(WyilFile.Type declaration) {
>, <Line: +		addTypeItem(declaration.type());
>, <Line: +		buildPools(declaration.getTree());
>, <Line: +		buildPools(declaration.getTree());
>, <Line: +	private void buildPools(SyntaxTree tree) {
>, <Line: +		for(Location<?> e : tree.getLocations()) {
>, <Line: +			buildPools(e);
>, <Line: +	private void buildPools(SyntaxTree.Location<?> loc) {
>, <Line: +		for(int i=0;i!=loc.numberOfTypes();++i) {
>, <Line: +			addTypeItem(loc.getType(i));
>, <Line: +		buildPools(loc.getBytecode());
>, <Line: +		} else if (code instanceof Bytecode.Invoke) {
>, <Line: +			addTypeItem(c.type());
>, <Line: +		} else if(code instanceof Bytecode.NamedBlock) {
>, <Line: +			Bytecode.NamedBlock nb = (Bytecode.NamedBlock) code;
>, <Line: +			addStringItem(nb.getName());
>, <Line: +			for (Bytecode.Case cs : s.cases()) {
>, <Line: +				for (Constant c : cs.values()) {
>, <Line: +					addConstantItem(c);
>, <Line: +				}
>, <Line: +		} else if (code instanceof Bytecode.IndirectInvoke) {
>, <Line: +			Bytecode.IndirectInvoke b = (Bytecode.IndirectInvoke) code;
>, <Line: +			addTypeItem(b.type());
>, <Line: +		} else if (code instanceof Bytecode.Invoke) {
>, <Line: +			Bytecode.Invoke b = (Bytecode.Invoke) code;
>, <Line: +			addTypeItem(b.type());
>, <Line: +		} else if (code instanceof Bytecode.VariableDeclaration) {
>, <Line: +			Bytecode.VariableDeclaration vd = (Bytecode.VariableDeclaration) code;
>, <Line: +			addStringItem(vd.getName());
>, <Line: +		} else if (v instanceof Constant.FunctionOrMethod) {
>, <Line: +			Constant.FunctionOrMethod fm = (Constant.FunctionOrMethod) v;
>, <Line: +		} else if (v instanceof Constant.Type) {
>, <Line: +			Constant.Type ct = (Constant.Type) v;
>, <Line: +			addTypeItem(ct.value());
>, <Line: +	public final static int CONSTANT_Type = 12;
>]
[<Line: -		case BLOCK_CodeForest:
>, <Line: -			bytes = generateCodeForest((BytecodeForest) data);
>, <Line: -			break;
>, <Line: -			} else if (val instanceof Constant.Lambda) {
>, <Line: -				Constant.Lambda fm = (Constant.Lambda) val;
>, <Line: -	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: -	 * | CodeForest : invariant |
>, <Line: -	 * Finally, <code>invariant</code> gives the type's invariant as zero or
>, <Line: -	 * more bytecode blocks.
>, <Line: -		output.write_uv(stringCache.get(td.name()));
>, <Line: -		output.write_uv(generateModifiers(td.modifiers()));
>, <Line: -		output.write_uv(typeCache.get(td.type()));
>, <Line: -		writeBlock(BLOCK_CodeForest, td.invariant(), output);
>, <Line: -	 * | uv : nRequires         |
>, <Line: -	 * | uv : nEnsures          |
>, <Line: -	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: -	 * | CodeForest : code      |
>, <Line: -	 * type itself. Finally, <code>code</code> provides all code associated with
>, <Line: -	 * the function or method which includes any preconditions, postconditions
>, <Line: -	 * and the body itself. Here, <code>nRequires</code> identifiers the number
>, <Line: -	 * of roots which correspond to the precondition, whilst
>, <Line: -	 * <code>nEnsures</code> the number of roots corresponding to the
>, <Line: -	 * postcondition. Any root after this comprise the body.
>, <Line: -		output.write_uv(stringCache.get(md.name()));
>, <Line: -		output.write_uv(generateModifiers(md.modifiers()));
>, <Line: -		output.write_uv(typeCache.get(md.type()));
>, <Line: -		output.write_uv(md.preconditions().length);
>, <Line: -		output.write_uv(md.postconditions().length);
>, <Line: -		output.pad_u8(); // pad out to next byte boundary
>, <Line: -		writeBlock(BLOCK_CodeForest, md.code(), output);
>, <Line: -		output.close();
>, <Line: -		return bytes.toByteArray();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Construct a code forest using a given set of pre-calculated label
>, <Line: -	 * offsets. The format is:
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * <pre>
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nRegs          |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nBlocks        |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nRoots         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nAttrs         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | Register[nRegs]    |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv[nRoots]         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | CodeBlock[nBlocks] |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | Attribute[nAttrs]  |
>, <Line: -	 * +--------------------+
>, <Line: -	 * </pre>
>, <Line: -	 * 
>, <Line: -	 * <p>
>, <Line: -	 * Each bytecode has a given offset which is calculated from the start of
>, <Line: -	 * all blocks. For example, assume block 1 has ten actual bytecodes (i.e.
>, <Line: -	 * which are not labels); then, a bytecode at index 2 in block 2 has offset
>, <Line: -	 * 12.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * The mapping of label names to their bytecode offsets is needed when
>, <Line: -	 * writing branching bytecodes (e.g. goto). Each label object is associated
>, <Line: -	 * with the bytecode following it in the block.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param forest
>, <Line: -	 *            The forest being written to the stream
>, <Line: -	 * @param labels
>, <Line: -	 *            The set of pre-calculated label offsets
>, <Line: -	 * @throws IOException
>, <Line: -	 */
>, <Line: -	private byte[] generateCodeForest(BytecodeForest forest) throws IOException {
>, <Line: -		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
>, <Line: -		BinaryOutputStream output = new BinaryOutputStream(bytes);
>, <Line: -		HashMap<String, Integer> labels = buildLabelsMap(forest);
>, <Line: -		output.write_uv(forest.numRegisters());
>, <Line: -		output.write_uv(forest.numBlocks());
>, <Line: -		output.write_uv(forest.numRoots());
>, <Line: -		output.write_uv(0); // currently no attributes
>, <Line: -		List<BytecodeForest.Register> registers = forest.registers();
>, <Line: -		for (int i = 0; i != registers.size(); ++i) {
>, <Line: -			writeCodeRegister(registers.get(i), output);
>, <Line: -		// FIXME: in principle we can get rid of the following by reorgansing
>, <Line: -		// the forest so that root blocks come first.
>, <Line: -		for (int i = 0; i != forest.numRoots(); ++i) {
>, <Line: -			output.write_uv(forest.getRoot(i));
>, <Line: -		}
>, <Line: -		int offset = 0;
>, <Line: -		for (int i = 0; i != forest.numBlocks(); ++i) {
>, <Line: -			BytecodeForest.Block block = forest.get(i);
>, <Line: -			offset = writeCodeBlock(block, offset, labels, output);
>, <Line: -		return bytes.toByteArray();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Construct a mapping of labels to the bytecode offsets they represent
>, <Line: -	 * within the code forest. Labels do not correspond to "real" bytecodes
>, <Line: -	 * which are written out. Rather they are associated with the offset of
>, <Line: -	 * the bytecode immediately following them in a given block.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * Each bytecode has a given offset which is calculated from the start of
>, <Line: -	 * all blocks. For example, assume block 1 has ten actual bytecodes (i.e.
>, <Line: -	 * which are not labels); then, a bytecode at index 2 in block 2 has offset
>, <Line: -	 * 12.
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * The purpose of the label mapping is to enable branch offsets to be
>, <Line: -	 * calculated when writing them out.
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param forest
>, <Line: -	 *            Code forest to construct label mapping from
>, <Line: -	 * @param labels
>, <Line: -	 *            Lab map being constructed
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private HashMap<String, Integer> buildLabelsMap(BytecodeForest forest) {
>, <Line: -		HashMap<String, Integer> labels = new HashMap<String, Integer>();
>, <Line: -		int offset = 0;
>, <Line: -		for (int i = 0; i != forest.numBlocks(); ++i) {
>, <Line: -			BytecodeForest.Block block = forest.get(i);
>, <Line: -			for (int j = 0; j != block.size(); ++j) {
>, <Line: -				Bytecode code = block.get(j).code();
>, <Line: -				if (code instanceof Bytecode.Label) {
>, <Line: -					Bytecode.Label l = (Bytecode.Label) code;
>, <Line: -					labels.put(l.label(), offset-1);
>, <Line: -				} else {
>, <Line: -					offset = offset + 1;
>, <Line: -				}
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return labels;
>, <Line: -	 * Write details of a given code register to the output stream. The format
>, <Line: -	 * of reach register entry is:
>, <Line: -	 * | uv : nAttrs       |
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv : typeIdx      |
>, <Line: -	 * | Attribute[nAttrs] |
>, <Line: -	private void writeCodeRegister(BytecodeForest.Register register, BinaryOutputStream output) throws IOException {
>, <Line: -		// TODO: write out register attributes (including name)
>, <Line: -		output.write_uv(0);
>, <Line: -		// Write out the type index
>, <Line: -		output.write_uv(typeCache.get(register.type()));
>, <Line: -	 * <p>
>, <Line: -	 * Write out a block of bytecodes using a given set of pre-calculated label
>, <Line: -	 * offsets. The format is:
>, <Line: -	 * </p>
>, <Line: -	 * | uv : nCodes       |
>, <Line: -	 * | Bytecode[nCodes]  |
>, <Line: -	 * <p>
>, <Line: -	 * The block is associated with a given offset value, which indicates the
>, <Line: -	 * offset of the first bytecode in the block to be used when calculating
>, <Line: -	 * branch offsets.
>, <Line: -	 * </p>
>, <Line: -	 * 
>, <Line: -	 * @param block
>, <Line: -	 * @param offset
>, <Line: -	 * @param labels
>, <Line: -	 * @param output
>, <Line: -	 * @return
>, <Line: -	 * @throws IOException
>, <Line: -	private int writeCodeBlock(BytecodeForest.Block block, int offset, HashMap<String, Integer> labels,
>, <Line: -			BinaryOutputStream output) throws IOException {
>, <Line: -		// First, determine how many labels there are in this block (since
>, <Line: -		// labels are not real bytecodes)
>, <Line: -		int nlabels = countLabels(block);
>, <Line: -		// Second, write the count of bytecodes
>, <Line: -		output.write_uv(block.size() - nlabels);
>, <Line: -		// Third, write the count of attributes
>, <Line: -		// TODO: write out attributes
>, <Line: -		output.write_uv(0);
>, <Line: -		// Finally, write the actual bytecodes!
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			Bytecode code = block.get(i).code();
>, <Line: -			if (code instanceof Bytecode.Label) {
>, <Line: -				// Skip over labels because these are not written to disk and
>, <Line: -				// have no "offset"
>, <Line: -			} else {
>, <Line: -				writeBytecode(code, offset, labels, output);
>, <Line: -				offset = offset + 1;
>, <Line: -			}
>, <Line: -		// TODO: write attributes
>, <Line: -		return offset;
>, <Line: -	 * Write out a given bytecode a given set of pre-calculated label offsets,
>, <Line: -	 * whose format is currently given as follows:
>, <Line: -	 * | uv : nTargets     |
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv : nOperands    |
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv : nTypes       | 
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv[nTargets]      |
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv[nOperands]     |
>, <Line: -	 * +-------------------+ 
>, <Line: -	 * | uv[nTypes]        |
>, <Line: -	 * +-------------------+
>, <Line: -	 * | uv[] rest         |
>, <Line: -	 * +-------------------+
>, <Line: -	private void writeBytecode(Bytecode code, int offset, HashMap<String, Integer> labels, BinaryOutputStream output)
>, <Line: -		writeCommon(code, output);
>, <Line: -		writeRest(code, offset, labels, output);
>, <Line: -	/**
>, <Line: -	 * Write the "common" part of a bytecode instruction. This includes the
>, <Line: -	 * opcode, target register, operand registers, types and attributes.
>, <Line: -	 *
>, <Line: -	 * @param code
>, <Line: -	 *            --- The bytecode to be written.
>, <Line: -	 * @param output
>, <Line: -	 *            --- The binary stream to write this bytecode to.
>, <Line: -	 * @throws IOException
>, <Line: -	 */
>, <Line: -	private void writeCommon(Bytecode code, BinaryOutputStream output) throws IOException {
>, <Line: -		output.write_u8(code.opcode());
>, <Line: -		int[] targets = code.targets();
>, <Line: -		int[] operands = code.operands();
>, <Line: -		Type[] types = code.types();
>, <Line: -		output.write_uv(targets.length);
>, <Line: -		output.write_uv(operands.length);
>, <Line: -		output.write_uv(types.length);
>, <Line: -		output.write_uv(0); // attributes
>, <Line: -		// Write target registers
>, <Line: -		for (int i = 0; i != targets.length; ++i) {
>, <Line: -			output.write_uv(targets[i]);
>, <Line: -		// Write operand registers
>, <Line: -		for (int i = 0; i != operands.length; ++i) {
>, <Line: -			output.write_uv(operands[i]);
>, <Line: -		// Write type indices
>, <Line: -		for (int i = 0; i != types.length; ++i) {
>, <Line: -			output.write_uv(typeCache.get(types[i]));
>, <Line: -		// TODO: write attributes
>, <Line: -	 * @param labels
>, <Line: -	 *            --- A map from label to offset. This is required to determine
>, <Line: -	 *            the (relative) jump offset for a branching instruction.
>, <Line: -	private void writeRest(Bytecode code, int offset, HashMap<String, Integer> labels,
>, <Line: -			BinaryOutputStream output) throws IOException {
>, <Line: -		// now deal with non-uniform instructions
>, <Line: -		// First, deal with special cases
>, <Line: -		if(code instanceof Bytecode.Compound) {
>, <Line: -			// Assert / Assume / Loop / Quantify
>, <Line: -			Bytecode.Compound cb = (Bytecode.Compound) code; 
>, <Line: -			output.write_uv(cb.block());
>, <Line: -		} else if(code instanceof Bytecode.Branching) {
>, <Line: -			Bytecode.Branching bb = (Bytecode.Branching) code;
>, <Line: -			int destination = labels.get(bb.destination());
>, <Line: -			output.write_uv(destination);
>, <Line: -		} else if (code instanceof Bytecode.Const) {
>, <Line: -		} else if (code instanceof Bytecode.FieldLoad) {
>, <Line: -		} else if (code instanceof Bytecode.Invoke) {
>, <Line: -		} else if (code instanceof Bytecode.Lambda) {
>, <Line: -			output.write_uv(nameCache.get(c.name()));
>, <Line: -		} else if (code instanceof Bytecode.Update) {
>, <Line: -			Bytecode.Update c = (Bytecode.Update) code;
>, <Line: -			List<String> fields = c.fields;
>, <Line: -			output.write_uv(fields.size());
>, <Line: -			for (int i = 0; i != fields.size(); ++i) {
>, <Line: -				output.write_uv(stringCache.get(fields.get(i)));
>, <Line: -			}
>, <Line: -		} else if (code instanceof Bytecode.Switch) {
>, <Line: -			List<Pair<Constant, String>> branches = c.branches();
>, <Line: -			int target = labels.get(c.defaultTarget());
>, <Line: -			output.write_uv(target);
>, <Line: -			output.write_uv(branches.size());
>, <Line: -			for (Pair<Constant, String> b : branches) {
>, <Line: -				output.write_uv(constantCache.get(b.first()));
>, <Line: -				target = labels.get(b.second());
>, <Line: -				output.write_uv(target);
>, <Line: -	/**
>, <Line: -	 * Count the number of label bytecodes in a given block. This is needed to
>, <Line: -	 * help calculate the number of "real" bytecodes in that block, since labels
>, <Line: -	 * are not real bytecodes. Rather they are just markers acting as branch
>, <Line: -	 * targets.
>, <Line: -	 * 
>, <Line: -	 * @param block
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private int countLabels(BytecodeForest.Block block) {
>, <Line: -		int nlabels = 0;
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			Bytecode code = block.get(i).code();
>, <Line: -			if (code instanceof Bytecode.Label) {
>, <Line: -				nlabels++;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return nlabels;
>, <Line: -	}
>, <Line: -	private void buildPools(WyilFile.Type declaration) {
>, <Line: -		addTypeItem(declaration.type());
>, <Line: -		buildPools(declaration.invariant());
>, <Line: -	private void buildPools(WyilFile.Constant declaration) {
>, <Line: -		addConstantItem(declaration.constant());
>, <Line: -		buildPools(declaration.code());		
>, <Line: -	private void buildPools(BytecodeForest forest) {		
>, <Line: -		for(int i=0;i!=forest.numRegisters();++i) {
>, <Line: -			buildPools(forest.getRegister(i));
>, <Line: -		}
>, <Line: -		for(int i=0;i!=forest.numBlocks();++i) {
>, <Line: -			buildPools(forest.get(i));
>, <Line: -	private void buildPools(BytecodeForest.Register reg) {
>, <Line: -		addTypeItem(reg.type());
>, <Line: -	}
>, <Line: -	private void buildPools(BytecodeForest.Block block) {
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			BytecodeForest.Entry entry = block.get(i);
>, <Line: -			buildPools(entry.code());			
>, <Line: -			// TODO: handle entry attributes
>, <Line: -		// First, deal with special cases
>, <Line: -		}else if (code instanceof Bytecode.Invoke) {
>, <Line: -		} else if (code instanceof Bytecode.Lambda) {
>, <Line: -			Bytecode.Lambda c = (Bytecode.Lambda) code;
>, <Line: -			addNameItem(c.name());
>, <Line: -		} else if (code instanceof Bytecode.Update) {
>, <Line: -			Bytecode.Update c = (Bytecode.Update) code;
>, <Line: -			for (Bytecode.LVal l : c) {
>, <Line: -				if (l instanceof Bytecode.RecordLVal) {
>, <Line: -					Bytecode.RecordLVal lv = (Bytecode.RecordLVal) l;
>, <Line: -					addStringItem(lv.field);
>, <Line: -				}
>, <Line: -			}
>, <Line: -			for (Pair<Constant, String> b : s.branches()) {
>, <Line: -				addConstantItem(b.first());
>, <Line: -		}
>, <Line: -		// Second, deal with standard cases
>, <Line: -		for (Type type : code.types()) {
>, <Line: -			addTypeItem(type);
>, <Line: -		} else if (v instanceof Constant.Lambda) {
>, <Line: -			Constant.Lambda fm = (Constant.Lambda) v;
>, <Line: -	public final static int BLOCK_CodeForest = 20;
>, <Line: -	// ... (anticipating some others here)
>, <Line: -	// public final static int CONSTANT_Map = 12;
>]