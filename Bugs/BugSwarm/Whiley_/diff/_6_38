[<Line: +package wyil.builders;
>, <Line: +import static wyil.lang.Bytecode.OPCODE_aliasdecl;
>, <Line: +import static wyil.lang.Bytecode.OPCODE_varaccess;
>, <Line: +import static wyil.lang.Bytecode.OPCODE_vardecl;
>, <Line: +import static wyil.lang.Bytecode.OPCODE_vardeclinit;
>, <Line: +import static wyil.util.ErrorMessages.errorMessage;
>, <Line: +import static wyil.util.ErrorMessages.internalFailure;
>, <Line: +import java.math.BigInteger;
>, <Line: +import java.util.*;
>, <Line: +import wycc.lang.Attribute;
>, <Line: +import wycc.lang.NameID;
>, <Line: +import wycc.lang.SyntacticElement;
>, <Line: +import wycc.lang.SyntaxError.InternalFailure;
>, <Line: +import wycc.util.Pair;
>, <Line: +import wycc.util.ResolveError;
>, <Line: +import wycs.core.Value;
>, <Line: +import wycs.syntax.Expr;
>, <Line: +import wycs.syntax.SyntacticType;
>, <Line: +import wycs.syntax.TypePattern;
>, <Line: +import wycs.syntax.WyalFile;
>, <Line: +import wyfs.lang.Path;
>, <Line: +import wyfs.util.Trie;
>, <Line: +import wyil.lang.Bytecode;
>, <Line: +import wyil.lang.Bytecode.*;
>, <Line: +import wyil.lang.SyntaxTree;
>, <Line: +import wyil.lang.SyntaxTree.Location;
>, <Line: +import wyil.lang.Constant;
>, <Line: +import wyil.lang.Type;
>, <Line: +import wyil.lang.WyilFile;
>, <Line: +import wyil.util.ErrorMessages;
>, <Line: +import wyil.util.SyntaxTrees;
>, <Line: +import wyil.util.TypeSystem;
>, <Line: +/**
>, <Line: + * <p>
>, <Line: + * Responsible for generating verification conditions from a given WyIL file. A
>, <Line: + * verification condition is a logical condition which must be shown to hold in
>, <Line: + * order for the underlying WyIL program to considered "correct". The
>, <Line: + * Verification Condition Generator (VCG) examines in turn each function or
>, <Line: + * method in a given WyIL file. The VCG traverses each control-flow graph
>, <Line: + * emitting verification conditions as it discovers them. The following
>, <Line: + * illustrates:
>, <Line: + * </p>
>, <Line: + * 
>, <Line: + * <pre>
>, <Line: + * function abs(int x) -> (int r)
>, <Line: + * ensures r >= 0:
>, <Line: + *     //
>, <Line: + *     if x >= 0:
>, <Line: + *        return x
>, <Line: + *     else:
>, <Line: + *        return -x
>, <Line: + * </pre>
>, <Line: + *
>, <Line: + * <p>
>, <Line: + * The above function can be viewed in a slightly more precise fashion as
>, <Line: + * follows, where the block structure is indicated:
>, <Line: + * </p>
>, <Line: + *
>, <Line: + * <pre>
>, <Line: + * +-----------------------------+ (1)
>, <Line: + * |function abs(int x) -> (int r)
>, <Line: + * |ensures r >= 0:
>, <Line: + * |  +--------------------------+ (2)
>, <Line: + * |  |  //
>, <Line: + * |  |  if x >= 0:
>, <Line: + * |  |   +----------------------+ (3)
>, <Line: + * |  |   | return x
>, <Line: + * |  |   +----------------------+
>, <Line: + * |  |  else:
>, <Line: + * |  |   +----------------------+ (4)
>, <Line: + * |  |   | return -x
>, <Line: + * |  |   +----------------------+
>, <Line: + * |  +--------------------------+
>, <Line: + * +-----------------------------+
>, <Line: + * </pre>
>, <Line: + * 
>, <Line: + * <p>
>, <Line: + * The VCG will generate exactly two verification conditions from this function
>, <Line: + * corresponding to the paths "1,2,3" and "1,2,4". These verification conditions
>, <Line: + * are required to ensure that, given the information know at the point of each
>, <Line: + * return, we can establish the post-condition holds. The two verification
>, <Line: + * conditions are:
>, <Line: + * </p>
>, <Line: + * 
>, <Line: + * <ul>
>, <Line: + * <li><b>1,2,3:</b> <code>x >= 0 ==> x >= 0</code>. This verification
>, <Line: + * corresponds to the case where the if condition is known to be true.</li>
>, <Line: + * <li><b>1,2,4:</b> <code>x < 0 ==> -x >= 0</code>. This verification
>, <Line: + * corresponds to the case where the if condition is known to be false.</li>
>, <Line: + * </ul>
>, <Line: + * 
>, <Line: + * <p>
>, <Line: + * The VCG attempts to generate verification conditions which are easier to read
>, <Line: + * by making use of macros as much as possible. For example, each clause of a
>, <Line: + * function/method's precondition or postcondition is turned into a distinct
>, <Line: + * (named) macro.
>, <Line: + * </p>
>, <Line: + * 
>, <Line: + * @author David J. Pearce
>, <Line: + *
>, <Line: + */
>, <Line: +public class VerificationConditionGenerator {
>, <Line: +	private final Wyil2WyalBuilder builder;
>, <Line: +	private final TypeSystem typeSystem;
>, <Line: +	public VerificationConditionGenerator(Wyil2WyalBuilder builder) {
>, <Line: +		this.builder = builder;
>, <Line: +		this.typeSystem = new TypeSystem(builder.project());
>, <Line: +	}
>, <Line: +	// ===============================================================================
>, <Line: +	// Top-Level Controller
>, <Line: +	// ===============================================================================
>, <Line: +	/**
>, <Line: +	 * Translate a WyilFile into a WyalFile which contains the verification
>, <Line: +	 * conditions necessary to establish that all functions and methods in the
>, <Line: +	 * WyilFile meet their specifications, and that no array-out-of-bounds or
>, <Line: +	 * division-by-zero exceptions are possible (amongst other things).
>, <Line: +	 * 
>, <Line: +	 * @param wyilFile
>, <Line: +	 *            The input file to be translated
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public WyalFile translate(WyilFile wyilFile) {
>, <Line: +		WyalFile wyalFile = new WyalFile(wyilFile.id(), wyilFile.filename());
>, <Line: +		for (WyilFile.Block b : wyilFile.blocks()) {
>, <Line: +			if (b instanceof WyilFile.Constant) {
>, <Line: +				translateConstantDeclaration((WyilFile.Constant) b, wyalFile);
>, <Line: +			} else if (b instanceof WyilFile.Type) {
>, <Line: +				translateTypeDeclaration((WyilFile.Type) b, wyalFile);
>, <Line: +			} else if (b instanceof WyilFile.FunctionOrMethod) {
>, <Line: +				WyilFile.FunctionOrMethod method = (WyilFile.FunctionOrMethod) b;
>, <Line: +				translateFunctionOrMethodDeclaration(method, wyalFile);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return wyalFile;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a constant declaration into WyAL. At the moment, this does
>, <Line: +	 * nothing because constant declarations are not supported in WyAL files.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            The type declaration being translated.
>, <Line: +	 * @param wyalFile
>, <Line: +	 *            The WyAL file being constructed
>, <Line: +	 */
>, <Line: +	private void translateConstantDeclaration(WyilFile.Constant decl, WyalFile wyalFile) {
>, <Line: +		// FIXME: WyAL file format should support constants
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Transform a type declaration into verification conditions as necessary.
>, <Line: +	 * In particular, the type should be "inhabitable". This means, for example,
>, <Line: +	 * that the invariant does not contradict itself. Furthermore, we need to
>, <Line: +	 * translate the type invariant into a macro block.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            The type declaration being translated.
>, <Line: +	 * @param wyalFile
>, <Line: +	 *            The WyAL file being constructed
>, <Line: +	 */
>, <Line: +	private void translateTypeDeclaration(WyilFile.Type declaration, WyalFile wyalFile) {
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		List<Location<Bytecode.Expr>> invariants = declaration.getInvariant();
>, <Line: +		// First, translate the invariant (if applicable)
>, <Line: +		Expr.Variable var = null;
>, <Line: +		Expr invariant = null;
>, <Line: +		if (invariants.size() > 0) {
>, <Line: +			Location<VariableDeclaration> v = (Location<VariableDeclaration>) tree.getLocation(0);
>, <Line: +			var = new Expr.Variable(v.getBytecode().getName(), v.attributes());
>, <Line: +			invariant = generateTypeInvariants(declaration, invariants, var);
>, <Line: +		}
>, <Line: +		// FIXME: add inhabitability check
>, <Line: +		// Convert the type into a type pattern
>, <Line: +		SyntacticType type = convert(declaration.type(), declaration);
>, <Line: +		TypePattern.Leaf pattern = new TypePattern.Leaf(type, var);
>, <Line: +		// Done
>, <Line: +		WyalFile.Type td = wyalFile.new Type(declaration.name(), Collections.EMPTY_LIST, pattern, invariant,
>, <Line: +				declaration.attributes());
>, <Line: +		wyalFile.add(td);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate each of the clauses representing the invariant of a type.
>, <Line: +	 * 
>, <Line: +	 * @param invariants
>, <Line: +	 * @param var
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr generateTypeInvariants(WyilFile.Type declaration, List<Location<Bytecode.Expr>> invariants,
>, <Line: +			Expr.Variable var) {
>, <Line: +		GlobalEnvironment globalEnvironment = new GlobalEnvironment(declaration);
>, <Line: +		LocalEnvironment localEnvironment = new LocalEnvironment(globalEnvironment);
>, <Line: +		Expr invariant = null;
>, <Line: +		for (int i = 0; i != invariants.size(); ++i) {
>, <Line: +			Expr clause = translateExpression(invariants.get(i), localEnvironment);
>, <Line: +			// FIXME: this is ugly. Instead, WyAL files could support
>, <Line: +			// multiple invariant clauses?
>, <Line: +			invariant = and(invariant, clause);
>, <Line: +		}
>, <Line: +		return invariant;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Transform a function or method declaration into verification conditions
>, <Line: +	 * as necessary. This is done by traversing the control-flow graph of the
>, <Line: +	 * function or method in question. Verifications are emitted when conditions
>, <Line: +	 * are encountered which must be checked. For example, that the
>, <Line: +	 * preconditions are met at a function invocation.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            The function or method declaration being translated.
>, <Line: +	 * @param wyalFile
>, <Line: +	 *            The WyAL file being constructed
>, <Line: +	 */
>, <Line: +	private void translateFunctionOrMethodDeclaration(WyilFile.FunctionOrMethod declaration, WyalFile wyalFile) {
>, <Line: +		// Create the prototype for this function or method. This is the
>, <Line: +		// function or method declaration which can be used within verification
>, <Line: +		// conditions to refer to this function or method. This does not include
>, <Line: +		// a body, since function or methods are treated as being
>, <Line: +		// "uninterpreted" for the purposes of verification.
>, <Line: +		createFunctionOrMethodPrototype(declaration, wyalFile);
>, <Line: +		// Create macros representing the individual clauses of the function or
>, <Line: +		// method's precondition and postcondition. These macros can then be
>, <Line: +		// called either to assume the precondition/postcondition or to check
>, <Line: +		// them. Using individual clauses helps to provide better error
>, <Line: +		// messages.
>, <Line: +		translatePreconditionMacros(declaration, wyalFile);
>, <Line: +		translatePostconditionMacros(declaration, wyalFile);
>, <Line: +		// The environments are needed to prevent clashes between variable
>, <Line: +		// versions across verification conditions, and also to type variables
>, <Line: +		// used in verification conditions.
>, <Line: +		GlobalEnvironment globalEnvironment = new GlobalEnvironment(declaration);
>, <Line: +		LocalEnvironment localEnvironment = new LocalEnvironment(globalEnvironment);
>, <Line: +		// Generate the initial assumption set for a given function or method,
>, <Line: +		// which roughly corresponds to its precondition.
>, <Line: +		AssumptionSet assumptions = generateFunctionOrMethodAssumptionSet(declaration, localEnvironment);
>, <Line: +		// Generate verification conditions by propagating forwards through the
>, <Line: +		// control-flow graph of the function or method in question. For each
>, <Line: +		// statement encountered, generate the preconditions which must hold
>, <Line: +		// true at that point. Furthermore, generate the effect of this
>, <Line: +		// statement on the current state.
>, <Line: +		List<VerificationCondition> vcs = new ArrayList<VerificationCondition>();
>, <Line: +		Context context = new Context(wyalFile, assumptions, localEnvironment, null, vcs);
>, <Line: +		translateStatementBlock(declaration.getBody(), context);
>, <Line: +		//
>, <Line: +		// Translate each generated verification condition into an assertion in
>, <Line: +		// the underlying WyalFile.
>, <Line: +		createAssertions(declaration, vcs, globalEnvironment, wyalFile);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate the sequence of invariant expressions which constitute the
>, <Line: +	 * precondition of a function or method into corresponding macro
>, <Line: +	 * declarations.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 * @param environment
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private void translatePreconditionMacros(WyilFile.FunctionOrMethod declaration, WyalFile wyalFile) {
>, <Line: +		List<Location<Bytecode.Expr>> invariants = declaration.getPrecondition();
>, <Line: +		//
>, <Line: +		String prefix = declaration.name() + "_requires_";
>, <Line: +		//
>, <Line: +		for (int i = 0; i != invariants.size(); ++i) {
>, <Line: +			String name = prefix + i;
>, <Line: +			// Construct fresh environment for this macro. This is necessary to
>, <Line: +			// avoid name clashes with subsequent macros.
>, <Line: +			GlobalEnvironment globalEnvironment = new GlobalEnvironment(declaration);
>, <Line: +			LocalEnvironment localEnvironment = new LocalEnvironment(globalEnvironment);
>, <Line: +			TypePattern type = generatePreconditionTypePattern(declaration, localEnvironment);
>, <Line: +			// Translate expression itself
>, <Line: +			Expr clause = translateExpression(invariants.get(i), localEnvironment);
>, <Line: +			// Capture any free variables. This is necessary to deal with any
>, <Line: +			// variable aliases introduced by type test operators.
>, <Line: +			clause = captureFreeVariables(declaration, globalEnvironment, clause);
>, <Line: +			//
>, <Line: +			wyalFile.add(
>, <Line: +					wyalFile.new Macro(name, Collections.EMPTY_LIST, type, clause, invariants.get(i).attributes()));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate the sequence of invariant expressions which constitute the
>, <Line: +	 * postcondition of a function or method into corresponding macro
>, <Line: +	 * declarations.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 * @param environment
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private void translatePostconditionMacros(WyilFile.FunctionOrMethod declaration, WyalFile wyalFile) {
>, <Line: +		List<Location<Bytecode.Expr>> invariants = declaration.getPostcondition();
>, <Line: +		//
>, <Line: +		String prefix = declaration.name() + "_ensures_";
>, <Line: +		//
>, <Line: +		for (int i = 0; i != invariants.size(); ++i) {
>, <Line: +			String name = prefix + i;
>, <Line: +			// Construct fresh environment for this macro. This is necessary to
>, <Line: +			// avoid name clashes with subsequent macros.
>, <Line: +			GlobalEnvironment globalEnvironment = new GlobalEnvironment(declaration);
>, <Line: +			LocalEnvironment localEnvironment = new LocalEnvironment(globalEnvironment);
>, <Line: +			TypePattern type = generatePostconditionTypePattern(declaration, localEnvironment);
>, <Line: +			Expr clause = translateExpression(invariants.get(i), localEnvironment.clone());
>, <Line: +			// Capture any free variables. This is necessary to deal with any
>, <Line: +			// variable aliases introduced by type test operators.
>, <Line: +			clause = captureFreeVariables(declaration, globalEnvironment, clause);
>, <Line: +			//
>, <Line: +			wyalFile.add(
>, <Line: +					wyalFile.new Macro(name, Collections.EMPTY_LIST, type, clause, invariants.get(i).attributes()));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Expr captureFreeVariables(WyilFile.Declaration declaration, GlobalEnvironment globalEnvironment,
>, <Line: +			Expr clause) {
>, <Line: +		HashSet<String> freeVariables = new HashSet<String>();
>, <Line: +		HashSet<String> freeAliases = new HashSet<String>();
>, <Line: +		clause.freeVariables(freeVariables);
>, <Line: +		for (String var : freeVariables) {
>, <Line: +			if (globalEnvironment.getParent(var) != null) {
>, <Line: +				// This indicates that the given variable is an alias, rather
>, <Line: +				// than a top-level declaration.
>, <Line: +				freeAliases.add(var);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Determine any variable aliases as necessary.
>, <Line: +		if (freeAliases.size() > 0) {
>, <Line: +			// This indicates there are one or more free variables in the
>, <Line: +			// clause. Hence, these must be universally quantified to ensure the
>, <Line: +			// clause is well=typed.
>, <Line: +			TypePattern types = generateExpressionTypePattern(declaration, globalEnvironment, freeAliases);
>, <Line: +			Expr aliases = determineVariableAliases(globalEnvironment, freeAliases);
>, <Line: +			//
>, <Line: +			clause = new Expr.ForAll(types, implies(aliases, clause));
>, <Line: +		}
>, <Line: +		return clause;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate the initial assumption set for a function or method. This is
>, <Line: +	 * essentially made up of the precondition(s) for that function or method.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private AssumptionSet generateFunctionOrMethodAssumptionSet(WyilFile.FunctionOrMethod declaration,
>, <Line: +			LocalEnvironment environment) {
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		String prefix = declaration.name() + "_requires_";
>, <Line: +		Expr[] preconditions = new Expr[declaration.getPrecondition().size()];
>, <Line: +		Expr[] arguments = new Expr[declaration.type().params().size()];
>, <Line: +		// Translate parameters as arguments to invocation
>, <Line: +		for (int i = 0; i != arguments.length; ++i) {
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) tree.getLocation(i);
>, <Line: +			String versionedName = environment.read(var.getIndex());
>, <Line: +			arguments[i] = new Expr.Variable(versionedName, var.attributes());
>, <Line: +		}
>, <Line: +		//
>, <Line: +		Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +		//
>, <Line: +		for (int i = 0; i != preconditions.length; ++i) {
>, <Line: +			preconditions[i] = new Expr.Invoke(prefix + i, declaration.parent().id(), Collections.EMPTY_LIST, argument);
>, <Line: +		}
>, <Line: +		// Add all the preconditions as assupmtions
>, <Line: +		return AssumptionSet.ROOT.add(preconditions);
>, <Line: +	}
>, <Line: +	// =========================================================================
>, <Line: +	// Statements
>, <Line: +	// =========================================================================
>, <Line: +	private Context translateStatementBlock(Location<Block> block, Context context) {
>, <Line: +		for (int i = 0; i != block.numberOfOperands(); ++i) {
>, <Line: +			Location<?> stmt = block.getOperand(i);
>, <Line: +			context = translateStatement(stmt, context);
>, <Line: +			if (stmt.getBytecode() instanceof Bytecode.Return) {
>, <Line: +				return null;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	@SuppressWarnings("unchecked")
>, <Line: +	private Context translateStatement(Location<?> stmt, Context context) {
>, <Line: +		SyntaxTree tree = stmt.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		//
>, <Line: +		try {
>, <Line: +			switch (stmt.getOpcode()) {
>, <Line: +			case Bytecode.OPCODE_assert:
>, <Line: +				return translateAssert((Location<Assert>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_assign:
>, <Line: +				return translateAssign((Location<Assign>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_assume:
>, <Line: +				return translateAssume((Location<Assume>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_break:
>, <Line: +				return translateBreak((Location<Break>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_continue:
>, <Line: +				return translateContinue((Location<Continue>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_debug:
>, <Line: +				return context;
>, <Line: +			case Bytecode.OPCODE_dowhile:
>, <Line: +				return translateDoWhile((Location<DoWhile>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_fail:
>, <Line: +				return translateFail((Location<Fail>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_if:
>, <Line: +			case Bytecode.OPCODE_ifelse:
>, <Line: +				return translateIf((Location<If>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_indirectinvoke:
>, <Line: +				checkExpressionPreconditions(stmt, context);
>, <Line: +				translateIndirectInvoke((Location<IndirectInvoke>) stmt, context.getEnvironment());
>, <Line: +				return context;
>, <Line: +			case Bytecode.OPCODE_invoke:
>, <Line: +				checkExpressionPreconditions(stmt, context);
>, <Line: +				translateInvoke((Location<Invoke>) stmt, context.getEnvironment());
>, <Line: +				return context;
>, <Line: +			case Bytecode.OPCODE_namedblock:
>, <Line: +				return translateNamedBlock((Location<NamedBlock>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_return:
>, <Line: +				return translateReturn((Location<Return>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_skip:
>, <Line: +				return translateSkip((Location<Skip>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_switch:
>, <Line: +				return translateSwitch((Location<Switch>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_while:
>, <Line: +				return translateWhile((Location<While>) stmt, context);
>, <Line: +			case Bytecode.OPCODE_vardecl:
>, <Line: +			case Bytecode.OPCODE_vardeclinit:
>, <Line: +				return translateVariableDeclaration((Location<VariableDeclaration>) stmt, context);
>, <Line: +			default:
>, <Line: +				internalFailure("unknown statement encountered (" + stmt + ")", decl.parent().filename(),
>, <Line: +						stmt.attributes());
>, <Line: +				return null; // deadcode
>, <Line: +			}
>, <Line: +		} catch (InternalFailure e) {
>, <Line: +			throw e;
>, <Line: +		} catch (Throwable e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, stmt.attributes());
>, <Line: +			throw e; // deadcode
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assert statement. This emits a verification condition which
>, <Line: +	 * ensures the assert condition holds, given the current context.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateAssert(Location<Assert> stmt, Context context) {
>, <Line: +		Location<?> operand = stmt.getOperand(0);
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(operand, context);
>, <Line: +		Expr condition = p.first();
>, <Line: +		context = p.second();
>, <Line: +		//
>, <Line: +		VerificationCondition verificationCondition = new VerificationCondition("assertion failed", context.assumptions,
>, <Line: +				condition, operand.attributes());
>, <Line: +		context.emit(verificationCondition);
>, <Line: +		//
>, <Line: +		return context.assume(condition);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assign statement. This updates the version number of the
>, <Line: +	 * underlying assigned variable.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateAssign(Location<Assign> stmt, Context context) {
>, <Line: +		Location<?>[] lhs = stmt.getOperandGroup(0);
>, <Line: +		Location<?>[] rhs = stmt.getOperandGroup(1);
>, <Line: +		// TODO: generate checks for type invariants #666
>, <Line: +		for (int i = 0, j = 0; i != rhs.length; ++i) {
>, <Line: +			Location<?> rval = rhs[i];
>, <Line: +			Location<?>[] lval = Arrays.copyOfRange(lhs, j, rval.numberOfTypes());
>, <Line: +			context = translateAssign(lval, rval, context);
>, <Line: +			j = j + rval.numberOfTypes();
>, <Line: +		}
>, <Line: +		// Done
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an individual assignment from one rval to one or more lvals. If
>, <Line: +	 * there are multiple lvals, then a tuple is created to represent the
>, <Line: +	 * left-hand side.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            One or more expressions representing the left-hand side
>, <Line: +	 * @param rval
>, <Line: +	 *            A single expression representing the right-hand side
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context translateAssign(Location<?>[] lval, Location<?> rval, Context context) {
>, <Line: +		Pair<Expr, Context> rp = translateExpressionWithChecks(rval, context);
>, <Line: +		context = rp.second();
>, <Line: +		Expr[] ls = new Expr[lval.length];
>, <Line: +		for(int i=0;i!=ls.length;++i) {
>, <Line: +			Pair<Expr,Context> lp = translateSingleAssignment(lval[i], context);
>, <Line: +			ls[i] = lp.first();
>, <Line: +			context = lp.second();
>, <Line: +		}
>, <Line: +		Expr lhs = ls.length == 1 ? ls[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, ls);
>, <Line: +		//
>, <Line: +		Expr condition = new Expr.Binary(Expr.Binary.Op.EQ, lhs, rp.first());
>, <Line: +		//
>, <Line: +		return context.assume(condition);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an individual assignment from one rval to exactly one lval.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            A single location representing the left-hand side
>, <Line: +	 * @param rval
>, <Line: +	 *            A single expression representing the right-hand side
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr,Context> translateSingleAssignment(Location<?> lval, Context context) {
>, <Line: +		// FIXME: this method is a bit of a kludge. It would be nicer,
>, <Line: +		// eventually, to have all right-hand side expression represented in
>, <Line: +		// WyTP directly. This could potentially be done by including an update
>, <Line: +		// operation in WyTP ... ?
>, <Line: +		switch (lval.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_arrayindex:
>, <Line: +			return translateArrayAssign((Location<Operator>) lval, context);
>, <Line: +		case Bytecode.OPCODE_dereference:
>, <Line: +			// There's nothing useful we can do here.
>, <Line: +			return translateDereference((Location<Operator>) lval, context);
>, <Line: +		case Bytecode.OPCODE_fieldload:
>, <Line: +			return translateRecordAssign((Location<FieldLoad>) lval, context);
>, <Line: +		case Bytecode.OPCODE_varaccess:
>, <Line: +			return translateVariableAssign((Location<VariableAccess>) lval, context);
>, <Line: +		default:
>, <Line: +			internalFailure("unknown lval encountered (" + lval + ")", context.getEnclosingFile().filename(),
>, <Line: +					lval.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assignment to a field.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            The field access expression
>, <Line: +	 * @param result
>, <Line: +	 *            The value being assigned to the given array element
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr,Context> translateRecordAssign(Location<FieldLoad> lval, Context context) {
>, <Line: +		SyntaxTree tree = lval.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		try {
>, <Line: +			Bytecode.FieldLoad bytecode = lval.getBytecode();
>, <Line: +			Type.EffectiveRecord type = typeSystem.expandAsEffectiveRecord(lval.getOperand(0).getType());
>, <Line: +			// Translate source expression
>, <Line: +			Pair<Expr, Context> p = translateExpressionWithChecks(lval.getOperand(0), context);
>, <Line: +			Expr originalSource = p.first();
>, <Line: +			context = p.second();
>, <Line: +			// Generate new source expression based of havoced variable
>, <Line: +			Location<VariableAccess> var = extractAssignedVariable(lval);
>, <Line: +			if (var != null) {
>, <Line: +				context = context.havoc(var);
>, <Line: +			}
>, <Line: +			Expr newSource = translateExpression(lval.getOperand(0), context.getEnvironment());
>, <Line: +			//
>, <Line: +			ArrayList<String> fields = new ArrayList<String>(type.fields().keySet());
>, <Line: +			Collections.sort(fields);
>, <Line: +			int index = fields.indexOf(bytecode.fieldName());
>, <Line: +			for (int i = 0; i != fields.size(); ++i) {
>, <Line: +				if (i != index) {
>, <Line: +					Expr j = new Expr.Constant(Value.Integer(BigInteger.valueOf(i)));
>, <Line: +					Expr oldField = new Expr.IndexOf(originalSource, j, lval.attributes());
>, <Line: +					Expr newField = new Expr.IndexOf(newSource, j, lval.attributes());
>, <Line: +					context = context.assume(new Expr.Binary(Expr.Binary.Op.EQ, oldField, newField, lval.attributes()));
>, <Line: +				}
>, <Line: +			}
>, <Line: +			Expr j = new Expr.Constant(Value.Integer(BigInteger.valueOf(index)));
>, <Line: +			Expr newField = new Expr.IndexOf(newSource, j, lval.attributes());
>, <Line: +			return new Pair<Expr,Context>(newField,context);
>, <Line: +		} catch (ResolveError e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, lval.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assignment to an array element.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            The array assignment expression
>, <Line: +	 * @param result
>, <Line: +	 *            The value being assigned to the given array element
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr,Context> translateArrayAssign(Location<Operator> lval, Context context) {
>, <Line: +		SyntaxTree tree = lval.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		try {
>, <Line: +			Type elementType = typeSystem.expandAsEffectiveArray(lval.getOperand(0).getType()).element();
>, <Line: +			// Translate src and index expressions
>, <Line: +			Pair<Expr, Context> p1 = translateExpressionWithChecks(lval.getOperand(0), context);
>, <Line: +			Expr originalSource = p1.first();
>, <Line: +			context = p1.second();
>, <Line: +			Pair<Expr, Context> p2 = translateExpressionWithChecks(lval.getOperand(1), context);
>, <Line: +			Expr index = p2.first();
>, <Line: +			context = p2.second();
>, <Line: +			// Emit verification conditions to check access in bounds
>, <Line: +			checkIndexOutOfBounds(lval, context);
>, <Line: +			// Generate new source expression based of havoced variable
>, <Line: +			Location<VariableAccess> var = extractAssignedVariable(lval);
>, <Line: +			if (var != null) {
>, <Line: +				context = context.havoc(var);
>, <Line: +			}
>, <Line: +			Expr newSource = translateExpression(lval.getOperand(0), context.getEnvironment());
>, <Line: +			// Construct connection between new source expression and original
>, <Line: +			// source expression
>, <Line: +			Expr arg = new Expr.Nary(Expr.Nary.Op.TUPLE, new Expr[] { originalSource, newSource, index },
>, <Line: +					lval.attributes());
>, <Line: +			ArrayList<SyntacticType> generics = new ArrayList<SyntacticType>();
>, <Line: +			generics.add(convert(elementType, decl));
>, <Line: +			Expr.Invoke macro = new Expr.Invoke("update", Trie.fromString("wycs/core/Array"), generics, arg);
>, <Line: +			// Construct connection between new source expression element and
>, <Line: +			// result
>, <Line: +			Expr newLVal = new Expr.IndexOf(newSource, index, lval.attributes());
>, <Line: +			//
>, <Line: +			return new Pair<Expr,Context>(newLVal,context.assume(macro));
>, <Line: +		} catch (ResolveError e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, lval.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assignment to a variable
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            The array assignment expression
>, <Line: +	 * @param result
>, <Line: +	 *            The value being assigned to the given array element
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr,Context> translateDereference(Location<?> lval, Context context) {
>, <Line: +		Expr e = translateAsUnknown(lval,context.getEnvironment());
>, <Line: +		return new Pair<Expr,Context>(e,context);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assignment to a variable
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 *            The array assignment expression
>, <Line: +	 * @param result
>, <Line: +	 *            The value being assigned to the given array element
>, <Line: +	 * @param context
>, <Line: +	 *            The enclosing context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr,Context> translateVariableAssign(Location<VariableAccess> lval, Context context) {
>, <Line: +		Location<VariableDeclaration> decl = (Location<VariableDeclaration>) lval.getOperand(0);
>, <Line: +		context = context.havoc(decl.getIndex());
>, <Line: +		String nVersionedVar = context.read(decl);
>, <Line: +		Expr.Variable var = new Expr.Variable(nVersionedVar);
>, <Line: +		return new Pair<Expr,Context>(var,context);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Determine the variable at the root of a given sequence of assignments, or
>, <Line: +	 * return null if there is no statically determinable variable.
>, <Line: +	 * 
>, <Line: +	 * @param lval
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Location<VariableAccess> extractAssignedVariable(Location<?> lval) {
>, <Line: +		SyntaxTree tree = lval.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		//
>, <Line: +		switch (lval.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_arrayindex:
>, <Line: +			return extractAssignedVariable(lval.getOperand(0));
>, <Line: +		case Bytecode.OPCODE_dereference:
>, <Line: +			return null;
>, <Line: +		case Bytecode.OPCODE_fieldload:
>, <Line: +			return extractAssignedVariable(lval.getOperand(0));
>, <Line: +		case Bytecode.OPCODE_varaccess:
>, <Line: +			return (Location<VariableAccess>) lval;
>, <Line: +		default:
>, <Line: +			internalFailure("unknown lval encountered (" + lval + ")", decl.parent().filename(), lval.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an assume statement. This simply updates the current context to
>, <Line: +	 * assume that the given condition holds true (i.e. regardless of whether it
>, <Line: +	 * does or not). The purpose of assume statements is to allow some level of
>, <Line: +	 * interaction between the programmer and the verifier. That is, the
>, <Line: +	 * programmer can assume things which he/she knows to be true which the
>, <Line: +	 * verifier cannot prove (for whatever reason).
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateAssume(Location<Assume> stmt, Context context) {
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), context);
>, <Line: +		Expr condition = p.first();
>, <Line: +		context = p.second();
>, <Line: +		return context.assume(condition);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a break statement. This takes the current context and pushes it
>, <Line: +	 * into the enclosing loop scope. It will then be extracted later and used.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateBreak(Location<Break> stmt, Context context) {
>, <Line: +		LoopScope enclosingLoop = context.getEnclosingLoopScope();
>, <Line: +		enclosingLoop.addBreakContext(context);
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a continue statement. This takes the current context and pushes
>, <Line: +	 * it into the enclosing loop scope. It will then be extracted later and
>, <Line: +	 * used.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateContinue(Location<Continue> stmt, Context context) {
>, <Line: +		LoopScope enclosingLoop = context.getEnclosingLoopScope();
>, <Line: +		enclosingLoop.addContinueContext(context);
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a DoWhile statement.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context translateDoWhile(Location<DoWhile> stmt, Context context) {
>, <Line: +		WyilFile.Declaration declaration = context.getEnvironment().getParent().enclosingDeclaration;
>, <Line: +		Location<?>[] loopInvariant = stmt.getOperandGroup(0);
>, <Line: +		// Translate the loop invariant and generate appropriate macro
>, <Line: +		translateLoopInvariantMacros(loopInvariant, declaration, context.wyalFile);
>, <Line: +		// Rule 1. Check loop invariant after first iteration
>, <Line: +		LoopScope firstScope = new LoopScope();
>, <Line: +		Context beforeFirstBodyContext = context.newLoopScope(firstScope);
>, <Line: +		Context afterFirstBodyContext = translateStatementBlock(stmt.getBlock(0), beforeFirstBodyContext);
>, <Line: +		// Join continue contexts together since they must also preserve the
>, <Line: +		// loop invariant
>, <Line: +		afterFirstBodyContext = joinDescendants(beforeFirstBodyContext, afterFirstBodyContext,
>, <Line: +				firstScope.continueContexts);
>, <Line: +		//
>, <Line: +		checkLoopInvariant("loop invariant not established by first iteration", loopInvariant, afterFirstBodyContext);
>, <Line: +		// Rule 2. Check loop invariant preserved on subsequence iterations. On
>, <Line: +		// entry to the loop body we must havoc all modified variables. This is
>, <Line: +		// necessary as such variables should retain their values from before
>, <Line: +		// the loop.
>, <Line: +		LoopScope arbitraryScope = new LoopScope();
>, <Line: +		Context beforeArbitraryBodyContext = context.newLoopScope(arbitraryScope).havoc(stmt.getOperandGroup(1));
>, <Line: +		beforeArbitraryBodyContext = assumeLoopInvariant(loopInvariant, beforeArbitraryBodyContext);
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), beforeArbitraryBodyContext);
>, <Line: +		Expr trueCondition = p.first();
>, <Line: +		beforeArbitraryBodyContext = p.second().assume(trueCondition);
>, <Line: +		Context afterArbitraryBodyContext = translateStatementBlock(stmt.getBlock(0), beforeArbitraryBodyContext);
>, <Line: +		// Join continue contexts together since they must also preserve the
>, <Line: +		// loop invariant
>, <Line: +		afterArbitraryBodyContext = joinDescendants(beforeArbitraryBodyContext, afterArbitraryBodyContext,
>, <Line: +				arbitraryScope.continueContexts);
>, <Line: +		//
>, <Line: +		checkLoopInvariant("loop invariant not restored", loopInvariant, afterArbitraryBodyContext);
>, <Line: +		// Rule 3. Assume loop invariant holds.
>, <Line: +		Context exitContext = context.havoc(stmt.getOperandGroup(1));
>, <Line: +		exitContext = assumeLoopInvariant(loopInvariant, exitContext);
>, <Line: +		Expr falseCondition = invertCondition(translateExpression(stmt.getOperand(0), exitContext.getEnvironment()),
>, <Line: +				stmt.getOperand(0));
>, <Line: +		exitContext = exitContext.assume(falseCondition);
>, <Line: +		//
>, <Line: +		// Finally, need to join any break contexts from either first iteration
>, <Line: +		// or arbitrary iteration
>, <Line: +		exitContext = joinDescendants(context, exitContext, firstScope.breakContexts, arbitraryScope.breakContexts);
>, <Line: +		//
>, <Line: +		return exitContext;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a fail statement. Execution should never reach such a
>, <Line: +	 * statement. Hence, we need to emit a verification condition to ensure this
>, <Line: +	 * is the case.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context translateFail(Location<Fail> stmt, Context context) {
>, <Line: +		Expr condition = new Expr.Constant(Value.Bool(false), stmt.attributes());
>, <Line: +		//
>, <Line: +		VerificationCondition verificationCondition = new VerificationCondition("possible panic", context.assumptions,
>, <Line: +				condition, stmt.attributes());
>, <Line: +		context.emit(verificationCondition);
>, <Line: +		//
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate an if statement. This translates the true and false branches
>, <Line: +	 * and then recombines them together to form an updated environment. This is
>, <Line: +	 * challenging when the environments are updated independently in both
>, <Line: +	 * branches.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateIf(Location<If> stmt, Context context) {
>, <Line: +		//
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), context);
>, <Line: +		Expr trueCondition = p.first();
>, <Line: +		// FIXME: this is broken as includes assumptions propagated through
>, <Line: +		// logical &&'s
>, <Line: +		context = p.second();
>, <Line: +		Expr falseCondition = invertCondition(trueCondition, stmt.getOperand(0));
>, <Line: +		//
>, <Line: +		Context trueContext = context.assume(trueCondition);
>, <Line: +		Context falseContext = context.assume(falseCondition);
>, <Line: +		//
>, <Line: +		trueContext = translateStatementBlock(stmt.getBlock(0), trueContext);
>, <Line: +		if (stmt.numberOfBlocks() > 1) {
>, <Line: +			falseContext = translateStatementBlock(stmt.getBlock(1), falseContext);
>, <Line: +		}
>, <Line: +		// Finally, we must join the two context's back together. This ensures
>, <Line: +		// that information from either side is properly preserved
>, <Line: +		return joinDescendants(context, new Context[] { trueContext, falseContext });
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a named block
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateNamedBlock(Location<NamedBlock> stmt, Context context) {
>, <Line: +		return translateStatementBlock(stmt.getBlock(0), context);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a return statement. If a return value is given, then this must
>, <Line: +	 * ensure that the post-condition of the enclosing function or method is met
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateReturn(Location<Return> stmt, Context context) {
>, <Line: +		//
>, <Line: +		SyntaxTree tree = stmt.getEnclosingTree();
>, <Line: +		WyilFile.FunctionOrMethod declaration = (WyilFile.FunctionOrMethod) tree.getEnclosingDeclaration();
>, <Line: +		Type.FunctionOrMethod type = declaration.type();
>, <Line: +		Location<?>[] returns = stmt.getOperands();
>, <Line: +		List<Location<Bytecode.Expr>> postcondition = declaration.getPostcondition();
>, <Line: +		//
>, <Line: +		if (returns.length > 0) {
>, <Line: +			// There is at least one return value. Therefore, we need to check
>, <Line: +			// any preconditions for those return expressions and, potentially,
>, <Line: +			// ensure any postconditions of the cnlosing function/method are
>, <Line: +			// met.
>, <Line: +			Pair<Expr[], Context> p = translateExpressionsWithChecks(returns, context);
>, <Line: +			Expr[] exprs = p.first();
>, <Line: +			context = p.second();
>, <Line: +			//
>, <Line: +			if (postcondition.size() > 0) {
>, <Line: +				// There is at least one return value and at least one
>, <Line: +				// postcondition clause. Therefore, we need to check the return
>, <Line: +				// values against the post condition(s). One of the difficulties
>, <Line: +				// here is that the postcondition will refer to parameters as
>, <Line: +				// they were on entry to the function/method, not as they are
>, <Line: +				// now.
>, <Line: +				Expr[] arguments = new Expr[type.params().size() + type.returns().size()];
>, <Line: +				// Translate parameters as arguments to post-condition
>, <Line: +				// invocation
>, <Line: +				for (int i = 0; i != type.params().size(); ++i) {
>, <Line: +					Location<VariableDeclaration> var = (Location<VariableDeclaration>) tree.getLocation(i);
>, <Line: +					arguments[i] = new Expr.Variable(var.getBytecode().getName(), var.attributes());
>, <Line: +				}
>, <Line: +				// Copy over return expressions as arguments for invocation(s)
>, <Line: +				System.arraycopy(exprs, 0, arguments, type.params().size(), exprs.length);
>, <Line: +				//
>, <Line: +				Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +				String prefix = declaration.name() + "_ensures_";
>, <Line: +				// Finally, generate an appropriate verification condition to
>, <Line: +				// check
>, <Line: +				// each postcondition clause
>, <Line: +				for (int i = 0; i != postcondition.size(); ++i) {
>, <Line: +					Expr clause = new Expr.Invoke(prefix + i, declaration.parent().id(), Collections.EMPTY_LIST,
>, <Line: +							argument);
>, <Line: +					context.emit(new VerificationCondition("postcondition not satisfied", context.assumptions, clause,
>, <Line: +							stmt.attributes()));
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Return null to signal that execution does not continue after this
>, <Line: +		// return statement.
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a skip statement, which obviously does nothing
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateSkip(Location<Skip> stmt, Context context) {
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a switch statement.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private Context translateSwitch(Location<Switch> stmt, Context context) {
>, <Line: +		Bytecode.Switch bytecode = stmt.getBytecode();
>, <Line: +		Bytecode.Case[] cases = bytecode.cases();
>, <Line: +		//
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), context);
>, <Line: +		Expr value = p.first();
>, <Line: +		context = p.second();
>, <Line: +		//
>, <Line: +		Expr defaultValue = null;
>, <Line: +		Context[] descendants = new Context[cases.length + 1];
>, <Line: +		Context defaultContext = null;
>, <Line: +		//
>, <Line: +		for (int i = 0; i != cases.length; ++i) {
>, <Line: +			Bytecode.Case caSe = cases[i];
>, <Line: +			Context caseContext;
>, <Line: +			// Setup knowledge from case values
>, <Line: +			if (!caSe.isDefault()) {
>, <Line: +				Expr e = null;
>, <Line: +				for (Constant constant : caSe.values()) {
>, <Line: +					Expr.Constant v = new Expr.Constant(convert(constant, stmt));
>, <Line: +					e = or(e, new Expr.Binary(Expr.Binary.Op.EQ, value, v, stmt.attributes()));
>, <Line: +					defaultValue = and(defaultValue, new Expr.Binary(Expr.Binary.Op.NEQ, value, v, stmt.attributes()));
>, <Line: +				}
>, <Line: +				caseContext = context.assume(e);
>, <Line: +				descendants[i] = translateStatementBlock(stmt.getBlock(i), caseContext);
>, <Line: +			} else {
>, <Line: +				defaultContext = context.assume(defaultValue);
>, <Line: +				defaultContext = translateStatementBlock(stmt.getBlock(i), defaultContext);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Sort out default context
>, <Line: +		if (defaultContext == null) {
>, <Line: +			// indicates no default block was present, so we just assume what we
>, <Line: +			// know and treat it as a fall through.
>, <Line: +			defaultContext = context.assume(defaultValue);
>, <Line: +		}
>, <Line: +		descendants[descendants.length - 1] = defaultContext;
>, <Line: +		//
>, <Line: +		return joinDescendants(context, descendants);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a While statement.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context translateWhile(Location<While> stmt, Context context) {
>, <Line: +		WyilFile.Declaration declaration = context.getEnvironment().getParent().enclosingDeclaration;
>, <Line: +		Location<?>[] loopInvariant = stmt.getOperandGroup(0);
>, <Line: +		// Translate the loop invariant and generate appropriate macro
>, <Line: +		translateLoopInvariantMacros(loopInvariant, declaration, context.wyalFile);
>, <Line: +		// Rule 1. Check loop invariant on entry
>, <Line: +		checkLoopInvariant("loop invariant does not hold on entry", loopInvariant, context);
>, <Line: +		// Rule 2. Check loop invariant preserved. On entry to the loop body we
>, <Line: +		// must havoc all modified variables. This is necessary as such
>, <Line: +		// variables should retain their values from before the loop.
>, <Line: +		LoopScope scope = new LoopScope();
>, <Line: +		Context beforeBodyContext = context.newLoopScope(scope).havoc(stmt.getOperandGroup(1));
>, <Line: +		beforeBodyContext = assumeLoopInvariant(loopInvariant, beforeBodyContext);
>, <Line: +		Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), beforeBodyContext);
>, <Line: +		Expr trueCondition = p.first();
>, <Line: +		beforeBodyContext = p.second().assume(trueCondition);
>, <Line: +		Context afterBodyContext = translateStatementBlock(stmt.getBlock(0), beforeBodyContext);
>, <Line: +		// Join continue contexts together since they must also preserve the
>, <Line: +		// loop invariant
>, <Line: +		afterBodyContext = joinDescendants(beforeBodyContext, afterBodyContext, scope.continueContexts);
>, <Line: +		checkLoopInvariant("loop invariant not restored", loopInvariant, afterBodyContext);
>, <Line: +		// Rule 3. Assume loop invariant holds.
>, <Line: +		Context exitContext = context.havoc(stmt.getOperandGroup(1));
>, <Line: +		exitContext = assumeLoopInvariant(loopInvariant, exitContext);
>, <Line: +		Expr falseCondition = invertCondition(translateExpression(stmt.getOperand(0), exitContext.getEnvironment()),
>, <Line: +				stmt.getOperand(0));
>, <Line: +		exitContext = exitContext.assume(falseCondition);
>, <Line: +		//
>, <Line: +		// Finally, need to join any break contexts
>, <Line: +		exitContext = joinDescendants(context, exitContext, scope.breakContexts);
>, <Line: +		//
>, <Line: +		return exitContext;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate the sequence of invariant expressions which constitute the loop
>, <Line: +	 * invariant of a loop into one or more macros
>, <Line: +	 * 
>, <Line: +	 * @param loopInvariant
>, <Line: +	 *            The clauses making up the loop invariant
>, <Line: +	 * @param environment
>, <Line: +	 * @param wyalFile
>, <Line: +	 */
>, <Line: +	private void translateLoopInvariantMacros(Location<?>[] loopInvariant, WyilFile.Declaration declaration,
>, <Line: +			WyalFile wyalFile) {
>, <Line: +		//
>, <Line: +		String prefix = declaration.name() + "_loopinvariant_";
>, <Line: +		//
>, <Line: +		for (int i = 0; i != loopInvariant.length; ++i) {
>, <Line: +			Location<?> clause = loopInvariant[i];
>, <Line: +			String name = prefix + clause.getIndex();
>, <Line: +			// Construct fresh environment for this macro. This is necessary to
>, <Line: +			// avoid name clashes with subsequent macros.
>, <Line: +			GlobalEnvironment globalEnvironment = new GlobalEnvironment(declaration);
>, <Line: +			LocalEnvironment localEnvironment = new LocalEnvironment(globalEnvironment);
>, <Line: +			TypePattern type = generateLoopInvariantTypePattern(declaration, loopInvariant, localEnvironment);
>, <Line: +			Expr e = translateExpression(clause, localEnvironment.clone());
>, <Line: +			wyalFile.add(wyalFile.new Macro(name, Collections.EMPTY_LIST, type, e, e.attributes()));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Emit verification condition(s) to ensure that the clauses of loop
>, <Line: +	 * invariant hold at a given point
>, <Line: +	 * 
>, <Line: +	 * @param loopInvariant
>, <Line: +	 *            The clauses making up the loop invariant
>, <Line: +	 * @param context
>, <Line: +	 */
>, <Line: +	private void checkLoopInvariant(String msg, Location<?>[] loopInvariant, Context context) {
>, <Line: +		//
>, <Line: +		LocalEnvironment environment = context.getEnvironment();
>, <Line: +		WyilFile.FunctionOrMethod declaration = (WyilFile.FunctionOrMethod) environment
>, <Line: +				.getParent().enclosingDeclaration;
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		// FIXME: this is completely broken in the case of multiple loops. The
>, <Line: +		// problem is that we need to distinguish the macro names based on some
>, <Line: +		// kind of block identifier.
>, <Line: +		String prefix = declaration.name() + "_loopinvariant_";
>, <Line: +		// Construct argument to invocation
>, <Line: +		int[] localVariables = SyntaxTrees.determineUsedVariables(loopInvariant);
>, <Line: +		Expr[] arguments = new Expr[localVariables.length];
>, <Line: +		for (int i = 0; i != arguments.length; ++i) {
>, <Line: +			Location<VariableAccess> var = (Location<VariableAccess>) tree.getLocation(localVariables[i]);
>, <Line: +			arguments[i] = new Expr.Variable(environment.read(var.getIndex()), var.attributes());
>, <Line: +		}
>, <Line: +		Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +		//
>, <Line: +		for (int i = 0; i != loopInvariant.length; ++i) {
>, <Line: +			Location<?> clause = loopInvariant[i];
>, <Line: +			Expr macroCall = new Expr.Invoke(prefix + clause.getIndex(), declaration.parent().id(),
>, <Line: +					Collections.EMPTY_LIST, argument, clause.attributes());
>, <Line: +			context.emit(new VerificationCondition(msg, context.assumptions, macroCall, clause.attributes()));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Context assumeLoopInvariant(Location<?>[] loopInvariant, Context context) {
>, <Line: +		//
>, <Line: +		LocalEnvironment environment = context.getEnvironment();
>, <Line: +		WyilFile.FunctionOrMethod declaration = (WyilFile.FunctionOrMethod) environment
>, <Line: +				.getParent().enclosingDeclaration;
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		// FIXME: this is completely broken in the case of multiple loops. The
>, <Line: +		// problem is that we need to distinguish the macro names based on some
>, <Line: +		// kind of block identifier.
>, <Line: +		String prefix = declaration.name() + "_loopinvariant_";
>, <Line: +		// Construct argument to invocation
>, <Line: +		int[] localVariables = SyntaxTrees.determineUsedVariables(loopInvariant);
>, <Line: +		Expr[] arguments = new Expr[localVariables.length];
>, <Line: +		for (int i = 0; i != arguments.length; ++i) {
>, <Line: +			Location<VariableAccess> var = (Location<VariableAccess>) tree.getLocation(localVariables[i]);
>, <Line: +			arguments[i] = new Expr.Variable(environment.read(var.getIndex()), var.attributes());
>, <Line: +		}
>, <Line: +		Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +		//
>, <Line: +		for (int i = 0; i != loopInvariant.length; ++i) {
>, <Line: +			Location<?> clause = loopInvariant[i];
>, <Line: +			Expr macroCall = new Expr.Invoke(prefix + clause.getIndex(), declaration.parent().id(),
>, <Line: +					Collections.EMPTY_LIST, argument, clause.attributes());
>, <Line: +			context = context.assume(macroCall);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a variable declaration.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context translateVariableDeclaration(Location<VariableDeclaration> stmt, Context context) {
>, <Line: +		if (stmt.numberOfOperands() > 0) {
>, <Line: +			Pair<Expr, Context> p = translateExpressionWithChecks(stmt.getOperand(0), context);
>, <Line: +			context = context.write(stmt.getIndex(), p.first());
>, <Line: +		}
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	// =========================================================================
>, <Line: +	// Checked Expressions
>, <Line: +	// =========================================================================
>, <Line: +	/**
>, <Line: +	 * Translate zero or more expressions into their equivalent WyAL
>, <Line: +	 * expressions. At the same time, emit verification conditions to check that
>, <Line: +	 * the expression's preconditions. For example, in the expression
>, <Line: +	 * <code>x[i] + 1</code> we need to check that <code>i</code> is within
>, <Line: +	 * bounds.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- Expression to be translated
>, <Line: +	 * @param context
>, <Line: +	 *            --- Context in which translation is occurring
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr[], Context> translateExpressionsWithChecks(Location<?>[] exprs, Context context) {
>, <Line: +		// Generate expression preconditions as verification conditions
>, <Line: +		for (Location<?> expr : exprs) {
>, <Line: +			checkExpressionPreconditions(expr, context);
>, <Line: +		}
>, <Line: +		// Gather up any postconditions from function invocations
>, <Line: +		for (Location<?> expr : exprs) {
>, <Line: +			context = assumeExpressionPostconditions(expr, context);
>, <Line: +		}
>, <Line: +		// Translate expression in the normal fashion
>, <Line: +		return new Pair<Expr[],Context>(translateExpressions(exprs, context.getEnvironment()), context);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translate a given expression into its equivalent WyAL expression. At the
>, <Line: +	 * same time, emit verification conditions to check that the expression's
>, <Line: +	 * preconditions. For example, in the expression <code>x[i] + 1</code> we
>, <Line: +	 * need to check that <code>i</code> is within bounds.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- Expression to be translated
>, <Line: +	 * @param context
>, <Line: +	 *            --- Context in which translation is occurring
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Pair<Expr, Context> translateExpressionWithChecks(Location<?> expr, Context context) {
>, <Line: +		// Generate expression preconditions as verification conditions
>, <Line: +		checkExpressionPreconditions(expr, context);
>, <Line: +		// Gather up any postconditions from function invocations
>, <Line: +		context = assumeExpressionPostconditions(expr, context);
>, <Line: +		// Translate expression in the normal fashion
>, <Line: +		return new Pair<Expr,Context>(translateExpression(expr, context.getEnvironment()), context);
>, <Line: +	}
>, <Line: +	@SuppressWarnings("unchecked")
>, <Line: +	private void checkExpressionPreconditions(Location<?> expr, Context context) {
>, <Line: +		WyilFile.Declaration decl = expr.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +		try {
>, <Line: +			// First, recurse all subexpressions
>, <Line: +			int opcode = expr.getOpcode();
>, <Line: +			if (opcode == Bytecode.OPCODE_logicaland) {
>, <Line: +				// In the case of a logical and condition we need to propagate
>, <Line: +				// the
>, <Line: +				// left-hand side as an assumption into the right-hand side.
>, <Line: +				// This is
>, <Line: +				// an artifact of short-circuiting whereby terms on the
>, <Line: +				// right-hand
>, <Line: +				// side only execute when the left-hand side is known to hold.
>, <Line: +				for (int i = 0; i != expr.numberOfOperands(); ++i) {
>, <Line: +					checkExpressionPreconditions(expr.getOperand(i), context);
>, <Line: +					Expr e = translateExpression(expr.getOperand(i), context.getEnvironment());
>, <Line: +					context = context.assume(e);
>, <Line: +				}
>, <Line: +			} else if (opcode != Bytecode.OPCODE_varaccess) {
>, <Line: +				// In the case of a general expression, we just recurse any
>, <Line: +				// subexpressions without propagating information forward. We
>, <Line: +				// must ignore variable accesses here, because they refer back
>, <Line: +				// to the relevant variable declaration.
>, <Line: +				for (int i = 0; i != expr.numberOfOperands(); ++i) {
>, <Line: +					checkExpressionPreconditions(expr.getOperand(i), context);
>, <Line: +				}
>, <Line: +				for (int i = 0; i != expr.numberOfOperandGroups(); ++i) {
>, <Line: +					Location<?>[] group = expr.getOperandGroup(i);
>, <Line: +					for (Location<?> e : group) {
>, <Line: +						checkExpressionPreconditions(e, context);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// Second, perform actual precondition checks
>, <Line: +			switch (expr.getOpcode()) {
>, <Line: +			case Bytecode.OPCODE_invoke:
>, <Line: +				checkInvokePreconditions((Location<Invoke>) expr, context);
>, <Line: +				break;
>, <Line: +			case Bytecode.OPCODE_div:
>, <Line: +			case Bytecode.OPCODE_rem:
>, <Line: +				checkDivideByZero((Location<Operator>) expr, context);
>, <Line: +				break;
>, <Line: +			case Bytecode.OPCODE_arrayindex:
>, <Line: +				checkIndexOutOfBounds((Location<Operator>) expr, context);
>, <Line: +				break;
>, <Line: +			case Bytecode.OPCODE_arraygen:
>, <Line: +				checkArrayGeneratorLength((Location<Operator>) expr, context);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +		} catch (InternalFailure e) {
>, <Line: +			throw e;
>, <Line: +		} catch (Throwable e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, expr.attributes());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private void checkInvokePreconditions(Location<Invoke> expr, Context context) throws Exception {
>, <Line: +		WyilFile.Declaration declaration = expr.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +		Bytecode.Invoke bytecode = expr.getBytecode();
>, <Line: +		//
>, <Line: +		WyilFile.FunctionOrMethod fm = lookupFunctionOrMethod(bytecode.name(), bytecode.type(), expr);
>, <Line: +		int numPreconditions = fm.getPrecondition().size();
>, <Line: +		//
>, <Line: +		if (numPreconditions > 0) {
>, <Line: +			// There is at least one precondition for the function/method being
>, <Line: +			// called. Therefore, we need to generate a verification condition
>, <Line: +			// which will check that the precondition holds.
>, <Line: +			//
>, <Line: +			Expr[] arguments = translateExpressions(expr.getOperands(), context.getEnvironment());
>, <Line: +			Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +			String prefix = bytecode.name().name() + "_requires_";
>, <Line: +			// Finally, generate an appropriate verification condition to check
>, <Line: +			// each precondition clause
>, <Line: +			for (int i = 0; i != numPreconditions; ++i) {
>, <Line: +				Expr clause = new Expr.Invoke(prefix + i, declaration.parent().id(), Collections.EMPTY_LIST, argument);
>, <Line: +				context.emit(new VerificationCondition("precondition not satisfied", context.assumptions, clause,
>, <Line: +						expr.attributes()));
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private void checkDivideByZero(Location<Operator> expr, Context context) {
>, <Line: +		Expr rhs = translateExpression(expr.getOperand(1), context.getEnvironment());
>, <Line: +		Value zero = Value.Integer(BigInteger.ZERO);
>, <Line: +		Expr.Constant constant = new Expr.Constant(zero, rhs.attributes());
>, <Line: +		Expr neqZero = new Expr.Binary(Expr.Binary.Op.NEQ, rhs, constant, rhs.attributes());
>, <Line: +		//
>, <Line: +		context.emit(new VerificationCondition("division by zero", context.assumptions, neqZero, expr.attributes()));
>, <Line: +	}
>, <Line: +	private void checkIndexOutOfBounds(Location<Operator> expr, Context context) {
>, <Line: +		Expr src = translateExpression(expr.getOperand(0), context.getEnvironment());
>, <Line: +		Expr idx = translateExpression(expr.getOperand(1), context.getEnvironment());
>, <Line: +		Expr zero = new Expr.Constant(Value.Integer(BigInteger.ZERO));
>, <Line: +		Expr length = new Expr.Unary(Expr.Unary.Op.LENGTHOF, src);
>, <Line: +		//
>, <Line: +		Expr negTest = new Expr.Binary(Expr.Binary.Op.GTEQ, idx, zero, idx.attributes());
>, <Line: +		Expr lenTest = new Expr.Binary(Expr.Binary.Op.LT, idx, length, idx.attributes());
>, <Line: +		//
>, <Line: +		context.emit(new VerificationCondition("index out of bounds (negative)", context.assumptions, negTest,
>, <Line: +				expr.attributes()));
>, <Line: +		context.emit(new VerificationCondition("index out of bounds (not less than length)", context.assumptions,
>, <Line: +				lenTest, expr.attributes()));
>, <Line: +	}
>, <Line: +	private void checkArrayGeneratorLength(Location<Operator> expr, Context context) {
>, <Line: +		Expr rhs = translateExpression(expr.getOperand(1), context.getEnvironment());
>, <Line: +		Value zero = Value.Integer(BigInteger.ZERO);
>, <Line: +		Expr.Constant constant = new Expr.Constant(zero, rhs.attributes());
>, <Line: +		Expr neqZero = new Expr.Binary(Expr.Binary.Op.GTEQ, rhs, constant, rhs.attributes());
>, <Line: +		//
>, <Line: +		context.emit(
>, <Line: +				new VerificationCondition("negative length possible", context.assumptions, neqZero, expr.attributes()));
>, <Line: +	}
>, <Line: +	private Context assumeExpressionPostconditions(Location<?> expr, Context context) {
>, <Line: +		WyilFile.Declaration decl = expr.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +		try {
>, <Line: +			// First, propagate through all subexpressions
>, <Line: +			for (int i = 0; i != expr.numberOfOperands(); ++i) {
>, <Line: +				context = assumeExpressionPostconditions(expr.getOperand(i), context);
>, <Line: +			}
>, <Line: +			for (int i = 0; i != expr.numberOfOperandGroups(); ++i) {
>, <Line: +				Location<?>[] group = expr.getOperandGroup(i);
>, <Line: +				for (Location<?> e : group) {
>, <Line: +					context = assumeExpressionPostconditions(e, context);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			switch (expr.getOpcode()) {
>, <Line: +			case Bytecode.OPCODE_invoke:
>, <Line: +				context = assumeInvokePostconditions((Location<Invoke>) expr, context);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			return context;
>, <Line: +		} catch (InternalFailure e) {
>, <Line: +			throw e;
>, <Line: +		} catch (Throwable e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, expr.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Context assumeInvokePostconditions(Location<Invoke> expr, Context context) throws Exception {
>, <Line: +		WyilFile.Declaration declaration = expr.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +		Bytecode.Invoke bytecode = expr.getBytecode();
>, <Line: +		//
>, <Line: +		WyilFile.FunctionOrMethod fm = lookupFunctionOrMethod(bytecode.name(), bytecode.type(), expr);
>, <Line: +		int numPostconditions = fm.getPostcondition().size();
>, <Line: +		//
>, <Line: +		if (numPostconditions > 0) {
>, <Line: +			// There is at least one postcondition for the function/method being
>, <Line: +			// called. Therefore, we need to generate a verification condition
>, <Line: +			// which will check that the precondition holds.
>, <Line: +			//
>, <Line: +			Expr[] parameters = translateExpressions(expr.getOperands(), context.getEnvironment());
>, <Line: +			Expr[] arguments = Arrays.copyOf(parameters, parameters.length + fm.type().returns().size());
>, <Line: +			// FIXME: following broken for multiple returns
>, <Line: +			arguments[arguments.length - 1] = translateExpression(expr, context.getEnvironment());
>, <Line: +			//
>, <Line: +			Expr argument = arguments.length == 1 ? arguments[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, arguments);
>, <Line: +			String prefix = bytecode.name().name() + "_ensures_";
>, <Line: +			// Finally, generate an appropriate verification condition to check
>, <Line: +			// each precondition clause
>, <Line: +			for (int i = 0; i != numPostconditions; ++i) {
>, <Line: +				Expr clause = new Expr.Invoke(prefix + i, declaration.parent().id(), Collections.EMPTY_LIST, argument);
>, <Line: +				context = context.assume(clause);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return context;
>, <Line: +	}
>, <Line: +	// =========================================================================
>, <Line: +	// Expression
>, <Line: +	// =========================================================================
>, <Line: +	private Expr[] translateExpressions(Location<?>[] loc, LocalEnvironment environment) {
>, <Line: +		Expr[] results = new Expr[loc.length];
>, <Line: +		for (int i = 0; i != results.length; ++i) {
>, <Line: +			results[i] = translateExpression(loc[i], environment);
>, <Line: +		}
>, <Line: +		return results;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Transform a given bytecode location into its equivalent WyAL expression.
>, <Line: +	 * 
>, <Line: +	 * @param location
>, <Line: +	 *            The bytecode location to be translated
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	@SuppressWarnings("unchecked")
>, <Line: +	private Expr translateExpression(Location<?> loc, LocalEnvironment environment) {
>, <Line: +		WyilFile.Declaration decl = loc.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +		try {
>, <Line: +			switch (loc.getOpcode()) {
>, <Line: +			case Bytecode.OPCODE_const:
>, <Line: +				return translateConstant((Location<Const>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_convert:
>, <Line: +				return translateConvert((Location<Convert>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_fieldload:
>, <Line: +				return translateFieldLoad((Location<FieldLoad>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_indirectinvoke:
>, <Line: +				return translateIndirectInvoke((Location<IndirectInvoke>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_invoke:
>, <Line: +				return translateInvoke((Location<Invoke>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_lambda:
>, <Line: +				return translateLambda((Location<Lambda>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_some:
>, <Line: +			case Bytecode.OPCODE_all:
>, <Line: +				return translateQuantifier((Location<Quantifier>) loc, environment);
>, <Line: +			case Bytecode.OPCODE_varaccess:
>, <Line: +				return translateVariableAccess((Location<VariableAccess>) loc, environment);
>, <Line: +			default:
>, <Line: +				return translateOperator((Location<Operator>) loc, environment);
>, <Line: +			}
>, <Line: +		} catch (InternalFailure e) {
>, <Line: +			throw e;
>, <Line: +		} catch (Throwable e) {
>, <Line: +			internalFailure(e.getMessage(), decl.parent().filename(), e, loc.attributes());
>, <Line: +			throw e; // deadcode
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Expr translateConstant(Location<Const> expr, LocalEnvironment environment) {
>, <Line: +		Bytecode.Const bytecode = expr.getBytecode();
>, <Line: +		// FIXME: the following is something of a hack to avoid having to
>, <Line: +		// translate function pointers. However, it's not a general fix, and i'm
>, <Line: +		// not sure what the right solution is. Perhaps having an "unknown
>, <Line: +		// value" as the WyCS level might work (and be useful to replace
>, <Line: +		// translateAsUnknown).
>, <Line: +		if (bytecode.constant() instanceof Constant.FunctionOrMethod) {
>, <Line: +			return translateAsUnknown(expr, environment);
>, <Line: +		}
>, <Line: +		Value value = convert(bytecode.constant(), expr);
>, <Line: +		return new Expr.Constant(value, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateConvert(Location<Convert> expr, LocalEnvironment environment) {
>, <Line: +		// TODO: check whether need to do any more here
>, <Line: +		return translateExpression(expr.getOperand(0), environment);
>, <Line: +	}
>, <Line: +	private Expr translateFieldLoad(Location<FieldLoad> expr, LocalEnvironment environment) {
>, <Line: +		try {
>, <Line: +			Bytecode.FieldLoad bytecode = expr.getBytecode();
>, <Line: +			Location<?> srcOperand = expr.getOperand(0);
>, <Line: +			Type.EffectiveRecord er = typeSystem.expandAsEffectiveRecord(srcOperand.getType());
>, <Line: +			// FIXME: need to include Records in WyCS
>, <Line: +			// We need to determine and sort the fields here because records are
>, <Line: +			// implemented as WyCS Tuples.
>, <Line: +			ArrayList<String> fields = new ArrayList<String>(er.fields().keySet());
>, <Line: +			Collections.sort(fields);
>, <Line: +			// Now, translate source expression
>, <Line: +			Expr src = translateExpression(srcOperand, environment);
>, <Line: +			// Generate index expression, which is a tuple index
>, <Line: +			Expr index = new Expr.Constant(Value.Integer(BigInteger.valueOf(fields.indexOf(bytecode.fieldName()))));
>, <Line: +			// Done
>, <Line: +			return new Expr.IndexOf(src, index, expr.attributes());
>, <Line: +		} catch (ResolveError e) {
>, <Line: +			SyntaxTree tree = expr.getEnclosingTree();
>, <Line: +			internalFailure(e.getMessage(), tree.getEnclosingDeclaration().parent().filename(), e, expr.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Expr translateIndirectInvoke(Location<IndirectInvoke> expr, LocalEnvironment environment) {
>, <Line: +		// FIXME: need to implement this
>, <Line: +		return translateAsUnknown(expr, environment);
>, <Line: +	}
>, <Line: +	private Expr translateInvoke(Location<Invoke> expr, LocalEnvironment environment) {
>, <Line: +		Bytecode.Invoke bytecode = expr.getBytecode();
>, <Line: +		Expr[] operands = translateExpressions(expr.getOperands(), environment);
>, <Line: +		Expr argument = operands.length == 1 ? operands[0]
>, <Line: +				: new Expr.Nary(Expr.Nary.Op.TUPLE, operands, expr.attributes());
>, <Line: +		//
>, <Line: +		return new Expr.Invoke(bytecode.name().name(), bytecode.name().module(), Collections.EMPTY_LIST, argument,
>, <Line: +				expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateLambda(Location<Lambda> expr, LocalEnvironment environment) {
>, <Line: +		// FIXME: need to implement this
>, <Line: +		return translateAsUnknown(expr, environment);
>, <Line: +	}
>, <Line: +	private Expr translateOperator(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Bytecode.Operator bytecode = expr.getBytecode();
>, <Line: +		Bytecode.OperatorKind kind = bytecode.kind();
>, <Line: +		switch (kind) {
>, <Line: +		case NOT:
>, <Line: +			return translateNotOperator(expr, environment);
>, <Line: +		case NEG:
>, <Line: +		case ARRAYLENGTH:
>, <Line: +			return translateUnaryOperator(unaryOperatorMap.get(kind), expr, environment);
>, <Line: +		case ADD:
>, <Line: +		case SUB:
>, <Line: +		case MUL:
>, <Line: +		case DIV:
>, <Line: +		case REM:
>, <Line: +		case EQ:
>, <Line: +		case NEQ:
>, <Line: +		case LT:
>, <Line: +		case LTEQ:
>, <Line: +		case GT:
>, <Line: +		case GTEQ:
>, <Line: +		case AND:
>, <Line: +		case OR:
>, <Line: +			return translateBinaryOperator(binaryOperatorMap.get(kind), expr, environment);
>, <Line: +		case IS:
>, <Line: +			return translateIs(expr, environment);
>, <Line: +		case ARRAYINDEX:
>, <Line: +			return translateArrayIndex(expr, environment);
>, <Line: +		case ARRAYCONSTRUCTOR:
>, <Line: +			return translateArrayInitialiser(expr, environment);
>, <Line: +		case ARRAYGENERATOR:
>, <Line: +			return translateArrayGenerator(expr, environment);
>, <Line: +		case RECORDCONSTRUCTOR:
>, <Line: +			return translateRecordInitialiser(expr, environment);
>, <Line: +		case RIGHTSHIFT:
>, <Line: +		case LEFTSHIFT:
>, <Line: +		case BITWISEAND:
>, <Line: +		case BITWISEOR:
>, <Line: +		case BITWISEXOR:
>, <Line: +		case BITWISEINVERT:
>, <Line: +		case DEREFERENCE:
>, <Line: +		case NEW:
>, <Line: +			return translateAsUnknown(expr, environment);
>, <Line: +		default:
>, <Line: +			// FIXME: need to implement this
>, <Line: +			throw new RuntimeException("Implement me! " + kind);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Expr translateNotOperator(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr e = translateExpression(expr.getOperand(0), environment);
>, <Line: +		return invertCondition(e, expr.getOperand(0));
>, <Line: +	}
>, <Line: +	private Expr translateUnaryOperator(Expr.Unary.Op op, Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr e = translateExpression(expr.getOperand(0), environment);
>, <Line: +		return new Expr.Unary(op, e, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateBinaryOperator(Expr.Binary.Op op, Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr lhs = translateExpression(expr.getOperand(0), environment);
>, <Line: +		Expr rhs = translateExpression(expr.getOperand(1), environment);
>, <Line: +		return new Expr.Binary(op, lhs, rhs, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateIs(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr lhs = translateExpression(expr.getOperand(0), environment);
>, <Line: +		Location<Const> rhs = (Location<Const>) expr.getOperand(1);
>, <Line: +		Bytecode.Const bytecode = rhs.getBytecode();
>, <Line: +		Constant.Type constant = (Constant.Type) bytecode.constant();
>, <Line: +		SyntacticType typeTest = convert(constant.value(), environment.getParent().enclosingDeclaration);
>, <Line: +		return new Expr.Is(lhs, typeTest, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateArrayIndex(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr lhs = translateExpression(expr.getOperand(0), environment);
>, <Line: +		Expr rhs = translateExpression(expr.getOperand(1), environment);
>, <Line: +		return new Expr.IndexOf(lhs, rhs, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateArrayGenerator(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr element = translateExpression(expr.getOperand(0), environment);
>, <Line: +		Expr count = translateExpression(expr.getOperand(1), environment);
>, <Line: +		environment = environment.write(expr.getIndex());
>, <Line: +		return new Expr.Binary(Expr.Binary.Op.ARRAYGEN, element, count, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateArrayInitialiser(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr[] vals = translateExpressions(expr.getOperands(), environment);
>, <Line: +		return new Expr.Nary(Expr.Nary.Op.ARRAY, vals, expr.attributes());
>, <Line: +	}
>, <Line: +	private Expr translateQuantifier(Location<Quantifier> expr, LocalEnvironment environment) {
>, <Line: +		Bytecode.Quantifier bytecode = expr.getBytecode();
>, <Line: +		// Determine the type and names of each quantified variable.
>, <Line: +		TypePattern pattern = generateQuantifierTypePattern(expr);
>, <Line: +		// Apply quantifier ranges
>, <Line: +		Expr ranges = generateQuantifierRanges(expr, environment);
>, <Line: +		// Generate quantifier body
>, <Line: +		Expr body = translateExpression(expr.getOperand(0), environment);
>, <Line: +		body = implies(ranges, body);
>, <Line: +		// Generate quantifier expression
>, <Line: +		switch (bytecode.kind()) {
>, <Line: +		case ALL:
>, <Line: +			return new Expr.ForAll(pattern, body, expr.attributes());
>, <Line: +		case SOME:
>, <Line: +		default:
>, <Line: +			return new Expr.Exists(pattern, body, expr.attributes());
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Expr translateRecordInitialiser(Location<Operator> expr, LocalEnvironment environment) {
>, <Line: +		Expr[] vals = translateExpressions(expr.getOperands(), environment);
>, <Line: +		return new Expr.Nary(Expr.Nary.Op.TUPLE, vals, expr.attributes());
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Translating as unknown basically means we're not representing the
>, <Line: +	 * operation in question at the verification level. This could be something
>, <Line: +	 * that we'll implement in the future, or maybe not.
>, <Line: +	 * 
>, <Line: +	 * @param expr
>, <Line: +	 * @param environment
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr translateAsUnknown(Location<?> expr, LocalEnvironment environment) {
>, <Line: +		// What we're doing here is creating a completely fresh variable to
>, <Line: +		// represent the return value. This is basically saying the return value
>, <Line: +		// could be anything, and we don't care what.
>, <Line: +		environment = environment.write(expr.getIndex());
>, <Line: +		String r = environment.read(expr.getIndex());
>, <Line: +		return new Expr.Variable(r, expr.attributes());
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate a type pattern representing the type and name of all quantifier
>, <Line: +	 * variables described by this quantifier.
>, <Line: +	 * 
>, <Line: +	 * @param expr
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generateQuantifierTypePattern(Location<Quantifier> expr) {
>, <Line: +		SyntaxTree tree = expr.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		//
>, <Line: +		List<TypePattern> params = new ArrayList<TypePattern>();
>, <Line: +		for (int i = 0; i != expr.numberOfOperandGroups(); ++i) {
>, <Line: +			Location<?>[] group = expr.getOperandGroup(i);
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) group[0];
>, <Line: +			SyntacticType varType = convert(var.getType(), decl);
>, <Line: +			Expr.Variable varExpr = new Expr.Variable(var.getBytecode().getName(), var.attributes());
>, <Line: +			params.add(new TypePattern.Leaf(varType, varExpr));
>, <Line: +		}
>, <Line: +		return new TypePattern.Tuple(params);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate a logical conjunction which represents the given ranges of all
>, <Line: +	 * quantified variables. That is a conjunction of the form
>, <Line: +	 * <code>start <= var && var < end</code>.
>, <Line: +	 * 
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr generateQuantifierRanges(Location<Quantifier> expr, LocalEnvironment environment) {
>, <Line: +		Expr ranges = null;
>, <Line: +		for (int i = 0; i != expr.numberOfOperandGroups(); ++i) {
>, <Line: +			Location<?>[] group = expr.getOperandGroup(i);
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) group[0];
>, <Line: +			Expr.Variable varExpr = new Expr.Variable(var.getBytecode().getName(), var.attributes());
>, <Line: +			Expr startExpr = translateExpression(group[1], environment);
>, <Line: +			Expr endExpr = translateExpression(group[2], environment);
>, <Line: +			Expr lhs = new Expr.Binary(Expr.Binary.Op.LTEQ, startExpr, varExpr);
>, <Line: +			Expr rhs = new Expr.Binary(Expr.Binary.Op.LT, varExpr, endExpr);
>, <Line: +			ranges = and(ranges, and(lhs, rhs));
>, <Line: +		}
>, <Line: +		return ranges;
>, <Line: +	}
>, <Line: +	private Expr translateVariableAccess(Location<VariableAccess> expr, LocalEnvironment environment) {
>, <Line: +		Location<?> decl = (Location<?>) expr.getOperand(0);
>, <Line: +		Bytecode bytecode = decl.getBytecode();
>, <Line: +		String var;
>, <Line: +		if (bytecode instanceof VariableDeclaration) {
>, <Line: +			// In this case, we have a direct read of top-level variable.
>, <Line: +			var = environment.read(decl.getIndex());
>, <Line: +		} else {
>, <Line: +			// In this case, we are reading an alias of a top-level variable. We
>, <Line: +			// need to record this information to preserve the equality between
>, <Line: +			// these two variables later on.
>, <Line: +			AliasDeclaration alias = (AliasDeclaration) bytecode;
>, <Line: +			var = environment.readAlias(decl.getIndex(), alias.getOperand(0));
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return new Expr.Variable(var, expr.attributes());
>, <Line: +	}
>, <Line: +	// =========================================================================
>, <Line: +	// Helpers
>, <Line: +	// =========================================================================
>, <Line: +	/**
>, <Line: +	 * Construct an implication from one expression to another
>, <Line: +	 * 
>, <Line: +	 * @param antecedent
>, <Line: +	 * @param consequent
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr implies(Expr antecedent, Expr consequent) {
>, <Line: +		if (antecedent == null) {
>, <Line: +			return consequent;
>, <Line: +		} else {
>, <Line: +			return new Expr.Binary(Expr.Binary.Op.IMPLIES, antecedent, consequent);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a conjunction of two expressions
>, <Line: +	 * 
>, <Line: +	 * @param lhs
>, <Line: +	 * @param rhs
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr and(Expr lhs, Expr rhs) {
>, <Line: +		if (lhs == null) {
>, <Line: +			return rhs;
>, <Line: +		} else if (rhs == null) {
>, <Line: +			return rhs;
>, <Line: +		} else {
>, <Line: +			return new Expr.Binary(Expr.Binary.Op.AND, lhs, rhs);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a disjunct of two expressions
>, <Line: +	 * 
>, <Line: +	 * @param lhs
>, <Line: +	 * @param rhs
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr or(Expr lhs, Expr rhs) {
>, <Line: +		if (lhs == null) {
>, <Line: +			return rhs;
>, <Line: +		} else if (rhs == null) {
>, <Line: +			return rhs;
>, <Line: +		} else {
>, <Line: +			return new Expr.Binary(Expr.Binary.Op.OR, lhs, rhs);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Join one or more descendant context's together. To understand this,
>, <Line: +	 * consider the following snippet, annotated with context information:
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * // Context: y >= 0
>, <Line: +	 * if x >= 0:
>, <Line: +	 *    x = x + 1
>, <Line: +	 *    // Context: y >= 0 && x >= 0 && x$1 == x + 1
>, <Line: +	 * else:
>, <Line: +	 *    x = -x
>, <Line: +	 *    // Context: y >= 0 && x < 0 && x$2 == x + 1
>, <Line: +	 * //
>, <Line: +	 * Context: ?
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * At this point, we have two goals in combining the contextual information
>, <Line: +	 * back together. Firstly, we want to factor out the parts common to both
>, <Line: +	 * (e.g. <code>y >= 0</code> above). Secondly, we need to determine the
>, <Line: +	 * appropriate version for variables modified on one or both branches (e.g.
>, <Line: +	 * <code>x</code> above). Thus, the joined context for the above would be:
>, <Line: +	 * 
>, <Line: +	 * <pre>
>, <Line: +	 * y >= 0 && ((x >= 0 && x$1 == x + 1 && x$3 == x$1) || (x < 0 && x$2 == -x && x$3 == x$2))
>, <Line: +	 * </pre>
>, <Line: +	 * 
>, <Line: +	 * In the resulting environment, the current version of <code>x</code> would
>, <Line: +	 * then be <code>x$3</code>. To determine affected variables we simplify
>, <Line: +	 * identify any variable with a different version between at least two
>, <Line: +	 * context's.
>, <Line: +	 * 
>, <Line: +	 * @param ancestor
>, <Line: +	 *            Distinguished context for join, which is an ancestor of those
>, <Line: +	 *            context's being joined.
>, <Line: +	 * @param descendants
>, <Line: +	 *            Descendant context's being joined. Again, these maybe null for
>, <Line: +	 *            branches which terminate (e.g. via return).
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Context joinDescendants(Context ancestor, Context[] descendants) {
>, <Line: +		// Santity check parameters, as they maybe null. This happens in case of
>, <Line: +		// branches which terminate (e.g. via return or break).
>, <Line: +		descendants = removeNull(descendants);
>, <Line: +		if (descendants.length == 0) {
>, <Line: +			// In this case, the are actually no active descendants. Hence, the
>, <Line: +			// resulting context is null to indicate no branches escape this
>, <Line: +			// meet point.
>, <Line: +			return null;
>, <Line: +		} else if (descendants.length == 1) {
>, <Line: +			// If there's only one, then we don't need to join it.
>, <Line: +			return descendants[0];
>, <Line: +		}
>, <Line: +		//
>, <Line: +		LocalEnvironment joinedEnvironment = joinEnvironments(descendants);
>, <Line: +		//
>, <Line: +		AssumptionSet[] descendentAssumptions = new AssumptionSet[descendants.length];
>, <Line: +		for (int i = 0; i != descendants.length; ++i) {
>, <Line: +			Context ithContext = descendants[i];
>, <Line: +			LocalEnvironment ithEnvironment = ithContext.environment;
>, <Line: +			AssumptionSet ithAssumptions = ithContext.assumptions;
>, <Line: +			descendentAssumptions[i] = updateVariableVersions(ithAssumptions, ithEnvironment, joinedEnvironment);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		AssumptionSet joinedAssumptions = ancestor.assumptions.joinDescendants(descendentAssumptions);
>, <Line: +		//
>, <Line: +		return new Context(ancestor.wyalFile, joinedAssumptions, joinedEnvironment, ancestor.enclosingLoop,
>, <Line: +				ancestor.verificationConditions);
>, <Line: +	}
>, <Line: +	private Context joinDescendants(Context ancestor, Context firstDescendant, List<Context> descendants1,
>, <Line: +			List<Context> descendants2) {
>, <Line: +		ArrayList<Context> descendants = new ArrayList<Context>(descendants1);
>, <Line: +		descendants.addAll(descendants2);
>, <Line: +		return joinDescendants(ancestor, firstDescendant, descendants);
>, <Line: +	}
>, <Line: +	private Context joinDescendants(Context ancestor, Context firstDescendant, List<Context> descendants) {
>, <Line: +		Context[] ds = descendants.toArray(new Context[descendants.size() + 1]);
>, <Line: +		ds[descendants.size()] = firstDescendant;
>, <Line: +		return joinDescendants(ancestor, ds);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Bring a given assumption set which is consistent with an original
>, <Line: +	 * environment up-to-date with a new environment.
>, <Line: +	 * 
>, <Line: +	 * @param assumptions
>, <Line: +	 *            The assumption set associated with a given context being
>, <Line: +	 *            joined together.
>, <Line: +	 * @param original
>, <Line: +	 *            The original environment associated with the given context.
>, <Line: +	 *            This maps from location indices to version numbers and is
>, <Line: +	 *            consistent with the given assumption set.
>, <Line: +	 * @param updated
>, <Line: +	 *            The updated mapping from location indices to version numbers.
>, <Line: +	 *            In many cases, these will be the same as in the original
>, <Line: +	 *            environment. However, some versions will have been updated
>, <Line: +	 *            because they were modified in one or more context's being
>, <Line: +	 *            joined. In such case, the given assumption set must be brought
>, <Line: +	 *            up to date with the new version numbers.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private AssumptionSet updateVariableVersions(AssumptionSet assumptions, LocalEnvironment original,
>, <Line: +			LocalEnvironment updated) {
>, <Line: +		for (Map.Entry<Integer, String> e : updated.locals.entrySet()) {
>, <Line: +			Integer varIndex = e.getKey();
>, <Line: +			String newVarVersionedName = e.getValue();
>, <Line: +			String oldVarVersionedName = original.read(varIndex);
>, <Line: +			if (!oldVarVersionedName.equals(newVarVersionedName)) {
>, <Line: +				// indicates a version change of the given variable.
>, <Line: +				Expr.Variable oldVar = new Expr.Variable(oldVarVersionedName);
>, <Line: +				Expr.Variable newVar = new Expr.Variable(newVarVersionedName);
>, <Line: +				assumptions = assumptions.add(new Expr.Binary(Expr.Binary.Op.EQ, newVar, oldVar));
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return assumptions;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Join the local environments of one or more context's together. This means
>, <Line: +	 * retaining variable versions which are the same for all context's,
>, <Line: +	 * allocating new versions for those which are different in at least one
>, <Line: +	 * case, and removing those which aren't present it at least one.
>, <Line: +	 * 
>, <Line: +	 * @param contexts
>, <Line: +	 *            Array of at least one non-null Context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private LocalEnvironment joinEnvironments(Context... contexts) {
>, <Line: +		//
>, <Line: +		Context head = contexts[0];
>, <Line: +		GlobalEnvironment global = head.getEnvironment().getParent();
>, <Line: +		HashSet<Integer> modified = new HashSet<Integer>();
>, <Line: +		HashSet<Integer> deleted = new HashSet<Integer>();
>, <Line: +		Map<Integer, String> headLocals = head.environment.locals;
>, <Line: +		// Compute the modified and deleted sets
>, <Line: +		for (int i = 1; i < contexts.length; ++i) {
>, <Line: +			Context ithContext = contexts[i];
>, <Line: +			Map<Integer, String> ithLocals = ithContext.environment.locals;
>, <Line: +			// First check env against head
>, <Line: +			for (Map.Entry<Integer, String> e : ithLocals.entrySet()) {
>, <Line: +				Integer key = e.getKey();
>, <Line: +				String s1 = e.getValue();
>, <Line: +				String s2 = headLocals.get(key);
>, <Line: +				if (s1 == null) {
>, <Line: +					deleted.add(key);
>, <Line: +				} else if (!s1.equals(s2)) {
>, <Line: +					modified.add(key);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			// Second, check head against env
>, <Line: +			for (Map.Entry<Integer, String> e : headLocals.entrySet()) {
>, <Line: +				Integer key = e.getKey();
>, <Line: +				String s1 = e.getValue();
>, <Line: +				String s2 = ithLocals.get(key);
>, <Line: +				if (s1 == null) {
>, <Line: +					deleted.add(key);
>, <Line: +				} else if (!s1.equals(s2)) {
>, <Line: +					modified.add(key);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// Finally, construct the combined local map
>, <Line: +		HashMap<Integer, String> combinedLocals = new HashMap<Integer, String>();
>, <Line: +		for (Map.Entry<Integer, String> e : headLocals.entrySet()) {
>, <Line: +			Integer key = e.getKey();
>, <Line: +			String value = e.getValue();
>, <Line: +			if (deleted.contains(key)) {
>, <Line: +				// Ignore this entry. This must be checked before we look at
>, <Line: +				// modified (since variable can be marked both).
>, <Line: +				continue;
>, <Line: +			} else if (modified.contains(key)) {
>, <Line: +				// Update version number
>, <Line: +				value = global.allocateVersion(key);
>, <Line: +			}
>, <Line: +			combinedLocals.put(key, value);
>, <Line: +		}
>, <Line: +		// Now, use the modified and deleted sets to build the new environment
>, <Line: +		return new LocalEnvironment(global, combinedLocals);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a function or method prototype with a given name and type. The
>, <Line: +	 * function or method can then be called elsewhere as an uninterpreted
>, <Line: +	 * function. The function or method doesn't have a body but is used as a
>, <Line: +	 * name to be referred to from assertions.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            --- the function or method declaration in question
>, <Line: +	 * @param wyalFile
>, <Line: +	 *            --- the file onto which this function is created.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private void createFunctionOrMethodPrototype(WyilFile.FunctionOrMethod declaration, WyalFile wyalFile) {
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		List<Type> params = declaration.type().params();
>, <Line: +		List<Type> returns = declaration.type().returns();
>, <Line: +		//
>, <Line: +		TypePattern.Leaf[] parameterPatterns = new TypePattern.Leaf[params.size()];
>, <Line: +		// second, set initial environment
>, <Line: +		int loc = 0;
>, <Line: +		for (int i = 0; i != params.size(); ++i, ++loc) {
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) tree.getLocation(loc);
>, <Line: +			Expr.Variable v = new Expr.Variable(var.getBytecode().getName());
>, <Line: +			SyntacticType parameterType = convert(params.get(i), declaration);
>, <Line: +			parameterPatterns[i] = new TypePattern.Leaf(parameterType, v);
>, <Line: +		}
>, <Line: +		TypePattern.Leaf[] returnPatterns = new TypePattern.Leaf[returns.size()];
>, <Line: +		// second, set initial environment
>, <Line: +		for (int i = 0; i != returns.size(); ++i, ++loc) {
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) tree.getLocation(loc);
>, <Line: +			Expr.Variable v = new Expr.Variable(var.getBytecode().getName());
>, <Line: +			SyntacticType returnType = convert(returns.get(i), declaration);
>, <Line: +			returnPatterns[i] = new TypePattern.Leaf(returnType, v);
>, <Line: +		}
>, <Line: +		// Construct the type declaration for the new block macro
>, <Line: +		TypePattern from = new TypePattern.Tuple(parameterPatterns);
>, <Line: +		TypePattern to = new TypePattern.Tuple(returnPatterns);
>, <Line: +		//
>, <Line: +		wyalFile.add(wyalFile.new Function(declaration.name(), Collections.EMPTY_LIST, from, to, null));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Turn each verification condition into an assertion in the underlying
>, <Line: +	 * WyalFile being generated. The main challenge here is to ensure that all
>, <Line: +	 * variables used in the assertion are properly typed.
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            The enclosing function or method declaration
>, <Line: +	 * @param vcs
>, <Line: +	 *            The list of verification conditions which have been generated
>, <Line: +	 * @param environment
>, <Line: +	 *            The global environment which maps all versioned variables to
>, <Line: +	 *            their underlying locations. This is necessary to determine the
>, <Line: +	 *            type of all free variables.
>, <Line: +	 * @param wyalFile
>, <Line: +	 *            The WyAL file being generated
>, <Line: +	 */
>, <Line: +	private void createAssertions(WyilFile.FunctionOrMethod declaration, List<VerificationCondition> vcs,
>, <Line: +			GlobalEnvironment environment, WyalFile wyalFile) {
>, <Line: +		// FIXME: should be logged somehow?
>, <Line: +		for (int i = 0; i != vcs.size(); ++i) {
>, <Line: +			VerificationCondition vc = vcs.get(i);
>, <Line: +			// Build the actual verification condition
>, <Line: +			Expr verificationCondition = buildVerificationCondition(declaration, environment, vc);
>, <Line: +			// Add generated verification condition as assertion
>, <Line: +			wyalFile.add(wyalFile.new Assert(vc.description, verificationCondition, vc.attributes()));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Construct a fully typed and quantified expression for representing a
>, <Line: +	 * verification condition. Aside from flattening the various components, it
>, <Line: +	 * must also determine appropriate variable types, including those for
>, <Line: +	 * aliased variables.
>, <Line: +	 * 
>, <Line: +	 * @param vc
>, <Line: +	 * @param environment
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public Expr buildVerificationCondition(WyilFile.FunctionOrMethod declaration, GlobalEnvironment environment,
>, <Line: +			VerificationCondition vc) {
>, <Line: +		Expr antecedent = flatten(vc.antecedent);
>, <Line: +		Expr consequent = vc.consequent;
>, <Line: +		HashSet<String> freeVariables = new HashSet<String>();
>, <Line: +		antecedent.freeVariables(freeVariables);
>, <Line: +		consequent.freeVariables(freeVariables);
>, <Line: +		// Determine any variable aliases as necessary.
>, <Line: +		Expr aliases = determineVariableAliases(environment, freeVariables);
>, <Line: +		// Construct the initial condition
>, <Line: +		Expr verificationCondition = implies(and(aliases, antecedent), vc.consequent);
>, <Line: +		// Now, generate type information for any free variables
>, <Line: +		if (freeVariables.size() > 0) {
>, <Line: +			// This indicates there are one or more free variables in the
>, <Line: +			// verification condition. Hence, these must be universally
>, <Line: +			// quantified to ensure the vc is well=typed.
>, <Line: +			TypePattern types = generateExpressionTypePattern(declaration, environment, freeVariables);
>, <Line: +			verificationCondition = new Expr.ForAll(types, verificationCondition);
>, <Line: +		}
>, <Line: +		// Done
>, <Line: +		return verificationCondition;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Flatten a given assumption set into a single logical condition. The key
>, <Line: +	 * challenge here is to try and do this as efficiency as possible.
>, <Line: +	 * 
>, <Line: +	 * @param assumptions
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr flatten(AssumptionSet assumptions) {
>, <Line: +		Expr result = flattenUpto(assumptions, null);
>, <Line: +		if (result == null) {
>, <Line: +			return new Expr.Constant(Value.Bool(true));
>, <Line: +		} else {
>, <Line: +			return result;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Flatten an assumption set upto a given ancestor. That is, do not include
>, <Line: +	 * the ancestor or any of its ancestors in the results. This is a little
>, <Line: +	 * like taking the difference of the given assumptions and the given
>, <Line: +	 * ancestor's assumptions.
>, <Line: +	 * 
>, <Line: +	 * @param assumptions
>, <Line: +	 *            The assumption set to be flattened
>, <Line: +	 * @param ancestor
>, <Line: +	 *            An ancestor of the given assumption set, or null to indicate
>, <Line: +	 *            all ancestors should be included
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr flattenUpto(AssumptionSet assumptions, AssumptionSet ancestor) {
>, <Line: +		if (assumptions == ancestor) {
>, <Line: +			// We have reached the ancestor
>, <Line: +			return null;
>, <Line: +		} else {
>, <Line: +			// Flattern parent assumptions
>, <Line: +			AssumptionSet[] parents = assumptions.parents;
>, <Line: +			Expr e = null;
>, <Line: +			switch (parents.length) {
>, <Line: +			case 0:
>, <Line: +				// do nothing
>, <Line: +				break;
>, <Line: +			case 1:
>, <Line: +				// easy
>, <Line: +				e = flattenUpto(parents[0], ancestor);
>, <Line: +				break;
>, <Line: +			default:
>, <Line: +				// harder
>, <Line: +				AssumptionSet lca = assumptions.commonAncestor;
>, <Line: +				Expr factor = flattenUpto(lca, ancestor);
>, <Line: +				for (int i = 0; i != parents.length; ++i) {
>, <Line: +					e = or(e, flattenUpto(parents[i], lca));
>, <Line: +				}
>, <Line: +				e = and(factor, e);
>, <Line: +			}
>, <Line: +			// Combine with local assumptions (if applicable)
>, <Line: +			Expr[] local = assumptions.assumptions;
>, <Line: +			for (int i = 0; i != local.length; ++i) {
>, <Line: +				e = and(e, local[i]);
>, <Line: +			}
>, <Line: +			//
>, <Line: +			return e;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Determine any variable aliases which need to be accounted for. This is
>, <Line: +	 * done by adding an equality between the aliased variables to ensure they
>, <Line: +	 * have the same value.
>, <Line: +	 * 
>, <Line: +	 * @param environment
>, <Line: +	 * @param freeVariables
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Expr determineVariableAliases(GlobalEnvironment environment, Set<String> freeVariables) {
>, <Line: +		Expr aliases = null;
>, <Line: +		for (String var : freeVariables) {
>, <Line: +			String parent = environment.getParent(var);
>, <Line: +			if (parent != null) {
>, <Line: +				// This indicates a variable alias, so construct the necessary
>, <Line: +				// equality.
>, <Line: +				Expr.Variable lhs = new Expr.Variable(var);
>, <Line: +				Expr.Variable rhs = new Expr.Variable(parent);
>, <Line: +				Expr aliasEquality = new Expr.Binary(Expr.Binary.Op.EQ, lhs, rhs);
>, <Line: +				//
>, <Line: +				aliases = and(aliases, aliasEquality);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return aliases;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Packaged the set of free variables up into a type pattern (for now).
>, <Line: +	 * 
>, <Line: +	 * @param declaration
>, <Line: +	 *            The enclosing function or method declaration
>, <Line: +	 * @param environment
>, <Line: +	 *            The global environment which maps all versioned variables to
>, <Line: +	 *            their underlying locations. This is necessary to determine the
>, <Line: +	 *            type of all free variables.
>, <Line: +	 * @param freeVariables
>, <Line: +	 *            Set of free variables to allocate
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generateExpressionTypePattern(WyilFile.Declaration declaration, GlobalEnvironment environment,
>, <Line: +			Set<String> freeVariables) {
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		TypePattern[] patterns = new TypePattern[freeVariables.size()];
>, <Line: +		int index = 0;
>, <Line: +		for (String var : freeVariables) {
>, <Line: +			Expr.Variable v = new Expr.Variable(var);
>, <Line: +			Location<?> l = tree.getLocation(environment.resolve(var));
>, <Line: +			SyntacticType wycsType = convert(l.getType(), declaration);
>, <Line: +			patterns[index++] = new TypePattern.Leaf(wycsType, v);
>, <Line: +		}
>, <Line: +		if (patterns.length == 1) {
>, <Line: +			return patterns[0];
>, <Line: +		} else {
>, <Line: +			return new TypePattern.Tuple(patterns);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert the parameter types for a given function or method declaration
>, <Line: +	 * into a corresponding list of type patterns. This is primarily useful for
>, <Line: +	 * generating declarations from functions or method.
>, <Line: +	 * 
>, <Line: +	 * @param params
>, <Line: +	 * @param declaration
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generatePreconditionTypePattern(WyilFile.FunctionOrMethod declaration,
>, <Line: +			LocalEnvironment environment) {
>, <Line: +		List<Type> params = declaration.type().params();
>, <Line: +		int[] parameterLocations = range(0, params.size());
>, <Line: +		return generateTypePatterns(declaration, environment, parameterLocations);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert the return types for a given function or method declaration into
>, <Line: +	 * a corresponding list of type patterns. This is primarily useful for
>, <Line: +	 * generating declarations from functions or method.
>, <Line: +	 * 
>, <Line: +	 * @param params
>, <Line: +	 * @param declaration
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generatePostconditionTypePattern(WyilFile.FunctionOrMethod declaration,
>, <Line: +			LocalEnvironment environment) {
>, <Line: +		List<Type> params = declaration.type().params();
>, <Line: +		List<Type> returns = declaration.type().returns();
>, <Line: +		int[] parameterLocations = range(0, params.size());
>, <Line: +		int[] returnLocations = range(parameterLocations.length, parameterLocations.length + returns.size());
>, <Line: +		return generateTypePatterns(declaration, environment, parameterLocations, returnLocations);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert the types of local variables in scope at a given position within
>, <Line: +	 * a function or method into a type pattern. This is primarily useful for
>, <Line: +	 * determining the types for a loop invariant macro.
>, <Line: +	 * 
>, <Line: +	 * @param params
>, <Line: +	 * @param declaration
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generateLoopInvariantTypePattern(WyilFile.Declaration declaration, Location<?>[] loopInvariant,
>, <Line: +			LocalEnvironment environment) {
>, <Line: +		int[] localVariableLocations = SyntaxTrees.determineUsedVariables(loopInvariant);
>, <Line: +		return generateTypePatterns(declaration, environment, localVariableLocations);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert a list of types from a given declaration into a corresponding
>, <Line: +	 * list of type patterns. This is primarily useful for generating
>, <Line: +	 * declarations from functions or method.
>, <Line: +	 * 
>, <Line: +	 * @param types
>, <Line: +	 * @param declaration
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private TypePattern generateTypePatterns(WyilFile.Declaration declaration, LocalEnvironment environment,
>, <Line: +			int[]... groups) {
>, <Line: +		//
>, <Line: +		SyntaxTree tree = declaration.getTree();
>, <Line: +		int[] locations = flattern(groups);
>, <Line: +		TypePattern.Leaf[] patterns = new TypePattern.Leaf[locations.length];
>, <Line: +		// second, set initial environment
>, <Line: +		for (int i = 0; i != locations.length; ++i) {
>, <Line: +			Location<VariableDeclaration> var = (Location<VariableDeclaration>) tree.getLocation(locations[i]);
>, <Line: +			String versionedName = environment.read(var.getIndex());
>, <Line: +			Expr.Variable v = new Expr.Variable(versionedName);
>, <Line: +			SyntacticType parameterType = convert(var.getType(), declaration);
>, <Line: +			patterns[i] = new TypePattern.Leaf(parameterType, v);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		if (patterns.length == 1) {
>, <Line: +			return patterns[0];
>, <Line: +		} else {
>, <Line: +			return new TypePattern.Tuple(patterns);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert a WyIL constant into its equivalent WyCS constant. In some cases,
>, <Line: +	 * this is a direct translation. In other cases, WyIL constants are encoded
>, <Line: +	 * using more primitive WyCS values.
>, <Line: +	 * 
>, <Line: +	 * @param c
>, <Line: +	 *            --- The WyIL constant to be converted.
>, <Line: +	 * @param context
>, <Line: +	 *            Additional contextual information associated with the point of
>, <Line: +	 *            this conversion. These are used for debugging purposes to
>, <Line: +	 *            associate any errors generated with a source line.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Value convert(Constant c, SyntaxTree.Location<?> context) {
>, <Line: +		if (c instanceof Constant.Null) {
>, <Line: +			return wycs.core.Value.Null;
>, <Line: +		} else if (c instanceof Constant.Bool) {
>, <Line: +			Constant.Bool cb = (Constant.Bool) c;
>, <Line: +			return wycs.core.Value.Bool(cb.value());
>, <Line: +		} else if (c instanceof Constant.Byte) {
>, <Line: +			Constant.Byte cb = (Constant.Byte) c;
>, <Line: +			return wycs.core.Value.Integer(BigInteger.valueOf(cb.value()));
>, <Line: +		} else if (c instanceof Constant.Integer) {
>, <Line: +			Constant.Integer cb = (Constant.Integer) c;
>, <Line: +			return wycs.core.Value.Integer(cb.value());
>, <Line: +		} else if (c instanceof Constant.Array) {
>, <Line: +			Constant.Array cb = (Constant.Array) c;
>, <Line: +			List<Constant> cb_values = cb.values();
>, <Line: +			ArrayList<Value> items = new ArrayList<Value>();
>, <Line: +			for (int i = 0; i != cb_values.size(); ++i) {
>, <Line: +				items.add(convert(cb_values.get(i), context));
>, <Line: +			}
>, <Line: +			return Value.Array(items);
>, <Line: +		} else if (c instanceof Constant.Record) {
>, <Line: +			Constant.Record rb = (Constant.Record) c;
>, <Line: +			// NOTE: records are currently translated into WyCS as tuples,
>, <Line: +			// where each field is allocated a slot based on an alphabetical
>, <Line: +			// sorting
>, <Line: +			// of field names. It's unclear at this stage whether or not that is
>, <Line: +			// a general solution. In particular, it would seem to be broken for
>, <Line: +			// type testing.
>, <Line: +			ArrayList<String> fields = new ArrayList<String>(rb.values().keySet());
>, <Line: +			Collections.sort(fields);
>, <Line: +			ArrayList<Value> values = new ArrayList<Value>();
>, <Line: +			for (String field : fields) {
>, <Line: +				values.add(convert(rb.values().get(field), context));
>, <Line: +			}
>, <Line: +			return wycs.core.Value.Tuple(values);
>, <Line: +		} else {
>, <Line: +			WyilFile.Declaration decl = context.getEnclosingTree().getEnclosingDeclaration();
>, <Line: +			internalFailure("unknown constant encountered (" + c + ")", decl.parent().filename(), context.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Convert a WyIL type into its equivalent WyCS type. In some cases, this is
>, <Line: +	 * a direct translation. In other cases, WyIL types are encoded using more
>, <Line: +	 * primitive WyCS types.
>, <Line: +	 * 
>, <Line: +	 * @param type
>, <Line: +	 *            The WyIL type to be converted.
>, <Line: +	 * @param context
>, <Line: +	 *            Additional contextual information associated with the point of
>, <Line: +	 *            this conversion. These are used for debugging purposes to
>, <Line: +	 *            associate any errors generated with a source line.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private static SyntacticType convert(Type type, WyilFile.Block context) {
>, <Line: +		// FIXME: this is fundamentally broken in the case of recursive types.
>, <Line: +		// See Issue #298.
>, <Line: +		if (type instanceof Type.Any) {
>, <Line: +			return new SyntacticType.Any(context.attributes());
>, <Line: +		} else if (type instanceof Type.Void) {
>, <Line: +			return new SyntacticType.Void(context.attributes());
>, <Line: +		} else if (type instanceof Type.Null) {
>, <Line: +			return new SyntacticType.Null(context.attributes());
>, <Line: +		} else if (type instanceof Type.Bool) {
>, <Line: +			return new SyntacticType.Bool(context.attributes());
>, <Line: +		} else if (type instanceof Type.Byte) {
>, <Line: +			// FIXME: implement SyntacticType.Byte
>, <Line: +			// return new SyntacticType.Byte(attributes(branch);
>, <Line: +			return new SyntacticType.Int(context.attributes());
>, <Line: +		} else if (type instanceof Type.Int) {
>, <Line: +			return new SyntacticType.Int(context.attributes());
>, <Line: +		} else if (type instanceof Type.Array) {
>, <Line: +			Type.Array lt = (Type.Array) type;
>, <Line: +			SyntacticType element = convert(lt.element(), context);
>, <Line: +			// ugly.
>, <Line: +			return new SyntacticType.List(element);
>, <Line: +		} else if (type instanceof Type.Record) {
>, <Line: +			Type.Record rt = (Type.Record) type;
>, <Line: +			HashMap<String, Type> fields = rt.fields();
>, <Line: +			ArrayList<String> names = new ArrayList<String>(fields.keySet());
>, <Line: +			ArrayList<SyntacticType> elements = new ArrayList<SyntacticType>();
>, <Line: +			Collections.sort(names);
>, <Line: +			for (int i = 0; i != names.size(); ++i) {
>, <Line: +				String field = names.get(i);
>, <Line: +				elements.add(convert(fields.get(field), context));
>, <Line: +			}
>, <Line: +			return new SyntacticType.Tuple(elements);
>, <Line: +		} else if (type instanceof Type.Reference) {
>, <Line: +			// FIXME: how to translate this??
>, <Line: +			return new SyntacticType.Any();
>, <Line: +		} else if (type instanceof Type.Union) {
>, <Line: +			Type.Union tu = (Type.Union) type;
>, <Line: +			HashSet<Type> tu_elements = tu.bounds();
>, <Line: +			ArrayList<SyntacticType> elements = new ArrayList<SyntacticType>();
>, <Line: +			for (Type te : tu_elements) {
>, <Line: +				elements.add(convert(te, context));
>, <Line: +			}
>, <Line: +			return new SyntacticType.Union(elements);
>, <Line: +		} else if (type instanceof Type.Negation) {
>, <Line: +			Type.Negation nt = (Type.Negation) type;
>, <Line: +			SyntacticType element = convert(nt.element(), context);
>, <Line: +			return new SyntacticType.Negation(element);
>, <Line: +		} else if (type instanceof Type.FunctionOrMethod) {
>, <Line: +			Type.FunctionOrMethod ft = (Type.FunctionOrMethod) type;
>, <Line: +			// FIXME: need to do something better here
>, <Line: +			return new SyntacticType.Any();
>, <Line: +		} else if (type instanceof Type.Nominal) {
>, <Line: +			Type.Nominal nt = (Type.Nominal) type;
>, <Line: +			NameID nid = nt.name();
>, <Line: +			ArrayList<String> names = new ArrayList<String>();
>, <Line: +			for (String pc : nid.module()) {
>, <Line: +				names.add(pc);
>, <Line: +			}
>, <Line: +			names.add(nid.name());
>, <Line: +			return new SyntacticType.Nominal(names, context.attributes());
>, <Line: +		} else {
>, <Line: +			internalFailure("unknown type encountered (" + type.getClass().getName() + ")", context.parent().filename(),
>, <Line: +					context.attributes());
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Lookup a given function or method. This maybe contained in the same file,
>, <Line: +	 * or in a different file. This may require loading that file in memory to
>, <Line: +	 * access this information.
>, <Line: +	 * 
>, <Line: +	 * @param name
>, <Line: +	 *            --- Fully qualified name of function
>, <Line: +	 * @param fun
>, <Line: +	 *            --- Type of fucntion.
>, <Line: +	 * @param block
>, <Line: +	 *            --- Enclosing block (for debugging purposes).
>, <Line: +	 * @param branch
>, <Line: +	 *            --- Enclosing branch (for debugging purposes).
>, <Line: +	 * @return
>, <Line: +	 * @throws Exception
>, <Line: +	 */
>, <Line: +	public WyilFile.FunctionOrMethod lookupFunctionOrMethod(NameID name, Type.FunctionOrMethod fun,
>, <Line: +			SyntaxTree.Location<?> stmt) throws Exception {
>, <Line: +		SyntaxTree tree = stmt.getEnclosingTree();
>, <Line: +		WyilFile.Declaration decl = tree.getEnclosingDeclaration();
>, <Line: +		//
>, <Line: +		Path.Entry<WyilFile> e = builder.project().get(name.module(), WyilFile.ContentType);
>, <Line: +		if (e == null) {
>, <Line: +			internalFailure(errorMessage(ErrorMessages.RESOLUTION_ERROR, name.module().toString()),
>, <Line: +					decl.parent().filename(), stmt.attributes());
>, <Line: +		}
>, <Line: +		WyilFile m = e.read();
>, <Line: +		WyilFile.FunctionOrMethod method = m.functionOrMethod(name.name(), fun);
>, <Line: +		return method;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Generate the logically inverted expression corresponding to a given
>, <Line: +	 * comparator. For example, inverting "<=" gives ">", inverting "==" gives
>, <Line: +	 * "!=", etc.
>, <Line: +	 *
>, <Line: +	 * @param test
>, <Line: +	 *            --- the binary comparator being inverted.
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public Expr invertCondition(Expr expr, Location<?> elem) {
>, <Line: +		if (expr instanceof Expr.Binary) {
>, <Line: +			Expr.Binary binTest = (Expr.Binary) expr;
>, <Line: +			Expr.Binary.Op op = null;
>, <Line: +			switch (binTest.op) {
>, <Line: +			case EQ:
>, <Line: +				op = Expr.Binary.Op.NEQ;
>, <Line: +				break;
>, <Line: +			case NEQ:
>, <Line: +				op = Expr.Binary.Op.EQ;
>, <Line: +				break;
>, <Line: +			case GTEQ:
>, <Line: +				op = Expr.Binary.Op.LT;
>, <Line: +				break;
>, <Line: +			case GT:
>, <Line: +				op = Expr.Binary.Op.LTEQ;
>, <Line: +				break;
>, <Line: +			case LTEQ:
>, <Line: +				op = Expr.Binary.Op.GT;
>, <Line: +				break;
>, <Line: +			case LT:
>, <Line: +				op = Expr.Binary.Op.GTEQ;
>, <Line: +				break;
>, <Line: +			case AND: {
>, <Line: +				Expr lhs = invertCondition(binTest.leftOperand, elem);
>, <Line: +				Expr rhs = invertCondition(binTest.rightOperand, elem);
>, <Line: +				return new Expr.Binary(Expr.Binary.Op.OR, lhs, rhs, expr.attributes());
>, <Line: +			}
>, <Line: +			case OR: {
>, <Line: +				Expr lhs = invertCondition(binTest.leftOperand, elem);
>, <Line: +				Expr rhs = invertCondition(binTest.rightOperand, elem);
>, <Line: +				return new Expr.Binary(Expr.Binary.Op.AND, lhs, rhs, expr.attributes());
>, <Line: +			}
>, <Line: +			}
>, <Line: +			if (op != null) {
>, <Line: +				return new Expr.Binary(op, binTest.leftOperand, binTest.rightOperand, expr.attributes());
>, <Line: +			}
>, <Line: +		} else if (expr instanceof Expr.Is) {
>, <Line: +			Expr.Is ei = (Expr.Is) expr;
>, <Line: +			SyntacticType type = ei.rightOperand;
>, <Line: +			return new Expr.Is(ei.leftOperand, new SyntacticType.Negation(type, type.attributes()), ei.attributes());
>, <Line: +		}
>, <Line: +		// Otherwise, compare against false
>, <Line: +		// FIXME: this is just wierd and needs to be fixed.
>, <Line: +		return new Expr.Unary(Expr.Unary.Op.NOT, expr);
>, <Line: +	}
>, <Line: +	private static <T> T[] append(T[] lhs, T[] rhs) {
>, <Line: +		T[] rs = Arrays.copyOf(lhs, lhs.length + rhs.length);
>, <Line: +		System.arraycopy(rhs, 0, rs, lhs.length, rhs.length);
>, <Line: +		return rs;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Create exact copy of a given array, but with evey null element removed.
>, <Line: +	 * 
>, <Line: +	 * @param items
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private static <T> T[] removeNull(T[] items) {
>, <Line: +		int count = 0;
>, <Line: +		for (int i = 0; i != items.length; ++i) {
>, <Line: +			if (items[i] == null) {
>, <Line: +				count = count + 1;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (count == 0) {
>, <Line: +			return items;
>, <Line: +		} else {
>, <Line: +			T[] rs = Arrays.copyOf(items, items.length - count);
>, <Line: +			for (int i = 0, j = 0; i != items.length; ++i) {
>, <Line: +				T item = items[i];
>, <Line: +				if (item != null) {
>, <Line: +					rs[j++] = item;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return rs;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public static int[] range(int start, int end) {
>, <Line: +		int[] rs = new int[Math.abs(end - start)];
>, <Line: +		for (int i = start; i < end; ++i) {
>, <Line: +			rs[i - start] = i;
>, <Line: +		}
>, <Line: +		return rs;
>, <Line: +	}
>, <Line: +	public static int[] flattern(int[][] groups) {
>, <Line: +		int length = 0;
>, <Line: +		for (int i = 0; i != groups.length; ++i) {
>, <Line: +			length += groups[i].length;
>, <Line: +		}
>, <Line: +		//
>, <Line: +		int[] result = new int[length];
>, <Line: +		for (int i = 0, j = 0; i != groups.length; ++i) {
>, <Line: +			int[] group = groups[i];
>, <Line: +			System.arraycopy(group, 0, result, j, group.length);
>, <Line: +			j = j + group.length;
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return result;
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Assumptions
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Provides an immutable assumption set which (in principle) can be factored
>, <Line: +	 * more precisely than a flat collection.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private static class AssumptionSet {
>, <Line: +		/**
>, <Line: +		 * The least common ancestor for all parents sets. A parent may be the
>, <Line: +		 * common ancestor. Making this explicit is not strictly necessary, but
>, <Line: +		 * helps with the flattening process.
>, <Line: +		 */
>, <Line: +		private final AssumptionSet commonAncestor;
>, <Line: +		/**
>, <Line: +		 * The set of parent sets from which this assumption set is derived.
>, <Line: +		 */
>, <Line: +		private final AssumptionSet[] parents;
>, <Line: +		/**
>, <Line: +		 * The set of assumptions explicitly provided by this assumption set.
>, <Line: +		 * The complete set of assumptions includes those of the parents as
>, <Line: +		 * well.
>, <Line: +		 */
>, <Line: +		private final Expr[] assumptions;
>, <Line: +		private AssumptionSet(AssumptionSet commonAncestor, AssumptionSet[] parents, Expr... assumptions) {
>, <Line: +			this.commonAncestor = commonAncestor;
>, <Line: +			this.parents = parents;
>, <Line: +			this.assumptions = assumptions;
>, <Line: +		}
>, <Line: +		public AssumptionSet add(Expr... assumptions) {
>, <Line: +			return new AssumptionSet(this, new AssumptionSet[] { this }, assumptions);
>, <Line: +		}
>, <Line: +		public AssumptionSet joinDescendants(AssumptionSet... descendants) {
>, <Line: +			if (descendants.length == 1) {
>, <Line: +				return descendants[0];
>, <Line: +			} else {
>, <Line: +				return new AssumptionSet(this, descendants);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		public static final AssumptionSet ROOT = new AssumptionSet(null, new AssumptionSet[0]);
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Verification Conditions
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Provides a simple structure representing a verification condition. This
>, <Line: +	 * will be turned into an assertion of some form. A verification is always
>, <Line: +	 * of the form "X ==> Y", where X is the "antecedent" and Y the
>, <Line: +	 * "consequent". More specifically, X represents the knowledge known at the
>, <Line: +	 * given point and Y is the condition we are attempting to assert.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private static class VerificationCondition extends SyntacticElement.Impl {
>, <Line: +		private final String description;
>, <Line: +		private final AssumptionSet antecedent;
>, <Line: +		private final Expr consequent;
>, <Line: +		private VerificationCondition(String description, AssumptionSet antecedent, Expr consequent,
>, <Line: +				List<Attribute> attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.description = description;
>, <Line: +			this.antecedent = antecedent;
>, <Line: +			this.consequent = consequent;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Environments
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * The global environment provides a global allocation of "versioned"
>, <Line: +	 * variables. This ensures that across any related set of environments, no
>, <Line: +	 * version clashes are possible between variables of the same name. This
>, <Line: +	 * also means that we can determine the underlying location that each
>, <Line: +	 * variable corresponds to.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private class GlobalEnvironment {
>, <Line: +		/**
>, <Line: +		 * Provides a link back to the enclosing declaration. This is necessary
>, <Line: +		 * to enable us to convert location indices into variable names and
>, <Line: +		 * types.
>, <Line: +		 */
>, <Line: +		private final WyilFile.Declaration enclosingDeclaration;
>, <Line: +		/**
>, <Line: +		 * Maps versioned variable strings to their underlying location index. A
>, <Line: +		 * version variable string is of the form "x$1" where "x" is the
>, <Line: +		 * variable name and "1" the version number.
>, <Line: +		 */
>, <Line: +		private final Map<String, Integer> allocation;
>, <Line: +		/**
>, <Line: +		 * Maps aliased variables to their parent variable. That is the variable
>, <Line: +		 * which is being aliased.
>, <Line: +		 */
>, <Line: +		private final Map<String, String> parents;
>, <Line: +		/**
>, <Line: +		 * Provides a global mapping of all local variable names to the next
>, <Line: +		 * unused version numbers. This is done with variable names rather than
>, <Line: +		 * location indices because it is possible two have different variables
>, <Line: +		 * with the same name,
>, <Line: +		 */
>, <Line: +		private final Map<String, Integer> versions;
>, <Line: +		public GlobalEnvironment(WyilFile.Declaration enclosingDeclaration) {
>, <Line: +			this.enclosingDeclaration = enclosingDeclaration;
>, <Line: +			this.allocation = new HashMap<String, Integer>();
>, <Line: +			this.parents = new HashMap<String, String>();
>, <Line: +			this.versions = new HashMap<String, Integer>();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the parent for a potential variable alias, or null if there is no
>, <Line: +		 * alias.
>, <Line: +		 * 
>, <Line: +		 * @param alias
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public String getParent(String alias) {
>, <Line: +			return parents.get(alias);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the location index from a versioned variable name of the form
>, <Line: +		 * "x$1"
>, <Line: +		 * 
>, <Line: +		 * @param versionedVariable
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int resolve(String versionedVariable) {
>, <Line: +			return allocation.get(versionedVariable);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Allocation a new versioned variable name of the form "x$1" for a
>, <Line: +		 * given location index
>, <Line: +		 * 
>, <Line: +		 * @param index
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public String allocateVersion(int index) {
>, <Line: +			SyntaxTree tree = enclosingDeclaration.getTree();
>, <Line: +			Location<?> loc = tree.getLocation(index);
>, <Line: +			Bytecode bytecode = loc.getBytecode();
>, <Line: +			String name;
>, <Line: +			if (bytecode instanceof Bytecode.VariableDeclaration) {
>, <Line: +				Bytecode.VariableDeclaration v = (Bytecode.VariableDeclaration) bytecode;
>, <Line: +				name = v.getName();
>, <Line: +			} else if (bytecode instanceof Bytecode.AliasDeclaration) {
>, <Line: +				Location<Bytecode.VariableDeclaration> v = getVariableDeclaration(loc);
>, <Line: +				// This indicates an alias declaration
>, <Line: +				name = v.getBytecode().getName();
>, <Line: +			} else {
>, <Line: +				// This indicates an unnamed location
>, <Line: +				name = "$" + index;
>, <Line: +			}
>, <Line: +			// Allocate a new version number for this variable
>, <Line: +			Integer version = versions.get(name);
>, <Line: +			String versionedVar;
>, <Line: +			if (version == null) {
>, <Line: +				version = 0;
>, <Line: +				// Variables with version 0 just take the original name. This is
>, <Line: +				// not necessary, but it makes for slightly nicer verification
>, <Line: +				// conditions.
>, <Line: +				versionedVar = name;
>, <Line: +			} else {
>, <Line: +				version = version + 1;
>, <Line: +				versionedVar = name + "$" + version;
>, <Line: +			}
>, <Line: +			versions.put(name, version);
>, <Line: +			// Create the versioned variable name and remember which location it
>, <Line: +			// corresponds to.
>, <Line: +			allocation.put(versionedVar, index);
>, <Line: +			//
>, <Line: +			return versionedVar;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Add a new variable alias for a variable to its parent
>, <Line: +		 * 
>, <Line: +		 * @param leftVar
>, <Line: +		 * @param rightVar
>, <Line: +		 */
>, <Line: +		public void addVariableAlias(String alias, String parent) {
>, <Line: +			parents.put(alias, parent);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * The local environment provides a mapping from local variables in the
>, <Line: +	 * current scope to their current version number. Local environments are
>, <Line: +	 * transitively immutable objects, except for the global environment they
>, <Line: +	 * refer to.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private class LocalEnvironment {
>, <Line: +		/**
>, <Line: +		 * Provides access to the global environment
>, <Line: +		 */
>, <Line: +		private final GlobalEnvironment global;
>, <Line: +		/**
>, <Line: +		 * Maps all local variables in scope to their current versioned variable
>, <Line: +		 * names
>, <Line: +		 */
>, <Line: +		private final Map<Integer, String> locals;
>, <Line: +		public LocalEnvironment(GlobalEnvironment global) {
>, <Line: +			this.global = global;
>, <Line: +			this.locals = new HashMap<Integer, String>();
>, <Line: +		}
>, <Line: +		public LocalEnvironment(GlobalEnvironment global, Map<Integer, String> locals) {
>, <Line: +			this.global = global;
>, <Line: +			this.locals = new HashMap<Integer, String>(locals);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the envlosing global environment for this local environment
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public GlobalEnvironment getParent() {
>, <Line: +			return global;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Read the current versioned variable name for a given location index.
>, <Line: +		 * 
>, <Line: +		 * @param index
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public String read(int index) {
>, <Line: +			String vv = locals.get(index);
>, <Line: +			if (vv == null) {
>, <Line: +				vv = global.allocateVersion(index);
>, <Line: +				locals.put(index, vv);
>, <Line: +			}
>, <Line: +			return vv;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Read the current versioned variable name for a given (aliased)
>, <Line: +		 * location index.
>, <Line: +		 * 
>, <Line: +		 * @param alias
>, <Line: +		 *            The variable being read (which is an alias)
>, <Line: +		 * @param parent
>, <Line: +		 *            The variable which this is an alias of
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public String readAlias(int alias, int parent) {
>, <Line: +			String aliasedVariable = read(alias);
>, <Line: +			String parentVariable = read(parent);
>, <Line: +			global.addVariableAlias(aliasedVariable, parentVariable);
>, <Line: +			return aliasedVariable;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Create a new version for each variable in a sequence of variables.
>, <Line: +		 * This create a completely new local environment.
>, <Line: +		 * 
>, <Line: +		 * @param index
>, <Line: +		 */
>, <Line: +		public LocalEnvironment write(int... indices) {
>, <Line: +			LocalEnvironment nenv = new LocalEnvironment(global, locals);
>, <Line: +			for (int i = 0; i != indices.length; ++i) {
>, <Line: +				nenv.locals.put(indices[i], global.allocateVersion(indices[i]));
>, <Line: +			}
>, <Line: +			return nenv;
>, <Line: +		}
>, <Line: +		public LocalEnvironment clone() {
>, <Line: +			return new LocalEnvironment(global, locals);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public Location<VariableDeclaration> getVariableDeclaration(Location<?> decl) {
>, <Line: +		switch (decl.getOpcode()) {
>, <Line: +		case OPCODE_aliasdecl:
>, <Line: +		case OPCODE_varaccess:
>, <Line: +			return getVariableDeclaration(decl.getOperand(0));
>, <Line: +		case OPCODE_vardecl:
>, <Line: +		case OPCODE_vardeclinit:
>, <Line: +			return (Location<VariableDeclaration>) decl;
>, <Line: +		default:
>, <Line: +			throw new RuntimeException("internal failure --- dead code reached");
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// LoopScope
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Represents the enclosing "loop scope". This is needed for dealing with
>, <Line: +	 * break and continue statements. Basically, as a way of taking the context
>, <Line: +	 * at the point of the statement in question and moving it out to the
>, <Line: +	 * enclosing loop.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private static class LoopScope {
>, <Line: +		private List<Context> breakContexts;
>, <Line: +		private List<Context> continueContexts;
>, <Line: +		public LoopScope() {
>, <Line: +			this.breakContexts = new ArrayList<Context>();
>, <Line: +			this.continueContexts = new ArrayList<Context>();
>, <Line: +		}
>, <Line: +		public List<Context> breakContexts() {
>, <Line: +			return breakContexts;
>, <Line: +		}
>, <Line: +		public List<Context> continueContexts() {
>, <Line: +			return continueContexts;
>, <Line: +		}
>, <Line: +		public void addBreakContext(Context context) {
>, <Line: +			breakContexts.add(context);
>, <Line: +		}
>, <Line: +		public void addContinueContext(Context context) {
>, <Line: +			continueContexts.add(context);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Context
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Represents a given translation context.
>, <Line: +	 * 
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	private static class Context {
>, <Line: +		/**
>, <Line: +		 * Represents the wyalfile being generated. This is useful if we want to
>, <Line: +		 * add macro definitions, etc.
>, <Line: +		 */
>, <Line: +		private final WyalFile wyalFile;
>, <Line: +		/**
>, <Line: +		 * The list of generated verification conditions.
>, <Line: +		 */
>, <Line: +		private final List<VerificationCondition> verificationConditions;
>, <Line: +		/**
>, <Line: +		 * The set of assumptions which are known to hold at a given point
>, <Line: +		 * during generation.
>, <Line: +		 */
>, <Line: +		private final AssumptionSet assumptions;
>, <Line: +		/**
>, <Line: +		 * The local environment mapping variables to their current version
>, <Line: +		 * numbers
>, <Line: +		 */
>, <Line: +		private final LocalEnvironment environment;
>, <Line: +		/**
>, <Line: +		 * A reference to the enclosing loop scope, or null if no such scope.
>, <Line: +		 */
>, <Line: +		private final LoopScope enclosingLoop;
>, <Line: +		public Context(WyalFile wyalFile, AssumptionSet assumptions, LocalEnvironment environment,
>, <Line: +				LoopScope enclosingLoop, List<VerificationCondition> vcs) {
>, <Line: +			this.wyalFile = wyalFile;
>, <Line: +			this.assumptions = assumptions;
>, <Line: +			this.environment = environment;
>, <Line: +			this.verificationConditions = vcs;
>, <Line: +			this.enclosingLoop = enclosingLoop;
>, <Line: +		}
>, <Line: +		public WyilFile getEnclosingFile() {
>, <Line: +			return environment.getParent().enclosingDeclaration.parent();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the local environment associated witht his context
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public LocalEnvironment getEnvironment() {
>, <Line: +			return environment;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the enclosing loop scope.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public LoopScope getEnclosingLoopScope() {
>, <Line: +			return enclosingLoop;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Generate a new context from this one where a give condition is
>, <Line: +		 * assumed to hold.
>, <Line: +		 * 
>, <Line: +		 * @param condition
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Context assume(Expr... conditions) {
>, <Line: +			AssumptionSet nAssumptions = assumptions.add(conditions);
>, <Line: +			return new Context(wyalFile, nAssumptions, environment, enclosingLoop, verificationConditions);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Emit a verification condition which ensures a given assertion holds
>, <Line: +		 * true in this translation context.
>, <Line: +		 * 
>, <Line: +		 * @param vc
>, <Line: +		 *            The verification condition to be emitted
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public void emit(VerificationCondition vc) {
>, <Line: +			verificationConditions.add(vc);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Assign an expression to a given variable. This results in the version
>, <Line: +		 * number for that variable being increased. Thus, any historical
>, <Line: +		 * references to that variable in the set of assumptions remain valid.
>, <Line: +		 * 
>, <Line: +		 * @param lhs
>, <Line: +		 *            The index of the location being assigned
>, <Line: +		 * @param rhs
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Context write(int lhs, Expr rhs) {
>, <Line: +			// Update version number of the assigned variable
>, <Line: +			LocalEnvironment nEnvironment = environment.write(lhs);
>, <Line: +			String nVersionedVar = nEnvironment.read(lhs);
>, <Line: +			// Update assumption sets to reflect the "assigment"
>, <Line: +			Expr.Variable var = new Expr.Variable(nVersionedVar);
>, <Line: +			Expr condition = new Expr.Binary(Expr.Binary.Op.EQ, var, rhs);
>, <Line: +			AssumptionSet nAssumptions = assumptions.add(condition);
>, <Line: +			//
>, <Line: +			return new Context(wyalFile, nAssumptions, nEnvironment, enclosingLoop, verificationConditions);
>, <Line: +		}
>, <Line: +		public String read(Location<?> expr) {
>, <Line: +			return environment.read(expr.getIndex());
>, <Line: +		}
>, <Line: +		public Context havoc(int lhs) {
>, <Line: +			LocalEnvironment nEnvironment = environment.write(lhs);
>, <Line: +			//
>, <Line: +			return new Context(wyalFile, assumptions, nEnvironment, enclosingLoop, verificationConditions);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Havoc a number of variable accesses. This results in the version
>, <Line: +		 * numbers for those variables being increased. Thus, any historical
>, <Line: +		 * references to those variables in the set of assumptions remain valid.
>, <Line: +		 * 
>, <Line: +		 * @param lhs
>, <Line: +		 *            The variable accesses being havoced
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Context havoc(Location<?>... exprs) {
>, <Line: +			// Update version number of the assigned variables
>, <Line: +			int[] vars = new int[exprs.length];
>, <Line: +			for (int i = 0; i != exprs.length; ++i) {
>, <Line: +				// At this point, we're assuming only variable accesses can be
>, <Line: +				// havoced. However, potentially, it might make sense to open
>, <Line: +				// this up a little.
>, <Line: +				Location<VariableAccess> va = (Location<VariableAccess>) exprs[i];
>, <Line: +				vars[i] = va.getOperand(0).getIndex();
>, <Line: +			}
>, <Line: +			LocalEnvironment nEnvironment = environment.write(vars);
>, <Line: +			// done
>, <Line: +			return new Context(wyalFile, assumptions, nEnvironment, enclosingLoop, verificationConditions);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Construct a context within a given loop scope.
>, <Line: +		 * 
>, <Line: +		 * @param scope
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Context newLoopScope(LoopScope scope) {
>, <Line: +			return new Context(wyalFile, assumptions, environment, scope, verificationConditions);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Operator Maps
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Maps unary bytecodes into unary expression opcodes.
>, <Line: +	 */
>, <Line: +	private static Map<Bytecode.OperatorKind, Expr.Unary.Op> unaryOperatorMap;
>, <Line: +	/**
>, <Line: +	 * Maps binary bytecodes into binary expression opcodes.
>, <Line: +	 */
>, <Line: +	private static Map<Bytecode.OperatorKind, Expr.Binary.Op> binaryOperatorMap;
>, <Line: +	static {
>, <Line: +		// Configure operator maps. This is done using maps to ensure that
>, <Line: +		// changes in one operator kind does not have knock-on effects. This
>, <Line: +		// used to be a problem when an array was used to implement the mapping.
>, <Line: +		// =====================================================================
>, <Line: +		// Unary operator map
>, <Line: +		// =====================================================================
>, <Line: +		unaryOperatorMap = new HashMap<Bytecode.OperatorKind, Expr.Unary.Op>();
>, <Line: +		// Arithmetic
>, <Line: +		unaryOperatorMap.put(Bytecode.OperatorKind.NEG, Expr.Unary.Op.NEG);
>, <Line: +		// Logical
>, <Line: +		unaryOperatorMap.put(Bytecode.OperatorKind.NOT, Expr.Unary.Op.NOT);
>, <Line: +		// Array
>, <Line: +		unaryOperatorMap.put(Bytecode.OperatorKind.ARRAYLENGTH, Expr.Unary.Op.LENGTHOF);
>, <Line: +		// =====================================================================
>, <Line: +		// Binary operator map
>, <Line: +		// =====================================================================
>, <Line: +		binaryOperatorMap = new HashMap<Bytecode.OperatorKind, Expr.Binary.Op>();
>, <Line: +		// Arithmetic
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.ADD, Expr.Binary.Op.ADD);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.SUB, Expr.Binary.Op.SUB);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.MUL, Expr.Binary.Op.MUL);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.DIV, Expr.Binary.Op.DIV);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.REM, Expr.Binary.Op.REM);
>, <Line: +		// Equality
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.EQ, Expr.Binary.Op.EQ);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.NEQ, Expr.Binary.Op.NEQ);
>, <Line: +		// Relational
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.LT, Expr.Binary.Op.LT);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.GT, Expr.Binary.Op.GT);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.LTEQ, Expr.Binary.Op.LTEQ);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.GTEQ, Expr.Binary.Op.GTEQ);
>, <Line: +		// Logical
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.AND, Expr.Binary.Op.AND);
>, <Line: +		binaryOperatorMap.put(Bytecode.OperatorKind.OR, Expr.Binary.Op.OR);
>, <Line: +	}
>, <Line: +}
>]
[]