[<Line: +import static wyil.util.interpreter.Interpreter.error;
>, <Line: +import java.security.Policy.Parameters;
>, <Line: +import wycc.lang.SyntacticElement;
>, <Line: +import wyil.lang.Bytecode.*;
>, <Line: +import static wyil.lang.SyntaxTree.*;
>, <Line: +import wyil.util.TypeSystem;
>, <Line: +import wyil.util.interpreter.Interpreter.ConstantObject;
>, <Line: +	private final TypeSystem expander;
>, <Line: +		this.expander = new TypeSystem(project);
>, <Line: +	private enum Status {
>, <Line: +		RETURN,
>, <Line: +		BREAK,
>, <Line: +		CONTINUE,
>, <Line: +		NEXT
>, <Line: +	}
>, <Line: +			if (fm.getBody() == null) {
>, <Line: +				// FIXME: Add support for native functions or methods. That is,
>, <Line: +				// allow native functions to be implemented and called from the
>, <Line: +				// interpreter.
>, <Line: +			SyntaxTree tree = fm.getTree();
>, <Line: +			Constant[] frame = new Constant[tree.getLocations().size()];
>, <Line: +			System.arraycopy(args, 0, frame, 0, sig.params().size());			
>, <Line: +			// Check the precondition
>, <Line: +			checkInvariants(frame,fm.getPrecondition());
>, <Line: +			// Execute the method or function body
>, <Line: +			executeBlock(fm.getBody(), frame);
>, <Line: +			// Extra the return values
>, <Line: +			Constant[] returns = extractReturns(frame,fm.type());
>, <Line: +			//
>, <Line: +			// Check the postcondition holds
>, <Line: +			System.arraycopy(args,0,frame,0,args.length);
>, <Line: +			checkInvariants(frame, fm.getPostcondition());
>, <Line: +			// 				
>, <Line: +			return returns;			
>, <Line: +	 * Given an execution frame, extract the return values from a given function
>, <Line: +	 * or method. The parameters of the function or method are located first in
>, <Line: +	 * the frame, followed by the return values.
>, <Line: +	 * @param type
>, <Line: +	private Constant[] extractReturns(Constant[] frame, Type.FunctionOrMethod type) {
>, <Line: +		int paramsSize = type.params().size();
>, <Line: +		int returnsSize = type.returns().size();
>, <Line: +		Constant[] returns = new Constant[returnsSize];
>, <Line: +		for (int i = 0, j = paramsSize; i != returnsSize; ++i, ++j) {
>, <Line: +			returns[i] = frame[j];
>, <Line: +		}
>, <Line: +		return returns;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a given block of statements starting from the beginning. Control
>, <Line: +	 * may terminate prematurely in a number of situations. For example, when a
>, <Line: +	 * return or break statement is encountered.
>, <Line: +	 * 
>, <Line: +	 * @param block
>, <Line: +	 *            --- Statement block to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 *
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeBlock(Location<Block> block, Constant[] frame) {
>, <Line: +		for (int i = 0; i != block.numberOfOperands(); ++i) {
>, <Line: +			Location<Stmt> stmt = (Location<Stmt>) block.getOperand(i);
>, <Line: +			Status r = executeStatement(stmt, frame);
>, <Line: +			if (r != Status.NEXT) {				
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a statement at a given point in the function or method body
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The statement to be executed
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeStatement(Location<?> stmt, Constant[] frame) {
>, <Line: +		switch (stmt.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_assert:
>, <Line: +		case Bytecode.OPCODE_assume:
>, <Line: +			return executeAssertOrAssume((Location<AssertOrAssume>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_assign:
>, <Line: +			return executeAssign((Location<Assign>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_break:
>, <Line: +			return executeBreak((Location<Break>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_continue:
>, <Line: +			return executeContinue((Location<Continue>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_debug:
>, <Line: +			return executeDebug((Location<Debug>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_dowhile:
>, <Line: +			return executeDoWhile((Location<DoWhile>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_fail:
>, <Line: +			return executeFail((Location<Fail>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_if:
>, <Line: +		case Bytecode.OPCODE_ifelse:
>, <Line: +			return executeIf((Location<If>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_indirectinvoke:
>, <Line: +			executeIndirectInvoke((Location<IndirectInvoke>) stmt, frame);
>, <Line: +			return Status.NEXT;
>, <Line: +		case Bytecode.OPCODE_invoke:
>, <Line: +			executeInvoke((Location<Invoke>) stmt, frame);
>, <Line: +			return Status.NEXT;
>, <Line: +		case Bytecode.OPCODE_namedblock:
>, <Line: +			return executeNamedBlock((Location<NamedBlock>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_while:
>, <Line: +			return executeWhile((Location<While>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_return:
>, <Line: +			return executeReturn((Location<Return>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_skip:
>, <Line: +			return executeSkip((Location<Skip>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_switch:
>, <Line: +			return executeSwitch((Location<Switch>) stmt, frame);
>, <Line: +		case Bytecode.OPCODE_vardeclinit:
>, <Line: +		case Bytecode.OPCODE_vardecl:
>, <Line: +			return executeVariableDeclaration((Location<VariableDeclaration>) stmt, frame);
>, <Line: +		}
>, <Line: +		deadCode(stmt);
>, <Line: +		return null; // deadcode
>, <Line: +	}
>, <Line: +	private Status executeAssign(Location<Assign> stmt, Constant[] frame) {
>, <Line: +		// FIXME: handle multi-assignments properly
>, <Line: +		SyntaxTree.Location<?>[] lhs = stmt.getOperandGroup(LEFTHANDSIDE);
>, <Line: +		Constant[] rhs = executeExpressions(stmt.getOperandGroup(RIGHTHANDSIDE), frame);
>, <Line: +		for (int i = 0; i != lhs.length; ++i) {
>, <Line: +			// TODO: this is not a very efficient way of implement assignment.
>, <Line: +			// To improve performance, it would help if values were mutable,
>, <Line: +			// rather than immutable constants.
>, <Line: +			LVal lval = constructLVal(lhs[i], frame);
>, <Line: +			lval.write(frame, rhs[i]);
>, <Line: +		}
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute an assert or assume statement. In both cases, if the condition
>, <Line: +	 * evaluates to false an exception is thrown.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Assert or Assume statement.
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeAssertOrAssume(Location<AssertOrAssume> stmt, Constant[] frame) {
>, <Line: +		//
>, <Line: +		checkInvariants(frame,(Location<Expr>) stmt.getOperand(CONDITION));
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a break statement. This transfers to control out of the nearest
>, <Line: +	 * enclosing loop.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Break statement.
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeBreak(Location<Break> stmt, Constant[] frame) {
>, <Line: +		// TODO: the break bytecode supports a non-nearest exit and eventually
>, <Line: +		// this should be supported.
>, <Line: +		return Status.BREAK;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a continue statement. This transfers to control back to the start
>, <Line: +	 * the nearest enclosing loop.
>, <Line: +	 * 
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Break statement.
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeContinue(Location<Continue> stmt, Constant[] frame) {
>, <Line: +		// TODO: the continue bytecode supports a non-nearest exit and eventually
>, <Line: +		// this should be supported.
>, <Line: +		return Status.CONTINUE;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a Debug statement at a given point in the function or method
>, <Line: +	 * body. This will write the provided string out to the debug stream.
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Debug statement to executed
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeDebug(Location<Debug> stmt, Constant[] frame) {
>, <Line: +		//
>, <Line: +		Constant.Array arr = executeExpression(ARRAY_T, stmt.getOperand(0), frame);
>, <Line: +		for (Constant item : arr.values()) {
>, <Line: +			BigInteger b = ((Constant.Integer) item).value();
>, <Line: +			char c = (char) b.intValue();
>, <Line: +			debug.print(c);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a DoWhile statement at a given point in the function or method
>, <Line: +	 * body. This will loop over the body zero or more times.
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Loop statement to executed
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeDoWhile(Location<DoWhile> stmt, Constant[] frame) {
>, <Line: +		Status r = Status.NEXT;
>, <Line: +		while (r == Status.NEXT || r == Status.CONTINUE) {
>, <Line: +			r = executeBlock(stmt.getBlock(0), frame);
>, <Line: +			if (r == Status.NEXT) {
>, <Line: +				Constant.Bool operand = executeExpression(BOOL_T, stmt.getOperand(CONDITION), frame);
>, <Line: +				if (!operand.value()) {
>, <Line: +					return Status.NEXT;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// If we get here, then we have exited the loop body without falling
>, <Line: +		// through to the next bytecode.
>, <Line: +		if (r == Status.BREAK) {
>, <Line: +			return Status.NEXT;
>, <Line: +			return r;
>, <Line: +	 * Execute a fail statement at a given point in the function or method body.
>, <Line: +	 * This will generate a runtime fault.
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The fail statement to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeFail(Location<Fail> stmt, Constant[] frame) {
>, <Line: +		throw new AssertionError("Runtime fault occurred");
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute an if statement at a given point in the function or method body.
>, <Line: +	 * This will proceed done either the true or false branch.
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The if statement to execute
>, <Line: +	private Status executeIf(Location<If> stmt, Constant[] frame) {
>, <Line: +		Bytecode.If bytecode = stmt.getBytecode();
>, <Line: +		Constant.Bool operand = executeExpression(BOOL_T, stmt.getOperand(CONDITION), frame);
>, <Line: +		if (operand.value()) {
>, <Line: +			// branch taken, so execute true branch
>, <Line: +			return executeBlock(stmt.getBlock(TRUEBRANCH), frame);
>, <Line: +		} else if (bytecode.hasFalseBranch()) {
>, <Line: +			// branch not taken, so execute false branch
>, <Line: +			return executeBlock(stmt.getBlock(FALSEBRANCH), frame);
>, <Line: +			return Status.NEXT;
>, <Line: +	 * Execute a named block which is simply a block of statements.
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Block statement to executed
>, <Line: +	private Status executeNamedBlock(Location<NamedBlock> stmt, Constant[] frame) {
>, <Line: +		Location<Block> block = stmt.getBlock(0);
>, <Line: +		return executeBlock(block,frame);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a While statement at a given point in the function or method
>, <Line: +	 * body. This will loop over the body zero or more times.
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- Loop statement to executed
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeWhile(Location<While> stmt, Constant[] frame) {
>, <Line: +		Status r;
>, <Line: +		do {
>, <Line: +			Constant.Bool operand = executeExpression(BOOL_T, stmt.getOperand(CONDITION), frame);
>, <Line: +			if (!operand.value()) {
>, <Line: +				return Status.NEXT;
>, <Line: +			}
>, <Line: +			// Keep executing the loop body until we exit it somehow.
>, <Line: +			r = executeBlock(stmt.getBlock(0), frame);
>, <Line: +		} while (r == Status.NEXT || r == Status.CONTINUE);
>, <Line: +		// If we get here, then we have exited the loop body without falling
>, <Line: +		// through to the next bytecode.
>, <Line: +		if (r == Status.BREAK) {
>, <Line: +			return Status.NEXT;
>, <Line: +	 * Execute a Return statement at a given point in the function or method
>, <Line: +	 * body
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The return statement to execute
>, <Line: +	private Status executeReturn(Location<Return> stmt, Constant[] frame) {
>, <Line: +		// We know that a return statement can only appear in either a function
>, <Line: +		// or method declaration. It cannot appear, for example, in a type
>, <Line: +		// declaration. Therefore, the enclosing declaration is a function or
>, <Line: +		// method.
>, <Line: +		SyntaxTree tree = stmt.getEnclosingTree();
>, <Line: +		WyilFile.FunctionOrMethod fm = (WyilFile.FunctionOrMethod) tree.getEnclosingDeclaration();
>, <Line: +		Type.FunctionOrMethod type = fm.type();
>, <Line: +		int paramsSize = type.params().size();
>, <Line: +		Constant[] values = executeExpressions(stmt.getOperands(), frame);
>, <Line: +		for (int i = 0, j = paramsSize; i != values.length; ++i, ++j) {
>, <Line: +			frame[j] = values[i];
>, <Line: +		}
>, <Line: +		return Status.RETURN;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a skip statement at a given point in the function or method
>, <Line: +	 * body
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The skip statement to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeSkip(Location<Skip> stmt, Constant[] frame) {
>, <Line: +		// skip !
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a Switch statement at a given point in the function or method
>, <Line: +	 * body
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The swithc statement to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeSwitch(Location<Switch> stmt, Constant[] frame) {
>, <Line: +		Bytecode.Switch bytecode = stmt.getBytecode();
>, <Line: +		Bytecode.Case[] cases = bytecode.cases();
>, <Line: +		//
>, <Line: +		Constant value = executeExpression(ANY_T, stmt.getOperand(CONDITION), frame);
>, <Line: +		for (int i = 0; i != cases.length; ++i) {
>, <Line: +			Bytecode.Case c = cases[i];
>, <Line: +			Location<Block> body = stmt.getBlock(i);
>, <Line: +			if (c.isDefault()) {
>, <Line: +				return executeBlock(body, frame);
>, <Line: +			} else {
>, <Line: +				for (Constant v : c.values()) {
>, <Line: +					if (v.equals(value)) {
>, <Line: +						return executeBlock(body, frame);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		return Status.NEXT;
>, <Line: +	 * Execute a variable declaration statement at a given point in the function or method
>, <Line: +	 * body
>, <Line: +	 *
>, <Line: +	 * @param stmt
>, <Line: +	 *            --- The statement to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Status executeVariableDeclaration(Location<VariableDeclaration> stmt, Constant[] frame) {
>, <Line: +		// We only need to do something if this has an initialiser
>, <Line: +		if(stmt.numberOfOperands() > 0) {
>, <Line: +			Constant value = executeExpression(ANY_T, stmt.getOperand(0), frame);
>, <Line: +			frame[stmt.getIndex()] = value;
>, <Line: +		}
>, <Line: +		return Status.NEXT;
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Single expressions
>, <Line: +	// =============================================================		
>, <Line: +	/**
>, <Line: +	 * Execute a single expression which is expected to return a single result
>, <Line: +	 * of an expected type. If a result of an incorrect type is returned, then
>, <Line: +	 * an exception is raised.
>, <Line: +	 * 
>, <Line: +	 * @param expected
>, <Line: +	 *            The expected type of the result
>, <Line: +	 * @param expr
>, <Line: +	 *            The expression to be executed
>, <Line: +	 * @param frame
>, <Line: +	 *            The frame in which the expression is executing
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private <T extends Constant> T executeExpression(Class<T> expected, Location<?> expr, Constant[] frame) {
>, <Line: +		Constant val;
>, <Line: +		Bytecode.Expr bytecode = (Bytecode.Expr) expr.getBytecode();
>, <Line: +		switch (bytecode.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_const:
>, <Line: +			val = executeConst((Location<Const>) expr, frame);
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_convert:
>, <Line: +			val = executeConvert((Location<Bytecode.Convert>) expr, frame);
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_fieldload:
>, <Line: +			val = executeFieldLoad((Location<FieldLoad>) expr, frame);
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_indirectinvoke:
>, <Line: +			val = executeIndirectInvoke((Location<IndirectInvoke>) expr, frame)[0];
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_invoke:
>, <Line: +			val = executeInvoke((Location<Invoke>) expr, frame)[0];
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_lambda:
>, <Line: +			val = executeLambda((Location<Lambda>) expr, frame);
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_some:
>, <Line: +		case Bytecode.OPCODE_all:
>, <Line: +			val = executeQuantifier((Location<Quantifier>) expr, frame);
>, <Line: +			break;
>, <Line: +		case Bytecode.OPCODE_varaccess:
>, <Line: +			val = executeVariableAccess((Location<VariableAccess>) expr, frame);
>, <Line: +			break;
>, <Line: +		default:
>, <Line: +			val = executeOperator((Location<Operator>) expr, frame);
>, <Line: +		}
>, <Line: +		return checkType(val, expr, expected);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a Constant expression at a given point in the function or
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	private Constant executeConst(Location<Const> expr, Constant[] frame) {
>, <Line: +		return expr.getBytecode().constant();
>, <Line: +	/**
>, <Line: +	 * Execute a type conversion at a given point in the function or method body
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant executeConvert(Location<Convert> expr, Constant[] frame) {
>, <Line: +			Constant operand = executeExpression(ANY_T, expr.getOperand(0), frame);
>, <Line: +			Type target = expander.getUnderlyingType(expr.getType());
>, <Line: +			return convert(operand, target, expr);
>, <Line: +			error(e.getMessage(), expr);
>, <Line: +			return null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a binary operator at a given point in the function or method
>, <Line: +	 * body. This will check operands match their expected types.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant executeOperator(Location<Operator> expr, Constant[] frame) {
>, <Line: +		Bytecode bytecode = expr.getBytecode();
>, <Line: +		switch (bytecode.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_logicaland: {
>, <Line: +			// This is a short-circuiting operator
>, <Line: +			Constant.Bool lhs = executeExpression(BOOL_T, expr.getOperand(0), frame);
>, <Line: +			if (!lhs.value()) {
>, <Line: +				// Short-circuit
>, <Line: +				return Constant.False;
>, <Line: +			}
>, <Line: +			return executeExpression(BOOL_T, expr.getOperand(1), frame);
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_logicalor: {
>, <Line: +			// This is a short-circuiting operator
>, <Line: +			Constant.Bool lhs = executeExpression(BOOL_T, expr.getOperand(0), frame);
>, <Line: +			if (lhs.value()) {
>, <Line: +				// Short-circuit
>, <Line: +				return Constant.True;
>, <Line: +			}
>, <Line: +			return executeExpression(BOOL_T, expr.getOperand(1), frame);
>, <Line: +		}
>, <Line: +		default: {
>, <Line: +			// This is the default case where can treat the operator as an
>, <Line: +			// external function and just call it with the evaluated operands.
>, <Line: +			SyntaxTree.Location<?>[] operands = expr.getOperands();
>, <Line: +			Constant[] values = new Constant[operands.length];
>, <Line: +			// Read all operands
>, <Line: +			for (int i = 0; i != operands.length; ++i) {
>, <Line: +				values[i] = executeExpression(ANY_T, operands[i], frame);
>, <Line: +			}
>, <Line: +			// Compute result
>, <Line: +			return operators[bytecode.getOpcode()].apply(values, this, expr);
>, <Line: +		}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Constant executeFieldLoad(Location<FieldLoad> loc, Constant[] frame) {
>, <Line: +		Bytecode.FieldLoad bytecode = loc.getBytecode();
>, <Line: +		Constant.Record rec = executeExpression(RECORD_T, loc.getOperand(0), frame);
>, <Line: +		return rec.values().get(bytecode.fieldName());
>, <Line: +	}
>, <Line: +	private Constant executeQuantifier(Location<Quantifier> expr, Constant[] frame) {
>, <Line: +		boolean r = executeQuantifier(0, expr, frame);
>, <Line: +		// r ==> continued all the way through
>, <Line: +		// ! ==> terminated early
>, <Line: +		if (expr.getOpcode() == Bytecode.OPCODE_some) {
>, <Line: +			return r ? Constant.False : Constant.True;
>, <Line: +		} else {
>, <Line: +			return r ? Constant.True : Constant.False;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute one range of the quantifier, or the body if no ranges remain.
>, <Line: +	 * 
>, <Line: +	 * @param index
>, <Line: +	 * @param expr
>, <Line: +	 * @param frame
>, <Line: +	 * @param context
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private boolean executeQuantifier(int index, Location<Quantifier> expr, Constant[] frame) {
>, <Line: +		Bytecode.Quantifier bytecode = expr.getBytecode();
>, <Line: +		if (index == expr.numberOfOperandGroups()) {
>, <Line: +			// This is the base case where we evaluate the condition itself.
>, <Line: +			Constant.Bool r = executeExpression(BOOL_T, expr.getOperand(CONDITION), frame);
>, <Line: +			int opcode = bytecode.getOpcode();
>, <Line: +			if (r.value() && opcode == Bytecode.OPCODE_some) {
>, <Line: +				return false;
>, <Line: +			} else if (!r.value() && opcode == Bytecode.OPCODE_all) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +			// This means that, for the given quantifier kind, we have to
>, <Line: +			// continue as is.
>, <Line: +			return true;
>, <Line: +		} else {
>, <Line: +			SyntaxTree.Location<?>[] range = expr.getOperandGroup(index);
>, <Line: +			int var = range[VARIABLE].getIndex();
>, <Line: +			Constant.Integer start = executeExpression(INT_T, range[START], frame);
>, <Line: +			Constant.Integer end = executeExpression(INT_T, range[END], frame);			
>, <Line: +			long s = start.value().longValue();
>, <Line: +			long e = end.value().longValue();
>, <Line: +			for (long i = s; i < e; ++i) {
>, <Line: +				frame[var] = new Constant.Integer(BigInteger.valueOf(i));
>, <Line: +				boolean r = executeQuantifier(index + 1, expr, frame);
>, <Line: +				if (!r) {
>, <Line: +					// early termination
>, <Line: +					return r;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return true;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private Constant executeLambda(Location<Lambda> expr, Constant[] frame) {
>, <Line: +		// Clone the frame at this point, in order that changes seen after this
>, <Line: +		// bytecode is executed are not propagated into the lambda itself.
>, <Line: +		frame = Arrays.copyOf(frame, frame.length);
>, <Line: +		return new ConstantLambda(expr, frame);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute a variable access expression at a given point in the function or
>, <Line: +	 * method body. This simply loads the value of the given variable from the
>, <Line: +	 * frame.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant executeVariableAccess(Location<VariableAccess> expr, Constant[] frame) {
>, <Line: +		Location<VariableDeclaration> decl = getVariableDeclaration(expr);
>, <Line: +		return frame[decl.getIndex()];
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Multiple expressions
>, <Line: +	// =============================================================
>, <Line: +	/**
>, <Line: +	 * Execute one or more expressions. This is slightly more complex than for
>, <Line: +	 * the single expression case because of the potential to encounter
>, <Line: +	 * "positional operands". That is, severals which arise from executing the
>, <Line: +	 * same expression.
>, <Line: +	 * 
>, <Line: +	 * @param operands
>, <Line: +	 * @param frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant[] executeExpressions(Location<?>[] operands, Constant[] frame) {
>, <Line: +		Constant[][] results = new Constant[operands.length][];
>, <Line: +		int count = 0;
>, <Line: +		for(int i=0;i!=operands.length;++i) {
>, <Line: +			results[i] = executeMultiReturnExpression(operands[i],frame);
>, <Line: +			count += results[i].length;
>, <Line: +		}
>, <Line: +		Constant[] rs = new Constant[count];
>, <Line: +		int j = 0;
>, <Line: +		for(int i=0;i!=operands.length;++i) {
>, <Line: +			Constant[] r = results[i];
>, <Line: +			System.arraycopy(r, 0, rs, j, r.length);
>, <Line: +			j += r.length;
>, <Line: +		}
>, <Line: +		return rs;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute an expression which has the potential to return more than one
>, <Line: +	 * result. Thus the return type must accommodate this by allowing zero or
>, <Line: +	 * more returned values.
>, <Line: +	 * 
>, <Line: +	 * @param expr
>, <Line: +	 * @param frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant[] executeMultiReturnExpression(Location<?> expr, Constant[] frame) {
>, <Line: +		Bytecode.Expr bytecode = (Expr) expr.getBytecode();
>, <Line: +		switch (bytecode.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_indirectinvoke:
>, <Line: +			return executeIndirectInvoke((Location<IndirectInvoke>) expr, frame);
>, <Line: +		case Bytecode.OPCODE_invoke:
>, <Line: +			return executeInvoke((Location<Invoke>) expr, frame);
>, <Line: +		case Bytecode.OPCODE_const:
>, <Line: +		case Bytecode.OPCODE_convert:
>, <Line: +		case Bytecode.OPCODE_fieldload:
>, <Line: +		case Bytecode.OPCODE_lambda:
>, <Line: +		case Bytecode.OPCODE_some:
>, <Line: +		case Bytecode.OPCODE_all:
>, <Line: +		default:
>, <Line: +			Constant val = executeExpression(ANY_T, expr, frame);
>, <Line: +			return new Constant[] { val };
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Execute an IndirectInvoke bytecode instruction at a given point in the
>, <Line: +	 * function or method body. This first checks the operand is a function
>, <Line: +	 * reference, and then generates a recursive call to execute the given
>, <Line: +	 * function. If the function does not exist, or is provided with the wrong
>, <Line: +	 * number of arguments, then a runtime fault will occur.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @param context
>, <Line: +	 *            --- Context in which bytecodes are executed
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant[] executeIndirectInvoke(Location<IndirectInvoke> expr, Constant[] frame) {
>, <Line: +		// FIXME: This is implementation is *ugly* --- can we do better than
>, <Line: +		// this? One approach is to register an anonymous function so that we
>, <Line: +		// can reuse executeAllWithin in both bases. This is hard to setup
>, <Line: +		// though.
>, <Line: +		SyntaxTree.Location<?> src = expr.getOperand(0);
>, <Line: +		Constant operand = executeExpression(ANY_T, src,frame);
>, <Line: +		// Check that we have a function reference
>, <Line: +		if(operand instanceof Constant.FunctionOrMethod) {
>, <Line: +			Constant.FunctionOrMethod cl = checkType(operand, src, Constant.FunctionOrMethod.class);			
>, <Line: +			Constant[] arguments = executeExpressions(expr.getOperandGroup(ARGUMENTS),frame);			
>, <Line: +			return execute(cl.name(),cl.type(),arguments);
>, <Line: +		} else {
>, <Line: +			ConstantLambda cl = checkType(operand, src, ConstantLambda.class);
>, <Line: +			// Yes we do; now construct the arguments. This requires merging the
>, <Line: +			// constant arguments provided in the lambda itself along with those
>, <Line: +			// operands provided for the "holes".
>, <Line: +			Constant[] lambdaFrame = Arrays.copyOf(cl.frame, cl.frame.length); 
>, <Line: +			int[] parameters = cl.lambda.getBytecode().getOperandGroup(PARAMETERS);
>, <Line: +			Constant[] arguments = executeExpressions(expr.getOperandGroup(ARGUMENTS),frame);
>, <Line: +			for(int i=0;i!=parameters.length;++i) {			
>, <Line: +				lambdaFrame[parameters[i]] = arguments[i];
>, <Line: +			}
>, <Line: +			// Make the actual call. This may return multiple values since it is
>, <Line: +			// a function/method invocation.
>, <Line: +			return executeMultiReturnExpression(cl.lambda.getOperand(BODY), lambdaFrame);
>, <Line: +	/**
>, <Line: +	 * Execute an Invoke bytecode instruction at a given point in the function
>, <Line: +	 * or method body. This generates a recursive call to execute the given
>, <Line: +	 * function. If the function does not exist, or is provided with the wrong
>, <Line: +	 * number of arguments, then a runtime fault will occur.
>, <Line: +	 *
>, <Line: +	 * @param expr
>, <Line: +	 *            --- The expression to execute
>, <Line: +	 * @param frame
>, <Line: +	 *            --- The current stack frame
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	private Constant[] executeInvoke(Location<Invoke> expr, Constant[] frame) {
>, <Line: +		Bytecode.Invoke bytecode = expr.getBytecode();
>, <Line: +		SyntaxTree.Location<?>[] operands = expr.getOperands();
>, <Line: +		Constant[] arguments = executeExpressions(operands,frame);		
>, <Line: +		return execute(bytecode.name(), bytecode.type(), arguments);		
>, <Line: +	}
>, <Line: +	// =============================================================
>, <Line: +	// Constants
>, <Line: +	// =============================================================
>, <Line: +	private Constant convert(Constant value, Type to, SyntacticElement context) {
>, <Line: +	private Constant convert(Constant value, Type.Record to, SyntacticElement context) {
>, <Line: +	private Constant convert(Constant value, Type.Array to, SyntacticElement context) {
>, <Line: +	private Constant convert(Constant value, Type.Union to, SyntacticElement context) {
>, <Line: +	private Constant convert(Constant value, Type.FunctionOrMethod to, SyntacticElement context) {
>, <Line: +	 * This method constructs a "mutable" representation of the lval. This is a
>, <Line: +	 * bit strange, but is necessary because values in the frame are currently
>, <Line: +	 * immutable.
>, <Line: +	 * @param operand
>, <Line: +	private LVal constructLVal(SyntaxTree.Location<?> expr, Constant[] frame) {
>, <Line: +		switch (expr.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_arrayindex: {
>, <Line: +			LVal src = constructLVal(expr.getOperand(0), frame);
>, <Line: +			Constant.Integer index = executeExpression(INT_T, expr.getOperand(1), frame);
>, <Line: +			int i = index.value().intValue();
>, <Line: +			return new ArrayLVal(src, i);
>, <Line: +		case Bytecode.OPCODE_dereference: {
>, <Line: +			LVal src = constructLVal(expr.getOperand(0), frame);
>, <Line: +			return new DereferenceLVal(src);
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_fieldload: {
>, <Line: +			Bytecode.FieldLoad fl = (Bytecode.FieldLoad) expr.getBytecode();
>, <Line: +			LVal src = constructLVal(expr.getOperand(0), frame);
>, <Line: +			return new RecordLVal(src, fl.fieldName());
>, <Line: +		}
>, <Line: +		case Bytecode.OPCODE_varaccess: {
>, <Line: +			Location<VariableDeclaration> decl = getVariableDeclaration(expr); 
>, <Line: +			return new VariableLVal(decl.getIndex());
>, <Line: +		}
>, <Line: +		}
>, <Line: +		deadCode(expr);
>, <Line: +		return null; // deadcode
>, <Line: +	private abstract class LVal {
>, <Line: +		abstract public Constant read(Constant[] frame);
>, <Line: +		abstract public void write(Constant[] frame,Constant rhs);
>, <Line: +	}
>, <Line: +	private class VariableLVal extends LVal {
>, <Line: +		private final int index;
>, <Line: +		public VariableLVal(int index) {
>, <Line: +			this.index = index;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Constant read(Constant[] frame) {
>, <Line: +			return frame[index];
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public void write(Constant[] frame, Constant rhs) {
>, <Line: +			frame[index] = rhs;
>, <Line: +	private class ArrayLVal extends LVal {
>, <Line: +		private final LVal src;
>, <Line: +		private final int index;
>, <Line: +		public ArrayLVal(LVal src, int index) {
>, <Line: +			this.src = src;
>, <Line: +			this.index = index;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Constant read(Constant[] frame) {
>, <Line: +			Constant.Array src = checkType(this.src.read(frame),null,Constant.Array.class);
>, <Line: +			return src.values().get(index);		
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public void write(Constant[] frame,Constant rhs) {
>, <Line: +			Constant.Array arr = checkType(this.src.read(frame),null,Constant.Array.class);			
>, <Line: +			ArrayList<Constant> values = new ArrayList<Constant>(arr.values());				
>, <Line: +			values.set(index, rhs);
>, <Line: +			src.write(frame,new Constant.Array(values));
>, <Line: +		}
>, <Line: +	private class RecordLVal extends LVal {
>, <Line: +		private final LVal src;
>, <Line: +		private final String field;
>, <Line: +		public RecordLVal(LVal src, String field) {
>, <Line: +			this.src = src;
>, <Line: +			this.field = field;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Constant read(Constant[] frame) {
>, <Line: +			Constant.Record src = checkType(this.src.read(frame),null,Constant.Record.class);
>, <Line: +			return src.values().get(field);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public void write(Constant[] frame, Constant rhs) {
>, <Line: +			Constant.Record rec = checkType(this.src.read(frame),null,Constant.Record.class);
>, <Line: +			HashMap<String, Constant> values = new HashMap<String, Constant>(rec.values());			
>, <Line: +			values.put(field, rhs);
>, <Line: +			src.write(frame,new Constant.Record(values));			
>, <Line: +	private class DereferenceLVal extends LVal {
>, <Line: +		private final LVal src;
>, <Line: +		public DereferenceLVal(LVal src) {
>, <Line: +			this.src = src;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public Constant read(Constant[] frame) {
>, <Line: +			ConstantObject objecy = checkType(src.read(frame),null,ConstantObject.class);
>, <Line: +			return objecy.read();
>, <Line: +		@Override
>, <Line: +		public void write(Constant[] frame, Constant rhs) {
>, <Line: +			ConstantObject object = checkType(src.read(frame),null,ConstantObject.class);
>, <Line: +			object.write(rhs);
>, <Line: +		}
>, <Line: +	public boolean isMemberOfType(Constant value, Type type, SyntacticElement context) {
>, <Line: +			if (value instanceof Constant.FunctionOrMethod) {
>, <Line: +				Constant.FunctionOrMethod l = (Constant.FunctionOrMethod) value;
>, <Line: +				// First, attempt to locate the enclosing module for this
>, <Line: +				// nominal type.  
>, <Line: +				// Read in the module. This may result in it being read from
>, <Line: +				// disk, or from a cache in memory, or even from somewhere else.
>, <Line: +				// Check every invariant associated with this type evaluates to
>, <Line: +				// true. 
>, <Line: +				List<Location<Expr>> invariants = td.getInvariant();
>, <Line: +				if (invariants.size() > 0) {
>, <Line: +					SyntaxTree tree = td.getTree();
>, <Line: +					Constant[] frame = new Constant[tree.getLocations().size()];
>, <Line: +					checkInvariants(frame, invariants);
>, <Line: +	 * Evaluate zero or more conditional expressions, and check whether any is
>, <Line: +	 * false. If so, raise an exception indicating a runtime fault.
>, <Line: +	 * @param invariants
>, <Line: +	public void checkInvariants(Constant[] frame, List<Location<Expr>> invariants) {
>, <Line: +		for (int i = 0; i != invariants.size(); ++i) {
>, <Line: +			Constant.Bool b = executeExpression(BOOL_T, invariants.get(i), frame);
>, <Line: +			if (!b.value()) {
>, <Line: +				// FIXME: need to do more here
>, <Line: +				throw new AssertionError();
>, <Line: +	 * Evaluate zero or more conditional expressions, and check whether any is
>, <Line: +	 * false. If so, raise an exception indicating a runtime fault.
>, <Line: +	 * @param invariants
>, <Line: +	public void checkInvariants(Constant[] frame, Location<Expr>... invariants) {
>, <Line: +		for (int i = 0; i != invariants.length; ++i) {
>, <Line: +			Constant.Bool b = executeExpression(BOOL_T, invariants[i], frame);
>, <Line: +			if (!b.value()) {
>, <Line: +				// FIXME: need to do more here
>, <Line: +				throw new AssertionError();
>, <Line: +	@SafeVarargs
>, <Line: +	public static <T extends Constant> T checkType(Constant operand, SyntacticElement context, Class<T>... types) {
>, <Line: +		if(operand == null) {
>, <Line: +			error("null operand", context);
>, <Line: +		} else {
>, <Line: +			error("operand returned " + operand.getClass().getName() + ", expecting one of " + Arrays.toString(types), context);
>, <Line: +		}
>, <Line: +	public static Object error(String msg, SyntacticElement context) {
>, <Line: +	private Object deadCode(SyntacticElement element) {
>, <Line: +	public Location<VariableDeclaration> getVariableDeclaration(Location<?> decl) {
>, <Line: +		switch (decl.getOpcode()) {
>, <Line: +		case Bytecode.OPCODE_aliasdecl:
>, <Line: +		case Bytecode.OPCODE_varaccess:
>, <Line: +			return getVariableDeclaration(decl.getOperand(0));
>, <Line: +		case Bytecode.OPCODE_vardecl:
>, <Line: +		case Bytecode.OPCODE_vardeclinit:
>, <Line: +			return (Location<VariableDeclaration>) decl;
>, <Line: +		default:
>, <Line: +			throw new RuntimeException("internal failure --- dead code reached");
>, <Line: +	private static final Class<Constant> ANY_T = Constant.class;
>, <Line: +	private static final Class<Constant.Bool> BOOL_T = Constant.Bool.class;
>, <Line: +	private static final Class<Constant.Integer> INT_T = Constant.Integer.class;
>, <Line: +	private static final Class<Constant.Array> ARRAY_T = Constant.Array.class;
>, <Line: +	private static final Class<Constant.Record> RECORD_T = Constant.Record.class;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Represents an object allocated on the heap.
>, <Line: +	 *
>, <Line: +	 * @author David J. Pearce
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	public static class ConstantLambda extends Constant {
>, <Line: +		private final Location<Bytecode.Lambda> lambda;		
>, <Line: +		private final Constant[] frame;		
>, <Line: +		public ConstantLambda(Location<Bytecode.Lambda> lambda, Constant... frame) {
>, <Line: +			this.lambda = lambda;
>, <Line: +			this.frame = frame;
>, <Line: +		}
>, <Line: +		public boolean equals(Object o) {
>, <Line: +			return o == this;
>, <Line: +		}
>, <Line: +		public int hashCode() {
>, <Line: +			return Arrays.hashCode(frame);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public int compareTo(Constant o) {
>, <Line: +			// This method cannot be implmened because it does not make sense to
>, <Line: +			// compare a reference with another reference.
>, <Line: +			throw new UnsupportedOperationException("ConstantObject.compare() cannot be implemented");
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public wyil.lang.Type type() {
>, <Line: +			return lambda.getType();
>, <Line: +		}
>, <Line: +		public Constant apply(Constant[] operands, Interpreter enclosing, Location<Operator> context);
>]
[<Line: -import wyil.util.TypeExpander;
>, <Line: -	private final TypeExpander expander;
>, <Line: -		this.expander = new TypeExpander(project);
>, <Line: -			BytecodeForest code = fm.code();
>, <Line: -			if (fm.body() == null) {
>, <Line: -				// FIXME: add support for native functions or methods
>, <Line: -			ArrayList<Type> sig_params = sig.params();
>, <Line: -			Constant[] frame = new Constant[code.numRegisters()];
>, <Line: -			for (int i = 0; i != sig_params.size(); ++i) {
>, <Line: -				frame[i] = args[i];
>, <Line: -			}
>, <Line: -			// Finally, let's do it!
>, <Line: -			BytecodeForest.Index pc = new BytecodeForest.Index(fm.body(), 0);
>, <Line: -			return (Constant[]) executeAllWithin(frame, new Context(pc, code));
>, <Line: -	 * Execute a given block of bytecodes starting from the beginning
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecode instructions are executed
>, <Line: -	private Object executeAllWithin(Constant[] frame, Context context) {
>, <Line: -		BytecodeForest forest = context.forest;
>, <Line: -		BytecodeForest.Index pc = context.pc;
>, <Line: -		int block = pc.block();
>, <Line: -		BytecodeForest.Block codes = forest.get(pc.block());
>, <Line: -		while (pc.block() == block && pc.offset() < codes.size()) {
>, <Line: -			Object r = execute(frame, new Context(pc, context.forest));
>, <Line: -			if (r instanceof BytecodeForest.Index) {
>, <Line: -				pc = (BytecodeForest.Index) r;
>, <Line: -			} else {
>, <Line: -		if (pc.block() != block) {
>, <Line: -			// non-local exit
>, <Line: -			return pc;
>, <Line: -			return null;
>, <Line: -	 * Execute an Assign bytecode instruction at a given point in the function
>, <Line: -	 * or method body
>, <Line: -	 * @param pc
>, <Line: -	 *            --- The position of the instruction to execute
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	private Object execute(Constant[] frame, Context context) {
>, <Line: -		Bytecode bytecode = context.forest.get(context.pc).code();
>, <Line: -		// FIXME: turn this into a switch statement?
>, <Line: -		if (bytecode instanceof Bytecode.Invariant) {
>, <Line: -			return execute((Bytecode.Invariant) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.AssertOrAssume) {
>, <Line: -			return execute((Bytecode.AssertOrAssume) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Operator) {
>, <Line: -			return execute((Bytecode.Operator) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Const) {
>, <Line: -			return execute((Bytecode.Const) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Convert) {
>, <Line: -			return execute((Bytecode.Convert) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Debug) {
>, <Line: -			return execute((Bytecode.Debug) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Fail) {
>, <Line: -			return execute((Bytecode.Fail) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.FieldLoad) {
>, <Line: -			return execute((Bytecode.FieldLoad) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Goto) {
>, <Line: -			return execute((Bytecode.Goto) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.If) {
>, <Line: -			return execute((Bytecode.If) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.IfIs) {
>, <Line: -			return execute((Bytecode.IfIs) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.IndirectInvoke) {
>, <Line: -			return execute((Bytecode.IndirectInvoke) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Invoke) {
>, <Line: -			return execute((Bytecode.Invoke) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Label) {
>, <Line: -			// essentially do nout
>, <Line: -			return context.pc.next();
>, <Line: -		} else if (bytecode instanceof Bytecode.Lambda) {
>, <Line: -			return execute((Bytecode.Lambda) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Quantify) {
>, <Line: -			return execute((Bytecode.Quantify) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Loop) {
>, <Line: -			return execute((Bytecode.Loop) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Return) {
>, <Line: -			return execute((Bytecode.Return) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Switch) {
>, <Line: -			return execute((Bytecode.Switch) bytecode, frame, context);
>, <Line: -		} else if (bytecode instanceof Bytecode.Update) {
>, <Line: -			return execute((Bytecode.Update) bytecode, frame, context);
>, <Line: -			throw new IllegalArgumentException("Unknown bytecode encountered: " + bytecode);
>, <Line: -	 * Execute an assert or assume bytecode.
>, <Line: -	 * @param pc
>, <Line: -	 *            --- The position of the instruction to execute
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	private Object execute(Bytecode.AssertOrAssume bytecode, Constant[] frame, Context context) {
>, <Line: -		//
>, <Line: -		BytecodeForest.Index pc = new BytecodeForest.Index(bytecode.block(), 0);
>, <Line: -		Object r = executeAllWithin(frame, new Context(pc, context.forest));
>, <Line: -		//
>, <Line: -		if (r == null) {
>, <Line: -			// Body of assert fell through to next
>, <Line: -			return context.pc.next();
>, <Line: -	 * Execute a binary operator instruction at a given point in the function or
>, <Line: -	 * method body. This will check operands match their expected types.
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	private Object execute(Bytecode.Operator bytecode, Constant[] frame, Context context) {
>, <Line: -		int[] operands = bytecode.operands();
>, <Line: -		Constant[] values = new Constant[operands.length];
>, <Line: -		// Read all operands
>, <Line: -		for(int i=0;i!=operands.length;++i) {
>, <Line: -			values[i] = frame[operands[i]];
>, <Line: -		// Compute result
>, <Line: -		Constant result = operators[bytecode.opcode()].apply(values, context);		
>, <Line: -		// Write result to target
>, <Line: -		frame[bytecode.target(0)] = result;
>, <Line: -		// Continue on to next instruction
>, <Line: -		return context.pc.next();
>, <Line: -	 * Execute a Const bytecode instruction at a given point in the function or
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	private Object execute(Bytecode.Const bytecode, Constant[] frame, Context context) {
>, <Line: -		frame[bytecode.target()] = bytecode.constant();
>, <Line: -		return context.pc.next();
>, <Line: -	private Object execute(Bytecode.Convert bytecode, Constant[] frame, Context context) {
>, <Line: -			Constant operand = frame[bytecode.operand(0)];
>, <Line: -			Type target = expander.getUnderlyingType(bytecode.result());
>, <Line: -			frame[bytecode.target(0)] = convert(operand, target, context);
>, <Line: -			return context.pc.next();
>, <Line: -		} catch (IOException e) {
>, <Line: -			return error(e.getMessage(), context);
>, <Line: -			return error(e.getMessage(), context);
>, <Line: -	private Constant convert(Constant value, Type to, Context context) {
>, <Line: -	private Constant convert(Constant value, Type.Record to, Context context) {
>, <Line: -	private Constant convert(Constant value, Type.Array to, Context context) {
>, <Line: -	private Constant convert(Constant value, Type.Union to, Context context) {
>, <Line: -	private Constant convert(Constant value, Type.FunctionOrMethod to, Context context) {
>, <Line: -	 * Execute a Debug bytecode instruction at a given point in the function or
>, <Line: -	 * method body. This will write the provided string out to the debug stream.
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	private Object execute(Bytecode.Debug bytecode, Constant[] frame, Context context) {
>, <Line: -		//
>, <Line: -		Constant.Array list = (Constant.Array) frame[bytecode.operand(0)];
>, <Line: -		for (Constant item : list.values()) {
>, <Line: -			BigInteger b = ((Constant.Integer) item).value();
>, <Line: -			char c = (char) b.intValue();
>, <Line: -			debug.print(c);
>, <Line: -		//
>, <Line: -		return context.pc.next();
>, <Line: -	/**
>, <Line: -	 * Execute a fail bytecode instruction at a given point in the function or
>, <Line: -	 * method body. This will generate a runtime fault.
>, <Line: -	 *
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 * @param frame
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private Object execute(Bytecode.Fail bytecode, Constant[] frame, Context context) {
>, <Line: -		throw new Error("Runtime fault occurred");
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.FieldLoad bytecode, Constant[] frame, Context context) {
>, <Line: -		Constant.Record rec = (Constant.Record) frame[bytecode.operand(0)];
>, <Line: -		frame[bytecode.target(0)] = rec.values().get(bytecode.fieldName());
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Quantify bytecode, Constant[] frame, Context context) {
>, <Line: -		Constant startOperand = frame[bytecode.startOperand()];
>, <Line: -		Constant endOperand = frame[bytecode.endOperand()];
>, <Line: -		checkType(startOperand, context, Constant.Integer.class);
>, <Line: -		checkType(endOperand, context, Constant.Integer.class);
>, <Line: -		Constant.Integer so = (Constant.Integer) startOperand;
>, <Line: -		Constant.Integer eo = (Constant.Integer) endOperand;
>, <Line: -		int start = so.value().intValue();
>, <Line: -		int end = eo.value().intValue();
>, <Line: -		for (int i = start; i < end; ++i) {
>, <Line: -			// Assign the index variable
>, <Line: -			frame[bytecode.indexOperand()] = new Constant.Integer(BigInteger.valueOf(i));
>, <Line: -			// Execute loop body for one iteration
>, <Line: -			BytecodeForest.Index pc = new BytecodeForest.Index(bytecode.block(), 0);
>, <Line: -			Object r = executeAllWithin(frame, new Context(pc, context.forest));
>, <Line: -			// Now, check whether we fell through to the end or not. If not,
>, <Line: -			// then we must have exited somehow so return to signal that.
>, <Line: -			if (r != null) {
>, <Line: -				return r;
>, <Line: -			}
>, <Line: -		return context.pc.next();
>, <Line: -	private Object execute(Bytecode.Goto bytecode, Constant[] frame, Context context) {
>, <Line: -		return context.getLabel(bytecode.destination());
>, <Line: -	private Object execute(Bytecode.If bytecode, Constant[] frame, Context context) {
>, <Line: -		Constant.Bool operand = checkType(frame[bytecode.operand(0)],context,Constant.Bool.class);
>, <Line: -		if (operand.value()) {
>, <Line: -			// branch taken, so jump to destination label
>, <Line: -			return context.getLabel(bytecode.destination());
>, <Line: -		} else {
>, <Line: -			// branch not taken, so fall through to next bytecode.
>, <Line: -			return context.pc.next();
>, <Line: -	private Object execute(Bytecode.IfIs bytecode, Constant[] frame, Context context) {
>, <Line: -		Type typeOperand = bytecode.type(1);
>, <Line: -		Constant op = frame[bytecode.operand(0)];
>, <Line: -		if (isMemberOfType(op, typeOperand, context)) {
>, <Line: -			return context.getLabel(bytecode.destination());
>, <Line: -		// No, it doesn't so fall through to next instruction
>, <Line: -		return context.pc.next();
>, <Line: -	public boolean isMemberOfType(Constant value, Type type, Context context) {
>, <Line: -			if (value instanceof Constant.Lambda) {
>, <Line: -				Constant.Lambda l = (Constant.Lambda) value;
>, <Line: -				// Second, find the given function or method
>, <Line: -				// Check any invariant associated with this type
>, <Line: -				BytecodeForest invariant = td.invariant();
>, <Line: -				if (invariant.numBlocks() > 0) {
>, <Line: -					Constant[] frame = new Constant[invariant.numRegisters()];
>, <Line: -					BytecodeForest.Index pc = new BytecodeForest.Index(invariant.getRoot(0), 0);
>, <Line: -					executeAllWithin(frame, new Context(pc, invariant));
>, <Line: -	 * Execute an IndirectInvoke bytecode instruction at a given point in the
>, <Line: -	 * function or method body. This first checks the operand is a function
>, <Line: -	 * reference, and then generates a recursive call to execute the given
>, <Line: -	 * function. If the function does not exist, or is provided with the wrong
>, <Line: -	 * number of arguments, then a runtime fault will occur.
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	 * @return
>, <Line: -	private Object execute(Bytecode.IndirectInvoke bytecode, Constant[] frame, Context context) {
>, <Line: -		Constant operand = frame[bytecode.operand(0)];
>, <Line: -		// Check that we have a function reference
>, <Line: -		checkType(operand, context, Constant.Lambda.class);
>, <Line: -		// Yes we do; now construct the arguments. This requires merging the
>, <Line: -		// constant arguments provided in the lambda itself along with those
>, <Line: -		// operands provided for the "holes".
>, <Line: -		Constant.Lambda func = (Constant.Lambda) operand;
>, <Line: -		List<Constant> func_arguments = func.arguments();
>, <Line: -		int[] operands = bytecode.operands();
>, <Line: -		Constant[] arguments = new Constant[func_arguments.size() + (operands.length - 1)];
>, <Line: -		{
>, <Line: -			int i = 0;
>, <Line: -			for (int j = 1; j != operands.length; ++j) {
>, <Line: -				arguments[i++] = frame[operands[j]];
>, <Line: -			}
>, <Line: -			for (int j = 0; j != func_arguments.size(); ++j) {
>, <Line: -				arguments[i++] = func.arguments().get(j);
>, <Line: -		// Make the actual call
>, <Line: -		Constant[] results = execute(func.name(), func.type(), arguments);
>, <Line: -		// Check whether a return value was expected or not
>, <Line: -		int[] targets = bytecode.targets();
>, <Line: -		List<Type> returns = bytecode.type(0).returns();
>, <Line: -		for (int i = 0; i != targets.length; ++i) {
>, <Line: -			// Coerce the result (may not be actually necessary))
>, <Line: -			frame[targets[i]] = convert(results[i], returns.get(i), context);
>, <Line: -		}
>, <Line: -		// Done
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Invariant bytecode, Constant[] frame, Context context) {
>, <Line: -		// FIXME: currently implemented as a NOP because of #480
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Execute an Invoke bytecode instruction at a given point in the function
>, <Line: -	 * or method body. This generates a recursive call to execute the given
>, <Line: -	 * function. If the function does not exist, or is provided with the wrong
>, <Line: -	 * number of arguments, then a runtime fault will occur.
>, <Line: -	 *
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 * @param frame
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 * @param context
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private Object execute(Bytecode.Invoke bytecode, Constant[] frame, Context context) {
>, <Line: -		int[] operands = bytecode.operands();
>, <Line: -		Constant[] arguments = new Constant[operands.length];
>, <Line: -		for (int i = 0; i != arguments.length; ++i) {
>, <Line: -			arguments[i] = frame[operands[i]];
>, <Line: -		}
>, <Line: -		Constant[] results = execute(bytecode.name(), bytecode.type(0), arguments);
>, <Line: -		int[] targets = bytecode.targets();
>, <Line: -		for (int i = 0; i != targets.length; ++i) {
>, <Line: -			frame[targets[i]] = results[i];
>, <Line: -		}
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Lambda bytecode, Constant[] frame, Context context) {
>, <Line: -		int[] operands = bytecode.operands();
>, <Line: -		Constant[] arguments = new Constant[operands.length];
>, <Line: -		for (int i = 0; i != arguments.length; ++i) {
>, <Line: -			int reg = operands[i];
>, <Line: -			arguments[i] = frame[reg];
>, <Line: -		}
>, <Line: -		// FIXME: need to do something with the operands here.
>, <Line: -		frame[bytecode.target(0)] = new Constant.Lambda(bytecode.name(), bytecode.type(0), arguments);
>, <Line: -		//
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Loop bytecode, Constant[] frame, Context context) {
>, <Line: -		Object r;
>, <Line: -		do {
>, <Line: -			// Keep executing the loop body until we exit it somehow.
>, <Line: -			BytecodeForest.Index pc = new BytecodeForest.Index(bytecode.block(), 0);
>, <Line: -			r = executeAllWithin(frame, new Context(pc, context.forest));
>, <Line: -		} while (r == null);
>, <Line: -		// If we get here, then we have exited the loop body without falling
>, <Line: -		// through to the next bytecode.
>, <Line: -		return r;
>, <Line: -	 * Execute a Return bytecode instruction at a given point in the function or
>, <Line: -	 * method body
>, <Line: -	 * @param bytecode
>, <Line: -	 *            --- The bytecode to execute
>, <Line: -	 *            --- The current stack frame
>, <Line: -	 *            --- Context in which bytecodes are executed
>, <Line: -	 * @return
>, <Line: -	private Object execute(Bytecode.Return bytecode, Constant[] frame, Context context) {
>, <Line: -		int[] operands = bytecode.operands();
>, <Line: -		Constant[] returns = new Constant[operands.length];
>, <Line: -		for (int i = 0; i != operands.length; ++i) {
>, <Line: -			returns[i] = frame[operands[i]];
>, <Line: -		}
>, <Line: -		return returns;
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Switch bytecode, Constant[] frame, Context context) {
>, <Line: -		//
>, <Line: -		Constant operand = frame[bytecode.operand(0)];
>, <Line: -		for (Pair<Constant, String> branch : bytecode.branches()) {
>, <Line: -			Constant caseOperand = branch.first();
>, <Line: -			if (caseOperand.equals(operand)) {
>, <Line: -				return context.getLabel(branch.second());
>, <Line: -		return context.getLabel(bytecode.defaultTarget());
>, <Line: -	}
>, <Line: -	private Object execute(Bytecode.Update bytecode, Constant[] frame, Context context) {
>, <Line: -		Constant rhs = frame[bytecode.result()];
>, <Line: -		Constant lhs = frame[bytecode.target(0)];
>, <Line: -		frame[bytecode.target(0)] = update(lhs, bytecode.iterator(), rhs, frame, context);
>, <Line: -		return context.pc.next();
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Manages the process of updating an LVal. Here, the left-hand side (lhs)
>, <Line: -	 * value is passed in along with a descriptor describing the shape of the
>, <Line: -	 * lhs. The right-hand side value is that being assigned by the bytecode to
>, <Line: -	 * a component of the left-hand side.
>, <Line: -	 *
>, <Line: -	 * @param lhs
>, <Line: -	 *            The left-hand side component being updated
>, <Line: -	 * @param descriptor
>, <Line: -	 *            A descriptor describing the shape of the left-hand side
>, <Line: -	 *            component.
>, <Line: -	 * @param rhs
>, <Line: -	 *            The right-hand side value being assigned to the inner-most
>, <Line: -	 *            component of the left-hand side.
>, <Line: -	 * @param frame
>, <Line: -	 *            The current stack frame
>, <Line: -	 * @param context
>, <Line: -	 *            Context in which bytecodes are executed
>, <Line: -	 *
>, <Line: -	 * @return The left-hand side updated with the new value assigned
>, <Line: -	 */
>, <Line: -	private Constant update(Constant lhs, Iterator<Bytecode.LVal> descriptor, Constant rhs, Constant[] frame,
>, <Line: -			Context context) {
>, <Line: -		if (descriptor.hasNext()) {
>, <Line: -			Bytecode.LVal lval = descriptor.next();
>, <Line: -			// Check what shape the left-hand side is
>, <Line: -			if (lval instanceof Bytecode.ArrayLVal) {
>, <Line: -				// List
>, <Line: -				Bytecode.ArrayLVal lv = (Bytecode.ArrayLVal) lval;
>, <Line: -				Constant operand = frame[lv.indexOperand];
>, <Line: -				checkType(operand, context, Constant.Integer.class);
>, <Line: -				checkType(lhs, context, Constant.Array.class);
>, <Line: -				Constant.Array list = (Constant.Array) lhs;
>, <Line: -				int index = ((Constant.Integer) operand).value().intValue();
>, <Line: -				ArrayList<Constant> values = new ArrayList<Constant>(list.values());
>, <Line: -				rhs = update(values.get(index), descriptor, rhs, frame, context);
>, <Line: -				values.set(index, rhs);
>, <Line: -				return new Constant.Array(values);
>, <Line: -			} else if (lval instanceof Bytecode.RecordLVal) {
>, <Line: -				// Record
>, <Line: -				Bytecode.RecordLVal lv = (Bytecode.RecordLVal) lval;
>, <Line: -				checkType(lhs, context, Constant.Record.class);
>, <Line: -				Constant.Record record = (Constant.Record) lhs;
>, <Line: -				HashMap<String, Constant> values = new HashMap<String, Constant>(record.values());
>, <Line: -				rhs = update(values.get(lv.field), descriptor, rhs, frame, context);
>, <Line: -				values.put(lv.field, rhs);
>, <Line: -				return new Constant.Record(values);
>, <Line: -			} else {
>, <Line: -				// Reference
>, <Line: -				Bytecode.ReferenceLVal lv = (Bytecode.ReferenceLVal) lval;
>, <Line: -				checkType(lhs, context, ConstantObject.class);
>, <Line: -				ConstantObject object = (ConstantObject) lhs;
>, <Line: -				rhs = update(object.read(), descriptor, rhs, frame, context);
>, <Line: -				object.write(rhs);
>, <Line: -				return object;
>, <Line: -			}
>, <Line: -		} else {
>, <Line: -			// Base case --- we've reached the inner most component. Therefore,
>, <Line: -			// we effectively replace the lhs with the rhs.
>, <Line: -			return rhs;
>, <Line: -		}
>, <Line: -	public static <T extends Constant> T checkType(Constant operand, Context context, Class<T>... types) {
>, <Line: -		error("invalid operand", context);
>, <Line: -	public static Object error(String msg, Context context) {
>, <Line: -	private Object deadCode(Context context) {
>, <Line: -	/**
>, <Line: -	 * A class for grouping two related items together. In essence, the context
>, <Line: -	 * represents a position within a given bytecode block. This is useful for
>, <Line: -	 * better error reporting.
>, <Line: -	 *
>, <Line: -	 * @author David J. Pearce
>, <Line: -	 *
>, <Line: -	 */
>, <Line: -	public static class Context {
>, <Line: -		public final BytecodeForest.Index pc;
>, <Line: -		public final BytecodeForest forest;
>, <Line: -		private Map<String, BytecodeForest.Index> labels;
>, <Line: -		public Context(BytecodeForest.Index pc, BytecodeForest block) {
>, <Line: -			this.pc = pc;
>, <Line: -			this.forest = block;
>, <Line: -		}
>, <Line: -		public BytecodeForest.Index getLabel(String label) {
>, <Line: -			if (labels == null) {
>, <Line: -				labels = Bytecode.buildLabelMap(forest);
>, <Line: -			}
>, <Line: -			return labels.get(label);
>, <Line: -		}
>, <Line: -		public Bytecode getBytecode() {
>, <Line: -			return forest.get(pc).first();
>, <Line: -		public Constant apply(Constant[] operands, Context context);
>]