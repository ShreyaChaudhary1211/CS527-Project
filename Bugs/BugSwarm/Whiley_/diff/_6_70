[<Line: +import java.math.BigInteger;
>, <Line: +	public WyBool is(Object o) {
>, <Line: +		boolean r = instanceOf(o);
>, <Line: +		return r ? WyBool.TRUE : WyBool.FALSE;
>, <Line: +	}
>, <Line: +	public abstract boolean instanceOf(Object o);
>, <Line: +	private static final class Void extends WyType {
>, <Line: +		Void() {
>, <Line: +			super(K_VOID);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Any extends WyType {
>, <Line: +		Any() {
>, <Line: +			super(K_ANY);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return true;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Meta extends WyType {
>, <Line: +		Meta() {
>, <Line: +			super(K_META);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Null extends WyType {
>, <Line: +		Null() {
>, <Line: +			super(K_NULL);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return o == null;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Bool extends WyType {
>, <Line: +		Bool() {
>, <Line: +			super(K_BOOL);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return o instanceof WyBool;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Byte extends WyType {
>, <Line: +		Byte() {
>, <Line: +			super(K_BYTE);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return o instanceof WyByte;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private static final class Integer extends WyType {
>, <Line: +		Integer() {
>, <Line: +			super(K_INT);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return o instanceof BigInteger;
>, <Line: +		}
>, <Line: +	}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object obj) {
>, <Line: +			if(obj instanceof WyObject) {
>, <Line: +				WyObject ol = (WyObject) obj;
>, <Line: +				return element.instanceOf(ol.state());
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +	public static final class Array extends WyType {
>, <Line: +		public Array(WyType element, boolean nonEmpty) {
>, <Line: +			super(K_LIST);
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object obj) {
>, <Line: +			if(obj instanceof WyArray) {
>, <Line: +				WyArray ol = (WyArray) obj;
>, <Line: +				if(nonEmpty && ol.isEmpty()) {
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				if(element.kind == K_ANY) {
>, <Line: +					return true;
>, <Line: +				} else if(element.kind == K_VOID) {
>, <Line: +					return ol.isEmpty();
>, <Line: +				} else {
>, <Line: +					for(Object elem : ol) {
>, <Line: +						if(!element.instanceOf(elem)) {
>, <Line: +							return false;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					return true;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object obj) {
>, <Line: +			if(obj instanceof WyRecord) {
>, <Line: +				WyRecord ol = (WyRecord) obj;
>, <Line: +				if(!isOpen && names.length != ol.size()) {
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				for(int i=0;i!=names.length;++i) {
>, <Line: +					String name = names[i];
>, <Line: +					if(ol.containsKey(name)) {
>, <Line: +						WyType type = types[i];
>, <Line: +						Object val = ol.get(name);
>, <Line: +						if(!type.instanceOf(val)) {
>, <Line: +							return false;
>, <Line: +						}
>, <Line: +					} else {
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object obj) {
>, <Line: +			for(WyType bound : bounds) {
>, <Line: +				if(bound.instanceOf(obj)) {
>, <Line: +					return true;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return !element.instanceOf(o);
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			// FIXME: this is fundamentally broken, since it does not consider
>, <Line: +			// the parameter types of the underlying function. See #552
>, <Line: +			return o instanceof WyLambda;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			// FIXME: this is fundamentally broken, since it does not consider
>, <Line: +			// the parameter types of the underlying function. See #552
>, <Line: +			return o instanceof WyLambda;
>, <Line: +		}
>, <Line: +		@Override
>, <Line: +		public boolean instanceOf(Object o) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +			return new Array(children[0],nonEmpty);
>, <Line: +			Array t = (Array) type;
>, <Line: +				WyType.Array list = (WyType.Array) type;
>, <Line: +			WyType.Array list = (WyType.Array) t;
>]
[<Line: -import static wyil.lang.Type.K_CHAR;
>, <Line: -import static wyil.lang.Type.K_RATIONAL;
>, <Line: -import static wyil.lang.Type.K_STRING;
>, <Line: -import static wyil.lang.Type.K_TUPLE;
>, <Line: -import static wyil.lang.Type.K_SET;
>, <Line: -import static wyil.lang.Type.K_MAP;
>, <Line: -	public static final Char CHAR = new Char();
>, <Line: -	public static final Rational REAL = new Rational();
>, <Line: -	public static final Strung STRING = new Strung();
>, <Line: -	private static final class Void extends WyType { Void() {super(K_VOID);}}
>, <Line: -	private static final class Any extends WyType { Any() {super(K_ANY);}}
>, <Line: -	private static final class Meta extends WyType { Meta() {super(K_META);}}
>, <Line: -	private static final class Null extends WyType { Null() {super(K_NULL);}}
>, <Line: -	private static final class Bool extends WyType { Bool() {super(K_BOOL);}}
>, <Line: -	private static final class Byte extends WyType { Byte() {super(K_BYTE);}}
>, <Line: -	private static final class Char extends WyType { Char() {super(K_CHAR);}}
>, <Line: -	private static final class Integer extends WyType { Integer() {super(K_INT);}}
>, <Line: -	private static final class Rational extends WyType { Rational() {super(K_RATIONAL);}}
>, <Line: -	private static final class Strung extends WyType { Strung() {super(K_STRING);}}
>, <Line: -	}
>, <Line: -	public static final class List extends WyType {
>, <Line: -		public WyType element;
>, <Line: -		public final boolean nonEmpty;
>, <Line: -		public List(WyType element, boolean nonEmpty) {
>, <Line: -			super(K_LIST);
>, <Line: -			this.element = element;
>, <Line: -			this.nonEmpty = nonEmpty;
>, <Line: -	public static final class Set extends WyType {
>, <Line: -		public Set(WyType element, boolean nonEmpty) {
>, <Line: -			super(K_SET);
>, <Line: -	}
>, <Line: -	public static final class Dictionary extends WyType {
>, <Line: -		public WyType key;
>, <Line: -		public WyType value;
>, <Line: -		public Dictionary(WyType key, WyType value) {
>, <Line: -			super(K_MAP);
>, <Line: -			this.key = key;
>, <Line: -			this.value = value;
>, <Line: -	}
>, <Line: -	public static final class Tuple extends WyType {
>, <Line: -		public final WyType[] types;
>, <Line: -		public Tuple(WyType[] types) {
>, <Line: -			super(K_TUPLE);
>, <Line: -			this.types = types;
>, <Line: -		case K_CHAR:
>, <Line: -			return CHAR;
>, <Line: -		case K_RATIONAL:
>, <Line: -			return REAL;
>, <Line: -		case K_STRING:
>, <Line: -			return STRING;
>, <Line: -		case K_TUPLE: {
>, <Line: -			return new Tuple(children);
>, <Line: -		}
>, <Line: -		case K_SET: {
>, <Line: -			boolean nonEmpty = reader.read_bit();
>, <Line: -			return new Set(children[0],nonEmpty);
>, <Line: -		}
>, <Line: -			return new List(children[0],nonEmpty);
>, <Line: -		}
>, <Line: -		case K_MAP: {
>, <Line: -			return new Dictionary(children[0],children[1]);
>, <Line: -		case K_CHAR:
>, <Line: -		case K_RATIONAL:
>, <Line: -		case K_STRING:
>, <Line: -		case K_TUPLE: {
>, <Line: -			Tuple t = (Tuple) type;
>, <Line: -			substitute(t.types,nodes);
>, <Line: -			return;
>, <Line: -		}
>, <Line: -		case K_SET: {
>, <Line: -			Set t = (Set) type;
>, <Line: -			t.element = substitute((Label)t.element,nodes);
>, <Line: -			return;
>, <Line: -		}
>, <Line: -			List t = (List) type;
>, <Line: -		case K_MAP: {
>, <Line: -			Dictionary t = (Dictionary) type;
>, <Line: -			t.key = substitute((Label)t.key,nodes);
>, <Line: -			t.value = substitute((Label)t.value,nodes);
>, <Line: -			return;
>, <Line: -		}
>, <Line: -			case K_RATIONAL:
>, <Line: -			case K_STRING:
>, <Line: -				WyType.List list = (WyType.List) type;
>, <Line: -			case K_SET:
>, <Line: -			{
>, <Line: -				WyType.Set set = (WyType.Set) type;
>, <Line: -				set.element = substitute(set.element,label,root,visited);
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case K_MAP:
>, <Line: -			{
>, <Line: -				WyType.Dictionary dict = (WyType.Dictionary) type;
>, <Line: -				dict.key = substitute(dict.key,label,root,visited);
>, <Line: -				dict.value = substitute(dict.value,label,root,visited);
>, <Line: -				break;
>, <Line: -			}
>, <Line: -		case K_RATIONAL:
>, <Line: -			return "real";
>, <Line: -		case K_STRING:
>, <Line: -			return "string";
>, <Line: -			WyType.List list = (WyType.List) t;
>]