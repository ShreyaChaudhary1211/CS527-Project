[<Line: +package wyil.lang;
>, <Line: +import java.util.ArrayList;
>, <Line: +import java.util.List;
>, <Line: +import wycc.lang.Attribute;
>, <Line: +import wycc.lang.SyntacticElement;
>, <Line: +/**
>, <Line: + * A SyntaxTree representation of the Whiley Intermediate Language (WyIL).
>, <Line: + * Specifically, bytecodes in WyIL are "flat" rather than being nested trees,
>, <Line: + * etc. This makes them easier to work with for performing optimisation, amongst
>, <Line: + * other things. This also means they are close to their byte-level
>, <Line: + * representation on disk. However, the tree-like nature of a typically abstract
>, <Line: + * syntax tree is convenient in many ways, and this class provides a "wrapper"
>, <Line: + * for bytecodes which makes them appear as a tree-like structure.
>, <Line: + * 
>, <Line: + * @author David J. Pearce
>, <Line: + *
>, <Line: + */
>, <Line: +public class SyntaxTree {
>, <Line: +	/**
>, <Line: +	 * The enclosing declaration for this tree
>, <Line: +	 */
>, <Line: +	private final WyilFile.Declaration parent;
>, <Line: +	/**
>, <Line: +	 * The set of locations making up this tree. Each location is some kind of
>, <Line: +	 * component of the tree. For example, an expression or statement.
>, <Line: +	 */
>, <Line: +	private final List<Location<?>> locations; 
>, <Line: +	public SyntaxTree(WyilFile.Declaration enclosingDeclaration) {
>, <Line: +		this.parent = enclosingDeclaration;
>, <Line: +		this.locations = new ArrayList<Location<?>>();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Returns the number of locations in this syntax tree.
>, <Line: +	 * 
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public int size() {
>, <Line: +		return locations.size();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Get the location at a given index in this syntax tree.
>, <Line: +	 * 
>, <Line: +	 * @param index
>, <Line: +	 *            --- index of location to return
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public Location<?> getLocation(int index) {
>, <Line: +		return locations.get(index);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Get the location at a given index in this syntax tree.
>, <Line: +	 * 
>, <Line: +	 * @param index
>, <Line: +	 *            --- index of location to return
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public Location<?>[] getLocations(int... indices) {
>, <Line: +		Location<?>[] locs = new Location<?>[indices.length];
>, <Line: +		for(int i=0;i!=indices.length;++i) {
>, <Line: +			locs[i] = getLocation(indices[i]);
>, <Line: +		}
>, <Line: +		return locs;
>, <Line: +	}
>, <Line: +	public List<Location<?>> getLocations() {
>, <Line: +		return locations;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Get the index of a given location in this tree.
>, <Line: +	 * 
>, <Line: +	 * @param location
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public int getIndexOf(Location<?> location) {
>, <Line: +		return locations.indexOf(location);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Get the enclosing declaration of this syntax tree.
>, <Line: +	 * 
>, <Line: +	 * @return
>, <Line: +	 */
>, <Line: +	public WyilFile.Declaration getEnclosingDeclaration() {
>, <Line: +		return parent;
>, <Line: +	}
>, <Line: +	// ============================================================
>, <Line: +	// Location
>, <Line: +	// ============================================================
>, <Line: +	public static class Location<T extends Bytecode> extends SyntacticElement.Impl {
>, <Line: +		private final SyntaxTree parent;
>, <Line: +		private final Type[] types;
>, <Line: +		private final T bytecode;
>, <Line: +		public Location(SyntaxTree parent, T bytecode, Attribute...attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = new Type[0];
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		public Location(SyntaxTree parent, T bytecode, List<Attribute> attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = new Type[0];
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		public Location(SyntaxTree parent, Type type, T bytecode, Attribute...attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = new Type[] {type};
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		public Location(SyntaxTree parent, Type type, T bytecode, List<Attribute> attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = new Type[] {type};
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		public Location(SyntaxTree parent, Type[] types, T bytecode, Attribute...attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = types;
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		public Location(SyntaxTree parent, Type[] types, T bytecode, List<Attribute> attributes) {
>, <Line: +			super(attributes);
>, <Line: +			this.parent = parent;
>, <Line: +			this.types = types;
>, <Line: +			this.bytecode = bytecode;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the index of this location in the enclosing syntax tree. Every
>, <Line: +		 * location has a unique index.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int getIndex() {
>, <Line: +			return parent.getIndexOf(this);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the enclosing syntax tree of this location.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public SyntaxTree getEnclosingTree() {
>, <Line: +			return parent;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the declared type of this location. This is a convenience method
>, <Line: +		 * since, in most cases, we are working on locations that have exactly
>, <Line: +		 * one type.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Type getType() {
>, <Line: +			if(types.length > 1) {
>, <Line: +				throw new IllegalArgumentException("ambiguous request for type");
>, <Line: +			} else if(types.length == 0) {
>, <Line: +				throw new IllegalArgumentException("no types available for access");
>, <Line: +			} else {
>, <Line: +				return types[0];
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get a specific type of this location. 
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Type getType(int i) {
>, <Line: +			return types[i];
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the types for this location. 
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Type[] getTypes() {
>, <Line: +			return types;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the number of types declared by this location.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int numberOfTypes() {
>, <Line: +			return types.length;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the bytecode associated with this location
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public T getBytecode() {
>, <Line: +			return bytecode;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the underlying opcode for this location
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int getOpcode() {
>, <Line: +			return bytecode.getOpcode();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the number of operand groups in this location.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int numberOfOperands() {
>, <Line: +			return bytecode.numberOfOperands();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Return the ith operand associated with this location.
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Location<?> getOperand(int i) {
>, <Line: +			return parent.getLocation(bytecode.getOperand(i));
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Return the ith operand associated with this location.
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Location<?>[] getOperands() {
>, <Line: +			return parent.getLocations(bytecode.getOperands());
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the number of operand groups in this location.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int numberOfOperandGroups() {
>, <Line: +			return bytecode.numberOfOperandGroups();
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the ith operand group in this location.
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Location<?>[] getOperandGroup(int i) {
>, <Line: +			int[] group = bytecode.getOperandGroup(i);
>, <Line: +			return parent.getLocations(group);
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the number of blocks contained in this statement. This includes
>, <Line: +		 * only those which are immediate children of this statement, but not
>, <Line: +		 * those which are transitively contained.
>, <Line: +		 * 
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public int numberOfBlocks() {
>, <Line: +			if(bytecode instanceof Bytecode.Stmt) {
>, <Line: +				Bytecode.Stmt stmt = (Bytecode.Stmt) bytecode;
>, <Line: +				return stmt.numberOfBlocks();
>, <Line: +			} else {
>, <Line: +				return 0;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * Get the ith block contained in this statement.
>, <Line: +		 * 
>, <Line: +		 * @param i
>, <Line: +		 * @return
>, <Line: +		 */
>, <Line: +		public Location<Bytecode.Block> getBlock(int i) {
>, <Line: +			Bytecode.Stmt stmt = (Bytecode.Stmt) bytecode;
>, <Line: +			return (Location<Bytecode.Block>) parent.getLocation(stmt.getBlock(i));			
>, <Line: +		}
>, <Line: +		public String toString() {
>, <Line: +			int index = getIndex();
>, <Line: +			String ts = "";
>, <Line: +			for(int i=0;i!=types.length;++i) {
>, <Line: +				if(i!=0) {
>, <Line: +					ts += ",";
>, <Line: +				}
>, <Line: +				ts += types[i];
>, <Line: +			}
>, <Line: +			return index + ":" + ts + ":" + bytecode;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Some helpful context to make reading the code using syntax trees simpler.
>, <Line: +	 */
>, <Line: +	public static final int CONDITION = 0;
>, <Line: +	public static final int BODY = 0;
>, <Line: +	public static final int VARIABLE = 0;
>, <Line: +	public static final int TRUEBRANCH = 0;
>, <Line: +	public static final int PARAMETERS = 0;
>, <Line: +	public static final int ARGUMENTS = 0;
>, <Line: +	public static final int LEFTHANDSIDE = 0;
>, <Line: +	//
>, <Line: +	public static final int START = 1;
>, <Line: +	public static final int FALSEBRANCH = 1;
>, <Line: +	public static final int RIGHTHANDSIDE = 1;
>, <Line: +	public static final int ENVIRONMENT = 0;
>, <Line: +	//
>, <Line: +	public static final int END = 2;
>, <Line: +}
>]
[]