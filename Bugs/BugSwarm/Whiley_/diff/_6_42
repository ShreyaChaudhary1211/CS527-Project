[<Line: +import wyil.lang.SyntaxTree.Location;
>, <Line: +		// FIXME: check type invariants
>, <Line: +		// FIXME: check pre/postconditions
>, <Line: +		checkFunctionPure(0,new HashSet<Integer>(),c.getTree());
>, <Line: +	protected void checkFunctionPure(int blockID, HashSet<Integer> visited, SyntaxTree enclosing) {
>, <Line: +		visited.add(blockID);
>, <Line: +		Location<Bytecode.Block> block = (Location<Bytecode.Block>) enclosing.getLocation(blockID);
>, <Line: +		for (int i = 0; i != block.numberOfOperands(); ++i) {
>, <Line: +			Location<?> e = block.getOperand(i);
>, <Line: +			Bytecode code = e.getBytecode();
>, <Line: +			if (code instanceof Bytecode.Invoke && ((Bytecode.Invoke) code).type() instanceof Type.Method) {
>, <Line: +				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, e.attributes());
>, <Line: +			} else if (code instanceof Bytecode.IndirectInvoke
>, <Line: +					&& ((Bytecode.IndirectInvoke) code).type() instanceof Type.Method) {
>, <Line: +				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, e.attributes());
>, <Line: +			} else if (code.getOpcode() == Bytecode.OPCODE_newobject) {
>, <Line: +				syntaxError(errorMessage(ALLOCATION_NOT_PERMITTED_IN_FUNCTION), filename, e.attributes());
>, <Line: +			} else if (code.getOpcode() == Bytecode.OPCODE_dereference) {
>, <Line: +				syntaxError(errorMessage(REFERENCE_ACCESS_NOT_PERMITTED_IN_FUNCTION), filename, e.attributes());
>, <Line: +			} else if (code instanceof Bytecode.Stmt) {
>, <Line: +				Bytecode.Stmt a = (Bytecode.Stmt) code;
>, <Line: +				for (int j = 0; j != a.numberOfBlocks(); ++j) {
>, <Line: +					int subblock = a.getBlock(j);
>, <Line: +					// The visited check is necessary to handle break and
>, <Line: +					// continue bytecodes. These contain the block identifier of
>, <Line: +					// their enclosing loop and, hence, following this would
>, <Line: +					// lead to an infinite loop.
>, <Line: +					if (!visited.contains(subblock)) {
>, <Line: +						checkFunctionPure(subblock, visited, enclosing);
>, <Line: +					}
>, <Line: +				}
>]
[<Line: -import wyil.attributes.SourceLocation;
>, <Line: -import wyil.lang.BytecodeForest.Index;
>, <Line: -	private static class Handler {
>, <Line: -		public final ArrayList<Type> handlers;
>, <Line: -		public final HashSet<Type> active;
>, <Line: -		public final Handler parent;
>, <Line: -		public Handler(java.util.List<Pair<Type, String>> handlers, Handler parent) {
>, <Line: -			this.handlers = new ArrayList<Type>();
>, <Line: -			for(Pair<Type,String> handler : handlers) {
>, <Line: -				this.handlers.add(handler.first());
>, <Line: -			}
>, <Line: -			this.parent = parent;
>, <Line: -			this.active = new HashSet<Type>();
>, <Line: -		}
>, <Line: -		public Handler(Type throwsClause) {
>, <Line: -			this.handlers = new ArrayList<Type>();
>, <Line: -			this.handlers.add(throwsClause);
>, <Line: -			this.parent = null;
>, <Line: -			this.active = new HashSet<Type>();
>, <Line: -		}
>, <Line: -		public boolean catchException(Type type) {
>, <Line: -			for (Type t : handlers) {
>, <Line: -				if (Type.isSubtype(t, type)) {
>, <Line: -					active.add(t);
>, <Line: -					return true;
>, <Line: -				} else if (Type.isSubtype(type, t)) {
>, <Line: -					active.add(t);
>, <Line: -					// this exception may escape
>, <Line: -					type = Type.intersect(type, Type.Negation(t));
>, <Line: -				}
>, <Line: -			}
>, <Line: -			if (parent != null) {
>, <Line: -				return parent.catchException(type);
>, <Line: -			} else {
>, <Line: -				return false;
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -		checkFunctionPure(c.body(),c.code());
>, <Line: -	protected void checkFunctionPure(int blockID, BytecodeForest forest) {
>, <Line: -		BytecodeForest.Block block = forest.get(blockID);
>, <Line: -		for (int i = 0; i != block.size(); ++i) {
>, <Line: -			BytecodeForest.Entry e = block.get(i);
>, <Line: -			Bytecode code = e.first();			
>, <Line: -			if(code instanceof Bytecode.Invoke && ((Bytecode.Invoke)code).type(0) instanceof Type.Method) {
>, <Line: -				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, e.attribute(SourceLocation.class));
>, <Line: -			} else if (code instanceof Bytecode.IndirectInvoke && ((Bytecode.IndirectInvoke)code).type(0) instanceof Type.Method) {
>, <Line: -				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, e.attribute(SourceLocation.class));
>, <Line: -			} else if (code.opcode() == Bytecode.OPCODE_newobject) {
>, <Line: -				syntaxError(errorMessage(ALLOCATION_NOT_PERMITTED_IN_FUNCTION), filename, e.attribute(SourceLocation.class));
>, <Line: -			} else if (code.opcode() == Bytecode.OPCODE_dereference) {
>, <Line: -				syntaxError(errorMessage(REFERENCE_ACCESS_NOT_PERMITTED_IN_FUNCTION), filename,
>, <Line: -						e.attribute(SourceLocation.class));
>, <Line: -			} else if (code instanceof Bytecode.Compound) {
>, <Line: -				Bytecode.Compound a = (Bytecode.Compound) code;
>, <Line: -				checkFunctionPure(a.block(), forest);
>]