[<Line: +			return Codes.Quantify(l.startOperand, l.endOperand, l.indexOperand,
>, <Line: +		// Special case which doesn't have a type.
>, <Line: +		} else if(opcode == Code.OPCODE_quantify) {
>, <Line: +			int count = readRest(wideRest);
>, <Line: +			int indexOperand = operands[0];
>, <Line: +			int startOperand = operands[1];
>, <Line: +			int endOperand = operands[2];
>, <Line: +			operands = Arrays.copyOfRange(operands, 3, operands.length);
>, <Line: +			ArrayList<Code> bytecodes = readCodeBlock(offset + 1, count, labels);			
>, <Line: +			return Codes.Quantify(startOperand, endOperand, indexOperand,
>, <Line: +					operands, bytecodes);
>]
[<Line: -			return Codes.Quantify(l.type, l.sourceOperand, l.indexOperand,
>, <Line: -		case Code.OPCODE_range:
>, <Line: -			// Special case which doesn't have a type.
>, <Line: -		case Code.OPCODE_quantify:
>, <Line: -		case Code.OPCODE_forall: {
>, <Line: -			if (!(type instanceof Type.EffectiveList)) {
>, <Line: -				throw new RuntimeException("expected collection type");
>, <Line: -			}
>, <Line: -			int count = readRest(wideRest);
>, <Line: -			int indexOperand = operands[0];
>, <Line: -			int sourceOperand = operands[1];
>, <Line: -			operands = Arrays.copyOfRange(operands, 2, operands.length);
>, <Line: -			ArrayList<Code> bytecodes = readCodeBlock(offset + 1, count, labels);			
>, <Line: -			return Codes.Quantify((Type.EffectiveList) type,
>, <Line: -					sourceOperand, indexOperand, operands, bytecodes);
>, <Line: -		}
>]