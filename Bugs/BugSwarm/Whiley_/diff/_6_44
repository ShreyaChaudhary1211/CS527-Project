[<Line: +import wycc.lang.Attribute;
>, <Line: +import wyil.lang.Bytecode.Expr;
>, <Line: +import wyil.lang.SyntaxTree.Location;
>, <Line: +import wyil.util.AbstractBytecode;
>, <Line: +				constant = new Constant.FunctionOrMethod(name, t);
>, <Line: +				break;
>, <Line: +			}
>, <Line: +			case WyilFileWriter.CONSTANT_Type: {
>, <Line: +				int typeIndex = input.read_uv();
>, <Line: +				constant = new Constant.Type(typePool[typeIndex]);
>, <Line: +		WyilFile wyilFile = new WyilFile(pathPool[pathIdx], "unknown.whiley");
>, <Line: +			readModuleBlock(wyilFile);
>, <Line: +		return wyilFile;
>, <Line: +	private void readModuleBlock(WyilFile parent) throws IOException {
>, <Line: +			readConstantBlock(parent);
>, <Line: +			readTypeBlock(parent);
>, <Line: +			readFunctionOrMethodBlock(parent);
>, <Line: +	private void readConstantBlock(WyilFile parent) throws IOException {
>, <Line: +		WyilFile.Block block = new WyilFile.Constant(parent, generateModifiers(modifiers), stringPool[nameIdx],
>, <Line: +				constantPool[constantIdx]);
>, <Line: +		parent.blocks().add(block);
>, <Line: +	 * | uv : nInvariants       |
>, <Line: +	 * | uv[nInvariants]        |
>, <Line: +	 * | SyntaxTree             |
>, <Line: +	 * +------------------------+
>, <Line: +	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: +	private void readTypeBlock(WyilFile parent) throws IOException {
>, <Line: +		int nInvariants = input.read_uv();
>, <Line: +		//
>, <Line: +		Collection<Modifier> mods = generateModifiers(modifiers);
>, <Line: +		String name = stringPool[nameIdx];
>, <Line: +		Type type = typePool[typeIdx];
>, <Line: +		//
>, <Line: +		int[] invariant = new int[nInvariants];		
>, <Line: +		for (int i = 0; i != nInvariants; ++i) {
>, <Line: +			invariant[i] = input.read_uv();
>, <Line: +		}
>, <Line: +		WyilFile.Type decl = new WyilFile.Type(parent, mods, name, type);
>, <Line: +		SyntaxTree tree = readSyntaxTree(decl);
>, <Line: +		//
>, <Line: +		for (int i = 0; i != nInvariants;++i) {
>, <Line: +			Location<Bytecode.Expr> expr = (Location<Expr>) tree.getLocation(invariant[i]);
>, <Line: +			decl.getInvariant().add(expr);
>, <Line: +		}
>, <Line: +		parent.blocks().add(decl);
>, <Line: +	 * | uv : nPreconditions    |
>, <Line: +	 * | uv : nPostconditions   |
>, <Line: +	 * | uv[nPreconditions]     |
>, <Line: +	 * | uv[nPostconditions]    |
>, <Line: +	 * | uv : body              |
>, <Line: +	 * +------------------------+
>, <Line: +	 * | SyntaTree              |
>, <Line: +	 * +------------------------+
>, <Line: +	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: +	 * type itself. 
>, <Line: +	private void readFunctionOrMethodBlock(WyilFile parent) throws IOException {
>, <Line: +		int nPreconditions = input.read_uv();
>, <Line: +		int nPostconditions = input.read_uv();
>, <Line: +		//
>, <Line: +		Collection<Modifier> mods = generateModifiers(modifiers);
>, <Line: +		String name = stringPool[nameIdx];
>, <Line: +		//
>, <Line: +		WyilFile.FunctionOrMethod decl = new WyilFile.FunctionOrMethod(parent, mods, name, type);
>, <Line: +		int[] precondition = new int[nPreconditions];
>, <Line: +		for (int i = 0; i != nPreconditions; ++i) {
>, <Line: +			precondition[i] = input.read_uv();
>, <Line: +		}
>, <Line: +		int[] postcondition = new int[nPostconditions];
>, <Line: +		for (int i = 0; i != nPostconditions; ++i) {
>, <Line: +			postcondition[i] = input.read_uv();
>, <Line: +		}
>, <Line: +		//
>, <Line: +		int body = input.read_uv();
>, <Line: +		//
>, <Line: +		readSyntaxTree(decl);
>, <Line: +		SyntaxTree tree = decl.getTree();
>, <Line: +		//
>, <Line: +		for (int i = 0; i != nPreconditions; ++i) {
>, <Line: +			Location<Bytecode.Expr> expr = (Location<Expr>) tree.getLocation(precondition[i]);
>, <Line: +			decl.getPrecondition().add(expr);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		for (int i = 0; i != nPostconditions; ++i) {
>, <Line: +			Location<Bytecode.Expr> expr = (Location<Expr>) tree.getLocation(postcondition[i]);
>, <Line: +			decl.getPostcondition().add(expr);
>, <Line: +		}
>, <Line: +		//
>, <Line: +		Location<Bytecode.Block> loc = (Location<Bytecode.Block>) tree.getLocation(body);
>, <Line: +		decl.setBody(loc);
>, <Line: +		//
>, <Line: +		parent.blocks().add(decl);
>, <Line: +	 * Read a syntax tree from the output stream. The format
>, <Line: +	 * of a syntax tree is one of the following:
>, <Line: +	 * +-------------------+
>, <Line: +	 * | uv : nLocs        |
>, <Line: +	 * +-------------------+ 
>, <Line: +	 * | Locations[nLocs]  |
>, <Line: +	 * +-------------------+
>, <Line: +	 * @param parent
>, <Line: +	 * @return
>, <Line: +	private SyntaxTree readSyntaxTree(WyilFile.Declaration parent) throws IOException {
>, <Line: +		SyntaxTree tree = parent.getTree();
>, <Line: +		int nLocs = input.read_uv();
>, <Line: +		for(int i=0;i!=nLocs;++i) {
>, <Line: +			tree.getLocations().add(readLocation(tree));
>, <Line: +		return tree;
>, <Line: +	 * Read details of a Location from the input stream. The format of a
>, <Line: +	 * location is:
>, <Line: +	 * | uv : nTypes       |
>, <Line: +	 * +-------------------+
>, <Line: +	 * | uv[] : typeIdxs   |
>, <Line: +	 * +-------------------+
>, <Line: +	 * | Bytecode          |
>, <Line: +	private SyntaxTree.Location<?> readLocation(SyntaxTree tree) throws IOException {
>, <Line: +		int nTypes = input.read_uv();
>, <Line: +		Type[] types = new Type[nTypes];
>, <Line: +		for (int i = 0; i != types.length; ++i) {
>, <Line: +			int typeIdx = input.read_uv();
>, <Line: +			types[i] = typePool[typeIdx];
>, <Line: +		int nAttrs = input.read_uv();
>, <Line: +		Bytecode bytecode = readBytecode();
>, <Line: +		//
>, <Line: +		List<Attribute> attributes = new ArrayList<Attribute>();
>, <Line: +		//
>, <Line: +		return new SyntaxTree.Location<Bytecode>(tree, types, bytecode, attributes);
>, <Line: +	 * REad a given bytecode whose format is currently given as follows:
>, <Line: +	 * | u8 : opcode       |
>, <Line: +	 *        ...
>, <Line: +	 * <b>NOTE:</b> The intention is to support a range of different bytecode
>, <Line: +	 * formats in order to optimise the common cases. For example, when there
>, <Line: +	 * are no targets, no operands, no types, etc. Furthermore, when the size of
>, <Line: +	 * items can be reduced from uv to u4, etc.
>, <Line: +	private Bytecode readBytecode() throws IOException {
>, <Line: +		int opcode = input.read_u8();
>, <Line: +		// FIXME: read attributes!
>, <Line: +		Bytecode.Schema schema = AbstractBytecode.schemas[opcode];
>, <Line: +		// First, read and validate all operands, groups and blocks
>, <Line: +		int[] operands = readOperands(schema);
>, <Line: +		int[][] groups = readOperandGroups(schema);
>, <Line: +		int[] blocks = readBlocks(schema);
>, <Line: +		// Second, read all extras		
>, <Line: +		Object[] extras = readExtras(schema);		
>, <Line: +		// Finally, create the bytecode
>, <Line: +		return schema.construct(opcode,operands,groups,blocks,extras);		
>, <Line: +	}
>, <Line: +	private int[] readOperands(Bytecode.Schema schema) throws IOException {		
>, <Line: +		switch(schema.getOperands()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			return null;
>, <Line: +		case ONE:
>, <Line: +			int o = input.read_uv();
>, <Line: +			return new int[] { o }; 
>, <Line: +		case TWO:
>, <Line: +			int o1 = input.read_uv();
>, <Line: +			int o2 = input.read_uv();
>, <Line: +			return new int[] { o1, o2 };
>, <Line: +		case MANY:
>, <Line: +		default:
>, <Line: +			return readUnboundArray();
>, <Line: +	private int[][] readOperandGroups(Bytecode.Schema schema) throws IOException {
>, <Line: +		switch(schema.getOperandGroups()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			return null;
>, <Line: +		case ONE:
>, <Line: +			int[] o = readUnboundArray();
>, <Line: +			return new int[][] { o }; 
>, <Line: +		case TWO:
>, <Line: +			int[] o1 = readUnboundArray();
>, <Line: +			int[] o2 = readUnboundArray();
>, <Line: +			return new int[][] { o1, o2 };
>, <Line: +		case MANY:
>, <Line: +		default:
>, <Line: +			int size = input.read_uv();
>, <Line: +			int[][] os = new int[size][];
>, <Line: +			for(int i=0;i!=size;++i) {
>, <Line: +				os[i] = readUnboundArray();
>, <Line: +			}
>, <Line: +			return os;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private int[] readBlocks(Bytecode.Schema schema) throws IOException {
>, <Line: +		switch(schema.getBlocks()) {
>, <Line: +		case ZERO:
>, <Line: +			// do nout
>, <Line: +			return null;
>, <Line: +		case ONE:
>, <Line: +			int o = input.read_uv();
>, <Line: +			return new int[] { o }; 
>, <Line: +		case TWO:
>, <Line: +			int o1 = input.read_uv();
>, <Line: +			int o2 = input.read_uv();
>, <Line: +			return new int[] { o1, o2 };
>, <Line: +		case MANY:
>, <Line: +		default:
>, <Line: +			return readUnboundArray();
>, <Line: +		}
>, <Line: +	private Object[] readExtras(Bytecode.Schema schema)
>, <Line: +		Bytecode.Extras[] extras = schema.extras();
>, <Line: +			case TYPE: {
>, <Line: +				int typeIdx = input.read_uv();
>, <Line: +				results[i] = typePool[typeIdx];
>, <Line: +				// This is basically a special case just for the switch
>, <Line: +				// statement.
>, <Line: +				Bytecode.Case[] pairs = new Bytecode.Case[nPairs];
>, <Line: +					int block = input.read_uv();
>, <Line: +					int nConstants = input.read_uv();
>, <Line: +					Constant[] constants = new Constant[nConstants];
>, <Line: +					for(int k=0;k!=nConstants;++k) {
>, <Line: +						int constIdx = input.read_uv();
>, <Line: +						constants[k] = constantPool[constIdx];
>, <Line: +					}					
>, <Line: +					pairs[j] = new Bytecode.Case(block,constants);
>, <Line: +	private int[] readUnboundArray() throws IOException {
>, <Line: +		int size = input.read_uv();
>, <Line: +		int[] array = new int[size];
>, <Line: +		for(int i=0;i!=size;++i) {
>, <Line: +			array[i] = input.read_uv();
>, <Line: +		}
>, <Line: +		return array;
>, <Line: +	}
>]
[<Line: -import java.math.BigDecimal;
>, <Line: -import wycc.util.Pair;
>, <Line: -import wycc.util.Triple;
>, <Line: -import wyil.lang.Bytecode.Schema;
>, <Line: -import wyil.lang.Bytecode.Extras;
>, <Line: -import wyil.lang.Bytecode.Operands;
>, <Line: -import wyil.lang.Bytecode.Targets;
>, <Line: -import wyil.lang.Bytecode.Types;
>, <Line: -				constant = new Constant.Lambda(name, t);
>, <Line: -		List<WyilFile.Block> declarations = new ArrayList<WyilFile.Block>();
>, <Line: -			declarations.add(readModuleBlock());
>, <Line: -		return new WyilFile(pathPool[pathIdx], "unknown.whiley", declarations);
>, <Line: -	private WyilFile.Block readModuleBlock() throws IOException {
>, <Line: -		WyilFile.Block block;
>, <Line: -			block = readConstantBlock();
>, <Line: -			block = readTypeBlock();
>, <Line: -			block = readFunctionOrMethodBlock();
>, <Line: -		return block;
>, <Line: -	private WyilFile.Constant readConstantBlock() throws IOException {
>, <Line: -		return new WyilFile.Constant(generateModifiers(modifiers), stringPool[nameIdx], constantPool[constantIdx]);
>, <Line: -	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: -	 * | CodeForest : invariant |
>, <Line: -	 * Finally, <code>invariant</code> gives the type's invariant as zero or
>, <Line: -	 * more bytecode blocks.
>, <Line: -	private WyilFile.Type readTypeBlock() throws IOException {
>, <Line: -		BytecodeForest forest = readCodeForestBlock();
>, <Line: -		return new WyilFile.Type(generateModifiers(modifiers), stringPool[nameIdx], typePool[typeIdx], forest);
>, <Line: -	 * | uv : nRequires         |
>, <Line: -	 * | uv : nEnsures          |
>, <Line: -	 * ~~~~~~~~~~ u8 ~~~~~~~~~~~~
>, <Line: -	 * | CodeForest : code      |
>, <Line: -	 * type itself. Finally, <code>code</code> provides all code associated with
>, <Line: -	 * the function or method which includes any preconditions, postconditions
>, <Line: -	 * and the body itself. Here, <code>nRequires</code> identifiers the number
>, <Line: -	 * of roots which correspond to the precondition, whilst
>, <Line: -	 * <code>nEnsures</code> the number of roots corresponding to the
>, <Line: -	 * postcondition. Any root after this comprise the body.
>, <Line: -	private WyilFile.FunctionOrMethod readFunctionOrMethodBlock() throws IOException {
>, <Line: -		int nRequires = input.read_uv();
>, <Line: -		int nEnsures = input.read_uv();
>, <Line: -		input.pad_u8();
>, <Line: -		BytecodeForest forest = readCodeForestBlock();
>, <Line: -		return new WyilFile.FunctionOrMethod(generateModifiers(modifiers), stringPool[nameIdx], type, forest,
>, <Line: -				nRequires, nEnsures);
>, <Line: -	 * <p>
>, <Line: -	 * Read a code forest from the input stream. The format is:
>, <Line: -	 * </p>
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nRegs          |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nBlocks        |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nRoots         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv: nAttrs         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | Register[nRegs]    |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | uv[nRoots]         |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | CodeBlock[nBlocks] |
>, <Line: -	 * +--------------------+
>, <Line: -	 * | Attribute[nAttrs]  |
>, <Line: -	 * +--------------------+
>, <Line: -	 * <p>
>, <Line: -	 * Each bytecode has a given offset which is calculated from the start of
>, <Line: -	 * all blocks. For example, assume block 1 has ten actual bytecodes (i.e.
>, <Line: -	 * which are not labels); then, a bytecode at index 2 in block 2 has offset
>, <Line: -	 * 12.
>, <Line: -	 * </p>
>, <Line: -	 * @param forest
>, <Line: -	 *            The forest being written to the stream
>, <Line: -	 * @param labels
>, <Line: -	 *            The set of pre-calculated label offsets
>, <Line: -	 * @param output
>, <Line: -	private BytecodeForest readCodeForestBlock() throws IOException {
>, <Line: -		input.pad_u8();
>, <Line: -		int kind = input.read_uv(); // unused
>, <Line: -		int size = input.read_uv(); // unused
>, <Line: -		input.pad_u8();
>, <Line: -		int nRegs = input.read_uv();
>, <Line: -		int nBlocks = input.read_uv();
>, <Line: -		int nRoots = input.read_uv();
>, <Line: -		int nAttrs = input.read_uv();
>, <Line: -		BytecodeForest forest = new BytecodeForest();
>, <Line: -		for(int i=0;i!=nRegs;++i) {
>, <Line: -			BytecodeForest.Register register = readCodeRegister();
>, <Line: -			forest.registers().add(register);
>, <Line: -		for(int i=0;i!=nRoots;++i) {
>, <Line: -			int root = input.read_uv();
>, <Line: -			forest.addRoot(root);
>, <Line: -		}
>, <Line: -		HashMap<Integer, Bytecode.Label> labels = new HashMap<Integer, Bytecode.Label>();
>, <Line: -		int offset = 0;
>, <Line: -		for(int i=0;i!=nBlocks;++i) {
>, <Line: -			BytecodeForest.Block block = readCodeBlock(offset,labels);
>, <Line: -			forest.add(block);
>, <Line: -			offset += block.size();
>, <Line: -		}
>, <Line: -		insertLabels(forest, labels);
>, <Line: -		return forest;
>, <Line: -	 * Read a given code register from the input stream. The format
>, <Line: -	 * of reach register entry is:
>, <Line: -	 * | uv : typeIdx      |
>, <Line: -	 * @param register
>, <Line: -	 *            Register to be written out
>, <Line: -	private BytecodeForest.Register readCodeRegister() throws IOException {
>, <Line: -		int nAttrs = input.read_uv();
>, <Line: -		int typeIdx = input.read_uv();
>, <Line: -		// TODO: read any attributes given
>, <Line: -		return new BytecodeForest.Register(typePool[typeIdx], "unknown");
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * This function is responsible for inserting labels into the correct
>, <Line: -	 * positions within all blocks contained in a forest. Every label is given
>, <Line: -	 * an offset within the flat bytecode array, as stored on disk. The
>, <Line: -	 * challenge here is that, having loaded it from disk, the bytecode array is
>, <Line: -	 * nested rather than flat. This is because certain bytecodes contain blocks
>, <Line: -	 * of nested bytecodes (e.g. loop bytecode). Therefore, we need to track the
>, <Line: -	 * offset within the flat bytecode array against that of the now nested
>, <Line: -	 * bytecode structure.
>, <Line: -	 *
>, <Line: -	 * @param offset
>, <Line: -	 *            The current offset within the flat bytecode array.
>, <Line: -	 * @param bytecodes
>, <Line: -	 *            The list of bytecodes we are inserting into.
>, <Line: -	 * @param labels
>, <Line: -	 *            The map of offsets to labels being inserted.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	private int insertLabels(BytecodeForest forest, HashMap<Integer, Bytecode.Label> labels) {
>, <Line: -		int offset = 0;
>, <Line: -		for (int i = 0; i != forest.numBlocks(); ++i) {
>, <Line: -			BytecodeForest.Block block = forest.get(i);
>, <Line: -			for (int j = 0; j != block.size(); ++j) {
>, <Line: -				// First, check whether there is a label to insert
>, <Line: -				Bytecode.Label label = labels.get(offset++);
>, <Line: -				if (label != null) {
>, <Line: -					block.add(++j, label);
>, <Line: -				}
>, <Line: -			}
>, <Line: -		// Done
>, <Line: -		return offset;
>, <Line: -	 * Read a block of bytecodes whilst adding newly discovered labels to a
>, <Line: -	 * given set of label offsets. The format is:
>, <Line: -	 * | uv : nCodes       |
>, <Line: -	 * | Bytecode[nCodes]  |
>, <Line: -	 * +-------------------+
>, <Line: -	 * The block is associated with a given offset value, which indicates the
>, <Line: -	 * offset of the first bytecode in the block to be used when calculating
>, <Line: -	 * branch offsets.
>, <Line: -	 * 
>, <Line: -	 * @param offset
>, <Line: -	 * @param labels
>, <Line: -	 * @return
>, <Line: -	 * @throws IOException
>, <Line: -	public BytecodeForest.Block readCodeBlock(int offset, HashMap<Integer, Bytecode.Label> labels)
>, <Line: -			throws IOException {
>, <Line: -		int nCodes = input.read_uv();
>, <Line: -		ArrayList<BytecodeForest.Entry> bytecodes = new ArrayList<BytecodeForest.Entry>();
>, <Line: -		for (int i = 0; i < nCodes; ++i) {
>, <Line: -			Bytecode code = readBytecode(i + offset, labels);
>, <Line: -			bytecodes.add(new BytecodeForest.Entry(code));
>, <Line: -		// TODO: read any attributes given
>, <Line: -		return new BytecodeForest.Block(bytecodes);
>, <Line: -	private Bytecode readBytecode(int offset, HashMap<Integer, Bytecode.Label> labels) throws IOException {
>, <Line: -		int opcode = input.read_u8();
>, <Line: -		Bytecode.Schema schema = schemas[opcode];
>, <Line: -		// First, read and validate all targets, operands and types
>, <Line: -		int nTargets = input.read_uv();
>, <Line: -		int nOperands = input.read_uv();
>, <Line: -		int nTypes = input.read_uv();
>, <Line: -		int nAttts = input.read_uv();
>, <Line: -		int[] targets = readRegisters(nTargets);
>, <Line: -		int[] operands = readRegisters(nOperands);
>, <Line: -		Type[] types = readTypes(nTypes);
>, <Line: -		// Second, read all extras		
>, <Line: -		Object[] extras = readExtras(schema,labels);
>, <Line: -		// Finally, create the bytecode
>, <Line: -		return schema.construct(opcode,targets,operands,types,extras);		
>, <Line: -	private Object[] readExtras(Bytecode.Schema schema, HashMap<Integer, Bytecode.Label> labels)
>, <Line: -		Extras[] extras = schema.extras();
>, <Line: -			case BLOCK: {
>, <Line: -				int blockID = input.read_uv();
>, <Line: -				results[i] = blockID;
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case TARGET: {
>, <Line: -				int target = input.read_uv();
>, <Line: -				Bytecode.Label l = findLabel(target, labels);
>, <Line: -				results[i] = l.label();
>, <Line: -				Pair<Constant,String>[] pairs = new Pair[nPairs];
>, <Line: -					int constIdx = input.read_uv();
>, <Line: -					int target = input.read_uv();
>, <Line: -					String label = findLabel(target,labels).label();
>, <Line: -					pairs[j] = new Pair<Constant,String>(constantPool[constIdx],label);
>, <Line: -	private static int labelCount = 0;
>, <Line: -	private static Bytecode.Label findLabel(int target, HashMap<Integer, Bytecode.Label> labels) {
>, <Line: -		Bytecode.Label label = labels.get(target);
>, <Line: -		if (label == null) {
>, <Line: -			label = new Bytecode.Label("label" + labelCount++);
>, <Line: -			labels.put(target, label);
>, <Line: -		}
>, <Line: -		return label;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * ==================================================================
>, <Line: -	 * Individual Bytecode Schemas
>, <Line: -	 * ==================================================================
>, <Line: -	 */
>, <Line: -	private static final Schema[] schemas = new Schema[255];
>, <Line: -	static {
>, <Line: -		//		
>, <Line: -		schemas[Bytecode.OPCODE_goto] = new Schema(Targets.ZERO, Operands.ZERO, Types.ZERO, Extras.TARGET){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Goto((String) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_fail] = new Schema(Targets.ZERO, Operands.ZERO, Types.ZERO){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Fail();
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_assert] = new Schema(Targets.ZERO, Operands.ZERO, Types.ZERO, Extras.BLOCK){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Assert((Integer) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_assume] = new Schema(Targets.ZERO, Operands.ZERO, Types.ZERO, Extras.BLOCK){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Assume((Integer) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_invariant] = new Schema(Targets.ZERO, Operands.ZERO, Types.ZERO, Extras.BLOCK){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Invariant((Integer) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		// =========================================================================
>, <Line: -		// Unary Operators.
>, <Line: -		// =========================================================================
>, <Line: -		schemas[Bytecode.OPCODE_debug] = new Schema(Targets.ZERO, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Debug(operands[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_return] = new Schema(Targets.ZERO, Operands.MANY, Types.MANY){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Return(types,operands);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_switch] = new Schema(Targets.ZERO, Operands.ONE, Types.ONE, Extras.TARGET, Extras.SWITCH_ARRAY){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				String defaultTarget = (String) extras[0];
>, <Line: -				Pair<Constant,String>[] cases = (Pair<Constant,String>[]) extras[1];
>, <Line: -				return new Bytecode.Switch(types[0], operands[0], defaultTarget, Arrays.asList(cases));
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_ifis] = new Schema(Targets.ZERO, Operands.ONE, Types.TWO, Extras.TARGET){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.IfIs(types[0], operands[0], types[1], (String)extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		// =========================================================================
>, <Line: -		// Unary Assignables
>, <Line: -		// =========================================================================
>, <Line: -		schemas[Bytecode.OPCODE_assign] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.ASSIGN);
>, <Line: -			}
>, <Line: -		};		
>, <Line: -		schemas[Bytecode.OPCODE_newobject] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0],targets,operands,Bytecode.OperatorKind.NEW);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_dereference] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.DEREFERENCE);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_arrayinvert] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.BITWISEINVERT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_arraylength] = new Schema(Targets.ONE, Operands.ONE, Types.ONE) {
>, <Line: -			public Bytecode construct(int opcode, int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.ARRAYLENGTH);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_neg] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.NEG);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_not] = new Schema(Targets.ONE, Operands.ONE, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.NOT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_fieldload] = new Schema(Targets.ONE, Operands.ONE, Types.ONE, Extras.STRING){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.FieldLoad((Type.EffectiveRecord) types[0], targets[0], operands[0], (String) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_convert] = new Schema(Targets.ONE, Operands.ONE, Types.TWO){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Convert(types[0], targets[0], operands[0], types[1]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_const] = new Schema(Targets.ONE, Operands.ZERO, Types.ZERO, Extras.CONSTANT){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Const(targets[0], (Constant) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		// =========================================================================
>, <Line: -		// Binary Operators
>, <Line: -		// =========================================================================
>, <Line: -		schemas[Bytecode.OPCODE_if] = new Schema(Targets.ZERO, Operands.ONE, Types.ONE, Extras.TARGET){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.If(types[0], operands[0], (String) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		// =========================================================================
>, <Line: -		// Binary Assignables
>, <Line: -		// =========================================================================
>, <Line: -		schemas[Bytecode.OPCODE_add] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.ADD);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_sub] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.SUB);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_mul] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.MUL);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_div] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.DIV);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_rem] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.REM);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_eq] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.EQ);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_ne] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.NEQ);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_lt] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.LT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_le] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.LTEQ);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_gt] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.GT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_ge] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.GTEQ);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_bitwiseor] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.BITWISEOR);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_bitwisexor] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.BITWISEXOR);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_bitwiseand] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.BITWISEAND);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_lshr] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.LEFTSHIFT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_rshr] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.RIGHTSHIFT);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_arrayindex] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0],targets,operands,Bytecode.OperatorKind.ARRAYINDEX);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_arrygen] = new Schema(Targets.ONE, Operands.TWO, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands,Bytecode.OperatorKind.ARRAYGENERATOR);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_array] = new Schema(Targets.ONE, Operands.MANY, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.ARRAYCONSTRUCTOR);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		// =========================================================================
>, <Line: -		// Nary Assignables
>, <Line: -		// =========================================================================
>, <Line: -		schemas[Bytecode.OPCODE_record] = new Schema(Targets.ONE, Operands.MANY, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Operator(types[0], targets, operands, Bytecode.OperatorKind.RECORDCONSTRUCTOR);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_invoke] = new Schema(Targets.MANY, Operands.MANY, Types.ONE, Extras.NAME){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Invoke((Type.FunctionOrMethod) types[0], targets, operands, (NameID) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_indirectinvoke] = new Schema(Targets.MANY, Operands.MANY, Types.ONE){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				int src = operands[0];
>, <Line: -				operands = Arrays.copyOfRange(operands,1,operands.length);
>, <Line: -				return new Bytecode.IndirectInvoke((Type.FunctionOrMethod) types[0], targets, src, operands);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_lambda] = new Schema(Targets.MANY, Operands.MANY, Types.ONE, Extras.NAME){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Lambda((Type.FunctionOrMethod) types[0], targets[0], operands, (NameID) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_loop] = new Schema(Targets.MANY, Operands.MANY, Types.ONE, Extras.BLOCK){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Loop(targets, (Integer) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_quantify] = new Schema(Targets.MANY, Operands.MANY, Types.ONE, Extras.BLOCK){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				return new Bytecode.Quantify(operands[0],operands[1],operands[2], targets, (Integer) extras[0]);
>, <Line: -			}
>, <Line: -		};
>, <Line: -		schemas[Bytecode.OPCODE_update] = new Schema(Targets.MANY, Operands.MANY, Types.ONE, Extras.STRING_ARRAY){
>, <Line: -			public Bytecode construct(int opcode,int[] targets, int[] operands, Type[] types, Object[] extras) {
>, <Line: -				ArrayList<String> fields = new ArrayList<String>();
>, <Line: -				String[] strings = (String[]) extras[0];
>, <Line: -				for(int i=0;i!=strings.length;++i) { fields.add(strings[i]); }
>, <Line: -				int operand = operands[operands.length-1];
>, <Line: -				operands = Arrays.copyOf(operands, operands.length-1);
>, <Line: -				return new Bytecode.Update(types[0], targets[0], operands, operand, types[1], fields);
>, <Line: -			}
>, <Line: -		};
>, <Line: -	}
>]