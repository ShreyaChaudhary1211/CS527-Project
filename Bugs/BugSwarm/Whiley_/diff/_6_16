[<Line: +		Token lookahead = tryAndMatch(false, If, Either, Exists, Forall);
>, <Line: +		} else if (lookahead != null && lookahead.kind == Either) {
>, <Line: +			return parseEitherOrStatement(wf, generics, environment, indent);
>, <Line: +	private Expr parseEitherOrStatement(WyalFile wf, HashSet<String> generics,
>, <Line: +				lookahead = tryAndMatch(false, Or);
>, <Line: +		} while (lookahead != null && lookahead.kind == Or);
>, <Line: +			return parseArrayExpression(wf, generics, environment, terminated);
>, <Line: +	private Expr parseArrayExpression(WyalFile wf, HashSet<String> generics,
>, <Line: +		boolean isArray = true;
>, <Line: +				if(!isArray) {
>, <Line: +					// Force failure
>, <Line: +					match(RightSquare);
>, <Line: +				} else  if(tryAndMatch(true,SemiColon) == null) {
>, <Line: +					match(Comma);
>, <Line: +				} else {
>, <Line: +					// This indicates an array
>, <Line: +					isArray = false;
>, <Line: +				}
>, <Line: +		if (isArray) {
>, <Line: +			return new Expr.Nary(Expr.Nary.Op.ARRAY, exprs, sourceAttr(start, index - 1));
>, <Line: +		} else {
>, <Line: +			return new Expr.Binary(Expr.Binary.Op.ARRAYGEN, exprs.get(0), exprs.get(1), sourceAttr(start, index - 1));
>, <Line: +		}
>]
[<Line: -		Token lookahead = tryAndMatch(false, If, Case, Exists, Forall);
>, <Line: -		} else if (lookahead != null && lookahead.kind == Case) {
>, <Line: -			return parseCaseStatement(wf, generics, environment, indent);
>, <Line: -	private Expr parseCaseStatement(WyalFile wf, HashSet<String> generics,
>, <Line: -				lookahead = tryAndMatch(false, Case);
>, <Line: -		} while (lookahead != null && lookahead.kind == Case);
>, <Line: -			return parseListExpression(wf, generics, environment, terminated);
>, <Line: -	private Expr parseListExpression(WyalFile wf, HashSet<String> generics,
>, <Line: -				match(Comma);
>, <Line: -		return new Expr.Nary(Expr.Nary.Op.ARRAY, exprs, sourceAttr(start,
>, <Line: -				index - 1));
>]