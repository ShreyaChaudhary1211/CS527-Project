[]
[<Line: -package wyil.transforms;
>, <Line: -import java.util.Arrays;
>, <Line: -import java.util.BitSet;
>, <Line: -import java.util.HashSet;
>, <Line: -import java.util.List;
>, <Line: -import wybs.lang.Builder;
>, <Line: -import wycc.lang.Transform;
>, <Line: -import wyil.lang.BytecodeForest;
>, <Line: -import wyil.lang.Bytecode;
>, <Line: -import wyil.lang.Type;
>, <Line: -import wyil.lang.WyilFile;
>, <Line: -/**
>, <Line: - * <p>
>, <Line: - * Responsible for determining what the modified variables (a.k.a variants) in a
>, <Line: - * loop are. It is a requirement for correctly formed Wyil bytecodes that any
>, <Line: - * variable which may be assigned within a loop is explicitly declared. This is
>, <Line: - * important, for example, when generating verification conditions during the
>, <Line: - * verification process.
>, <Line: - * </p>
>, <Line: - *
>, <Line: - * <p>
>, <Line: - * For example, consider this Whiley program:
>, <Line: - * </p>
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * int sum(int stride, [int] list):
>, <Line: - *     r = 0
>, <Line: - *     i = 0
>, <Line: - *     while i < |list|:
>, <Line: - *         r = r + list[i]
>, <Line: - *         i = i + stride
>, <Line: - *     return r *
>, <Line: - * </pre>
>, <Line: - * <p>
>, <Line: - * In the above program, the variables <code>r</code> and <code>i</code> are
>, <Line: - * <i>loop variants</i> because they are assigned within the body of the loop.
>, <Line: - * Note, however, that <code>stride</code> is not a loop variant because it
>, <Line: - * remains constant (i.e. invariant) for the duration of the loop.
>, <Line: - * </p>
>, <Line: - *
>, <Line: - * @author David J. Pearce
>, <Line: - *
>, <Line: - */
>, <Line: -public class LoopVariants implements Transform<WyilFile> {
>, <Line: -	private String filename;
>, <Line: -	/**
>, <Line: -	 * Determines whether constant propagation is enabled or not.
>, <Line: -	 */
>, <Line: -	private boolean enabled = getEnable();
>, <Line: -	public LoopVariants(Builder builder) {
>, <Line: -	}
>, <Line: -	public static String describeEnable() {
>, <Line: -		return "Enable/disable loop variant inference";
>, <Line: -	}
>, <Line: -	public static boolean getEnable() {
>, <Line: -		return true; // default value
>, <Line: -	}
>, <Line: -	public void setEnable(boolean flag) {
>, <Line: -		this.enabled = flag;
>, <Line: -	}
>, <Line: -	public void apply(WyilFile module) {
>, <Line: -		if (enabled) {
>, <Line: -			filename = module.filename();
>, <Line: -			for (WyilFile.Type type : module.types()) {
>, <Line: -				infer(type);
>, <Line: -			}
>, <Line: -			for (WyilFile.FunctionOrMethod method : module
>, <Line: -					.functionOrMethods()) {
>, <Line: -				infer(method);
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public void infer(WyilFile.Type type) {
>, <Line: -		BytecodeForest forest = type.invariant();
>, <Line: -		for(int i=0;i!=forest.numRoots();++i) {
>, <Line: -			infer(forest.getRoot(i),forest);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public void infer(WyilFile.FunctionOrMethod method) {		
>, <Line: -		BytecodeForest forest = method.code();
>, <Line: -		for(int i=0;i!=forest.numRoots();++i) {
>, <Line: -			infer(forest.getRoot(i),forest);
>, <Line: -		}		
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Determine the modified variables for a given block of Wyil bytecodes. In
>, <Line: -	 * doing this, infer the modified operands for any loop bytecodes
>, <Line: -	 * encountered.
>, <Line: -	 *
>, <Line: -	 * @param block
>, <Line: -	 * @param method
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected BitSet infer(int blockID, BytecodeForest forest) {
>, <Line: -		BytecodeForest.Block block = forest.get(blockID);
>, <Line: -		BitSet modified = new BitSet(forest.registers().size());
>, <Line: -		int size = block.size();
>, <Line: -		for (int i = 0; i < size; ++i) {
>, <Line: -			BytecodeForest.Entry e = block.get(i);
>, <Line: -			Bytecode code = e.code();
>, <Line: -			for (int target : code.targets()) {
>, <Line: -				modified.set(target);
>, <Line: -			}
>, <Line: -			if (code instanceof Bytecode.Compound) {
>, <Line: -				Bytecode.Compound body = (Bytecode.Compound) code;
>, <Line: -				BitSet loopModified = infer(body.block(), forest);
>, <Line: -				if (code instanceof Bytecode.Quantify) {
>, <Line: -					// Unset the modified status of the index operand, it is
>, <Line: -					// already implied that this is modified.
>, <Line: -					Bytecode.Quantify qc = (Bytecode.Quantify) code;
>, <Line: -					loopModified.clear(qc.indexOperand());
>, <Line: -					code = new Bytecode.Quantify(qc.startOperand(), qc.endOperand(), qc.indexOperand(), toArray(loopModified),
>, <Line: -							qc.block());
>, <Line: -					block.set(i, code, e.attributes());
>, <Line: -				} else if (code instanceof Bytecode.Loop) {
>, <Line: -					Bytecode.Loop loop = (Bytecode.Loop) code;
>, <Line: -					code = new Bytecode.Loop(toArray(loopModified), loop.block());
>, <Line: -					block.set(i, code, e.attributes());
>, <Line: -				}
>, <Line: -				modified.or(loopModified);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return modified;
>, <Line: -	}
>, <Line: -	protected int[] toArray(BitSet bs) {
>, <Line: -		int[] arr = new int[bs.cardinality()];
>, <Line: -		for (int i = bs.nextSetBit(0), j = 0; i >= 0; i = bs.nextSetBit(i + 1), ++j) {
>, <Line: -			arr[j] = i;
>, <Line: -		}
>, <Line: -		return arr;
>, <Line: -	}
>, <Line: -}
>]