[]
[<Line: -// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
>, <Line: -// All rights reserved.
>, <Line: -//
>, <Line: -// Redistribution and use in source and binary forms, with or without
>, <Line: -// modification, are permitted provided that the following conditions are met:
>, <Line: -//    * Redistributions of source code must retain the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer.
>, <Line: -//    * Redistributions in binary form must reproduce the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer in the
>, <Line: -//      documentation and/or other materials provided with the distribution.
>, <Line: -//    * Neither the name of the <organization> nor the
>, <Line: -//      names of its contributors may be used to endorse or promote products
>, <Line: -//      derived from this software without specific prior written permission.
>, <Line: -//
>, <Line: -// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
>, <Line: -// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
>, <Line: -// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
>, <Line: -// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
>, <Line: -// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
>, <Line: -// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
>, <Line: -// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
>, <Line: -// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
>, <Line: -// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
>, <Line: -// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>, <Line: -package wyil.util.dfa;
>, <Line: -import java.util.ArrayList;
>, <Line: -import java.util.Collections;
>, <Line: -import java.util.HashMap;
>, <Line: -import java.util.List;
>, <Line: -import java.util.Map;
>, <Line: -import wycc.lang.SyntaxError;
>, <Line: -import wycc.util.Pair;
>, <Line: -import wyil.attributes.SourceLocation;
>, <Line: -import wyil.lang.*;
>, <Line: -import wyil.util.*;
>, <Line: -import static wyil.util.ErrorMessages.*;
>, <Line: -public abstract class ForwardFlowAnalysis<T> {
>, <Line: -	/**
>, <Line: -	 * The filename of the module currently being propagated through
>, <Line: -	 */
>, <Line: -	protected String filename;
>, <Line: -	/**
>, <Line: -	 * The function or method currently being propagated through.
>, <Line: -	 */
>, <Line: -	protected WyilFile.FunctionOrMethod method;
>, <Line: -	/**
>, <Line: -	 * The code forest currently being propagated through.
>, <Line: -	 */
>, <Line: -	protected BytecodeForest forest;
>, <Line: -	/**
>, <Line: -	 * The temporary abstract stores being generated during propagation.
>, <Line: -	 */
>, <Line: -	protected HashMap<String, T> stores;
>, <Line: -	public void apply(WyilFile module) {
>, <Line: -		filename = module.filename();
>, <Line: -		for(WyilFile.Block d : module.blocks()) {
>, <Line: -			if(d instanceof WyilFile.Constant) {
>, <Line: -				WyilFile.Constant cd = (WyilFile.Constant) d;
>, <Line: -				module.replace(cd,propagate((cd)));
>, <Line: -			} else if(d instanceof WyilFile.Type) {
>, <Line: -				WyilFile.Type td = (WyilFile.Type) d;
>, <Line: -				module.replace(td,propagate(td));
>, <Line: -			} else if(d instanceof WyilFile.FunctionOrMethod) {
>, <Line: -				WyilFile.FunctionOrMethod md = (WyilFile.FunctionOrMethod) d;
>, <Line: -				if (!md.hasModifier(Modifier.NATIVE)) {
>, <Line: -					// native functions/methods don't have bodies
>, <Line: -					module.replace(md,propagate(md));
>, <Line: -				}
>, <Line: -			}
>, <Line: -		}
>, <Line: -	}
>, <Line: -	protected WyilFile.Constant propagate(WyilFile.Constant constant) {
>, <Line: -		return constant;
>, <Line: -	}
>, <Line: -	protected WyilFile.Type propagate(WyilFile.Type type) {
>, <Line: -		return type;
>, <Line: -	}
>, <Line: -	protected WyilFile.FunctionOrMethod propagate(
>, <Line: -			WyilFile.FunctionOrMethod method) {
>, <Line: -		this.method = method;
>, <Line: -		this.stores = new HashMap<String, T>();
>, <Line: -		this.forest = method.code();
>, <Line: -		T init = initialStore();
>, <Line: -		propagate(method.body(), init);
>, <Line: -		return new WyilFile.FunctionOrMethod(method.modifiers(), method.name(),
>, <Line: -				method.type(), method.code(), method.preconditions().length,
>, <Line: -				method.postconditions().length, method.attributes());
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * Propagate a given store forwards through this bytecode block. A list of
>, <Line: -	 * exception handlers that are active is provided.
>, <Line: -	 *
>, <Line: -	 * @param parentIndex
>, <Line: -	 *            The bytecode index of the bytecode containing this block, or
>, <Line: -	 *            the empty index otherwise.
>, <Line: -	 * @param block
>, <Line: -	 *            The bytecode block to be propagated through.
>, <Line: -	 * @param store
>, <Line: -	 *            The store which holds at the end of this block.
>, <Line: -	 * @param handlers
>, <Line: -	 *            The list of active exception handlers
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected T propagate(int blockID, T store) {
>, <Line: -		BytecodeForest.Block block = forest.get(blockID);
>, <Line: -		for (int i = 0; i < block.size(); ++i) {
>, <Line: -			Bytecode code = block.get(i).code();
>, <Line: -			// Construct the bytecode ID
>, <Line: -			BytecodeForest.Index id = new BytecodeForest.Index(blockID,i);
>, <Line: -			try {
>, <Line: -				// First, check for a label which may have incoming information.
>, <Line: -				if (code instanceof Bytecode.Label) {
>, <Line: -					Bytecode.Label l = (Bytecode.Label) code;
>, <Line: -					T tmp = stores.get(l.label());
>, <Line: -					if (tmp != null && store != null) {
>, <Line: -						store = join(store, tmp);
>, <Line: -					} else if (tmp != null) {
>, <Line: -						store = tmp;
>, <Line: -					}
>, <Line: -				}
>, <Line: -				T oldStore = store;
>, <Line: -				if (store == null) {
>, <Line: -					// this indicates dead-code has been reached.
>, <Line: -					continue;
>, <Line: -				} else if (code instanceof Bytecode.Loop) {
>, <Line: -					Bytecode.Loop loop = (Bytecode.Loop) code;
>, <Line: -					// propagate through the loop body
>, <Line: -					store = propagate(id, loop, store);
>, <Line: -					continue;
>, <Line: -				} else if (code instanceof Bytecode.If) {
>, <Line: -					Bytecode.If ifgoto = (Bytecode.If) code;
>, <Line: -					Pair<T, T> r = propagate(id, ifgoto, store);
>, <Line: -					store = r.second();
>, <Line: -					merge(ifgoto.destination(), r.first(), stores);
>, <Line: -				} else if (code instanceof Bytecode.IfIs) {
>, <Line: -					Bytecode.IfIs ifgoto = (Bytecode.IfIs) code;
>, <Line: -					Pair<T, T> r = propagate(id, ifgoto, store);
>, <Line: -					store = r.second();
>, <Line: -					merge(ifgoto.destination(), r.first(), stores);
>, <Line: -				} else if (code instanceof Bytecode.Switch) {
>, <Line: -					Bytecode.Switch sw = (Bytecode.Switch) code;
>, <Line: -					List<T> r = propagate(id, sw, store);
>, <Line: -					// assert r.second().size() == nsw.branches.size()
>, <Line: -					Bytecode.Switch nsw = (Bytecode.Switch) code;
>, <Line: -					for (int j = 0; j != nsw.branches().size(); ++j) {
>, <Line: -						String target = nsw.branches().get(j).second();
>, <Line: -						T nstore = r.get(j);
>, <Line: -						merge(target, nstore, stores);
>, <Line: -					}
>, <Line: -					merge(sw.defaultTarget(), store, stores);
>, <Line: -					store = null;
>, <Line: -				} else if (code instanceof Bytecode.Goto) {
>, <Line: -					Bytecode.Goto gto = (Bytecode.Goto) code;
>, <Line: -					merge(gto.destination(), store, stores);
>, <Line: -					store = null;
>, <Line: -				} else {
>, <Line: -					// This indicates a sequential statement was encountered.
>, <Line: -					store = propagate(id, code, store);
>, <Line: -					if (code instanceof Bytecode.Return
>, <Line: -							|| code instanceof Bytecode.Fail) {
>, <Line: -						store = null;
>, <Line: -					}
>, <Line: -				}
>, <Line: -			} catch (SyntaxError se) {
>, <Line: -				throw se;
>, <Line: -			} catch (Throwable ex) {
>, <Line: -				internalFailure("internal failure", filename, ex, forest.get(id).attribute(SourceLocation.class));
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return store;
>, <Line: -	}
>, <Line: -	private void merge(String target, T store, Map<String, T> stores) {
>, <Line: -		T old = stores.get(target);
>, <Line: -		if (old == null) {
>, <Line: -			stores.put(target, store);
>, <Line: -		} else {
>, <Line: -			stores.put(target, join(old, store));
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Propagate through a conditional branch. This produces two stores for the
>, <Line: -	 * true and false branches respectively. The code of the statement returned
>, <Line: -	 * is either that of the original statement, a Skip, or a Goto. The latter
>, <Line: -	 * two indicate that the code was proven definitely false, or definitely
>, <Line: -	 * true (respectively).
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param index
>, <Line: -	 *            --- Index of bytecode in root CodeBlock
>, <Line: -	 * @param ifgoto
>, <Line: -	 *            --- the code of this statement
>, <Line: -	 * @param store
>, <Line: -	 *            --- abstract store which holds true immediately before this
>, <Line: -	 *            statement.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract Pair<T,T> propagate(BytecodeForest.Index index, Bytecode.If ifgoto, T store);
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Propagate through a type test. This produces two stores for the true and
>, <Line: -	 * false branches respectively. The code of the statement returned is either
>, <Line: -	 * that of the original statement, a Skip, or a Goto. The latter two
>, <Line: -	 * indicate that the code was proven definitely false, or definitely true
>, <Line: -	 * (respectively).
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param index
>, <Line: -	 *            --- Index of bytecode in root CodeBlock
>, <Line: -	 * @param iftype
>, <Line: -	 *            --- the code of this statement
>, <Line: -	 * @param store
>, <Line: -	 *            --- abstract store which holds true immediately before this
>, <Line: -	 *            statement.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract Pair<T, T> propagate(BytecodeForest.Index index, Bytecode.IfIs iftype, T store);
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Propagate through a multi-way branch. This produces multiple stores ---
>, <Line: -	 * one for each of the various branches.
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param index
>, <Line: -	 *            --- Index of bytecode in root CodeBlock
>, <Line: -	 * @param sw
>, <Line: -	 *            --- the code of this statement
>, <Line: -	 * @param store
>, <Line: -	 *            --- abstract store which holds true immediately before this
>, <Line: -	 *            statement.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract List<T> propagate(BytecodeForest.Index index, Bytecode.Switch sw, T store);
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Propagate through a loop statement, producing a store which holds true
>, <Line: -	 * immediately after the statement
>, <Line: -	 * </p>
>, <Line: -	 * <p>
>, <Line: -	 * <b>NOTE: the <code>start</code> index holds the loop code, whilst the
>, <Line: -	 * <code>end</code> index holds the end code.
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param index
>, <Line: -	 *            --- Index of bytecode in root block
>, <Line: -	 * @param code
>, <Line: -	 *            --- The loop bytecode
>, <Line: -	 * @param entry
>, <Line: -	 *            --- The block entry for the loop statement
>, <Line: -	 * @param store
>, <Line: -	 *            --- Abstract store which holds true immediately before this
>, <Line: -	 *            statement.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract T propagate(BytecodeForest.Index index, Bytecode.Loop code, T store);
>, <Line: -	/**
>, <Line: -	 * <p>
>, <Line: -	 * Propagate through a sequential statement, producing a store which holds
>, <Line: -	 * true immediately after the statement
>, <Line: -	 * </p>
>, <Line: -	 *
>, <Line: -	 * @param index
>, <Line: -	 *            --- Index of bytecode in root CodeBlock
>, <Line: -	 * @param code
>, <Line: -	 *            --- Bytecode in question
>, <Line: -	 * @param store
>, <Line: -	 *            --- Abstract store which holds true immediately before this
>, <Line: -	 *            statement.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract T propagate(BytecodeForest.Index index, Bytecode code, T store);
>, <Line: -	/**
>, <Line: -	 * Determine the initial store for the current method case.
>, <Line: -	 *
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract T initialStore();
>, <Line: -	/**
>, <Line: -	 * Join two abstract stores together producing a new abstract store. Observe
>, <Line: -	 * that this operation must not side-effect the two input stores. This is
>, <Line: -	 * because they may currently be stored in the stores map.
>, <Line: -	 *
>, <Line: -	 * @param store1
>, <Line: -	 * @param store2
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	protected abstract T join(T store1, T store2);
>, <Line: -}
>]