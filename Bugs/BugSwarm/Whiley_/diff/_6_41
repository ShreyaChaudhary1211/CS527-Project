[]
[<Line: -// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
>, <Line: -// All rights reserved.
>, <Line: -//
>, <Line: -// Redistribution and use in source and binary forms, with or without
>, <Line: -// modification, are permitted provided that the following conditions are met:
>, <Line: -//    * Redistributions of source code must retain the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer.
>, <Line: -//    * Redistributions in binary form must reproduce the above copyright
>, <Line: -//      notice, this list of conditions and the following disclaimer in the
>, <Line: -//      documentation and/or other materials provided with the distribution.
>, <Line: -//    * Neither the name of the <organization> nor the
>, <Line: -//      names of its contributors may be used to endorse or promote products
>, <Line: -//      derived from this software without specific prior written permission.
>, <Line: -//
>, <Line: -// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
>, <Line: -// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
>, <Line: -// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
>, <Line: -// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
>, <Line: -// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
>, <Line: -// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
>, <Line: -// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
>, <Line: -// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
>, <Line: -// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
>, <Line: -// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>, <Line: -package wyil.checks;
>, <Line: -import java.util.*;
>, <Line: -import wybs.lang.Builder;
>, <Line: -import wycc.lang.Transform;
>, <Line: -import wycc.util.Pair;
>, <Line: -import wyfs.lang.Path;
>, <Line: -import wyil.util.*;
>, <Line: -import wyil.util.dfa.*;
>, <Line: -import wyil.attributes.SourceLocation;
>, <Line: -import wyil.lang.*;
>, <Line: -import static wycc.lang.SyntaxError.*;
>, <Line: -import static wyil.lang.BytecodeForest.*;
>, <Line: -import static wyil.util.ErrorMessages.*;
>, <Line: -/**
>, <Line: - * <p>
>, <Line: - * The purpose of this class is to check that all variables are defined before
>, <Line: - * being used. For example:
>, <Line: - * </p>
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * function f() => int:
>, <Line: - * 	int z
>, <Line: - * 	return z + 1
>, <Line: - * </pre>
>, <Line: - *
>, <Line: - * <p>
>, <Line: - * In the above example, variable z is used in the return statement before it
>, <Line: - * has been defined any value. This is considered a syntax error in whiley.
>, <Line: - * </p>
>, <Line: - * @author David J. Pearce
>, <Line: - *
>, <Line: - */
>, <Line: -public class DefiniteAssignmentCheck extends
>, <Line: -		ForwardFlowAnalysis<HashSet<Integer>> implements Transform<WyilFile> {
>, <Line: -	/**
>, <Line: -	 * Determines whether constant propagation is enabled or not.
>, <Line: -	 */
>, <Line: -	private boolean enabled = getEnable();
>, <Line: -	public DefiniteAssignmentCheck(Builder builder) {
>, <Line: -	}
>, <Line: -	public static String describeEnable() {
>, <Line: -		return "Enable/disable constant propagation";
>, <Line: -	}
>, <Line: -	public static boolean getEnable() {
>, <Line: -		return true; // default value
>, <Line: -	}
>, <Line: -	public void setEnable(boolean flag) {
>, <Line: -		this.enabled = flag;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public void apply(WyilFile module) {
>, <Line: -		if(enabled) {
>, <Line: -			super.apply(module);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public HashSet<Integer> initialStore() {
>, <Line: -		HashSet<Integer> defined = new HashSet<Integer>();
>, <Line: -		int diff = 0;
>, <Line: -		for(int i=0;i!=method.type().params().size();++i) {
>, <Line: -			defined.add(i+diff);
>, <Line: -		}
>, <Line: -		return defined;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public HashSet<Integer> propagate(BytecodeForest.Index index, Bytecode code, HashSet<Integer> in) {
>, <Line: -		checkUses(index, code, in);
>, <Line: -		int[] defs = defs(code);
>, <Line: -		if (defs.length >= 0) {
>, <Line: -			for (int def : defs) {
>, <Line: -				in = new HashSet<Integer>(in);
>, <Line: -				in.add(def);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return in;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public Pair<HashSet<Integer>, HashSet<Integer>> propagate(BytecodeForest.Index index,
>, <Line: -			Bytecode.If igoto, HashSet<Integer> in) {
>, <Line: -		if (!in.contains(igoto.operand(0))) {
>, <Line: -			syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -					forest.get(index).attribute(SourceLocation.class));
>, <Line: -		}
>, <Line: -		return new Pair(in, in);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public Pair<HashSet<Integer>, HashSet<Integer>> propagate(BytecodeForest.Index index, Bytecode.IfIs iftype,
>, <Line: -			HashSet<Integer> in) {
>, <Line: -		if (!in.contains(iftype.operand(0))) {
>, <Line: -			syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -					forest.get(index).attribute(SourceLocation.class));
>, <Line: -		}
>, <Line: -		return new Pair(in, in);
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public List<HashSet<Integer>> propagate(BytecodeForest.Index index, Bytecode.Switch sw, HashSet<Integer> in) {
>, <Line: -		if (!in.contains(sw.operand(0))) {
>, <Line: -			syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -					forest.get(index).attribute(SourceLocation.class));
>, <Line: -		}
>, <Line: -		ArrayList<HashSet<Integer>> stores = new ArrayList();
>, <Line: -		for (int i = 0; i != sw.branches().size(); ++i) {
>, <Line: -			stores.add(in);
>, <Line: -		}
>, <Line: -		return stores;
>, <Line: -	}
>, <Line: -	@Override
>, <Line: -	public HashSet<Integer> propagate(BytecodeForest.Index index, Bytecode.Loop loop, HashSet<Integer> in) {
>, <Line: -		if (loop instanceof Bytecode.Quantify) {
>, <Line: -			Bytecode.Quantify fall = (Bytecode.Quantify) loop;
>, <Line: -			if (!in.contains(fall.startOperand()) || !in.contains(fall.endOperand())) {
>, <Line: -				syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -						forest.get(index).attribute(SourceLocation.class));
>, <Line: -			}
>, <Line: -			in = new HashSet<Integer>(in);
>, <Line: -			in.add(fall.indexOperand());
>, <Line: -		}
>, <Line: -		HashSet<Integer> r = propagate(loop.block(), in);
>, <Line: -		return join(in, r);
>, <Line: -	}
>, <Line: -	protected HashSet<Integer> join(HashSet<Integer> s1, HashSet<Integer> s2) {
>, <Line: -		HashSet<Integer> r = new HashSet<Integer>();
>, <Line: -		// set intersection
>, <Line: -		for (Integer s : s1) {
>, <Line: -			if (s2.contains(s)) {
>, <Line: -				r.add(s);
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return r;
>, <Line: -	}
>, <Line: -	public void checkUses(BytecodeForest.Index index, Bytecode code, HashSet<Integer> in) {
>, <Line: -		for (int operand : code.operands()) {
>, <Line: -			if (!in.contains(operand)) {
>, <Line: -				syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -						forest.get(index).attribute(SourceLocation.class));
>, <Line: -			}
>, <Line: -		}
>, <Line: -		if (code instanceof Bytecode.Update && !in.contains(code.target(0))) {
>, <Line: -			// In this case, we are assigning to an index or field.
>, <Line: -			// Therefore, the target register must already be defined.
>, <Line: -			syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED), filename,
>, <Line: -					forest.get(index).attribute(SourceLocation.class));
>, <Line: -		}
>, <Line: -	}
>, <Line: -	public int[] defs(Bytecode code) {
>, <Line: -		return code.targets();		
>, <Line: -	}
>, <Line: -}
>]