[<Line: +		sysout.put("print_s", new WyLambda() {
>, <Line: +		sysout.put("println_s", new WyLambda() {
>, <Line: +		sysout.put("print", new WyLambda() {
>, <Line: +		sysout.put("println", new WyLambda() {
>]
[<Line: -	/**
>, <Line: -	 * The <code>instanceOf</code> method implements a runtime type test.
>, <Line: -	 */
>, <Line: -	public static boolean instanceOf(Object obj, WyType t) {
>, <Line: -		switch(t.kind) {
>, <Line: -			case K_ANY:
>, <Line: -				return true;
>, <Line: -			case K_VOID:
>, <Line: -				return false;
>, <Line: -			case K_NULL:
>, <Line: -				return obj == null;
>, <Line: -			case K_BOOL:
>, <Line: -				return obj instanceof WyBool;
>, <Line: -			case K_BYTE:
>, <Line: -				return obj instanceof WyByte;
>, <Line: -			case K_INT:
>, <Line: -				return obj instanceof BigInteger;
>, <Line: -			case K_STRING:
>, <Line: -				return obj instanceof String;
>, <Line: -			case K_REFERENCE: {
>, <Line: -				if(obj instanceof WyObject) {
>, <Line: -					WyObject ol = (WyObject) obj;
>, <Line: -					WyType.Reference ref = (WyType.Reference) t;
>, <Line: -					Object element = ol.state();
>, <Line: -					return instanceOf(element,ref.element);
>, <Line: -				}
>, <Line: -				break;
>, <Line: -			}				
>, <Line: -			case K_LIST:
>, <Line: -			{
>, <Line: -				if(obj instanceof WyArray) {
>, <Line: -					WyArray ol = (WyArray) obj;
>, <Line: -					WyType.List tl = (WyType.List) t;
>, <Line: -					if(tl.nonEmpty && ol.isEmpty()) {
>, <Line: -						return false;
>, <Line: -					}
>, <Line: -					WyType el = tl.element;
>, <Line: -					if(el.kind == K_ANY) {
>, <Line: -						return true;
>, <Line: -					} else if(el.kind == K_VOID) {
>, <Line: -						return ol.isEmpty();
>, <Line: -					} else {
>, <Line: -						for(Object elem : ol) {
>, <Line: -							if(!instanceOf(elem,el)) {
>, <Line: -								return false;
>, <Line: -							}
>, <Line: -						}
>, <Line: -						return true;
>, <Line: -					}
>, <Line: -				}
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case K_RECORD:
>, <Line: -			{
>, <Line: -				if(obj instanceof WyRecord) {
>, <Line: -					WyRecord ol = (WyRecord) obj;
>, <Line: -					WyType.Record tl = (WyType.Record) t;
>, <Line: -					String[] names = tl.names;
>, <Line: -					WyType[] types = tl.types;
>, <Line: -					if(!tl.isOpen && names.length != ol.size()) {
>, <Line: -						return false;
>, <Line: -					}
>, <Line: -					for(int i=0;i!=names.length;++i) {
>, <Line: -						String name = names[i];
>, <Line: -						if(ol.containsKey(name)) {
>, <Line: -							WyType type = types[i];
>, <Line: -							Object val = ol.get(name);
>, <Line: -							if(!instanceOf(val,type)) {
>, <Line: -								return false;
>, <Line: -							}
>, <Line: -						} else {
>, <Line: -							return false;
>, <Line: -						}
>, <Line: -					}
>, <Line: -					return true;
>, <Line: -				}
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case K_NEGATION:
>, <Line: -			{
>, <Line: -				WyType.Negation not = (WyType.Negation) t;
>, <Line: -				return !instanceOf(obj,not.element);
>, <Line: -			}
>, <Line: -			case K_UNION:
>, <Line: -			{
>, <Line: -				WyType.Union un = (WyType.Union) t;
>, <Line: -				for(WyType bound : un.bounds) {
>, <Line: -					if(instanceOf(obj,bound)) {
>, <Line: -						return true;
>, <Line: -					}
>, <Line: -				}
>, <Line: -				break;
>, <Line: -			}
>, <Line: -			case K_FUNCTION:
>, <Line: -			case K_METHOD: {
>, <Line: -				// FIXME: this is fundamentally broken, since it does not consider
>, <Line: -				// the parameter types of the underlying function. See #552
>, <Line: -				return obj instanceof WyLambda;
>, <Line: -			}
>, <Line: -		}
>, <Line: -		return false;
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * This method gets called when we're testing a list object against some
>, <Line: -	 * type. To reduce the number of cases, we can narrow down the possible
>, <Line: -	 * types by a process of deduction. The type cannot be <code>void</code> or
>, <Line: -	 * <code>any</code> (since the test would already have been eliminated).
>, <Line: -	 * Likewise, it cannot be e.g. a record, since again the test would already
>, <Line: -	 * have been eliminated. In fact, the type can only be a list or its
>, <Line: -	 * negation.
>, <Line: -	 *
>, <Line: -	 * @param object
>, <Line: -	 *            --- object being tested against.
>, <Line: -	 * @param type
>, <Line: -	 *            --- type to test against.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public static boolean instanceOf(WyArray object, WyType type) {
>, <Line: -		if(type instanceof WyType.List) {
>, <Line: -			WyType.List tl = (WyType.List) type;
>, <Line: -			WyType el = tl.element;
>, <Line: -			if(el.kind == K_ANY) {
>, <Line: -				return true;
>, <Line: -			} else if(el.kind == K_VOID) {
>, <Line: -				return object.isEmpty();
>, <Line: -			} else {
>, <Line: -				for(Object elem : object) {
>, <Line: -					if(!instanceOf(elem,el)) {
>, <Line: -						return false;
>, <Line: -					}
>, <Line: -				}
>, <Line: -				return true;
>, <Line: -			}
>, <Line: -		} else {
>, <Line: -			return instanceOf((Object)object,type);
>, <Line: -		}
>, <Line: -	}
>, <Line: -	/**
>, <Line: -	 * This method gets called when we're testing a record object against some
>, <Line: -	 * type. To reduce the number of cases, we can narrow down the possible
>, <Line: -	 * types by a process of deduction. The type cannot be <code>void</code> or
>, <Line: -	 * <code>any</code> (since the test would already have been eliminated).
>, <Line: -	 * Likewise, it cannot be e.g. a list, since again the test would already
>, <Line: -	 * have been eliminated. In fact, the type can only be a record or its
>, <Line: -	 * negation.
>, <Line: -	 *
>, <Line: -	 * @param object
>, <Line: -	 *            --- object being tested against.
>, <Line: -	 * @param type
>, <Line: -	 *            --- type to test against.
>, <Line: -	 * @return
>, <Line: -	 */
>, <Line: -	public static boolean instanceOf(WyRecord object, WyType type) {
>, <Line: -		if(type instanceof WyType.Record) {
>, <Line: -			WyType.Record tl = (WyType.Record) type;
>, <Line: -			String[] names = tl.names;
>, <Line: -			WyType[] types = tl.types;
>, <Line: -			if (!tl.isOpen && names.length != object.size()) {
>, <Line: -				return false;
>, <Line: -			}
>, <Line: -			for(int i=0;i!=names.length;++i) {
>, <Line: -				String name = names[i];
>, <Line: -				if(object.containsKey(name)) {
>, <Line: -					WyType fieldType = types[i];
>, <Line: -					Object val = object.get(name);
>, <Line: -					if(!instanceOf(val,fieldType)) {
>, <Line: -						return false;
>, <Line: -					}
>, <Line: -				} else {
>, <Line: -					return false;
>, <Line: -				}
>, <Line: -			}
>, <Line: -			return true;
>, <Line: -		} else {
>, <Line: -			return instanceOf((Object)object,type);
>, <Line: -		}
>, <Line: -	}
>, <Line: -		sysout.put("print_s", new WyLambda((Object[]) null) {
>, <Line: -		sysout.put("println_s", new WyLambda((Object[]) null) {
>, <Line: -		sysout.put("print", new WyLambda((Object[]) null) {
>, <Line: -		sysout.put("println", new WyLambda((Object[]) null) {
>]