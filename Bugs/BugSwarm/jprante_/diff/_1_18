[<Line: +package org.xbib.metrics;
>, <Line: +import com.twitter.jsr166e.LongAdder;
>, <Line: +import java.util.Date;
>, <Line: +import java.util.concurrent.Executors;
>, <Line: +import java.util.concurrent.ScheduledExecutorService;
>, <Line: +import java.util.concurrent.ScheduledFuture;
>, <Line: +import java.util.concurrent.TimeUnit;
>, <Line: +/**
>, <Line: + * A meter metric which measures mean throughput and one-, five-, and
>, <Line: + * fifteen-minute exponentially-weighted moving average throughputs.
>, <Line: + *
>, <Line: + * @see <a href="http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average">EMA</a>
>, <Line: + */
>, <Line: +public class ElasticsearchMeterMetric implements MeterMetric {
>, <Line: +    private final static ScheduledExecutorService service = Executors.newScheduledThreadPool(3);
>, <Line: +    private final ExpWeightedMovingAverage m1Rate = ExpWeightedMovingAverage.oneMinuteEWMA();
>, <Line: +    private final ExpWeightedMovingAverage m5Rate = ExpWeightedMovingAverage.fiveMinuteEWMA();
>, <Line: +    private final ExpWeightedMovingAverage m15Rate = ExpWeightedMovingAverage.fifteenMinuteEWMA();
>, <Line: +    private final LongAdder count;
>, <Line: +    private final long startDate;
>, <Line: +    private final long startTime;
>, <Line: +    private final TimeUnit rateUnit;
>, <Line: +    private final ScheduledFuture<?> future;
>, <Line: +    private long stopDate;
>, <Line: +    private long stopTime;
>, <Line: +    public ElasticsearchMeterMetric(long intervalSeconds, TimeUnit rateUnit) {
>, <Line: +        this.rateUnit = rateUnit;
>, <Line: +        this.count = new LongAdder();
>, <Line: +        this.startDate = System.currentTimeMillis();
>, <Line: +        this.startTime = System.nanoTime();
>, <Line: +        this.future = service.scheduleAtFixedRate(new Runnable() {
>, <Line: +            @Override
>, <Line: +            public void run() {
>, <Line: +                tick();
>, <Line: +            }
>, <Line: +        }, intervalSeconds, intervalSeconds, TimeUnit.SECONDS);
>, <Line: +    }
>, <Line: +    public TimeUnit rateUnit() {
>, <Line: +        return rateUnit;
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Updates the moving averages.
>, <Line: +     */
>, <Line: +    public void tick() {
>, <Line: +        m1Rate.tick();
>, <Line: +        m5Rate.tick();
>, <Line: +        m15Rate.tick();
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Mark the occurrence of an event.
>, <Line: +     */
>, <Line: +    public void mark() {
>, <Line: +        mark(1);
>, <Line: +    }
>, <Line: +    /**
>, <Line: +     * Mark the occurrence of a given number of events.
>, <Line: +     *
>, <Line: +     * @param n the number of events
>, <Line: +     */
>, <Line: +    public void mark(long n) {
>, <Line: +        count.add(n);
>, <Line: +        m1Rate.update(n);
>, <Line: +        m5Rate.update(n);
>, <Line: +        m15Rate.update(n);
>, <Line: +    }
>, <Line: +    public long count() {
>, <Line: +        return count.sum();
>, <Line: +    }
>, <Line: +    public long started() {
>, <Line: +        return startTime;
>, <Line: +    }
>, <Line: +    public Date startedAt() {
>, <Line: +        return new Date(startDate);
>, <Line: +    }
>, <Line: +    public long stopped() {
>, <Line: +        return stopTime;
>, <Line: +    }
>, <Line: +    public Date stoppedAt() {
>, <Line: +        return new Date(stopDate);
>, <Line: +    }
>, <Line: +    public long elapsed() {
>, <Line: +        return System.nanoTime() - startTime;
>, <Line: +    }
>, <Line: +    public double fifteenMinuteRate() {
>, <Line: +        return m15Rate.rate(rateUnit);
>, <Line: +    }
>, <Line: +    public double fiveMinuteRate() {
>, <Line: +        return m5Rate.rate(rateUnit);
>, <Line: +    }
>, <Line: +    public double meanRate() {
>, <Line: +        long count = count();
>, <Line: +        if (count == 0) {
>, <Line: +            return 0.0;
>, <Line: +        } else {
>, <Line: +            final long elapsed = System.nanoTime() - startTime;
>, <Line: +            return convertNsRate(count / (double) elapsed);
>, <Line: +        }
>, <Line: +    }
>, <Line: +    public double oneMinuteRate() {
>, <Line: +        return m1Rate.rate(rateUnit);
>, <Line: +    }
>, <Line: +    public void stop() {
>, <Line: +        this.stopTime = System.nanoTime();
>, <Line: +        this.stopDate = System.currentTimeMillis();
>, <Line: +        future.cancel(false);
>, <Line: +    }
>, <Line: +    private double convertNsRate(double ratePerNs) {
>, <Line: +        return ratePerNs * (double) rateUnit.toNanos(1);
>, <Line: +    }
>, <Line: +}
>]
[]