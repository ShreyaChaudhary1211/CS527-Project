[<Line: +package org.stagemonitor.requestmonitor.reporter;
>, <Line: +import static org.stagemonitor.core.metrics.metrics2.MetricName.name;
>, <Line: +import java.io.ByteArrayOutputStream;
>, <Line: +import java.io.IOException;
>, <Line: +import java.io.OutputStream;
>, <Line: +import java.nio.charset.Charset;
>, <Line: +import java.util.Collection;
>, <Line: +import java.util.Iterator;
>, <Line: +import java.util.List;
>, <Line: +import java.util.concurrent.TimeUnit;
>, <Line: +import com.codahale.metrics.Meter;
>, <Line: +import com.codahale.metrics.Timer;
>, <Line: +import org.slf4j.Logger;
>, <Line: +import org.slf4j.LoggerFactory;
>, <Line: +import org.stagemonitor.core.CorePlugin;
>, <Line: +import org.stagemonitor.core.configuration.Configuration;
>, <Line: +import org.stagemonitor.core.elasticsearch.ElasticsearchClient;
>, <Line: +import org.stagemonitor.core.metrics.MetricUtils;
>, <Line: +import org.stagemonitor.core.metrics.metrics2.MetricName;
>, <Line: +import org.stagemonitor.core.util.HttpClient;
>, <Line: +import org.stagemonitor.core.util.JsonUtils;
>, <Line: +import org.stagemonitor.core.util.StringUtils;
>, <Line: +import org.stagemonitor.requestmonitor.ExternalRequest;
>, <Line: +import org.stagemonitor.requestmonitor.RequestMonitorPlugin;
>, <Line: +/**
>, <Line: + * An implementation of {@link RequestTraceReporter} that reports
>, <Line: + * {@link org.stagemonitor.requestmonitor.RequestTrace#externalRequests} into to <code>stagemonitor-external-requests-*</code>
>, <Line: + * Elasticsearch index
>, <Line: + */
>, <Line: +public class ElasticsearchExternalRequestReporter extends RequestTraceReporter {
>, <Line: +	private static final String ES_EXTERNAL_REQUEST_TRACE_LOGGER = "ElasticsearchExternalRequestTraces";
>, <Line: +	private static final Logger logger = LoggerFactory.getLogger(ElasticsearchExternalRequestReporter.class);
>, <Line: +	private final Logger externalRequestsLogger;
>, <Line: +	private static final byte[] BULK_HEADER = "{\"index\":{}}\n".getBytes(Charset.forName("UTF-8"));
>, <Line: +	private CorePlugin corePlugin;
>, <Line: +	private RequestMonitorPlugin requestMonitorPlugin;
>, <Line: +	private ElasticsearchClient elasticsearchClient;
>, <Line: +	private Meter reportingRate = new Meter();
>, <Line: +	public ElasticsearchExternalRequestReporter() {
>, <Line: +		this(LoggerFactory.getLogger(ES_EXTERNAL_REQUEST_TRACE_LOGGER));
>, <Line: +	}
>, <Line: +	public ElasticsearchExternalRequestReporter(Logger externalRequestsLogger) {
>, <Line: +		this.externalRequestsLogger = externalRequestsLogger;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void init(InitArguments initArguments) {
>, <Line: +		final Configuration configuration = initArguments.getConfiguration();
>, <Line: +		corePlugin = configuration.getConfig(CorePlugin.class);
>, <Line: +		requestMonitorPlugin = configuration.getConfig(RequestMonitorPlugin.class);
>, <Line: +		elasticsearchClient = corePlugin.getElasticsearchClient();
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public void reportRequestTrace(final ReportArguments reportArguments) throws Exception {
>, <Line: +		final List<ExternalRequest> externalRequests = reportArguments.getRequestTrace().getExternalRequests();
>, <Line: +		for (Iterator<ExternalRequest> iterator = externalRequests.iterator(); iterator.hasNext(); ) {
>, <Line: +			final ExternalRequest externalRequest = iterator.next();
>, <Line: +			trackExternalRequestMetrics(externalRequest);
>, <Line: +			if (!isReportExternalRequest(externalRequest)) {
>, <Line: +				iterator.remove();
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (externalRequests.isEmpty()) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		final String index = "stagemonitor-external-requests-" + StringUtils.getLogstashStyleDate();
>, <Line: +		if (!requestMonitorPlugin.isOnlyLogElasticsearchRequestTraceReports()) {
>, <Line: +			elasticsearchClient.sendBulkAsync("/" + index + "/requests", new HttpClient.OutputStreamHandler() {
>, <Line: +				@Override
>, <Line: +				public void withHttpURLConnection(OutputStream os) throws IOException {
>, <Line: +					writeExternalRequestsToOutputStream(os, externalRequests);
>, <Line: +				}
>, <Line: +			});
>, <Line: +		} else {
>, <Line: +			final ByteArrayOutputStream os = new ByteArrayOutputStream();
>, <Line: +			writeExternalRequestsToOutputStream(os, externalRequests);
>, <Line: +			externalRequestsLogger.info(new String(os.toByteArray(), Charset.forName("UTF-8")));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	private void trackExternalRequestMetrics(ExternalRequest externalRequest) {
>, <Line: +		// 0 means the time could not be determined
>, <Line: +		if (externalRequest.getExecutionTimeNanos() <= 0) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		final long duration = externalRequest.getExecutionTimeNanos();
>, <Line: +		corePlugin.getMetricRegistry()
>, <Line: +				.timer(getExternalRequestTimerName(externalRequest, "All"))
>, <Line: +				.update(duration, TimeUnit.NANOSECONDS);
>, <Line: +		if (externalRequest.getExecutedBy() != null) {
>, <Line: +			corePlugin.getMetricRegistry()
>, <Line: +					.timer(getExternalRequestTimerName(externalRequest))
>, <Line: +					.update(duration, TimeUnit.NANOSECONDS);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public static MetricName getExternalRequestTimerName(ExternalRequest externalRequest) {
>, <Line: +		return getExternalRequestTimerName(externalRequest, externalRequest.getExecutedBy());
>, <Line: +	}
>, <Line: +	public static MetricName getExternalRequestTimerName(ExternalRequest externalRequest, String signature) {
>, <Line: +		return name("external_request_response_time")
>, <Line: +				.type(externalRequest.getRequestType())
>, <Line: +				.tag("signature", signature)
>, <Line: +				.tag("method", externalRequest.getRequestMethod()).build();
>, <Line: +	}
>, <Line: +	private void writeExternalRequestsToOutputStream(OutputStream os, Collection<ExternalRequest> externalRequests) throws IOException {
>, <Line: +		for (ExternalRequest externalRequest : externalRequests) {
>, <Line: +			os.write(BULK_HEADER);
>, <Line: +			os.write(JsonUtils.getMapper().writeValueAsBytes(externalRequest));
>, <Line: +			os.write('\n');
>, <Line: +			reportingRate.mark();
>, <Line: +		}
>, <Line: +		os.write('\n');
>, <Line: +		os.close();
>, <Line: +	}
>, <Line: +	private boolean isReportExternalRequest(ExternalRequest externalRequest) {
>, <Line: +		if (externalRequest.getExecutionTime() < requestMonitorPlugin.getExcludeExternalRequestsFasterThan()) {
>, <Line: +			logger.debug("Exclude external request {} because it was faster than {}", externalRequest.getExecutedBy(),
>, <Line: +					requestMonitorPlugin.getExcludeExternalRequestsFasterThan());
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		if (MetricUtils.isRateLimitExceeded(requestMonitorPlugin.getOnlyReportNExternalRequestsPerMinute(), reportingRate)) {
>, <Line: +			logger.debug("Exclude external request {} because would exceed the reporting rate of {}",
>, <Line: +					externalRequest.getExecutedBy(), requestMonitorPlugin.getOnlyReportNExternalRequestsPerMinute());
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		Timer timer = corePlugin.getMetricRegistry().timer(getExternalRequestTimerName(externalRequest));
>, <Line: +		final double percentageThreshold = requestMonitorPlugin.getExcludeExternalRequestsWhenFasterThanXPercent();
>, <Line: +		if (!MetricUtils.isFasterThanXPercentOfAllRequests(externalRequest.getExecutionTimeNanos(), percentageThreshold, timer)) {
>, <Line: +			logger.debug("Exclude external request {} because was faster than {}% of all requests",
>, <Line: +					externalRequest.getExecutedBy(), percentageThreshold * 100);
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean isActive(IsActiveArguments isActiveArguments) {
>, <Line: +		final boolean urlAvailable = !corePlugin.getElasticsearchUrls().isEmpty();
>, <Line: +		final boolean logOnly = requestMonitorPlugin.isOnlyLogElasticsearchRequestTraceReports();
>, <Line: +		return (urlAvailable || logOnly);
>, <Line: +	}
>, <Line: +	@Override
>, <Line: +	public boolean requiresCallTree() {
>, <Line: +		return false;
>, <Line: +	}
>, <Line: +}
>]
[]