[<Line: +import java.util.concurrent.Executors;
>, <Line: +import java.util.concurrent.TimeUnit;
>, <Line: +import org.stagemonitor.core.util.ExecutorUtils;
>, <Line: + * This {@link net.bytebuddy.agent.builder.AgentBuilder.BinaryLocator} caches
>, <Line: + * {@link net.bytebuddy.description.type.TypeDescription}s and clears the cache every minute to avoid memory leaks.
>, <Line: + * Class loader memory leaks are also avoided by using {@link WeakConcurrentMap}.
>, <Line: +public class AutoEvictingCachingBinaryLocator extends AgentBuilder.BinaryLocator.WithTypePoolCache {
>, <Line: +	public AutoEvictingCachingBinaryLocator() {
>, <Line: +	public AutoEvictingCachingBinaryLocator(TypePool.Default.ReaderMode readerMode) {
>, <Line: +		Executors.newScheduledThreadPool(1, new ExecutorUtils.NamedThreadFactory("type-pool-cache-evicter")).scheduleAtFixedRate(new Runnable() {
>, <Line: +			@Override
>, <Line: +			public void run() {
>, <Line: +				cacheProviders.clear();
>, <Line: +				TimedElementMatcherDecorator.logMetrics();
>, <Line: +			}
>, <Line: +		}, 5, 1, TimeUnit.MINUTES);
>, <Line: +		classLoader = classLoader == null ? BootstrapClassLoaderMarker.INSTANCE : classLoader;
>, <Line: +		TypePool.CacheProvider cacheProvider = cacheProviders.get(classLoader);
>, <Line: +		while (cacheProvider == null) {
>, <Line: +			cacheProviders.putIfAbsent(classLoader, new TypePool.CacheProvider.Simple());
>, <Line: +			cacheProvider = cacheProviders.get(classLoader);
>, <Line: +		return cacheProvider;
>]
[<Line: -import java.util.concurrent.atomic.AtomicBoolean;
>, <Line: - * This {@link net.bytebuddy.agent.builder.AgentBuilder.BinaryLocator} is intended to cache
>, <Line: - * {@link net.bytebuddy.description.type.TypeDescription}s only on application startup.
>, <Line: - * After the the majority of the transformations are done (for example after the application has started)
>, <Line: - * one should call {@link #deactivateCaching()} to free memory.
>, <Line: -public class DeactivatableCachingBinaryLocator extends AgentBuilder.BinaryLocator.WithTypePoolCache {
>, <Line: -	private final AtomicBoolean cacheEnabled = new AtomicBoolean(true);
>, <Line: -	public DeactivatableCachingBinaryLocator() {
>, <Line: -	public DeactivatableCachingBinaryLocator(TypePool.Default.ReaderMode readerMode) {
>, <Line: -		if (cacheEnabled.get()) {
>, <Line: -			classLoader = classLoader == null ? BootstrapClassLoaderMarker.INSTANCE : classLoader;
>, <Line: -			TypePool.CacheProvider cacheProvider = cacheProviders.get(classLoader);
>, <Line: -			while (cacheProvider == null) {
>, <Line: -				cacheProviders.putIfAbsent(classLoader, new TypePool.CacheProvider.Simple());
>, <Line: -				cacheProvider = cacheProviders.get(classLoader);
>, <Line: -			}
>, <Line: -			return cacheProvider;
>, <Line: -		} else {
>, <Line: -			return TypePool.CacheProvider.NoOp.INSTANCE;
>, <Line: -	public void deactivateCaching() {
>, <Line: -		cacheEnabled.set(false);
>, <Line: -		cacheProviders.clear();
>, <Line: -	}
>]