[<Line: +import org.stagemonitor.core.instrument.CallerUtil;
>, <Line: +import org.stagemonitor.core.util.CompletedFuture;
>, <Line: +	// TODO remove static keyword. This is currently needed for tests
>, <Line: +		reportRequestTrace(info);
>, <Line: +		trackExternalRequestMetrics(requestName, requestTrace);
>, <Line: +	private <T extends RequestTrace> void trackExternalRequestMetrics(String requestName, T requestTrace) {
>, <Line: +		for (ExternalRequestStats externalRequestStats : requestTrace.getExternalRequestStats()) {
>, <Line: +			if (externalRequestStats.getExecutionTimeNanos() > 0) {
>, <Line: +				if (requestMonitorPlugin.isCollectDbTimePerRequest()) {
>, <Line: +					metricRegistry.timer(name("response_time_server")
>, <Line: +							.tag("request_name", requestName)
>, <Line: +							.layer(externalRequestStats.getRequestType()).build())
>, <Line: +							.update(externalRequestStats.getExecutionTimeNanos(), NANOSECONDS);
>, <Line: +				}
>, <Line: +				metricRegistry.timer(name("response_time_server")
>, <Line: +						.tag("request_name", "All")
>, <Line: +						.layer(externalRequestStats.getRequestType()).build())
>, <Line: +						.update(externalRequestStats.getExecutionTimeNanos(), NANOSECONDS);
>, <Line: +			metricRegistry.meter(name("external_requests_rate")
>, <Line: +					.tag("request_name", requestName)
>, <Line: +					.type(externalRequestStats.getRequestType()).build())
>, <Line: +					.mark(externalRequestStats.getExecutionCount());
>, <Line: +	private <T extends RequestTrace> void reportRequestTrace(final RequestInformation<T> requestInformation) {
>, <Line: +			requestInformation.requestTraceReporterFuture = asyncRequestTraceReporterPool.submit(new Runnable() {
>, <Line: +						if (isActive(requestInformation.getRequestTrace(), requestTraceReporter)) {
>, <Line: +								requestTraceReporter.reportRequestTrace(new RequestTraceReporter.ReportArguments(requestInformation.getRequestTrace()));
>, <Line: +			requestInformation.requestTraceReporterFuture = new CompletedFuture<Object>(null);
>, <Line: +		private Future<?> requestTraceReporterFuture;
>, <Line: +			} else if (!isAnyRequestTraceReporterActiveWhichNeedsTheCallTree(getRequestTrace())) {
>, <Line: +		public Future<?> getRequestTraceReporterFuture() {
>, <Line: +			return requestTraceReporterFuture;
>, <Line: +		}
>, <Line: +	private boolean isAnyRequestTraceReporterActiveWhichNeedsTheCallTree(RequestTrace requestTrace) {
>, <Line: +		for (RequestTraceReporter reporter : requestTraceReporters) {
>, <Line: +			if (reporter.requiresCallTree() && isActive(requestTrace, reporter)) {
>, <Line: +	 * @deprecated use <code>RequestMonitor.get().getRequestTrace()</code> or
>, <Line: +	 * <code>RequestMonitor.get().ifRequestPresent(RequestTraceConsumer)</code>
>, <Line: +	@Deprecated
>, <Line: +		final RequestInformation<? extends RequestTrace> requestInformation = RequestMonitor.get().request.get();
>, <Line: +		return requestInformation != null ? requestInformation.getRequestTrace() : null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @return the {@link RequestTrace} of the current request (may be <code>null</code>)
>, <Line: +	 */
>, <Line: +	public RequestTrace getRequestTrace() {
>, <Line: +	/**
>, <Line: +	 * Allows to modify the {@link RequestTrace} without explicit null checks.
>, <Line: +	 * This method behaves simmilar to {@link java.util.Optional#ifPresent(java.util.function.Consumer)} and only applies the provided
>, <Line: +	 * {@link RequestTraceConsumer} if there is a {@link RequestTrace} bound to the current thread.
>, <Line: +	 * <p/>
>, <Line: +	 * This method works well with lambdas and avoids verbose null checks.
>, <Line: +	 *
>, <Line: +	 * @param consumer a consumer which accepts the current {@link RequestTrace}
>, <Line: +	 */
>, <Line: +	public void ifRequestPresent(RequestTraceConsumer consumer) {
>, <Line: +		final RequestTrace requestTrace = getRequestTrace();
>, <Line: +		if (requestTrace != null) {
>, <Line: +			consumer.accept(requestTrace);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	public interface RequestTraceConsumer {
>, <Line: +		void accept(RequestTrace requestTrace);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Tracking an external request means that a timer for the execution time, grouped by the executing method
>, <Line: +	 * {see @link #getCallerSignature()} is maintained.
>, <Line: +	 * Additionally, the external requests may be stored in the stagemonitor-external-requests-* index, depending
>, <Line: +	 * on the configuration.
>, <Line: +	 *
>, <Line: +	 * @param externalRequest the external request to track
>, <Line: +	 */
>, <Line: +	public void trackExternalRequest(ExternalRequest externalRequest) {
>, <Line: +		final RequestTrace request = getRequestTrace();
>, <Line: +		if (request != null) {
>, <Line: +			externalRequest.setExecutedBy(CallerUtil.getCallerSignature());
>, <Line: +			Profiler.addIOCall(externalRequest.getRequest(), externalRequest.getExecutionTimeNanos());
>, <Line: +			request.addExternalRequest(externalRequest);
>, <Line: +		}
>, <Line: +	}
>, <Line: +		get().addReporter(requestTraceReporter);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Gets the {@link RequestMonitor}.
>, <Line: +	 * <p/>
>, <Line: +	 * You can use this instance for example to call the following methods:
>, <Line: +	 * <ul>
>, <Line: +	 *     <li>{@link #trackExternalRequest(ExternalRequest)}</li>
>, <Line: +	 *     <li>{@link #addReporter(RequestTraceReporter)}</li>
>, <Line: +	 *     <li>{@link #addOnBeforeRequestCallback(Runnable)}</li>
>, <Line: +	 *     <li>{@link #addOnAfterRequestCallback(Runnable)}</li>
>, <Line: +	 *     <li>{@link #getRequestTrace()}</li>
>, <Line: +	 *     <li>{@link #ifRequestPresent(RequestTraceConsumer)}</li>
>, <Line: +	 * </ul>
>, <Line: +	 *
>, <Line: +	 * @return the current request monitor
>, <Line: +	 */
>, <Line: +	public static RequestMonitor get() {
>, <Line: +		return Stagemonitor.getPlugin(RequestMonitorPlugin.class).getRequestMonitor();
>]
[<Line: -import static java.util.concurrent.TimeUnit.MILLISECONDS;
>, <Line: -import org.stagemonitor.core.instrument.AgentAttacher;
>, <Line: -		reportRequestTrace(requestTrace);
>, <Line: -		trackDbMetrics(requestName, requestTrace);
>, <Line: -	private <T extends RequestTrace> void trackDbMetrics(String requestName, T requestTrace) {
>, <Line: -		if (requestTrace.getExecutionCountDb() > 0) {
>, <Line: -			if (requestMonitorPlugin.isCollectDbTimePerRequest()) {
>, <Line: -				metricRegistry.timer(name("response_time_server").tag("request_name", requestName).layer("jdbc").build()).update(requestTrace.getExecutionTimeDb(), MILLISECONDS);
>, <Line: -			metricRegistry.timer(name("response_time_server").tag("request_name", "All").layer("jdbc").build()).update(requestTrace.getExecutionTimeDb(), MILLISECONDS);
>, <Line: -			metricRegistry.meter(name("jdbc_query_rate").tag("request_name", requestName).build()).mark(requestTrace.getExecutionCountDb());
>, <Line: -	private <T extends RequestTrace> void reportRequestTrace(final T requestTrace) {
>, <Line: -			asyncRequestTraceReporterPool.submit(new Runnable() {
>, <Line: -						if (isActive(requestTrace, requestTraceReporter)) {
>, <Line: -								requestTraceReporter.reportRequestTrace(new RequestTraceReporter.ReportArguments(requestTrace));
>, <Line: -			} else if (!isAnyRequestTraceReporterActive(getRequestTrace())) {
>, <Line: -	private boolean isAnyRequestTraceReporterActive(RequestTrace requestTrace) {
>, <Line: -		for (RequestTraceReporter requestTraceReporter : requestTraceReporters) {
>, <Line: -			if (isActive(requestTrace, requestTraceReporter)) {
>, <Line: -		Stagemonitor.getPlugin(RequestMonitorPlugin.class).getRequestMonitor().addReporter(requestTraceReporter);
>]